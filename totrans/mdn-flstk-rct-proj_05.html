<html><head></head><body>
<div id="_idContainer047" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-51"><a id="_idTextAnchor050" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-52" class="calibre5"><a id="_idTextAnchor051" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Implementing a Backend Using Express, Mongoose ODM, and Jest</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">After learning the basics of Node.js and MongoDB, we will now put them into practice by building our first backend service using Express to provide a REST API, Mongoose </span><strong class="bold"><span class="kobospan" id="kobo.4.1">object data modeling</span></strong><span class="kobospan" id="kobo.5.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.6.1">ODM</span></strong><span class="kobospan" id="kobo.7.1">) to</span><a id="_idIndexMarker122" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.8.1"> interface with MongoDB, and Jest to test our code. </span><span class="kobospan" id="kobo.8.2">We will first learn how to structure a backend project using an architectural pattern. </span><span class="kobospan" id="kobo.8.3">Then, we will create database schemas using Mongoose. </span><span class="kobospan" id="kobo.8.4">Next, we will make service functions to interface with the database schemas and write tests for them using Jest. </span><span class="kobospan" id="kobo.8.5">Then, we will learn what REST is and when it is useful. </span><span class="kobospan" id="kobo.8.6">Finally, we provide a REST API and serve it using Express. </span><span class="kobospan" id="kobo.8.7">At the end of this chapter, we will have a working backend service to be consumed by a frontend developed in the </span><span><span class="kobospan" id="kobo.9.1">next chapter.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.10.1">In this chapter, we are going to cover the following </span><span><span class="kobospan" id="kobo.11.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.12.1">Designing a </span><span><span class="kobospan" id="kobo.13.1">backend service</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.14.1">Creating database schemas </span><span><span class="kobospan" id="kobo.15.1">using Mongoose</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.16.1">Developing and testing </span><span><span class="kobospan" id="kobo.17.1">service functions</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.18.1">Providing a REST API </span><span><span class="kobospan" id="kobo.19.1">using Express</span></span></li>
</ul>
<h1 id="_idParaDest-53" class="calibre5"><a id="_idTextAnchor052" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.20.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.21.1">Before we start, please install all requirements from </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.22.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.23.1">, </span><em class="italic"><span class="kobospan" id="kobo.24.1">Preparing for Full-stack Development</span></em><span class="kobospan" id="kobo.25.1">, and </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.26.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.27.1">, </span><em class="italic"><span class="kobospan" id="kobo.28.1">Getting to Know Node.js </span></em><span><em class="italic"><span class="kobospan" id="kobo.29.1">and MongoDB</span></em></span><span><span class="kobospan" id="kobo.30.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.31.1">The versions listed in those chapters are the ones used in the book. </span><span class="kobospan" id="kobo.31.2">While installing a newer version should not be an issue, please note that certain steps might work differently on a newer version. </span><span class="kobospan" id="kobo.31.3">If you are having an issue with the code and steps provided in this book, please try using the versions mentioned in </span><em class="italic"><span class="kobospan" id="kobo.32.1">Chapters 1</span></em> <span><span class="kobospan" id="kobo.33.1">and </span></span><span><em class="italic"><span class="kobospan" id="kobo.34.1">2</span></em></span><span><span class="kobospan" id="kobo.35.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.36.1">You can find the code for this chapter on GitHub </span><span><span class="kobospan" id="kobo.37.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch3" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.38.1">https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch3</span></span></a><span><span class="kobospan" id="kobo.39.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.40.1">If you cloned the full repository for the book, Husky may not find the </span><strong class="source-inline"><span class="kobospan" id="kobo.41.1">.git</span></strong><span class="kobospan" id="kobo.42.1"> directory when running </span><strong class="source-inline"><span class="kobospan" id="kobo.43.1">npm install</span></strong><span class="kobospan" id="kobo.44.1">. </span><span class="kobospan" id="kobo.44.2">In that case, just run </span><strong class="source-inline"><span class="kobospan" id="kobo.45.1">git init</span></strong><span class="kobospan" id="kobo.46.1"> in the root of the corresponding </span><span><span class="kobospan" id="kobo.47.1">chapter folder.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.48.1">The CiA video for the chapter can be found </span><span><span class="kobospan" id="kobo.49.1">at: </span></span><a href="https://youtu.be/fFHVVVn03rc" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.50.1">https://youtu.be/fFHVVVn03rc</span></span></a><span><span class="kobospan" id="kobo.51.1">.</span></span></p>
<h1 id="_idParaDest-54" class="calibre5"><a id="_idTextAnchor053" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.52.1">Designing a backend service</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.53.1">To design </span><a id="_idIndexMarker123" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.54.1">our backend service, we are going to use a variation of an existing architectural pattern </span><a id="_idIndexMarker124" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.55.1">called </span><strong class="bold"><span class="kobospan" id="kobo.56.1">model–view–controller</span></strong><span class="kobospan" id="kobo.57.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.58.1">MVC</span></strong><span class="kobospan" id="kobo.59.1">) pattern. </span><span class="kobospan" id="kobo.59.2">The MVC pattern consists of the </span><span><span class="kobospan" id="kobo.60.1">following parts:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.61.1">Model</span></strong><span class="kobospan" id="kobo.62.1">: Handles</span><a id="_idIndexMarker125" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.63.1"> data and basic </span><span><span class="kobospan" id="kobo.64.1">data logic</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.65.1">Controller</span></strong><span class="kobospan" id="kobo.66.1">: Controls how</span><a id="_idIndexMarker126" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.67.1"> data is processed </span><span><span class="kobospan" id="kobo.68.1">and displayed</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.69.1">View</span></strong><span class="kobospan" id="kobo.70.1">: Displays</span><a id="_idIndexMarker127" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.71.1"> the </span><span><span class="kobospan" id="kobo.72.1">current state</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.73.1">In traditional full-stack applications, the backend would render and display the frontend completely, and an interaction would usually require a full-page refresh. </span><span class="kobospan" id="kobo.73.2">The MVC architecture was designed mainly for such applications. </span><span class="kobospan" id="kobo.73.3">However, in modern applications, the frontend is usually interactive and rendered in the backend only through server-side rendering. </span><span class="kobospan" id="kobo.73.4">In modern applications, we thus often distinguish between the actual backend service(s) and the backend for frontend (which handles static site generation and </span><span><span class="kobospan" id="kobo.74.1">server-side rendering):</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer036">
<span class="kobospan" id="kobo.75.1"><img alt="Figure 3.1 – A modern full-stack architecture, with a single backend service and a frontend with server-side rendering (SSR) and static-site generation (SSG)" src="image/B19385_03_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.76.1">Figure 3.1 – A modern full-stack architecture, with a single backend service and a frontend with server-side rendering (SSR) and static-site generation (SSG)</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.77.1">For modern </span><a id="_idIndexMarker128" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.78.1">applications, the idea is that the backend service only deals with processing and serving requests and data and does not render the user interface anymore. </span><span class="kobospan" id="kobo.78.2">Instead, we have a separate application that handles the frontend and server-side rendering of user interfaces specifically. </span><span class="kobospan" id="kobo.78.3">To adapt to this change, we adjust the MVC architectural pattern to a data-service-route pattern for the backend service </span><span><span class="kobospan" id="kobo.79.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.80.1">Route layer</span></strong><span class="kobospan" id="kobo.81.1">: Defines </span><a id="_idIndexMarker129" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.82.1">routes that consumers can access and handles user input by processing the request parameters and body and then calling </span><span><span class="kobospan" id="kobo.83.1">service functions</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.84.1">Service layer</span></strong><span class="kobospan" id="kobo.85.1">: Provides</span><a id="_idIndexMarker130" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.86.1"> service functions, such as </span><strong class="bold"><span class="kobospan" id="kobo.87.1">create–read–update–delete</span></strong><span class="kobospan" id="kobo.88.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.89.1">CRUD</span></strong><span class="kobospan" id="kobo.90.1">) functions, which</span><a id="_idIndexMarker131" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.91.1"> access the database through the </span><span><span class="kobospan" id="kobo.92.1">data layer</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.93.1">Data layer</span></strong><span class="kobospan" id="kobo.94.1">: Only </span><a id="_idIndexMarker132" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.95.1">deals with accessing the database and does basic validation to ensure that the database </span><span><span class="kobospan" id="kobo.96.1">is consistent</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.97.1">This separation of concerns works best for services that only expose routes and do not deal with rendering user interfaces. </span><span class="kobospan" id="kobo.97.2">Each layer in this pattern only deals with one step in processing </span><span><span class="kobospan" id="kobo.98.1">the request.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.99.1">After learning about the design of backend services, let’s get started creating a folder structure reflecting what we </span><span><span class="kobospan" id="kobo.100.1">have learned.</span></span></p>
<h2 id="_idParaDest-55" class="calibre7"><a id="_idTextAnchor054" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.101.1">Creating the folder structure for our backend service</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.102.1">We are now</span><a id="_idIndexMarker133" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.103.1"> going to create a folder structure for our backend service based on this pattern. </span><span class="kobospan" id="kobo.103.2">Follow </span><span><span class="kobospan" id="kobo.104.1">these steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.105.1">First, copy  the </span><strong class="source-inline1"><span class="kobospan" id="kobo.106.1">ch2</span></strong><span class="kobospan" id="kobo.107.1"> folder to a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.108.1">ch3</span></strong><span class="kobospan" id="kobo.109.1"> folder to create a new folder for our backend service, </span><span><span class="kobospan" id="kobo.110.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.111.1">$ cp -R ch2 ch3</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.112.1">Open the new </span><strong class="source-inline1"><span class="kobospan" id="kobo.113.1">ch3</span></strong><span class="kobospan" id="kobo.114.1"> folder in </span><span><span class="kobospan" id="kobo.115.1">VS Code.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.116.1">Edit the </span><strong class="source-inline1"><span class="kobospan" id="kobo.117.1">.eslintrc.json</span></strong><span class="kobospan" id="kobo.118.1"> file and replace the </span><strong class="source-inline1"><span class="kobospan" id="kobo.119.1">browser</span></strong><span class="kobospan" id="kobo.120.1"> env with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.121.1">node</span></strong><span class="kobospan" id="kobo.122.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.123.1">es6</span></strong><span class="kobospan" id="kobo.124.1"> env, </span><span><span class="kobospan" id="kobo.125.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.126.1">
  "env": {
</span><strong class="bold1"><span class="kobospan1" id="kobo.127.1">    "node": true</span></strong><span class="kobospan1" id="kobo.128.1">,
</span><strong class="bold1"><span class="kobospan1" id="kobo.129.1">    "es6": true</span></strong><span class="kobospan1" id="kobo.130.1">
  },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.131.1">Also, </span><em class="italic"><span class="kobospan" id="kobo.132.1">remove</span></em><span class="kobospan" id="kobo.133.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.134.1">react</span></strong><span class="kobospan" id="kobo.135.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.136.1">jsx-a11y</span></strong><span class="kobospan" id="kobo.137.1"> plugins from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.138.1">.eslintrc.json</span></strong><span class="kobospan" id="kobo.139.1"> file. </span><span class="kobospan" id="kobo.139.2">We can also remove the React</span><span><span class="kobospan" id="kobo.140.1">-</span></span><span class="kobospan" id="kobo.141.1">related </span><strong class="source-inline1"><span class="kobospan" id="kobo.142.1">settings</span></strong><span class="kobospan" id="kobo.143.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.144.1">overrides</span></strong><span class="kobospan" id="kobo.145.1"> now by removing the </span><span><span class="kobospan" id="kobo.146.1">highlighted lines:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.147.1">
  "extends": [
    "eslint:recommended",
</span><strong class="bold1"><span class="kobospan1" id="kobo.148.1">    "plugin:react/recommended",</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.149.1">    "plugin:react/jsx-runtime",</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.150.1">    "plugin:jsx-a11y/recommended",</span></strong><span class="kobospan1" id="kobo.151.1">
    "prettier"
  ]</span><strong class="bold1"><span class="kobospan1" id="kobo.152.1">,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.153.1">  "settings": {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.154.1">    "react": {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.155.1">      "version": "detect"</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.156.1">    }</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.157.1">  },</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.158.1">  "overrides": [</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.159.1">    {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.160.1">      "files": ["*.js", "*.jsx"]</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.161.1">    }</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.162.1">  ]</span></strong></pre></li> <li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.163.1">Delete</span></em><span class="kobospan" id="kobo.164.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.165.1">inde</span><a id="_idTextAnchor055" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.166.1">x.html</span></strong><span class="kobospan" id="kobo.167.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.168.1">vite.config.js</span></strong></span><span><span class="kobospan" id="kobo.169.1"> files.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.170.1">We can now also </span><em class="italic"><span class="kobospan" id="kobo.171.1">remove</span></em><span class="kobospan" id="kobo.172.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.173.1">vite.config.js</span></strong><span class="kobospan" id="kobo.174.1"> file from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.175.1">.</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.176.1">eslintignore</span></strong></span><span><span class="kobospan" id="kobo.177.1"> file:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.178.1">
dist/
</span><strong class="bold1"><span class="kobospan1" id="kobo.179.1">vite.config.js</span></strong></pre></li> <li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.180.1">Delete</span></em><span class="kobospan" id="kobo.181.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.182.1">public</span></strong><span class="kobospan" id="kobo.183.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.184.1">backend</span></strong><span class="kobospan" id="kobo.185.1">, and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.186.1">src</span></strong></span><span><span class="kobospan" id="kobo.187.1"> folders.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.188.1">Open the </span><strong class="source-inline1"><span class="kobospan" id="kobo.189.1">ch3</span></strong><span class="kobospan" id="kobo.190.1"> folder in VS Code, open a Terminal and run the</span><a id="_idTextAnchor056" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.191.1"> following commands to remove </span><strong class="source-inline1"><span class="kobospan" id="kobo.192.1">vite</span></strong> <span><span class="kobospan" id="kobo.193.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.194.1">react</span></strong></span><span><span class="kobospan" id="kobo.195.1">:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.196.1">$ npm uninstall --save react react-dom</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.197.1">$ npm uninstall --save-dev vite @types/react \</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.198.1">  @types/react-dom @vitejs/plugin-react \</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.199.1">  eslint-plugin-jsx-a11y eslint-plugin-react</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.200.1">Edit</span><a id="_idIndexMarker134" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.201.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.202.1">package.json</span></strong><span class="kobospan" id="kobo.203.1"> file and </span><em class="italic"><span class="kobospan" id="kobo.204.1">remove</span></em><span class="kobospan" id="kobo.205.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.206.1">dev</span></strong><span class="kobospan" id="kobo.207.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.208.1">build</span></strong><span class="kobospan" id="kobo.209.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.210.1">preview</span></strong><span class="kobospan" id="kobo.211.1"> scripts </span><span><span class="kobospan" id="kobo.212.1">from it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.213.1">
  "scripts": {
</span><strong class="bold1"><span class="kobospan1" id="kobo.214.1">    "dev": "vite",</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.215.1">    "build": "vite build",</span></strong><span class="kobospan1" id="kobo.216.1">
    "lint": "eslint src",
</span><strong class="bold1"><span class="kobospan1" id="kobo.217.1">    "preview": "vite preview",</span></strong><span class="kobospan1" id="kobo.218.1">
    "prepare": "husky install"
  },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.219.1">Now, create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.220.1">src/</span></strong><span class="kobospan" id="kobo.221.1"> folder, and within it, create </span><strong class="source-inline1"><span class="kobospan" id="kobo.222.1">src/db/</span></strong><span class="kobospan" id="kobo.223.1"> (for the data layer), </span><strong class="source-inline1"><span class="kobospan" id="kobo.224.1">src/services/</span></strong><span class="kobospan" id="kobo.225.1"> (for the services layer), and </span><strong class="source-inline1"><span class="kobospan" id="kobo.226.1">src/routes/</span></strong><span class="kobospan" id="kobo.227.1"> (for the routes </span><span><span class="kobospan" id="kobo.228.1">layer) folders.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.229.1">Our first application is going to be a blog application. </span><span class="kobospan" id="kobo.229.2">For such an application, we are going to need the API to be able to do </span><span><span class="kobospan" id="kobo.230.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.231.1">Get a list </span><span><span class="kobospan" id="kobo.232.1">of posts</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.233.1">Get a </span><span><span class="kobospan" id="kobo.234.1">single post</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.235.1">Create a </span><span><span class="kobospan" id="kobo.236.1">new post</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.237.1">Update an </span><span><span class="kobospan" id="kobo.238.1">existing post</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.239.1">Delete an </span><span><span class="kobospan" id="kobo.240.1">existing post</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.241.1">To provide </span><a id="_idIndexMarker135" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.242.1">these functions, we first need to create a database schema to define what a blog post object should look like in our database. </span><span class="kobospan" id="kobo.242.2">Then, we need service functions to handle CRUD functionality for blog posts. </span><span class="kobospan" id="kobo.242.3">Finally, we are going to define our REST API to query, create, update, and delete </span><span><span class="kobospan" id="kobo.243.1">blog posts.</span></span></p>
<h1 id="_idParaDest-56" class="calibre5"><a id="_idTextAnchor057" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.244.1">Creating database schemas using Mongoose</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.245.1">Before we can get started defining the database schemas, we first need to set up Mongoose itself. </span><span class="kobospan" id="kobo.245.2">Mongoose</span><a id="_idIndexMarker136" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.246.1"> is a library that simplifies MongoDB object modeling by reducing the boilerplate code needed to interface with MongoDB. </span><span class="kobospan" id="kobo.246.2">It also includes common business logic such as setting </span><strong class="source-inline"><span class="kobospan" id="kobo.247.1">createdAt</span></strong><span class="kobospan" id="kobo.248.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.249.1">updatedAt</span></strong><span class="kobospan" id="kobo.250.1"> timestamps automatically and validation and type casting to keep the database </span><span><span class="kobospan" id="kobo.251.1">state consistent.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.252.1">Follow these steps to set up </span><a id="_idIndexMarker137" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.253.1">the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.254.1">mongoose</span></strong></span><span><span class="kobospan" id="kobo.255.1"> library:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.256.1">First, install the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.257.1">mongoose</span></strong></span><span><span class="kobospan" id="kobo.258.1"> library:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.259.1">$ npm install mongoose@8.0.2</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.260.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.261.1">src/db/init.js</span></strong><span class="kobospan" id="kobo.262.1"> file and import </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.263.1">mongoose</span></strong></span><span><span class="kobospan" id="kobo.264.1"> there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.265.1">
import mongoose from 'mongoose'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.266.1">Define and export a function that will initialize the </span><span><span class="kobospan" id="kobo.267.1">database connection:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.268.1">
export function initDatabase() {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.269.1">First, we define </span><strong class="source-inline1"><span class="kobospan" id="kobo.270.1">DATABASE_URL</span></strong><span class="kobospan" id="kobo.271.1"> to point to our local MongoDB instance running via Docker and specify </span><strong class="source-inline1"><span class="kobospan" id="kobo.272.1">blog</span></strong><span class="kobospan" id="kobo.273.1"> as the </span><span><span class="kobospan" id="kobo.274.1">database name:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.275.1">
  const DATABASE_URL = 'mongodb://localhost:27017/blog'</span></pre><p class="calibre3"><span class="kobospan" id="kobo.276.1">The connection string is similar to what we used in the previous chapter when directly accessing the database </span><span><span class="kobospan" id="kobo.277.1">via Node.js.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.278.1">Then, add a listener to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.279.1">open</span></strong><span class="kobospan" id="kobo.280.1"> event on the Mongoose connection so that we can show a log message once we are connected to </span><span><span class="kobospan" id="kobo.281.1">the database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.282.1">
  mongoose.connection.on('open', () =&gt; {
    console.info('successfully connected to database:', DATABASE_URL)
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.283.1">Now, use</span><a id="_idIndexMarker138" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.284.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.285.1">mongoose.connect()</span></strong><span class="kobospan" id="kobo.286.1"> function to connect to our MongoDB database and return the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.287.1">connection</span></strong></span><span><span class="kobospan" id="kobo.288.1"> object:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.289.1">
  const connection = mongoose.connect(DATABASE_URL)
  return connection
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.290.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.291.1">src/example.js</span></strong><span class="kobospan" id="kobo.292.1"> file and import and run the </span><strong class="source-inline1"><span class="kobospan" id="kobo.293.1">initDatabase</span></strong> <span><span class="kobospan" id="kobo.294.1">function there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.295.1">
import { initDatabase } from './db/init.js'
initDatabase()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.296.1">Run the </span><strong class="source-inline1"><span class="kobospan" id="kobo.297.1">src/example.js</span></strong><span class="kobospan" id="kobo.298.1"> file using Node.js to see Mongoose successfully connecting to </span><span><span class="kobospan" id="kobo.299.1">our database:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.300.1">$ node src/example.js</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.301.1">As always, you</span><a id="_idIndexMarker139" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.302.1"> can stop the server by pressing </span><em class="italic"><span class="kobospan" id="kobo.303.1">Ctrl</span></em><span class="kobospan" id="kobo.304.1"> + </span><em class="italic"><span class="kobospan" id="kobo.305.1">C</span></em><span class="kobospan" id="kobo.306.1"> in </span><span><span class="kobospan" id="kobo.307.1">the Terminal.</span></span></p></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.308.1">We can see our log message being printed to the Terminal, so we know that Mongoose was able to successfully connect to our database! </span><span class="kobospan" id="kobo.308.2">If there is an error, for example, because Docker (or the container) is not running, it will hang for a while and then throw an error about the connection being refused (</span><strong class="source-inline"><span class="kobospan" id="kobo.309.1">ECONNREFUSED</span></strong><span class="kobospan" id="kobo.310.1">). </span><span class="kobospan" id="kobo.310.2">In that case, make sure the Docker MongoDB container is running properly and can be </span><span><span class="kobospan" id="kobo.311.1">connected to.</span></span></p>
<h2 id="_idParaDest-57" class="calibre7"><a id="_idTextAnchor058" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.312.1">Defining a model for blog posts</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.313.1">After initializing the </span><a id="_idIndexMarker140" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.314.1">database, the first thing we should do is define the data</span><a id="_idIndexMarker141" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.315.1"> structure for blog posts. </span><span class="kobospan" id="kobo.315.2">Blog posts in our system should have a title, an author, contents, and some tags associated with the post. </span><span class="kobospan" id="kobo.315.3">Follow these steps to define the data structure for </span><span><span class="kobospan" id="kobo.316.1">blog posts:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.317.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.318.1">src/db/models/</span></strong></span><span><span class="kobospan" id="kobo.319.1"> folder.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.320.1">Inside that folder, create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.321.1">src/db/models/post.js</span></strong><span class="kobospan" id="kobo.322.1"> file, import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.323.1">mongoose</span></strong><span class="kobospan" id="kobo.324.1"> and the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.325.1">Schema</span></strong></span><span><span class="kobospan" id="kobo.326.1"> classes:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.327.1">
import mongoose, { Schema } from 'mongoose'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.328.1">Define a new schema </span><span><span class="kobospan" id="kobo.329.1">for posts:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.330.1">
const postSchema = new Schema({</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.331.1">Now specify all properties of a blog post and the corresponding types. </span><span class="kobospan" id="kobo.331.2">We have a required </span><strong class="source-inline1"><span class="kobospan" id="kobo.332.1">title</span></strong><span class="kobospan" id="kobo.333.1">, an </span><strong class="source-inline1"><span class="kobospan" id="kobo.334.1">author</span></strong><span class="kobospan" id="kobo.335.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.336.1">contents</span></strong><span class="kobospan" id="kobo.337.1">, which are </span><span><span class="kobospan" id="kobo.338.1">all strings:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.339.1">
  title: { type: String, required: true },
  author: String,
  contents: String,</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.340.1">Lastly, we have </span><strong class="source-inline1"><span class="kobospan" id="kobo.341.1">tags</span></strong><span class="kobospan" id="kobo.342.1">, which are a </span><span><span class="kobospan" id="kobo.343.1">string array:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.344.1">
  tags: [String],
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.345.1">Now that we</span><a id="_idIndexMarker142" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.346.1"> have defined the schema, we can create a </span><a id="_idIndexMarker143" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.347.1">Mongoose model from it by using the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.348.1">mongoose.model()</span></strong></span><span><span class="kobospan" id="kobo.349.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.350.1">
export const Post = mongoose.model('post', postSchema)</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.351.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.352.1">The first argument to </span><strong class="source-inline1"><span class="kobospan" id="kobo.353.1">mongoose.model()</span></strong><span class="kobospan" id="kobo.354.1"> specifies the name of the collection. </span><span class="kobospan" id="kobo.354.2">In our case, the collection will be called </span><strong class="source-inline1"><span class="kobospan" id="kobo.355.1">posts</span></strong><span class="kobospan" id="kobo.356.1"> because we specified </span><strong class="source-inline1"><span class="kobospan" id="kobo.357.1">post</span></strong><span class="kobospan" id="kobo.358.1"> as the name. </span><span class="kobospan" id="kobo.358.2">In Mongoose models, we need to specify the name of the document in </span><span><span class="kobospan" id="kobo.359.1">singular form.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.360.1">Now that we have defined the data structure and model for blog posts, we can start using it to create and </span><span><span class="kobospan" id="kobo.361.1">query posts.</span></span></p>
<h2 id="_idParaDest-58" class="calibre7"><a id="_idTextAnchor059" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.362.1">Using the blog post model</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.363.1">After creating our model, let’s try </span><a id="_idIndexMarker144" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.364.1">using it! </span><span class="kobospan" id="kobo.364.2">For now, we are simply going to access it in the </span><strong class="source-inline"><span class="kobospan" id="kobo.365.1">src/example.js</span></strong><span class="kobospan" id="kobo.366.1"> file because we have not defined any service functions or </span><span><span class="kobospan" id="kobo.367.1">routes yet:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.368.1">Import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.369.1">Post</span></strong><span class="kobospan" id="kobo.370.1"> model in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.371.1">src/example.js</span></strong></span><span><span class="kobospan" id="kobo.372.1"> file:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.373.1">
import { initDatabase } from './db/init.js'
</span><strong class="bold1"><span class="kobospan1" id="kobo.374.1">import { Post } from './db/models/post.js'</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.375.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.376.1">initDatabase()</span></strong><span class="kobospan" id="kobo.377.1"> function we defined earlier is an </span><strong class="source-inline1"><span class="kobospan" id="kobo.378.1">async</span></strong><span class="kobospan" id="kobo.379.1"> function, so we need to </span><strong class="source-inline1"><span class="kobospan" id="kobo.380.1">await</span></strong><span class="kobospan" id="kobo.381.1"> it; otherwise, we would be attempting to access the database before we are connected </span><span><span class="kobospan" id="kobo.382.1">to it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.383.1">
await initDatabase()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.384.1">Create a new blog post by calling </span><strong class="source-inline1"><span class="kobospan" id="kobo.385.1">new Post()</span></strong><span class="kobospan" id="kobo.386.1">, defining some </span><span><span class="kobospan" id="kobo.387.1">example data:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.388.1">
const post = new Post({
  title: 'Hello Mongoose!',
  author: 'Daniel Bugl',
  contents: 'This post is stored in a MongoDB database using Mongoose.',
  tags: ['mongoose', 'mongodb'],
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.389.1">Call </span><strong class="source-inline1"><span class="kobospan" id="kobo.390.1">.save()</span></strong><span class="kobospan" id="kobo.391.1"> on the blog post to save it to </span><span><span class="kobospan" id="kobo.392.1">the database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.393.1">
await post.save()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.394.1">Now we can use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.395.1">.find()</span></strong><span class="kobospan" id="kobo.396.1"> function to list all posts, and log </span><span><span class="kobospan" id="kobo.397.1">the result:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.398.1">
const posts = await Post.find()
console.log(posts)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.399.1">Run the example </span><a id="_idIndexMarker145" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.400.1">script to see our post being inserted </span><span><span class="kobospan" id="kobo.401.1">and listed:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.402.1">$ node src/example.js</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.403.1">You will get the following result after running the </span><span><span class="kobospan" id="kobo.404.1">preceding script:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer037">
<span class="kobospan" id="kobo.405.1"><img alt="Figure 3.2 – Our first document inserted via Mongoose!" src="image/B19385_03_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.406.1">Figure 3.2 – Our first document inserted via Mongoose!</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.407.1">As you can see, using Mongoose is very similar to using MongoDB directly. </span><span class="kobospan" id="kobo.407.2">However, it offers us some wrappers around models for convenience, making it easier to deal </span><span><span class="kobospan" id="kobo.408.1">with documents.</span></span></p>
<h2 id="_idParaDest-59" class="calibre7"><a id="_idTextAnchor060" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.409.1">Defining creation and last update dates in the blog post</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.410.1">You may have noticed </span><a id="_idIndexMarker146" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.411.1">that we have not added any dates to our blog post. </span><span class="kobospan" id="kobo.411.2">So, we do not know when a blog post is created or when it was last updated. </span><span class="kobospan" id="kobo.411.3">Mongoose makes implementing such functionality simple, let’s try it </span><span><span class="kobospan" id="kobo.412.1">out now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.413.1">Edit the </span><strong class="source-inline1"><span class="kobospan" id="kobo.414.1">src/db/models/post.js</span></strong><span class="kobospan" id="kobo.415.1"> file and add a second argument to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.416.1">new Schema()</span></strong><span class="kobospan" id="kobo.417.1"> constructor. </span><span class="kobospan" id="kobo.417.2">The second argument specifies options for the schema. </span><span class="kobospan" id="kobo.417.3">Here, we set the </span><strong class="source-inline1"><span class="kobospan" id="kobo.418.1">timestamps: </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.419.1">true</span></strong></span><span><span class="kobospan" id="kobo.420.1"> setting:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.421.1">
const postSchema = new Schema(
  {
    title: String,
    author: String,
    contents: String,
    tags: [String],
  },
  </span><strong class="bold1"><span class="kobospan1" id="kobo.422.1">{ timestamps: true },</span></strong><span class="kobospan1" id="kobo.423.1">
)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.424.1">Now all we need to do is create a new blog post by running the example script, and we will see that the last post inserted now has </span><strong class="source-inline1"><span class="kobospan" id="kobo.425.1">createdAt</span></strong><span class="kobospan" id="kobo.426.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.427.1">updatedAt</span></strong></span><span><span class="kobospan" id="kobo.428.1"> timestamps:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.429.1">$ node src/example.js</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.430.1">To see if the </span><strong class="source-inline1"><span class="kobospan" id="kobo.431.1">updatedAt</span></strong><span class="kobospan" id="kobo.432.1"> timestamp works, let’s try updating the created blog post by using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.433.1">findByIdAndUpdate</span></strong><span class="kobospan" id="kobo.434.1"> method. </span><span class="kobospan" id="kobo.434.2">Save the result of </span><strong class="source-inline1"><span class="kobospan" id="kobo.435.1">await post.save()</span></strong><span class="kobospan" id="kobo.436.1"> in a </span><strong class="source-inline1"><span class="kobospan" id="kobo.437.1">createdPost</span></strong><span class="kobospan" id="kobo.438.1"> constant, then add the following code close to the end of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.439.1">src/example.js</span></strong><span class="kobospan" id="kobo.440.1"> file, before the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.441.1">Post.find()</span></strong></span><span><span class="kobospan" id="kobo.442.1"> call:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.443.1">const createdPost =</span></strong><span class="kobospan1" id="kobo.444.1"> await post.save()
</span><strong class="bold1"><span class="kobospan1" id="kobo.445.1">await Post.findByIdAndUpdate(createdPost._id, {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.446.1">  $set: { title: 'Hello again, Mongoose!' </span><span class="kobospan1" id="kobo.446.2">},</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.447.1">})</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.448.1">Run the server again to see the blog posts </span><span><span class="kobospan" id="kobo.449.1">being updated:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.450.1">$ node src/example.js</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.451.1">You will get</span><a id="_idIndexMarker147" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.452.1"> three posts, and the last one of them now looks </span><span><span class="kobospan" id="kobo.453.1">as follows:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer038">
<span class="kobospan" id="kobo.454.1"><img alt="Figure 3.3 – Our updated document with the automatically updated timestamps" src="image/B19385_03_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.455.1">Figure 3.3 – Our updated document with the automatically updated timestamps</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.456.1">As we can see, using Mongoose makes dealing with MongoDB documents much more convenient! </span><span class="kobospan" id="kobo.456.2">Now that we have defined our database model, let’s start developing (and writing tests for) </span><span><span class="kobospan" id="kobo.457.1">service functions!</span></span></p>
<h1 id="_idParaDest-60" class="calibre5"><a id="_idTextAnchor061" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.458.1">Developing and testing service functions</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.459.1">Up until now, we have always been testing code by putting it in the </span><strong class="source-inline"><span class="kobospan" id="kobo.460.1">src/example.js</span></strong><span class="kobospan" id="kobo.461.1"> file. </span><span class="kobospan" id="kobo.461.2">Now, we are going to write some service functions and learn how to write actual tests for them by </span><span><span class="kobospan" id="kobo.462.1">using Jest.</span></span></p>
<h2 id="_idParaDest-61" class="calibre7"><a id="_idTextAnchor062" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.463.1">Setting up the test environment</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.464.1">First, we are going to set up our </span><a id="_idIndexMarker148" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.465.1">test environment by following </span><span><span class="kobospan" id="kobo.466.1">these steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.467.1">Install </span><strong class="source-inline1"><span class="kobospan" id="kobo.468.1">jest</span></strong><span class="kobospan" id="kobo.469.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.470.1">mongodb-memory-server</span></strong><span class="kobospan" id="kobo.471.1"> as </span><span><span class="kobospan" id="kobo.472.1">dev dependencies:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.473.1">$ npm install --save-dev jest@29.7.0 \</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.474.1">  mongodb-memory-server@9.1.1</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.475.1">Jest is a test runner used to define and execute unit tests. </span><span class="kobospan" id="kobo.475.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.476.1">mongodb-memory-server</span></strong><span class="kobospan" id="kobo.477.1"> library allows us to spin up a fresh instance of a MongoDB database, storing data only in memory, so that we can run our tests on a fresh </span><span><span class="kobospan" id="kobo.478.1">database instance.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.479.1">Create a </span><strong class="source-inline1"><span class="kobospan" id="kobo.480.1">src/test/</span></strong><span class="kobospan" id="kobo.481.1"> folder to put the setup for our </span><span><span class="kobospan" id="kobo.482.1">tests in.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.483.1">In this folder, create a </span><strong class="source-inline1"><span class="kobospan" id="kobo.484.1">src/test/globalSetup.js</span></strong><span class="kobospan" id="kobo.485.1"> file, where we will import </span><strong class="source-inline1"><span class="kobospan" id="kobo.486.1">MongoMemoryServer</span></strong><span class="kobospan" id="kobo.487.1"> from the previously </span><span><span class="kobospan" id="kobo.488.1">installed library:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.489.1">
import { MongoMemoryServer } from 'mongodb-memory-server'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.490.1">Now define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.491.1">globalSetup</span></strong><span class="kobospan" id="kobo.492.1"> function, which creates a memory server </span><span><span class="kobospan" id="kobo.493.1">for MongoDB:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.494.1">
export default async function globalSetup() {
  const instance = await MongoMemoryServer.create({</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.495.1">When creating</span><a id="_idIndexMarker149" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.496.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.497.1">MongoMemoryServer</span></strong><span class="kobospan" id="kobo.498.1">, set the binary version to </span><strong class="source-inline1"><span class="kobospan" id="kobo.499.1">6.0.4</span></strong><span class="kobospan" id="kobo.500.1">, which is the same version that we installed for our </span><span><span class="kobospan" id="kobo.501.1">Docker container:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.502.1">
    binary: {
      version: '6.0.4',
    },
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.503.1">We will store the MongoDB instance as a global variable to be able to access it later in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.504.1">globalTeardown</span></strong></span><span><span class="kobospan" id="kobo.505.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.506.1">
  global.__MONGOINSTANCE = instance</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.507.1">We will also store the URL to connect to our test instance in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.508.1">DATABASE_URL</span></strong> <span><span class="kobospan" id="kobo.509.1">environment variable:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.510.1">
  process.env.DATABASE_URL = instance.getUri()
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.511.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.512.1">src/db/init.js</span></strong><span class="kobospan" id="kobo.513.1"> and adjust the </span><strong class="source-inline1"><span class="kobospan" id="kobo.514.1">DATABASE_URL</span></strong><span class="kobospan" id="kobo.515.1"> to come from the environment variable so that our tests will be using the </span><span><span class="kobospan" id="kobo.516.1">correct database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.517.1">
export function initDatabase() {
  const DATABASE_URL = </span><strong class="bold1"><span class="kobospan1" id="kobo.518.1">process.env.DATABASE_URL</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.519.1">Additionally, create a </span><strong class="source-inline1"><span class="kobospan" id="kobo.520.1">src/test/globalTeardown.js</span></strong><span class="kobospan" id="kobo.521.1"> file to stop the MongoDB instance when our tests are finished and add the following code </span><span><span class="kobospan" id="kobo.522.1">inside it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.523.1">
export default async function globalTeardown() {
  await global.__MONGOINSTANCE.stop()
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.524.1">Now, create a </span><strong class="source-inline1"><span class="kobospan" id="kobo.525.1">src/test/setupFileAfterEnv.js</span></strong><span class="kobospan" id="kobo.526.1"> file. </span><span class="kobospan" id="kobo.526.2">Here, we will define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.527.1">beforeAll</span></strong><span class="kobospan" id="kobo.528.1"> function to initialize our database connection in Mongoose before all tests run and an </span><strong class="source-inline1"><span class="kobospan" id="kobo.529.1">afterAll</span></strong><span class="kobospan" id="kobo.530.1"> function to disconnect from the database </span><a id="_idIndexMarker150" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.531.1">after all tests </span><span><span class="kobospan" id="kobo.532.1">finish running:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.533.1">
import mongoose from 'mongoose'
import { beforeAll, afterAll } from '@jest/globals'
import { initDatabase } from '../db/init.js'
beforeAll(async () =&gt; {
  await initDatabase()
})
afterAll(async () =&gt; {
  await mongoose.disconnect()
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.534.1">Then, create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.535.1">jest.config.json</span></strong><span class="kobospan" id="kobo.536.1"> file in the root of our project where we will define the config for our tests. </span><span class="kobospan" id="kobo.536.2">In the </span><strong class="source-inline1"><span class="kobospan" id="kobo.537.1">jest.config.json</span></strong><span class="kobospan" id="kobo.538.1"> file, we first set the test environment </span><span><span class="kobospan" id="kobo.539.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.540.1">node</span></strong></span><span><span class="kobospan" id="kobo.541.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.542.1">
{
  "testEnvironment": "node",</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.543.1">Next, tell</span><a id="_idIndexMarker151" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.544.1"> Jest to use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.545.1">globalSetup</span></strong><span class="kobospan" id="kobo.546.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.547.1">globalTeardown</span></strong><span class="kobospan" id="kobo.548.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.549.1">setupFileAfterEnv</span></strong><span class="kobospan" id="kobo.550.1"> files we </span><span><span class="kobospan" id="kobo.551.1">created earlier:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.552.1">
  "globalSetup": "&lt;rootDir&gt;/src/test/globalSetup.js",
  "globalTeardown": "&lt;rootDir&gt;/src/test/globalTeardown.js",
  "setupFilesAfterEnv": ["&lt;rootDir&gt;/src/test/setupFileAfterEnv.js"]
}</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.553.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.554.1">In this case, </span><strong class="source-inline1"><span class="kobospan" id="kobo.555.1">&lt;rootDir&gt;</span></strong><span class="kobospan" id="kobo.556.1"> is a special string that automatically gets resolved to the root directory by Jest. </span><span class="kobospan" id="kobo.556.2">You do not need to manually fill in a root </span><span><span class="kobospan" id="kobo.557.1">directory here.</span></span></p>
<ol class="calibre15">
<li value="13" class="calibre11"><span class="kobospan" id="kobo.558.1">Finally, edit the </span><strong class="source-inline1"><span class="kobospan" id="kobo.559.1">package.json</span></strong><span class="kobospan" id="kobo.560.1"> file and add a </span><strong class="source-inline1"><span class="kobospan" id="kobo.561.1">test</span></strong><span class="kobospan" id="kobo.562.1"> script, which will </span><span><span class="kobospan" id="kobo.563.1">run Jest:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.564.1">
  "scripts": {
</span><strong class="bold1"><span class="kobospan1" id="kobo.565.1">    "test": "NODE_OPTIONS=--experimental-vm-modules jest",</span></strong><span class="kobospan1" id="kobo.566.1">
    "lint": "eslint src",
    "prepare": "husky install"
  },</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.567.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.568.1">At the time of writing, the JavaScript </span><a id="_idIndexMarker152" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.569.1">ecosystem is still in the process of moving to the </span><strong class="bold"><span class="kobospan" id="kobo.570.1">ECMAScript module</span></strong><span class="kobospan" id="kobo.571.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.572.1">ESM</span></strong><span class="kobospan" id="kobo.573.1">) standard. </span><span class="kobospan" id="kobo.573.2">In this book, we already use this new standard. </span><span class="kobospan" id="kobo.573.3">However, Jest does not support it yet by default, so we need to pass the </span><strong class="source-inline1"><span class="kobospan" id="kobo.574.1">--experimental-vm-modules</span></strong><span class="kobospan" id="kobo.575.1"> option when </span><span><span class="kobospan" id="kobo.576.1">running Jest.</span></span></p>
<ol class="calibre15">
<li value="14" class="calibre11"><span class="kobospan" id="kobo.577.1">If we attempt</span><a id="_idIndexMarker153" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.578.1"> running this script now, we will see that there are no tests found, but we can still see that Jest is set up and </span><span><span class="kobospan" id="kobo.579.1">working properly:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.580.1">$ npm test</span></strong></pre></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer039">
<span class="kobospan" id="kobo.581.1"><img alt="Figure 3.4 – Jest is set up successfully, but we have not defined any tests yet" src="image/B19385_03_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.582.1">Figure 3.4 – Jest is set up successfully, but we have not defined any tests yet</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.583.1">Now that our test environment is set up, we can start writing our service functions and unit tests. </span><span class="kobospan" id="kobo.583.2">It is always a good idea to write unit tests right after writing service functions, as it means we will be able to debug them right away while still having their intended behavior fresh in </span><span><span class="kobospan" id="kobo.584.1">our minds.</span></span></p>
<h2 id="_idParaDest-62" class="calibre7"><a id="_idTextAnchor063" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.585.1">Writing our first service function: createPost</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.586.1">For our first service</span><a id="_idIndexMarker154" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.587.1"> function, we are going to make a function to create a new post. </span><span class="kobospan" id="kobo.587.2">We can then write tests for it by verifying that the create function creates a new post with the specified properties. </span><span class="kobospan" id="kobo.587.3">Follow </span><span><span class="kobospan" id="kobo.588.1">these steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.589.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.590.1">src/services/posts.js</span></strong></span><span><span class="kobospan" id="kobo.591.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.592.1">In the </span><strong class="source-inline1"><span class="kobospan" id="kobo.593.1">src/services/posts.js</span></strong><span class="kobospan" id="kobo.594.1"> file, first import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.595.1">Post</span></strong></span><span><span class="kobospan" id="kobo.596.1"> model:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.597.1">
import { Post } from '../db/models/post.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.598.1">Define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.599.1">createPost</span></strong><span class="kobospan" id="kobo.600.1"> function, which takes an object with </span><strong class="source-inline1"><span class="kobospan" id="kobo.601.1">title</span></strong><span class="kobospan" id="kobo.602.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.603.1">author</span></strong><span class="kobospan" id="kobo.604.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.605.1">contents</span></strong><span class="kobospan" id="kobo.606.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.607.1">tags</span></strong><span class="kobospan" id="kobo.608.1"> as arguments and creates and returns a </span><span><span class="kobospan" id="kobo.609.1">new post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.610.1">
export async function createPost({ title, author, contents, tags }) {
  const post = new Post({ title, author, contents, tags })
  return await post.save()
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.611.1">We specifically listed all properties that we want the user to be able to provide here instead of simply passing the whole object to the </span><strong class="source-inline"><span class="kobospan" id="kobo.612.1">new Post()</span></strong><span class="kobospan" id="kobo.613.1"> constructor. </span><span class="kobospan" id="kobo.613.2">While we need to type more code this way, it allows us to have control over which properties a user should be able to set. </span><span class="kobospan" id="kobo.613.3">For example, if we later add permissions to the database models, we may be accidentally allowing users to set those permissions here, if we forget to exclude those properties. </span><span class="kobospan" id="kobo.613.4">For those security reasons, it is always good practice to have a list of allowed properties instead</span><a id="_idIndexMarker155" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.614.1"> of simply passing down the </span><span><span class="kobospan" id="kobo.615.1">whole object.</span></span></p></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.616.1">After writing our first service function, let’s continue by writing test cases </span><span><span class="kobospan" id="kobo.617.1">for it.</span></span></p>
<h2 id="_idParaDest-63" class="calibre7"><a id="_idTextAnchor064" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.618.1">Defining test cases for the createPost service function</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.619.1">To </span><a id="_idIndexMarker156" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.620.1">test if the </span><strong class="source-inline"><span class="kobospan" id="kobo.621.1">createPost</span></strong><span class="kobospan" id="kobo.622.1"> function works as expected, we are going to define </span><a id="_idIndexMarker157" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.623.1">unit test cases for it </span><span><span class="kobospan" id="kobo.624.1">using Jest:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.625.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.626.1">src/__tests__/</span></strong><span class="kobospan" id="kobo.627.1"> folder, which will contain all </span><span><span class="kobospan" id="kobo.628.1">test definitions.</span></span></li>
</ol>
<p class="callout-heading"><span class="kobospan" id="kobo.629.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.630.1">Alternatively, test files can also be co-located with the related files that they are testing. </span><span class="kobospan" id="kobo.630.2">However, in this book, we use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.631.1">__tests__</span></strong><span class="kobospan" id="kobo.632.1"> directory to make it easier to distinguish tests from </span><span><span class="kobospan" id="kobo.633.1">other files.</span></span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.634.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.635.1">src/__tests__/posts.test.js</span></strong><span class="kobospan" id="kobo.636.1"> file for our tests related to posts. </span><span class="kobospan" id="kobo.636.2">In this file, start by importing </span><strong class="source-inline1"><span class="kobospan" id="kobo.637.1">mongoose</span></strong><span class="kobospan" id="kobo.638.1"> and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.639.1">describe</span></strong><span class="kobospan" id="kobo.640.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.641.1">expect</span></strong><span class="kobospan" id="kobo.642.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.643.1">test</span></strong><span class="kobospan" id="kobo.644.1"> functions </span><span><span class="kobospan" id="kobo.645.1">from </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.646.1">@jest/globals</span></strong></span><span><span class="kobospan" id="kobo.647.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.648.1">
import mongoose from 'mongoose'
import { describe, expect, test } from '@jest/globals'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.649.1">Also </span><a id="_idIndexMarker158" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.650.1">import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.651.1">createPost</span></strong><span class="kobospan" id="kobo.652.1"> function</span><a id="_idIndexMarker159" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.653.1"> from our services and the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.654.1">Post</span></strong></span><span><span class="kobospan" id="kobo.655.1"> model:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.656.1">
import { createPost } from '../services/posts.js'
import { Post } from '../db/models/post.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.657.1">Then, use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.658.1">describe()</span></strong><span class="kobospan" id="kobo.659.1"> function to define a new test. </span><span class="kobospan" id="kobo.659.2">This function describes a group of tests. </span><span class="kobospan" id="kobo.659.3">We can call our group </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.660.1">creating posts</span></strong></span><span><span class="kobospan" id="kobo.661.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.662.1">
describe('creating posts', () =&gt; {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.663.1">Inside the group, we will define a test by using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.664.1">test()</span></strong><span class="kobospan" id="kobo.665.1"> function. </span><span class="kobospan" id="kobo.665.2">We can pass an </span><strong class="source-inline1"><span class="kobospan" id="kobo.666.1">async</span></strong><span class="kobospan" id="kobo.667.1"> function here to be able to use async/await syntax. </span><span class="kobospan" id="kobo.667.2">We call the first test </span><strong class="source-inline1"><span class="kobospan" id="kobo.668.1">creating posts with all parameters </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.669.1">should succeed</span></strong></span><span><span class="kobospan" id="kobo.670.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.671.1">
  test('with all parameters should succeed', async () =&gt; {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.672.1">Inside this test, we will use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.673.1">createPost</span></strong><span class="kobospan" id="kobo.674.1"> function to create a new post with </span><span><span class="kobospan" id="kobo.675.1">some parameters:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.676.1">
    const post = {
      title: 'Hello Mongoose!',
      author: 'Daniel Bugl',
      contents: 'This post is stored in a MongoDB database using Mongoose.',
      tags: ['mongoose', 'mongodb'],
    }
    const createdPost = await createPost(post)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.677.1">Then, verify that it returns a post with an ID by using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.678.1">expect()</span></strong><span class="kobospan" id="kobo.679.1"> function from Jest and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.680.1">toBeInstanceOf</span></strong><span class="kobospan" id="kobo.681.1"> matcher to verify that it is </span><span><span class="kobospan" id="kobo.682.1">an </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.683.1">ObjectId</span></strong></span><span><span class="kobospan" id="kobo.684.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.685.1">
    expect(createdPost._id).toBeInstanceOf(mongoose.Types.ObjectId)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.686.1">Now use</span><a id="_idIndexMarker160" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.687.1"> Mongoose directly to</span><a id="_idIndexMarker161" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.688.1"> find the post with the </span><span><span class="kobospan" id="kobo.689.1">given ID:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.690.1">
    const foundPost = await Post.findById(createdPost._id)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.691.1">We </span><strong class="source-inline1"><span class="kobospan" id="kobo.692.1">expect()</span></strong><span class="kobospan" id="kobo.693.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.694.1">foundPost</span></strong><span class="kobospan" id="kobo.695.1"> to equal an object containing at least the properties of the original post object we defined. </span><span class="kobospan" id="kobo.695.2">Additionally, we expect the created post to have </span><strong class="source-inline1"><span class="kobospan" id="kobo.696.1">createdAt</span></strong><span class="kobospan" id="kobo.697.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.698.1">updatedAt</span></strong></span><span><span class="kobospan" id="kobo.699.1"> timestamps:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.700.1">
    expect(foundPost).toEqual(expect.objectContaining(post))
    expect(foundPost.createdAt).toBeInstanceOf(Date)
    expect(foundPost.updatedAt).toBeInstanceOf(Date)
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.701.1">Additionally, define a second test, called </span><strong class="source-inline1"><span class="kobospan" id="kobo.702.1">creating posts without title should fail</span></strong><span class="kobospan" id="kobo.703.1">. </span><span class="kobospan" id="kobo.703.2">As we defined the </span><strong class="source-inline1"><span class="kobospan" id="kobo.704.1">title</span></strong><span class="kobospan" id="kobo.705.1"> to be required, it should not be possible to create a post </span><span><span class="kobospan" id="kobo.706.1">without one:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.707.1">
  test('without title should fail', async () =&gt; {
    const post = {
      author: 'Daniel Bugl',
      contents: 'Post with no title',
      tags: ['empty'],
    }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.708.1">Use a </span><strong class="source-inline1"><span class="kobospan" id="kobo.709.1">try</span></strong><span class="kobospan" id="kobo.710.1">/</span><strong class="source-inline1"><span class="kobospan" id="kobo.711.1">catch</span></strong><span class="kobospan" id="kobo.712.1"> construct to catch the error and </span><strong class="source-inline1"><span class="kobospan" id="kobo.713.1">expect()</span></strong><span class="kobospan" id="kobo.714.1"> the error to be a Mongoose </span><strong class="source-inline1"><span class="kobospan" id="kobo.715.1">ValidationError</span></strong><span class="kobospan" id="kobo.716.1">, which tells us that the title </span><span><span class="kobospan" id="kobo.717.1">is required:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.718.1">
    try {
      await createPost(post)
     } catch (err) {
      expect(err).toBeInstanceOf(mongoose.Error.ValidationError)
      expect(err.message).toContain('`title` is required')
    }
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.719.1">Finally, make a </span><a id="_idIndexMarker162" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.720.1">test called </span><strong class="source-inline1"><span class="kobospan" id="kobo.721.1">creating posts with minimal parameters should succeed</span></strong><span class="kobospan" id="kobo.722.1"> and</span><a id="_idIndexMarker163" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.723.1"> only enter </span><span><span class="kobospan" id="kobo.724.1">the </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.725.1">title</span></strong></span><span><span class="kobospan" id="kobo.726.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.727.1">
  test('with minimal parameters should succeed', async () =&gt; {
    const post = {
      title: 'Only a title',
    }
    const createdPost = await createPost(post)
    expect(createdPost._id).toBeInstanceOf(mongoose.Types.ObjectId)
  })
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.728.1">Now that we have</span><a id="_idIndexMarker164" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.729.1"> defined our tests, run </span><a id="_idIndexMarker165" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.730.1">the script we </span><span><span class="kobospan" id="kobo.731.1">defined earlier:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.732.1">$ npm test</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.733.1">As we can see, using unit tests we can do isolated tests on our service functions without having to define and manually access routes or write some manual test setups. </span><span class="kobospan" id="kobo.733.2">These tests also have the added advantage that when we change code later, we can ensure that the previously defined behavior did not change by re-running </span><span><span class="kobospan" id="kobo.734.1">the tests.</span></span></p>
</div>


<div id="_idContainer047" class="calibre2">
<h2 id="_idParaDest-64" class="calibre7"><a id="_idTextAnchor065" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.735.1">Defining a function to list posts</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.736.1">After defining a function</span><a id="_idIndexMarker166" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.737.1"> to create posts, we are now going to define an </span><a id="_idIndexMarker167" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.738.1">internal </span><strong class="source-inline"><span class="kobospan" id="kobo.739.1">listPosts</span></strong><span class="kobospan" id="kobo.740.1"> function, which allows us to query posts and define a sort order. </span><span class="kobospan" id="kobo.740.2">Then, we are going to use this function to define </span><strong class="source-inline"><span class="kobospan" id="kobo.741.1">listAllPosts</span></strong><span class="kobospan" id="kobo.742.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.743.1">listPostsByAuthor</span></strong><span class="kobospan" id="kobo.744.1">, and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.745.1">listPostsByTag</span></strong></span><span><span class="kobospan" id="kobo.746.1"> functions:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.747.1">Edit the </span><strong class="source-inline1"><span class="kobospan" id="kobo.748.1">src/services/posts.js</span></strong><span class="kobospan" id="kobo.749.1"> file and define a new function at the end of </span><span><span class="kobospan" id="kobo.750.1">the file.</span></span><p class="calibre3"><span class="kobospan" id="kobo.751.1">The function accepts a </span><strong class="source-inline"><span class="kobospan" id="kobo.752.1">query</span></strong><span class="kobospan" id="kobo.753.1"> and an </span><strong class="source-inline"><span class="kobospan" id="kobo.754.1">options</span></strong><span class="kobospan" id="kobo.755.1"> argument (with </span><strong class="source-inline"><span class="kobospan" id="kobo.756.1">sortBy</span></strong><span class="kobospan" id="kobo.757.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.758.1">sortOrder</span></strong><span class="kobospan" id="kobo.759.1"> properties). </span><span class="kobospan" id="kobo.759.2">With </span><strong class="source-inline"><span class="kobospan" id="kobo.760.1">sortBy</span></strong><span class="kobospan" id="kobo.761.1">, we can define which field we want to sort by, and the </span><strong class="source-inline"><span class="kobospan" id="kobo.762.1">sortOrder</span></strong><span class="kobospan" id="kobo.763.1"> argument allows us to specify whether posts should be sorted in ascending or descending order. </span><span class="kobospan" id="kobo.763.2">By default, we list all posts (empty object as query) and show the newest posts first (sorted by </span><strong class="source-inline"><span class="kobospan" id="kobo.764.1">createdAt</span></strong><span class="kobospan" id="kobo.765.1">, in </span><span><strong class="source-inline"><span class="kobospan" id="kobo.766.1">descending</span></strong></span><span><span class="kobospan" id="kobo.767.1"> order):</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.768.1">
async function listPosts(
  query = {},
  { sortBy = 'createdAt', sortOrder = 'descending' } = {},
) {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.769.1">We can use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.770.1">.find()</span></strong><span class="kobospan" id="kobo.771.1"> method from our Mongoose model to list all posts, passing an argument to </span><span><span class="kobospan" id="kobo.772.1">sort them:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.773.1">
  return await Post.find(query).sort({ [sortBy]: sortOrder })
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.774.1">Now we can define a function to list all posts, which simply passes an empty object </span><span><span class="kobospan" id="kobo.775.1">as query:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.776.1">
export async function listAllPosts(options) {
  return await listPosts({}, options)
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.777.1">Similarly, we can </span><a id="_idIndexMarker168" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.778.1">create a function to list all posts by a certain</span><a id="_idIndexMarker169" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.779.1"> author by passing </span><strong class="source-inline1"><span class="kobospan" id="kobo.780.1">author</span></strong><span class="kobospan" id="kobo.781.1"> to the </span><span><span class="kobospan" id="kobo.782.1">query object:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.783.1">
export async function listPostsByAuthor(author, options) {
  return await listPosts({ author }, options)
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.784.1">Lastly, define a function to list posts </span><span><span class="kobospan" id="kobo.785.1">by tag:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.786.1">
export async function listPostsByTag(tags, options) {
  return await listPosts({ tags }, options)
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.787.1">In MongoDB, we</span><a id="_idIndexMarker170" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.788.1"> can simply match strings in an array by</span><a id="_idIndexMarker171" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.789.1"> matching the string as if it was a single value, so all we need to do is add a query for </span><strong class="source-inline"><span class="kobospan" id="kobo.790.1">tags: 'nodejs'</span></strong><span class="kobospan" id="kobo.791.1">. </span><span class="kobospan" id="kobo.791.2">MongoDB will then return all documents that have a </span><strong class="source-inline"><span class="kobospan" id="kobo.792.1">'nodejs'</span></strong><span class="kobospan" id="kobo.793.1"> string in their </span><span><strong class="source-inline"><span class="kobospan" id="kobo.794.1">tags</span></strong></span><span><span class="kobospan" id="kobo.795.1"> array.</span></span></p></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.796.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.797.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.798.1">{ [variable]: … }</span></strong><span class="kobospan" id="kobo.799.1"> operator resolves the string stored in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.800.1">variable</span></strong><span class="kobospan" id="kobo.801.1"> to a key name for the created object. </span><span class="kobospan" id="kobo.801.2">So, if our variable contains </span><strong class="source-inline1"><span class="kobospan" id="kobo.802.1">'createdAt'</span></strong><span class="kobospan" id="kobo.803.1">, the resulting object will be </span><strong class="source-inline1"><span class="kobospan" id="kobo.804.1">{ createdAt: … }</span></strong><span class="kobospan" id="kobo.805.1">.</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.806.1">After defining the list post function, let’s also write test cases </span><span><span class="kobospan" id="kobo.807.1">for it.</span></span></p>
<h2 id="_idParaDest-65" class="calibre7"><a id="_idTextAnchor066" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.808.1">Defining test cases for list posts</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.809.1">Defining test</span><a id="_idIndexMarker172" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.810.1"> cases for list posts is similar to create posts. </span><span class="kobospan" id="kobo.810.2">However, we </span><a id="_idIndexMarker173" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.811.1">now need to create an initial state where we already have some posts in the database to be able to test the list functions. </span><span class="kobospan" id="kobo.811.2">We can do this by using the </span><strong class="source-inline"><span class="kobospan" id="kobo.812.1">beforeEach()</span></strong><span class="kobospan" id="kobo.813.1"> function, which executes some code before each test case is executed. </span><span class="kobospan" id="kobo.813.2">We can use the </span><strong class="source-inline"><span class="kobospan" id="kobo.814.1">beforeEach()</span></strong><span class="kobospan" id="kobo.815.1"> function for a whole test file or only run it for each test inside a </span><strong class="source-inline"><span class="kobospan" id="kobo.816.1">describe()</span></strong><span class="kobospan" id="kobo.817.1"> group. </span><span class="kobospan" id="kobo.817.2">In our case, we are going to define it for the whole file, as the sample posts will come in handy when we test the delete post </span><span><span class="kobospan" id="kobo.818.1">function later:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.819.1">Edit the </span><strong class="source-inline1"><span class="kobospan" id="kobo.820.1">src/__tests__/posts.js</span></strong><span class="kobospan" id="kobo.821.1"> file, adjust the </span><strong class="source-inline1"><span class="kobospan" id="kobo.822.1">import</span></strong><span class="kobospan" id="kobo.823.1"> statement to import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.824.1">beforeEach</span></strong><span class="kobospan" id="kobo.825.1"> function from </span><strong class="source-inline1"><span class="kobospan" id="kobo.826.1">@jest/globals</span></strong><span class="kobospan" id="kobo.827.1"> and import the various functions to list posts from </span><span><span class="kobospan" id="kobo.828.1">our services:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.829.1">
import { describe, expect, test</span><strong class="bold1"><span class="kobospan1" id="kobo.830.1">, beforeEach</span></strong><span class="kobospan1" id="kobo.831.1"> } from '@jest/globals'
import { createPost</span><strong class="bold1"><span class="kobospan1" id="kobo.832.1">,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.833.1">         listAllPosts,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.834.1">         listPostsByAuthor,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.835.1">         listPostsByTag,</span></strong><span class="kobospan1" id="kobo.836.1">
} from '../services/posts.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.837.1">At the end of the file, define an array of </span><span><span class="kobospan" id="kobo.838.1">sample posts:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.839.1">
const samplePosts = [
  { title: 'Learning Redux', author: 'Daniel Bugl', tags: ['redux'] },
  { title: 'Learn React Hooks', author: 'Daniel Bugl', tags: ['react'] },
  {
    title: 'Full-Stack React Projects',
    author: 'Daniel Bugl',
    tags: ['react', 'nodejs'],
  },
  { title: 'Guide to TypeScript' },
]</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.840.1">Now, define</span><a id="_idIndexMarker174" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.841.1"> an empty array, which will be populated </span><a id="_idIndexMarker175" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.842.1">with the created posts. </span><span class="kobospan" id="kobo.842.2">Then, define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.843.1">beforeEach</span></strong><span class="kobospan" id="kobo.844.1"> function, which first clears all posts from the database and clears the array of created sample posts and then creates the sample posts in the database again for each of the posts defined in the array earlier. </span><span class="kobospan" id="kobo.844.2">This ensures that we have a consistent state of the database before each test case runs and that we have an array to compare against when testing the list </span><span><span class="kobospan" id="kobo.845.1">post functions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.846.1">
let createdSamplePosts = []
beforeEach(async () =&gt; {
  await Post.deleteMany({})
  createdSamplePosts = []
  for (const post of samplePosts) {
    const createdPost = new Post(post)
    createdSamplePosts.push(await createdPost.save())
  }
})</span></pre><p class="calibre3"><span class="kobospan" id="kobo.847.1">To ensure that </span><a id="_idIndexMarker176" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.848.1">our unit tests are modular and</span><a id="_idIndexMarker177" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.849.1"> independent from each other, we insert posts into the database directly by using Mongoose functions (instead of the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.850.1">createPost</span></strong></span><span><span class="kobospan" id="kobo.851.1"> function).</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.852.1">Now that we have some sample posts ready, let’s write our first test case, which should simply list all posts. </span><span class="kobospan" id="kobo.852.2">We will define a new test group for </span><strong class="source-inline1"><span class="kobospan" id="kobo.853.1">listing posts</span></strong><span class="kobospan" id="kobo.854.1"> and a test to verify that all sample posts are listed by the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.855.1">listAllPosts()</span></strong></span><span><span class="kobospan" id="kobo.856.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.857.1">
describe('listing posts', () =&gt; {
  test('should return all posts', async () =&gt; {
    const posts = await listAllPosts()
    expect(posts.length).toEqual(createdSamplePosts.length)
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.858.1">Next, make a test that verifies that the default sort order shows newest posts first. </span><span class="kobospan" id="kobo.858.2">We sort the </span><strong class="source-inline1"><span class="kobospan" id="kobo.859.1">createdSamplePosts</span></strong><span class="kobospan" id="kobo.860.1"> array manually by </span><strong class="source-inline1"><span class="kobospan" id="kobo.861.1">createdAt</span></strong><span class="kobospan" id="kobo.862.1"> (descending) and then compare the sorted dates to those returned from the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.863.1">listAllPosts()</span></strong></span><span><span class="kobospan" id="kobo.864.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.865.1">
  test('should return posts sorted by creation date descending by default', async () =&gt; {
    const posts = await listAllPosts()
    const sortedSamplePosts = createdSamplePosts.sort(
      (a, b) =&gt; b.createdAt - a.createdAt,
    )
    expect(posts.map((post) =&gt; post.createdAt)).toEqual(
      sortedSamplePosts.map((post) =&gt; post.createdAt),
    )
  })</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.866.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.867.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.868.1">.map()</span></strong><span class="kobospan" id="kobo.869.1"> function applies a function to each element of an array and returns the result. </span><span class="kobospan" id="kobo.869.2">In our case, we select the </span><strong class="source-inline1"><span class="kobospan" id="kobo.870.1">createdAt</span></strong><span class="kobospan" id="kobo.871.1"> property from all elements of the array. </span><span class="kobospan" id="kobo.871.2">We cannot directly compare the arrays with each other because Mongoose returns documents with a lot of additional information in hidden metadata, which Jest will attempt </span><span><span class="kobospan" id="kobo.872.1">to compare.</span></span></p>
<ol class="calibre15">
<li value="6" class="calibre11"><span class="kobospan" id="kobo.873.1">Additionally, define a</span><a id="_idIndexMarker178" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.874.1"> test case where the </span><strong class="source-inline1"><span class="kobospan" id="kobo.875.1">sortBy</span></strong><span class="kobospan" id="kobo.876.1"> value is</span><a id="_idIndexMarker179" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.877.1"> changed to </span><strong class="source-inline1"><span class="kobospan" id="kobo.878.1">updatedAt</span></strong><span class="kobospan" id="kobo.879.1">, and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.880.1">sortOrder</span></strong><span class="kobospan" id="kobo.881.1"> value is changed to </span><strong class="source-inline1"><span class="kobospan" id="kobo.882.1">ascending</span></strong><span class="kobospan" id="kobo.883.1"> (showing oldest updated </span><span><span class="kobospan" id="kobo.884.1">posts first):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.885.1">
  test('should take into account provided sorting options', async () =&gt; {
    const posts = await listAllPosts({
      sortBy: 'updatedAt',
      sortOrder: 'ascending',
    })
    const sortedSamplePosts = createdSamplePosts.sort(
      (a, b) =&gt; a.updatedAt - b.updatedAt,
    )
    expect(posts.map((post) =&gt; post.updatedAt)).toEqual(
      sortedSamplePosts.map((post) =&gt; post.updatedAt),
    )
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.886.1">Then, add a test to </span><a id="_idIndexMarker180" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.887.1">ensure that listing posts by </span><span><span class="kobospan" id="kobo.888.1">author</span></span><span><a id="_idIndexMarker181" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.889.1"> works:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.890.1">
  test('should be able to filter posts by author', async () =&gt; {
    const posts = await listPostsByAuthor('Daniel Bugl')
    expect(posts.length).toBe(3)
  })</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.891.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.892.1">We are controlling the test environment by creating a specific set of sample posts before each test case runs. </span><span class="kobospan" id="kobo.892.2">We can make use of this controlled environment to simplify our tests. </span><span class="kobospan" id="kobo.892.3">As we already know that there are only three posts with that author, we can simply check if the function returned exactly three posts. </span><span class="kobospan" id="kobo.892.4">Doing so keeps our tests simple, and they are still safe because we control the </span><span><span class="kobospan" id="kobo.893.1">environment completely.</span></span></p>
<ol class="calibre15">
<li value="8" class="calibre11"><span class="kobospan" id="kobo.894.1">Finally, add a test to verify that listing posts by </span><span><span class="kobospan" id="kobo.895.1">tag works:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.896.1">
  test('should be able to filter posts by tag', async () =&gt; {
    const posts = await listPostsByTag('nodejs')
    expect(posts.length).toBe(1)
  })
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.897.1">Run the tests again and watch them </span><span><span class="kobospan" id="kobo.898.1">all pass:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.899.1">$ npm test</span></strong></pre></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer040">
<span class="kobospan" id="kobo.900.1"><img alt="Figure 3.5 – All our tests passing successfully!" src="image/B19385_03_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.901.1">Figure 3.5 – All our tests passing successfully!</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.902.1">As we can see, for </span><a id="_idIndexMarker182" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.903.1">some tests, we need to prepare an initial</span><a id="_idIndexMarker183" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.904.1"> state. </span><span class="kobospan" id="kobo.904.2">In our case, we only had to create some posts, but this initial state may become more sophisticated. </span><span class="kobospan" id="kobo.904.3">For example, on a more advanced blogging platform, it may be necessary to create a user account first, then create a blog on the platform, and then create blog posts for that blog. </span><span class="kobospan" id="kobo.904.4">In that case, we could create test utility functions, such as </span><strong class="source-inline"><span class="kobospan" id="kobo.905.1">createTestUser</span></strong><span class="kobospan" id="kobo.906.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.907.1">createTestBlog</span></strong><span class="kobospan" id="kobo.908.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.909.1">createTestPost</span></strong><span class="kobospan" id="kobo.910.1"> and import them in our tests. </span><span class="kobospan" id="kobo.910.2">We can then use these functions in </span><strong class="source-inline"><span class="kobospan" id="kobo.911.1">beforeEach()</span></strong><span class="kobospan" id="kobo.912.1"> across multiple test files instead of manually doing it every single time. </span><span class="kobospan" id="kobo.912.2">Depending on your application structure, different test utility functions may be needed, so feel free to define them as you </span><span><span class="kobospan" id="kobo.913.1">see fit.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.914.1">After defining the test cases for the list posts function, let’s continue by defining the get single post, update post, and delete </span><span><span class="kobospan" id="kobo.915.1">post functions.</span></span></p>
<h2 id="_idParaDest-66" class="calibre7"><a id="_idTextAnchor067" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.916.1">Defining the get single post, update and delete post functions</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.917.1">The get single </span><a id="_idIndexMarker184" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.918.1">post, update and delete post functions can be </span><a id="_idIndexMarker185" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.919.1">defined very similarly to the list posts function. </span><span class="kobospan" id="kobo.919.2">Let’s do</span><a id="_idIndexMarker186" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.920.1"> that </span><span><span class="kobospan" id="kobo.921.1">quickly now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.922.1">Edit the </span><strong class="source-inline1"><span class="kobospan" id="kobo.923.1">src/services/posts.js</span></strong><span class="kobospan" id="kobo.924.1"> file and define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.925.1">getPostById</span></strong><span class="kobospan" id="kobo.926.1"> function </span><span><span class="kobospan" id="kobo.927.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.928.1">
export async function getPostById(postId) {
  return await Post.findById(postId)
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.929.1">It may seem a bit trivial to define a service function that just calls </span><strong class="source-inline"><span class="kobospan" id="kobo.930.1">Post.findById</span></strong><span class="kobospan" id="kobo.931.1">, but it is good practice to define it anyway. </span><span class="kobospan" id="kobo.931.2">Later, we may want to add some additional restrictions, such as access control. </span><span class="kobospan" id="kobo.931.3">Having the service function allows us to change it only in one place and we do not have to worry about forgetting to add it somewhere. </span><span class="kobospan" id="kobo.931.4">Another benefit is that if we, for example, want to change the database provider later, the developer only needs to worry about getting the service functions working again, and they can be verified with the </span><span><span class="kobospan" id="kobo.932.1">test cases.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.933.1">In the same file, define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.934.1">updatePost</span></strong><span class="kobospan" id="kobo.935.1"> function. </span><span class="kobospan" id="kobo.935.2">It will take an ID of an existing post, and an object of parameters to be updated. </span><span class="kobospan" id="kobo.935.3">We are going to use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.936.1">findOneAndUpdate</span></strong><span class="kobospan" id="kobo.937.1"> function from Mongoose, together with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.938.1">$set</span></strong><span class="kobospan" id="kobo.939.1"> operator, to change the specified parameters. </span><span class="kobospan" id="kobo.939.2">As a third argument, we provide an options object with </span><strong class="source-inline1"><span class="kobospan" id="kobo.940.1">new: true</span></strong><span class="kobospan" id="kobo.941.1"> so that the function returns the modified object instead of </span><span><span class="kobospan" id="kobo.942.1">the original:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.943.1">
export async function updatePost(postId, { title, author, contents, tags }) {
  return await Post.findOneAndUpdate(
    { _id: postId },
    { $set: { title, author, contents, tags } },
    { new: true },
  )
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.944.1">In the same file, also define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.945.1">deletePost</span></strong><span class="kobospan" id="kobo.946.1"> function, which simply takes the ID of an existing post</span><a id="_idIndexMarker187" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.947.1"> and deletes it from </span><span><span class="kobospan" id="kobo.948.1">the database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.949.1">
export async function deletePost(postId) {
  return await Post.deleteOne({ _id: postId })
}</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.950.1">Tip</span></p>
<p class="callout"><span class="kobospan" id="kobo.951.1">Depending on your application, you may want to set a </span><strong class="source-inline1"><span class="kobospan" id="kobo.952.1">deletedOn</span></strong><span class="kobospan" id="kobo.953.1"> timestamp instead of deleting it right away. </span><span class="kobospan" id="kobo.953.2">Then, set up a function that gets all documents that have been deleted for more than 30 days and delete them. </span><span class="kobospan" id="kobo.953.3">Of course, this means that we need to always filter out already deleted posts in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.954.1">listPosts</span></strong><span class="kobospan" id="kobo.955.1"> function and that we need to write test cases for </span><span><span class="kobospan" id="kobo.956.1">this behavior!</span></span></p>
<ol class="calibre15">
<li value="4" class="calibre11"><span class="kobospan" id="kobo.957.1">Edit </span><a id="_idIndexMarker188" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.958.1">the </span><strong class="source-inline1"><span class="kobospan" id="kobo.959.1">src/__tests__/posts.js</span></strong><span class="kobospan" id="kobo.960.1"> file and import</span><a id="_idIndexMarker189" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.961.1"> the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.962.1">getPostById</span></strong></span><span><span class="kobospan" id="kobo.963.1"> function:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.964.1">  getPostById,</span></strong><span class="kobospan1" id="kobo.965.1">
} from '../services/posts.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.966.1">Add tests for getting a post by ID and failing to get a post because the ID did not exist in </span><span><span class="kobospan" id="kobo.967.1">the database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.968.1">
describe('getting a post', () =&gt; {
  test('should return the full post', async () =&gt; {
    const post = await getPostById(createdSamplePosts[0]._id)
    expect(post.toObject()).toEqual(createdSamplePosts[0].toObject())
  })
  test('should fail if the id does not exist', async () =&gt; {
    const post = await getPostById('000000000000000000000000')
    expect(post).toEqual(null)
  })
})</span></pre><p class="calibre3"><span class="kobospan" id="kobo.969.1">In the first test, we use</span><strong class="source-inline"><span class="kobospan" id="kobo.970.1">.toObject()</span></strong><span class="kobospan" id="kobo.971.1"> to convert the Mongoose object with all its internal properties and metadata to a </span><strong class="bold"><span class="kobospan" id="kobo.972.1">plain old JavaScript object </span></strong><span class="kobospan" id="kobo.973.1">(</span><strong class="bold"><span class="kobospan" id="kobo.974.1">POJO</span></strong><span class="kobospan" id="kobo.975.1">) so that we can </span><a id="_idIndexMarker190" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.976.1">compare it to the sample post </span><a id="_idIndexMarker191" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.977.1">object by</span><a id="_idIndexMarker192" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.978.1"> comparing </span><span><span class="kobospan" id="kobo.979.1">all properties.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.980.1">Next, import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.981.1">updatePost</span></strong></span><span><span class="kobospan" id="kobo.982.1"> function:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.983.1">  updatePost,</span></strong><span class="kobospan1" id="kobo.984.1">
} from '../services/posts.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.985.1">Then, add</span><a id="_idIndexMarker193" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.986.1"> tests for updating a post successfully. </span><span class="kobospan" id="kobo.986.2">We add one test to verify that the specified property was changed and another test to verify that it does not interfere with </span><span><span class="kobospan" id="kobo.987.1">other properties:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.988.1">
describe('updating posts', () =&gt; {
  test('should update the specified property', async () =&gt; {
    await updatePost(createdSamplePosts[0]._id, {
      author: 'Test Author',
    })
    const updatedPost = await Post.findById(createdSamplePosts[0]._id)
    expect(updatedPost.author).toEqual('Test Author')
  })
  test('should not update other properties', async () =&gt; {
    await updatePost(createdSamplePosts[0]._id, {
      author: 'Test Author',
    })
    const updatedPost = await Post.findById(createdSamplePosts[0]._id)
    expect(updatedPost.title).toEqual('Learning Redux')
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.989.1">Additionally, add </span><a id="_idIndexMarker194" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.990.1">a test to ensure the </span><strong class="source-inline1"><span class="kobospan" id="kobo.991.1">updatedAt</span></strong><span class="kobospan" id="kobo.992.1"> timestamp </span><a id="_idIndexMarker195" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.993.1">was updated. </span><span class="kobospan" id="kobo.993.2">To do so, first convert the </span><strong class="source-inline1"><span class="kobospan" id="kobo.994.1">Date</span></strong><span class="kobospan" id="kobo.995.1"> objects to</span><a id="_idIndexMarker196" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.996.1"> numbers by using </span><strong class="source-inline1"><span class="kobospan" id="kobo.997.1">.getTime()</span></strong><span class="kobospan" id="kobo.998.1">, and then we can compare them by using the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.999.1">expect(…).toBeGreaterThan(…)</span></strong></span><span><span class="kobospan" id="kobo.1000.1"> matcher:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1001.1">
  test('should update the updatedAt timestamp', async () =&gt; {
    await updatePost(createdSamplePosts[0]._id, {
      author: 'Test Author',
    })
    const updatedPost = await Post.findById(createdSamplePosts[0]._id)
    expect(updatedPost.updatedAt.getTime()).toBeGreaterThan(
        createdSamplePosts[0].updatedAt.getTime(),
      )
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1002.1">Also add a</span><a id="_idIndexMarker197" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1003.1"> failing test to see if the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1004.1">updatePost</span></strong><span class="kobospan" id="kobo.1005.1"> function</span><a id="_idIndexMarker198" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1006.1"> returns </span><strong class="source-inline1"><span class="kobospan" id="kobo.1007.1">null</span></strong><span class="kobospan" id="kobo.1008.1"> when no post with a </span><a id="_idIndexMarker199" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1009.1">matching ID </span><span><span class="kobospan" id="kobo.1010.1">was found:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1011.1">
  test('should fail if the id does not exist', async () =&gt; {
    const post = await updatePost('000000000000000000000000', {
      author: 'Test Author',
    })
    expect(post).toEqual(null)
  })
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1012.1">Lastly, import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1013.1">deletePost</span></strong></span><span><span class="kobospan" id="kobo.1014.1"> function:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1015.1">  deletePost,</span></strong><span class="kobospan1" id="kobo.1016.1">
} from '../services/posts.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1017.1">Then, add tests for successful and unsuccessful deletes by checking if the post was deleted and verifying the </span><span><span class="kobospan" id="kobo.1018.1">returned </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1019.1">deletedCount</span></strong></span><span><span class="kobospan" id="kobo.1020.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1021.1">
describe('deleting posts', () =&gt; {
  test('should remove the post from the database', async () =&gt; {
    const result = await deletePost(createdSamplePosts[0]._id)
    expect(result.deletedCount).toEqual(1)
    const deletedPost = await Post.findById(createdSamplePosts[0]._id)
    expect(deletedPost).toEqual(null)
  })
  test('should fail if the id does not exist', async () =&gt; {
    const result = await deletePost('000000000000000000000000')
    expect(result.deletedCount).toEqual(0)
  })
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1022.1">Finally, run</span><a id="_idIndexMarker200" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1023.1"> all tests</span><a id="_idIndexMarker201" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1024.1"> again; they </span><a id="_idIndexMarker202" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1025.1">should </span><span><span class="kobospan" id="kobo.1026.1">all pass:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1027.1">$ npm test</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1028.1">Writing tests for service functions may be tedious, but it will save us a lot of time in the long run. </span><span class="kobospan" id="kobo.1028.2">Adding additional functionality later, such as access control, may change the basic behavior of the service functions. </span><span class="kobospan" id="kobo.1028.3">By having the unit tests, we can ensure that we do not break existing behavior when adding </span><span><span class="kobospan" id="kobo.1029.1">new functionality.</span></span></p>
<h2 id="_idParaDest-67" class="calibre7"><a id="_idTextAnchor068" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1030.1">Using the Jest VS Code extension</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1031.1">Up until now, we have run our tests by using</span><a id="_idIndexMarker203" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1032.1"> Jest via the Terminal. </span><span class="kobospan" id="kobo.1032.2">There is also a Jest extension for VS Code, which we can use to make running tests more visual. </span><span class="kobospan" id="kobo.1032.3">The extension is especially helpful for larger projects where we have many tests in multiple files. </span><span class="kobospan" id="kobo.1032.4">Additionally, the extension can automatically watch and re-run tests if we change the definitions. </span><span class="kobospan" id="kobo.1032.5">We can install the extension </span><span><span class="kobospan" id="kobo.1033.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1034.1">Go to the </span><strong class="bold"><span class="kobospan" id="kobo.1035.1">Extensions</span></strong><span class="kobospan" id="kobo.1036.1"> tab in the VS </span><span><span class="kobospan" id="kobo.1037.1">Code sidebar.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1038.1">Enter </span><strong class="source-inline1"><span class="kobospan" id="kobo.1039.1">Orta.vscode-jest</span></strong><span class="kobospan" id="kobo.1040.1"> in the search box to find the </span><span><span class="kobospan" id="kobo.1041.1">Jest extension.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1042.1">Install the extension by pressing the </span><span><strong class="bold"><span class="kobospan" id="kobo.1043.1">Install</span></strong></span><span><span class="kobospan" id="kobo.1044.1"> button.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1045.1">Now go to the newly added test icon on the sidebar (it should be a chemistry </span><span><span class="kobospan" id="kobo.1046.1">flask icon):</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer041">
<span class="kobospan" id="kobo.1047.1"><img alt="Figure 3.6 – The Testing tab in VS Code provided by the Jest extension" src="image/B19385_03_6.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1048.1">Figure 3.6 – The Testing tab in VS Code provided by the Jest extension</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1049.1">The Jest extension </span><a id="_idIndexMarker204" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1050.1">provides us an overview of all tests that we have defined. </span><span class="kobospan" id="kobo.1050.2">We can hover over them and press on the </span><strong class="bold"><span class="kobospan" id="kobo.1051.1">Play</span></strong><span class="kobospan" id="kobo.1052.1"> icon to re-run a specific test. </span><span class="kobospan" id="kobo.1052.2">By default, the Jest extension enables </span><strong class="bold"><span class="kobospan" id="kobo.1053.1">auto-run-watch</span></strong><span class="kobospan" id="kobo.1054.1"> (as can be seen in </span><span><em class="italic"><span class="kobospan" id="kobo.1055.1">Figure 3</span></em></span><em class="italic"><span class="kobospan" id="kobo.1056.1">.6</span></em><span class="kobospan" id="kobo.1057.1">). </span><span class="kobospan" id="kobo.1057.2">If </span><strong class="bold"><span class="kobospan" id="kobo.1058.1">auto-run-watch</span></strong><span class="kobospan" id="kobo.1059.1"> is enabled, the extension will re-run tests automatically when test </span><a id="_idIndexMarker205" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1060.1">definition files are saved. </span><span class="kobospan" id="kobo.1060.2">That’s </span><span><span class="kobospan" id="kobo.1061.1">pretty handy!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1062.1">Now that we have defined and tested our service functions, we can start using them when defining routes, which we are going to </span><span><span class="kobospan" id="kobo.1063.1">do next!</span></span></p>
<h1 id="_idParaDest-68" class="calibre5"><a id="_idTextAnchor069" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1064.1">Providing a REST API using Express</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1065.1">Having our data and service layers set up, we have a good framework for being able to write our backend. </span><span class="kobospan" id="kobo.1065.2">However, we still need an interface that lets users access our backend. </span><span class="kobospan" id="kobo.1065.3">This interface will be</span><a id="_idIndexMarker206" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1066.1"> a </span><strong class="bold"><span class="kobospan" id="kobo.1067.1">representational state transfer</span></strong><span class="kobospan" id="kobo.1068.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1069.1">REST</span></strong><span class="kobospan" id="kobo.1070.1">) API. </span><span class="kobospan" id="kobo.1070.2">A REST API provides a way to access our server via HTTP requests, which we can make use of when we develop </span><span><span class="kobospan" id="kobo.1071.1">our frontend.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer042">
<span class="kobospan" id="kobo.1072.1"><img alt="Figure 3.7 – The interaction between client and server using HTTP requests" src="image/B19385_03_7.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1073.1">Figure 3.7 – The interaction between client and server using HTTP requests</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1074.1">As we can see, clients can send requests to our backend server, and the server will respond to them. </span><span class="kobospan" id="kobo.1074.2">There are five commonly used methods in a </span><span><span class="kobospan" id="kobo.1075.1">REST-based architecture:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1076.1">GET</span></strong><span class="kobospan" id="kobo.1077.1">: This is</span><a id="_idIndexMarker207" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1078.1"> used to read resources. </span><span class="kobospan" id="kobo.1078.2">Generally, it should not influence the database state and, given the same input, it should return the same output (unless the database state was changed through other requests). </span><span class="kobospan" id="kobo.1078.3">This behavior is called </span><strong class="bold"><span class="kobospan" id="kobo.1079.1">idempotence</span></strong><span class="kobospan" id="kobo.1080.1">. </span><span class="kobospan" id="kobo.1080.2">In response</span><a id="_idIndexMarker208" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1081.1"> to a successful GET request, a server usually returns the resource(s) with a 200 OK </span><span><span class="kobospan" id="kobo.1082.1">status code.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1083.1">POST</span></strong><span class="kobospan" id="kobo.1084.1">: This is </span><a id="_idIndexMarker209" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1085.1">used to create new resources, from the information provided in the request body. </span><span class="kobospan" id="kobo.1085.2">In response to a successful POST request, a server usually either returns the newly created object with a 201 Created status code or returns an empty response (with 201 Created status code) with a URL in the </span><strong class="bold"><span class="kobospan" id="kobo.1086.1">Location</span></strong><span class="kobospan" id="kobo.1087.1"> header that points to the newly </span><span><span class="kobospan" id="kobo.1088.1">created resource.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1089.1">PUT</span></strong><span class="kobospan" id="kobo.1090.1">: This is used to </span><a id="_idIndexMarker210" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1091.1">update an existing resource with a given ID, replacing the resource completely with the new data provided in the request body. </span><span class="kobospan" id="kobo.1091.2">In some cases, it can also be used to create a new resource with a client-specified ID. </span><span class="kobospan" id="kobo.1091.3">In response to a successful PUT request, a server either returns the updated resource with a 200 OK status code, 204 No Content if it does not return the updated resource, or 201 Created if it created a </span><span><span class="kobospan" id="kobo.1092.1">new resource.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1093.1">PATCH</span></strong><span class="kobospan" id="kobo.1094.1">: This is used to modify an existing resource with a given ID, only updating the fields specified in the request body instead of replacing the whole resource. </span><span class="kobospan" id="kobo.1094.2">In response to a successful PATCH</span><a id="_idIndexMarker211" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1095.1"> request, a server either returns the updated resource with 200 OK or 204 No Content if it does not return the </span><span><span class="kobospan" id="kobo.1096.1">updated resource.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1097.1">DELETE</span></strong><span class="kobospan" id="kobo.1098.1">: This is used to delete a resource with a given ID. </span><span class="kobospan" id="kobo.1098.2">In response to a successful DELETE</span><a id="_idIndexMarker212" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1099.1"> request, a server either returns the deleted resource with 200 OK or 204 No Content if it does not return the </span><span><span class="kobospan" id="kobo.1100.1">deleted resource.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1101.1">HTTP REST API routes are usually defined in a folder-like structure. </span><span class="kobospan" id="kobo.1101.2">It is always a good idea to prefix all routes with </span><strong class="source-inline"><span class="kobospan" id="kobo.1102.1">/api/v1/</span></strong><span class="kobospan" id="kobo.1103.1"> (</span><strong class="source-inline"><span class="kobospan" id="kobo.1104.1">v1</span></strong><span class="kobospan" id="kobo.1105.1"> being the version of the API definition, starting with </span><strong class="source-inline"><span class="kobospan" id="kobo.1106.1">1</span></strong><span class="kobospan" id="kobo.1107.1">). </span><span class="kobospan" id="kobo.1107.2">If we want to change the API definition later, we can then easily run </span><strong class="source-inline"><span class="kobospan" id="kobo.1108.1">/api/v1/</span></strong><span class="kobospan" id="kobo.1109.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.1110.1">/api/v2/</span></strong><span class="kobospan" id="kobo.1111.1"> in parallel for a while until everything </span><span><span class="kobospan" id="kobo.1112.1">is migrated.</span></span></p>
<h2 id="_idParaDest-69" class="calibre7"><a id="_idTextAnchor070" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1113.1">Defining our API routes</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1114.1">Now that we </span><a id="_idIndexMarker213" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1115.1">have learned how HTTP REST</span><a id="_idIndexMarker214" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1116.1"> APIs work, let’s start by defining routes for our backend, covering all functionality we have already implemented in the </span><span><span class="kobospan" id="kobo.1117.1">service functions:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1118.1">GET /api/v1/posts</span></strong><span class="kobospan" id="kobo.1119.1">: Get a list of </span><span><span class="kobospan" id="kobo.1120.1">all posts</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1121.1">GET /api/v1/posts?sortBy=updatedAt&amp;sortOrder=ascending</span></strong><span class="kobospan" id="kobo.1122.1">: Get a list of all posts sorted by </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1123.1">updatedAt</span></strong></span><span><span class="kobospan" id="kobo.1124.1"> (ascending)</span></span></li>
</ul>
<p class="callout-heading"><span class="kobospan" id="kobo.1125.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1126.1">Everything after the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1127.1">?</span></strong><span class="kobospan" id="kobo.1128.1"> symbol is called a query string and follows the format </span><strong class="source-inline1"><span class="kobospan" id="kobo.1129.1">key1=value1&amp;key2=value2&amp;…</span></strong><span class="kobospan" id="kobo.1130.1">. </span><span class="kobospan" id="kobo.1130.2">The query string can be used to provide additional optional parameters to </span><span><span class="kobospan" id="kobo.1131.1">a route.</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1132.1">GET /api/v1/posts?author=daniel</span></strong><span class="kobospan" id="kobo.1133.1">: Get a list of posts by </span><span><span class="kobospan" id="kobo.1134.1">author “daniel”</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1135.1">GET /api/v1/posts?tag=react</span></strong><span class="kobospan" id="kobo.1136.1">: Get a list of posts with the </span><span><span class="kobospan" id="kobo.1137.1">tag </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1138.1">react</span></strong></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1139.1">GET /api/v1/posts/:id</span></strong><span class="kobospan" id="kobo.1140.1">: Get a single post </span><span><span class="kobospan" id="kobo.1141.1">by ID</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1142.1">POST /api/v1/posts</span></strong><span class="kobospan" id="kobo.1143.1">: Create a </span><span><span class="kobospan" id="kobo.1144.1">new post</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1145.1">PATCH /api/v1/posts/:id</span></strong><span class="kobospan" id="kobo.1146.1">: Update an existing post </span><span><span class="kobospan" id="kobo.1147.1">by ID</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1148.1">DELETE /api/v1/posts/:id</span></strong><span class="kobospan" id="kobo.1149.1">: Delete an existing post </span><span><span class="kobospan" id="kobo.1150.1">by ID</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1151.1">As we can see, by putting together our already developed service functions and what we have learned about REST APIs, we can easily define routes for our backend. </span><span class="kobospan" id="kobo.1151.2">Now that we have defined our </span><a id="_idIndexMarker215" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1152.1">routes, let’s set up Express</span><a id="_idIndexMarker216" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1153.1"> and our backend server to be able to expose </span><span><span class="kobospan" id="kobo.1154.1">those routes.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.1155.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1156.1">This is just one example of how a REST API can be designed. </span><span class="kobospan" id="kobo.1156.2">It is intended as an example to get you started with full-stack development. </span><span class="kobospan" id="kobo.1156.3">Later, on your own time, feel free to check out other resources, such as </span><a href="https://standards.rest" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.1157.1">https://standards.rest</span></a><span class="kobospan" id="kobo.1158.1">, to deepen your knowledge of REST </span><span><span class="kobospan" id="kobo.1159.1">API designs.</span></span></p>
<h2 id="_idParaDest-70" class="calibre7"><a id="_idTextAnchor071" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1160.1">Setting up Express</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1161.1">Express is a web </span><a id="_idIndexMarker217" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1162.1">application framework for Node.js. </span><span class="kobospan" id="kobo.1162.2">It provides utility functions to easily define routes for REST APIs and serve HTTP servers. </span><span class="kobospan" id="kobo.1162.3">Express is also very extensible, and there are many plugins for it in the </span><span><span class="kobospan" id="kobo.1163.1">JavaScript ecosystem.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.1164.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1165.1">While Express is the most well-known framework at the time of writing, there are also newer ones, such as </span><a id="_idIndexMarker218" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1166.1">Koa (</span><a href="https://koajs.com" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.1167.1">https://koajs.com</span></a><span class="kobospan" id="kobo.1168.1">) or</span><a id="_idIndexMarker219" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1169.1"> Fastify (</span><a href="https://fastify.dev" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.1170.1">https://fastify.dev</span></a><span class="kobospan" id="kobo.1171.1">). </span><span class="kobospan" id="kobo.1171.2">Koa is designed by the team behind Express but aims to be smaller, more expressive, and more robust. </span><span class="kobospan" id="kobo.1171.3">Fastify focuses on efficiency and low overhead. </span><span class="kobospan" id="kobo.1171.4">Feel free to check these out on your own time to see if they fit your </span><span><span class="kobospan" id="kobo.1172.1">requirements better.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1173.1">Before we can set up </span><a id="_idIndexMarker220" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1174.1">the routes, let’s take some time to set up our Express application and backend server by following </span><span><span class="kobospan" id="kobo.1175.1">these steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1176.1">First, install the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1177.1">express</span></strong></span><span><span class="kobospan" id="kobo.1178.1"> dependency:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1179.1">$ npm install express@4.18.2</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1180.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.1181.1">src/app.js</span></strong><span class="kobospan" id="kobo.1182.1"> file. </span><span class="kobospan" id="kobo.1182.2">This file will contain everything needed to set up our Express app. </span><span class="kobospan" id="kobo.1182.3">In this file, first </span><span><span class="kobospan" id="kobo.1183.1">import </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1184.1">express</span></strong></span><span><span class="kobospan" id="kobo.1185.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1186.1">
import express from 'express'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1187.1">Then create a new Express app, </span><span><span class="kobospan" id="kobo.1188.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1189.1">
const app = express()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1190.1">Now we can define routes on the Express app. </span><span class="kobospan" id="kobo.1190.2">For example, to define a GET route, we can write the </span><span><span class="kobospan" id="kobo.1191.1">following code:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1192.1">
app.get('/', (req, res) =&gt; {
  res.send('Hello from Express!')
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1193.1">We export the app to be able to use it in </span><span><span class="kobospan" id="kobo.1194.1">other files:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1195.1">
export { app }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1196.1">Next, we need to create a server and specify a port, similar to what we did before when creating an HTTP server. </span><span class="kobospan" id="kobo.1196.2">To do so, we create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.1197.1">src/index.js</span></strong><span class="kobospan" id="kobo.1198.1"> file. </span><span class="kobospan" id="kobo.1198.2">In this file, we import the </span><span><span class="kobospan" id="kobo.1199.1">Express app:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1200.1">
import { app } from './app.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1201.1">Then, we define a port, make the Express app listen to it, and log a message telling us where the server </span><span><span class="kobospan" id="kobo.1202.1">is running:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1203.1">
const PORT = 3000
app.listen(PORT)
console.info(`express server running on http://localhost:${PORT}`)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1204.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1205.1">package.json</span></strong><span class="kobospan" id="kobo.1206.1"> and add</span><a id="_idIndexMarker221" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1207.1"> a </span><strong class="source-inline1"><span class="kobospan" id="kobo.1208.1">start</span></strong><span class="kobospan" id="kobo.1209.1"> script to run </span><span><span class="kobospan" id="kobo.1210.1">our server:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1211.1">
  "scripts": {
</span><strong class="bold1"><span class="kobospan1" id="kobo.1212.1">    "start": "node src/index.js",</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1213.1">Run the backend server by executing the </span><span><span class="kobospan" id="kobo.1214.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1215.1">$ npm start</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1216.1">Now, navigate to </span><strong class="source-inline1"><span class="kobospan" id="kobo.1217.1">http://localhost:3000/</span></strong><span class="kobospan" id="kobo.1218.1"> in your browser and you will see </span><strong class="bold"><span class="kobospan" id="kobo.1219.1">Hello from Express!</span></strong><span class="kobospan" id="kobo.1220.1"> Being </span><a id="_idIndexMarker222" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1221.1">printed, just like before with the plain </span><span><span class="kobospan" id="kobo.1222.1">http server:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer043">
<span class="kobospan" id="kobo.1223.1"><img alt="Figure 3.8 – Accessing our first Express app from the browser!" src="image/B19385_03_8.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1224.1">Figure 3.8 – Accessing our first Express app from the browser!</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1225.1">That’s all there is to setting up a simple</span><a id="_idIndexMarker223" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1226.1"> Express app! </span><span class="kobospan" id="kobo.1226.2">We can now keep defining routes by using </span><strong class="source-inline"><span class="kobospan" id="kobo.1227.1">app.get()</span></strong><span class="kobospan" id="kobo.1228.1"> for GET routes, </span><strong class="source-inline"><span class="kobospan" id="kobo.1229.1">app.post()</span></strong><span class="kobospan" id="kobo.1230.1"> for POST routes, etc. </span><span class="kobospan" id="kobo.1230.2">However, before we start developing our routes, let’s take some time to improve our development environment. </span><span class="kobospan" id="kobo.1230.3">First, we should make </span><strong class="source-inline"><span class="kobospan" id="kobo.1231.1">PORT</span></strong><span class="kobospan" id="kobo.1232.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.1233.1">DATABASE_URL</span></strong><span class="kobospan" id="kobo.1234.1"> configurable so that we can change them without having to change the code. </span><span class="kobospan" id="kobo.1234.2">To do so, we are going to use </span><span><span class="kobospan" id="kobo.1235.1">environment variables.</span></span></p>
<h2 id="_idParaDest-71" class="calibre7"><a id="_idTextAnchor072" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1236.1">Using dotenv for setting environment variables</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1237.1">A good</span><a id="_idIndexMarker224" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1238.1"> way to load environment variables is</span><a id="_idIndexMarker225" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1239.1"> using </span><strong class="source-inline"><span class="kobospan" id="kobo.1240.1">dotenv</span></strong><span class="kobospan" id="kobo.1241.1">, which loads environment variables from </span><strong class="source-inline"><span class="kobospan" id="kobo.1242.1">.env</span></strong><span class="kobospan" id="kobo.1243.1"> files into our </span><strong class="source-inline"><span class="kobospan" id="kobo.1244.1">process.env</span></strong><span class="kobospan" id="kobo.1245.1">. </span><span class="kobospan" id="kobo.1245.2">This makes it easy to define environment variables for local development while keeping it possible to set them differently in, for example, a testing environment. </span><span class="kobospan" id="kobo.1245.3">Follow these steps to set </span><span><span class="kobospan" id="kobo.1246.1">up </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1247.1">dotenv</span></strong></span><span><span class="kobospan" id="kobo.1248.1">:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1249.1">Install the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1250.1">dotenv</span></strong></span><span><span class="kobospan" id="kobo.1251.1"> dependency:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1252.1">$ npm install dotenv@16.3.1</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1253.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1254.1">src/index.js</span></strong><span class="kobospan" id="kobo.1255.1">, import </span><strong class="source-inline1"><span class="kobospan" id="kobo.1256.1">dotenv</span></strong><span class="kobospan" id="kobo.1257.1"> there, and call </span><strong class="source-inline1"><span class="kobospan" id="kobo.1258.1">dotenv.config()</span></strong><span class="kobospan" id="kobo.1259.1"> to initialize the environment variables. </span><span class="kobospan" id="kobo.1259.2">We should do this before we call any other code in </span><span><span class="kobospan" id="kobo.1260.1">our app:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1261.1">
import dotenv from 'dotenv'
dotenv.config()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1262.1">Now we can start replacing our static variables with environment variables. </span><span class="kobospan" id="kobo.1262.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1263.1">src/index.js</span></strong><span class="kobospan" id="kobo.1264.1"> and replace the static port </span><strong class="source-inline1"><span class="kobospan" id="kobo.1265.1">3000</span></strong> <span><span class="kobospan" id="kobo.1266.1">with </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1267.1">process.env.PORT</span></strong></span><span><span class="kobospan" id="kobo.1268.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1269.1">
const PORT = </span><strong class="bold1"><span class="kobospan1" id="kobo.1270.1">process.env.PORT</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1271.1">We have already migrated the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1272.1">initDatabase</span></strong><span class="kobospan" id="kobo.1273.1"> function to use </span><strong class="source-inline1"><span class="kobospan" id="kobo.1274.1">process.env.DATABASE_URL</span></strong><span class="kobospan" id="kobo.1275.1"> earlier when we set up Jest. </span><span class="kobospan" id="kobo.1275.2">Now, we can edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1276.1">src/index.js</span></strong><span class="kobospan" id="kobo.1277.1"> and import </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1278.1">initDatabase</span></strong></span><span><span class="kobospan" id="kobo.1279.1"> there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1280.1">
import { initDatabase } from './db/init.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1281.1">Adjust the existing code to first call </span><strong class="source-inline1"><span class="kobospan" id="kobo.1282.1">initDatabase</span></strong><span class="kobospan" id="kobo.1283.1">, and only when the database initialized, start the Express app. </span><span class="kobospan" id="kobo.1283.2">We can now also handle errors while connecting to the database by adding a </span><span><span class="kobospan" id="kobo.1284.1">try/catch block:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1285.1">try {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1286.1">  </span></strong><strong class="bold1"><span class="kobospan1" id="kobo.1287.1">await initDatabase()</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1288.1">  </span></strong><span class="kobospan1" id="kobo.1289.1">const PORT = process.env.PORT
  app.listen(PORT)
  console.info(`express server running on http://localhost:${PORT}`)
</span><strong class="bold1"><span class="kobospan1" id="kobo.1290.1">} catch (err) {</span></strong><span class="kobospan1" id="kobo.1291.1">
  </span><strong class="bold1"><span class="kobospan1" id="kobo.1292.1">console.error('error connecting to database:', err)</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1293.1">}</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1294.1">Finally, create </span><a id="_idIndexMarker226" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1295.1">a </span><strong class="source-inline1"><span class="kobospan" id="kobo.1296.1">.env</span></strong><span class="kobospan" id="kobo.1297.1"> file in the root of the</span><a id="_idIndexMarker227" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1298.1"> project and define the two environment </span><span><span class="kobospan" id="kobo.1299.1">variables there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1300.1">
PORT=3000
DATABASE_URL=mongodb://localhost:27017/blog</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1301.1">We should exclude the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1302.1">.env</span></strong><span class="kobospan" id="kobo.1303.1"> file from the Git repository, as it is only used for local development. </span><span class="kobospan" id="kobo.1303.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1304.1">.gitignore</span></strong><span class="kobospan" id="kobo.1305.1"> and add </span><strong class="source-inline1"><span class="kobospan" id="kobo.1306.1">.env</span></strong><span class="kobospan" id="kobo.1307.1"> to it in a </span><span><span class="kobospan" id="kobo.1308.1">new line:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1309.1">
.env</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1310.1">At the moment, we have no sensible information in our environment variables, but it is still a good practice to do this already now. </span><span class="kobospan" id="kobo.1310.2">Later, we may have some credentials in the environment variables, which we do not want to accidentally push to a </span><span><span class="kobospan" id="kobo.1311.1">Git repository.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.1312.1">To make it easier for someone to get started with our project, we can create a copy of our </span><strong class="source-inline1"><span class="kobospan" id="kobo.1313.1">.env</span></strong><span class="kobospan" id="kobo.1314.1"> file and duplicate it to </span><strong class="source-inline1"><span class="kobospan" id="kobo.1315.1">.env.template</span></strong><span class="kobospan" id="kobo.1316.1">, making sure that it does not contain any sensitive credentials, of course! </span><span class="kobospan" id="kobo.1316.2">Sensitive credentials could instead be stored in, for example, a shared </span><span><span class="kobospan" id="kobo.1317.1">password manager.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1318.1">If it is still</span><a id="_idIndexMarker228" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1319.1"> running from before, stop the</span><a id="_idIndexMarker229" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1320.1"> server (by pressing </span><em class="italic"><span class="kobospan" id="kobo.1321.1">Ctrl</span></em><span class="kobospan" id="kobo.1322.1"> + </span><em class="italic"><span class="kobospan" id="kobo.1323.1">C</span></em><span class="kobospan" id="kobo.1324.1"> in the Terminal) and start it again </span><span><span class="kobospan" id="kobo.1325.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1326.1">$ npm start</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1327.1">You will get the </span><span><span class="kobospan" id="kobo.1328.1">following result:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer044">
<span class="kobospan" id="kobo.1329.1"><img alt="Figure 3.9 – Initializing the database connection and the Express server with environment variables" src="image/B19385_03_9.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1330.1">Figure 3.9 – Initializing the database connection and the Express server with environment variables</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1331.1">As we can see, </span><strong class="source-inline"><span class="kobospan" id="kobo.1332.1">dotenv</span></strong><span class="kobospan" id="kobo.1333.1"> makes it easy to maintain environment variables for development while still allowing us the possibility to change them in a continuous integration, testing, or </span><span><span class="kobospan" id="kobo.1334.1">production environment.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1335.1">You may have noticed that we need to manually restart the server after making some changes. </span><span class="kobospan" id="kobo.1335.2">This is a stark contrast to the hot reloading we got out of the box from Vite, where any changes we make are applied to the frontend in the browser instantly. </span><span class="kobospan" id="kobo.1335.3">Let’s now spend some time to improve the development experience by making the server auto-restart </span><span><span class="kobospan" id="kobo.1336.1">on changes.</span></span></p>
<h2 id="_idParaDest-72" class="calibre7"><a id="_idTextAnchor073" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1337.1">Using nodemon for easier development</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1338.1">To make our server </span><a id="_idIndexMarker230" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1339.1">auto-restart on changes, we can use the </span><strong class="source-inline"><span class="kobospan" id="kobo.1340.1">nodemon</span></strong><span class="kobospan" id="kobo.1341.1"> tool. </span><span class="kobospan" id="kobo.1341.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1342.1">nodemon</span></strong><span class="kobospan" id="kobo.1343.1"> tool allows us to run our server, similarly to the node CLI command. </span><span class="kobospan" id="kobo.1343.2">However, it offers the possibility to auto-restart the server on changes to the </span><span><span class="kobospan" id="kobo.1344.1">source files.</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1345.1">Install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1346.1">nodemon</span></strong><span class="kobospan" id="kobo.1347.1"> tool as a </span><span><span class="kobospan" id="kobo.1348.1">dev dependency:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1349.1">$ npm install –save-dev nodemon@3.0.2</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1350.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.1351.1">nodemon.json</span></strong><span class="kobospan" id="kobo.1352.1"> file in the root of your project and add the following contents </span><span><span class="kobospan" id="kobo.1353.1">to it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1354.1">
{
  "watch": ["./src", ".env", "package-lock.json"]
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1355.1">This makes sure that all code in the </span><strong class="source-inline"><span class="kobospan" id="kobo.1356.1">src/</span></strong><span class="kobospan" id="kobo.1357.1"> folder is watched for changes, and it will refresh if any files inside it are changed. </span><span class="kobospan" id="kobo.1357.2">Additionally, we specified the </span><strong class="source-inline"><span class="kobospan" id="kobo.1358.1">.env</span></strong><span class="kobospan" id="kobo.1359.1"> file in case environment variables are changed and the </span><strong class="source-inline"><span class="kobospan" id="kobo.1360.1">package-lock.json</span></strong><span class="kobospan" id="kobo.1361.1"> file in case packages are added </span><span><span class="kobospan" id="kobo.1362.1">or upgraded.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.1363.1">Now, edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1364.1">package.json</span></strong><span class="kobospan" id="kobo.1365.1"> and define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.1366.1">"dev"</span></strong><span class="kobospan" id="kobo.1367.1"> script that </span><span><span class="kobospan" id="kobo.1368.1">runs </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1369.1">nodemon</span></strong></span><span><span class="kobospan" id="kobo.1370.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1371.1">
  "scripts": {
</span><strong class="bold1"><span class="kobospan1" id="kobo.1372.1">    "dev": "nodemon src/index.js",</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1373.1">Stop the server (if it is currently running) and start it again by running the </span><span><span class="kobospan" id="kobo.1374.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1375.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1376.1">As we can see, our server is now running through </span><strong class="source-inline1"><span class="kobospan" id="kobo.1377.1">nodemon</span></strong><span class="kobospan" id="kobo.1378.1">! </span><span class="kobospan" id="kobo.1378.2">We can try it out by changing the port in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1379.1">.</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.1380.1">env</span></strong></span><span><span class="kobospan" id="kobo.1381.1"> file:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1382.1">
PORT=</span><strong class="bold1"><span class="kobospan1" id="kobo.1383.1">3001</span></strong><span class="kobospan1" id="kobo.1384.1">
DATABASE_URL=mongodb://localhost:27017/blog</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1385.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1386.1">.env.template</span></strong><span class="kobospan" id="kobo.1387.1"> as well </span><a id="_idIndexMarker231" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1388.1">to change the port </span><span><span class="kobospan" id="kobo.1389.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1390.1">3001</span></strong></span><span><span class="kobospan" id="kobo.1391.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1392.1">
PORT=</span><strong class="bold1"><span class="kobospan1" id="kobo.1393.1">3001</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1394.1">Keep the </span><span><span class="kobospan" id="kobo.1395.1">server running.</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer045">
<span class="kobospan" id="kobo.1396.1"><img alt="Figure 3.10 – Nodemon automatically restarting the server after we changed the port" src="image/B19385_03_10.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1397.1">Figure 3.10 – Nodemon automatically restarting the server after we changed the port</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1398.1">After making the change, </span><strong class="source-inline"><span class="kobospan" id="kobo.1399.1">nodemon</span></strong><span class="kobospan" id="kobo.1400.1"> automatically restarted the server for us with the new port. </span><span class="kobospan" id="kobo.1400.2">We now have something like hot reloading, but for backend development—awesome! </span><span class="kobospan" id="kobo.1400.3">Now that we have improved the developer experience on the backend, let’s start writing our API routes with Express. </span><span class="kobospan" id="kobo.1400.4">Keep the server running (via </span><strong class="source-inline"><span class="kobospan" id="kobo.1401.1">nodemon</span></strong><span class="kobospan" id="kobo.1402.1">) to see it restart and update live </span><span><span class="kobospan" id="kobo.1403.1">while coding!</span></span></p>
<h2 id="_idParaDest-73" class="calibre7"><a id="_idTextAnchor074" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1404.1">Creating our API routes with Express</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1405.1">We can now start </span><a id="_idIndexMarker232" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1406.1">creating our previously defined API routes </span><a id="_idIndexMarker233" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1407.1">with express. </span><span class="kobospan" id="kobo.1407.2">We start by defining the </span><span><span class="kobospan" id="kobo.1408.1">GET routes:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1409.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.1410.1">src/routes/posts.js</span></strong><span class="kobospan" id="kobo.1411.1"> file and import the service </span><span><span class="kobospan" id="kobo.1412.1">functions there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1413.1">
import {
  listAllPosts,
  listPostsByAuthor,
  listPostsByTag,
  getPostById,
} from '../services/posts.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1414.1">Now create and export a new function called </span><strong class="source-inline1"><span class="kobospan" id="kobo.1415.1">postsRoutes</span></strong><span class="kobospan" id="kobo.1416.1">, which takes the Express app as </span><span><span class="kobospan" id="kobo.1417.1">an argument:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1418.1">
export function postsRoutes(app) {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1419.1">In this function, define the routes. </span><span class="kobospan" id="kobo.1419.2">Start with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1420.1">GET /</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.1421.1">api/v1/posts</span></strong></span><span><span class="kobospan" id="kobo.1422.1"> route:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1423.1">
  app.get('/api/v1/posts', async (req, res) =&gt; {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1424.1">In this route, we </span><a id="_idIndexMarker234" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1425.1">need to make use of query </span><a id="_idIndexMarker235" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1426.1">params (</span><strong class="source-inline1"><span class="kobospan" id="kobo.1427.1">req.query</span></strong><span class="kobospan" id="kobo.1428.1"> in Express) to map them to the arguments of our functions. </span><span class="kobospan" id="kobo.1428.2">We want to be able to add query params for </span><strong class="source-inline1"><span class="kobospan" id="kobo.1429.1">sortBy</span></strong><span class="kobospan" id="kobo.1430.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.1431.1">sortOrder</span></strong><span class="kobospan" id="kobo.1432.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.1433.1">author</span></strong><span class="kobospan" id="kobo.1434.1">, </span><span><span class="kobospan" id="kobo.1435.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1436.1">tag</span></strong></span><span><span class="kobospan" id="kobo.1437.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1438.1">
    const { sortBy, sortOrder, author, tag } = req.query
    const options = { sortBy, sortOrder }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1439.1">Before we call our service functions, which might throw an error if we pass invalid data to the database functions, we should add a try-catch block to handle potential </span><span><span class="kobospan" id="kobo.1440.1">errors properly:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1441.1">
    try {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1442.1">We now need to check if the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1443.1">author</span></strong><span class="kobospan" id="kobo.1444.1"> or </span><strong class="source-inline1"><span class="kobospan" id="kobo.1445.1">tag</span></strong><span class="kobospan" id="kobo.1446.1"> was provided. </span><span class="kobospan" id="kobo.1446.2">If both were provided, we return a </span><strong class="source-inline1"><span class="kobospan" id="kobo.1447.1">400 Bad Request</span></strong><span class="kobospan" id="kobo.1448.1"> status code and a JSON object with an error message by </span><span><span class="kobospan" id="kobo.1449.1">calling </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1450.1">res.json()</span></strong></span><span><span class="kobospan" id="kobo.1451.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1452.1">
      if (author &amp;&amp; tag) {
        return res
          .status(400)
          .json({ error: 'query by either author or tag, not both' })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1453.1">Otherwise, we </span><a id="_idIndexMarker236" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1454.1">call the respective service function </span><a id="_idIndexMarker237" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1455.1">and return a JSON response in Express by calling </span><strong class="source-inline1"><span class="kobospan" id="kobo.1456.1">res.json()</span></strong><span class="kobospan" id="kobo.1457.1">. </span><span class="kobospan" id="kobo.1457.2">In case an error happened, we catch it, log it, and return a 500 </span><span><span class="kobospan" id="kobo.1458.1">status code:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1459.1">
      } else if (author) {
        return res.json(await listPostsByAuthor(author, options))
      } else if (tag) {
        return res.json(await listPostsByTag(tag, options))
      } else {
        return res.json(await listAllPosts(options))
      }
    } catch (err) {
      console.error('error listing posts', err)
      return res.status(500).end()
    }
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1460.1">Next, we define an API route to get a single post. </span><span class="kobospan" id="kobo.1460.2">We use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1461.1">:id</span></strong><span class="kobospan" id="kobo.1462.1"> param placeholder to be able to access it as a dynamic parameter in </span><span><span class="kobospan" id="kobo.1463.1">the function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1464.1">
  app.get('/api/v1/posts/:id', async (req, res) =&gt; {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1465.1">Now, we can access </span><strong class="source-inline1"><span class="kobospan" id="kobo.1466.1">req.params.id</span></strong><span class="kobospan" id="kobo.1467.1"> to get the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1468.1">:id</span></strong><span class="kobospan" id="kobo.1469.1"> part of our route and pass it to our </span><span><span class="kobospan" id="kobo.1470.1">service function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1471.1">
    const { id } = req.params
    try {
      const post = await getPostById(id)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1472.1">If the result of the function is </span><strong class="source-inline1"><span class="kobospan" id="kobo.1473.1">null</span></strong><span class="kobospan" id="kobo.1474.1">, we return a 404 response because the post was not found. </span><span class="kobospan" id="kobo.1474.2">Otherwise, we return the post as a </span><span><span class="kobospan" id="kobo.1475.1">JSON response:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1476.1">
      if (post === null) return res.status(404).end()
      return res.json(post)
    } catch (err) {
      console.error('error getting post', err)
      return res.status(500).end()
    }
  })
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1477.1">By default, Express</span><a id="_idIndexMarker238" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1478.1"> will return the JSON response with</span><a id="_idIndexMarker239" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1479.1"> status </span><span><span class="kobospan" id="kobo.1480.1">200 OK.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.1481.1">After defining our GET routes, we still need to mount them in our app. </span><span class="kobospan" id="kobo.1481.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1482.1">src/app.js</span></strong><span class="kobospan" id="kobo.1483.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1484.1">postsRoutes</span></strong> <span><span class="kobospan" id="kobo.1485.1">function there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1486.1">
import { postsRoutes } from './routes/posts.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1487.1">Then, call the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1488.1">postsRoutes(app)</span></strong><span class="kobospan" id="kobo.1489.1"> function after initializing our </span><span><span class="kobospan" id="kobo.1490.1">Express app:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1491.1">
const app = express()
</span><strong class="bold1"><span class="kobospan1" id="kobo.1492.1">postsRoutes(app)</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1493.1">Go to http://localhost:3001/api/v1/posts to see the route </span><span><span class="kobospan" id="kobo.1494.1">in action!</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer046">
<span class="kobospan" id="kobo.1495.1"><img alt="Figure 3.11 – Our first real API route in action!" src="image/B19385_03_11.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1496.1">Figure 3.11 – Our first real API route in action!</span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.1497.1">Tip</span></p>
<p class="callout"><span class="kobospan" id="kobo.1498.1">You can install a </span><strong class="bold"><span class="kobospan" id="kobo.1499.1">JSON Formatter</span></strong><span class="kobospan" id="kobo.1500.1"> extension</span><a id="_idIndexMarker240" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1501.1"> in your browser to format the JSON response nicely, like in </span><span><em class="italic"><span class="kobospan" id="kobo.1502.1">Figure 3</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.1503.1">.11</span></em></span><span><span class="kobospan" id="kobo.1504.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1505.1">After defining the GET routes, we need to define the POST routes. </span><span class="kobospan" id="kobo.1505.2">However, these accept a body, which will be formatted as JSON objects. </span><span class="kobospan" id="kobo.1505.3">As such, we need a way to parse this JSON body </span><span><span class="kobospan" id="kobo.1506.1">in Express.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.1507.1">Defining routes with a JSON request body</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.1508.1">To define</span><a id="_idIndexMarker241" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1509.1"> routes with a JSON request body in Express, we need to use the </span><strong class="source-inline"><span class="kobospan" id="kobo.1510.1">body-parser</span></strong><span class="kobospan" id="kobo.1511.1"> module. </span><span class="kobospan" id="kobo.1511.2">This module detects if a client sent a JSON request (by looking at the </span><strong class="source-inline"><span class="kobospan" id="kobo.1512.1">Content-Type</span></strong><span class="kobospan" id="kobo.1513.1"> header) and then automatically parses it for us so that we can access the object </span><span><span class="kobospan" id="kobo.1514.1">in </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1515.1">req.body</span></strong></span><span><span class="kobospan" id="kobo.1516.1">.</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1517.1">Install the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1518.1">body-parser</span></strong></span><span><span class="kobospan" id="kobo.1519.1"> dependency:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1520.1">$ npm install body-parser@1.20.2</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1521.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1522.1">src/app.js</span></strong><span class="kobospan" id="kobo.1523.1"> and import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1524.1">body-parser</span></strong></span><span><span class="kobospan" id="kobo.1525.1"> there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1526.1">
import bodyParser from 'body-parser'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1527.1">Now add the following code after our app is initialized to load the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1528.1">body-parser</span></strong><span class="kobospan" id="kobo.1529.1"> plugin as middleware into our </span><span><span class="kobospan" id="kobo.1530.1">Express app:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1531.1">
const app = express()
</span><strong class="bold1"><span class="kobospan1" id="kobo.1532.1">app.use(bodyParser.json())</span></strong></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.1533.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1534.1">Middleware in Express allows us to do something before and after each request. </span><span class="kobospan" id="kobo.1534.2">In this case, </span><strong class="source-inline1"><span class="kobospan" id="kobo.1535.1">body-parser</span></strong><span class="kobospan" id="kobo.1536.1"> is reading the JSON body for us, parsing it as JSON and giving us a JavaScript object that we can easily access from our route definitions. </span><span class="kobospan" id="kobo.1536.2">It should be noted that only routes defined after the middleware have access to it, so the order of defining middleware and routes </span><span><span class="kobospan" id="kobo.1537.1">is important!</span></span></p>
<ol class="calibre15">
<li value="4" class="calibre11"><span class="kobospan" id="kobo.1538.1">After </span><a id="_idIndexMarker242" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1539.1">loading the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1540.1">body-parser</span></strong><span class="kobospan" id="kobo.1541.1">, we edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1542.1">src/routes/posts.js</span></strong><span class="kobospan" id="kobo.1543.1"> and import the service functions needed to make the rest of </span><span><span class="kobospan" id="kobo.1544.1">our routes:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1545.1">  createPost,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1546.1">  updatePost,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1547.1">  deletePost,</span></strong><span class="kobospan1" id="kobo.1548.1">
} from '../services/posts.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1549.1">Now, we define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1550.1">POST /api/v1/posts</span></strong><span class="kobospan" id="kobo.1551.1"> route by using </span><strong class="source-inline1"><span class="kobospan" id="kobo.1552.1">app.post</span></strong><span class="kobospan" id="kobo.1553.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.1554.1">req.body</span></strong><span class="kobospan" id="kobo.1555.1">, inside of the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1556.1">postsRoutes</span></strong></span><span><span class="kobospan" id="kobo.1557.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1558.1">
  app.post('/api/v1/posts', async (req, res) =&gt; {
    try {
      const post = await createPost(req.body)
      return res.json(post)
    } catch (err) {
      console.error('error creating post', err)
      return res.status(500).end()
    }
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1559.1">Similarly, we can </span><a id="_idIndexMarker243" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1560.1">define the update route, where we need to make use of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1561.1">id</span></strong><span class="kobospan" id="kobo.1562.1"> param and the </span><span><span class="kobospan" id="kobo.1563.1">request body:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1564.1">
  app.patch('/api/v1/posts/:id', async (req, res) =&gt; {
    try {
      const post = await updatePost(req.params.id, req.body)
      return res.json(post)
    } catch (err) {
      console.error('error updating post', err)
      return res.status(500).end()
    }
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1565.1">Finally, we define the delete route, which does not require the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1566.1">body-parser</span></strong><span class="kobospan" id="kobo.1567.1">; we just need to get the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1568.1">id</span></strong><span class="kobospan" id="kobo.1569.1"> param here. </span><span class="kobospan" id="kobo.1569.2">We return 404 if the post was not found, and 204 No Content if the post was </span><span><span class="kobospan" id="kobo.1570.1">deleted successfully:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1571.1">
  app.delete('/api/v1/posts/:id', async (req, res) =&gt; {
    try {
      const { deletedCount } = await deletePost(req.params.id)
      if (deletedCount === 0) return res.sendStatus(404)
      return res.status(204).end()
    } catch (err) {
      console.error('error deleting post', err)
      return res.status(500).end()
    }
  })</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1572.1">As we can see, Express makes defining and handling routes, requests, and responses much easier. </span><span class="kobospan" id="kobo.1572.2">It already detects and sets headers for us, and thus it can read and send JSON responses properly. </span><span class="kobospan" id="kobo.1572.3">It also allows us to change the HTTP status </span><span><span class="kobospan" id="kobo.1573.1">code easily.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1574.1">Now that we finished defining the routes with a JSON request body, let’s allow access to our routes from other URLs </span><a id="_idIndexMarker244" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1575.1">using </span><strong class="bold"><span class="kobospan" id="kobo.1576.1">cross-origin resource </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.1577.1">sharing</span></strong></span><span><span class="kobospan" id="kobo.1578.1"> (</span></span><span><strong class="bold"><span class="kobospan" id="kobo.1579.1">CORS</span></strong></span><span><span class="kobospan" id="kobo.1580.1">).</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.1581.1">Allowing access from other URLs using CORS</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.1582.1">Browsers</span><a id="_idIndexMarker245" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1583.1"> have a safety feature to only allow us to access APIs on the same URL as the page we are currently on. </span><span class="kobospan" id="kobo.1583.2">To allow access to our backend from other URLs than the backend URL itself (for example, when we run the frontend on a different port in the next chapter), we need to allow CORS requests. </span><span class="kobospan" id="kobo.1583.3">Let’s set that up now by using the </span><strong class="source-inline"><span class="kobospan" id="kobo.1584.1">cors</span></strong><span class="kobospan" id="kobo.1585.1"> library </span><span><span class="kobospan" id="kobo.1586.1">with Express:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1587.1">Install the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1588.1">cors</span></strong></span><span><span class="kobospan" id="kobo.1589.1"> dependency:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1590.1">$ npm install cors@2.8.5</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1591.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1592.1">src/app.js</span></strong><span class="kobospan" id="kobo.1593.1"> and import </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1594.1">cors</span></strong></span><span><span class="kobospan" id="kobo.1595.1"> there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1596.1">
import cors from 'cors'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1597.1">Now add the </span><a id="_idIndexMarker246" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1598.1">following code after our app is initialized to load the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1599.1">cors</span></strong><span class="kobospan" id="kobo.1600.1"> plugin as middleware into our </span><span><span class="kobospan" id="kobo.1601.1">Express app:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1602.1">
const app = express()
</span><strong class="bold1"><span class="kobospan1" id="kobo.1603.1">app.use(cors())</span></strong><span class="kobospan1" id="kobo.1604.1">
app.use(bodyParser.json())</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1605.1">Now that CORS requests are allowed, we can start trying out the routes in </span><span><span class="kobospan" id="kobo.1606.1">a browser!</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.1607.1">Trying out the routes</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.1608.1">After</span><a id="_idIndexMarker247" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1609.1"> defining our routes, we can try them out by using the </span><strong class="source-inline"><span class="kobospan" id="kobo.1610.1">fetch()</span></strong><span class="kobospan" id="kobo.1611.1"> function in </span><span><span class="kobospan" id="kobo.1612.1">the browser:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1613.1">In your browser, go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.1614.1">http://localhost:3001/</span></strong><span class="kobospan" id="kobo.1615.1">, open the console by right-clicking on a page and clicking </span><strong class="bold"><span class="kobospan" id="kobo.1616.1">Inspect</span></strong><span class="kobospan" id="kobo.1617.1">, then go to the </span><span><strong class="bold"><span class="kobospan" id="kobo.1618.1">Console</span></strong></span><span><span class="kobospan" id="kobo.1619.1"> tab.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1620.1">In the console, enter the following code to make a GET request to get </span><span><span class="kobospan" id="kobo.1621.1">all posts:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1622.1">
fetch('http://localhost:3001/api/v1/posts')
  .then(res =&gt; res.json())
  .then(console.log)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1623.1">Now we can modify this code to make a POST request by specifying the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1624.1">Content-Type</span></strong><span class="kobospan" id="kobo.1625.1"> header to tell the server that we will be sending JSON and then sending a body with </span><strong class="source-inline1"><span class="kobospan" id="kobo.1626.1">JSON.stringify</span></strong><span class="kobospan" id="kobo.1627.1"> (as the body has to be </span><span><span class="kobospan" id="kobo.1628.1">a string):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1629.1">
fetch('http://localhost:3001/api/v1/posts'</span><strong class="bold1"><span class="kobospan1" id="kobo.1630.1">, {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1631.1">    headers: { 'Content-Type': 'application/json' },</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1632.1">    method: 'POST',</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1633.1">    body: JSON.stringify({ title: 'Test Post' })</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1634.1">})</span></strong><span class="kobospan1" id="kobo.1635.1">
  .then(res =&gt; res.json())
  .then(console.log)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1636.1">Similarly, we </span><a id="_idIndexMarker248" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1637.1">can also send a </span><strong class="source-inline1"><span class="kobospan" id="kobo.1638.1">PATCH</span></strong><span class="kobospan" id="kobo.1639.1"> request, </span><span><span class="kobospan" id="kobo.1640.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1641.1">
fetch('http://localhost:3001/api/v1/posts</span><strong class="bold1"><span class="kobospan1" id="kobo.1642.1">/642a8b15950196ee8b3437b2</span></strong><span class="kobospan1" id="kobo.1643.1">', {
    headers: { 'Content-Type': 'application/json' },
    </span><strong class="bold1"><span class="kobospan1" id="kobo.1644.1">method: 'PATCH',</span></strong><span class="kobospan1" id="kobo.1645.1">
    body: JSON.stringify({ title: 'Test Post</span><strong class="bold1"><span class="kobospan1" id="kobo.1646.1"> Changed'</span></strong><span class="kobospan1" id="kobo.1647.1"> })
})
  .then(res =&gt; res.json())
  .then(console.log)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1648.1">Make sure to replace the MongoDB IDs in the URL with the one returned from the </span><strong class="source-inline"><span class="kobospan" id="kobo.1649.1">POST</span></strong><span class="kobospan" id="kobo.1650.1"> request </span><span><span class="kobospan" id="kobo.1651.1">made before!</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.1652.1">Finally, we can send a </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1653.1">DELETE</span></strong></span><span><span class="kobospan" id="kobo.1654.1"> request:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1655.1">
fetch('http://localhost:3001/api/v1/posts/642a8b15950196ee8b3437b2', {
</span><strong class="bold1"><span class="kobospan1" id="kobo.1656.1">    method: 'DELETE',</span></strong><span class="kobospan1" id="kobo.1657.1">
})
  .then(res =&gt; </span><strong class="bold1"><span class="kobospan1" id="kobo.1658.1">res.status</span></strong><span class="kobospan1" id="kobo.1659.1">)
  .then(console.log)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1660.1">When doing a GET request, we can see that our post has now been </span><span><span class="kobospan" id="kobo.1661.1">deleted again:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1662.1">
fetch('http://localhost:3001/api/v1/posts/642a8b15950196ee8b3437b2')
  .then(res =&gt; res.status)
  .then(console.log)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1663.1">This</span><a id="_idIndexMarker249" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1664.1"> request should now return </span><span><span class="kobospan" id="kobo.1665.1">a </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1666.1">404</span></strong></span><span><span class="kobospan" id="kobo.1667.1">.</span></span></p></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.1668.1">Tip</span></p>
<p class="callout"><span class="kobospan" id="kobo.1669.1">Instead of the browser console, you can also use command line tools such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.1670.1">curl</span></strong><span class="kobospan" id="kobo.1671.1"> or apps such as Postman to make the requests. </span><span class="kobospan" id="kobo.1671.2">Feel free to use different tools to try out the requests if you are already familiar </span><span><span class="kobospan" id="kobo.1672.1">with them.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1673.1">We have now successfully defined all routes needed to handle a simple blog </span><span><span class="kobospan" id="kobo.1674.1">post API!</span></span></p>
<h1 id="_idParaDest-74" class="calibre5"><a id="_idTextAnchor075" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1675.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1676.1">The first version of our backend service is now complete, allowing us to create, read, update, and delete blog posts via a REST API (using Express), which then get stored in a MongoDB database (using Mongoose). </span><span class="kobospan" id="kobo.1676.2">Additionally, we have created service functions with unit tests, defined using the Jest test suite. </span><span class="kobospan" id="kobo.1676.3">All in all, we managed to create a solid foundation for our backend in </span><span><span class="kobospan" id="kobo.1677.1">this chapter.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1678.1">In the next chapter, </span><a href="B19385_04.xhtml#_idTextAnchor076" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.1679.1">Chapter 4</span></em></span></a><span class="kobospan" id="kobo.1680.1">, </span><em class="italic"><span class="kobospan" id="kobo.1681.1">Integrating a Frontend Using React and TanStack Query</span></em><span class="kobospan" id="kobo.1682.1">, we are going to integrate our backend into a React frontend using TanStack Query, a library to handle asynchronous state and thus data fetched from our server. </span><span class="kobospan" id="kobo.1682.2">This means that, after the next chapter, we will have developed our first </span><span><span class="kobospan" id="kobo.1683.1">full-stack application!</span></span></p>
</div>
</body></html>