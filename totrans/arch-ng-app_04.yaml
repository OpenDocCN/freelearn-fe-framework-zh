- en: Functional Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式响应式编程
- en: 'According to Wikipedia, **Functional Reactive Programming** (**FRP**) is a
    programming paradigm for reactive programming, which uses the building blocks
    of functional programming. OK, that sounds fancy, but what does it mean? To understand
    the whole sentence we need to break it apart a bit. Let''s try to define the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，**函数式响应式编程**（**FRP**）是一种响应式编程的编程范式，它使用函数式编程的构建块。好吧，这听起来很复杂，但它究竟意味着什么呢？为了理解整个句子，我们需要将其分解一下。让我们尝试定义以下内容：
- en: A **programming paradigm** is an overarching theory, or way of working, centered
    around how a program should be organized and structured. Object-oriented programming
    and functional programming are examples of programming paradigms.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编程范式**是一个涵盖性理论，或工作方式，它围绕程序应该如何组织和结构化。面向对象编程和函数式编程是编程范式的例子。'
- en: '**Reactive programming**, in short, is programming with asynchronous data streams.
    Asynchronous data streams are streams of data whose values can arrive at any point
    in time.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式编程**简而言之，是使用异步数据流的编程。异步数据流是值可以在任何时间点到达的数据流。'
- en: '**Functional programming** is a programming paradigm that takes a more mathematical
    approach, in that it sees a functional call as a mathematical computation and
    thereby avoids changing states or dealing with mutable data.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数式编程**是一种编程范式，它采用更数学化的方法，将函数调用视为数学计算，从而避免改变状态或处理可变数据。'
- en: So, in short, our Wikipedia definition means we have a functional programming
    approach to values that might arrive at any point in time. That doesn't really
    mean much, but hopefully things will have been cleared up a bit by the end of
    this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简而言之，我们的维基百科定义意味着我们有一种函数式编程方法来处理可能在任何时间点到达的值。这实际上并没有太多意义，但希望到本章结束时，事情会有所澄清。
- en: 'In this chapter, we will learn about:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: The differences between declarative and imperative programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式编程与命令式编程之间的区别
- en: Asynchronous data streams
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步数据流
- en: How these streams can be manipulated
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何操作这些流
- en: Functional programming versus imperative programming
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程与命令式编程的比较
- en: We will discuss and describe two different styles of programming, imperative
    programming and declarative programming. Functional programming is a subset of
    declarative programming. The easiest way to explain what declarative programming
    is to compare it to its opposite, imperative programming. Imperative programming
    focuses on *how* the program should achieve its result. Functional programming,
    on the other hand, is a declarative programming paradigm, which means its focus
    is on what the programming should accomplish, or the what. This is an important
    distinction.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论和描述两种不同的编程风格：命令式编程和声明式编程。函数式编程是声明式编程的一个子集。解释声明式编程的最简单方法就是将其与它的对立面——命令式编程——进行比较。命令式编程关注的是程序应该如何达到其结果。另一方面，函数式编程是一种声明式编程范式，这意味着它的重点是程序应该完成什么，或者说“什么”。这是一个重要的区别。
- en: Imperative programming versus declarative programming
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令式编程与声明式编程的比较
- en: 'Imperative programming is made up of statements that help change the program''s
    state. As mentioned before, it focuses on the *how* rather than the *what*. Let''s
    have a look at what this can look like in code to make it more clear:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程由帮助改变程序状态的语句组成。如前所述，它关注的是“如何”而不是“什么”。让我们看看代码中这可能是什么样子，以便使其更清晰：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code has the following effect: the variable `sum` is updated
    when we call `updateSum()`. We can also see that the function is very explicit
    about *how* the summation should happen.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码具有以下效果：当我们调用`updateSum()`时，变量`sum`会被更新。我们还可以看到，该函数非常明确地说明了求和应该“如何”发生。
- en: 'Declarative programming is more focused on *what* to achieve. It''s easy to
    think of this as being more high-level, because you say *what* you want to achieve.
    Let''s look at some SQL code. SQL is a declarative programming language:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式编程更关注“什么”要实现。很容易将其视为更高级的，因为你说出了你想要实现什么。让我们看看一些SQL代码。SQL是一种声明式编程语言：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we are querying a table for a number of records while telling SQL what
    we want to summarize. We are clearly carrying out the same type of action, which
    is to summarize something. The difference is that with our declarative example
    we tell SQL what we want done; we trust SQL to know to summarize.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在查询一个表以获取多个记录，同时告诉SQL我们想要汇总的内容。我们明显在进行相同类型的操作，即汇总某物。区别在于，在我们的声明性示例中，我们告诉SQL我们想要做什么；我们信任SQL知道如何汇总。
- en: First-class higher-order functions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一等高阶函数
- en: 'The term first class means that the language itself treats functions as values;
    they can be passed around as example arguments to other functions. A higher-order
    function is a function that takes other functions as parameters. Let''s look at
    an example to make this clearer:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: “一等”这个术语意味着语言本身将函数视为值；它们可以作为其他函数的参数传递。高阶函数是接受其他函数作为参数的函数。让我们通过一个例子来使这一点更清晰：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we can see that the second argument in our `project()` function is a function.
    The function is being applied to the first argument. We can also see that, depending
    on what input argument we give the higher-order function as its second argument,
    the higher-order function will behave differently.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的`project()`函数的第二个参数是一个函数。该函数被应用于第一个参数。我们还可以看到，根据我们给高阶函数作为其第二个参数的输入参数，高阶函数的行为会有所不同。
- en: Pure functions
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: 'A pure function is a function that does not have a side-effect. Nothing the
    function does will ever affect a variable outside of it. This means that the input
    argument, when used in a computation, should not cause a side-effect, such as
    talking to the filesystem or opening a network connection, for example. Let''s
    look at an example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是一个没有副作用的函数。函数所做的任何操作都不会影响它之外的变量。这意味着在计算中使用输入参数时，不应引起副作用，例如与文件系统交互或打开网络连接等。让我们来看一个例子：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we can see, our function opens up a file, loops through its rows, and calculates
    a sum of all the row contents. Unfortunately, the function talks to the filesystem,
    which is considered a side-effect. It may look a little bit contrived, but in
    a longer function it is not an impossibility to see both calculations—logging
    and talking to a database—take place, or so has been my experience. Such code
    is far from ideal, and suffers from separation of concerns and a whole lot of
    other issues. When it comes to pure functions though, it is a good idea to isolate
    the pure parts into their own functions, which would result in this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的函数打开一个文件，遍历其行，并计算所有行内容的总和。不幸的是，这个函数与文件系统进行交互，这被认为是一个副作用。这看起来可能有点牵强，但在一个更长的函数中，同时看到计算——记录日志和与数据库交互——发生，或者至少是我的经验是这样的。这样的代码远非理想，它存在关注点分离和其他许多问题。然而，当涉及到纯函数时，将纯部分隔离到它们自己的函数中是一个好主意，这将导致以下结果：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we now have two functions. We managed to isolate the pure parts
    into a function called `calculateSum()` and we ended up creating the `getRows()`
    function, which performs side-effects. Most programs have side-effects in some
    form, but your job as a programmer is to keep those functions away from pure functions
    as much as possible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在有两个函数。我们设法将纯部分隔离到一个名为`calculateSum()`的函数中，并最终创建了执行副作用的`getRows()`函数。大多数程序都以某种形式具有副作用，但作为程序员，你的任务是尽可能地将这些函数与纯函数分开。
- en: 'In reality, we have described two things here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们在这里描述了两件事：
- en: '**Pure functions**: They are more like mathematical computations that do not
    have side-effects.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯函数**：它们更像是没有副作用的数学计算。'
- en: '**Single responsibility principle** (**SRP**): Part of doing functional programming
    well is writing small and focused functions. Even though this is not a strict
    property of functional programming or pure functions, it is an important principle
    that will help you have the right mindset while adopting the functional programming
    lifestyle.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则**（**SRP**）：做好函数式编程的一部分是编写小而专注的函数。尽管这并不是函数式编程或纯函数的严格属性，但它是一个重要的原则，将帮助你采用函数式编程生活方式时拥有正确的思维方式。'
- en: One thing we didn't mention was why pure functions play an integral role in
    functional programming. They are predictable through their computational nature,
    which makes them easy to test. Building a system that mostly consists of many
    small predictable functions makes the whole system predictable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有提到的一件事是为什么纯函数在函数式编程中扮演着至关重要的角色。它们通过其计算性质是可预测的，这使得它们易于测试。构建主要由许多小型可预测函数组成的系统，使整个系统可预测。
- en: Recursion
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: '"To understand the word recursion see the word recursion."'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: “要理解递归这个词，请看递归这个词。”
- en: 'This is a standing joke at most engineering schools and it explains what it
    is in a very short way. Recursion is a mathematical concept. Let''s explain it
    a bit more. The official definition says the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在大多数工程学院中流传的一个笑话，它以非常简短的方式解释了它。递归是一个数学概念。让我们进一步解释一下。官方定义如下：
- en: Recursion is the process a procedure goes through when one of the steps of the
    procedure involves invoking the procedure itself. A procedure that goes through
    recursion is said to be 'recursive'.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是当程序的一个步骤涉及调用程序本身时，程序所经历的过程。经历递归的程序被称为“递归”。
- en: 'Ok, what does that mean in human speak? It says that at some point in running
    our function, we will call ourselves. This means we have a function that looks
    something like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这在人类语言中意味着什么？它说在运行我们的函数的某个时刻，我们将调用自己。这意味着我们有一个看起来像这样的函数：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can see that the function `something()` at some point in its body calls
    itself. A recursive function should abide to the following rules:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在函数`something()`的某个地方，它的主体调用了自身。一个递归函数应该遵守以下规则：
- en: Should call itself
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该调用自身
- en: Should eventually meet an exit condition
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终应该遇到退出条件
- en: 'If a recursive function doesn''t have an exit condition, we will run out of
    memory as the function will call itself for all eternity. There are certain types
    of problems that are more suitable than others to apply recursive programming
    to. Examples of these are:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果递归函数没有退出条件，由于函数将无限期地调用自身，我们将耗尽内存。某些类型的问题比其他类型的问题更适合应用递归编程。这些问题的例子包括：
- en: Traversing trees
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历树
- en: Compiling code
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译代码
- en: Writing algorithms for compression
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写压缩算法
- en: Sort lists
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序列表
- en: 'There are many more examples, but it''s important to remember that, although
    it''s a great tool, it shouldn''t be used everywhere. Let''s look at an example
    where recursion really shines. Our example is a linked list. A linked list consists
    of nodes that know about the node they are connected to. The code for the `Node`
    structure looks like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多更多例子，但重要的是要记住，尽管它是一个伟大的工具，但它不应该到处使用。让我们看看递归真正闪耀的例子。我们的例子是一个链表。链表由知道它们连接到的节点的节点组成。`Node`结构的代码如下：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using such a structure as a `Node`, we can construct a linked list consisting
    of several linked nodes. We can connect a set of node instances in the following
    way:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Node`这样的结构，我们可以构建由多个链接节点组成的链表。我们可以以下列方式连接一组节点实例：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A graphical representation of the preceding code would be the following diagram.
    Here, we can clearly see what our nodes consist of and how they are connected:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的图形表示如下图。在这里，我们可以清楚地看到我们的节点由什么组成以及它们是如何连接的：
- en: '![](img/f74ea5ae-b028-4afc-af5d-66e95e2bb579.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f74ea5ae-b028-4afc-af5d-66e95e2bb579.png)'
- en: 'Here, we have a linked list where we have three connected node instances. The
    head node is not connected to the node to the left. The second node however is
    connected to the first node and the first node is connected to the head node.
    The following type of operations on a list might be interesting to do:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个链表，其中我们有三个连接的节点实例。头节点没有连接到左侧的节点。然而，第二个节点连接到第一个节点，第一个节点连接到头节点。以下类型的列表操作可能很有趣：
- en: Find the head node, given any node in the list
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定链表中的任何节点，找到头节点
- en: Insert a node at a given point in the list
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在链表中给定位置插入一个节点
- en: Remove a node from a given point in the list
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从链表中给定位置删除一个节点
- en: 'Let''s have a look at how we can solve the first bullet point. Firstly, we
    will use an imperative approach and thereafter we will use a recursive approach
    to see how they differ. More importantly, let''s discuss why the recursive approach
    might be preferred:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何解决第一个要点。首先，我们将使用命令式方法，然后我们将使用递归方法来查看它们之间的区别。更重要的是，让我们讨论为什么递归方法可能更受欢迎：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we can see here, we are using a `while` loop to traverse through the list
    until we find the node instance whose `left` property is null. Now, let''s show
    the recursive approach:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们正在使用一个`while`循环遍历列表，直到我们找到`left`属性为空的节点实例。现在，让我们展示递归方法：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we check whether `startNode.left` is null. If that is
    the case, we have reached our exit condition. If we haven't reached the exit condition
    yet, we keep on calling ourselves.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们检查`startNode.left`是否为空。如果是这种情况，我们就达到了退出条件。如果我们还没有达到退出条件，我们就继续调用自己。
- en: 'Ok, so we have an imperative approach and a recursive approach. Why is the
    latter so much better? Well, with the recursive approach, we start off with a
    long list and we make the list shorter every time we call ourselves: a bit of
    a *divide and conquer* approach. One thing that clearly stands out with the recursive
    approach is that we defer execution by saying, no, our exit condition isn''t met
    yet, keep processing. Keep processing means we call ourselves as we do in our
    `if` clause. Is the point of recursive programming that we get fewer lines of
    code? Well, that could be the result, but more importantly: it changes our mindset
    toward how we go about solving problems. In imperative programming, we have a
    *let''s solve the problem from top to bottom mindset*, whereas in recursive programming,
    our mindset is more, define when we are done and slice down the problem to make
    it easier to deal with. In the preceding case, we discarded the part of our linked
    list that wasn''t interesting anymore.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们有两种方法：命令式方法和递归方法。为什么后者会好得多呢？嗯，使用递归方法，我们从一个长长的列表开始，每次调用自己时都会使列表变短：有点像一种*分而治之*的方法。递归方法中明显突出的一点是我们通过说“不，我们的退出条件还没有满足，继续处理”来推迟执行。继续处理意味着我们像在`if`子句中那样调用自己。递归编程的目的是我们得到更少的代码行数吗？嗯，这可能是一个结果，但更重要的是：它改变了我们解决问题的思维方式。在命令式编程中，我们有一种*从上到下解决问题*的思维方式，而在递归编程中，我们的思维方式更倾向于，定义何时完成，将问题切割成更容易处理的部分。在前面的例子中，我们丢弃了不再有趣的链表部分。
- en: No more loops
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有更多的循环
- en: 'One of the more significant changes when starting to code in a more functional
    way is that we get rid of `for` loops. Now that we know about recursion, we can
    just use that instead. Let''s have look at a simple imperative piece of code that
    prints an array:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始以更函数式的方式编写代码时，一个更显著的变化是我们摆脱了`for`循环。现在我们知道了递归，我们可以直接使用它。让我们看看一个简单的命令式代码片段，它打印一个数组：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The corresponding code using recursion looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归的相应代码看起来像这样：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see, our imperative code is still there in spirit. We still start
    at `0`. Moreover, we keep going until we come to the last position of our array.
    Once we hit our break condition, we exit the method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的命令式代码在精神上仍然存在。我们仍然从`0`开始。此外，我们继续进行，直到我们到达数组的最后一个位置。一旦我们达到退出条件，我们就退出方法。
- en: Reoccurring pattern
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复模式
- en: 'We haven''t really sold recursion as a concept at this point. We kind of get
    it, but are probably not convinced why good old `while` or `for` loops can''t
    be used in its place. Recursion shines when it solves problems that look like
    a reoccurring pattern. An example of that is a tree. A tree has some similar concepts
    to it such as consisting of nodes. A node without children connected to it is
    called a leaf. A node with children but that has no connection to an upward node
    is called a root node. Let''s illustrate this with a diagram:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有真正将递归作为一个概念推销出去。我们有点理解，但可能还没有说服自己为什么好的老式`while`或`for`循环不能被替换。递归在解决看起来像重复模式的问题时特别出色。一个例子就是树。树有一些类似的概念，比如由节点组成。没有子节点连接的节点被称为叶子。有子节点但没有向上节点连接的节点被称为根节点。让我们用一张图来展示这一点：
- en: '![](img/a027455b-81fd-4284-aebc-7615a806fde3.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a027455b-81fd-4284-aebc-7615a806fde3.png)'
- en: 'There are a few interesting operations that we would want to carry out on a
    tree:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在树上想要执行的一些有趣的操作包括：
- en: Summarise the node values
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结节点值
- en: Count the number of nodes
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算节点数量
- en: Calculate the width
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算宽度
- en: Calculate the depth
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算深度
- en: 'To attempt to solve that, we need to think about how to store a tree as a data
    structure. The most common way of modeling it is by creating a representation
    of a node as having a value, and a `left` property and a `right` property, then
    both those properties point to nodes in turn. Therefore, the code for said Node
    class might look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试解决这个问题，我们需要思考如何将树作为数据结构存储。最常见的方法是通过创建一个表示节点具有值、`left`属性和`right`属性的表示，然后这两个属性依次指向节点。因此，该节点类的代码可能看起来像这样：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next step is thinking how to create the tree itself. This code shows how
    we can create a tree with a root node and two children, and how to bind these
    together:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是思考如何创建树本身。此代码显示了如何创建一个具有根节点和两个子节点的树，以及如何将这些节点绑定在一起：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Worth highlighting is how the instances `left` and `right` do not have children.
    We can see that because we set their values to `null` on creation. Our root node,
    on the other hand, has the object instances `left` and `right` as children.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，实例`left`和`right`没有子节点。我们可以看到这一点，因为我们创建时将它们的值设置为`null`。另一方面，我们的根节点有对象实例`left`和`right`作为子节点。
- en: Summarise
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Thereafter, we need to think about how to summarise the nodes. Just looking
    at it, it looks like we should summarise the top node and its two children. So,
    a code implementation would start off like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们需要思考如何总结节点。仅从外观上看，这似乎意味着我们应该总结顶层节点及其两个子节点。因此，代码实现将开始如下：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'What happens if our tree grows and suddenly looks like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的树增长并突然看起来像这样：
- en: '![](img/7b191666-4c04-4430-92cd-1ce1cffaf73a.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b191666-4c04-4430-92cd-1ce1cffaf73a.png)'
- en: 'Let''s add to the preceding code so it looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向前面的代码添加一些内容，使其看起来像这样：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is technically working code, but it can be improved. What we should see
    at this point, looking at the tree, are reoccurring patterns in the tree. We have
    the following triangles:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是正常工作的代码，但可以改进。此时，我们应该在树中看到的是重复的模式。我们有以下三角形：
- en: '![](img/4987cb37-bffd-4ea5-ac9a-70ceadf7a6ce.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4987cb37-bffd-4ea5-ac9a-70ceadf7a6ce.png)'
- en: 'One triangle is made up of **2,** **3**, **5**, another one is made up of **3**,
    **1**, **2**, and the last one is made up of **5**, **4**, **2**. Every triangle
    computes its sum by taking the node itself, plus its left child and its right
    child. Recursion is all about this: discovering a reoccurring pattern and codifying
    it. We can now implement our `summarise()` function with recursion, like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个三角形由**2**、**3**、**5**组成，另一个由**3**、**1**、**2**组成，最后一个由**5**、**4**、**2**组成。每个三角形通过取节点本身，加上其左子节点和右子节点来计算其和。递归就是关于这个：发现重复的模式并将其编码化。我们现在可以使用递归来实现我们的`summarise()`函数，如下所示：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'What we are doing here is expressing our reoccurring pattern as *node + left
    node + right node*. When we call `summarise(node.left)` we simply run through
    `summarise()` again for that node. The preceding implementation is short and elegant,
    and is able to traverse the entire tree. Recursion is truly elegant once you find
    that your problem can be seen as a repeating pattern. The full code looks like
    this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是将重复的模式表示为`节点 + 左节点 + 右节点`。当我们调用`summarise(node.left)`时，我们只是再次为该节点运行`summarise()`。前面的实现既简短又优雅，能够遍历整个树。一旦你发现你的问题可以看作是一个重复的模式，递归就真正变得优雅了。完整的代码如下：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Count
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数
- en: 'Implementing a function that counts all the nodes in the trees is quite trivial
    now that we are beginning to grasp the nature of recursion. We can reuse our summary
    function from before and simply count every non-null node as `1` and null as `0`.
    So, we simply take the existing summary function and modify it to this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始理解递归的本质，实现一个计算树中所有节点数量的函数变得相当简单。我们可以重用之前的总结函数，简单地计算每个非空节点为`1`，空节点为`0`。所以，我们只需修改现有的总结函数，如下所示：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code ensures we traverse each and every node successfully. Our
    exit condition happens when we reach null. That is, we are trying to go from a
    node to one of its non-existing children.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码确保我们成功遍历了每个节点。我们的退出条件发生在我们到达null时。也就是说，我们试图从一个节点移动到其不存在的子节点之一。
- en: Width
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宽度
- en: 'To create a width function, we first need to define what we mean by width.
    Let''s have a look at our tree again:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个宽度函数，我们首先需要定义我们所说的宽度是什么。让我们再次看看我们的树：
- en: '![](img/26f8a6fa-05a3-44c1-8cd6-4266c283f05d.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26f8a6fa-05a3-44c1-8cd6-4266c283f05d.png)'
- en: 'This tree has a width of **4**. How is that? For every step down in the tree,
    our nodes expand one step to the left and one step to the right. This means that
    to calculate the width correctly, we need to traverse the edges of our tree. Every
    time we have to traverse a node to the left or to the right, we increment the
    width. What we are interested in doing from a calculation standpoint is to traverse
    the tree like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这棵树的宽度是**4**。这是怎么回事？对于树中的每一步向下，我们的节点向左和向右各扩展一步。这意味着为了正确计算宽度，我们需要遍历树的边缘。每次我们必须向左或向右遍历一个节点时，我们就会增加宽度。从计算的角度来看，我们感兴趣的是像这样遍历树：
- en: '![](img/1c0353df-bcff-4eb2-a7de-28fa7acd39fa.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c0353df-bcff-4eb2-a7de-28fa7acd39fa.png)'
- en: 'The code should therefore reflect this fact. We can implement this like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代码应该反映这一事实。我们可以这样实现：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note especially how, in the `calcWidth()` function, we call `calc()` with `node.left`
    and `node.right`, respectively, as arguments. We also add a `left` and `right`
    argument which, in the method `calc()`, means that we will keep going in that
    direction. Our exit condition is when we eventually hit null.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意在`calcWidth()`函数中，我们分别用`node.left`和`node.right`作为参数调用`calc()`。我们还添加了`left`和`right`参数，在`calc()`方法中意味着我们将继续朝那个方向前进。我们的退出条件是最终遇到null。
- en: Asynchronous data streams
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步数据流
- en: 'An asynchronous data stream is a stream of data where values are emitted, one
    after another, with a delay between them. The word asynchronous means that the
    data emitted can appear anywhere in time, after one second or even after two minutes,
    for example. A way to model asynchronous streams is to place the emitted values
    on a time axis, like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 异步数据流是一系列数据，其中值一个接一个地发出，它们之间有延迟。异步这个词意味着发出的数据可以在任何时间出现，比如一秒后甚至两分钟后。异步流的一种建模方法是将在时间轴上放置发出的值，如下所示：
- en: '![](img/f0ae8d59-f244-4005-bddf-967f0d6b328b.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0ae8d59-f244-4005-bddf-967f0d6b328b.png)'
- en: 'There are a lot of things that can be considered asynchronous. One such thing
    is fetching data through AJAX. When the data arrives depends on a number of factors,
    such as:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多事情可以被认为是异步的。其中之一是通过AJAX获取数据。数据何时到达取决于许多因素，例如：
- en: The speed of your connection
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的连接速度
- en: The responsiveness of the backend API
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端API的响应性
- en: The size of the data, and many more factors.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的大小，以及许多其他因素。
- en: The point is the data isn't arriving right at this very second.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是数据并不是在这个非常时刻到达。
- en: 'Other things that can be considered asynchronous are user initiated events,
    such as scrolling or mouse clicks. These are events that can happen at any point
    in time, depending on the user''s interaction. As such, we can consider these
    UI events as a continuous stream of data on a time axis. The following diagram
    depicts a stream of data representing a user clicking several times. Each click
    leads to a click event, **c**, which we place on a time axis:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可以被认为是异步的其他事情包括用户发起的事件，如滚动或鼠标点击。这些是在任何时间点都可能发生的事件，取决于用户的交互。因此，我们可以将这些UI事件视为时间轴上的连续数据流。以下图表描绘了代表用户多次点击的数据流。每次点击都会导致一个点击事件，**c**，我们将它放置在时间轴上：
- en: '![](img/f09aaa3a-001b-4a51-8eeb-e7232beed9fb.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f09aaa3a-001b-4a51-8eeb-e7232beed9fb.png)'
- en: 'At first glance, our diagram depicts four click events. Taking a closer look,
    we see that the click events seem grouped. The preceding diagram contains two
    pieces of information:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 初看我们的图表描绘了四个点击事件。仔细观察后，我们发现点击事件似乎被分组了。前一个图表包含以下两条信息：
- en: That a number of click events have occurred
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生了多次点击事件
- en: That the click events have occurred with a certain delay in between events
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击事件之间有特定的延迟发生
- en: Here, we can see that the two first clicks seem to happen very close together
    in time; when two events happen very close in time, this will be interpreted as
    a double-click. Therefore, our image above thus tells us about the events that
    occurred; it also tells us when and how often they occurred. Looking at the previous
    diagram, it is quite easy to distinguish between a single-click and a double-click.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到前两次点击似乎在时间上非常接近；当两个事件在时间上非常接近时，这将被解释为双击。因此，我们上面的图像告诉我们发生了哪些事件；它还告诉我们它们何时以及多久发生一次。查看前面的图表，区分单击和双击相当容易。
- en: We can assign different actions to each click behavior. A double-click might
    mean that we want to zoom-in, whereas a single-click might mean we want to select
    something; exactly what is up to the application you are writing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每种点击行为分配不同的动作。双击可能意味着我们想要放大，而单击可能意味着我们想要选择某个东西；具体取决于你正在编写的应用程序。
- en: 'A third example is that of input. What if we have a situation where the user
    is typing and stops typing after a while? After a certain amount of time has passed,
    the user expects the UI to react. This is the case with a search field. In that
    case, the user might enter something in a search field and press a search button
    when done. Another way to model that situation in a UI is to just provide a search
    field and wait for the user to stop typing as a sign of when to start searching
    for what the user wants. The final example is known as **autocomplete** behavior.
    It can be modeled in the following way:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个例子是输入的情况。如果我们有一个用户在输入一段时间后停止输入的情况呢？在经过一定时间后，用户期望UI做出反应。这就是搜索字段的情况。在这种情况下，用户可能在搜索字段中输入一些内容，并在完成后按下搜索按钮。在UI中模拟这种情况的另一种方式是提供一个搜索字段，并等待用户停止输入，作为开始搜索用户想要的内容的信号。最后一个例子被称为**自动完成**行为。它可以按以下方式建模：
- en: '![](img/9e367157-1c65-4371-aebe-77f6912e6bb7.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e367157-1c65-4371-aebe-77f6912e6bb7.png)'
- en: The first three characters entered seem to belong to the same search query,
    whereas the fourth character entered occurs a lot later and probably belongs to
    another query.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的前三个字符似乎属于同一个搜索查询，而第四个字符输入得晚得多，可能属于另一个查询。
- en: The point of this section has been to highlight that different things lend themselves
    to being modeled as streams, and that the time axis and the placement of the emitted
    values on it can come to mean something.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的在于强调不同的事物适合作为流来建模，以及时间轴上发出的值的放置可以意味着某些东西。
- en: Comparing lists to async streams – preparing for RxJS
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将列表与异步流比较——为RxJS做准备
- en: We have discussed so far how we can model asynchronous events as a continuous
    stream of data on a time axis, or stream modeling. Events can be AJAX data, mouse
    clicks, or some other type of event. Modeling things this way makes for an interesting
    perspective on things but, looking at a double-click situation for example, doesn't
    mean much unless we are able to dig out the data. There might be another case
    where there is data that we need to filter out. What we are discussing here is
    how to manipulate streams. Without that ability, stream modeling itself has no
    practical value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何将异步事件建模为时间轴上的连续数据流，或称为流建模。事件可以是AJAX数据、鼠标点击或其他类型的事件。以这种方式建模事物为事物提供了一个有趣的视角，但例如，在双击的情况下，除非我们能够挖掘出数据，否则这并没有什么意义。可能还有另一种情况，我们需要过滤掉某些数据。我们在这里讨论的是如何操作流。如果没有这种能力，流建模本身就没有实际价值。
- en: 'There are different ways to manipulate data: sometimes we want to change the
    data emitted to some other data and sometimes we might want to change how often
    the data is being emitted to a listener. Sometimes, we want our stream of data
    to become a totally different stream. We will try to model the following situations:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法来操作数据：有时我们希望将发出的数据改变为其他数据，有时我们可能希望改变数据被发送到监听器的频率。有时，我们希望我们的数据流变成一个完全不同的数据流。我们将尝试模拟以下情况：
- en: '**Projection**: Changing the data of the value being emitted'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投影**：改变发出的值的 数据'
- en: '**Filtering**: Changing what gets emitted'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤**：改变被发出的内容'
- en: Combining the functional programming paradigm with streams
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数式编程范式与流结合
- en: This chapter has covered functional programming and asynchronous data streams.
    Working with RxJS doesn't require a deep understanding of functional programming,
    but you do need to understand what declarative means, in order to focus on the
    right things. Your focus should be on what you want done, not how you want it
    done. RxJS, as a library, will take care of the how. More on that in the upcoming
    chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经涵盖了函数式编程和异步数据流。使用RxJS不需要对函数式编程有深入的了解，但你确实需要理解声明式意味着什么，以便专注于正确的事情。你的关注点应该是你想要完成的事情，而不是你想要如何完成它。作为一个库，RxJS将负责如何完成。更多内容将在下一章中介绍。
- en: These might seem like two different topics. Combining the two, however, gives
    us the ability to manipulate streams. A stream can be seen as a list of data,
    where the data is available at a certain point in time. If we start treating our
    streams as lists, especially immutable lists, then there are operations that go
    with lists that manipulate lists by applying operators to them. The result of
    the manipulation is a new list, not a mutated list. So let's start applying our
    list philosophy and its operators to the following situations.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可能看起来是两个不同的主题。然而，将它们结合起来，我们就能获得操纵流的能力。流可以被看作是一系列数据，其中数据在某个时间点可用。如果我们开始将我们的流视为列表，特别是不可变列表，那么就有一些与列表一起进行的操作，通过应用操作符来操纵列表。操纵的结果是一个新列表，而不是一个被修改的列表。所以，让我们开始应用我们的列表哲学及其操作符到以下情况。
- en: Projection
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投影
- en: '![](img/822b07eb-50f1-455e-981a-1dfa7b7481e5.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/822b07eb-50f1-455e-981a-1dfa7b7481e5.png)'
- en: 'Here, we can see that our stream is emitting the values **1**, **2**, **3**,
    and **4**, and then a manipulation happens that changes every value by incrementing
    it by one. This is quite a simple situation. If we consider this as a list, we
    can see that what we do here is simply a projection, which we would code like
    this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的流正在发出值**1**、**2**、**3**和**4**，然后发生了一个操作，将每个值增加一个。这是一个相当简单的情况。如果我们将其视为一个列表，我们可以看到我们在这里所做的只是一个投影，我们会这样编码：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Filtering
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤
- en: 'There might be some items in a list, as well as in a stream, that you do not
    want. What you do to fix that is to create a filter that filters out the unwanted
    data. Modeling our initial array, the manipulation, and the resulting array, we
    get the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和流中可能有一些你不希望的项目。为了解决这个问题，你需要创建一个过滤器来过滤掉不需要的数据。通过模拟初始数组、操作和结果数组，我们得到以下内容：
- en: '![](img/8ffa7b44-4784-472e-befd-585c97e2da97.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ffa7b44-4784-472e-befd-585c97e2da97.png)'
- en: 'In JavaScript, we can accomplish this by writing the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们可以通过编写以下代码来完成这个任务：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Combining mindsets
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合思维模式
- en: So, what are we trying to say with this section. Clearly, we have shown examples
    of how to manipulate lists. Well, what we have done is shown how we can display
    items on an axis. In that sense, we can see how it is easy to think of asynchronous
    events and lists of values in the same way, as we are graphically picturing them
    in the same way. The question is, why do we want to do that? The reason is that
    this is the mindset the RxJS library wants you to have when you start manipulating
    and crafting streams in the upcoming chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在这个部分试图表达什么？显然，我们已经展示了如何操纵列表的例子。好吧，我们所做的是展示了我们如何显示轴上的项目。从这个意义上说，我们可以看到异步事件和值列表以相同的方式思考是很容易的，因为我们以相同的方式图形化地描绘它们。问题是，我们为什么要这样做？原因在于，这正是RxJS库希望你在下一章开始操纵和制作流时拥有的心态。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'This chapter has established that we can model asynchronous events as values
    on a time axis. We introduced the idea of comparing these streams to lists and
    thereby applying functional methods to them that would not change the lists themselves
    but merely create a new list. The benefit of applying the functional paradigm
    is that we can focus on *what* to achieve rather than *how* to achieve it, thereby
    having a declarative approach. We realize it''s not easy to combine async and
    lists and create readable code from it. Fortunately, this is what the RxJS library
    does for us. It is this realization that prepares us for the coming chapter, [Chapter
    5](84bb33e0-d186-4abe-9b3f-10ba1ae911c8.xhtml), *RxJS Basics*, where we introduce
    RxJS as a library just that: create order in the async mess while modeling everything
    as a stream. With RxJS, we can truly focus on *what* rather than *how,* as it
    comes with a bunch of stream manipulation functions. After having read the next
    chapter, you will understand how RxJS works on a fundamental level, but also how
    it addresses the problems mentioned in this chapter.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经确立，我们可以将异步事件建模为时间轴上的值。我们引入了将这些流与列表进行比较的想法，并因此应用了不会改变列表本身但仅创建一个新列表的功能方法。应用函数式范式的优点在于，我们可以专注于*要实现什么*而不是*如何实现*，从而采用声明式方法。我们意识到将异步和列表结合起来并从中创建可读的代码并不容易。幸运的是，这正是RxJS库为我们做的事情。正是这种认识使我们为即将到来的第五章，*RxJS基础*，做好了准备，在那里我们介绍RxJS作为一个库：在异步混乱中创建秩序，将一切建模为流。有了RxJS，我们真正可以专注于*要实现什么*而不是*如何实现*，因为它附带了一系列流操作函数。在阅读下一章之后，你将了解RxJS在基本层面的工作原理，以及它如何解决本章中提到的问题。
