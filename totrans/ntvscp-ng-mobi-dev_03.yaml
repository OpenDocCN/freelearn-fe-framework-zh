- en: Our First View via Component Building
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过组件构建我们的第一个视图
- en: We've been working hard at framing the base of our app in [Chapter 2](part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d),
    *Feature Modules,* and now it's time to finally get a glimpse of what we're working
    with. This is all about getting that first view from our sketch to the mobile
    device screen.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在努力构建[第2章](part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d)中“功能模块”的基础，现在终于可以一窥我们所工作的内容。这全部关于将我们的草图中的第一个视图移动到移动设备屏幕上。
- en: Building views with NativeScript for Angular is not much different than view
    building for the web. We will use Angular's Component decorator to build various
    components our UI needs to achieve the desired usability we're after. Instead
    of using the HTML markup, we will be using NativeScript XML, which is an extremely
    powerful, yet simple and concise, abstraction of all native view components on
    both iOS and Android.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NativeScript 为 Angular 构建视图与网页视图构建没有太大区别。我们将使用 Angular 的组件装饰器来构建我们 UI 需要的各种组件，以实现我们追求的可用性。我们将使用
    NativeScript XML 而不是 HTML 标记，因为 NativeScript XML 是一个非常强大、简单且简洁的抽象，它代表了 iOS 和 Android
    上的所有原生视图组件。
- en: 'We won''t be covering all the benefits and types of components you have access
    to here; but to learn more, we recommend any of the following books:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会涵盖所有可用的组件的好处和类型；但若想了解更多，我们推荐以下任何一本书籍：
- en: '[https://www.packtpub.com/web-development/getting-started-nativescript](https://www.packtpub.com/web-development/getting-started-nativescript)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/web-development/getting-started-nativescript](https://www.packtpub.com/web-development/getting-started-nativescript)'
- en: '[https://www.manning.com/books/nativescript-in-action](https://www.manning.com/books/nativescript-in-action)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.manning.com/books/nativescript-in-action](https://www.manning.com/books/nativescript-in-action)'
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Using Component decorator to compose our views
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组件装饰器来组合我们的视图
- en: Creating reusable components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用组件
- en: Creating a custom view filter using Pipe
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道创建自定义视图过滤器
- en: Running the app on the iOS and Android simulators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 iOS 和 Android 模拟器上运行应用
- en: Our first view via component building
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过组件构建我们的第一个视图
- en: If we look at our sketch from [Chapter 1](part0023.html#LTSU0-289fe2426d594f99a90e4363b2c9c34d),
    *Get into Shape with @NgModule*, we can see a header at the top of the app, which
    will contain our app title with the record button to the right. We also see a
    listing of tracks with some player controls at the bottom. We can break these
    key elements of our UI design into essentially three primary components. One component
    is already provided by the NativeScript framework, the ActionBar, which we will
    use to represent the top header.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看[第1章](part0023.html#LTSU0-289fe2426d594f99a90e4363b2c9c34d)中的草图，“使用 @NgModule
    进入形状”，我们可以看到应用顶部的标题栏，其中将包含我们的应用标题和右侧的记录按钮。我们还可以看到底部的曲目列表和一些播放器控制。我们可以将这些 UI 设计的关键元素分解为基本上三个主要组件。一个组件是由
    NativeScript 框架提供的，即ActionBar，我们将用它来表示顶部标题栏。
- en: NativeScript provides many rich view components to build our UI. The markup
    is not HTML but rather XML with an `.html` extension, which may seem unusual.
    The reason the `.html` extension is used for XML view templates with NativeScript
    for Angular is that the custom renderer ([https://github.com/NativeScript/nativescript-angular](https://github.com/NativeScript/nativescript-angular))
    uses a DOM adapter to parse the view template. Each NativeScript XML component
    represents true native view widgets on each respective platform.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: NativeScript 提供了许多丰富的视图组件来构建我们的 UI。标记不是 HTML，而是具有 `.html` 扩展名的 XML，这可能会显得有些不寻常。使用
    NativeScript for Angular 的 `.html` 扩展名用于 XML 视图模板的原因是自定义渲染器（[https://github.com/NativeScript/nativescript-angular](https://github.com/NativeScript/nativescript-angular)）使用
    DOM 适配器来解析视图模板。每个 NativeScript XML 组件代表各自平台上的真实原生视图小部件。
- en: For the other two primary components, we will use Angular's Component decorator.
    It's important at this phase of the app development cycle to think about encapsulated
    pieces of UI functionality. We will encapsulate our track listing as a component
    and the player controls as another component. In this exercise, we will use an outside-in
    approach to building our UI from an abstract viewpoint down to the implementation
    details of each component.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他两个主要组件，我们将使用 Angular 的组件装饰器。在应用开发周期的这个阶段，考虑封装的 UI 功能块非常重要。我们将把我们的曲目列表封装为一个组件，并将播放器控制封装为另一个组件。在这个练习中，我们将从抽象的观点开始，逐步到每个组件的实现细节，采用自外向内的方法来构建我们的
    UI。
- en: 'To begin, let''s focus on the root component in our Angular app because it
    will define the basic layout of our first view. Open `app/app.component.html`,
    clear its contents, and replace with the following to rough out the initial UI
    concept from our sketch:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们关注我们的 Angular 应用程序中的根组件，因为它将定义我们第一个视图的基本布局。打开 `app/app.component.html`，清除其内容，并用以下内容替换，以从我们的草图草拟初始
    UI 概念：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We are expressing our view with `ActionBar` and the primary layout container
    for the main view, `GridLayout`. With NativeScript, it''s important that each
    view starts with a layout container as the root node (outside of any `ActionBar`
    or `ScrollView`), much like `div` tags that are used with HTML markup. At the
    time of this writing, there are six layout containers provided by NativeScript:
    `StackLayout`, `GridLayout`, `FlexboxLayout`, `AbsoluteLayout`, `DockLayout`,
    and `WrapLayout`. For our layout here, `GridLayout` will work well.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `ActionBar` 和主要视图的主要布局容器 `GridLayout` 来表达我们的视图。在 NativeScript 中，每个视图以一个布局容器作为根节点（在
    `ActionBar` 或 `ScrollView` 之外）开始是很重要的，就像在 HTML 标记中使用 `div` 标签一样。在撰写本文时，NativeScript
    提供了六个布局容器：`StackLayout`、`GridLayout`、`FlexboxLayout`、`AbsoluteLayout`、`DockLayout`
    和 `WrapLayout`。对于我们的布局，`GridLayout` 会工作得很好。
- en: All about the GridLayout
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 GridLayout 的所有内容
- en: The GridLayout is one of the three most used layouts you will use in your NativeScript
    application (the others are FlexboxLayout and StackLayout). This is the layout
    that allows you to build complex layouts easily.  To use the GridLayout is very
    much like the enhanced table in HTML.  You are basically going to want to take
    your screen area and divide your screen into the pieces you need. It will allow
    you to tell the columns (or rows) to be a percentage of the remaining width (and
    height) of the screen. The grid supports three types of values; **absolute size**,
    a percentage of **remaining space**, and **used space**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: GridLayout 是你在 NativeScript 应用程序中会用到的三种最常用的布局之一（其他的是 FlexboxLayout 和 StackLayout）。这是允许你轻松构建复杂布局的布局。使用
    GridLayout 非常类似于 HTML 中的增强表格。你基本上会想要将屏幕区域划分为你需要的部分。它将允许你告诉列（或行）占屏幕剩余宽度（和高度）的百分比。网格支持三种类型的值；**绝对大小**、**剩余空间**的百分比和**已用空间**。
- en: For **absolute size**, you just type in the number. For example, `100` means
    it will use 100 dp of space.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**绝对大小**，你只需输入数字。例如，`100`表示它将使用100 dp的空间。
- en: Another name for **dp** is **dip**. They are the same. A device-independent
    pixel (also density-independent pixel, DIP, or DP) is a physical unit of measurement
    based on a coordinate system held by a computer and represents an abstraction
    of a pixel for use by an application that an underlying system then converts to
    physical pixels.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**dp** 的另一个名称是 **dip**。它们是相同的。设备无关像素（也称为密度无关像素，DIP 或 DP）是基于计算机坐标系统的物理单位，代表了一个用于应用程序的像素抽象，底层系统将其转换为物理像素。'
- en: If you take the smallest iOS device supported, it has a screen width of 320dp.
    For other devices, such as tablets, some have a width of 1024 dp. So, 100 dp would
    be almost one third of an iOS phone, where it is one tenth of the screen on a
    tablet. So, this is something you need to think about when using fixed absolute
    values. It is typically better to use the used space over a fixed value, unless
    you are needing to constrain the column to a specific size.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择支持的最小 iOS 设备，它的屏幕宽度为 320dp。对于其他设备，例如平板电脑，一些设备的宽度为 1024 dp。因此，100 dp 几乎是
    iOS 手机的一个三分之一，而在平板电脑上则是屏幕的十分之一。所以，在使用固定绝对值时，你需要考虑这一点。通常，使用已用空间比使用固定值更好，除非你需要将列限制为特定大小。
- en: To use **remaining space-**based values , that is, `***`, the `***` tells it
    to use the rest of the remaining space. If the columns (or rows) is set to *`*`, `*`*,
    then space will be divided into two equal remainders of space. Likewise, `rows="*,*,*,*,*"`
    will specify five equal sized rows. You can also specify things, such as `columns="2*,3*,*",`
    and you will get three columns; the first column will be two sixth of the screen,
    the second column will be three sixth of the screen, and the final column will
    be one sixth of the screen (that is, 2+3+1 = 6).  This allows you great flexibility
    in how to use the remainder of the space.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用基于**剩余空间**的值，即 `***`，`***` 告诉它使用剩余的空间。如果列（或行）设置为 `*`，则空间将分为两个相等的剩余空间。同样，`rows="*,*,*,*,*"`
    将指定五个等大小的行。你还可以指定一些事情，例如 `columns="2*,3*,*",`，你将得到三个列；第一个列将是屏幕的六分之二，第二个列将是屏幕的六分之三，最后一个列将是屏幕的六分之一（即
    2+3+1=6）。这允许你在使用剩余空间方面有极大的灵活性。
- en: The third type of sizing is **space used**. So what happens is the content inside
    the grid is measured and then the column is assigned the size that is the max
    used in that column (or row). This is very useful when you have a grid where you
    have data but you aren't sure of the size or you don't really care; you just want
    it to look good. So, this is the auto keyword. I might have `columns="auto,auto,*,auto"`.
    This means columns 1,2, and 4 will all be automatically sized based on the content
    inside those columns; and column 3 will use whatever space is left over. This
    is very useful for laying out the entire screen or parts of the screen where you
    are looking for a certain look.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种尺寸是**空间使用**。所以，当网格内部的内容被测量后，列将被分配一个大小，这个大小是该列（或行）中使用的最大值。这在您有一个包含数据但不确定大小或您并不真的在乎的网格时非常有用；您只是希望它看起来不错。所以，这是auto关键字。我可能有`columns="auto,auto,*,auto"`。这意味着第1、2和4列将根据这些列中的内容自动调整大小；而第3列将使用剩余的空间。这对于布局整个屏幕或屏幕的某些部分非常有用，您希望达到某种特定的外观。
- en: The final reason why the GridLayout is one of the best layouts is that when
    you assign items to the GridLayout, you can actually assign multiple items to
    the same rows and/or columns and you can use row or column spans to allow items
    to use more than one row and/or column.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: GridLayout之所以是最佳布局之一，最后一个原因是当您将项目分配给GridLayout时，您实际上可以将多个项目分配给相同的行和/或列，并且您可以使用行或列跨度来允许项目使用多个行和/或列。
- en: To assign an object, you just assign it via `row="0"` and/or `col="0"` (keep
    in mind these are index-based positions). You can also use `rowSpan` and `colSpan`
    to make an element span multiple rows and/or columns. Overall, the GridLayout
    is the most versatile layout and allows you to easily create almost any layout
    you will need in your app.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要分配一个对象，您只需通过`row="0"`和/或`col="0"`进行分配（请注意，这些是基于索引的位置）。您还可以使用`rowSpan`和`colSpan`来使一个元素跨越多个行和/或列。总的来说，GridLayout是最灵活的布局，允许您轻松创建您在应用程序中需要的几乎任何布局。
- en: Back to our layout
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到我们的布局
- en: Inside the grid, we have declared a `track-list` component to represent our track
    listing, which will flex vertically, taking up all the vertical space and leaving
    only a height of 100 for `player-controls`. We indicate `track-list` as `row="0"
    col="0"`, since rows and columns are index-based. The flexible (remainder) vertical
    height is defined via the GridLayout's `*` in the rows attribute. The bottom section
    of the grid (row 1) will represent the player controls, allowing users to play/pause
    the mix and shuttle the playback position.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在网格内部，我们声明了一个`track-list`组件来表示我们的轨道列表，该组件将垂直伸缩，占据所有垂直空间，并为`player-controls`留下100像素的高度。我们将`track-list`标记为`row="0"
    col="0"`，因为行和列是基于索引的。网格的灵活（剩余）垂直高度是通过GridLayout的`*`在行属性中定义的。网格的底部部分（第1行）将代表播放器控制，允许用户播放/暂停混合并移动播放位置。
- en: Now that we have the app's primary view defined in a rather abstract way, let's
    dive into the two custom components we need to build, `track-list` and `player-controls`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经以相当抽象的方式定义了应用程序的主要视图，让我们深入了解我们需要构建的两个自定义组件，`track-list`和`player-controls`。
- en: Building TrackList component
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建TrackList组件
- en: The track list should be a listing of all the recorded tracks. Each row in the
    list should provide a single record button to re-record in addition to a name
    label for displaying the title provided by the user. It should also provide a
    switch to allow the user to solo just that particular track.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 轨道列表应该是所有已记录轨道的列表。列表中的每一行应提供一个单独的记录按钮以重新录制，以及一个名称标签来显示用户提供的标题。它还应提供一个开关，允许用户仅独奏该特定轨道。
- en: We can inject `PlayerService` and declare it `public` to allow us to bind directly
    to the service's tracks collection.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注入`PlayerService`并将其声明为`public`，以便我们可以直接绑定到服务中的轨道集合。
- en: We can also mock out some of our bindings to get things rolling like the `record`
    action. For now, let's just allow a track to be passed in and let's print out
    an inspection of that track via `LogService`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以模拟一些我们的绑定来启动一些操作，比如`record`动作。目前，我们只允许传入一个轨道，并通过`LogService`打印出该轨道的检查信息。
- en: 'Let''s start by creating `app/modules/player/components/track-list/ track-list.component.ts`(with
    a matching `.html` template):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建`app/modules/player/components/track-list/ track-list.component.ts`（与匹配的`.html`模板）开始：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For the view template `track-list.component.html`, we are going to employ the
    powerful `ListView` component. This widget represents the native UITableView ([https://developer.apple.com/reference/uikit/uitableview](https://developer.apple.com/reference/uikit/uitableview))
    on iOS and the native ListView ([https://developer.android.com/guide/topics/ui/layout/listview.html](https://developer.android.com/guide/topics/ui/layout/listview.html))
    on Android, offering 60 fps virtual scrolling with reused rows. Its performance
    is unparalleled on mobile devices:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视图模板 `track-list.component.html`，我们将使用强大的 `ListView` 组件。此小部件代表 iOS 上的原生 UITableView
    ([https://developer.apple.com/reference/uikit/uitableview](https://developer.apple.com/reference/uikit/uitableview))
    和 Android 上的原生 ListView ([https://developer.android.com/guide/topics/ui/layout/listview.html](https://developer.android.com/guide/topics/ui/layout/listview.html))，提供具有复用行的
    60 fps 虚拟滚动。在移动设备上的性能无与伦比：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There's a lot going on with this view template, so let's inspect it a bit.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图模板中有很多内容，让我们稍微检查一下。
- en: Since we made `playerService` `public` upon injection into our Component's constructor,
    we can bind directly to its tracks via the `ListView` items' attribute using standard
    Angular binding syntax expressed as `[items]`. This will be the collection our
    list will iterate on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在组件构造函数中注入 `playerService` 时将其设置为 `public`，我们可以通过 `ListView` 项的属性直接绑定到其轨道，使用标准的
    Angular 绑定语法表示为 `[items]`。这将是我们列表迭代的集合。
- en: The `template` node inside allows us to encapsulate how each row of our list
    will be laid out. It also allows us to declare a variable name (`let-track`) for
    use as our iterator reference.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`template` 节点内部允许我们封装列表每一行布局的方式。它还允许我们声明一个变量名（`let-track`），用作我们的迭代器引用。'
- en: We start with a GridLayout, since each row will contain a Record button (to
    allow a track to be re-recorded), to which we will assign a width of 75\. This
    button will be bound to the `tap` event, which will activate a recording session
    if the user is authenticated.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 GridLayout 开始，因为每一行将包含一个记录按钮（允许重新录制轨道），我们将为其分配宽度 75。此按钮将绑定到 `tap` 事件，如果用户已认证，则将激活一个录制会话。
- en: Then, we will have a Label to display a user-provided name for the track, which
    we will assign `*` to ensure it expands to fill the horizontal space in between
    our left-hand and right-hand columns. We use the text attribute to bind to `track.name`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将有一个标签来显示用户提供的轨道名称，我们将将其分配为 `*` 以确保它扩展以填充我们左侧和右侧列之间的水平空间。我们使用文本属性将其绑定到
    `track.name`。
- en: Lastly, we will use `switch` to allow the user to toggle soloing the track in
    the mix. This provides the `checked` attribute to allow us to bind our `track.solo`
    property to.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用 `switch` 允许用户切换混音中的轨道独奏。这提供了 `checked` 属性，使我们能够将 `track.solo` 属性绑定到它。
- en: Building a dialog wrapper service to prompt the user
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个对话框包装服务以提示用户
- en: If you recall from [Chapter 1](part0023.html#LTSU0-289fe2426d594f99a90e4363b2c9c34d), *Get
    Into Shape with @NgModule*, recording is a feature that should only be available
    to authenticated users. Therefore, we will want to prompt the user with a login
    dialog when they tap the Record button on each track. If they are already logged
    in, we will want to prompt them to confirm if they want to re-record the track
    for good usability.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得 [第 1 章](part0023.html#LTSU0-289fe2426d594f99a90e4363b2c9c34d) 中 *使用 @NgModule
    进入形状*，录制是一个仅应提供给认证用户的功能。因此，当用户在每条轨道上点击记录按钮时，我们将想要提示用户登录对话框。如果他们已经登录，我们将想要提示他们确认是否想要重新录制轨道，以确保良好的用户体验。
- en: We could handle this dialog directly in the Component by importing a NativeScript
    dialog service that provides a consistent API across both platforms. The `ui/dialogs`
    module from the NativeScript framework ([https://docs.nativescript.org/ui/dialogs](https://docs.nativescript.org/ui/dialogs))
    is a very convenient service, allowing you to create native alerts, confirms,
    prompts, actions, and basic login dialogs. However, we may want to provide custom
    native dialog implementations on both iOS and Android down the road for an even
    nicer UX experience. There are several plugins that provide very elegant native
    dialogs, for example, [https://github.com/NathanWalker/nativescript-fancyalert](https://github.com/NathanWalker/nativescript-fancyalert).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在组件中处理这个对话框，通过导入提供跨平台一致 API 的 NativeScript 对话框服务。NativeScript 框架的 `ui/dialogs`
    模块（[https://docs.nativescript.org/ui/dialogs](https://docs.nativescript.org/ui/dialogs)）是一个非常方便的服务，允许你创建原生警报、确认、提示、操作和基本的登录对话框。然而，我们可能希望在将来为
    iOS 和 Android 提供定制的原生对话框实现，以获得更好的 UX 体验。有几个插件提供了非常优雅的原生对话框，例如，[https://github.com/NathanWalker/nativescript-fancyalert](https://github.com/NathanWalker/nativescript-fancyalert)。
- en: To prepare for this enriched user experience, let's build a quick Angular service
    that we can inject and use everywhere, which will allow us to easily implement
    these niceties down the road.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备这个丰富的用户体验，让我们构建一个快速的 Angular 服务，我们可以注入并在任何地方使用，这将允许我们轻松地实现这些细微之处。
- en: 'Since this should be considered a `core` service to our app, let''s create `app/modules/core/services/dialog.service.ts`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这应该被视为我们应用的 `核心` 服务，让我们创建 `app/modules/core/services/dialog.service.ts`：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At first glance, this may appear incredibly wasteful! Why create a wrapper that
    provides the exact same API as a service that already exists from the NativeScript
    framework?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这可能会显得非常浪费！为什么创建一个提供与 NativeScript 框架中已存在的服务完全相同 API 的包装器？
- en: Yes, indeed, at this stage, it appears that way. However, we are preparing for
    greatness in flexibility and power with how we will handle these dialogs in the
    future. Stay tuned for a potential bonus chapter of material covering this fun
    and unique polish to the integration.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，确实如此，在这个阶段看起来是这样的。然而，我们正在为未来的灵活性及处理这些对话框的能力做准备，以实现卓越。请继续关注，可能会有关于这个有趣且独特的整合润色的额外章节。
- en: The last thing we need to do before we move on to use this service is to ensure
    it is added to our core service `PROVIDERS` collection. This will make sure Angular's
    DI system knows our new service is a valid token available for injection.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续使用此服务之前，我们需要确保它被添加到我们的核心服务 `PROVIDERS` 集合中。这将确保 Angular 的 DI 系统知道我们的新服务是一个有效的令牌，可用于注入。
- en: 'Open `app/modules/core/services/index.ts` and modify as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `app/modules/core/services/index.ts` 并按照以下方式修改：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are now ready to inject and use our new service.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好注入和使用我们的新服务。
- en: Integrating DialogService into our component
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 DialogService 集成到我们的组件中
- en: 'Let''s open up `track-list.component.ts` and inject `DialogService` for use
    in our record method. We will also need to determine if the user is logged in
    to conditionally display a login dialog or confirm prompt, so let''s also inject `AuthService`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开 `track-list.component.ts` 并注入 `DialogService` 以在我们的记录方法中使用。我们还需要确定用户是否已登录，以便有条件地显示登录对话框或确认提示，所以让我们也注入
    `AuthService`：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The record method now first checks to see whether a user is authenticated via
    the static `AuthService.CURRENT_USER` reference, which is set when `AuthService`
    is first constructed via Angular's dependency injection upon app launch (see [Chapter
    2](part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d), *Feature Modules*).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 记录方法现在首先检查用户是否通过静态 `AuthService.CURRENT_USER` 引用进行认证，该引用是在 `AuthService` 首次通过
    Angular 的依赖注入在应用启动时设置的（参见[第2章](part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d)，*功能模块*）。
- en: If a user is authenticated, we present a confirmation dialog to ensure the action
    was intentional.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已认证，我们将展示一个确认对话框以确保操作是故意的。
- en: If the user is not authenticated, we want to prompt the user to log in. To reduce
    the overload for this book, we will assume the user is already registered via
    a backend API, so we won't be asking the user to register.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户未认证，我们希望提示用户登录。为了减少本书的负担，我们假设用户已经通过后端 API 注册，因此我们不会要求用户注册。
- en: We need to implement the `promptLogin` method in `AuthService` to persist the
    user's login credentials, so every time they return to the app, it will automatically
    log them in. The record method now provides an extra optional argument `usernameAttempt`,
    which will be useful to repopulate the username field of the login prompt when
    reinitiating the login sequence after a user input validation error. We won't do
    a thorough validation of user input here, but we can at least do a lightweight
    check for a valid email.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`AuthService`中实现`promptLogin`方法以持久化用户的登录凭据，这样每次他们返回应用时，它将自动登录。记录方法现在提供了一个额外的可选参数`usernameAttempt`，这在用户在输入验证错误后重新初始化登录序列时重新填充登录提示的用户名字段时将非常有用。我们在这里不会进行彻底的用户输入验证，但我们可以至少进行轻量级的有效电子邮件检查。
- en: In your own app, you should probably do more user input validation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在你自己的应用中，你可能需要进行更多的用户输入验证。
- en: 'To maintain a clean separation of concerns, open `app/modules/core/services/auth.service.ts`
    to implement `promptLogin`. Here''s the entire service with the modifications:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持关注点的清晰分离，打开`app/modules/core/services/auth.service.ts`以实现`promptLogin`。以下是整个服务及其修改内容：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We use the `dialogService.login` method to open a native login dialog, allowing
    the user to input a username and password. Once they choose ok, we do minimal
    validation of the input and, if successful, proceed to persist the username and
    password via `DatabaseService`. Otherwise, we simply alert the user of an error
    and reject our promise, passing along the username that was entered. This allows
    us to help the user out by redisplaying the login dialog with the failed username
    they entered, so they can more easily make corrections.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`dialogService.login`方法打开一个原生登录对话框，允许用户输入用户名和密码。一旦他们选择确定，我们将对输入进行最小验证，如果成功，则通过`DatabaseService`持久化用户名和密码。否则，我们简单地提醒用户错误，并拒绝我们的承诺，传递他们输入的用户名。这允许我们通过重新显示带有失败用户名的登录对话框来帮助用户，使他们更容易进行更正。
- en: With these service level details complete, the `track-list` component is looking
    pretty good. However, there is one additional step we should take while we are
    working on this. If you recall, our TrackModel contains an order property that
    will help the user order the tracks in any way they'd like for convenience.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些服务级别的细节后，`track-list`组件看起来相当不错。然而，在我们处理这个组件的时候，我们应该采取一个额外的步骤。如果你还记得，我们的TrackModel包含一个顺序属性，这将帮助用户以任何他们希望的方式方便地对轨道进行排序。
- en: Creating an Angular Pipe - OrderBy
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Angular管道 - OrderBy
- en: 'Angular provides the Pipe decorator for ease in creating view filters. Let''s
    start by showing how we will use this in the view. You can see that it appears
    very similar to a command-line pipe used in Unix shell scripts; hence, it''s named:
    `Pipe`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了Pipe装饰器，以便轻松创建视图过滤器。让我们首先展示我们如何在视图中使用它。你可以看到它看起来非常类似于Unix shell脚本中使用的命令行管道；因此，它被命名为：`Pipe`：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will take the `playerService.tracks` collection and ensure it is ordered
    via the `order` property of each `TrackModel` for the view display.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取`playerService.tracks`集合，并确保它通过每个`TrackModel`的`order`属性进行排序，以便在视图显示中使用。
- en: 'Since we may want to use this anywhere in our app views, let''s add this pipe
    as part of `CoreModule`. Create `app/modules/core/pipes/order-by.pipe.ts` and
    here is how we will implement `OrderByPipe`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能希望在我们的应用视图中任何地方使用这个管道，让我们将其作为`CoreModule`的一部分添加。创建`app/modules/core/pipes/order-by.pipe.ts`，以下是我们将如何实现`OrderByPipe`：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We won''t go into too much detail with what is going on here, since this is
    pretty typical in JavaScript to order a collection. To finish this off, ensure
    `app/modules/core/pipes/index.ts` follows our standard convention:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过多地详细介绍这里发生的事情，因为这在大JavaScript中排序集合是很典型的。为了完成这个任务，确保`app/modules/core/pipes/index.ts`遵循我们的标准约定：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Lastly, import the preceding collection for use with `app/modules/core/core.module.ts`.
    Here is the full file with all the modifications:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，导入前面的集合以与`app/modules/core/core.module.ts`一起使用。以下是包含所有修改的完整文件：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since pipes are view level implementations, we ensure they are added as part
    of the `exports` collection to allow other modules to use them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于管道是视图级别的实现，我们确保它们作为`exports`集合的一部分添加，以便其他模块可以使用它们。
- en: Now, if we were to run our app at this point, you would notice that our `OrderBy`
    pipe used on our `track-list.component.html` view template would *NOT* work!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在这个时候运行我们的应用，你会注意到我们用于`track-list.component.html`视图模板的`OrderBy`管道将**不会**工作！
- en: Angular modules compile in isolation of one another.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Angular模块在彼此隔离的情况下编译。
- en: 'This is a critical point to understand: Angular compiles `PlayerModule` that
    declares `TrackListComponent`unto itself in an isolated sense. Since we declared `OrderByPipe`
    as part of `CoreModule` and `PlayerModule` has no dependency (at the moment) on
    `CoreModule`, the `TrackListComponent` gets compiled with no awareness of `OrderByPipe`!
    You would end up seeing this error generated in the console:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要理解的关键点：Angular将`PlayerModule`编译为声明`TrackListComponent`的自定义模块。由于我们已将`OrderByPipe`作为`CoreModule`的一部分进行声明，而`PlayerModule`目前没有对`CoreModule`的依赖，因此`TrackListComponent`在编译时对`OrderByPipe`没有任何认识！你最终会在控制台看到以下错误生成：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To remedy this, we want to make sure `PlayerModule` is aware of view-related declarations
    (such as pipes or other components) from `CoreModule` by ensuring `CoreModule`
    is added as part of the `imports` collection on `PlayerModule`. This also provides
    us with one additional convenience. If you notice, `CoreModule` specifies `NativeScriptModule`
    as an export, which means any module that imports `CoreModule` will inherently
    get `NativeScriptModule` along with it. Here are the final modifications to `PlayerModule`
    to allow everything to work together:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们想要确保`PlayerModule`了解来自`CoreModule`的视图相关声明（如管道或其他组件），通过确保`CoreModule`被添加到`PlayerModule`的`imports`集合中。这也为我们提供了一项额外的便利。如果你注意到，`CoreModule`指定了`NativeScriptModule`作为导出，这意味着任何导入`CoreModule`的模块都会自动获得`NativeScriptModule`。以下是允许一切协同工作的`PlayerModule`的最终修改：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can now move on to the `player-controls` component.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续到`player-controls`组件。
- en: Building PlayerControls component
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建`PlayerControls`组件
- en: Our player controls should contain a play/pause toggle button for the entire
    mix. It should also present a slider control to allow us to skip ahead and rewind our
    playback.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制器应该包含一个用于整个混音的播放/暂停切换按钮。它还应提供一个滑动控制，以便我们可以跳过播放和倒带。
- en: 'Let''s create `app/modules/player/components/player-controls/player-controls.component.html`(with
    a matching `.ts`):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`app/modules/player/components/player-controls/player-controls.component.html`（与匹配的`.ts`文件）：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We start with a single row `GridLayout` with an explicit 100 height. Then, the
    first column will be constrained to 75 wide to accommodate our play/pause toggle
    button. Then, the second column will take up the rest of the horizontal space,
    indicated with `*` with the `Slider` component. This component is provided by
    the NativeScript framework and allows us to bind the `maxValue` attribute to the
    total duration of our mix as well as a value to `currentTime` of the playback.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个具有显式100高度的单一行`GridLayout`开始。然后，第一列将被限制为75宽，以容纳我们的播放/暂停切换按钮。然后，第二列将占据剩余的水平空间，用`*`表示，与`Slider`组件一起。这个组件由NativeScript框架提供，允许我们将`maxValue`属性绑定到混音的总时长，以及播放的`currentTime`。
- en: 'Then, for `player-controls.component.ts`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于`player-controls.component.ts`：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For now, we have placed `currentTime` and `duration` directly on the component,
    however, we will refactor those into  `PlayerService` later. Eventually, all of
    the state related to our player will come from `PlayerService` when we implement
    plugins to handle our audio in subsequent chapters. The `togglePlay` method also
    just stubs out some general behavior, toggling the text of our button to Play
    or Stop.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将`currentTime`和`duration`直接放置在组件上，然而，我们将在稍后将其重构到`PlayerService`中。最终，当我们实现后续章节中的插件来处理我们的音频时，与播放器相关的所有状态都将来自`PlayerService`。`togglePlay`方法也只是一个通用行为的占位符，切换按钮的文本为播放或停止。
- en: Quick preview
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速预览
- en: 'At this point, we will take a quick look at what we have built so far. Currently,
    our player service returns an empty list of tracks. To see the results, we should
    add some dummy data to it. For example, in `PlayerService`, we could add:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将快速查看我们迄今为止所构建的内容。目前，我们的播放器服务返回一个空的曲目列表。为了看到结果，我们应该向其中添加一些占位符数据。例如，在`PlayerService`中，我们可以添加：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Don't be surprised if it's not pretty; we'll cover that in the next chapter.
    We also won't cover all the runtime commands available to us yet; we'll cover
    that thoroughly in [Chapter 6](part0072.html#24L8G0-289fe2426d594f99a90e4363b2c9c34d), *Running
    the app on iOS and Android*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它看起来不漂亮，请不要感到惊讶；我们将在下一章中介绍这一点。我们也不会介绍所有可用的运行时命令；我们将在[第6章](part0072.html#24L8G0-289fe2426d594f99a90e4363b2c9c34d)“在iOS和Android上运行应用”中详细介绍。
- en: Preview  on iOS
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS上的预览
- en: 'You will have to be on a Mac with XCode installed to preview the iOS app:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在一台安装了XCode的Mac上预览iOS应用：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This should launch the iOS Simulator and you should see the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该启动iOS模拟器，你应该看到以下截图：
- en: '![](img/00006.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00006.jpeg)'
- en: Preview on Android
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓预览
- en: 'You will have to have the AndroidSDKk and tools installed to preview on an
    Android emulator:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在安卓SDK和工具安装完毕后，才能在安卓模拟器上预览：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This should launch an Android emulator and you should see the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会启动一个安卓模拟器，你应该会看到以下截图：
- en: '![](img/00007.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00007.jpeg)'
- en: Congratulations! We have our first view.  Well hey, no one said it would be
    pretty yet!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们有了第一个视图。嘿，没人说过它现在就会很漂亮！
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have kicked off Part 2 with the component building, where we have laid out
    our root component `app.component.html` to house our primary view, where you learned
    about `GridLayout`, a very useful layout container.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始构建第二部分，其中我们布置了根组件`app.component.html`以容纳我们的主要视图，在那里你学习了`GridLayout`，一个非常有用的布局容器。
- en: Angular's Component decorator allowed us to easily build `TrackListComponent`
    as well as `PlayerControlsComponent`.We also learned how to build an Angular `Pipe`
    to aid our view's ability to keep our track list in order. Angular's `NgModule` taught
    us we need to ensure any view-related declarations needed for any components are imported
    properly. This Angular design pattern helps maintain module isolation as standalone
    units of code that can be intermixed by importing modules into each other.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的组件装饰器使我们能够轻松构建`TrackListComponent`和`PlayerControlsComponent`。我们还学会了如何构建一个Angular
    `Pipe`来帮助我们的视图保持跟踪列表的顺序。Angular的`NgModule`教导我们，我们需要确保任何组件所需的任何与视图相关的声明都正确导入。这种Angular设计模式有助于保持模块隔离，作为可以相互导入模块的独立代码单元。
- en: We also enhanced a fair share of our services to support some of the usability
    we desire with our components.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还增强了一部分服务，以支持我们希望与组件一起使用的某些可用性。
- en: Finally, we were able to take a quick peek at what we were building. Even though
    it's not at all pretty at this point, we can see things coming together.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们终于能够快速瞥一眼我们所构建的内容。尽管目前看起来并不美观，但我们已经能看到事物正在逐渐融合。
- en: In [Chapter 4](part0059.html#1O8H60-289fe2426d594f99a90e4363b2c9c34d), *A prettier
    view with CSS*, you will learn how to use CSS to bring out the pretty from our
    views.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](part0059.html#1O8H60-289fe2426d594f99a90e4363b2c9c34d)《使用CSS美化视图》中，你将学习如何使用CSS来从我们的视图中提取美观。
