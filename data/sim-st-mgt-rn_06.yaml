- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Using MobX as a State Manager in a React Native App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 React Native 应用中使用 MobX 作为状态管理器
- en: 'In the previous chapter, we had a chance to try the most popular state management
    solution in the `FavoritedImages` context with **Redux**. You can go back at any
    time to check what exactly was changed in the code in the GitHub repo’s folder
    for [*Chapter* *5*](B18396_05.xhtml#_idTextAnchor056): [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们有机会尝试在 `FavoritedImages` 上下文中使用最受欢迎的状态管理解决方案 **Redux**。您可以随时返回 GitHub
    仓库的文件夹 [*第 5 章*](B18396_05.xhtml#_idTextAnchor056) 检查代码中具体发生了哪些变化：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5)。
- en: 'If you’re curious to see the entire app fully migrated to Redux, please go
    to another folder: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5-complete](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5-complete).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看到整个应用完全迁移到 Redux，请访问另一个文件夹：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5-complete](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5-complete)。
- en: We’ve had a steep hill to climb so far. We talked about `FavoritedImages` with
    a state management library. In this chapter, we will talk about `FavoritedImages`
    context with a MobX state, models, and actions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们面临了一个陡峭的学习曲线。我们讨论了使用状态管理库的 `FavoritedImages`。在本章中，我们将讨论使用 MobX 状态、模型和动作的
    `FavoritedImages` 上下文。
- en: 'Here’s what this chapter will include:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将包括以下内容：
- en: Going over **MobX** concepts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复习 **MobX** 概念
- en: Configuring **MobX** in the Funbook app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Funbook 应用中配置 **MobX**
- en: Using `FavoritedImages`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `FavoritedImages`
- en: 'By the end of this chapter, you should feel comfortable using **MobX**. Not
    only will you know what **MobX** models, snapshots, and stores are but you will
    also know whether you prefer them over **Redux**! And that’s what this book is
    really about: getting to know different solutions so you can pick whichever you
    prefer for your future projects.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该能够熟练使用 **MobX**。您不仅将了解 **MobX** 模型、快照和存储是什么，而且您还将知道您是否更喜欢它们而不是 **Redux**！这正是本书的真正目的：了解不同的解决方案，以便您可以为未来的项目选择您更喜欢的方案。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to follow along with this chapter, you will need some knowledge of
    **JavaScript** and **ReactJS**. If you have followed at least *Chapters 1* to
    *4* of this book, you should be able to go forward without any issues.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章的内容，您需要了解一些 **JavaScript** 和 **ReactJS** 的知识。如果您至少跟完了本书的 *第 1 章* 到 *第
    4 章*，您应该能够无任何问题地继续前进。
- en: Feel free to use an IDE of your choice, as React Native does not need any specific
    functionality. Currently, the most popular IDEs for frontend developers are Microsoft’s
    VSCode, Atom, Sublime Text, and WebStorm.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随意使用您选择的 IDE，因为 React Native 不需要任何特定功能。目前，前端开发者中最受欢迎的 IDE 是微软的 VSCode、Atom、Sublime
    Text 和 WebStorm。
- en: The code snippets provided in this chapter are there to illustrate what we should
    be doing with the code. They do not provide the whole picture. To code along easier,
    please open the GitHub repo in your IDE and look at the files in there. You can
    either start with the file in the folder named `example-app-full` or `chapter-6`.
    If you start with `example-app-full`, you will be responsible for implementing
    the solutions described in this chapter. If you choose to look at `chapter-6`,
    you will see the entire solution implemented by me.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的代码片段旨在说明我们应该如何使用代码。它们并不提供完整的画面。为了更容易地编码，请打开您 IDE 中的 GitHub 仓库并查看其中的文件。您可以从名为
    `example-app-full` 或 `chapter-6` 的文件夹中的文件开始。如果您从 `example-app-full` 开始，您将负责实现本章中描述的解决方案。如果您选择查看
    `chapter-6`，您将看到我实现的整个解决方案。
- en: 'If you get stuck or lost, you can check the code in the GitHub repo: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-6](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-6).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到困难或迷失方向，可以检查 GitHub 仓库中的代码：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-6](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-6)。
- en: Going over MobX concepts
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习 MobX 概念
- en: As you may have noticed, my dear reader, I like to start every big section with
    a little bit of history about the piece of software that we are going to examine.
    It so happens that MobX has a very calm presence in the React community. There
    isn’t really any drama surrounding its conception or development. It was announced
    in 2015 as a solution on the blog of the company Mendix, where the creator of
    MobX, *Michel Weststrate*, used to work. The blog post details the reasons for
    creating this library, namely the fact that a pure ReactJS app in 2015 was not
    very good at managing complex states. Since then, MobX has been developed as an
    OSS library on GitHub. In 2016, it was joined by **MobX-State-Tree** (**MST**),
    a state container system for MobX. MST is to MobX what Redux Toolkit is to Redux.
    It’s an additional tool made for a better **developer experience** (**DX**), but
    it’s not required. I personally like to make my life easier, so in this book,
    we will use MST.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，亲爱的读者，我喜欢在每个大节开始时，简要介绍一下我们将要检查的软件的历史。碰巧MobX在React社区中有着非常平静的存在。它的构思或开发过程中并没有真正的戏剧性。它在2015年由Mendix公司的博客宣布，MobX的创造者*Michel
    Weststrate*曾在这里工作。博客文章详细介绍了创建这个库的原因，即2015年的纯ReactJS应用在管理复杂状态方面并不很好。从那时起，MobX已经在GitHub上作为一个开源库被开发。2016年，它加入了**MobX-State-Tree**（**MST**），这是MobX的状态容器系统。MST对于MobX来说，就像Redux
    Toolkit对于Redux一样。它是一个为更好的**开发者体验**（**DX**）而制作的额外工具，但它不是必需的。我个人喜欢让我的生活更简单，所以在这本书中，我们将使用MST。
- en: I exchanged a few messages with *Jamon Holmgren*, who is the CTO of Infinite
    Red, one of the most renowned software houses specializing in React Native, and
    the maintainer of **MST**. He said he found out about **MobX** around 5 years
    ago when his teammates were looking for alternatives to Redux. After doing a trial
    project, they really liked it and they’ve been using it ever since. It’s even
    integrated into **Ignite**, the **React Native** boilerplate by Infinite Red.
    Jamon says that “**MST’s** main advantage is that you get the central store feel
    of Redux without having to touch four or five different files for every change.
    You also get granular re-renders without having to write a single selector and
    a very natural JavaScript-y feel. Developers at Infinite Red used MST on apps
    with hundreds of screens and millions of daily active users with little issue,
    so it’s a proven state management system that works really well with React and
    React Native.” In cases where developers have to work with less structured data,
    over which they need more control, **MobX** could be the better solution over
    **MST**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我与*Jamon Holmgren*交换了几条信息，他是Infinite Red的CTO，Infinite Red是一家在React Native领域享有盛誉的软件公司，同时也是**MST**的维护者。他说他大约5年前得知**MobX**，当时他的队友们在寻找Redux的替代品。在完成一个试验项目后，他们非常喜欢它，并且一直在使用它。它甚至已经集成到Infinite
    Red的**React Native**模板**Ignite**中。Jamon说，“**MST**的主要优势是，你可以在不触及每个更改时需要触摸四个或五个不同文件的情况下，获得Redux的中心存储感觉。你还可以获得细粒度的重新渲染，而不需要编写单个选择器，并且感觉非常自然。Infinite
    Red的开发者在拥有数百个屏幕和数百万日活跃用户的App上使用MST时几乎没有问题，因此它是一个经过验证的、与React和React Native配合得非常好的状态管理系统。”在开发者需要与更不结构化的数据一起工作，并且需要更多控制的情况下，**MobX**可能比**MST**是更好的解决方案。
- en: “**MobX** still brings the observability (granular, targeted re-renders) and
    natural updates that MST has, but is much lighter weight," Jamon added.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: “**MobX**仍然带来了MST所具有的可观察性（细粒度、有针对性的重新渲染）和自然的更新，但重量更轻，”Jamon补充道。
- en: '**MobX** was created around 7 years ago, but it has stayed relevant over the
    years. Jamon says he would like to improve the **TypeScript** (**TS**) types of
    the library, but overall, he thinks the library is holding up very well thanks
    to its author’s, Michel Westrate’s, excellent engineering.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**MobX**大约7年前被创建，但多年来一直保持着相关性。Jamon说，他希望改进库的**TypeScript**（**TS**）类型，但总体来说，他认为由于作者Michel
    Weststrate出色的工程，这个库表现得非常好。'
- en: '**MobX** is currently one of the most popular state management libraries for
    **React** apps. The documentation states that it’s one of the most popular **Redux**
    alternatives. If you read the docs closely enough, you may find a few places where
    the authors allude to **MobX** being better than **Redux**. When I asked Jamon
    about this rivalry, he said, “It’s always fun to have other great communities
    to banter with. The reality is that the **MobX** community respects the **Redux**
    community a ton. Their community pushes ours to be better and improve. They make
    different trade-off decisions and one or the other might not be your particular
    style, so it’s great to have options.”'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**MobX** 目前是 **React** 应用程序中最受欢迎的状态管理库之一。文档中提到，它是最受欢迎的 **Redux** 替代方案之一。如果你仔细阅读文档，可能会发现作者暗示
    **MobX** 比起 **Redux** 更好。当我问及这种竞争关系时，Jamon 说：“与其他优秀的社区争论总是很有趣。现实是，**MobX** 社区非常尊重
    **Redux** 社区。他们的社区推动我们变得更好，并不断进步。他们做出了不同的权衡决策，可能不是你的特定风格，所以有选择权是件好事。”'
- en: The **MobX** maintainers have, of course, the full right to think the solution
    they are working on is better. Now, let’s see what you think, my dear reader!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，**MobX** 维护者有完全的权利认为他们正在工作的解决方案更好。现在，让我们看看你，亲爱的读者，是怎么想的！
- en: 'As far as **MobX** concepts and high-level ideas are concerned, there is one
    very important sentence underlined in the documentation:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 **MobX** 的概念和高级理念，文档中有一句非常重要的话被加粗了：
- en: Anything that can be derived from the application state, should be. Automatically.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 应该从应用状态中推导出任何可以推导的东西。自动地。
- en: '- The MobX Motto'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '- **MobX** 口号'
- en: This is a new concept! Anything that can be derived, should be derived automatically.
    Have we derived anything from our app state automatically before? Not really.
    At first, we created `useState` and `useEffect` hooks, coupled with **React**
    context. We had to manually update all the necessary pieces of the state whenever
    the user interacted with our app. In Redux, we wrote out actions and they passed
    the information on state updates to the reducers. We may say the state update
    happened automatically; we didn’t have to perform any additional tasks after passing
    the actions. We did, however, create the action and call it manually. We also
    know that **Redux** does not promote deriving values from the application state
    specifically. The **Redux** documentation concentrates more on immutability, the
    state being the single source of truth, and using plain functions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个新概念！任何可以推导出的东西都应该自动推导。我们之前是否自动从我们的应用状态中推导出任何东西？实际上并没有。最初，我们创建了 `useState`
    和 `useEffect` 钩子，与 **React** 上下文结合使用。每当用户与我们的应用交互时，我们必须手动更新所有必要的状态部分。在 Redux 中，我们编写了动作，并将状态更新的信息传递给
    reducer。我们可以说状态更新是自动发生的；在传递动作后，我们不需要执行任何额外的任务。然而，我们确实创建了动作并手动调用它。我们还知道 **Redux**
    并不特别提倡从应用状态中推导值。**Redux** 文档更多地集中在不可变性、状态是单一真相来源以及使用纯函数。
- en: 'The **MobX** documentation states that this library is based on transparent
    functional programming – a concept further explained in the book *MobX Quick Start
    Guide*, published by **Packt Publishing**. The philosophy of **MobX** is to be
    the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**MobX** 文档指出，这个库基于透明的函数式编程——这一概念在由 **Packt Publishing** 出版的《MobX 快速入门指南》一书中得到了进一步解释。**MobX**
    的哲学是以下这些：'
- en: '**Straightforward** – write minimalistic code and the reactivity system will
    automatically detect all changes without adding special tools or boilerplate.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**简单直接** – 编写简约的代码，反应系统将自动检测所有更改，无需添加特殊工具或样板代码。'
- en: '**Effortlessly optimal** – data changes are tracked at runtime, which means
    the computations run only when needed and we avoid unnecessary component re-renders.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**轻松优化** – 数据更改在运行时跟踪，这意味着计算只在需要时运行，我们避免了不必要的组件重新渲染。'
- en: '**Unopinionated** – **MobX** can be used with any UI framework, which makes
    your code decoupled, portable, and easily testable.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**无偏见** – **MobX** 可以与任何 UI 框架一起使用，这使得你的代码解耦、可移植，并且易于测试。'
- en: One more interesting concept in **MobX**-land is snapshots. If you have ever
    written tests for JavaScript applications, you may have heard the term “snapshot.”
    **MobX** snapshots are similar to test snapshots. They save the state of the state
    tree at a given moment in time. Looking at **MobX** snapshots can be very handy
    during debugging or for making performant state updates after fetching data from
    the server. If you want to learn more about snapshots and debugging **MobX** states,
    I invite you to take a look at the [Egghead.io](http://Egghead.io) course created
    by *Michel Westrate*, the creator of **MobX**; you can find the link in the *Further
    reading* section. As for fetching data from the server, we will look into that
    in this chapter, in the last section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **MobX**-land 中还有一个有趣的概念，那就是快照。如果你曾经为 JavaScript 应用程序编写过测试，你可能听说过“快照”这个术语。**MobX**
    快照与测试快照类似。它们在特定时间点保存状态树的状态。在调试期间查看 **MobX** 快照或在从服务器获取数据后进行高效的状态更新时，这可能会非常有用。如果你想了解更多关于快照和调试
    **MobX** 状态的信息，我邀请你查看由 **MobX** 的创造者 *Michel Westrate* 创建的 [Egghead.io](http://Egghead.io)
    课程；你可以在 *进一步阅读* 部分找到链接。至于从服务器获取数据，我们将在本章的最后部分探讨这个问题。
- en: Now, we have a very theoretical hang on the main concepts of **MobX**. We know
    it’s different from **Redux**, but you would probably like, my dear reader, to
    see some code! Let’s move on to configuring **MobX** in the Funbook app.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对 **MobX** 的主要概念有了非常理论性的了解。我们知道它与 **Redux** 不同，但亲爱的读者，你可能想看到一些代码！让我们继续在
    Funbook 应用中配置 **MobX**。
- en: Configuring MobX in the Funbook app
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Funbook 应用中配置 MobX
- en: 'As promised by the **MobX** authors, the boilerplate for this library is minimal.
    We will have to add three dependencies and a couple of files for everything to
    work correctly. Let’s start by adding the necessary dependencies by running the
    following command in the terminal:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如 **MobX** 作者所承诺的，这个库的样板代码是最小的。我们需要添加三个依赖项和一些文件，才能使一切正常工作。让我们首先通过在终端运行以下命令来添加必要的依赖项：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command will install both **MobX** and **MobX**-State-Tree. **MobX** is
    unopinionated about the UI library we want to use it with. This means that when
    we decide to use a specific UI library, we will have to find a way to get it to
    cooperate with **MobX**. It so happens that we have chosen **React Native** as
    our UI library, so we need to add an additional dependency that will make **MobX**
    cooperate smoothly with React. Let’s run the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将安装 **MobX** 和 **MobX**-State-Tree。**MobX** 对我们想要与之一起使用的 UI 库没有意见。这意味着当我们决定使用特定的
    UI 库时，我们必须找到一种方法让它与 **MobX** 合作。碰巧我们选择了 **React Native** 作为我们的 UI 库，因此我们需要添加一个额外的依赖项，以便
    **MobX** 与 React 平滑合作。让我们运行以下命令：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have our dependencies, let’s run the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了依赖项，让我们运行以下命令：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It’s a good idea to check frequently whether our app is still running correctly.
    Something as innocent as installing dependencies can sometimes break the app,
    and we want to know about any issues as soon as they arise.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 经常检查我们的应用是否仍然正常运行是个好主意。像安装依赖项这样无害的事情有时可能会破坏应用，我们希望尽快知道任何问题。
- en: Assuming everything is working as expected, we can move on to implementing **MobX**
    instead of **React**’s context in the Funbook app.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切按预期工作，我们可以继续在 Funbook 应用中实现 **MobX** 而不是 **React** 的上下文。
- en: 'A little reminder, my dear reader, about the code: the code related to this
    chapter can be found in the `chapter-6` folder of this book''s repository: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-6](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-6).
    If you prefer to follow along on your own, please copy the `example-app-full`
    folder and start working from there.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小提醒，亲爱的读者，关于代码：与本章相关的代码可以在这本书的仓库的 `chapter-6` 文件夹中找到：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-6](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-6)。如果你更喜欢自己跟随，请复制
    `example-app-full` 文件夹并从这里开始工作。
- en: Using MobX for FavoritedImages
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 FavoritedImages 中使用 MobX
- en: At the beginning of this book, I made a choice, my dear reader, to write all
    examples in **JavaScript**. I have come to regret that decision while working
    on the examples with **MobX**. **MobX** documentation uses **TS**, a **JavaScript**
    superset, which brings many advantages. I encourage you my dear reader to learn
    about **TS**. I will not spend any more time on this topic as there are hundreds
    of hugely valuable TS resources both online and in book form, but I wanted to
    let you know, in case you read the **MobX** documentation, that the examples look
    a little different from the code in this book.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的开头，我亲爱的读者，我做出了一个选择，那就是用 **JavaScript** 编写所有示例。在用 **MobX** 编写示例时，我对此决定感到后悔。**MobX**
    文档使用 **TS**，这是 **JavaScript** 的超集，它带来了许多优势。我鼓励我的亲爱的读者去了解 **TS**。我不会在这个话题上花费更多时间，因为网上和书籍中都有数百种非常有价值的
    **TS** 资源，但我想要让你知道，以防你阅读 **MobX** 文档，示例看起来与这本书中的代码略有不同。
- en: Now that we have all of this out of the way, let’s get to coding! We will create
    a new folder called `models` where we will store data models for our app. The
    term “data models” may sound very serious to you, but don’t worry. **MobX** data
    models are nothing more than **JavaScript** objects with superpowers – by which
    I mean to say, they look like simple **JavaScript** objects, but they are capable
    of doing much more!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经把这些都弄清楚了，让我们开始编码！我们将创建一个名为 `models` 的新文件夹，我们将在这个文件夹中存储我们应用程序的数据模型。术语“数据模型”可能听起来非常严肃，但请放心。**MobX**
    数据模型不过是带有超级能力的 **JavaScript** 对象——我的意思是，它们看起来像简单的 **JavaScript** 对象，但它们能够做更多的事情！
- en: When we have a couple of models ready, we will create one more file for our
    global `store.js` and we will place all the logic for fetching and managing liked
    images in this file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有几个模型准备就绪时，我们将为我们的全局 `store.js` 创建一个额外的文件，并将获取和管理喜欢图像的所有逻辑放在这个文件中。
- en: 'Let’s start by creating the simplest model: for the user. We won’t be implementing
    actual user state changes, but we’ll just take a quick look at what **MobX** models
    look like in real-world implementation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建最简单的模型：用户的模型。我们不会实现实际的用户状态变更，但我们会快速看一下在现实世界的实现中 **MobX** 模型是什么样的：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We only need to import one item: types from `mobx-state-tree`. These types
    are very powerful tools in **MobX**. You can declare very simple types, such as
    the ones here – a string and a Boolean – but you can also declare that these values
    are optional, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要导入一个项目：来自 `mobx-state-tree` 的 `types`。这些类型是 **MobX** 中非常强大的工具。你可以声明非常简单的类型，就像这里的一样——一个字符串和一个布尔值——但你也可以声明这些值是可选的，如下所示：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also tell `""` symbols after the `types.string` definition in the preceding
    example signify), or that a given value may be undefined, like so:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在先前的示例中 `types.string` 定义后面的 `""` 符号表示），或者一个给定的值可能是未定义的，如下所示：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are many more types out there, but we won’t be covering all of them. However,
    the MST documentation has a very thorough section on types, and you can find a
    link to this in the *Further* *reading* section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他类型，但我们不会涵盖所有这些。然而，MST 文档有一个关于类型的非常详尽的章节，你可以在 *进一步* *阅读* 部分找到这个链接。
- en: You may have noticed that `types.model` is also at the very beginning of the
    declaration. This is what indicates to **MobX** that we are describing the shape
    of our data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 `types.model` 也位于声明的非常开始的位置。这就是告诉 **MobX** 我们正在描述我们数据形状的标志。
- en: Our `Users` model is very simple. We used it to get a first glance at `LikedImages`
    model.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Users` 模型非常简单。我们用它来初步了解 `LikedImages` 模型。
- en: 'We start again by importing `types` from `mobx-state-tree` and declaring the
    shape of a single `LikedImage` item:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次开始，通过从 `mobx-state-tree` 导入 `types` 并声明单个 `LikedImage` 项的形状：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We added a few properties to the `LikedImageItem` model. We will use those properties
    in the future to display the necessary data on the `Favorited` surface. It just
    so happens that these properties are present in the image items fetched from the
    server.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `LikedImageItem` 模型中添加了一些属性。我们将在未来使用这些属性在 `Favorited` 表面上显示必要的数据。恰好这些属性存在于从服务器获取的图像项中。
- en: 'Now that the single image model has been described, we can move on to setting
    up the array of identical images and the actions related to this array:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经描述了单个图像模型，我们可以继续设置相同图像的数组以及与此数组相关的操作：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Starting from the top, you will notice that we are declaring an object called
    `imageList`, which will store an array of `LikedImageItems`, and will be instantiated
    with the default value of an empty array.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，您会注意到我们正在声明一个名为 `imageList` 的对象，它将存储一个 `LikedImageItems` 的数组，并将使用空数组的默认值进行实例化。
- en: 'The `LikedImageItem` model doesn’t do anything interesting, so let’s move on
    to the `LikedImages` array. We have to add a `types.model`, where we tell our
    state manager that this piece of state will be an array of `LikedImageItems` –
    and then we add placeholders for the two functions that need to be created: adding
    and removing liked images.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`LikedImageItem` 模型并没有做什么有趣的事情，所以我们继续到 `LikedImages` 数组。我们必须添加一个 `types.model`，告诉我们的状态管理器这个状态片段将是一个
    `LikedImageItems` 的数组——然后我们添加两个需要创建的函数的占位符：添加和删除喜欢的图片。'
- en: We can now continue setting up **MobX** in our app. First of all, we will set
    up a store – similarly to **Redux**-managed apps, this will be the source of truth
    for the app. We will then fetch data from the server and pass it to the app. Once
    we have all of that ready, we will look at **MobX** actions – events to which
    our models will need to respond. Last, but not least, we’ll learn about deriving
    data from the state.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续在我们的应用程序中设置 **MobX**。首先，我们将设置一个存储——类似于 **Redux** 管理的应用程序，这将成为应用程序的真相来源。然后我们将从服务器获取数据并将其传递给应用程序。一旦我们准备好了所有这些，我们将查看
    **MobX** 动作——我们的模型需要响应的事件。最后，但同样重要的是，我们将了解从状态中推导数据。
- en: Creating the store
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建存储
- en: Before adding and removing images, there’s one more step we need to take. What
    do you think, my dear reader? Yes, we need to hook up the store!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加和删除图片之前，我们还需要采取一个步骤。亲爱的读者，您认为呢？是的，我们需要连接到存储！
- en: 'Let’s go to our `store.js` file and tell it to use the `User` and `LikedImages`
    models. We’ll start by importing all the necessary files and creating an empty
    store:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到我们的 `store.js` 文件，并告诉它使用 `User` 和 `LikedImages` 模型。我们将首先导入所有必要的文件并创建一个空的存储：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you may remember, my dear reader, **MobX** and **MST** are unopinionated
    as far as the UI is concerned. This means we need to look for detailed instructions
    on how to best integrate **MST** with our **React Native** app. It just so happens
    that the documentation recommends using **React**’s context to share trees between
    components. Our example is small so far and we will concentrate on one tree (the
    favorited images); however, it’s good to get set up correctly for our app to scale.
    And also: we understand context very well from the previous chapters, right? So,
    this is going to be a piece of cake:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记，亲爱的读者，**MobX** 和 **MST** 在UI方面都是无偏见的。这意味着我们需要寻找如何将 **MST** 与我们的 **React
    Native** 应用程序最佳集成的详细说明。碰巧的是，文档建议使用 **React** 的上下文在组件之间共享树。我们的例子目前还很小，我们将专注于一个树（收藏的图片）；然而，为我们的应用程序扩展正确设置是很重要的。还有：我们不是从之前的章节中很好地理解了上下文，对吧？所以，这将是一件轻而易举的事情：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we are creating a very simple context, which will be
    the vessel for `useMst` hook (as in, “use `null` and we will pass the real store
    when we add the `<Provider>` to our app:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个非常简单的上下文，它将成为 `useMst` 钩子的载体（也就是说，“使用 `null`，当我们向应用程序添加 `<Provider>`
    时，我们将传递真实的存储）：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Remember to wrap your app in the `Provide`r created for the **MobX** state.
    This is what is shown in the preceding code snippet.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将您的应用程序包裹在为 **MobX** 状态创建的 `Provide`r 中。这就是前面代码片段中显示的内容。
- en: 'Now that we’ve declared the store and our models, wrapped the app in a `Provider`,
    and passed the store to this `Provider`, we need to pull in the data from `ListOfFavorited.js`
    and replace the pure **React** context used previously with **MobX** data:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明了存储和我们的模型，将应用程序包裹在 `Provider` 中，并将存储传递给这个 `Provider`，我们需要从 `ListOfFavorited.js`
    中拉取数据，并用之前使用的纯 **React** 上下文替换 **MobX** 数据：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is going pretty nicely, don’t you think? We have our `ListOfFavoritedImages`
    component ready! Yes? Let’s check in the app:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这进行得相当顺利，不是吗？我们的 `ListOfFavoritedImages` 组件已经准备好了！是的？让我们检查一下应用程序：
- en: '![Figure 6.1 – Favorited surface with no images ](img/Figure_6.01_B18396.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 没有图片的收藏表面](img/Figure_6.01_B18396.jpg)'
- en: Figure 6.1 – Favorited surface with no images
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 没有图片的收藏表面
- en: All we see is a blank screen on the **Favorited** surface. What happened? We
    forgot to fetch the images! Let’s see how to do that in the next section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Favorited** 表面上，我们只看到了一个空白屏幕。发生了什么？我们忘记获取图片了！让我们看看如何在下一节中做到这一点。
- en: Fetching data
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取数据
- en: 'We have our image list stored on the server. **MobX**-**State**-**Tree** proposes
    two ways of fetching asynchronous data, but both are actions. Let’s create an
    action in the store:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在服务器上存储了图像列表。**MobX**-**State**-**Tree**提出了两种获取异步数据的方法，但两者都是操作。让我们在存储中创建一个操作：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We need an asynchronous function that will do the fetching – we have called
    it `fetchImages`. This function uses JavaScript’s `fetch` function and returns
    data from the server. Now that we have the data, we need to pass it into the `LikedImages`
    model. Let’s add a function that will do just that:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个异步函数来执行获取操作——我们将其命名为`fetchImages`。这个函数使用了JavaScript的`fetch`函数，并从服务器返回数据。现在我们有了数据，我们需要将其传递给`LikedImages`模型。让我们添加一个函数来完成这项工作：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The newly added `setLikedImages` function takes care of replacing the entire
    array of images with anything that’s passed to it. We also adjusted the `fetchImages`
    function, to pass the result of the fetch into `setLikedImages`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的`setLikedImages`函数负责用传递给它的任何内容替换整个图像数组。我们还调整了`fetchImages`函数，以便将获取的结果传递给`setLikedImages`。
- en: 'Now that we have told our app where to get the data from and where to put it,
    we only need to add WHEN. We could call the `store.fetchImages()` function directly
    from the app when it’s rendered. However, there is a more elegant solution: using
    the life cycle hooks provided by `afterCreate`, and it’s called, as you may expect,
    after a given store is created. Let’s add this hook to the list of actions in
    our store:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经告诉我们的应用从哪里获取数据以及将其放在哪里，我们只需要添加“何时”。我们可以在应用渲染时直接从应用中调用`store.fetchImages()`函数。然而，有一个更优雅的解决方案：使用`afterCreate`提供的生命周期钩子，正如你可能预期的，它是在创建给定存储之后调用的。让我们将这个钩子添加到我们存储中的操作列表中：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Ta-da! Our app will know what to fetch (the data from the server), where to
    put it once it’s fetched (in the `LikedImages` array), and when to do so (when
    the store is created). If you check the app now, you should see the list of images
    rendered correctly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们的应用将知道从哪里获取数据（服务器上的数据），一旦获取到数据后将其放在哪里（在`LikedImages`数组中），以及何时进行操作（当存储创建时）。如果你现在检查应用，你应该能看到正确渲染的图像列表。
- en: 'The code we wrote works fine, but we can improve it further. **MobX** and **MST**
    offer us optimized solutions for writing async logic. Their solution is called
    generator functions. This may sound scary at first, but don’t worry. All we need
    to do is import a couple of utilities from MST and change the syntax of our function
    slightly:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的代码运行良好，但我们可以进一步改进它。**MobX**和**MST**为我们提供了编写异步逻辑的优化解决方案。他们的解决方案被称为生成器函数。一开始这可能听起来有些吓人，但别担心。我们只需要从MST导入几个实用工具，并稍微改变一下函数的语法：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `fetchImages` function in this version uses a generator. For `flow` and
    use `*` with the `function` keyword. Then, we replace `async`/`await` with `yield`,
    which pauses the function and returns a `Promise`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的`fetchImages`函数使用了生成器。对于`flow`，使用`*`与`function`关键字一起。然后，我们将`async`/`await`替换为`yield`，这会暂停函数并返回一个`Promise`。
- en: As you may have noticed, we removed the `setLikedImages` action in this version
    of the code. It is not needed anymore, as we’re using another `applySnapshot`.
    I’ve mentioned briefly before what snapshots in `applySnapshot` utility here,
    we are making sure the update is optimized, as only the necessary data is updated.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，我们在这一版本的代码中移除了`setLikedImages`操作。它不再需要，因为我们正在使用另一个`applySnapshot`。我之前简要地提到了`applySnapshot`实用工具中的快照，我们确保更新是优化的，因为只有必要的数据被更新。
- en: This version of the code produces the same result as the previous one. However,
    it is written in fewer lines of code and uses practices recommended by the authors
    of **MobX**. It’s a good idea to write code in the recommended way – it helps
    us avoid bugs and performance issues. We surely know less about **MobX** than
    its author and maintainers, so let’s follow their lead.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码版本的输出结果与上一个版本相同。然而，它使用了更少的代码行，并且采用了**MobX**作者推荐的最佳实践。按照推荐的方式编写代码是个好主意——这有助于我们避免错误和性能问题。我们关于**MobX**的了解肯定不如其作者和维护者多，所以让我们跟随他们的脚步。
- en: Okay – we’re making great progress here. We have the data models and we have
    wired them up into a store. We passed the store into our app thanks to a `Provider`,
    and we fetched the initial data. The only thing left is to add actions and make
    this app come alive!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——我们在这里取得了很大的进展。我们已经有了数据模型，并将它们连接到了存储中。我们通过`Provider`将存储传递到我们的应用中，并获取了初始数据。现在唯一剩下的事情就是添加操作，让这个应用活跃起来！
- en: Adding actions
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加操作
- en: 'Let’s go back to our `LikedImages` model and add some real code for the `addImages`
    action:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`LikedImages`模型，并为`addImages`操作添加一些真正的代码：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `actions` function itself holds a reference to the entire array of liked
    images – this is the `self` keyword. In the first iteration of the `this`. `this`
    can unfortunately be confusing for many developers, which is why `self`. Plus,
    **MobX** realizes that if you’re doing an action on a model, you probably need
    access to that model, so it serves us what we need!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`actions`函数本身持有整个喜欢图片数组的引用——这就是`self`关键字。在`this`的第一个迭代中，`this`对于许多开发者来说可能很令人困惑，这就是为什么使用`self`。此外，**MobX**意识到如果你在一个模型上执行操作，你可能需要访问该模型，所以它为我们提供了我们需要的东西！'
- en: Now that we have a reference to the `LikedImages` array, we want to add a new
    item to that array. We could use `.push()`, but I chose to use `.unshift()`, which
    will push the new item to the top of the array and effectively display it at the
    top of the list of images on the `Favorites` surface.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`LikedImages`数组的引用，我们想要向该数组添加一个新项目。我们可以使用`.push()`，但我选择使用`.unshift()`，这将把新项目推送到数组的顶部，并有效地在`Favorites`表面的图片列表顶部显示它。
- en: 'The place where we would like to call this action is `ImageDetailsModal`, because
    we can “like” images from within this modal. This modal has a heart button. When
    it’s tapped, we would like the image to be added to our user’s array of liked
    images:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望调用此操作的地点是`ImageDetailsModal`，因为我们可以在其中“喜欢”图片。这个模态有一个心形按钮。当它被点击时，我们希望将图片添加到我们用户的喜欢图片数组中：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Beautiful! Now, when we tap this pressable heart icon on an image from the
    main feed, we should see the image added on the Favorited surface, right? Unfortunately,
    not yet. `observer` wrapper to the `ListOfFavorited` component. This `observer`
    wrapper will re-render our component when it detects a change in the data models:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 美妙！现在，当我们从主动态中点击这个可按压的心形图标时，我们应该看到图片被添加到收藏表面，对吧？不幸的是，目前还没有。给`ListOfFavorited`组件添加了`observer`包装器。这个`observer`包装器会在检测到数据模型变化时重新渲染我们的组件：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And now we’re almost done! There’s only one small catch left. When you like
    an image and then go back to the Favorited surface, you probably won’t see the
    new image until you start scrolling. This is not the functionality we’re looking
    for. We would like to see the newly liked image appear immediately. The issue
    here is `FlatList` component, which accepts simple arrays, but we’re trying to
    pass a special sort of array from our **MobX** model: an observable array.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们几乎完成了！只剩一个小问题。当你喜欢一张图片然后返回收藏表面时，你可能直到开始滚动才会看到新图片。这不是我们想要的功能。我们希望新喜欢的图片能立即显示。这里的问题是`FlatList`组件，它接受简单的数组，但我们正在尝试从我们的**MobX**模型传递一种特殊的数组：一个可观察的数组。
- en: Making FlatList play nice with MobX
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让FlatList与MobX和谐共存
- en: In order for our `FlatList` to render the updated data correctly, we need to
    use the `values` utility provided by MobX.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的`FlatList`正确渲染更新后的数据，我们需要使用MobX提供的`values`实用工具。
- en: 'Here’s the code of `FlatList` in the `ListOfFavorited` component:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ListOfFavorited`组件中`FlatList`的代码：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`Values` is a collection utility provided by the MST library that returns all
    values in the collection as an array, which is exactly what `FlatList` is expecting.
    You can read more about collection utilities in **MobX** in their documentation,
    and you can find a link in the *Further* *reading* section.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Values`是MST库提供的一个集合实用工具，它返回集合中的所有值作为一个数组，这正是`FlatList`所期望的。你可以在**MobX**的文档中了解更多关于集合实用工具的信息，并在*进一步阅读*部分找到链接。'
- en: Now, everything should be working as expected. Make sure to check your phone
    or phone simulator frequently. The sooner you discover errors and issues, the
    easier they are to debug.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切应该都按预期工作。请确保经常检查你的手机或手机模拟器。越早发现错误和问题，调试起来就越容易。
- en: Deriving data from state
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从状态中推导数据
- en: I’ve mentioned the fact that **MobX**’s authors state that anything that can
    be derived from state should be. We’ll get a chance to derive some data now.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到**MobX**的作者表示，任何可以从状态中推导出的东西都应该推导。我们现在将有机会推导一些数据。
- en: 'We would like to know which images are liked and which are not so that we can
    successfully add them to the list of liked images or avoid duplicating them. Deriving
    data from the state is done on the data models through `views`. I’ve decided to
    add this following view to the store because we are working in a constrained environment,
    and I want to keep things simple. Here’s the `RootStore` model:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想知道哪些图片被喜欢了，哪些没有被喜欢，这样我们才能成功地将它们添加到喜欢图片列表中或避免重复。从状态中推导数据是通过`views`在数据模型中完成的。我决定将以下视图添加到存储中，因为我们在一个受限的环境中工作，我想保持事情简单。这是`RootStore`模型：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As with `actions`, you will notice the `self` keyword here. It holds a reference
    to the current data model for easy access.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`actions`一样，你在这里会注意到`self`关键字。它持有对当前数据模型的引用，以便于访问。
- en: I created a `getIsImageLiked` function by passing it an image ID. We then filter
    over the entire liked images array to check whether that image ID exists.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过传递一个图片ID创建了一个`getIsImageLiked`函数。然后我们过滤整个喜欢的图片数组来检查该图片ID是否存在。
- en: Sure, this is not the most efficient way to check a user’s liked images in a
    social media app, which could potentially be hundreds upon hundreds of images
    – but we do want to see what these views are about, and this is a great chance
    to do so.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是检查社交媒体应用中用户喜欢的图片的最有效方法，这些图片可能成百上千——但我们确实想看看这些视图的内容，这是一个很好的机会。
- en: Let’s go back to `ImageDetailsModal`, where we would like to check whether a
    given image is liked or not and then display the appropriate icon (an empty heart
    for images that are not liked and a filled-in heart for liked images) and pass
    the appropriate function (either adding or removing it from the liked images array).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`ImageDetailsModal`，我们想要检查一个给定的图片是否被喜欢，然后显示相应的图标（未喜欢的图片为空心形，喜欢的图片为实心形），并传递适当的函数（要么添加到喜欢的图片数组中，要么从其中移除）。
- en: If you copied your code from the `example-app-full` folder, you’ll find `useEffect`
    in this component, which takes care of checking this exact thing. Let’s try simply
    replacing the old React context values with the new values from the **MobX** store.
    Does the code work? Go ahead and check, I’ll be waiting right here.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从`example-app-full`文件夹复制了你的代码，你会在该组件中找到`useEffect`，它负责检查这个确切的事情。让我们尝试简单地用来自**MobX**存储的新值替换旧的React上下文值。代码工作了吗？请继续检查，我就在这里等你。
- en: 'Something is not quite right, right? The code does not work as expected. To
    be honest, it does not work at all. If you tried to work out step by step what
    was happening, and what should be happening between `useEffect` changes, you may
    have found that it’s not that simple to figure out. The precedence of side effects
    can be very complicated, and it gets even more complicated in bigger apps – and
    that is why we use **MobX’s** dedicated tools: views.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么不对劲的地方吗？代码没有按预期工作。说实话，它根本不起作用。如果你试图一步一步地弄清楚在`useEffect`变化之间发生了什么，以及应该发生什么，你可能发现这并不简单。副作用优先级可能非常复杂，在大型的应用程序中更是如此——这就是为什么我们使用**MobX**的专用工具：视图。
- en: 'Going back to our code, we can go ahead and remove `useEffect` completely.
    We’re taking care of the filtering in `views`, which is added to the store. Let’s
    use `import` from the context hook and use the values provided by **MobX**:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的代码，我们可以完全移除`useEffect`。我们在`views`中处理过滤，这些`views`被添加到存储中。让我们使用来自上下文钩子的`import`并使用**MobX**提供的值：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Don’t forget to add the `observer` wrapper for our component to observe changes
    in data!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记为我们的组件添加`observer`包装器以观察数据变化！
- en: The heart icon is working as expected now – it looks filled in when an image
    has been liked on the `Favorited` surface and gets filled in when an un-liked
    image is newly liked.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在心形图标按预期工作——当图片在`Favorited`表面被喜欢时，它看起来是填充的，当未喜欢的图片被新喜欢时，它也会被填充。
- en: We have gone over creating data models and setting up the store, actions, and
    views in our `chapter-6-complete` folder if you would just like to see the complete
    app.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想看到完整的应用程序，我们已经在`chapter-6-complete`文件夹中创建了数据模型，设置了存储、操作和视图。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have just gone over the main ideas and the implementation of `observer` wrappers
    to the components that need to be aware of state changes and then we have a very
    nice **MobX**-managed app.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论了`observer`包装器的主要思想和实现，这些包装器用于需要知道状态变化的组件，然后我们有一个非常棒的**MobX**管理的应用程序。
- en: It’s great to know how you can manage states in a **React Native** app. It’s
    even better to know a few different ways to do so – and if you like different
    options, you’ll be happy to know that we will talk about **XState** in the next
    chapter!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何在**React Native**应用程序中管理状态是非常好的。知道几种不同的方法来做这件事就更好了——如果你喜欢不同的选项，你将很高兴地知道，我们将在下一章讨论**XState**！
- en: Further reading
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://mobx.js.org/README.html](https://mobx.js.org/README.html): MobX documentation.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://mobx.js.org/README.html](https://mobx.js.org/README.html)：MobX文档。'
- en: '[https://mobx-state-tree.js.org/intro/welcome](https://mobx-state-tree.js.org/intro/welcome):
    MobX-State-Tree.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://mobx-state-tree.js.org/intro/welcome](https://mobx-state-tree.js.org/intro/welcome)：MobX-State-Tree。'
- en: '[https://egghead.io/courses/manage-application-state-with-mobx-state-tree](https://egghead.io/courses/manage-application-state-with-mobx-state-tree):
    *Manage Application State* *with Mobx-state-tree.*'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://egghead.io/courses/manage-application-state-with-mobx-state-tree](https://egghead.io/courses/manage-application-state-with-mobx-state-tree):
    使用 *Mobx-state-tree* *管理应用程序状态*。'
- en: '[https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837](https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837):
    *MobX Quick* *Start Guide*.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837](https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837):
    *MobX 快速入门指南*。'
- en: '[https://github.com/infinitered/ignite](https://github.com/infinitered/ignite):
    Ignite – React Native boilerplate by Infinite Red.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/infinitered/ignite](https://github.com/infinitered/ignite):
    Infinite Red 的 React Native 模板 - Ignite。'
- en: '[https://reactnativeradio.com/episodes/rnr-241-redux-toolkit-vs-mobx-state-tree-showdown](https://reactnativeradio.com/episodes/rnr-241-redux-toolkit-vs-mobx-state-tree-showdown):
    Redux Toolkit versus MobX-State-Tree.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://reactnativeradio.com/episodes/rnr-241-redux-toolkit-vs-mobx-state-tree-showdown](https://reactnativeradio.com/episodes/rnr-241-redux-toolkit-vs-mobx-state-tree-showdown):
    Redux Toolkit 与 MobX-State-Tree 对比。'
- en: '[https://www.loom.com/share/9e3afe0547824e42bada06191e891ae1](https://www.loom.com/share/9e3afe0547824e42bada06191e891ae1):
    *Intro to MobX-State-Tree and MobX-React* by *Jamon Holmgren*.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.loom.com/share/9e3afe0547824e42bada06191e891ae1](https://www.loom.com/share/9e3afe0547824e42bada06191e891ae1):
    由 *Jamon Holmgren* 撰写的 *MobX-State-Tree 和 MobX-React 入门*。'
- en: '[https://mobx-state-tree.js.org/overview/types](https://mobx-state-tree.js.org/overview/types):
    MST types.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://mobx-state-tree.js.org/overview/types](https://mobx-state-tree.js.org/overview/types):
    MST 类型。'
- en: '[https://mobx.js.org/collection-utilities.html](https://mobx.js.org/collection-utilities.html):
    MobX collection utilities.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://mobx.js.org/collection-utilities.html](https://mobx.js.org/collection-utilities.html):
    MobX 集合工具。'
