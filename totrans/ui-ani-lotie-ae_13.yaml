- en: '*Chapter 10*: How To Nail It: Controlling Your Animation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we have a fully functional animation in our React Native app
    that starts playing as a loop when it is mounted and stops when unmounted. But
    what if we want to control the playback of the animation? Let''s give an example:
    we need to display the animation of a loading bar while we sequentially download
    five different files into our app. The loading bar will show the progress of the
    downloading files by filling itself (20% more each time a file is downloaded),
    resulting in a fully filled bar once those five files have been downloaded.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Animated loading bar used as an example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17930_10_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Animated loading bar used as an example
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we need to control the animation, updating it every time a file
    has been fully downloaded and stopping it while the next download is in progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain how this process works in `lottie-react-native`, we will review
    two different alternatives: the declarative and the imperative APIs. By the end
    of this chapter, we will know not only how to render Lottie animations in our
    React Native apps but we will be able to control their playback and layout.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain how this process works in `lottie-react-native`, we will review
    different alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: The declarative API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The imperative API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, we have to have a functioning React Native app running
    on a simulator or device. We will modify this app to include a `LottieView` component
    as we learned in previous chapters so we can modify and control the animation
    through methods and properties.
  prefs: []
  type: TYPE_NORMAL
- en: The declarative API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most frequent explanation for the distinction between imperative and declarative
    programming is that imperative code instructs the computer on how to perform tasks,
    whereas declarative code concentrates on what you want the computer to do.
  prefs: []
  type: TYPE_NORMAL
- en: Your code in imperative programming is made up of statements that affect the
    program's state by instructing the computer what to do. To put it another way,
    your code is built around defining variables and altering their values.
  prefs: []
  type: TYPE_NORMAL
- en: Your code in declarative programming is made up of expressions that evaluate
    their output based on their input by telling the machine what you want.
  prefs: []
  type: TYPE_NORMAL
- en: React was designed following the declarative paradigm, although it allows you
    to control some components the imperative way when needed. So does `lottie-react-native`
    as it provides different APIs for imperative or declarative control on the animations
    rendered within an app.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will focus on how to control the example animated loading
    bar with the `lottie-react-native` library's declarative API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of how controlling a Lottie animation can be achieved with
    the declarative API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, our `App` component receives a prop named `downloadedFiles`
    including the information of the files downloaded by the app. This information
    can be provided by Redux, MobX, a component wrapping app, or any other way. What's
    important for the sake of this example is to know that `downloadedFiles` is an
    array that will increase its size from `0` until the maximum number of files to
    be downloaded (defined by `const numFilesToDownload = 5;` in the example).
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using the Animated API from React Native to hold the progress of the
    animation: `const progress = useMemo(() => new Animated.Value(0), []);` . This
    is an `Animated.Value` that will start from `0` and progressively reach `1`, defining
    we want our animation to be complete. We are using `useMemo` here. As `progress`
    is a variable, we want to update it using React Native''s Animated API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this part, we are creating an effect that will update `progress` based on
    the number of files downloaded (`downloadedFiles.length`) and the number of files
    to be downloaded (`numFilesToDownload`). With this, we will be pushing the progress
    bar 20% toward its total every time a new file is downloaded. For example, if
    we've downloaded 2 of 5 files, `progress` will be set to 0.4, meaning the animation
    needs to smoothly play until 40% of its total play time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also define the duration for every push of the loading bar in the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important part in this example is the `LottieView` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We use the `progress` prop here so we can declare the progress of the animation
    based on an Animated value (`progress`), which depends on the number of files
    being downloaded at a certain moment.
  prefs: []
  type: TYPE_NORMAL
- en: We can find all the declarative properties, their descriptions, and default
    values in the `lottie-react-native` library's README file ([https://github.com/lottie-react-native/lottie-react-native/blob/master/docs/api.md](https://github.com/lottie-react-native/lottie-react-native/blob/master/docs/api.md)).
  prefs: []
  type: TYPE_NORMAL
- en: All of them can be declaratively used on a `LottieView` component to control
    the rendering and behavior of our Lottie animations. In the next section, we will
    learn how to control our animations with the imperative API for those cases where
    we need to explicitly say what to do to our animation instead of reacting to state
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: We have already learned how to use some of these properties in our `LottieView`
    objects. We will now show examples using other important props.
  prefs: []
  type: TYPE_NORMAL
- en: speed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `speed` property is a number that sets the speed of the animation based
    on how many times the default speed should be played:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The example above will play our animation twice as fast as the original animation
    speed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The example above will play our animation in reverse at the original animation
    speed. With this in mind, we could create a loop that renders the animation back
    and forth every 2 seconds instead of repeating it over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: onAnimationFinish
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `onAnimationFinish` property is a callback that will be triggered when
    the animation completes its playback. We can use it to navigate away to a new
    screen when the displaying animation finishes its playback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Note `loop={false}` is necessary for `onAnimationFinish` to work properly as
    a looped animation won't ever finish.
  prefs: []
  type: TYPE_NORMAL
- en: colorFilters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `colorFilters` property is an array of objects containing the string-coded
    hex colors that enables developers to change the colors for specific layers programmatically.
    For this prop to work properly, the correct keypath (a property set when creating
    the app in After Effects and stored in the Lottie JSON file) needs to be provided
    along with the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code modifies three After Effect layers (`button`, `circle`, and
    `square`) to change their colors to red (`'#FF0000'`), green (`'#00FF00'`), and
    blue (`'#0000FF'`) respectively.
  prefs: []
  type: TYPE_NORMAL
- en: textFiltersAndroid and textFiltersIOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`textFiltersAndroid` and `textFiltersIOS` contain an array of objects including
    texts to replace so we can programmatically modify a specific text in the animation.
    This property is useful when dealing with translations in our apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are replacing the text `'Hello!'` with `'Hola!'` and `'Bye!'`
    with `'Adios!'` in our animation for both iOS and Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have learned how to use the declarative API, let''s move on to
    a different way of interacting with our Lottie animations: the imperative API.'
  prefs: []
  type: TYPE_NORMAL
- en: The imperative API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it's just easier using imperative programming in our app, for example,
    sometimes we need to play/stop our animation based on user interactions inside
    the app. For these cases, we can use the `lottie-react-native` library's imperative
    API, which allows developers to control the animation playback in a very straightforward
    way.
  prefs: []
  type: TYPE_NORMAL
- en: React automatically provides the `ref` prop on all its components and the `useRef`
    hook to be used whenever we need to control the component in an imperative way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The piece of code we wrote in the previous section is actually a good example
    of how imperative programming makes more sense when we need to directly trigger
    an action on a component, improving readability and making our code easier to
    reason about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'For this approach, we need to first identify how many frames our animation
    contains and how many frames we need to render once we download each of the files
    to be downloaded. In this example, we could calculate it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of frames contained in the animation: `45`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Number of files to be downloaded: `5`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Number of frames to be played on every file download: `45` / `5` = `9`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we define the calculated number of frames to be played on every file
    download as a constant in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const numFramesPerFile = 9;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create a reference to our `LottieView` component that will
    enable us to call imperative methods on it. We do this using the `useRef` hook
    provided by React:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const animation = useRef(null);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This reference needs to be passed as the `ref` prop to our `LottieView` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: We also see how we explicitly pass `loop={false}` so the animation doesn't repeat
    when we call any imperative playback methods on it.
  prefs: []
  type: TYPE_NORMAL
- en: Having all this setup ready, we can create an effect that will be triggered
    on every file download. This effect will use the imperative play method on the
    referenced component. This play method accepts the initial and the final frames
    we want to play in the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use these parameters to reproduce just a part of the animation on every
    file download:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'When we know how many files the app has downloaded (`downloadedFiles.length`),
    we can easily calculate what the initial frame will be where the next animation
    part should start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we reach the most important part of this code: the part where we use
    the imperative API to reproduce the animation from the initial frame (`startFrame`)
    until the final frame (`startFrame + numFramesPerFile`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we reset the animation if the number of downloaded files is zero,
    so we make sure we always start from the initial frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Besides `play` and `reset`, we can find other imperative methods in the `lottie-react-native`
    library's README file found at [https://github.com/lottie-react-native/lottie-react-native/blob/master/docs/api.md](https://github.com/lottie-react-native/lottie-react-native/blob/master/docs/api.md).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we reviewed the differences between the declarative and the
    imperative APIs for `lottie-react-native`, which can be used to control the looks
    and the playback of our animation. On top of that, we learned how to use React
    Native's Animated API to smoothly control the progress of a Lottie animation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go through some of the most common issues, pitfalls,
    and problems we may face when using `lottie-react-native` in our React Native
    apps.
  prefs: []
  type: TYPE_NORMAL
