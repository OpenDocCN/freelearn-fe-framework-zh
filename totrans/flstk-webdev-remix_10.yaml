- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Working with File Uploads
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件上传
- en: 'Uploading files is something we do all the time on the web. The web provides
    built-in support for uploading files. However, uploading and processing files
    as part of a form submission still requires some additional considerations that
    we will cover in this chapter. This chapter is split into four sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上上传文件是我们经常做的事情。网络提供了内置的文件上传支持。然而，将文件上传和处理作为表单提交的一部分仍然需要考虑一些额外的因素，我们将在本章中介绍。本章分为四个部分：
- en: Using multi-part form data in Remix
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Remix中使用多部分表单数据
- en: Processing files on the server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上处理文件
- en: Authorizing access to assets with resource routes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用资源路由授权访问资产
- en: Forwarding files to third-party services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件转发到第三方服务
- en: In this chapter, we will iterate on BeeRich to support file uploads. First,
    we will update the creation and edit forms to allow adding and removing attachments.
    Next, we will refactor the `action` functions to process the attached files on
    the server. Further, we will investigate how to authorize access to uploaded files.
    Finally, we will learn about file size considerations and discuss different file
    storage solutions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将对BeeRich进行迭代以支持文件上传。首先，我们将更新创建和编辑表单以允许添加和删除附件。接下来，我们将重构`action`函数以在服务器上处理附加文件。进一步地，我们将研究如何授权访问上传的文件。最后，我们将了解文件大小考虑因素并讨论不同的文件存储解决方案。
- en: After reading this chapter, you will understand how to work with multi-part
    form data in Remix. You will know how to use Remix’s file upload helpers and how
    to use resource routes to authorize access to uploaded files. You will have also
    gained a theoretical understanding of what to consider when processing files and
    how to forward files to third-party services.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将了解如何在Remix中处理多部分表单数据。您将知道如何使用Remix的文件上传助手以及如何使用资源路由授权访问上传的文件。您还将获得处理文件时需要考虑的理论知识以及如何将文件转发到第三方服务的理解。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code for this chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/10-working-with-file-uploads/](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/10-working-with-file-uploads/).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的代码：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/10-working-with-file-uploads/](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/10-working-with-file-uploads/).
- en: Before starting this chapter, follow the instructions in the `README.md` file
    in this chapter’s folder on GitHub to clean up the experiments from [*Chapter
    9*](B17399_09.xhtml#_idTextAnchor137), *Assets and* *Metadata Handling*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本章之前，请按照GitHub上本章文件夹中`README.md`文件中的说明清理来自[*第9章*](B17399_09.xhtml#_idTextAnchor137)、“资产和”*元数据处理*的实验。
- en: Using multi-part form data in Remix
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Remix中使用多部分表单数据
- en: By default, form data is encoded using the `application/x-www-form-urlencoded`
    encoding type. URL-encoded form data appends the form data as key-value pairs
    to the request URL as search parameters. To attach files to HTML forms, we need
    to change the form’s encoding type. Appending form data to the URL is not the
    right approach when transferring binary data such as files. In this section, you
    will learn how to use multi-part encoding to support file uploads.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，表单数据使用`application/x-www-form-urlencoded`编码类型。URL编码的表单数据将表单数据作为键值对附加到请求URL作为查询参数。要向HTML表单附加文件，我们需要更改表单的编码类型。在传输如文件这样的二进制数据时，将表单数据附加到URL不是正确的方法。在本节中，您将学习如何使用多部分编码来支持文件上传。
- en: 'There are three different encoding types for HTML form elements:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HTML表单元素有三种不同的编码类型：
- en: '`application/x-www-form-urlencoded`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/x-www-form-urlencoded`'
- en: '`multipart/form-data`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multipart/form-data`'
- en: '`text/plain`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text/plain`'
- en: '`text/plain` is not what we are looking for. Plaintext encoding is not used
    for client-server communication as it submits the data in a human-readable format.
    Instead, we want to use `multipart/form-data` encoding, which places the form
    data into the request body, making it possible to include and stream binary files.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`text/plain`不是我们想要的。纯文本编码不用于客户端-服务器通信，因为它以人类可读的格式提交数据。相反，我们想要使用`multipart/form-data`编码，它将表单数据放入请求体中，使得包括和流式传输二进制文件成为可能。'
- en: 'Let’s update the expense creation and edit forms to allow users to attach files.
    First, let’s go ahead and make the changes to the expense creation form:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新费用创建和编辑表单，允许用户附加文件。首先，让我们对费用创建表单进行更改：
- en: Open the `dashboard.expenses._index.tsx` route module in an editor.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开`dashboard.expenses._index.tsx`路由模块。
- en: The route component currently renders a form with input fields for the expense’s
    title, description, and amount.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路由组件当前渲染一个带有费用标题、描述和金额输入字段的表单。
- en: 'Update the form encoding type to `multipart/form-data` and add a file input
    field:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将表单编码类型更新为 `multipart/form-data` 并添加一个文件输入字段：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, run the app locally (`npm run dev`) and inspect the updated UI.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行本地应用 (`npm run dev`) 并检查更新的用户界面。
- en: As visible in *Figure 10**.1*, the expense creation form now contains an attachment
    input field.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如 *图 10**.1 所示，费用创建表单现在包含一个附件输入字段。
- en: Fill out and submit the expense creation form.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写并提交费用创建表单。
- en: 'Note that the form submission still works. The `request.formData` function
    can parse both URL-encoded and multi-part form data. One downside of `request.formData`
    is that it loads all the form data into server memory. We will see what alternatives
    we have later in this chapter:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，表单提交仍然有效。`request.formData` 函数可以解析 URL 编码和多部分表单数据。`request.formData` 的一个缺点是它会将所有表单数据加载到服务器内存中。我们将在本章后面看到我们有哪些替代方案：
- en: '![Figure 10.1 – Screenshot of a form with an attachment input field](img/Figure_10.01_B17399.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 带有附件输入字段的表单截图](img/Figure_10.01_B17399.jpg)'
- en: Figure 10.1 – Screenshot of a form with an attachment input field
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 带有附件输入字段的表单截图
- en: Great! Just like that, we added an attachment to the expense creation form.
    As always, apply the same changes to the invoice creation form.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！就这样，我们向费用创建表单添加了一个附件。像往常一样，将相同的更改应用到发票创建表单。
- en: 'The expense creation form can now include an optional file attachment. In the
    next section, we will read the uploaded file on the server and persist it to the
    filesystem. However, we also need to associate saved attachments with the expenses.
    Let’s update the database schema so that it supports adding attachments to expenses
    and invoices:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 费用创建表单现在可以包含一个可选的文件附件。在下一节中，我们将在服务器上读取上传的文件并将其持久化到文件系统中。然而，我们还需要将保存的附件与费用关联起来。让我们更新数据库模式以支持向费用和发票添加附件：
- en: First, open the `prisma/schema.prisma` file in your editor.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在你的编辑器中打开 `prisma/schema.prisma` 文件。
- en: 'Add the following line to the `Expense` and `Invoice` database models:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到 `Expense` 和 `Invoice` 数据库模型：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save the changes and run `npx prisma format` in the terminal at the project’s
    root to format the `schema.prisma` file.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改，并在项目的根目录下终端中运行 `npx prisma format` 以格式化 `schema.prisma` 文件。
- en: Next, execute `npm run build` to update the Prisma client and types.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，执行 `npm run build` 以更新 Prisma 客户端和类型。
- en: Under the hood, Prisma generates types based on the `schema.prisma` file. After
    running `npm run build`, the expense and invoice types include the optional `attachment`
    property.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在底层，Prisma 根据的 `schema.prisma` 文件生成类型。在运行 `npm run build` 之后，费用和发票类型包括可选的 `attachment`
    属性。
- en: Finally, run `npm run update:db` to synchronize your local SQLite database schema
    with the updated Prisma schema.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行 `npm run update:db` 以将你的本地 SQLite 数据库模式与更新的 Prisma 模式同步。
- en: 'Once an expense has been created, we want to let users view and remove their
    current attachment. If no attachment is set, we further want users to be able
    to upload a new attachment. Next, let’s update the expense edit form to add this
    functionality:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个费用，我们希望让用户查看和删除他们当前的附件。如果没有设置附件，我们还希望用户能够上传一个新的附件。接下来，让我们更新费用编辑表单以添加此功能：
- en: Open the `dashboard.expenses.$id.tsx` route module in your editor.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开 `dashboard.expenses.$id.tsx` 路由模块。
- en: 'Update the route component’s form encoding type so that it supports file uploads:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新路由组件的表单编码类型，以便它支持文件上传：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Open the `app/components/forms.tsx` file in your editor and inspect the implementation
    of the `Attachment` component.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开 `app/components/forms.tsx` 文件并检查 `Attachment` 组件的实现。
- en: The `Attachment` component expects a `label` property and an `attachmentUrl`
    property and renders an anchor tag linking to the attachment. It further includes
    a submit button and a hidden input field named `attachmentUrl`.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Attachment` 组件期望一个 `label` 属性和一个 `attachmentUrl` 属性，并渲染一个链接到附件的锚标签。它还包括一个提交按钮和一个名为
    `attachmentUrl` 的隐藏输入字段。'
- en: Let's use the `Attachment` component within the edit forms to let users view
    and delete their expense and invoice attachments.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们在编辑表单中使用 `Attachment` 组件，让用户查看和删除他们的费用和发票附件。
- en: 'Import the reusable `Attachment` component in `dashboard.expenses.$id.tsx`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `dashboard.expenses.$id.tsx` 中导入可重用的 `Attachment` 组件：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '{expense.attachment ? (  <Attachment    label="Current Attachment"  attachmentUrl={`/dashboard/expenses/${expense.id}/attachments/${expense.attachment}`}  />)
    : (  <Input label="New Attachment" type="file" name="attachment" />)}'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{expense.attachment ? (  <Attachment    label="Current Attachment"  attachmentUrl={`/dashboard/expenses/${expense.id}/attachments/${expense.attachment}`}  />)
    : (  <Input label="New Attachment" type="file" name="attachment" />)}'
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the application locally and inspect the new file input field on the expense
    edit form.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地运行应用程序并检查费用编辑表单上的新文件输入字段。
- en: 'We need to add a new route module that handles access to file attachments.
    The new route module will be a resource route nested within the `dashboard/expenses/$id`
    path. Let’s create the necessary route structure for the new route module:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个新的路由模块来处理对文件附件的访问。新的路由模块将是一个嵌套在`dashboard/expenses/$id`路径中的资源路由。让我们为新的路由模块创建必要的路由结构：
- en: Rename the `dashboard.expenses.$id.tsx` file to `dashboard.expenses.$id._index.tsx`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`dashboard.expenses.$id.tsx`文件重命名为`dashboard.expenses.$id._index.tsx`。
- en: The route module still matches the same path as before. As an index route, it
    now acts as the default child route for the `$id` path segment.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路由模块仍然匹配之前的相同路径。作为一个索引路由，它现在作为`$id`路径段的默认子路由。
- en: Update the `action` attribute on all forms that are submitted to `dashboard.expenses.$id._index.tsx`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新所有提交到`dashboard.expenses.$id._index.tsx`的所有表单的`action`属性。
- en: We moved the `action` function in `dashboard.expenses.$id.tsx` to `dashboard.expenses.$id._index.tsx`.
    This changes the `action` function’s path.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将`dashboard.expenses.$id.tsx`中的`action`函数移动到了`dashboard.expenses.$id._index.tsx`。这改变了`action`函数的路径。
- en: 'Open the `dashboard.expenses.tsx` parent route module and update the `deleteProps`
    property of the `ListLinkItem` component:'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`dashboard.expenses.tsx`父级路由模块并更新`ListLinkItem`组件的`deleteProps`属性：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, create a new splat route module named `dashboard.expenses.$id.attachments.$.tsx`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的通配符路由模块，命名为`dashboard.expenses.$id.attachments.$.tsx`。
- en: Splats are wildcard route parameters that match the rest of the URL path starting
    from its location. Regardless of what subpath follows `/dashboard/expenses/$id/attachments/`,
    the splat parameter matches and stores the subpath in `params['*']`.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通配符是通配符路由参数，它匹配从其位置开始的URL路径的其余部分。无论跟随`/dashboard/expenses/$id/attachments/`的子路径是什么，通配符参数都会匹配并将子路径存储在`params['*']`中。
- en: For instance, if a user visits the `/dashboard/expenses/$id/attachments/bees/cool-bees.png`
    URL path, then the `params['*']` splat parameter contains the `bees/cool-bees.png`
    string.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果用户访问`/dashboard/expenses/$id/attachments/bees/cool-bees.png` URL路径，那么`params['*']`通配符参数包含`bees/cool-bees.png`字符串。
- en: 'Add the following code to the `dashboard.expenses.$id.attachments.$.tsx` splat
    route module:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`dashboard.expenses.$id.attachments.$.tsx`通配符路由模块中：
- en: '[PRE6]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Sign or log in to BeeRich and create a new expense.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在BeeRich上签名或登录并创建一个新的费用。
- en: Navigate to an expense details page by clicking on an expense in the expense
    overview list on the dashboard.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击仪表板上的费用概览列表中的费用来导航到费用详情页面。
- en: 'Append the: `/attachments/bees/cool-bees.png` path to the URL in the browser
    window.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`/attachments/bees/cool-bees.png`路径追加到浏览器窗口中的URL。
- en: You should see the `loader` functions, not just data for our route components.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到`loader`函数，而不仅仅是我们的路由组件的数据。
- en: Investigate the terminal and review the output of `console.log({ id, slug })`.
    Change the URL in the browser window to see how the output changes.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查终端并审查`console.log({ id, slug })`的输出。更改浏览器窗口中的URL以查看输出如何变化。
- en: Great! We created the required route module structure for our file upload functionality.
    As always, make sure to update the income route files to practice what you’ve
    learned in this section. Run the application locally to debug your implementation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经为我们的文件上传功能创建了所需的路由模块结构。一如既往，确保更新收入路由文件以练习你在本节中学到的内容。在本地运行应用程序以调试你的实现。
- en: In this section, you learned how to set the encoding type on an HTML form element
    and add file input fields. You further practiced working with splat route modules
    and resource routes. Next, we will utilize Remix’s file upload helper functions
    on the server to write the incoming files to the filesystem.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何在HTML表单元素上设置编码类型并添加文件输入字段。你还进一步练习了使用通配符路由模块和资源路由。接下来，我们将利用Remix的服务器端文件上传辅助函数将传入的文件写入文件系统。
- en: Processing files on the server
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端的文件处理
- en: There are several important considerations when handling file uploads on the
    server, most importantly the file size. In this section, we will learn how to
    process files in Remix’s `action` functions. We will start with a naïve implementation
    before refactoring the code and taking more concerns into account.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上处理文件上传时，有几个重要的考虑因素，最重要的是文件大小。在本节中，我们将学习如何在 Remix 的 `action` 函数中处理文件。我们将从一个简单的实现开始，然后重构代码并考虑更多的问题。
- en: Loading files into memory
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将文件加载到内存中
- en: 'Let’s get started by implementing some utilities for working with files:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现一些用于处理文件的实用程序开始：
- en: Create a new `app/modules/attachments.server.ts` file.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `app/modules/attachments.server.ts` 文件。
- en: 'Add the following code to `attachments.server.ts`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `attachments.server.ts`：
- en: '[PRE7]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The added `writeFile` function accepts a file and writes it to the `public`
    folder. Note that this is not our end solution but an intermediate step.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加的 `writeFile` 函数接受一个文件并将其写入 `public` 文件夹。请注意，这并不是我们的最终解决方案，而是一个中间步骤。
- en: The way we access the filesystem depends on the underlying server runtime. BeeRich
    runs on a Node.js runtime. Hence, in BeeRich, we use Node.js libraries to write
    to the filesystem.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们访问文件系统的方式取决于底层服务器运行时。BeeRich 在 Node.js 运行时上运行。因此，在 BeeRich 中，我们使用 Node.js
    库来写入文件系统。
- en: Open the `dashboard.expenses._index.tsx` route module.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `dashboard.expenses._index.tsx` 路由模块。
- en: 'Update the route module’s `action` function, as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新路由模块的 `action` 函数，如下所示：
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run BeeRich locally to test the current implementation.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地运行 BeeRich 以测试当前实现。
- en: Fill out the expense creation form, attach a file, and click `public` folder
    in your editor. Just like that, we can upload a file to the server and write it
    to the filesystem.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写费用创建表单，附加文件，并在您的编辑器中点击 `public` 文件夹。就这样，我们可以将文件上传到服务器并将其写入文件系统。
- en: You can now access the file by navigating to [http://localhost:3000/$file-name](http://localhost:3000/$file-name).
    Note that you must also add the file extension to the path.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以通过导航到 [http://localhost:3000/$file-name](http://localhost:3000/$file-name)
    来访问文件。请注意，您还必须在路径中添加文件扩展名。
- en: Theoretically, we could now read the filename on the server and save it to the
    expense object in the database. Since all files in the `public` folder are already
    accessible over the web, we could let users access their files by linking to `/$filename`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们现在可以在服务器上读取文件名并将其保存到数据库中的费用对象中。由于 `public` 文件夹中的所有文件都已经可以通过网络访问，我们可以让用户通过链接到
    `/$filename` 来访问他们的文件。
- en: 'Unfortunately, there are some limitations to the current naïve implementation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，当前简单实现存在一些限制：
- en: Filename collisions
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名冲突
- en: File size limitations
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件大小限制
- en: Privacy concerns
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐私问题
- en: With the current implementation, we do not manage filenames to avoid collisions.
    What if two users upload a file with the same name? We also don’t handle file
    size limitations. Large files can easily eat up the runtime memory on a server.
    Hence, it is important that we either limit the file size a user can upload or
    better implement the file upload handler in a way that it processes the incoming
    file as a stream of data where the file is handled in chunks rather than trying
    to load the whole file into memory at once.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 根据当前实现，我们没有管理文件名以避免冲突。如果两个用户上传了同名文件怎么办？我们也没有处理文件大小限制。大文件可以轻易地消耗服务器上的运行时内存。因此，限制用户可以上传的文件大小或更好地实现文件上传处理程序，使其作为数据流处理传入的文件，而不是一次性将整个文件加载到内存中，这一点非常重要。
- en: Further, by storing files in the `public` folder, we make the files publicly
    accessible. Anyone can try to guess filenames until they are lucky and able to
    access a file of another user – this is a huge security concern, especially when
    we are talking about sensitive data such as invoices and expenses.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过将文件存储在 `public` 文件夹中，我们使文件对公众可访问。任何人都可以尝试猜测文件名，直到他们幸运地能够访问另一个用户的文件——这是一个巨大的安全问题，尤其是当我们谈论像发票和费用这样的敏感数据时。
- en: Luckily, we can solve all these problems by taking advantage of Remix’s primitives
    and conventions. Let’s solve the first two concerns first using Remix’s upload
    handler helper functions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过利用 Remix 的原语和约定来解决所有这些问题。让我们首先使用 Remix 的上传处理辅助函数来解决前两个问题。
- en: Using Remix’s upload handler helper functions
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Remix 的上传处理辅助函数
- en: 'Remix offers a set of helper functions to manage file uploads. We will use
    the following ones to improve the current naïve implementation:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 提供了一套用于管理文件上传的辅助函数。我们将使用以下函数来改进当前的简单实现：
- en: '`unstable_composeUploadHandlers`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unstable_composeUploadHandlers`'
- en: '`unstable_createFileUploadHandler`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unstable_createFileUploadHandler`'
- en: '`unstable_createMemoryUploadHandler`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unstable_createMemoryUploadHandler`'
- en: '`unstable_parseMultipartFormData`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unstable_parseMultipartFormData`'
- en: Note that the functions currently include an `unstable_` prefix. This means
    their implementation may be up to change in future releases.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当前函数包含 `unstable_` 前缀。这意味着它们的实现可能在未来的版本中发生变化。
- en: 'Let’s get started:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: First, create a new folder in the project’s root called `attachments`. This
    is where we will store all attached files on the server.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在项目的根目录下创建一个名为 `attachments` 的新文件夹。这是我们将在服务器上存储所有附加文件的地方。
- en: Next, open the `app/modules/attachments.server.ts` file in your editor.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在您的编辑器中打开 `app/modules/attachments.server.ts` 文件。
- en: Remove the `writeFile` function.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除 `writeFile` 函数。
- en: 'Instead, use the `unstable_createFileUploadHandler` function to create a new
    file upload handler:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相反，使用 `unstable_createFileUploadHandler` 函数创建一个新的文件上传处理程序：
- en: '[PRE9]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `unstable_createFileUploadHandler` function takes a configuration object
    to specify where to store the uploaded files. It also lets us set the `avoidFileConflicts`
    flag to create unique filenames.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`unstable_createFileUploadHandler` 函数接受一个配置对象来指定上传文件的存储位置。它还允许我们设置 `avoidFileConflicts`
    标志以创建唯一的文件名。'
- en: 'The `standardFileUploadHandler` function is responsible for writing the uploaded
    files to the filesystem. Refer to the Remix documentation for more information
    about the available configuration options: [https://remix.run/docs/en/2.0.0/utils/unstable-create-file-upload-handler](https://remix.run/docs/en/2.0.0/utils/unstable-create-file-upload-handler).'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`standardFileUploadHandler` 函数负责将上传的文件写入文件系统。有关可用的配置选项的更多信息，请参阅 Remix 文档：[https://remix.run/docs/en/2.0.0/utils/unstable-create-file-upload-handler](https://remix.run/docs/en/2.0.0/utils/unstable-create-file-upload-handler)。'
- en: 'Next, create a custom file upload handler function:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个自定义文件上传处理程序函数：
- en: '[PRE10]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use Remix’s `unstable_composeUploadHandlers` function to compose our `attachmentsUploadHandler`
    helper function and Remix’s `unstable_createMemoryUploadHandler`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Remix 的 `unstable_composeUploadHandlers` 函数组合我们的 `attachmentsUploadHandler`
    辅助函数和 Remix 的 `unstable_createMemoryUploadHandler`：
- en: '[PRE11]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With that, we’ve created a higher-level `uploadHandler` helper function composed
    of two upload handlers.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有了这个，我们创建了一个高级的 `uploadHandler` 辅助函数，由两个上传处理程序组成。
- en: '`uploadHandler` calls the two handlers for each form data entry. First, we
    attempt to handle the form data entry with `attachmentsUploadHandler`. If `attachmentsUploadHandler`
    returns `null`, then we also attempt to handle the form data entry with `unstable_createMemoryUploadHandler`.'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`uploadHandler` 为每个表单数据条目调用两个处理程序。首先，我们尝试使用 `attachmentsUploadHandler` 处理表单数据条目。如果
    `attachmentsUploadHandler` 返回 `null`，那么我们也尝试使用 `unstable_createMemoryUploadHandler`
    处理表单数据条目。'
- en: As its name suggests, Remix’s `unstable_createMemoryUploadHandler` will handle
    all other form data fields and upload them to server memory so that we can access
    it, as usual, using the `FormData` interface.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如其名所示，Remix 的 `unstable_createMemoryUploadHandler` 将处理所有其他表单数据字段并将它们上传到服务器内存，这样我们就可以像往常一样使用
    `FormData` 接口来访问它。
- en: 'Great work! Let’s update our `action` functions so that they utilize the new
    upload handler:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！让我们更新我们的 `action` 函数，以便它们利用新的上传处理程序：
- en: Open the `dashboard.expenses._index.tsx` route module.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `dashboard.expenses._index.tsx` 路由模块。
- en: 'Remove the `writeFile` import and naïve implementation in the route module’s
    `action` function:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路由模块的 `action` 函数中移除 `writeFile` 的导入和天真实现：
- en: '[PRE12]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Import `unstable_parseMultipartFormData` from Remix:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Remix 导入 `unstable_parseMultipartFormData`：
- en: '[PRE13]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'import { parseMultipartFormData to replace request.formData():'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`import { parseMultipartFormData } to replace request.formData()`：'
- en: '[PRE14]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we let `unstable_parseMultipartFormData` handle the multipart form data
    using our custom `uploadHandler`. `unstable_parseMultipartFormData` calls our
    higher-order upload handler for every form data entry. The composed upload handler
    loops through our upload handlers until one of them returns neither `null` nor
    `undefined`. The attachment form data entry is processed by the file upload handler,
    returning the file name of the uploaded file, or null if no file has been submitted.
    `unstable_createMemoryUploadHandler` handles all other form data for us.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们让 `unstable_parseMultipartFormData` 使用我们的自定义 `uploadHandler` 处理多部分表单数据。`unstable_parseMultipartFormData`
    为每个表单数据条目调用我们的高阶上传处理程序。组合上传处理程序遍历我们的上传处理程序，直到其中一个返回既不是 `null` 也不是 `undefined`。附件表单数据条目由文件上传处理程序处理，返回上传文件的文件名，如果没有提交文件则返回
    `null`。`unstable_createMemoryUploadHandler` 为我们处理所有其他表单数据。
- en: '[PRE15]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, add the code to read the attachment form data and update the database
    query:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加读取附件表单数据并更新数据库查询的代码：
- en: '[PRE16]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Congratulations! You successfully added a file upload to the expense creation
    form. Make sure you apply the same changes to the income routes before moving
    on to the next section. Reuse the helper functions in `attachments.server.ts`
    to update the invoice creation `action` function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您成功地将文件上传添加到支出创建表单中。确保在进入下一节之前将相同的更改应用到收入路由上。重用`attachments.server.ts`中的辅助函数来更新发票创建`action`函数。
- en: Preventing server memory overflows
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 防止服务器内存溢出
- en: When working with file uploads, we must keep memory limitations in mind. Large
    file sizes can easily overwhelm our servers. This is why it’s important to handle
    incoming files in chunks instead of loading them fully into memory. Remix’s file
    upload helpers help us avoid filenaming collisions and let us stream file data
    to avoid server memory overflows.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文件上传时，我们必须注意内存限制。大文件大小很容易使我们的服务器不堪重负。这就是为什么处理传入的文件时，将其分块处理而不是完全加载到内存中很重要的原因。Remix的文件上传辅助函数帮助我们避免文件名冲突，并允许我们流式传输文件数据以避免服务器内存溢出。
- en: 'Next, we will update the expense edit form so that it can also handle file
    uploads:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新支出编辑表单，使其也能处理文件上传：
- en: Open the `dashboard.expenses.$id._index.tsx` file in your editor.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开`dashboard.expenses.$id._index.tsx`文件。
- en: 'Again, import `unstable_parseMultipartFormData` and `uploadHandler`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，导入`unstable_parseMultipartFormData`和`uploadHandler`：
- en: '[PRE17]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'export async function action({ params, request }: ActionFunctionArgs) {  const
    userId = await requireUserId(request);  const { id } = params;  if (!id) throw
    Error(''id route parameter must be defined'');action function distinguishes between
    delete and update form submissions. The delete form submission originates from
    the ListLinkItem component, while the update submission originates from the expense
    edit form in the dashboard.expenses.$id._index.tsx route module.Earlier in the
    chapter, we updated the expense edit form encoding to multi-part encoding, but
    we did not do the same to the expense deletion form. Hence, the `action` function
    must be able to support both multipart and URL-encoded form data. For this, we
    use the `content-type` header to distinguish which form encoding has been used
    and only use `parseMultipartFormData` for `multipart/form-data`.'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'export async function action({ params, request }: ActionFunctionArgs) {  const
    userId = await requireUserId(request);  const { id } = params;  if (!id) throw
    Error(''id路由参数必须被定义'');action函数区分删除和更新表单提交。删除表单提交来自ListLinkItem组件，而更新提交来自dashboard.expenses.$id._index.tsx路由模块中的支出编辑表单。在本章早期，我们更新了支出编辑表单的编码为多部分编码，但没有对支出删除表单做同样的处理。因此，`action`函数必须能够支持多部分和URL编码的表单数据。为此，我们使用`content-type`头区分使用了哪种表单编码，并且只为`multipart/form-data`使用`parseMultipartFormData`。'
- en: '[PRE18]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, update the `updateExpense` function so that it reads the `attachment`
    form data entry and adds the value to the database update query:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`updateExpense`函数，使其读取`attachment`表单数据条目并将值添加到数据库更新查询中：
- en: '[PRE19]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following function to the `attachments.server.ts` file:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数添加到`attachments.server.ts`文件中：
- en: '[PRE20]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`deleteAttachment` receives a `fileName` and deletes the associated file from
    the `attachments` folder.'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`deleteAttachment`接收一个`fileName`并从`attachments`文件夹中删除相关文件。'
- en: 'Import `deleteAttachment` in `dashboard.expenses.$id._index.tsx`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`dashboard.expenses.$id._index.tsx`中导入`deleteAttachment`：
- en: '[PRE21]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'async function removeAttachment(formData: FormData, id: string, userId: string):
    Promise<Response> {  const attachmentUrl = removeAttachment is called within the
    route module’s action function when the submit button carries the remove-attachment
    value, which is implemented in the Attachment component.'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'async function removeAttachment(formData: FormData, id: string, userId: string):
    Promise<Response> {  const attachmentUrl = removeAttachment是当提交按钮带有remove-attachment值时在路由模块的action函数中被调用的，该值在附件组件中实现。'
- en: '[PRE22]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Update the route module’s `action` function so that it handles the `remove-attachment`
    form’s action intent:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新路由模块的`action`函数，使其处理`remove-attachment`表单的动作意图：
- en: '[PRE23]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, update the `deleteExpense` function in the same file to remove the
    attachment when an expense is deleted:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在相同文件中更新`deleteExpense`函数，以便在删除支出时删除附件：
- en: '[PRE24]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Create an expense with an attachment. Check the `attachments` folder in your
    editor.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有附件的支出。检查您的编辑器中的`attachments`文件夹。
- en: Remove the attachment by clicking the `attachments` folder to see whether the
    file was deleted successfully.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击`attachments`文件夹来删除附件，查看文件是否成功删除。
- en: Next, add a new attachment to the same expense using the edit form and investigate
    the `attachments` folder again.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用编辑表单向同一支出添加新的附件，并再次调查`attachments`文件夹。
- en: 'Finally, delete the expense by clicking the **X** button in the expense overview
    list and check whether the file was deleted:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过在费用概览列表中点击**X**按钮来删除费用，并检查文件是否已删除：
- en: '![Figure 10.2 – Screenshot of the updated expense edit form](img/Figure_10.02_B17399.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 更新后的费用编辑表单的截图](img/Figure_10.02_B17399.jpg)'
- en: Figure 10.2 – Screenshot of the updated expense edit form
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 更新后的费用编辑表单的截图
- en: As visible in *Figure 10**.2*, the expense edit form should now correctly switch
    between the current attachment and the attachment input field if no attachment
    is set. The `attachments` folder. Deleting an expense should also remove the associated
    attached file from the `attachments` folder.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图10**.2*所示，如果未设置附件，费用编辑表单现在应正确地在当前附件和附件输入字段之间切换。删除费用还应从`attachments`文件夹中删除相关的附件文件。
- en: Before moving on, update the `income` routes to practice what you have learned
    in this section. Once the `income` routes have been updated, you can move on to
    the next section.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，更新`income`路由以练习本节中学到的内容。一旦`income`路由被更新，你就可以进入下一节。
- en: In this section, you learned how to work with Remix’s file upload helper functions.
    You now understand the considerations that come into play when managing file uploads
    and how to use Remix’s utilities to avoid memory and filenaming collisions. Next,
    we will implement the splat route to give BeeRich users secure access to their
    attachments.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何使用Remix的文件上传辅助函数。你现在理解了在管理文件上传时需要考虑的因素，以及如何使用Remix的实用工具来避免内存和文件命名冲突。接下来，我们将实现splat路由，以让BeeRich用户安全地访问他们的附件。
- en: Authorizing access to assets with resource routes
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用资源路由授权对资产的访问
- en: 'In [*Chapter 9*](B17399_09.xhtml#_idTextAnchor137), *Assets and Metadata Handling*,
    you practiced exposing assets via resource routes. We will now expand on that
    by dynamically creating a file download for the requested expense attachment.
    We will implement the splat route responsible for exposing the attachments and
    ensure that only authorized users can access their files:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B17399_09.xhtml#_idTextAnchor137)，“资产和元数据处理”中，你练习了通过资源路由公开资产。现在我们将在此基础上动态创建一个用于请求的费用附件的文件下载。我们将实现负责公开附件的splat路由，并确保只有授权用户才能访问他们的文件：
- en: 'First, let’s add one more helper function to the `attachments.server.ts` file:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们向`attachments.server.ts`文件添加一个额外的辅助函数：
- en: '[PRE25]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, open the `dashboard.expenses.$id.attachments.$.tsx` splat route module
    and replace its content with the following code:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`dashboard.expenses.$id.attachments.$.tsx` splat路由模块，并用以下代码替换其内容：
- en: '[PRE26]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It’s time to test the implementation. Try to download a current attachment.
    Clicking on the **Current Attachment** link should initiate a file download.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候测试实现了。尝试下载当前附件。点击**当前附件**链接应启动文件下载。
- en: Great work! You implemented a full stack file upload feature in BeeRich that
    spans several different forms, routes, and utilities.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你在BeeRich中实现了涵盖多个不同表单、路由和实用工具的全栈文件上传功能。
- en: Before moving on, make sure you implement the income splat route. Repeating
    this work on the income routes will help you practice all the new concepts.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保你实现了收入splat路由。在收入路由上重复这项工作将帮助你练习所有新的概念。
- en: Restricting access to user files
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 限制对用户文件的访问
- en: It is important to remember that files in the `public` folder are publicly accessible
    over the internet. We must ensure that private user data is protected by authorization
    code. In Remix, we can use resource routes to dynamically check access rights
    before granting access to user files.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，`public`文件夹中的文件可以通过互联网公开访问。我们必须确保通过授权代码保护私有用户数据。在Remix中，我们可以使用资源路由在授予用户文件访问权限之前动态检查访问权限。
- en: In this section, you learned how to create dynamic responses and expose assets
    via resource routes. You now understand how to authorize users in resource routes
    to restrict access. Next, we will discuss forwarding files to third-party services.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何创建动态响应并通过资源路由公开资产。你现在理解了如何在资源路由中授权用户以限制访问。接下来，我们将讨论将文件转发到第三方服务。
- en: Forwarding files to third-party services
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文件转发到第三方服务
- en: So far, we are hosting our user files on the server’s filesystem. This is sufficient
    for the educative scope of BeeRich. However, when working with user files, we
    should also consider hosting them on a dedicated file storage service. This section
    quickly outlines what else we need to consider when working with user files.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在服务器的文件系统中托管用户文件。这对于 BeeRich 的教育范围来说是足够的。然而，当处理用户文件时，我们也应考虑在专用的文件存储服务上托管它们。本节简要概述了在处理用户文件时还需要考虑的其他事项。
- en: Hosting user files directly on a web server may not be sufficient for most use
    cases. Hosting files locally may be hard to scale and requires you to secure sensitive
    user files and backups on your systems. Additionally, reading and writing to disk
    might create a lot of overhead for the web server that can be avoided by delegating
    the reads and writes to a third-party service.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在 Web 服务器上托管用户文件可能对于大多数用例来说可能不够。在本地托管文件可能难以扩展，需要你在系统中保护敏感用户文件和备份。此外，读取和写入磁盘可能会为
    Web 服务器创建大量开销，这些开销可以通过将读取和写入委托给第三方服务来避免。
- en: Most popular third-party storage services offer APIs to stream files. This allows
    us to receive the file upload as a stream of data so that we can forward the stream
    to a third-party service. After the upload is completed, the storage API usually
    provides a URL to the uploaded file, which we can use in our database to link
    to the new file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数流行的第三方存储服务提供 API 以流式传输文件。这使我们能够将文件上传作为数据流接收，以便我们可以将流转发到第三方服务。上传完成后，存储 API
    通常提供一个指向已上传文件的 URL，我们可以在数据库中使用它来链接到新文件。
- en: Remix’s upload handler primitives let you create custom handlers for different
    third-party services. Instead of writing to the local filesystem, we can create
    an upload handler that streams the data to a cloud provider.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 的上传处理程序原语允许你为不同的第三方服务创建自定义处理程序。我们不必写入本地文件系统，可以创建一个上传处理程序，将数据流式传输到云提供商。
- en: Popular file hosting providers include AWS S3, Cloudflare, Cloudinary, Firebase,
    and Vercel. You can find an example implementation that uses Cloudinary in the
    *Further* *reading* section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的文件托管提供商包括 AWS S3、Cloudflare、Cloudinary、Firebase 和 Vercel。你可以在 *进一步* *阅读*
    部分找到一个使用 Cloudinary 的示例实现。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to add files to HTML forms and how to handle
    file uploads in Remix.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将文件添加到 HTML 表单中，以及如何在 Remix 中处理文件上传。
- en: HTML forms support different encoding types. Multipart form encoding adds the
    form data to the response body. This is required when appending binary data, such
    as files. On the server, we can then stream in the response body and handle the
    uploaded files in chunks.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 表单支持不同的编码类型。多部分表单编码将表单数据添加到响应体中。当附加二进制数据，如文件时，这是必需的。在服务器上，我们然后可以流式传输响应体，并分块处理上传的文件。
- en: By reading this chapter, you now understand that Remix provides a set of file
    upload utilities for handling file uploads. Remix utilities help us avoid filenaming
    collisions and allow us to configure file size limits and file streaming. We can
    further compose several file upload handlers together and implement custom wrappers
    by implementing the `UploadHandler` type.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本章，你现在理解 Remix 提供了一套文件上传实用工具来处理文件上传。Remix 实用工具帮助我们避免文件命名冲突，并允许我们配置文件大小限制和文件流。我们可以进一步组合几个文件上传处理程序，并通过实现
    `UploadHandler` 类型来实现自定义包装器。
- en: Next, you learned how to restrict access to a resource route by authenticating
    user sessions and ensuring authorized database queries that query for a unique
    combination of entity `id` and user `id`. We must not place user files in the
    `public` folder. Instead, we must leverage resource routes and custom authorization
    logic.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你学习了如何通过验证用户会话并确保授权的数据库查询来查询实体 `id` 和用户 `id` 的唯一组合，从而限制对资源路由的访问。我们不得将用户文件放在
    `public` 文件夹中。相反，我们必须利用资源路由和自定义授权逻辑。
- en: Finally, we discussed the usage of third-party file hosting services. You now
    understand that using a third-party service may be more scalable and allow us
    to offload much of the complexity of storing files to a third-party service.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了第三方文件托管服务的使用。你现在理解使用第三方服务可能更具可扩展性，并允许我们将存储文件的许多复杂性卸载到第三方服务。
- en: Congratulations! Just like that, you made it through the second part of this
    book. In the next chapter, we’ll kick off the advanced topics of this book and
    learn more about optimistic UIs. Keep going to unlock the full potential of the
    web platform with Remix.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！就这样，你已经完成了这本书的第二部分。在下一章中，我们将开启本书的高级主题，并了解更多关于乐观用户界面的内容。继续前进，用Remix解锁Web平台的全部潜力。
- en: Further reading
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can learn more about the HTML form element’s `enctype` property via MDN
    Web Docs: [https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/enctype](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/enctype).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过MDN Web文档了解HTML表单元素的`enctype`属性：[https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/enctype](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/enctype)。
- en: 'You can find additional information about HTTP POST requests via MDN Web Docs:
    [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过MDN Web文档了解HTTP POST请求的更多信息：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST)。
- en: 'Review this example implementation from Remix’s example repository for uploading
    files to Cloudinary: [https://github.com/remix-run/examples/tree/main/file-and-cloudinary-upload](https://github.com/remix-run/examples/tree/main/file-and-cloudinary-upload).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Remix示例仓库中的此示例实现，用于上传文件到Cloudinary：[https://github.com/remix-run/examples/tree/main/file-and-cloudinary-upload](https://github.com/remix-run/examples/tree/main/file-and-cloudinary-upload)。
- en: 'You can learn more about Remix’s file upload helpers by reading the Remix documentation:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过阅读Remix文档了解更多关于Remix文件上传辅助工具的信息：
- en: '[https://remix.run/docs/en/2.0.0/utils/parse-multipart-form-data](https://remix.run/docs/en/2.0.0/utils/parse-multipart-form-data)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://remix.run/docs/en/2.0.0/utils/parse-multipart-form-data](https://remix.run/docs/en/2.0.0/utils/parse-multipart-form-data)'
- en: '[https://remix.run/docs/en/2.0.0/utils/unstable-create-file-upload-handler](https://remix.run/docs/en/2.0.0/utils/unstable-create-file-upload-handler)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://remix.run/docs/en/2.0.0/utils/unstable-create-file-upload-handler](https://remix.run/docs/en/2.0.0/utils/unstable-create-file-upload-handler)'
- en: '[https://remix.run/docs/en/2.0.0/utils/unstable-create-memory-upload-handler](https://remix.run/docs/en/2.0.0/utils/unstable-create-memory-upload-handler)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://remix.run/docs/en/2.0.0/utils/unstable-create-memory-upload-handler](https://remix.run/docs/en/2.0.0/utils/unstable-create-memory-upload-handler)'
- en: Part 3 – Advanced Concepts of Full Stack Web Development with Remix
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分 - 使用Remix的全栈Web开发高级概念
- en: In this final part, you will practice advanced concepts of full stack web development,
    such as optimistic UI, caching strategies, HTML streaming, and real-time data
    updates. You will again iterate on BeeRich to practice the studied concepts. You
    will also dig deeper into session management and understand what it means to deploy
    to the edge. Finally, you will learn about migration strategies to Remix and learn
    how to keep a Remix application up to date.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本最终部分，你将练习全栈Web开发的高级概念，如乐观用户界面、缓存策略、HTML流和实时数据更新。你将再次迭代BeeRich以练习所学概念。你还将深入了解会话管理，并理解部署到边缘的含义。最后，你将了解迁移到Remix的策略，并学习如何保持Remix应用程序的更新。
- en: 'This part has the following chapters:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 11*](B17399_11.xhtml#_idTextAnchor167), *Optimistic UI*'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B17399_11.xhtml#_idTextAnchor167), *乐观用户界面*'
- en: '[*Chapter 12*](B17399_12.xhtml#_idTextAnchor181), *Caching Strategies*'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B17399_12.xhtml#_idTextAnchor181), *缓存策略*'
- en: '[*Chapter 13*](B17399_13.xhtml#_idTextAnchor194), *Deferring Loader Data*'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B17399_13.xhtml#_idTextAnchor194), *延迟加载器数据*'
- en: '[*Chapter 14*](B17399_14.xhtml#_idTextAnchor204), *Real-Time with Remix*'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B17399_14.xhtml#_idTextAnchor204), *使用Remix进行实时操作*'
- en: '[*Chapter 15*](B17399_15.xhtml#_idTextAnchor214)*,* *Advanced Session Management*'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B17399_15.xhtml#_idTextAnchor214)*,* *高级会话管理*'
- en: '[*Chapter 16*](B17399_16.xhtml#_idTextAnchor221), *Developing for the Edge*'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B17399_16.xhtml#_idTextAnchor221), *边缘开发*'
- en: '[*Chapter 17*](B17399_17.xhtml#_idTextAnchor230), *Migration and Upgrade Strategies*'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第17章*](B17399_17.xhtml#_idTextAnchor230), *迁移和升级策略*'
