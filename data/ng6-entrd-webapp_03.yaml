- en: Prepare Angular App for Production Release
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为生产发布准备Angular应用程序
- en: If you don't ship it, it never happened. In the previous chapter, you created
    a local weather application that can retrieve current weather data. You have created
    some amount of value; however, if you don't put your app on the web, you end up
    creating zero value. Delivering something is difficult, delivering something to
    production is even more difficult. You want to follow a strategy that results
    in a reliable, high quality, and flexible release.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不发布它，它就没有发生过。在上一章中，您创建了一个可以检索当前天气数据的本地天气应用程序。您已经创造了一定价值；但是，如果您不将应用程序放在网络上，最终您将创造零价值。交付某物是困难的，将某物交付到生产中更加困难。您希望遵循一种能够产生可靠、高质量和灵活发布的策略。
- en: The app we created in [Chapter 2](312e0dbe-54ac-45c6-97c7-f41c98723919.xhtml), *Create
    a Local Weather Web Application*, is fragile, has failing unit and **end-to-end**
    (**e2e**) tests, and emits console errors. We need to fix the unit tests and harden
    the application by intentionally introducing errors so that you can see the side-effects
    of real-life conditions in action using debugging tools. We also need to be able
    to deliver the frontend app separately from the backend app, which is a very important
    decoupling to retain the flexibility of being able to push separate app and server
    updates. In addition, decoupling will ensure that as the various tools and technologies
    in your application stack inevitably falls out of support or favor, you will be
    able to replace your frontend or backend without a full rewrite of your system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](312e0dbe-54ac-45c6-97c7-f41c98723919.xhtml)中创建的应用程序，*创建一个本地天气Web应用程序*，是脆弱的，有失败的单元和端到端（e2e）测试，并且会发出控制台错误。我们需要修复单元测试并通过有意引入错误来加固应用程序，以便您可以使用调试工具看到真实条件的副作用。我们还需要能够单独交付前端应用程序和后端应用程序，这是保持能够推送单独的应用程序和服务器更新的灵活性非常重要的解耦。此外，解耦将确保随着应用程序堆栈中的各种工具和技术不可避免地不再受支持或受青睐，您将能够替换前端或后端，而无需完全重写系统。
- en: 'In this chapter, you will learn to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学会以下内容：
- en: Run Angular unit and e2e
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Angular单元和e2e
- en: Troubleshoot common Angular errors using Chrome Developer Tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Chrome开发者工具排除常见的Angular错误
- en: Guard against null data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止空数据
- en: Containerize the app using Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker将应用程序容器化
- en: Deploy the app on the web using Zeit Now
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Zeit Now将应用程序部署到网络上
- en: 'Required software is as listed:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所需软件如下所示：
- en: Docker Community Edition Version 17.12
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker社区版17.12版本
- en: Zeit Now Account
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zeit Now账户
- en: Angular unit tests
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular单元测试
- en: Just because your Angular app launches using `npm start` and seems to work fine,
    it doesn't mean it is error free or production ready. As covered earlier in [Chapter
    2](312e0dbe-54ac-45c6-97c7-f41c98723919.xhtml), *Create a Local Weather Web Application*,
    Angular CLI creates a unit test file as you create new components and services,
    such as `current-weather.component.spec.ts` and `weather.service.spec.ts`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为您的Angular应用程序使用`npm start`启动并且似乎工作正常，并不意味着它没有错误或准备好投入生产。如前面在[第2章](312e0dbe-54ac-45c6-97c7-f41c98723919.xhtml)中所述，Angular
    CLI在创建新组件和服务时会创建一个单元测试文件，例如`current-weather.component.spec.ts`和`weather.service.spec.ts`。
- en: 'At their most basic, these unit default unit tests ensure that your new components
    and services can be properly instantiated in the test harness. Take a look at
    the following spec file and observe the `should create` test. The framework asserts
    that component of the `CurrentWeatherComponent` type to not be null or undefined,
    but be truthy:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的层面上，这些默认单元测试确保您的新组件和服务可以在测试中正确实例化。看一下以下规范文件，并观察`should create`测试。该框架断言`CurrentWeatherComponent`类型的组件不是null或undefined，而是真实的。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `WeatherService` spec contains a similar test. However, you''ll note that
    both types of tests are set up slightly differently:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeatherService`规范包含了类似的测试。但是，您会注意到这两种类型的测试设置略有不同：'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the `WeatherService` spec's `beforeEach` function, the class under test is
    being configured as a provider and then injected into the test. On the other hand,
    the `CurrentWeatherComponent` spec has two `beforeEach` functions. The first,
    the `beforeEach` function declares and compiles the component's dependent modules
    asynchronously, while the second, the `beforeEach` function creates a test fixture
    and starts listening to changes in the component, ready to run the tests once
    the compilation is complete.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WeatherService`规范的`beforeEach`函数中，正在将要测试的类配置为提供者，然后注入到测试中。另一方面，`CurrentWeatherComponent`规范有两个`beforeEach`函数。第一个`beforeEach`函数异步声明和编译了组件的依赖模块，而第二个`beforeEach`函数创建了一个测试装置，并开始监听组件的变化，一旦编译完成就准备运行测试。
- en: Unit test execution
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试执行
- en: 'Angular CLI uses the Jasmine unit testing library to define unit tests and
    the Karma test runner to execute them. Best of it all, these testing tools are
    configured to be run out of the box. You may execute the unit tests with the following
    command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI使用Jasmine单元测试库来定义单元测试，并使用Karma测试运行器来执行它们。最好的是，这些测试工具已经配置好可以直接运行。您可以使用以下命令执行单元测试：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The tests will be run by the Karma test runner in a new Chrome browser window.
    The main benefit of Karma is that it brings live-reloading capabilities similar
    to what Angular CLI achieves with WebPack when developing your application. You
    should observe the last message on the Terminal to be Executed 5 of 5 (5 FAILED)
    ERROR. This is normal, because we haven't been paying attention to the tests at
    all, so let's fix them all.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将由Karma测试运行器在新的Chrome浏览器窗口中运行。Karma的主要优点是它带来了类似于Angular CLI在开发应用程序时使用WebPack实现的实时重新加载功能。您应该观察终端上的最后一条消息为Executed
    5 of 5 (5 FAILED) ERROR。这是正常的，因为我们根本没有注意测试，所以让我们修复它们。
- en: '![](Images/ca1b94c3-14d3-46ad-a89f-74bedca1c8bb.png)Karma Runner showing Jasmine
    Unit Test ResultsKeep the Karma Runner window open side-by-side with VS Code so
    that you can instantly see the results of your changes.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 保持Karma Runner窗口与VS Code并排打开，这样您可以立即看到您的更改结果。
- en: Declarations
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明
- en: The AppComponent should create the app test is failing. If you observe the error
    details, you'll see that `AppComponent` is failing to be created, because 'app-current-weather'
    is not a known element**.** Further, the error occurs if pointed out with a [ERROR
    ->] tag, and the last line spells things out for us, similar to the error originating
    from line 6 in AppComponent.html.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: AppComponent应该创建应用程序测试失败。如果您观察错误详情，您会发现`AppComponent`无法创建，因为'app-current-weather'不是一个已知的元素。此外，如果指出错误，错误会出现一个[ERROR
    ->]标签，最后一行为我们解释了事情，类似于AppComponent.html中的第6行出现的错误。
- en: 'Include `CurrentWeatherComponent` in the declarations of `app.component.spec.ts`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.component.spec.ts`的声明中包括`CurrentWeatherComponent`：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Providers
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供者
- en: You'll note that the number of errors didn't go down. Instead, `AppComponent` and
    `CurrentWeatherComponent` are failing to be created due to a missing provider
    for `WeatherService`. So, let's add the provider for `WeatherService` to the spec
    files for both components.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到错误数量并没有减少。相反，`AppComponent`和`CurrentWeatherComponent`由于缺少`WeatherService`的提供者而无法创建。因此，让我们在这两个组件的规范文件中为`WeatherService`添加提供者。
- en: Provide the `WeatherService` in the declarations in `app.component.spec.ts`
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.component.spec.ts`的声明中提供`WeatherService`。
- en: 'Apply the same code change in `current-weather.component.spec.ts`, as shown:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`current-weather.component.spec.ts`中应用相同的代码更改，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You may wonder why `AppComponent` is needing a provider, since the component
    constructor is not injected with the `WeatherService`. This is happening because `CurrentWeatherComponent` is
    a hard-coded dependency of `AppComponent`. It is possible to decouple the two
    components further in two ways: one way is to inject the component dynamically
    using an `ng-container`, and the other would be to leverage Angular Router and
    `router-outlet`. The latter option is how you will be structuring the vast majority
    of your applications and will be covered in the later chapters, and implementing
    the former option to properly decouple the components is left as an exercise for
    the reader.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么`AppComponent`需要一个提供程序，因为组件构造函数没有注入`WeatherService`。这是因为`CurrentWeatherComponent`是`AppComponent`的硬编码依赖项。可以通过两种方式进一步解耦这两个组件：一种方式是使用`ng-container`动态注入组件，另一种方式是利用Angular
    Router和`router-outlet`。后一种选项是你将会在大多数应用程序中使用的结构方式，并且将在后面的章节中进行介绍，而实现前一种选项以正确解耦组件则留给读者作为练习。
- en: Imports
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入
- en: You still have errors remaining. Let's start by fixing the errors with the `WeatherService`
    error first, since it's a dependency of other components. The test is reporting
    a missing provider for `HttpClient`. However, we don't want our unit test to make
    calls over HTTP, so we shouldn't provide the `HttpClient`, like we did in the
    previous section. Angular provides a test double for `HttpClient` named `HttpClientTestingModule`.
    In order to leverage it, you must import it, and it will then be automatically
    provided to the service for you.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然有剩余的错误。让我们首先修复`WeatherService`的错误，因为它是其他组件的依赖项。测试报告了一个缺少`HttpClient`提供程序的错误。然而，我们不希望我们的单元测试进行HTTP调用，所以我们不应该提供`HttpClient`，就像我们在上一节中所做的那样。Angular为`HttpClient`提供了一个名为`HttpClientTestingModule`的测试替身。为了利用它，你必须导入它，然后它将自动为你提供给服务。
- en: 'Import `HttpClientTestingModule` below the providers:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供程序下方导入`HttpClientTestingModule`。
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Similar to `HttpClientTestingModule`, there's also a `RouterTestingModule` and
    a `NoopAnimationsModule` that are mock versions of the real services, so the unit
    tests can focus on only testing the component or service code that you write.
    In the later chapters, we will also cover how you can write your own mocks.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`HttpClientTestingModule`，还有一个`RouterTestingModule`和一个`NoopAnimationsModule`，它们是真实服务的模拟版本，因此单元测试可以专注于测试你编写的组件或服务代码。在后面的章节中，我们还将介绍如何编写自己的模拟。
- en: Now you should only see errors related to `AppComponent` and `CurrentWeatherComponent`.
    These components are failing even though you have provided their dependencies.
    To understand why this happens and how you can resolve it, you must also understand
    how to work with test doubles.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该只看到与`AppComponent`和`CurrentWeatherComponent`相关的错误。即使你已经提供了它们的依赖项，这些组件也失败了。要理解为什么会发生这种情况以及如何解决它，你还必须了解如何使用测试替身。
- en: Test doubles
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试替身
- en: Only the code in the class-under-test should be exercised. In case of the `CurrentWeatherComponent`,
    we need to ensure that the service code is not executed. For this reason, you
    should *never* provide the actual implementation of the service. This is also
    why we used `HttpClientTestingModule` in the previous section. Since this is our
    custom service, we must provide our own implementation of a test double.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在受测试的类中的代码应该被执行。在`CurrentWeatherComponent`的情况下，我们需要确保服务代码不被执行。因此，你*永远*不应该提供服务的实际实现。这也是我们在上一节中使用`HttpClientTestingModule`的原因。由于这是我们的自定义服务，我们必须提供我们自己的测试替身的实现。
- en: 'In this case, we will implement a fake of the service. Since the fake of the `WeatherService`
    will be used in tests for multiple components, your implementation should be in
    a separate file. For the sake of maintainability and discoverability of your code
    base, one class per file is a good rule of thumb to follow. Keeping classes in
    separate files will save you from committing certain coding sins, like mistakenly
    creating or sharing global state or standalone functions between two classes,
    keeping your code properly decoupled in the process:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将实现一个服务的虚假。由于`WeatherService`的虚假将用于多个组件的测试，您的实现应该在一个单独的文件中。为了保持代码库的可维护性和可发现性，一个文件一个类是一个很好的遵循的原则。将类放在单独的文件中将使您免受某些编码罪的困扰，比如错误地在两个类之间创建或共享全局状态或独立函数，从而在此过程中保持代码适当地解耦：
- en: Create a new file `weather/weather.service.fake.ts`
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`weather/weather.service.fake.ts`
- en: We need to ensure that APIs for the actual implementation and the test double
    don't go out of sync over time. We can accomplish this by creating an interface
    for the service.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保实际实现和测试替身的API不会随着时间而不同步。我们可以通过为服务创建一个接口来实现这一点。
- en: 'Add `IWeatherService` to `weather.service.ts`, as shown:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，将`IWeatherService`添加到`weather.service.ts`中：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Update `WeatherService` so that it implements the new interface:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`WeatherService`以实现新接口：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement a basic fake in `weather.service.fake.ts`, as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`weather.service.fake.ts`中实现一个基本的虚假。
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We're leveraging the existing `ICurrentWeather` interface that our fake data
    is correctly shaped, but we must also turn it into an `Observable`. This is easily
    achieved using `of`, which creates an observable sequence, given the provided
    arguments.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在利用现有的`ICurrentWeather`接口，以确保我们的虚假数据正确地构建，但我们还必须将其转换为`Observable`。这很容易通过使用`of`来实现，它会根据提供的参数创建一个可观察序列。
- en: Now you're ready to provide the fake to `AppComponent` and `CurrentWeatherComponent`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好为`AppComponent`和`CurrentWeatherComponent`提供虚假。
- en: Update providers for both components to use `WeatherServiceFake`
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新两个组件的提供者以使用`WeatherServiceFake`
- en: 'so that the fake will be used instead of the actual service:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以便虚假将被用于实际服务的替代品：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As your services and components get more complicated, it''s easy to provide
    an incomplete or inadequate test double. You may see errors such as NetworkError:
    Failed to execute ''send'' on ''XMLHttpRequest'', Can''t resolve all parameters, or [object
    ErrorEvent] thrown. In case of the latter error, click on the Debug button in
    Karma to discover the view error details, which may look like Timeout - Async
    callback was not invoked within timeout specified by jasmine. Unit tests are designed
    to run in milliseconds, so it should be impossible to actually hit the default
    5-second timeout. The issue is almost always with the test setup or configuration.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '随着您的服务和组件变得更加复杂，很容易提供一个不完整或不足的测试替身。您可能会看到诸如NetworkError: Failed to execute
    ''send'' on ''XMLHttpRequest''，Can''t resolve all parameters，或[object ErrorEvent]
    thrown等错误。在后一种错误的情况下，点击Karma中的调试按钮以发现视图错误详情，可能会显示为Timeout - Async callback was
    not invoked within timeout specified by jasmine。单元测试设计为在毫秒内运行，因此实际上应该不可能达到默认的5秒超时。问题几乎总是出现在测试设置或配置中。'
- en: We have successfully resolved all configuration and setup related issues with
    our unit tests. Now, we need to fix the unit tests that were generated with the
    initial code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功解决了所有与单元测试相关的配置和设置问题。现在，我们需要修复使用初始代码生成的单元测试。
- en: Jasmine specs
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 茉莉花规范
- en: There are two failing unit tests. In Jasmine lingo, unit tests are called specs,
    implemented by the `it` function; `it` functions are organized under the `describe`
    functions that contains helper methods that can execute before or after each test
    and handle the overall configuration needs of specs. Your app has five specs that
    have been generated for you, and two of them are now failing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个单元测试失败。在Jasmine术语中，单元测试称为规范，由`it`函数实现；`it`函数组织在包含可以在每个测试之前或之后执行的辅助方法的`describe`函数下，并处理规范的整体配置需求。您的应用程序为您生成了五个规范，其中两个现在失败了。
- en: 'The first is `AppComponent should have as title ''app''`; however, we deleted
    this property from `AppComponent`, because we are not using it. In this rare case,
    we need to do this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`AppComponent应该有标题'app'`；但是，我们从`AppComponent`中删除了这个属性，因为我们没有在使用它。在这种罕见情况下，我们需要这样做：
- en: Delete the `should have as title 'app'` unit test.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`应该有标题'app'`单元测试。
- en: The error message is descriptive enough to let you know what test is failing
    quickly. This happens, because the description provided to the `describe` function
    is `'AppComponent'` , and the description provided to the `it` function is `'should
    have as title "app"'`. Jasmine then appends any parent object's description to
    the description of the spec. As you write new tests, it is up to you to maintain
    readable descriptions for your specs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息足够描述性，可以让您快速了解哪个测试失败了。这是因为提供给`describe`函数的描述是'AppComponent'，而提供给`it`函数的描述是'应该有标题'app''。Jasmine然后将任何父对象的描述附加到规范的描述中。当您编写新的测试时，您需要维护规范的可读描述。
- en: The next error, `AppComponent` `should render title in a h1 tag`, is one that
    we must fix. We render the words `LocalCast Weather` in the `h1` tag now.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的错误，`AppComponent应该在h1标签中呈现标题`，是我们必须修复的一个错误。我们现在在`h1`标签中呈现`LocalCast Weather`这几个词。
- en: 'Update the `should render title in a h1 tag` test as shown:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`应该在h1标签中呈现标题`测试如下所示：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All unit tests are now successfully passing. We should be performing atomic
    commits, so let's commit the code changes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有单元测试现在都成功通过了。我们应该执行原子提交，所以让我们提交代码更改。
- en: Commit your code changes.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交您的代码更改。
- en: In order to achieve effective unit test coverage, you should focus on testing
    the correctness of functions that contain business logic. This means that you
    should pay extra attention to adhering to the Single Responsibility and Open/Closed
    Principles, the S and O in SOLID principles.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现有效的单元测试覆盖率，您应该专注于测试包含业务逻辑的函数的正确性。这意味着您应该特别注意遵守单一职责和开闭原则，即SOLID原则中的S和O。
- en: Angular e2e tests
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular e2e测试
- en: In addition to unit tests, Angular CLI also generates and configures e2e tests
    for your application. While unit tests focus on isolating the class-under-test,
    e2e tests are about integration testing. Angular CLI leverages Protractor along
    with WebDriver, so you can write **automated acceptance tests** (**AAT**) from
    the perspective of a user interacting with your application on a browser. As a
    rule of thumb, you should always write an order of magnitude more unit tests than
    AATs, because your app changes frequently and as a result, AATs are vastly more
    fragile and expensive to maintain compared to unit tests.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单元测试外，Angular CLI还为您的应用程序生成和配置e2e测试。虽然单元测试侧重于隔离被测试的类，e2e测试则是关于集成测试。Angular
    CLI利用Protractor和WebDriver，因此您可以从用户在浏览器上与您的应用程序交互的角度编写**自动接受测试**（**AAT**）。根据经验，您应该始终编写比AAT多一个数量级的单元测试，因为您的应用程序经常发生变化，因此与单元测试相比，AAT更加脆弱且昂贵。
- en: If the term web driver sounds familiar, it's because it is an evolution of the
    canonical Selenium WebDriver. As of March 30th, 2017, WebDriver has been proposed
    as an official web standard at the W3C. You read more about it at [https://www.w3.org/TR/webdriver](https://www.w3.org/TR/webdriver).
    If you're familiar with Selenium from before, you will feel right at home, since
    a lot of the patterns and practices are near identical.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果术语Web驱动程序听起来很熟悉，那是因为它是经典的Selenium WebDriver的演变。截至2017年3月30日，WebDriver已被提议为W3C的官方Web标准。您可以在[https://www.w3.org/TR/webdriver](https://www.w3.org/TR/webdriver)上阅读更多关于它的信息。如果您之前熟悉Selenium，您会感到宾至如归，因为许多模式和实践几乎是相同的。
- en: 'The CLI provides e2e tests for the initial `AppComponent` and depending on
    the complexity and the feature set of your application, it is up to you to follow
    the provided pattern to better organize your tests. There two files generated
    per component under the `e2e` folder:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: CLI为初始的`AppComponent`提供了e2e测试，根据应用程序的复杂性和功能集，您可以遵循提供的模式来更好地组织您的测试。在`e2e`文件夹下为每个组件生成两个文件：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`app.e2e-spec.ts` is written in Jasmine and implements acceptance tests. The
    spec is dependent upon the page object (`po`) file, which is defined beside the
    `spec` file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.e2e-spec.ts`是用Jasmine编写的，实现了验收测试。该规范依赖于页面对象（`po`）文件，该文件定义在`spec`文件旁边：'
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The page object file encapsulates web driver implementation specifics from the
    `spec` file. AATs are the most. This results in easy-to-maintain, human-readable
    spec files. By separating concerns at this level, you isolate fragility of AATs
    to one location. By leveraging class inheritance, you can build a robust collection
    of page objects that can be easier to maintain over time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 页面对象文件封装了来自“spec”文件的Web驱动程序实现细节。 AATs是最。这导致了易于维护、人类可读的规范文件。通过在这个级别分离关注点，您可以将AAT的脆弱性隔离到一个位置。通过利用类继承，您可以构建一个强大的页面对象集合，随着时间的推移更容易维护。
- en: e2e test execution
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: e2e测试执行
- en: 'You may execute the e2e tests with the following command in the terminal; ensure
    that the `npm test` process is not running:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在终端中使用以下命令执行e2e测试；确保`npm test`进程没有在运行：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You will note that the test execution is different as compared to unit tests.
    While you can configure a watcher to continually execute unit tests with Karma,
    due to the user-driven and stateful nature of e2e tests, it is not a good practice
    to attempt a similar configuration with e2e tests. Running the tests once and
    stopping the test harness ensures a clean state with every run.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到测试执行与单元测试不同。虽然您可以配置一个观察者来不断执行Karma的单元测试，但由于e2e测试的用户驱动和有状态的特性，尝试使用类似的配置来执行e2e测试并不是一个好的做法。运行测试一次并停止测试工具确保每次运行都有一个干净的状态。
- en: e2e spec
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: e2e规范
- en: 'After executing the e2e tests, you should see an error message similar to the
    one here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 执行e2e测试后，您应该会看到类似于这里的错误消息：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This error is similar to the unit test you fixed earlier:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误类似于您之前修复的单元测试：
- en: 'Update the `spec` to expect the correct header as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`spec`以期望正确的标题如下：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Rerun the tests and they should be passing now:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行测试，现在应该通过了：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Commit your code changes.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交您的代码更改。
- en: Troubleshooting common Angular errors
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排除常见的Angular错误
- en: Our unit tests and e2e tests are now working. In this section, you intentionally
    introduce an easy-to-make mistake so that you can become familiar with real-life
    errors that can be happen while developing your applications and gain a solid
    understanding of the tooling that makes make you an effective developer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试和e2e测试现在正在运行。在这一部分，您有意引入一个容易犯的错误，以便您可以熟悉在开发应用程序时可能发生的真实错误，并对使您成为一名有效的开发人员的工具有扎实的理解。
- en: 'Let''s pretend that we made an innocent mistake when copying and pasting the
    URL from the API documentation page on `OpenWeatherMap.org` and forgot to add
    `http://` in front of it. This is an easy mistake to make:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上按*option* + ⌘ + *I*，或在Windows上按*F12*或*Ctrl* + *Shift* + *I*打开Chrome开发者工具（dev
    tools）。
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Your app will compile successfully, but when you inspect the results in the
    browser, you won''t see any weather data. In fact, it seems like the `CurrentWeather`
    component is not rendering at all, as you can see in the image below:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用将成功编译，但当你在浏览器中检查结果时，你不会看到任何天气数据。事实上，就像你在下面的图片中看到的那样，`CurrentWeather`组件似乎根本没有渲染：
- en: '![](Images/702cc572-cc9a-42c5-9635-facae5ecfac5.png)CurrentWeather Does Not
    Render'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/8abe7631-fffb-459f-a67a-48885508448b.png)带有实时重新加载的并排开发'
- en: To find out why, you will need to debug your Angular app.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出原因，你需要调试你的Angular应用。
- en: Debugging with Chrome Developer Tools
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Chrome开发者工具进行调试
- en: As a developer, I use the Google Chrome browser because of its cross-platform
    and consistent developer tools with helpful extensions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，我使用谷歌Chrome浏览器，因为它具有跨平台和一致的开发者工具，还有有用的扩展。
- en: Open Chrome Developer Tools (dev tools) on macOS by pressing *option* + ⌘ +
    *I* or on Windows by pressing *F12* or *Ctrl* + *Shift* + *I*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/702cc572-cc9a-42c5-9635-facae5ecfac5.png)CurrentWeather未渲染'
- en: 'As a best practice, I code with VS Code and the browser open side by side,
    while the dev tools are also open in the browser. There are several good reasons
    for practicing side-by-side development:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，我会在VS Code和浏览器并排编码，同时在浏览器中也打开开发工具。有几个很好的理由来练习并排开发：
- en: '**Fast feedback loops**: With live-reloading, you see the end result of your
    changes very quickly'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速反馈循环**：通过实时重新加载，你可以很快看到你的更改的最终结果'
- en: '**Laptops**: A lot of developers now do most of their development on a laptop
    and a second monitor is a luxury'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**笔记本电脑**：现在很多开发人员大部分时间都在笔记本电脑上进行开发，而第二个显示器是一种奢侈。'
- en: '**Attention to responsive design**: As I have limited space to work with, I
    constantly pay attention to mobile-first development, fixing desktop layout issues
    after the fact'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意响应式设计：由于我有限的空间可用，我不断关注移动优先开发，在事后修复桌面布局问题。观察一下并排开发是什么样子的：
- en: '**Awareness of network activity**: To enable me to quickly see any API call
    errors and also ensure that the amount of data that is being requested remains
    in line within my expectations'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络活动意识**：为了让我能够快速看到任何API调用错误，并确保请求的数据量保持在我的预期范围内'
- en: '**Awareness of console errors**: To enable me to quickly react and troubleshoot
    when new errors are introduced'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台错误意识**：为了让我能够在引入新错误时快速做出反应和解决问题'
- en: 'Observe how side-by-side development looks like:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在从`OpenWeatherMap.org`的API文档页面复制和粘贴URL时犯了一个无心的错误，并忘记在其前面添加`http://`。这是一个容易犯的错误：
- en: '![](Images/8abe7631-fffb-459f-a67a-48885508448b.png)Side-by-side development
    with live-reloading runningUltimately, you should do what works best for you.
    With the side-by-side setup, I frequently find myself toggling VS Code''s Explorer
    on and off and resizing the dev tools pane to a larger or smaller size depending
    on the specific task at hand. To toggle VS Code''s Explorer, click on the Explorer
    icon circled in the preceding screenshot.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你应该做最适合你的事情。通过并排设置，我经常发现自己在打开和关闭VS Code的资源管理器，并根据手头的具体任务调整开发工具窗格的大小。要切换VS
    Code的资源管理器，请点击前面截图中圈出的资源管理器图标。
- en: Just as you can do side-by-side development with live-reloading using `npm start`,
    you can get the same kind of fast feedback loops for unit testing using `npm test`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以使用`npm start`进行带有实时重新加载的并排开发一样，你也可以使用`npm test`进行单元测试，获得同样类型的快速反馈循环。
- en: '![](Images/a7785cea-8818-426c-b393-7979d7c13f67.png)Side-by-side development
    with unit testing'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/a7785cea-8818-426c-b393-7979d7c13f67.png)并排开发与单元测试'
- en: With the side-by-side unit testing setup, you can become very effective in developing
    unit tests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过并排的单元测试设置，你可以在开发单元测试方面变得非常有效。
- en: Optimizing Chrome Dev Tools
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化Chrome开发工具
- en: For the side-by-side development with live-reloading to work well, you need
    to optimize the default dev tools experience.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使并排开发和实时重新加载正常工作，你需要优化默认的开发工具体验。
- en: '![](Images/75d088f6-c4a3-481d-ad5d-ceb75fc7c11b.png)Optimized Chrome Developer
    Tools'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/75d088f6-c4a3-481d-ad5d-ceb75fc7c11b.png)优化的Chrome开发者工具'
- en: 'Looking at the preceding figure, you will note that numerous settings and information
    radiators are highlighted:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中可以看出，有很多设置和信息显示器被突出显示：
- en: Have the Network tab open by default so that you can see network traffic flowing.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认打开网络选项卡，这样你就可以看到网络流量的流动。
- en: Open the dev tools settings by clicking on the ![](Images/0934097c-46b9-40a7-a157-d5685f22e518.png) 
    button.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击![](Images/0934097c-46b9-40a7-a157-d5685f22e518.png)按钮打开开发工具设置。
- en: Click on the right-hand side icon so that dev tools dock on the right-hand side
    of Chrome. This layout gives more vertical space, so you can see more network
    traffic and console events at once. As a side benefit, the left-hand side takes
    the rough size and shape of a mobile device.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右侧图标，使开发工具停靠在Chrome的右侧。这种布局可以提供更多的垂直空间，这样你就可以一次看到更多的网络流量和控制台事件。作为一个附带的好处，左侧的布局接近移动设备的大小和形状。
- en: Toggle on large request rows and toggle off overview to see more of the URL
    and parameters for each request and gain more vertical space.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到大请求行，并关闭概览，以便查看每个请求的URL和参数，并获得更多的垂直空间。
- en: Check the option to Disable cache, which will force reload every resource when
    you refresh a page while the dev tools are open. This prevents bizarre caching
    errors from ruining your day.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选禁用缓存选项，这样当你在打开开发工具的情况下刷新页面时，将强制重新加载每个资源。这可以防止奇怪的缓存错误影响你的工作。
- en: You will mostly be interested in seeing XHR calls to various APIs, so click
    on XHR to filter results.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你主要会对各种API的XHR调用感兴趣，所以点击XHR来过滤结果。
- en: Note that you can glance the number of console errors in the upper-right corner
    as 12. The ideal number of console errors should be 0 at all times.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，你可以在右上角看到控制台错误的数量为12。理想情况下，控制台错误的数量应该始终为0。
- en: Note that the top item in the request row is indicating that there's an error
    with status code 404 Not Found.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，请求行中的顶部项目表明状态码为404未找到的错误。
- en: Since we are debugging an Angular application, the Augury extension has been
    loaded. I will cover this tool in more detail in [Chapter 7](b35a976c-1709-4f43-9c4e-1cf957e7ca6c.xhtml),* Create
    a Router-First Line-of-Business App*, when you will be building a far more complicated
    app.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在调试一个Angular应用程序，Augury扩展已经加载。我将在[第7章](b35a976c-1709-4f43-9c4e-1cf957e7ca6c.xhtml)中更详细地介绍这个工具，*创建一个更复杂的应用程序时，你将会构建一个更复杂的应用程序。
- en: With your optimized dev tools environment, you can now effectively troubleshoot
    and resolve the application error from earlier.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有了优化的开发工具环境，你现在可以有效地排除之前的应用程序错误。
- en: Troubleshooting network issues
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除网络问题
- en: 'There are three visible issues with the app at this state:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个状态下，应用程序有三个可见的问题：
- en: The component details aren't displaying
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件详情没有显示
- en: There are numerous console errors
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有很多控制台错误。
- en: The API call is returning a 404 not found error
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API调用返回404未找到错误
- en: 'Begin by inspecting any network errors, since network errors usually cause
    knock-on effects:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查任何网络错误，因为网络错误通常会引起连锁反应：
- en: Click on the failing URL in the Network tab
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网络选项卡中点击失败的URL
- en: In the Details pane that opens to the right of the URL, click on the Preview
    tab
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在URL右侧打开的详细信息窗格中，点击预览选项卡
- en: 'You should see this:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到这个：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By just observing this error message, you will likely miss the fact that you
    forgot to add the `http://` prefix to the URL. The bug is subtle and certainly
    not glaringly obvious.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅观察这个错误消息，您很可能会忽略这样一个事实，即您忘记向URL添加`http://`前缀。这个错误很微妙，当然不是非常明显的。
- en: 'Hover over the URL and observe the full URL, as shown:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在URL上，并观察完整的URL，如下所示：
- en: '![](Images/b91c6120-fedf-41eb-af35-06e479b1bd40.png)Inspecting Network Errors'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/b91c6120-fedf-41eb-af35-06e479b1bd40.png)检查网络错误'
- en: As you can see, now the bug is glaringly obvious. In this view, we get to see
    the full URL, and it becomes clear that the URL defined in `weather.service.ts`
    is not fully qualified, so Angular is attempting to load the resource from its
    parent server, hosted on `localhost:5000`, instead of going over the web to the
    right server.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，现在这个错误非常明显。在这个视图中，我们可以看到完整的URL，并且清楚地看到`weather.service.ts`中定义的URL没有完全合格，因此Angular尝试从其父服务器`localhost:5000`上加载资源，而不是通过网络到正确的服务器上。
- en: Investigating console errors
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调查控制台错误
- en: 'Before you fix this issue, it is worthwhile to understand the knock-on effects
    of the failing API call:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在您修复此问题之前，值得了解API调用失败的连锁效应：
- en: 'Observe the console errors:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察控制台错误：
- en: '![](Images/08e5a182-5e45-4fc3-8867-87745b5daf94.png)Dev Tools Console Error
    Context'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/08e5a182-5e45-4fc3-8867-87745b5daf94.png)开发工具控制台错误上下文'
- en: The first element of note here is the ERROR CONTEXT object, which has a property
    named DebugContext_. The DebugContext_ contains a detailed snapshot of the current
    state of your Angular application when the error happened. The information contained
    within DebugContext_ is light years ahead of the amount of mostly unhelpful error
    messages AngularJS generates.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的第一个元素是`ERROR CONTEXT`对象，它有一个名为`DebugContext_`的属性。`DebugContext_`包含了发生错误时您的Angular应用程序的当前状态的详细快照。`DebugContext_`中包含的信息远远超过了AngularJS生成的大部分不太有用的错误消息。
- en: Properties that have the value (...) are property getters, and you must click
    on them to load their details. For example, if you click on the ellipsis for componentRenderElement,
    it will be populated with the app-current-weather element. You can expand the
    element to inspect the runtime condition of the component.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 值为(...)的属性是属性获取器，您必须点击它们以加载其详细信息。例如，如果您点击componentRenderElement的省略号，它将被填充为app-current-weather元素。您可以展开该元素以检查组件的运行时条件。
- en: Now scroll to the top of the console
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在滚动到控制台的顶部
- en: 'Observe the first error:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察第一个错误：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You have probably encountered the `TypeError` before. This error is caused by
    trying to access the property of an object that is not defined. In this case,
    `CurrentWeatherComponent.current` is not assigned to with an object, because the
    http call is failing. Since `current` is not initialized and the template blindly
    tries to bind to its properties like `{{current.city}}`, we get a message saying
    property 'city' of undefined cannot be read. This is the kind of knock-on effect
    that can create many unpredictable side-effects in your application. You must
    proactively code to prevent this condition.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能之前遇到过`TypeError`。这个错误是由于尝试访问未定义对象的属性而引起的。在这种情况下，`CurrentWeatherComponent.current`没有分配给一个对象，因为http调用失败了。由于`current`没有初始化，模板盲目地尝试绑定其属性，比如`{{current.city}}`，我们会得到一个消息，说无法读取未定义的属性'city'。这是一种连锁反应，可能会在您的应用程序中产生许多不可预测的副作用。您必须积极编码以防止这种情况发生。
- en: Karma, Jasmine, and Unit Testing errors
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Karma、Jasmine和单元测试错误
- en: When running tests with the `ng test` command, you will encounter some high-level
    errors that can mask the root cause of the actual underlying errors.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`ng test`命令运行测试时，你可能会遇到一些高级错误，这些错误可能掩盖了实际潜在错误的根本原因。
- en: The general approach to resolving errors should be inside out, resolving child
    component issues first and leaving parent and root components for last.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 解决错误的一般方法应该是从内而外，首先解决子组件的问题，最后解决父组件和根组件的问题。
- en: NetworkError
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络错误
- en: 'Network errors can be caused by a multitude of underlying issues:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 网络错误可能是由多种潜在问题引起的：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Working inside out, you should implement test doubles of services and provide
    the fakes to the appropriate components, as covered in the previous section. However,
    in parent components, you may still encounter errors even if you correctly provided
    fakes. Refer to the section on dealing with generic error events to uncover the
    underlying issues.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从内而外地工作，你应该实现服务的测试替身，并将伪造的东西提供给适当的组件，就像前一节所介绍的那样。然而，在父组件中，即使你正确地提供了伪造的东西，你可能仍然会遇到错误。请参考处理通用错误事件的部分，以揭示潜在的问题。
- en: Generic ErrorEvents
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用错误事件
- en: 'Error events are generic errors that hide the underlying cause:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 错误事件是隐藏潜在原因的通用错误：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To expose the root cause of a generic error, implement a new `test:debug` script:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了暴露通用错误的根本原因，实现一个新的`test:debug`脚本：
- en: 'Implement `test:debug`, as shown, in `package.json`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`package.json`中实现如下所示的`test:debug`：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Execute `npm run test:debug`
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm run test:debug`
- en: Now the Karma runner will likely reveal the underlying issue
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在Karma运行器可能会揭示潜在的问题
- en: If necessary, follow the stack trace to find the child component that may be
    causing the issue
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有必要，跟踪堆栈以找到可能导致问题的子组件
- en: If this strategy is not helpful, you may be able to glean more information on
    what's going wrong by break point debugging your unit tests.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种策略不起作用，你可以通过断点调试单元测试来获取更多关于出错原因的信息。
- en: Debugging with Visual Studio Code
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Visual Studio Code进行调试
- en: 'You can also debug your Angular application, Karma, and Protractor tests from
    directly within Visual Studio Code. First, you need to configure the debugger
    to work with a Chrome debugging environment, as illustrated:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以直接在Visual Studio Code中调试你的Angular应用程序、Karma和Protractor测试。首先，你需要配置调试器以与Chrome调试环境配合工作，如下所示：
- en: '![](Images/7da64ae5-7684-4230-a1e8-55bb8cb009c0.png)VS Code Debugging Setup'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/7da64ae5-7684-4230-a1e8-55bb8cb009c0.png)VS Code调试设置'
- en: Click on the Debug pane
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击调试窗格
- en: Expand the No Configurations dropdown and click on Add Configuration...
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开“无配置”下拉菜单，然后点击“添加配置...”
- en: In the Select Environment select box, select Chrome
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“选择环境”选择框中，选择Chrome
- en: This will create a default configuration in the `.vscode/launch.json` file.
    We will modify this file to add three separate configurations.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`.vscode/launch.json`文件中创建一个默认配置。我们将修改这个文件以添加三个单独的配置。
- en: 'Replace the contents of `launch.json` with the following configuration:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下配置替换`launch.json`的内容：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Execute the relevant CLI command like `npm start`, `npm test`, or `npm run e2e` beforeyou
    start the debugger
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始调试之前，执行相关的CLI命令，如`npm start`、`npm test`或`npm run e2e`
- en: On the Debug page, in the Debug dropdown, select npm start and click on the
    green play icon
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调试页面上，在调试下拉菜单中，选择npm start，然后点击绿色播放图标
- en: Observe that a Chrome instance has launched
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察Chrome实例是否已启动
- en: Set a break point on a `.ts` file
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.ts`文件上设置断点
- en: Perform the action in the app to trigger the break point
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序中的操作以触发断点
- en: If all goes well, Chrome will report that the code has been Paused in Visual
    Studio Code
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，Chrome将报告代码已在Visual Studio Code中暂停
- en: At the time of publication, this method of debugging doesn't reliably work.
    I had to manually set a break point in Chrome Dev Tools | Sources tab, finding
    the same `.ts` file under the `webpack://.` folder, which correctly triggered
    the break point in VS Code. However, this renders the entire benefit of using
    VS Code to debug code useless. For more information, follow the Angular CLI section
    on VS Code Recipes on GitHub at [https://github.com/Microsoft/vscode-recipes](https://github.com/Microsoft/vscode-recipes).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布时，这种调试方法并不总是可靠的。我不得不在Chrome Dev Tools | Sources标签中手动设置断点，在`webpack://.`文件夹下找到相同的`.ts`文件，这样才能正确地触发VS
    Code中的断点。然而，这使得使用VS Code调试代码的整个好处变得毫无意义。有关更多信息，请在GitHub上查看Angular CLI部分关于VS Code
    Recipes的内容：[https://github.com/Microsoft/vscode-recipes](https://github.com/Microsoft/vscode-recipes)。
- en: Null guarding in Angular
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular中进行null防范
- en: 'In JavaScript, the `undefined` and `null` values are a persistent issue that
    must be proactively dealt with every step of the way. There are multiple ways
    to guard against `null` values in Angular:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`undefined`和`null`值是一个持久性问题，必须在每一步积极地处理。在Angular中，有多种方法可以防范`null`值：
- en: Property Initialization
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性初始化
- en: Safe Navigation Operator `?.`
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全导航操作符`?.`
- en: Null Guarding with `*ngIf`
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`*ngIf`进行null防范
- en: Property initialization
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性初始化
- en: 'In statically-typed languages such as Java, it is drilled into you that proper
    variable initialization/instantiation is the key to error free operation. So let''s
    try that in `CurrentWeatherComponent` by initializing current with default values:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如Java这样的静态类型语言中，你被灌输了正确的变量初始化/实例化是无错误操作的关键。所以让我们在`CurrentWeatherComponent`中尝试通过使用默认值来初始化当前值：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The outcome of these changes will reduce console errors from 12 to 3, at which
    point you will only be seeing API call related errors. However, the app itself
    will not be in a presentable state, as you can see below:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改的结果将把控制台错误从12个减少到3个，此时您只会看到与API调用相关的错误。然而，应用本身仍然不是一个可以展示的状态，如下所示：
- en: '![](Images/0b7f8993-abf1-455f-aeaf-9af5a22498e2.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0b7f8993-abf1-455f-aeaf-9af5a22498e2.png)'
- en: Results of Property Initialization
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 属性初始化的结果
- en: To make this view presentable to user, we will have to code for default values
    on every property on the template. So by fixing the null guarding issue by initialization,
    we created a default value handling issue. Both the initialization and the default
    value handling are *O(n)* scale tasks for developers. At its best, this strategy
    will be annoying to implement and at its worst, highly ineffective and error prone,
    requiring, at minimum, *O(2n)* effort per property.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个视图对用户可见，我们必须在模板的每个属性上编写默认值的代码。因此，通过初始化来修复null防范问题，我们创建了一个默认值处理问题。对于开发人员来说，初始化和默认值处理都是*O(n)*规模的任务。在最好的情况下，这种策略将是烦人的实施，在最坏的情况下，高度无效且容易出错，每个属性至少需要*O(2n)*的工作量。
- en: Safe navigation operator
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全导航操作符
- en: 'Angular implements the safe navigation operation `?.` to prevent unintended
    traversals of undefined objects. So, instead of writing initialization code and
    having to deal with template values, let''s just update the template:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Angular实现了安全导航操作`?.`来防止对未定义对象的意外遍历。因此，我们只需更新模板，而不是编写初始化代码并处理模板值：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This time, we didn''t have to make up defaults, and we let Angular deal with
    displaying undefined bindings. You will note that just like the initialization
    fix, the errors have been reduced from 12 to 3\. The app itself is in a somewhat
    better shape. There''s no more confusing data being displayed; however, it still
    is not in a presentable state, as shown below:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们不必自己设置默认值，让Angular处理显示未定义的绑定。您会注意到，就像初始化修复一样，错误数量已经从12个减少到3个。应用本身的状态有所改善。不再显示混乱的数据；然而，它仍然不是一个可以展示的状态，如下所示：
- en: '![](Images/47b9f913-c1ae-4553-bdc4-87ace908cfa1.png)Results of Safe Navigation
    Operator'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/47b9f913-c1ae-4553-bdc4-87ace908cfa1.png)安全导航操作符的结果'
- en: You can probably imagine ways where the safe navigation operator can come in
    handy, in far more complicated scenarios. However, when deployed at scale, this
    type of coding still requires, at minimum, *O(n)* level of effort to implement.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能可以想象在更复杂的场景中安全导航操作符可以派上用场的方式。然而，当大规模部署时，这种类型的编码仍然需要至少*O(n)*级别的工作量来实现。
- en: Null guarding with *ngIf
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用*ngIf进行空值保护
- en: The idea strategy will be to use `*ngIf`, which is a structural directive, meaning
    Angular will stop traversing DOM tree elements beyond a falsy statement.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的策略是使用`*ngIf`，这是一个结构指令，意味着Angular将在假语句之后停止遍历DOM树元素。
- en: 'In the `CurrentWeather` component, we can easily check to see whether the `current`
    variable is null or undefined before attempting to render the template:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CurrentWeather`组件中，我们可以在尝试渲染模板之前轻松检查`current`变量是否为null或未定义：
- en: 'Update the topmost `div` element with `*ngIf` to check whether `current` is
    an object, as shown:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新顶层的`div`元素，使用`*ngIf`来检查`current`是否是一个对象，如下所示：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now observe the console log and that no errors are being reported. You always
    ensure that your Angular application reports zero console errors. If you're still
    seeing errors in the console log, ensure that you have correctly reverted the
    `OpenWeather` URL to its correct state or kill and restart your `npm start` process.
    I highly recommend that you resolve any console errors before moving on. Once
    you've fixed all errors, ensure that you commit your code again.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在观察控制台日志，没有报告任何错误。你始终要确保你的Angular应用程序报告零控制台错误。如果你仍然在控制台日志中看到错误，请确保你已经正确恢复了`OpenWeather`的URL到正确的状态，或者终止并重新启动你的`npm
    start`进程。我强烈建议在继续之前解决任何控制台错误。一旦你修复了所有错误，确保你再次提交你的代码。
- en: Commit your code.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交你的代码。
- en: Containerizing the app using Docker
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker对应用进行容器化
- en: 'Docker [docker.io](http://docker.io) is an *open platform* for developing,
    shipping, and running applications. Docker combines a *lightweight* container
    virtualization platform with workflows and tooling that help manage and deploy
    applications. The most obvious difference between **Virtual Machines** (**VMs**)
    and Docker containers are that VMs usually are dozens of gigabytes in size and
    require gigabytes of memory, whereas containers are megabytes in disk and memory
    size requirements. Furthermore, the Docker platform abstracts away host **operating
    system** (**OS**) level configuration settings, so every piece of configuration
    that is needed to successfully run an application is encoded within the human-readable
    Dockerfile format, as demonstrated here:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Docker [docker.io](http://docker.io) 是一个用于开发、发布和运行应用程序的开放平台。Docker结合了一个轻量级的容器虚拟化平台和工作流程以及工具，帮助管理和部署应用程序。虚拟机（VMs）和Docker容器之间最明显的区别是，VMs通常有数十GB的大小，需要数GB的内存，而容器在磁盘和内存大小方面只有几MB的要求。此外，Docker平台抽象了主机操作系统级别的配置设置，因此成功运行应用程序所需的每一部分配置都编码在人类可读的Dockerfile格式中，如下所示：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding file describes a new container that inherits from a container
    named `duluca/minimal-node-web-server`, changes the working directory to `/usr/src/app`,
    and then copies the contents of `dist` folder from your development environment
    into the container''s `public` folder. In this case, the parent image is configured
    with an Express.js server to act as a web server to serve the content inside the
    `public` folder. Refer to the following diagram for a visual representation of
    what''s happening:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件描述了一个新的容器，该容器继承自一个名为`duluca/minimal-node-web-server`的容器，将工作目录更改为`/usr/src/app`，然后将开发环境中`dist`文件夹的内容复制到容器的`public`文件夹中。在这种情况下，父镜像配置了一个Express.js服务器，充当web服务器，以提供`public`文件夹中的内容。请参考以下图表，以了解正在发生的情况的可视化表示：
- en: '![](Images/1ed1c77e-c276-4cfb-aaec-b4adb09ef402.jpg)Context of a Docker Image'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像的上下文
- en: At the base layer is our host OS, such as Windows or macOS that runs the Docker
    runtime, which will be installed in the next section. The Docker runtime is capable
    of running self-contained Docker images, which is defined by the aforementioned
    `Dockerfile`. `duluca/minimal-node-web-server` is based off of the lightweight
    Linux operating system Alpine. Alpine is a completely pared down version of Linux
    that doesn't come with any GUI, drivers or even most CLI tools you may expect
    from a Linux system. As a result, the OS is around only ~5 MB in size. The base
    package then installs Node.js, which itself is around ~10 MB in size and my custom
    Node.js-based Express.js web server, resulting in a tiny ~15 MB image. The Express
    server is configured to serve the contents of the `/usr/src/app` folder. In the
    preceding `Dockerfile`, we merely copy the contents of the `/dist` folder in our
    development environment and place it into the `/usr/src/app` folder. We will later
    build and execute this image, which will run our Express web server containing
    the output of our `dist` folder.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础层是我们的主机操作系统，比如Windows或macOS，它运行Docker运行时，将在下一节中安装。Docker运行时能够运行自包含的Docker镜像，这是由上述的`Dockerfile`定义的。`duluca/minimal-node-web-server`基于轻量级的Linux操作系统Alpine。Alpine是Linux的一个完全精简版本，不带有任何图形界面，驱动程序，甚至大多数你可能期望从Linux系统中得到的CLI工具。因此，这个操作系统的大小只有大约5MB。基础软件包然后安装了Node.js，Node.js本身的大小约为10MB，以及我定制的基于Node.js的Express.js
    web服务器，结果是一个微小的约15MB的镜像。Express服务器被配置为提供`/usr/src/app`文件夹的内容。在前面的`Dockerfile`中，我们只是将开发环境中`/dist`文件夹的内容复制到`/usr/src/app`文件夹中。我们稍后将构建并执行这个镜像，这将运行我们的Express
    web服务器，其中包含我们`dist`文件夹的输出。
- en: The beauty of Docker is that you can navigate to [https://hub.docker.com](https://hub.docker.com),
    search for `duluca/minimal-node-web-server`, read its `Dockerfile`, and trace
    its origins all the way back to the original base image that is the foundation
    of the web server. I encourage you to vet every Docker image you use in this manner
    to understand what exactly it brings to the table for your needs. You may find
    it either overkill or has features you never knew about that can make your life
    a lot easier. Note that the parent images require a specific version of `duluca/minimal-node-web-server` at `8.11.1`.
    This is quite intentional, and as the reader, you should choose the latest available
    version of a Docker image you find. However, if you don't specify a version number,
    you will always get the latest version of the image. As more versions of an image
    is published, you may pull a future version that may break your application. For
    this reason, always specify a version number for images you're depending on.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的美妙之处在于你可以导航到[https://hub.docker.com](https://hub.docker.com)，搜索`duluca/minimal-node-web-server`，阅读它的`Dockerfile`，并追溯其源头直到作为web服务器基础的原始基础镜像。我鼓励你以这种方式审查你使用的每个Docker镜像，以了解它对你的需求到底带来了什么。你可能会发现它要么过度复杂，要么有你以前不知道的功能，可以让你的生活变得更加轻松。请注意，父镜像需要特定版本的`duluca/minimal-node-web-server`，为`8.11.1`。这是非常有意义的，作为读者，你应该选择你找到的Docker镜像的最新可用版本。然而，如果你不指定版本号，你将始终获得镜像的最新版本。随着镜像的发布更多版本，你可能会拉取一个未来版本，可能会破坏你的应用程序。因此，对于你依赖的镜像，总是指定一个版本号。
- en: 'One such case is the HTTPS redirection support that is baked into `duluca/minimal-node-web-server`.
    You can spend countless hours trying to set up a nginx proxy to do the same thing,
    when all you need to do is add the following line to your Dockerfile:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一个这样的案例是`duluca/minimal-node-web-server`中内置的HTTPS重定向支持。当你只需要在你的Dockerfile中添加以下行时，你可以花费无数小时尝试设置一个nginx代理来做同样的事情：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Just like npm packages, Docker can bring great convenience and value, but you
    must take care to understand the tools you are working with.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就像npm包一样，Docker可以带来巨大的便利和价值，但你必须小心地理解你正在使用的工具。
- en: In [Chapter 11](ba073d6f-c0a0-4681-aea6-aeedac3cbc69.xhtml), *Highly-Available
    Cloud Infrastructure on AWS,* I mention the use of a lower footprint docker image
    based on Nginx. If you're comfortable configuring `nginx`, you can use `duluca/minimal-nginx-web-server`
    as your base image.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](ba073d6f-c0a0-4681-aea6-aeedac3cbc69.xhtml)中，*AWS上高可用云基础设施*，我提到了基于Nginx的低占用的docker镜像的使用。如果你熟悉配置`nginx`，你可以使用`duluca/minimal-nginx-web-server`作为你的基础镜像。
- en: Installing Docker
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker
- en: In order to be able to build and run containers, you must first install the
    Docker execution environment on your computer.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够构建和运行容器，你必须首先在你的计算机上安装Docker执行环境。
- en: Windows support of Docker can be challenging. You must have a PC with a CPU
    that supports virtualization extensions, which is not a guarantee on laptops.
    You must also have a Pro version of Windows with Hyper-V enabled. On the flip
    side, Windows Server 2016 has native support for Docker, which is an unprecedented
    amount of support shown by Microsoft toward the industry initiative to adopt Docker
    and containerization.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Windows对Docker的支持可能具有挑战性。你必须拥有一个支持虚拟化扩展的CPU的PC，这在笔记本电脑上并不是一定的。你还必须拥有启用了Hyper-V的Windows专业版。另一方面，Windows
    Server 2016原生支持Docker，这是微软向行业采用Docker和容器化倡议所表现出的前所未有的支持量。
- en: 'Install Docker by executing the following command:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令安装Docker：
- en: 'For Windows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows：
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For macOS:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于macOS：
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Execute `docker -v` to verify the installation.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`docker -v`来验证安装。
- en: Setting up Docker scripts
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Docker脚本
- en: 'Now, let''s configure some Docker scripts that you can use to automated the
    building, testing, and publishing of your container. I have developed a set of
    scripts called **npm Scripts for Docker** that work on Windows 10 and macOS. You
    can get the latest version of these scripts at [bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置一些Docker脚本，您可以使用这些脚本来自动构建，测试和发布您的容器。我开发了一组名为**npm Scripts for Docker**的脚本，适用于Windows
    10和macOS。您可以在[bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker)获取这些脚本的最新版本：
- en: Sign up for a Docker Hub account on [https://hub.docker.com/](https://hub.docker.com/)
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://hub.docker.com/](https://hub.docker.com/)上注册Docker Hub帐户
- en: Create a public (free) repository for your application
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的应用程序创建一个公共（免费）存储库
- en: Unfortunately, at the time of publication, Zeit doesn't support private Docker
    Hub repositories, so your only alternative is to publish your container publicly.
    If your image must remain private, I encourage you to set up an AWS ECS environment
    as described in [Chapter 11](ba073d6f-c0a0-4681-aea6-aeedac3cbc69.xhtml), *Highly-Available
    Cloud Infrastructure on AWS*. You can keep tabs on the issue by visiting Zeit
    Now's documentation at [zeit.co/docs/deployment-types/docker](https://zeit.co/docs/deployment-types/docker).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在发布时，Zeit不支持私有Docker Hub存储库，因此您的唯一选择是公开发布您的容器。如果您的图像必须保持私有，我建议您按照[第11章](ba073d6f-c0a0-4681-aea6-aeedac3cbc69.xhtml)中描述的在AWS
    ECS环境中设置的方法进行操作，*在AWS上构建高可用云基础设施*。您可以通过访问Zeit Now的文档[zeit.co/docs/deployment-types/docker](https://zeit.co/docs/deployment-types/docker)来了解问题的最新情况。
- en: 'Update `package.json` to add a new config property with the following configuration
    properties:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`package.json`以添加一个新的配置属性，具有以下配置属性：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The namespace will be your DockerHub username. You will be defining what your
    repository is called during creation. An example image repository variable should
    look like `duluca/localcast-weather`. The image name is for easy identification
    of your container, while using Docker commands such as `docker ps`. I will call
    mine just `localcast-weather`. The port will define which port should be used
    to expose your application from inside the container. Since we use `5000` for
    development, pick a different one, like `8080`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间将是您的DockerHub用户名。您将在创建过程中定义您的存储库的名称。示例图像存储库变量应如`duluca/localcast-weather`。图像名称用于轻松识别您的容器，同时使用Docker命令，如`docker
    ps`。我将只称之为`localcast-weather`。端口将定义应从容器内部使用哪个端口来公开您的应用程序。由于我们在开发中使用`5000`，请选择另一个端口，如`8080`。
- en: Add Docker scripts to `package.json` by copy-pasting the scripts from [bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker).
    Here's an annotated version of the scripts that explains each function.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从[bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker)复制粘贴脚本将Docker脚本添加到`package.json`。以下是脚本的注释版本，解释了每个功能。
- en: 'Note that with npm scripts, the `pre` and `post` keywords are used to execute
    helper scripts, respectively, before or after the execution of a given script
    and scripts are intentionally broken into smaller pieces to make it easier to
    read and maintain them:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用npm脚本时，`pre`和`post`关键字分别用于在给定脚本的执行之前或之后执行辅助脚本，并且脚本故意分成较小的部分，以便更容易阅读和维护它们：
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`npm run docker:build` will build your Angular application in `pre`, then build
    the Docker image using the `docker image build` command and tag the image with
    a version number in post:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:build`将在`pre`中构建您的Angular应用程序，然后使用`docker image build`命令构建Docker镜像，并在`post`中为图像打上版本号：'
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`npm run docker:tag` will tag an already built Docker image using the version
    number from the `version` property in `package.json` and the `latest` tag:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:tag`将使用`package.json`中的`version`属性的版本号和`latest`标签标记已构建的Docker镜像：'
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`npm run docker:run` will remove any existing, prior version of an image and
    run the already built image using the `docker run` command. Note that the `imagePort`
    property is used as the external port of the Docker image, which is mapped to
    the internal port of the image that the Node.js server listens to, port `3000`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:run`将删除任何现有的先前版本的镜像，并使用`docker run`命令运行已构建的镜像。请注意，`imagePort`属性用作Docker镜像的外部端口，该端口映射到Node.js服务器监听的图像的内部端口`3000`：'
- en: '[PRE36]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`npm run docker:publish` will publish a built image to the configured repository,
    in this case, Docker Hub, using the `docker image push` command. First, the versioned
    image is published, followed by one tagged with `latest` in post:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:publish`将使用`docker image push`命令将构建的镜像发布到配置的存储库，本例中为Docker
    Hub。首先发布带版本标签的镜像，然后发布带`latest`标签的镜像。'
- en: '[PRE37]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`npm run docker:clean` will remove a previously built version of the image
    from your system, using the `docker rm -f` command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:clean`将使用`docker rm -f`命令从系统中删除先前构建的镜像：'
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`npm run docker:taillogs` will display the internal console logs of a running
    Docker instance using the `docker log -f` command, a very useful tool when debugging
    your Docker instance:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm run docker:taillogs`将使用`docker log -f`命令显示正在运行的Docker实例的内部控制台日志，这是在调试Docker实例时非常有用的工具：
- en: '[PRE39]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`npm run docker:open:win` or `npm run docker:open:mac` will wait for 2 seconds
    and then launch the browser with the correct URL to your application using the
    `imagePort` property:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:open:win`或`npm run docker:open:mac`将等待2秒，然后使用`imagePort`属性以正确的URL启动浏览器到您的应用程序：'
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`npm run docker:debug` will build your image and run an instance of it in `pre`,
    open the browser, and then start displaying the internal logs of the container.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:debug`将构建您的镜像并在`pre`中运行一个实例，打开浏览器，然后开始显示容器的内部日志。'
- en: 'Install two development dependencies that are needed to ensure cross-platform
    functionality of the scripts:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装两个开发依赖项，以确保脚本的跨平台功能：
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Customize the pre-build script to execute unit and e2e tests before building
    the image:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义预构建脚本以在构建图像之前执行单元测试和e2e测试：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Note that `npm run build` is provided the `--prod` argument, which achieves
    two things:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`npm run build`提供了`--prod`参数，可以实现两个目标：
- en: 1\. Development time payload of ~2.5 MB is optimized down to ~73kb or less
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 将约2.5 MB的开发时间负载优化为约73kb或更少
- en: 2\. The configuration items defined in `src/environments/environment.prod.ts`
    is used at runtime
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在`src/environments/environment.prod.ts`中定义的配置项在运行时使用
- en: 'Update `src/environments/environment.prod.ts` to look like using your own `appId`
    from `OpenWeather`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`src/environments/environment.prod.ts`，使用您自己的`OpenWeather`的`appId`：
- en: '[PRE43]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We are modifying how `npm test` is executed, so the tests are run only once
    and the tool stops executing. The `--watch=false` option is provided to achieve
    this behavior, as opposed to the development-friendly default continuous execution
    behavior. In addition `npm run build` is provided with `--output-path dist` to
    ensure that `index.html` is published at the root of the folder.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在修改`npm test`的执行方式，以便测试只运行一次，工具停止执行。提供`--watch=false`选项以实现此行为，而不是默认的持续执行行为。此外，`npm
    run build`提供了`--output-path dist`，以确保`index.html`发布在文件夹的根目录。
- en: Create a new file named `Dockerfile` with no file-extensions
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Dockerfile`的新文件，没有文件扩展名
- en: 'Implement the `Dockerfile`, as shown:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Dockerfile`，如下所示：
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Be sure to inspect the contents of your `dist` folder. Ensure that `index.html`
    is at the root of `dist`. Otherwise ensure that your `Dockerfile` copies the folder
    that has `index.html` at its root.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 确保检查`dist`文件夹的内容。确保`index.html`位于`dist`的根目录。否则，请确保您的`Dockerfile`复制具有`index.html`的文件夹。
- en: Execute `npm run predocker:build` to ensure that your application changes have
    been successful
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm run predocker:build`以确保您的应用程序更改已成功
- en: Execute `npm run docker:build` to ensure that your image builds successfully
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm run docker:build`以确保您的镜像成功构建
- en: 'While you can run any of the provided scripts individually, you really only
    need to remember two of them going forward:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以单独运行提供的任何脚本，但您实际上只需要记住其中两个：
- en: '**npm run docker:debug **will test, build, tag, run, tail and launch your containerize
    app in a new browser window for testing'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**npm run docker:debug**将在新的浏览器窗口中测试、构建、标记、运行、追踪和启动您的容器化应用程序'
- en: '**npm run docker:publish **will publish the image you just built and test to
    the online Docker repository'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**npm run docker:publish**将发布您刚刚构建和测试的图像到在线Docker存储库'
- en: 'Execute `docker:debug` in your terminal:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行`docker:debug`：
- en: '[PRE45]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You will note that the scripts display errors in the Terminal window. These
    are not necessarily indicators of a failure. The scripts are not polished, so
    they attempt both Windows and macOS compatible scripts parallelly, and during
    a first build, the clean command fails, because there's nothing to clean. By the
    time you read this, I may have published better scripts; if not, you're more than
    welcome to submit a pull request.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到脚本在终端窗口中显示错误。这些并不一定是失败的指标。脚本并不完善，因此它们会同时尝试Windows和macOS兼容的脚本，并且在第一次构建时，清理命令会失败，因为没有东西需要清理。在您阅读此文时，我可能已经发布了更好的脚本；如果没有，您可以随时提交拉取请求。
- en: 'A successful `docker:debug` run should result in a new in-focus browser window
    with your application and the server logs being tailed in the terminal, as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的`docker:debug`运行应该会在焦点中打开一个新的浏览器窗口，显示您的应用程序和服务器日志在终端中被追踪，如下所示：
- en: '[PRE46]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You should always run `docker ps` to check whether your image is running, when
    it was last updated, or if it is clashing with the existing images claiming the
    same port.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终运行`docker ps`来检查您的镜像是否正在运行，上次更新时间，或者它是否与声称相同端口的现有镜像发生冲突。
- en: 'Execute `docker:publish` in your terminal:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行`docker:publish`：
- en: '[PRE47]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You should observe a successful run in the Terminal window like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端窗口中观察到成功运行，如下所示：
- en: '[PRE48]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Over time, your local Docker cache may grow to a significant size, that is,
    on my laptop, roughly 40 GB over two years. You can use the `docker image prune`
    and `docker container prune` commands to reduce the size of your cache. For more
    detailed information, refer to the documentation at [https://docs.docker.com/config/pruning](https://docs.docker.com/config/pruning).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，您的本地Docker缓存可能会增长到相当大的规模，在我的笔记本电脑上大约是两年40GB。您可以使用`docker image prune`和`docker
    container prune`命令来减小缓存的大小。有关更详细的信息，请参阅[https://docs.docker.com/config/pruning](https://docs.docker.com/config/pruning)上的文档。
- en: Let's look into an easier way to interact with Docker next.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下与Docker互动的更简单的方法。
- en: Docker extension in VS Code
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VS Code中的Docker扩展
- en: 'Another way to interact with Docker images and containers is through VS Code.
    If you have installed the `PeterJausovec.vscode-docker` Docker extension, as suggested
    in [Chapter 2](312e0dbe-54ac-45c6-97c7-f41c98723919.xhtml)*, Create a Local Weather
    Web Application*, you will see an expandable title named DOCKER in the Explorer
    pane of VS Code, as pointed out with an arrow in the following screenshot:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 与Docker镜像和容器互动的另一种方式是通过VS Code。如果您已经安装了`PeterJausovec.vscode-docker` Docker扩展，如[第2章](312e0dbe-54ac-45c6-97c7-f41c98723919.xhtml)*创建本地天气Web应用程序*中建议的那样，您将在VS
    Code的资源管理器窗格中看到一个名为DOCKER的可展开标题，如下截图中的箭头所指出的那样：
- en: '![](Images/b002db3c-9f9a-4476-b5bb-90c2085ac184.png)Docker extension in VS
    Code'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/b002db3c-9f9a-4476-b5bb-90c2085ac184.png)VS Code中的Docker扩展'
- en: 'Let''s go through some of the functionality provided by the extension:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下扩展提供的一些功能：
- en: '**Images** contains a list of all the container snapshots that exist on your
    system'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**镜像**包含系统上存在的所有容器快照的列表'
- en: Right-clicking on a Docker image brings up a context menu to run various operations
    on it, like run, push and tag
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击Docker镜像会弹出上下文菜单，可以在其中运行各种操作，如运行、推送和标记
- en: '**Containers** list all executable Docker containers that exist on your system,
    which you start, stop or attach to'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**容器**列出系统上存在的所有可执行Docker容器，您可以启动、停止或附加到它们'
- en: '**Registries** display the registries that you''re configured to connect to,
    like DockerHub or AWS Elastic Container Registry'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**注册表**显示您配置连接的注册表，如DockerHub或AWS弹性容器注册表'
- en: While the extension makes it easier to interact with Docker, **npm Scripts for
    Docker** automate a lot of the chores related to building, tagging and testing
    and image. They are cross-platform and will work equally well in a continuous
    integration environment.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然该扩展使与Docker的交互变得更容易，**npm脚本用于Docker**可以自动化与构建、标记和测试镜像相关的许多琐事。它们是跨平台的，并且在持续集成环境中同样有效。
- en: You may find it confusing to interact with npm scripts in general through the
    CLI. Let's look at VS Code's npm script support next.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 通过CLI与npm脚本进行交互可能会让您感到困惑。让我们接下来看一下VS Code的npm脚本支持。
- en: NPM Scripts in VS Code
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VS Code中的NPM脚本
- en: 'VS Code provides support for npm scripts out of the box. In order to enable
    npm script explorer, open VS Code settings and ensure that the `"npm.enableScriptExplorer":
    true` property is present. Once you do, you will see an expandable title named NPM
    SCRIPTS in the Explorer pane, as pointed out with an arrow here:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 'VS Code默认支持npm脚本。为了启用npm脚本资源管理器，打开VS Code设置，并确保存在`"npm.enableScriptExplorer":
    true`属性。一旦您这样做了，您将在资源管理器窗格中看到一个可展开的标题，名为NPM SCRIPTS，如下箭头所指：'
- en: '![](Images/ce308d57-171d-4d8b-a50f-1d11a1dcb2e9.png)NPM Scripts in VS Code'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/ce308d57-171d-4d8b-a50f-1d11a1dcb2e9.png)VS Code中的NPM脚本'
- en: You can click on any script to launch the line that contains the script in `package.json`
    or right-click and select Run to execute the script.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以单击任何脚本来启动包含该脚本的行`package.json`，或者右键单击并选择运行来执行该脚本。
- en: Deploying containerized app
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署容器化应用
- en: If delivering something to production is difficult from a coding perspective,
    it is extremely difficult to do it right from an infrastructure perspective. In
    the later chapters, I will cover how to provision a world-class AWS **Elastic
    Container Service** (**ECS**) infrastructure for your applications, but that won't
    help if you need to quickly demonstrate an idea. Enter, Zeit Now.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从编码的角度来看，将某些东西交付到生产环境是困难的，那么从基础架构的角度来看，要做到正确更是极其困难。在后面的章节中，我将介绍如何为您的应用程序配置世界一流的AWS
    **弹性容器服务**（**ECS**）基础架构，但如果您需要快速展示一个想法，这是无济于事的。现在，Zeit Now登场了。
- en: Zeit Now
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zeit Now
- en: Zeit Now, [https://zeit.co/now](https://zeit.co/now), is a multi-cloud service
    that enables real-time global deployments of applications directly from the CLI.
    Now works with applications that either correctly implement `package.json` or
    a `Dockerfile`. Even though we have done both, we will prefer to deploy our Docker
    image, because a lot more magic is applied behind the scenes to make a `package.json`
    deployment work, whereas your Docker image can be deployed anywhere, including
    AWS ECS.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Zeit Now，[https://zeit.co/now](https://zeit.co/now)，是一个多云服务，可以实现应用程序的实时全球部署，直接从CLI进行。Now可以与正确实现`package.json`或`Dockerfile`的应用程序一起工作。尽管我们两者都做了，但我们更喜欢部署我们的Docker镜像，因为在幕后会应用更多的魔法来使`package.json`部署工作，而您的Docker镜像可以部署到任何地方，包括AWS
    ECS。
- en: Configuring the Now CLI tool
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Now CLI工具
- en: 'Now, let''s configure Zeit Now to work on your repository:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置Zeit Now来在您的存储库上工作：
- en: Install Zeit Now by executing `npm i -g now`
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`npm i -g now`来安装Zeit Now
- en: Ensure correct installation by executing `now -v`
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`now -v`来确保正确安装
- en: Create a new folder under `local-weather-app` called `now`
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`local-weather-app`下创建一个名为`now`的新文件夹
- en: Create a new `Dockerfile` under the new `now` folder
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的`now`文件夹下创建一个新的`Dockerfile`
- en: 'Implement the file to pull from the image you just published:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现从您刚刚发布的图像中提取文件：
- en: '[PRE49]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, execute the `now` command in your terminal and follow the instructions
    to the finish configuration:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在您的终端中执行`now`命令，并按照说明完成配置：
- en: '[PRE50]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Deploying
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: 'Deploying on Zeit Now is very easy:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在Zeit Now上部署非常容易：
- en: 'Change your working directory to `now` and execute the command:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的工作目录更改为`now`并执行命令：
- en: '[PRE51]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the Terminal window, the tool will report its progress and the URL from
    which you can access your now published app:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中，该工具将报告其进度和您可以访问您的已发布应用程序的URL：
- en: '[PRE52]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Navigate to the URL listed on the second line and verify the publication of
    your app.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到第二行列出的URL，并验证您的应用程序的发布。
- en: Note that if you've made a configuration error along the way, your browser may
    display an error saying This page is trying to load unsafe scripts, allow and
    reload to see your app.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您在途中出现配置错误，您的浏览器可能会显示一个错误，指出此页面正在尝试加载不安全的脚本，请允许并重新加载以查看您的应用程序。
- en: You can explore Zeit Now's paid features, which allow for advanced features
    such as automated scaling for your application.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以探索Zeit Now的付费功能，这些功能允许为您的应用程序提供高级功能，例如自动扩展。
- en: Congratulations, you are app is live on the internet!
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您的应用程序已在互联网上发布！
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you mastered unit and e2e test configuration and setup. You
    optimized your troubleshooting tools and became aware of the common Angular errors
    you will encounter while developing applications. You learned how to best avoid
    Angular console errors by guarding against null data. You configured your system
    to work with Docker and successfully containerized your web application with its
    own dedicated web server. You configured your project with npm scripts for Docker
    that can be leveraged by any team member. Finally, you have successfully delivered
    a web application in the cloud.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您掌握了单元测试和端到端测试的配置和设置。您优化了故障排除工具，并了解了在开发应用程序时可能遇到的常见Angular错误。您学会了如何通过防范空数据来最好地避免Angular控制台错误。您配置了系统以与Docker一起工作，并成功地为您的Web应用程序容器化了自己专用的Web服务器。您为Docker配置了项目的npm脚本，可以被任何团队成员利用。最后，您成功地在云中交付了一个Web应用程序。
- en: Now you know what takes to build a production-ready Angular application that
    is reliable, resilient, and containerized to allow for a flexible deployment strategy.
    In the next chapter, we will improve the apps feature set and make it look great
    using Angular Material.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何构建一个可靠、弹性和容器化的生产就绪的Angular应用程序，以实现灵活的部署策略。在下一章中，我们将改进应用程序的功能集，并使用Angular
    Material使其看起来更加出色。
