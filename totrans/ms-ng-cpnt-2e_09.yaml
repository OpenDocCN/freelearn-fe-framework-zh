- en: Spaceship Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I was a child, I loved to play spaceship pilot. I piled up old carton boxes
    and decorated the interiors to look like a spaceship cockpit. With a marker, I
    drew a spaceship dashboard on the inside of the boxes, and I remember playing
    in there for hours.
  prefs: []
  type: TYPE_NORMAL
- en: The thing that's special about the design of cockpits and spaceship dashboard
    is that they need to provide an overview and control over the whole spaceship,
    in very limited space. I think the same applies to application dashboards. A dashboard
    should provide the user with an overview and a sense of the overall status of
    what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will create such a dashboard for our task management application.
    We will make use of the open source charting library Chartist to create good looking,
    responsive charts and provide an overview of open tasks and project statuses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/926c564d-4442-4162-9cce-752159eb7aff.png)'
  prefs: []
  type: TYPE_IMG
- en: A preview of the tasks chart that we will build in this chapter
  prefs: []
  type: TYPE_NORMAL
- en: 'On a higher level, we will create the following components in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project summary**: This is the project summary that will provide a quick
    insight into the overall project status. By aggregating the efforts of all tasks
    in a project, we can provide a nice overall effort status, for which we have created
    the components in the previous chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project activity chart**: Without any labels or scales, this bar chart will
    give a quick sense of the activity on projects in the last 24 hours.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project tasks chart**: This chart will provide an overview of the task progress
    on projects. Using a line chart, we will display the count of open tasks over
    a certain time period. Using the toggle component that we created in [Chapter
    2](11f96942-6e99-46c5-b152-1af3b2579d44.xhtml), *Ready, Set, Go!*, we''ll provide
    an easy way for the user to switch the timeframe displayed on the chart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Chartist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create some components that will render charts, and
    we should look for some help in rendering them. Of course, we can follow a similar
    approach to what we used in [Chapter 6](2ba38f09-ef9f-4aee-952f-3ade56c99356.xhtml),
    *Keeping up with Activities*, when we drew our activity timeline. However, when
    it comes to more complex data visualization, it's better to rely on a library
    to do the heavy lifting.
  prefs: []
  type: TYPE_NORMAL
- en: It shouldn't be a surprise that we'll use a library called Chartist to fill
    this gap, because I've spent almost two years writing it. As the author of Chartist,
    I feel very lucky that we've found a perfect spot in this book to make use of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: I'd like to take the opportunity to briefly introduce you to Chartist, before
    we dive into the implementation of the components for our dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Chartist claims to provide simple responsive charts. Luckily, this is still
    the case after three years of existence. I can tell you that the hardest job of
    maintaining this library was probably protecting it from feature bloat. There
    are so many great movements, technologies, and ideas in the open source community,
    and to resist bloating the scope of the library and always stay focused on the
    initial claim wasn't easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me show you a very basic example of how you can create a simple line chart,
    once you''ve included the Chartist scripts on your website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding HTML markup that is required for this example looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows you the resulting chart that is rendered by Chartist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3968c7cc-44ba-4d16-83b5-daf2edc809d9.png)'
  prefs: []
  type: TYPE_IMG
- en: A simple line chart rendered with Chartist
  prefs: []
  type: TYPE_NORMAL
- en: I believe that by saying we'll stick to being simple, we've not promised too
    much.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the second core concern of Chartist, which is to be perfectly
    responsive. Chartist tries to stick to a very clear separation of concerns wherever
    possible, which means that it uses CSS for its appearance, SVG for its basic graphical
    structure, and JavaScript for any behaviors. By following this principle, we've
    already enabled a lot of responsiveness. We can use CSS media queries to apply
    different styles to our charts on different media.
  prefs: []
  type: TYPE_NORMAL
- en: While CSS is great for visual styles, there are plenty of elements in the process
    of rendering charts, which, unfortunately, can't be controlled by CSS. After all,
    that is the reason why we use a JavaScript library to render charts.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we control how Chartist renders our charts on different media, if
    we don't have control over this in CSS? Well, Chartist provides something called
    **responsive configuration overrides**. Using the browser's `matchMedia` API,
    Chartist is able to provide a configuration mechanism that allows you to specify
    options that you want to use only on certain media (mobile, desktop etc.).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example of how we can easily implement responsive behavior
    using a mobile-first approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the second parameter to the `Chartist.Line` constructor sets
    the initial options; we can provide overriding options, annotated with media queries
    in an array, as the third parameter of the constructor. In this example, we'll
    override the `showPoint` option for any media larger than 400 px in width. Media
    larger than 800 px in width will receive both the `showPoint` override and the
    `lineSmooth` override.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only can we specify real media queries to trigger setting changes, but
    we can also use an overriding mechanism that is very similar to CSS. This way,
    we can implement various approaches, such as ranged or exclusive media queries,
    mobile-first, or desktop-first. The responsive options mechanism can be used for
    all of the options available in Chartist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e4ec997-6217-4cf6-a2f7-f9a8c40b3e15.png)'
  prefs: []
  type: TYPE_IMG
- en: Displaying the previous chart on three different media, left to right, with
    a media with less than 400 px (A), less than 800 px (B), and more than 800 px
    (C)
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, implementing complex responsive behavior is a breeze with Chartist.
    Although our task management application was never meant to be a responsive web
    application, we can still benefit from this feature, in order to optimize our
    content.
  prefs: []
  type: TYPE_NORMAL
- en: That's enough about Chartist to get you started. If you would like to know more
    about my library, I recommend that you check out the project's website at [http://gionkunz.github.io/chartist-js](http://gionkunz.github.io/chartist-js).
    On the website, you can also visit the live example page at [http://gionkunz.github.io/chartist-js/examples.html](http://gionkunz.github.io/chartist-js/examples.html),
    where you can hack some charts directly in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Projects dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll create a projects dashboard, which will consist of
    the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Projects dashboard**: This is the main component in the dashboard and represents
    our whole dashboard view. It''s a composition of the rest of the components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project summary**: This is where we''ll display a summary of each project,
    where we will outline the most important facts. Our project summary component
    will also include an activity chart component that visualizes project activities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Projects dashboard container**: We also need to create a new container component,
    to expose our new component tree to the router and connect it to our database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tasks chart**: This is where we''ll provide a visual overview of open tasks
    over time. All projects will be represented in a line chart that displays the
    progress of open tasks. We''ll also provide some user interaction, so that the
    user can choose between different timeframes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Activity chart**: This component visualizes activities in a bar chart over
    a timeframe of 24 hours. This will help our users to quickly identify overall
    project activities and peaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the projects dashboard component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's follow our established tradition and start by modelling our data, which
    we're going to use in our components. We'd like to create a new interface to summarize
    projects. This includes the project data, tasks, activities, and a short description.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open our model file, located in `src/app/model.ts`, and add the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using this interface, we can aggregate all project relevant data into a single
    object, which simplifies our development a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move ahead and create our main dashboard component. The projects dashboard
    component has the responsibility of composing the main dashboard layout, by including
    our dashboard sub-components. It holds together all of the pieces within our projects
    dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our new projects dashboard component by using the Angular CLI
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up the generated component class, located on the path `src/app/projects-dashboard/projects-dashboard/projects-dashboard.component.ts`,
    and replace the stub code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our dashboard component accepts a `projectSummaries` input, which is a list
    of project summary objects that conforms to the `ProjectSummary` interface that
    we just created within our `TypeScript` model file.
  prefs: []
  type: TYPE_NORMAL
- en: A user can activate a project by clicking on a project summary component. Our
    projects dashboard component uses the output `outActivateProject` to delegate
    the event to the container, which we'll create later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the view of our component, and change the content within
    the file `src/app/projects-dashboard/projects-dashboard/projects-dashboard.component.html`
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For the moment, we only displayed the project title and the description that
    we'll compute on our project summary objects. In the next section, we will create
    a new project summary component that will deal with some more complex rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Project summary component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll create a project summary component that will provide
    some overview information for projects. Within the container component of our
    projects dashboard component tree, we'll make sure that we aggregate all of the
    necessary information to summarize projects. Our project summary UI component
    renders the data provided in the project summary objects, to create nice looking
    project overview cards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start building our component using the Angular CLI tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open the component class, located in `src/app/projects-dashboard/project-summary/project-summary.component.ts`,
    and replace its content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `projectSummary` input allows for passing a project summary object into
    our new UI component. There, we have all of the necessary information for displaying
    an overview of the project.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember from the previous chapter, [Chapter 8](43791ecf-9bd7-4439-ba76-8f34098d350a.xhtml),
    *Time Will Tell*, we've created a nice effort timeline component using SVG. Within
    our project summary, we would now like to reuse that component. However, we need
    to compute the total effort from the underlying tasks of our project.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to do is accumulate all task efforts into one overall effort. Using
    the `Array.prototype.reduce` function, we can accumulate all task efforts relatively
    easy. We're depending on the tasks present within our project summary object,
    which is passed to us with the input `projectSummary`. Since we'd like to recalculate
    the total effort when the project information changes, we can use the `OnChanges`
    life cycle hook and implement the method `ngOnChanges`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the template of our component, to see how we''re going to use
    the total efforts data to display our efforts timeline component. Open the file
    on the path `src/app/projects-dashboard/project-summary/project-summary.component.ts`,
    and amend it with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After displaying the project title and a description of the project summary,
    we included our efforts timeline component. We simply pass our computed `totalEfforts`
    into the `efforts` input, and the efforts timeline component will take care of
    the rendering. This timeline will now display the total aggregated amount of efforts
    logged on all tasks of a given project.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the timeline, we also rendered a formatted efforts text, like
    the one that we already rendered in the efforts component of the previous chapter.
    For this, we used the `formatEfforts` pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we still need to integrate our project summary component into the projects
    dashboard component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the template of our projects dashboard, located in `src/app/projects-dashboard/projects-dashboard/projects-dashboard.component.html`,
    and modify the template to include our project summary component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simply forward the project summary object to our newly created project
    summary component. Additionally, we''ve added a click event binding on project
    summary components, which will trigger our `activateProject` method on the projects
    dashboard component. This will allow us to implement a programmatic navigation
    within our container component, which is up next for implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/109ad064-df33-4643-bd5c-23cf44292389.png)'
  prefs: []
  type: TYPE_IMG
- en: A projects dashboard displaying two project summary components, with the aggregated
    total effort
  prefs: []
  type: TYPE_NORMAL
- en: Okay; so far, so good. We created two new UI components and reused our efforts
    timeline component to create an aggregated view of the total task efforts. Now,
    it's time to integrate our components by creating a new container component and
    configure the router of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the projects dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've created our initial projects dashboard components, and will now work on
    their integration into our application. We're going to need a new container component,
    which we'll also expose within the router configuration. We also need to update
    the navigation component of our application, in order to show a new navigation
    link to the dashboard view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with our new container component and use the Angular CLI tool
    to create the stubs for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up the generated component class, located in `src/app/container/projects-dashboard-container/projects-dashboard-container.component.ts`,
    and replace its content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Our newly created container is responsible for gathering all information necessary
    to create a list of project summary objects. We're using RxJS observables to create
    a reactive stream of project summary objects. The RxJS utility `combineLatests`
    allows us to join projects, tasks, and activities into one single stream. Within
    this joined stream, we are using the `map` operator to create one project summary
    object for every project obtained from the project service.
  prefs: []
  type: TYPE_NORMAL
- en: We're using our `limitWithEllipsis` helper function to convert the project description
    into a truncated (if necessary) version, which we're adding directly to our project
    summary object.
  prefs: []
  type: TYPE_NORMAL
- en: We've also injected the router into our container component, and will use it
    to do a programmatic navigation to the project view. We've implemented a method,
    `activateProject`, for this purpose, which we're going to call from our view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also change the template of our container component where we want to
    render the projects dashboard UI component and create the necessary bindings to
    pass our project summary data into the UI component tree. Open the file `src/app/container/projects-dashboard-container/projects-dashboard-container.component.html`,
    and replace its content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: All we need to do is render our projects dashboard UI component. We're passing
    our generated project summary objects down into the component input. Since we've
    implemented this using an observable stream, we need to use the `async` pipe.
  prefs: []
  type: TYPE_NORMAL
- en: When a project gets activated within the projects dashboard UI component, we
    receive an `outActivateProject` output event, which we can then use to call our
    `activateProject` method. There, we're using the router to navigate to the given
    project view.
  prefs: []
  type: TYPE_NORMAL
- en: Alright; now, we have all of the components ready to render our projects dashboard.
    There are two things left to do. We need to configure our router to activate our
    newly created container component and create a new navigation item within our
    app root component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the route configuration. Open up the route configuration
    file, located in `src/app/routes.ts`, and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We've added a new route configuration to activate our projects dashboard container
    component. In addition, we've changed our default redirect URL to redirect to
    our dashboard, instead of the first project detail view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay; let''s move on and use our new route to create a navigation item within
    our app root component. Open up the app component template, located in `src/app/app.component.html`,
    and perform the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! You've just completed all of the steps necessary for integrating our
    first set of projects dashboard components. You can now preview your changes in
    the browser. There should be a new navigation item available within the main navigation
    of the application. Also, when starting the application, you should automatically
    be redirected to the dashboard view.
  prefs: []
  type: TYPE_NORMAL
- en: You can already play with the efforts aggregation and try to modify a new task
    effort of a project, to see how the summary will be affected.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will enrich our project summary component with a nice
    Chartist chart.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create our first chart using Chartist, to provide a
    project activity overview over the past 24 hours. This bar chart will only provide
    some visual clues about the project activity, and our goal isn't to provide detailed
    information. For this reason, we will configure it to hide any labels, scales,
    and grid lines. The only visible part should be the bars of the bar chart.
  prefs: []
  type: TYPE_NORMAL
- en: Processing activity data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start creating the activity chart itself, we need to look at how we
    should transform and prepare our data for the charts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at what data we already have in our system. As far as the activities
    go, they all have a timestamp stored in the `time` field. However, for our chart,
    a list of timestamps is not sufficient enough. What we're looking for is a chart
    that displays one bar for each hour of the past 24 hours. Each one hour bar should
    represent the count of activities during that time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustration shows our source data, which is basically a time
    stream of activity events. On the lower arrow, we can see the data that we need
    to end up with for our chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26fd9766-7b21-4cf7-bb7d-5b33e092b85c.png)'
  prefs: []
  type: TYPE_IMG
- en: An illustration displaying activities as a time stream, where dots represent
    activities. By rasterizing the events into one-hour slices, we get something we
    call rasterized counts, as shown on the bottom arrow.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we're going to introduce a new interface within our application
    model. We would like to represent a data value within a list of values, which
    is getting rasterized.
  prefs: []
  type: TYPE_NORMAL
- en: We use the term rasterization to describe the process of sampling underlying
    data into slices on a raster. This is very similar to how a digital camera would
    sample the photons of light rays and accumulate them on a raster which we call
    pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''d like to not only use a timestamp for rasterization, but also weigh
    data values differently, depending on situations, we will introduce the following
    interface to our model, located in `src/app/model.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the previous figure, we counted all activities within a given hour and added
    up them up. However, we will need a more specific solution that allows us to incorporate
    weight while counting. This is especially useful if you want to make certain activities
    count more than others. By using a property called `weight` on data input to the
    rasterization process, we can accomplish a weighted count. In fact, we're no longer
    counting data values within a `timeframe`; we're adding up their weights to get
    a total weight for a given `timeframe`. This allows us to use negative weights,
    which will subtract from the total weight. This will be important for the second
    chart, which we're going to create at a later stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the function that performs the outlined data transformation.
    We''ll add this function to our time utility module, located in `src/app/utilities/time-utilities.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s briefly look at the input parameters of our newly created function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timeData`: This parameter is expected to be an array of rasterization data
    objects that contains a `time` property set to the timestamp of the event that
    should be counted. The objects should also contain a `weight` property, which
    is used to count. Using this property, we can count one event as two, or even
    count minus values to decrease the count in a rasterized frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeFrame`: This parameter specifies the time span of each rasterized frame,
    in milliseconds. If we want to have 24 rasterized frames, each consisting of one
    hour, this parameter needs to be set to 3,600,000 (*1 h = 60 min = 3,600 s = 3,600,000
    ms*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quantity`: This parameter sets the amount of rasterized frames that should
    be present in the output array. In the case of 24 frames of one hour, this parameter
    should be set to 24.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`now`: This parameter should be set as the point in time when the rasterization
    process will start. The rasterization will always move backwards in time, so this
    time marks the end time of our rasterization. The `now` parameter should be a
    timestamp, in milliseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fill`: This is how we can specify how we''d like our rasterized output array
    to be initialized. In the case of our activity counts, we want this to be set
    to zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function that we just created is necessary to create the activity chart.
    The transformation helps us to prepare project activities for the input data of
    the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an activity chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to create our first chart component using Chartist! However, before
    we get into our component, we need to make sure that Chartist is installed within
    our project. Let''s use npm to install Chartist as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Chartist is currently written in pure JavaScript. Luckily, the community created
    a very sophisticated type definition for Chartist, so you can benefit from typed
    interfaces when using Chartist with TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay; that''s all it takes to get us going with Chartist. Now, let''s create
    our activity chart using the Angular CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open the generated template, located on the path `src/app/projects-dashboard/activity-chart/activity-chart.component.html`,
    and replace its content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we leave all of the rendering up to Chartist, this is actually everything
    we need. Chartist needs an element as a container to create the chart in. We set
    a `chartContainer` local view reference, so that we can reference it from our
    component and pass it to Chartist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on with the chart creation. Open up the component class, located
    in `src/app/projects-dashboard/activity-chart/activity-chart.component.ts`, and
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the imports from the Angular core module, we're also importing
    the Chartist namespace object, as well as the interface, `IChartistBarChart`.
  prefs: []
  type: TYPE_NORMAL
- en: Our component takes a list of activities as input, which we're going to transform
    using our new rasterization function. This transformed data is then used with
    Chartist to visualize the data. We're using a member, chart, to store the Chartist
    instance, once created.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `ViewChild` decorator, we're obtaining the DOM element from our component
    view, which will be used as a container to create our chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue by adding a method to transform the activity list into something
    Chartist can work with. Within the same component class file, append the following
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Within the `createChartData` method, we are first creating a list of rasterization
    data objects from the list of activities that we provided from our component input.
    We can use the activity time as a timestamp, and all of our activities currently
    count the same, so we use a fixed weight of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we would like to extract the count of activities for every hour within
    the last 24 hours. We can use our `rasterize` function, with the necessary parameters,
    to transform our activities into exactly that format. The `rasterize` function
    will always return a list of numbers representing the count of activities within
    the desired timeframes. Together with the rasterization data, we pass the number
    of milliseconds for one hour, a total of 24 frames, and the current time as the
    starting point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Our method returns an object of the type `IChartistData`, which contains the
    data that we want to visualize with Chartist. The output of our `rasterize` function
    has exactly the right format for representing a data series in Chartist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the remaining code to complete our component class. Code changes
    are highlighted in bold, while the ellipsis character indicates irrelevant, hidden
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let's look into the code in more detail and walk through it step by step.
  prefs: []
  type: TYPE_NORMAL
- en: The `createChart` method creates a new chart instance with the data that is
    passed to the method. In order to create a new bar chart, we can use the `Chartist.Bar`
    constructor. As a first parameter, we pass the DOM element of our container view
    child. Chartist will create our chart in this container element. The second argument
    is our data, which we get from our method parameter. In the chart options, we'll
    set everything to achieve a very plain-looking chart, without any detailed information.
    We disable the grids, hide the labels, and remove any padding.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we're using the Chartist draw event to control how zero value
    bars are drawn. By default, Chartist won't draw a bar when the value for the bar
    is exactly zero. We can control and change this behavior by implementing our own
    custom draw event logic.
  prefs: []
  type: TYPE_NORMAL
- en: The `createOrUpdateChart` method checks whether the chart was already created,
    and only needs to be updated if we really need to create a new chart instance.
    This simplifies our handling a lot. As we get called from both the `AfterViewInit`
    and `OnChanges` life cycle hooks, we need to make sure that both the `chartContainer`
    view child and the `activities` input are ready before we continue.
  prefs: []
  type: TYPE_NORMAL
- en: If the `chart` member is already set to a chart that was previously created,
    we can use the `update` function on the Chartist instance to update it with the
    new data. If there's no chart object, we need to create a new chart. We can simply
    call our `createChart` method for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is great! We''ve created our first chart component using Chartist! Now,
    we can go back to our project summary component and integrate the activity chart
    there, to provide an activity overview. Open up the template of the project summary
    component, located in the file `src/app/projects-dashboard/project-summary/project-summary.component.html`,
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We added our activity chart component at the bottom of the already existing
    template. We also created the necessary binding to pass our activities, which
    we already had available on our project summary object, into the component.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You've successfully integrated the Chartist library into your
    project, and have used it to visualize project activity on our project summary
    components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll dive a bit deeper into the charting capabilities
    of Chartist, and will also provide some interactivity using Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing open tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create a line chart component using Chartist, which
    will display the open task progress of projects over time. To do this, we'll use
    a line chart with a specific interpolation that provides quantized steps, rather
    than lines with directly connected points.
  prefs: []
  type: TYPE_NORMAL
- en: We will also provide some interactivity, so that the user will be able to switch
    the displayed timeframe by using a toggle button. This will allow us to reuse
    the toggle UI component that we created in [Chapter 2](11f96942-6e99-46c5-b152-1af3b2579d44.xhtml),
    *Ready, Set, Go!*
  prefs: []
  type: TYPE_NORMAL
- en: Preparing task data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's look at the data that we have available in our system, when it
    comes to project tasks. The `created` attribute is set to the timestamp at the
    moment when the task was created. If a task is marked as done, however, we currently
    don't save the timestamp of that moment. In order to produce the chart that we're
    looking for, we will need to know when a task was completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce a new property on our task model for this purpose. Open up
    the `model` file, located in `src/app/model.ts`, and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to make sure to set the `completed` property at the right moment,
    whenever a task is completed. Let''s open the class of our task component, located
    in `src/app/tasks/task/task.component.ts`, and apply the following changes. Only
    modify the part in your code that is highlighted in the following code excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright; to complete this exercise, we also want to update our initial data
    within the in-memory database, to reflect a more accurate scenario. Open the file
    `src/app/database.ts`, and apply the following changes. Again, only change the
    parts that are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Modeling the problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s think about the problem of showing open task counts over time.
    As we''re only interested in the number of open tasks at any given time, we can
    use a model where we put all tasks onto a single timeline, and where we are only
    concerned with the events of tasks being created or completed. Let''s look at
    the following illustration to get a better understanding of the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/897d7898-90ee-4582-bfa6-e217d7bb03db.png)'
  prefs: []
  type: TYPE_IMG
- en: An illustration that shows how we can represent all task timelines on a single
    timeline, using the created and completed events. The created events count as
    +1, while the completed events count as -1
  prefs: []
  type: TYPE_NORMAL
- en: The lower arrow is a representation of all tasks of the created and completed
    events on a timeline. We can now use this information as input to our `rasterize`
    function, in order to get the data that we need for our chart. As the rasterization
    data objects that are used as input for the function also support a `weight` property,
    we can use this to represent the created (`+1`) or completed (`-1`) events.
  prefs: []
  type: TYPE_NORMAL
- en: We need to make a slight modification to our `rasterize` function. So far, the
    `rasterize` function only counts events together in frames. However, for the open
    task counts, we will look into an accumulation over time. If the task count changes,
    we need to keep the value until it changes again. In the transformation of activities
    in the previous section, we didn't use this same logic. There, we only counted
    events inside frames, but there was no accumulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following illustration to see the differences, as compared
    to the rasterization that we applied when processing activities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce0fe326-e7da-4517-8a78-4272ddaeb8cb.png)'
  prefs: []
  type: TYPE_IMG
- en: An illustration that shows how we can accumulate the open task count over time
  prefs: []
  type: TYPE_NORMAL
- en: We can count each `weight` property of the rasterization data objects (events)
    together over time. If there's a change in the accumulated value, we will write
    the current accumulated value into the rasterized output array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this accumulation feature into our `rasterize` function. Open
    up the time utility module, on the path `src/app/utilities/time-utilities.ts`,
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Let's walk through the changes that we applied to the `rasterize` function.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we add a new parameter to our function, with the name `accumulate`.
    We use ES6 default parameters to set the parameter to `false`, if no value was
    passed into the function when called.
  prefs: []
  type: TYPE_NORMAL
- en: We define a new `accumulatedValue` variable, which we initialize with zero.
    This variable is used to keep track of the sum of all `weight` values over time.
  prefs: []
  type: TYPE_NORMAL
- en: The next bit of code is very important. If we want to accumulate the sum of
    all `weight` values over time, we need to make sure that these values come in
    sequence. In order to ensure this, we sort the `timeData` list by its items `time`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: In the reduce callback, we increase the `accumulatedValue` variable by the `weight`
    value of the current `timeData` object.
  prefs: []
  type: TYPE_NORMAL
- en: If the `timeData` object falls into a rasterized frame, we do not increase this
    frame's count like we did before. In accumulation mode, we set the frames count
    to the current value in `accumulatedValue`. This will result in all changed accumulated
    values being reflected in the rasterized output array.
  prefs: []
  type: TYPE_NORMAL
- en: That's all the preparation we need to create our open tasks chart. We were able
    to refactor our `rasterize` function, which is now able to process time data and
    produce rasterized data series for various applications. With the use of a negative
    `weight` property, we can now create data series that increase and decrease, based
    on open tasks within a project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an open tasks chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the line chart that we''re going to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c89891c-8f39-4861-9e9b-8f49f03ff7e7.png)'
  prefs: []
  type: TYPE_IMG
- en: Open tasks visualized with our tasks chart component, using Chartist's step
    interpolation
  prefs: []
  type: TYPE_NORMAL
- en: We will utilize the refactored `rasterize` function of the previous topic, and
    will use the new accumulate mode to track open task counts over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the Angular CLI tool to create our new tasks chart component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s edit the component class, on the path `src/app/projects-dashboard/tasks-chart/tasks-chart.component.ts`,
    and change its content to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The basic structure of the preceding code should already look familiar to you.
    We're using the same structure as in our previous chart. However, the line chart
    that we are going to create now contains much more detailed information. We will
    render both axis labels and some scales. The *x*-axis of our chart will be a timeline,
    and we will use the Moment.js library to format the timestamps to a human-readable
    format.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at the `createChartData` and `createChart` methods.
    There's quite a bit of code here! Let's walk through it, step by step, to gain
    a better understanding of what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `projectSummaries` input as a base for our data visualization. We
    transform the tasks data using our updated `rasterize` function, in order to prepare
    the data for our line chart.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create our transformed series data by mapping the project
    summary list. The series array should include one data array for each project.
    Each data array will contain the open project tasks over time.
  prefs: []
  type: TYPE_NORMAL
- en: As the `rasterize` function expects a list of rasterization data objects, we
    need to first transform the projects task list into this format. We will make
    use of the weight feature of our `rasterize` function. We can simply create a
    rasterization data object with a weight of `1` for every event of a created task.
    For completed tasks, we create a rasterization data object with a weight of `-1`.
    This results in the desired input data for our `rasterize` function.
  prefs: []
  type: TYPE_NORMAL
- en: After preparing the data, we can call the `rasterize` function, in order to
    create a list of open tasks over a certain amount of rasterization frames. We
    use ten minute timeframes (600,000 ms) and rasterize with 144 frames. This makes
    a total of 24 hours. So, that's where those two magic numbers come from! However,
    this code will change a bit when we introduce the interactivity to our chart.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the series data, we also need labels for our chart. We create a new
    array and initialize this with 144 timestamps, all of which are set to the start
    of the 144 rasterized frames that we display on the chart.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the series data and the labels ready, and all that's left to do
    is render our chart. Within the `createChart` method, we're creating our line
    chart instance using the `Chartist.Line` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `lineSmooth` configuration, we can specify a special kind of interpolation
    for our line chart. The step interpolation will not connect each point in our
    line chart directly, but will rather plot our data in discrete steps, to move
    from point to point. This is exactly what we're looking for to render the open
    task counts over time.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `fillHoles` option to `true` in the step interpolation is very important.
    Using this setting, we can actually tell Chartist that it should close any gaps
    in the data (actually null values) and connect the line to the next valid value.
    Without this setting, we'd see gaps on the chart between the task count changes
    in our data arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay; that''s all we need in our component class, for the moment. Let''s move
    on to the rather simple template for our tasks chart component. Open the file,
    located on the path `src/app/projects-dashboard/tasks-chart/tasks-chart.component.html`,
    and change its content to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the activity chart component, we only create a simple chart container
    element, which we already reference in our component class using the view child
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our tasks chart component is now ready to be integrated into our dashboard.
    We can achieve this with some small changes to the template of our projects dashboard
    component. Let''s open the file `src/app/projects-dashboard/projects-dashboard/projects-dashboard.component.html`,
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Good stuff! This is basically all that we need to make our newly created tasks
    chart appear on our dashboard. You've created a simple line chart to visualize
    open tasks over time.
  prefs: []
  type: TYPE_NORMAL
- en: Let's further enhance our chart by rendering a chart legend and making the chart
    interactive for our users.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a chart legend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, there's no way to tell exactly what line on our chart represents
    what project. We can see one colored line for each project, but we can't associate
    these colors. What we need is a simple legend that helps our users to associate
    line chart colors to projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the required code changes to implement legends on our chart.
    Open our tasks chart component class, located on the path `src/app/projects-dashboard/tasks-chart/tasks-chart.component.ts`,
    and apply the following changes. Irrelevant parts of this change are hidden using
    the ellipsis character, while effective changes are marked in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We've added a local interface in our component module to represent individual
    legend items. The `title` property is going to be displayed for each item within
    our legend. The `class` property is used to set an appropriate CSS class, in order
    to render every legend item with the correct color, to match the colors of lines
    within our chart.
  prefs: []
  type: TYPE_NORMAL
- en: In the `OnChanges` life cycle hook, we simply map the project summary objects
    to a list of legend objects. The template string `` `series-${index + 1}` `` will
    generate the necessary class names to render the right color into our legend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this legend information, we can now go ahead and implement the necessary
    template changes to render the legend in our tasks chart component. Open the template,
    located on the path `src/app/projects-dashboard/tasks-chart/tasks-chart.component.html`,
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, that was a piece of cake, right? However, the result speaks for itself.
    We created a nice legend for the chart in just a couple of minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/064e3c96-1945-4627-8eac-de28c663a376.png)'
  prefs: []
  type: TYPE_IMG
- en: Open tasks chart with our added legend
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, we're going to add some user interaction to our chart and
    let our users control the timeframe that we're using to render our data.
  prefs: []
  type: TYPE_NORMAL
- en: Making the tasks chart interactive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, we hardcoded the timeframe of our open task chart to be 144 frames,
    each 10 minutes long, making a total of 24 hours displayed to the user. However,
    maybe our users will want to change this view.
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we will create a simple input control using our toggle component,
    which will allow our users to change the timeframe settings of the chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will provide the following views as options to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day**: This view will rasterize into 144 frames, each consisting of 10 minutes,
    which makes a total of 24 hours'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Week**: This view will rasterize into 168 frames, each consisting of one
    hour, which makes a total of seven days'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Year**: This view will rasterize into 360 frames, each representing a full
    day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start the implementation by modifying the tasks chart component `TypeScript`
    file, located on the path `src/app/projects-dashboard/tasks-chart/tasks-chart.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Let's briefly go over these changes. First, we added another local interface
    to represent the `timeframe` choices presented to the user. The `ChartTimeFrame`
    interface consists of a name property, which we'll use to present to the user.
    We also stored the `timeFrame` and `amount` properties for each chart `timeframe`
    object. These two properties represent the number of milliseconds for each frame
    and the frame count, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The new `timeFrames` member is set to an array of `timeframe` objects. These
    are the choices we'll present to the user, and they reflect the settings we discussed
    at the beginning of this section. The `timeFrameNames` member contains a list
    of timeframe names, which is directly derived from the `timeFrames` list. Finally,
    we have a `selectedTimeFrame` member, which simply points to the first available
    timeframe object to start with.
  prefs: []
  type: TYPE_NORMAL
- en: In the `createOrUpdateChart` function, we no longer rely on hardcoded values
    for the task count rasterization, but we refer to the data in the `selectedTimeFrame`
    object. By changing this object reference and calling the `createOrUpdateChart`
    function again, we can now switch the view on the underlying data dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we added a new `selectTimeFrame` method, which we will call from our
    component view to switch to a different timeframe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the necessary template changes to enable the switching of timeframes.
    We''re using our `toggle` UI component that we created at the very beginning of
    this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: From the bindings to the `toggle` component, you can already tell that we rely
    on the `timeFrameNames` member of our component to represent all selectable timeframes.
    We also bind to the `activeButton` input property of the `toggle` component using
    the `selectedTimeFrame` property of our tasks chart component. When the user activates
    a toggle button, we call the `selectTimeFrame` function, where the timeframe is
    switched and the chart is updated.
  prefs: []
  type: TYPE_NORMAL
- en: This is all that we need to enable switching the timeframe on our chart. The
    user can now choose between the year, week, and day views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Excellent work! You''ve added interactivity to the tasks chart by reusing the
    `toggle` UI component. Let''s take a look at the final result of our work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32180d58-7013-4408-8ca4-a155f19fc90b.png)'
  prefs: []
  type: TYPE_IMG
- en: Final tasks chart, which is now rendered within our application dashboard
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Chartist and how to use it in conjunction
    with Angular to create good looking and functional charts. We can leverage the
    power of both worlds to create reusable chart components that are nicely encapsulated.
  prefs: []
  type: TYPE_NORMAL
- en: Just like in most real cases, we always have a lot of data available. However,
    bringing that data into the right shape is sometimes tricky. In this chapter,
    we learned how we can transform existing data into a form that is optimized for
    visual representation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at building a plugin system in our application.
    This will allow us to develop portable functionality that is packaged into plugins.
    Our plugin system will render new plugins dynamically, and we will use it to develop
    a simple agile estimation plugin.
  prefs: []
  type: TYPE_NORMAL
