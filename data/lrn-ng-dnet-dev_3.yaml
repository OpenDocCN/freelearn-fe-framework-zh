- en: Chapter 3. Angular Building Blocks - Part 2
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章 Angular构建模块-第2部分
- en: 'This chapter gives you a detailed walk-through on the remaining uncovered core
    building blocks of the Angular architecture. In this chapter, we will cover the
    following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细介绍 Angular 架构中尚未涵盖的核心构建模块。 在本章中，我们将涵盖以下主题：
- en: Forms
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单
- en: Pipes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道
- en: Router
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由
- en: Services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Observables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: Forms
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单
- en: '* * *'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Every application has a data entry point where it enables end users to input
    data. Forms are meant to insert or update input data to a server and on a page.
    Input data should be validated before it is submitted for further action. There
    are two types of validation methods applied: client-side validation and server-side
    validation:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都有一个数据输入点，它使最终用户能够输入数据。表单旨在向服务器和页面插入或更新输入数据。在提交以进行进一步操作之前，应验证输入数据。应用了两种类型的验证方法：客户端验证和服务器端验证：
- en: '**Server-side validation**: Server-side validations will be handled by the
    server. The information received will be processed and validated by the server.
    It is necessary to update the UI with appropriate information if there are any
    errors in submitting the form. If the information is invalid or not sufficient,
    then the appropriate response will be sent back to the client. This approach to
    validation is more secure as it works even if JavaScript is turned off in the
    browser and also, malicious users can''t bypass the server-side validation. However,
    the drawback of this approach is that the form will be validated only after submitting
    it to the server. So, the user has to wait until the form is fully submitted to
    the server in order to know whetherÂ all the data supplied is valid.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端验证**：服务器端验证将由服务器处理。 收到的信息将由服务器处理和验证。 如果提交表单时存在任何错误，则需要使用适当的信息更新UI。 如果信息无效或不足，则将适当的响应发送回客户端。
    这种验证方法更加安全，因为即使浏览器中关闭了JavaScript，它也可以工作，并且恶意用户无法绕过服务器端验证。 但是，这种方法的缺点是只有在将表单提交到服务器后才会验证表单。
    因此，用户必须等到完全提交表单到服务器，才能知道所提供的所有数据是否有效。'
- en: '**Client-side validation**: Though server-side validation is more secure, itÂ will
    not provide a better user experience. Client-side validations are implemented
    using a scripting language such asÂ JavaScript, and the validations will be done
    on the client itself. The user input data can be validated as and when keyed in
    by the user. This leads to a richer experience by providing immediate response
    with validation errors on the screen. The user need not wait for the entire form
    to beÂ submitted to know whetherÂ the data entered isÂ valid.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端验证**：虽然服务器端验证更加安全，但它不会提供更好的用户体验。 使用脚本语言，如JavaScript，实现客户端验证，并在客户端上进行验证。
    用户输入的数据可以在用户输入时验证。 这会通过在屏幕上提供验证错误的即时响应，提供更丰富的体验。 用户无需等待整个表单提交，即可知道输入的数据是否有效。'
- en: Angular has classes such as FormBuilder, Control, and Validators to handle forms.
    ItÂ enables you to easily set validation rules using Control and Validators.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Angular具有FormBuilder、Control和Validators等类来处理表单。 它使您能够使用Control和Validators轻松设置验证规则。
- en: Tools for forms
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表单工具
- en: 'Angular has various tools to achieve the preceding scenarios to implement forms
    in our application. The following are such tools and their respective purposes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Angular有各种工具可实现应用程序中的表单。 以下是这些工具及其各自的目的：
- en: '**Controls**: These provide objects by encapsulating the inputs of forms'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控件**：这些通过封装表单的输入提供对象'
- en: '**Validators**: These help in validating the input data from forms'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证器**：这些有助于验证表单中的输入数据'
- en: '**Observers**: These help keep track of changes in forms and informs the user
    ofÂ any validation errors'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者**：这些有助于跟踪表单中的更改并通知用户任何验证错误'
- en: Types of Angular forms
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular形式的类型
- en: 'Angular provides two approaches for handling forms: template-driven forms and
    model-driven forms.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了两种处理表单的方法：模板驱动表单和模型驱动表单。
- en: Templete driven forms
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模板驱动表单
- en: AngularJS handled forms using the `ng-model` directive, and it leveraged the
    power of two-way binding that made the lives of developers easier. Angular enables
    developers to build template-driven forms using `ngModel`, which is similar to
    `ng-model` in AngularJS.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS使用`ng-model`指令处理表单，并利用了使开发人员生活更轻松的双向绑定功能。 Angular使开发人员能够使用`ngModel`构建模板驱动表单，这类似于AngularJS中的`ng-model`。
- en: 'The following is the implementation of template-driven forms:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是模板驱动表单的实现：
- en: Let's create an app named First Template Form in **Visual Studio Code**Â (**VS
    Code**).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 **Visual Studio Code**（**VS Code**）中创建一个名为 First Template Form 的应用程序。
- en: Add the required packages and dependency details in `package.json`, and install
    them using the `npm` install command.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `package.json` 中添加所需的包和依赖详情，并使用 `npm` install 命令进行安装。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a class book and add the following code snippet:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个书籍类，并添加以下代码片段：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create `AppComponent` and add the following code:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `AppComponent`，并添加以下代码：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This `AppComponent` shown earlierÂ is the root component of the application
    that will host the `BookFormComponent`. `AppComponent` is decorated with the first-template-form
    selector and template that has the inline HTML with the `<book-form/>`Â special
    tag. This tag will be updated with the actual template during runtime.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的 `AppComponent` 是应用程序的根组件，将托管 `BookFormComponent`。`AppComponent` 被装饰为第一个模板表单选择器，模板中包含带有`<book-form/>`特殊标签的内联
    HTML。这个标签在运行时将被更新为实际模板。
- en: 'Now, let''s add the book-form.component.ts with the following code snippet:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下代码片段向 `book-form.component.ts` 中添加代码：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, note that we have imported Book from `book.ts`. Book is the data model
    for this form. `BookFormComponent` is decorated with theÂ `@Component` directive
    that was imported from `@angular/core`. Selector value is set to `book-form` and
    the templateUrl is assigned with the template HTML file. In the `BookFormCompoent`,
    we have instantiated Book model with the dummy data. We have two methods--`onSubmit()`
    and `newBook()`--one to post the data submitted to API and the other to clear
    the form.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，注意到我们从 `book.ts` 中导入了 Book。Book 是该表单的数据模型。`BookFormComponent` 被装饰为 `@Component`
    指令，该指令从 `@angular/core` 中引入。选择器值设置为 `book-form`，templateUrl 被分配为模板 HTML 文件。在 `BookFormCompoent`
    中，我们用虚拟数据初始化了 Book 模型。我们有两个方法--`onSubmit()` 和 `newBook()`--一个用于向 API 提交数据，另一个用于清空表单。
- en: 'Now, let''s add the `book-form.component.html` template file to the following
    HTML content:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们向以下 HTML 内容中添加 `book-form.component.html` 模板文件：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a simple template form that has three input controls to key in the book,
    author, and publisher name, a submit button to submit the details, and a Clear
    button to clear the form. Angular implicitly applies the `ngForm` directive to
    the forms in the template. We assigned the `ngForm` directive to the `#bookForm`Â local
    variable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的模板表单，包含三个输入控件用于输入书名、作者和出版商名称，一个提交按钮用于提交详情，以及一个清除按钮用于清空表单。Angular 隐式地将
    `ngForm` 指令应用于模板中的表单。我们将 `ngForm` 指令分配给了 `#bookForm` 本地变量。
- en: Using theÂ `#bookForm`Â local variable, we can track the form for errors and
    check whether they are valid or invalid, touched or untouched, and pristine or
    dirty. Here, the submit button will be enabled only if the valid property of `ngForm`
    returns true, as it is assigned to the button's disabled property.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `#bookForm` 本地变量，我们可以跟踪表单的错误，并检查它们是有效还是无效、被触碰还是未触碰以及原始还是脏。在这里，只有当 `ngForm`
    的 valid 属性返回 true 时，提交按钮才会被启用，因为它被分配到按钮的 disabled 属性。
- en: The `onSubmit` function from `BookFormComponent` is assigned to the ngSubmit
    event of the form. So, when the submit button is clicked on, it will call the
    `onSubmit` function in `BookFormComponent`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookFormComponent` 中的 `onSubmit` 函数被分配给了表单的 `ngSubmit` 事件。因此，当单击提交按钮时，它将调用
    `BookFormComponent` 中的 `onSubmit` 函数。'
- en: 'Note that all the input controls contain the `ngModel` event-cum-property attribute,
    and it is assigned with their respective model properties, such as `model.name`,
    `model.author`, and `model.publication` respectively. In this way, we can achieve
    the two-way binding so that the model properties in `BookFormComponent` will be
    updated with their respective values when they are keyed into the corresponding
    input controls:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有输入控件都包含 `ngModel` 事件-属性属性，并且将其分配给它们各自的模型属性，比如 `model.name`、`model.author`
    和 `model.publication`。通过这种方式，我们可以实现双向绑定，这样当在对应的输入控件中输入值时，`BookFormComponent` 中的模型属性将被更新为它们各自的值：
- en: 'We have the required template and components in place. Now we need to create
    an `AppModule` to bootstrap the root component of our application, `AppComponent`.
    Create a file named `app.module.ts` and add the following code snippet:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经放置了所需的模板和组件。现在，我们需要创建一个 `AppModule` 来引导我们应用程序的根组件 `AppComponent`。创建一个名为
    `app.module.ts` 的文件，并添加以下代码片段：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we discussed inÂ [chapter 2](Learning%20Angular%20for%20.NET%20Developers_split_000.html#)*Angular
    Building Blocks - Part 1*, any Angular application will have a root module thatÂ will
    be decorated with theÂ `NgModule` directive along with the metadata details, such
    as imports, declarations, and bootstrap.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](Learning%20Angular%20for%20.NET%20Developers_split_000.html#)*Angular构建块-第1部分*中讨论的，任何Angular应用程序都将有一个根模块，该模块将使用`NgModule`指令进行装饰，并包含导入、声明和引导等元数据详细信息。
- en: In the precedingÂ code, note that we assigned the `AppComponent` class to bootstrap
    metadata to inform Angular that `AppComponent` is the root component of the application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，请注意我们将`AppComponent`类分配为引导元数据，以通知Angular`AppComponent`是应用程序的根组件。
- en: 'Now that we have all the required templates and classes in place, we need to
    bootstrap the module. Let''s create a file named `main.ts` with the following
    code snippet that bootstraps the module:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有所需的模板和类，我们需要引导模块。让我们创建一个名为`main.ts`的文件，其中包含以下代码片段，用于引导模块：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, add the index.html file with the following content:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下内容的index.html文件：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that the `<first-template-form/>` special tag is added in the body. This
    tag will be updated with the actual template during runtime. Also, note that the
    required libraries are loaded during runtime using the `System.js` module loader.
    The `systemjs.config.js` file should have the instructions on mapping the npm
    packages and our application''s starting point. Here, our application is bootstrapped
    in the `main.ts`, which will be transpiled to `main.js` after the application
    is built. The content of the `systemjs.config.js` is given as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在正文中添加了`<first-template-form/>`特殊标记。该标记将在运行时使用实际模板进行更新。另外，请注意，在运行时使用`System.js`模块加载器加载必需的库。`systemjs.config.js`文件应包含有关映射npm包和我们应用程序起始点的指令。在这里，我们的应用程序在`main.ts`中引导，这将在构建应用程序后被转译为`main.js`。`systemjs.config.js`的内容如下所示：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we have all that we need. Let''s run the application by pressing *F5*,
    and the index page will be rendered with the template powered by `BookFormComponent`,Â as
    follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了所有所需的内容。通过按下*F5*来运行应用程序，索引页面将以由`BookFormComponent`提供模板的方式呈现，如下所示：
- en: '![](img/image_03_001.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_001.png)'
- en: The output of the FIrstTemplateForm application
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`FirstTemplateForm`应用程序的输出'
- en: 'Now remove the dummy texts assigned to input controls and note that the form
    validation got fired showing the validation error message keeping the **`Submit`**
    button in a disabled state:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在移除分配给输入控件的虚拟文本，并注意表单验证已触发，显示验证错误消息，保持**`Submit`**按钮处于禁用状态：
- en: '![](img/image_03_002.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_002.png)'
- en: Inspecting the console log to form submit
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 检查控制台日志以进行表单提交
- en: In this template-drive form, you would have noted that we have applied the required
    attribute to the input controls. Similar to this, we can also apply minimum length
    and maximum length validations. However, applying validations like these tightly
    couples the validation logic to the template, and we can only test these validations
    by writing browser-based, end-to-end tests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板驱动表单中，您可能已经注意到我们已经将`required`属性应用于输入控件。类似于这样，我们还可以应用最小长度和最大长度验证。然而，这样应用验证会将验证逻辑紧密耦合到模板中，并且我们只能通过编写基于浏览器的端到端测试来测试这些验证。
- en: Model-driven forms
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模型驱动表单
- en: Angular provides the `FormGroup` and `FormControl` attributes to implement model-driven
    forms.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了`FormGroup`和`FormControl`属性来实现模型驱动表单。
- en: Fundamental objects of model-driven forms
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模型驱动表单的基本对象
- en: '`FormControl` and `FormGroup` are the two fundamental objects in a model-driven
    form.Â `FormControl` is an input field in the Angular form that encapsulates the
    value of the input field, its state (is valid), if it has changed (is dirty),
    or has any errors.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormControl`和`FormGroup`是模型驱动表单中的两个基本对象。`FormControl`是Angular表单中的输入字段，它封装了输入字段的值，其状态（有效性），是否已更改（脏），或是否有任何错误。'
- en: 'When we build a form, we need to create controls and attach metadata to the
    controls. We have to attach the Control class to the DOM input element by adding
    the `formControlName` attribute, as shown:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建一个表单时，我们需要创建控件并附加元数据到这些控件。我们必须通过添加`formControlName`属性将Control类附加到DOM输入元素，如下所示：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`FormGroup` can be instantiated by FormBuilder. We can also manually construct
    `FormGroup` in the components with the default values, as illustrated:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormGroup`可以由FormBuilder进行实例化。我们还可以用默认值在组件中手动构建`FormGroup`，如下所示：'
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s create an app named `ModelDrivenForm` in**Â Visual Studio Code** (**VS
    Code**). The following is the implementation of model-driven forms:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在**Visual Studio Code**（**VS Code**）中创建一个名为`ModelDrivenForm`的应用程序。以下是模型驱动表单的实现：
- en: 'Add the required package and dependency details, and install them using the
    npm install command:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所需的包和依赖项详细信息，并使用`npm install`命令来安装它们：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a `Book` class and add the following code snippet:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Book`类，并添加以下代码片段：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create `AppComponent` and add the following code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`AppComponent`并添加以下代码：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This `AppComponent` shown earlierÂ is the root component of the application
    that will host the `BookFormComponent`. `AppComponent` is decorated with the first-model-form
    selector and template that has the inline HTML with the `<book-form/>`Â special
    tag. This tag will be updated with the actual template during runtime.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此前展示的`AppComponent`是应用程序的根组件，将托管`BookFormComponent`。`AppComponent`带有第一个模型表单选择器和模板，其中包含带有特殊标签`<book-form/>`的内联HTML。这个标签将在运行时更新为实际模板。
- en: 'Now, let''s add the `book-form.component.ts` with the following code snippet:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加`book-form.component.ts`，使用以下代码片段：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, note that we have imported `FormControl`, `FormGroup`, and `Validators`Â from
    `@angular/forms`. These are the essential classes to implement a model-driven
    form. We have also imported `Component` and `OnInit` from `@angular/core` for
    Component class implementation, and then we have imported Book from `book.ts`.
    Book is the data model for this form.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，注意我们从`@angular/forms`中导入了`FormControl`、`FormGroup`和`Validators`。这些是实现模型驱动表单的基本类。我们还从`@angular/core`中导入了`Component`和`OnInit`，用于组件类的实现，然后我们从`book.ts`中导入了Book。Book是该表单的数据模型。
- en: '`BookFormComponent` is decorated with theÂ `@Component` directive that was
    imported from `@angular/core`. Selector value is set to `book-form`, and the `templateUrl`
    is assigned with the template HTML file.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookFormComponent`带有从`@angular/core`导入的`@Component`指令。选择器值设置为`book-form`，`templateUrl`分配了模板HTML文件。'
- en: In the `BookFormCompoent`, we have initialized the form model by instantiating
    `FormGroup` with the `FormControl` properties instantiated and assigned to properties
    such as name, author, and publication. We have theÂ `onSubmit()` methods to post
    the data submitted to API.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BookFormCompoent`中，我们通过实例化`FormGroup`并将其分配给属性，如名称、作者和出版物，来初始化表单模型。我们有`onSubmit()`方法来将提交的数据提交到API。
- en: 'Now, let''s add the `book-form.component.html` template file to the following
    HTML content:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加`book-form.component.html`模板文件，并添加以下HTML内容：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Similar to the template-driven form, this is a simple form based on model driven
    that has three input controls to key in the book, author, and publisher name and
    a submit button to submit the details. In the form tag, we have added the `formGroup`
    directive to the forms and assigned `bookForm` to it. Each input control has a
    special attribute form `ControlName` assigned with their respective `formControl`,
    such as name, author, and publication respectively.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与模板驱动表单类似，这是一个简单的模型驱动表单，其中包含三个输入控件用于输入图书、作者和出版商名称，以及一个提交按钮来提交详细信息。在表单标签中，我们添加了`formGroup`指令来分配给表单，并将其分配给了`bookForm`。每个输入控件都有一个特殊的属性`formControlName`，分别分配有各自的`formControl`，比如名称、作者和出版物。
- en: The `onSubmit` function from `BookFormComponent` is assigned to the `ngSubmit`
    event of the form. So, when the submit button is clicked on, it will call the
    `onSubmit` function in `BookFormComponent`, passing value and valid property of
    `bookForm`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookFormComponent`中的`onSubmit`函数分配给了表单的`ngSubmit`事件。因此，当单击提交按钮时，它将调用`BookFormComponent`中的`onSubmit`函数，传递`bookForm`的值和有效属性。'
- en: Note that all the input controls do not have any event-cum-property attribute
    as in the template-driven form. Here, we can achieve the two-way binding by passing
    the model value from theÂ `bookForm.value` property to theÂ `onSubmit` function
    and accessing the model from component.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有的输入控件都没有任何事件兼属性属性，就像模板驱动表单中一样。在这里，我们可以通过将模型值从`bookForm.value`属性传递到`onSubmit`函数，并从组件中访问模型来实现双向绑定。
- en: 'We have the required template and components in place. Now we need to create
    an `AppModule` to bootstrap the root component of our application, `AppComponent`.
    Create a file named `app.module.ts` and add the following code snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好所需的模板和组件。现在我们需要创建一个`AppModule`来引导我们应用程序的根组件`AppComponent`。创建一个名为`app.module.ts`的文件，并添加以下代码片段：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, note that we have assigned the `AppComponent` class to
    bootstrap metadata to inform Angular that `AppComponent` is the root component
    of the application. Also, note that we have imported `FormsModule` and `ReactiveFormsModule`
    from `@angular/forms`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，请注意，我们已将 `AppComponent` 类分配为引导元数据，以通知 Angular `AppComponent` 是应用程序的根组件。还要注意，我们已从
    `@angular/forms` 导入了 `FormsModule` 和 `ReactiveFormsModule`。
- en: 'Now that we have all the required templates and classes in place, we need to
    bootstrap the module. Let''s create a file named `main.ts` with the following
    code snippet that bootstraps the module:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好所有所需的模板和类，我们需要引导模块。让我们创建一个名为 `main.ts` 的文件，其中包含如下代码段来引导模块：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, add the `index.html` file with the following content:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下内容添加 `index.html` 文件：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that the `<first-model-form/>` special tag is added in the body. This
    tag will be updated with the actual template during runtime. Also, note that the
    required libraries are loaded during runtime using the `System.js` module loader.
    The `systemjs.config.js` file should have the instructions on mapping the `npm`
    packages and our application''s starting point. Here, our application is bootstrapped
    in the `main.ts`, which will be transpiled to `main.js` after the application
    is built. The content of the `systemjs.config.js` is given here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`<first-model-form/>` 特殊标记被添加到正文中。此标记将在运行时更新为实际模板。还要注意，使用 `System.js` 模块加载器在运行时加载所需的库。`systemjs.config.js`
    文件应该包含有关如何映射 `npm` 包和我们应用程序的起始点的指令。在这里，我们的应用程序在 `main.ts` 中启动，在构建应用程序后，它将被转译为
    `main.js`。`systemjs.config.js` 的内容如下：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we have all that we need. Let''s run the application by pressing *F5*,
    and the index page will be rendered with the template powered by `BookFormComponent`,
    as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，我们已经拥有了所需的一切。按下 *F5* 运行应用程序，索引页面将以`BookFormComponent`为模板进行渲染，如下所示:'
- en: '![](img/image_03_003.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_003.png)'
- en: The output of the model-driven form
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 模型驱动表单的输出
- en: On clicking on the **`Submit`** button by keeping the console window open in
    the developer tools of the Chrome browser, note that the logging model object
    is logged with the form valid to false as the author property is missing its value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chrome 浏览器的开发者工具中保持控制台窗口打开的情况下，单击 **`提交`** 按钮。请注意，日志记录模型对象是表单有效值为 false，因为作者属性缺少值。
- en: 'Now, let''s key in some value in the author property and click on theÂ **`Submit`**
    button by keeping the console window open in the developer tools of the Chrome
    browser. Note that the model object logged with the form valid to true will all
    the required properties filled with value, shown as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在作者属性中输入一些值，并在 Chrome 浏览器的开发者工具中保持控制台窗口打开的情况下，单击**`提交`** 按钮。请注意，模型对象与填充了值的所有必需属性的表单有效值都被记录如下：
- en: '![](img/image_03_004.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_004.png)'
- en: Inspecting the model-driven form submission
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 检查模型驱动表单提交
- en: As we have configured the validations in the component using `FormGroup`, we
    have loosely coupled the validation logic by moving it from template to component.
    So, we can write test methods using any test framework to verify the validation
    logic by asserting the components. Refer to [Chapter 8](Learning%20Angular%20for%20.NET%20Developers_split_000.html#),
    *Testing Angular applications* to know how to test an angular application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `FormGroup` 在组件中配置验证时，我们将验证逻辑从模板松散耦合移动到了组件中。所以，我们可以使用任何测试框架编写测试方法来通过断言组件来验证验证逻辑。参考[第8章](Learning%20Angular%20for%20.NET%20Developers_split_000.html#)，*测试
    Angular 应用* 来了解如何测试 Angular 应用。
- en: Pipes
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道
- en: '* * *'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Pipes in Angular are a replacement of filters in AngularJS 1.x. Pipes are an
    improved version of filters that transform common data. Most of the applications
    fetch data from a server and transform it before displaying the data on the frontend.
    In such cases, pipes are very useful in transforming the data on rendering the
    template. Angular provides these cool API pipes for this purpose. Pipes take data
    as input and output transformed data as needed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，管道是 AngularJS 1.x 中过滤器的替代品。管道是过滤器的改良版本，可以转换常见数据。大多数应用程序都会从服务器获取数据，并在在前端显示数据之前对其进行转换。在这种情况下，管道在渲染模板时非常有用。Angular
    为此提供了这些强大的管道 API。管道将数据作为输入，并根据需要输出转换后的数据。
- en: Common pipes
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常用的管道
- en: 'The following are the built-in pipes available in `@angular/core`, and we will
    see a few pipes with examples:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `@angular/core` 中提供的内置管道，并将看到一些带有示例的管道：
- en: AsyncPipe
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AsyncPipe
- en: CurrencyPipe
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CurrencyPipe
- en: DatePipe
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DatePipe
- en: DecimalPipe
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DecimalPipe
- en: I18nPluralPipe
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I18nPluralPipe
- en: I18nSelectPipe
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I18nSelectPipe
- en: JsonPipe
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JsonPipe
- en: LowerCasePipe
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LowerCasePipe
- en: PercentPipe
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PercentPipe
- en: SlicePipe
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SlicePipe
- en: TitleCasePipe
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TitleCasePipe
- en: UpperCasePipe
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UpperCasePipe
- en: Pipe with parameters
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带参数的管道
- en: 'We can pass parameters to a pipe followed by a colon (:) symbol,Â as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过冒号(:)符号向管道传递参数，如下所示：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Multiple inputs to a pipe can be added by separating the values by (:), as
    shown:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过(:)分隔的方式可以将多个输入传递给管道，如下所示：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Chaining pipes
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道链
- en: 'In some scenarios, it may be necessary to use more than one pipe. For example,
    consider a scenario to display data in uppercase, long formatted date. The following
    code displays the publishing date of a book in uppercase and in long formatted
    date:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能需要使用多个管道。例如，考虑一种情况，需要以大写形式和长日期格式显示数据。以下代码以大写形式和长日期格式显示书籍的出版日期：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Currency pipes
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 货币管道
- en: 'Currency pipes format the number to the required currency format that is provided.
    This is the syntax for a currency pipe:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 货币管道将数字格式化为所需的货币格式。这是货币管道的语法：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `expression` is the input data for a pipe;Â `currency` is the keyword of
    the pipe, and it takes three arguments, namely `currencyCode`, which takes values
    such as USD, INR, GBP, and EUR, `symbolDisplay`, which accepts true or false to
    show/hide the currency symbol, and `digitInfo`, which takes the decimal format
    for the currency. The following template demonstrates how to use the currency
    pipe:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`expression`是管道的输入数据；`currency`是管道的关键词，它接受三个参数，分别为`currencyCode`，取值为 USD、INR、GBP
    和 EUR，`symbolDisplay`，接受 true 或 false 来显示/隐藏货币符号，以及`digitInfo`，用于货币的小数格式。以下模板演示了如何使用货币管道：'
- en: '![](img/image_03_005.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_005.png)'
- en: The template that implements a currency pipe
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实现货币管道的模板
- en: 'The output of the template will be as follows for various currency formats:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于各种货币格式，模板的输出如下：
- en: '![](img/image_03_006.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_006.png)'
- en: The output of using a currency pipe
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用货币管道的输出
- en: Date pipes
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期管道
- en: 'Date pipes transform input data to various date formats that are supported
    by a date pipe. The syntax of the date pipe is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 日期管道将输入数据转换为日期管道支持的各种日期格式。日期管道的语法如下：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s assume that `dateData` is assigned with `Date.now()` in a component.
    The implementation of the date pipe in the template is as shownÂ in the following
    screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设组件中的`dateData`被赋予了`Date.now()`。在模板中实现日期管道的方式如下截图所示：
- en: '![](img/image_03_007.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_007.png)'
- en: The template that implements the date pipe
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 实现日期管道的模板
- en: 'The output of this template after applying various date formats is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 应用各种日期格式后的模板输出如下：
- en: '![](img/image_03_008.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_008.png)'
- en: The output of using a date pipe
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日期管道的输出
- en: A date pipe supports various formats, such as `medium` (`yMMMdjms`), `short`
    (`yMdjm`), `mediumDate` (`yMMMd`), `shortDate` (`yMd`), `fullDate` (`yMMMMEEEEd`),
    `longDate` (`yMMMMd`), `mediumTime` (`jms`), and `shortTime` (`jm`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 日期管道支持各种格式，如`medium`(`yMMMdjms`)、`short`(`yMdjm`)、`mediumDate`(`yMMMd`)、`shortDate`(`yMd`)、`fullDate`(`yMMMMEEEEd`)、`longDate`(`yMMMMd`)、`mediumTime`(`jms`)和`shortTime`(`jm`)。
- en: Uppercase and lowercase pipes
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大写和小写管道
- en: 'Uppercase and lowercase pipes transform input data into uppercase and lowercase
    respectively. The following template displays an author name both in lowercase
    and uppercase:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 大写和小写管道将输入数据分别转换为大写和小写。以下模板同时显示作者姓名的大写和小写形式：
- en: '![](img/image_03_009.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_009.png)'
- en: The template that implements theÂ uppercase and lowercase pipes
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实现大写和小写管道的模板
- en: 'The output of this template is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板的输出如下：
- en: '![](img/image_03_010.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_010.png)'
- en: The output of implementing an uppercase and lowercase pipe
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 实现大写和小写管道的输出
- en: JSON pipes
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON 管道
- en: 'A JSON pipe is similar to applying `JSON.Stringify` in JavaScript to an object
    that holds JSON values. The usage of a JSON pipe in a template is shown in this
    screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 管道类似于在 JavaScript 中应用 `JSON.Stringify` 对持有 JSON 值的对象进行操作。模板中使用 JSON 管道的用法如下截图所示：
- en: '![](img/image_03_011.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_011.png)'
- en: The template that implements the JSON pipe
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 JSON 管道的模板
- en: 'The output of using a JSON pipe in a template is as illustrated:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中使用 JSON 管道的输出如下所示：
- en: '![](img/image_03_012.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_012.png)'
- en: The output of using the JSON pipe
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JSON 管道的输出
- en: AppComponent
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AppComponent
- en: '* * *'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '`AppComponent` is the component of an application that is configured as root
    component, and it handles the rendering of the `app.component.html`Â template.
    In the preceding sections, we saw the template code that implemented various pipes
    and their respective output. The following code snippet shows the component for
    the template:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppComponent`是一个应用程序的组件，其配置为根组件，并且处理`app.component.html`Â模板的渲染。在前面的章节中，我们看到了实现各种管道及其各自输出的模板代码。以下代码片段显示了模板的组件：'
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Pipes, very powerful and simple-to-use APIs provided by Angular, ease our process
    of formatting data before displaying it on the screen.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 管道，这是Angular提供的非常强大且易于使用的API，能够在显示在屏幕上之前格式化数据，这极大地简化了我们的流程。
- en: Routers
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器
- en: '* * *'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: AngularJS used the `ngRoute` module to run simple routers with basic features.
    It enables deep linking of URLs to components and views by mapping the path to
    the routes configured using the `$routeProvider` service. AngularJS 1.x needs
    the `ngRoute` module to be installed to implement routing in an application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS使用`ngRoute`模块来运行具有基本功能的简单路由器。它通过将路径映射到使用`$routeProvider`服务配置的路由来使URL与组件和视图进行深度链接。AngularJS
    1.x需要安装`ngRoute`模块才能在应用中实现路由。
- en: Angular introduced a Component Router that deep links the URL request and navigates
    to the template or view. It passes parameters, if any, to the respective component
    that is annotated for this route.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Angular引入了一个组件路由器，用于深度链接URL请求并导航到模板或视图。如果有任何参数，它会将其传递给标注为该路线的相应组件。
- en: The core concept of Component Routers
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件路由的核心概念
- en: Angular uses a Component Router for a view system. It also works on AngularJS
    1.x. It supports intercepting routes and providing route-specific values to the
    loaded component, automatic deep linking, nested, and sibling routes. Let's go
    through some of the core features of Component Routers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用一个组件路由器作为视图系统。它还适用于AngularJS 1.x。它支持拦截路由并为加载的组件提供特定路由值，自动深度链接，嵌套和同级路由。让我们来看一下组件路由器的一些核心功能。
- en: Setting up a Component Router
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置组件路由器
- en: A Component Router is not part of the core Angular framework. It comes as part
    of the Angular NPM bundle as an individual library, `@angular/router`. We need
    to add `@angular/router` to the `packages.json` under the dependencies section.
    Then, in the `app.routing.ts`, we need to import `Routes` and `RouterModule` from
    `@angular/router`. The router constitutes directives such as `RouterOutlet`, `RouterLink`,
    and `RouterLinkActive`, a service `RouterModule` and the configuration for `Routes`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 组件路由器不是核心Angular框架的一部分。它作为单独库`@angular/router`的一部分出现在Angular NPM包中。我们需要将`@angular/router`添加到`packages.json`中的依赖项部分。然后，在`app.routing.ts`中，我们需要从`@angular/router`中导入`Routes`和`RouterModule`。路由器包括诸如`RouterOutlet`，`RouterLink`和`RouterLinkActive`这样的指令，一个`RouterModule`服务和`Routes`的配置。
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Configuring routes
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置路由
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we have configured two routes that help the user navigate to the `about`
    and `contact` views when clicked on. Routes are basically a collection of route
    definitions. The value of the path defined identifies the component to be instantiated
    when the URL in the browser matches the path. Then, the instantiated component
    will take care of rendering the view.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们配置了两个路由，帮助用户在单击时转到`about`和`contact`视图。路由基本上是路由定义的集合。所定义的路径值标识出匹配路径的URL时要实例化的组件。然后，实例化的组件将负责渲染视图。
- en: 'Now, we need to add the configured routes to the `AppModule`, import the `RouterModule`
    from `@angular/router`, and add it to the imports section of `@NgModule`, as described:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将配置的路由添加到`AppModule`中，从`@angular/router`中导入`RouterModule`，并将其添加到`@NgModule`的imports部分中，如下所示：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, the `forRoot()` method provides router service providers and directives
    to perform navigation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`forRoot()`方法提供了路由器服务提供程序和指令来执行导航。
- en: Router Outlet and Router Links
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由出口和路由链接
- en: When the user passes `'/about'` in the address bar of the browser appending
    to the end of the application URL, the router will match the request with the
    `'about'` and initiate the `AboutComponent` to handle rendering the view for `about`.
    We need to somehow inform the router where to display this `about` view. This
    can be achieved by specifying `<router-outlet/>`, which is similar to the `<ng-view/>`
    tag in AngularJS 1.x to load the templates associated with the corresponding path
    of the route.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户将`'/about'`添加到应用程序URL的末尾后，将其传递到浏览器地址栏中时，路由将使用`'about'`匹配该请求，并启动`AboutComponent`来处理`about`视图的渲染。我们需要以某种方式告知路由器在哪里显示此`about`视图。可以通过指定`<router-outlet/>`来实现这一点，这类似于AngularJS
    1.x中的`<ng-view/>`标记，用于加载与路由相应路径相关的模板。
- en: 'Router links help navigate the route URL via the link specified in the anchor
    tag by clicking on the router link. A sample router link tag is given here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 路由链接可通过单击锚标记中指定的链接来导航到路由URL。以下是一个示例路由链接标记：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Services
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: '* * *'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The applications we create handle volumes of data. Most of the data will be
    retrieved from services and will be reused in various parts of the application.
    Let's create a service that can retrieve data using `http`. The service should
    be loosely coupled with components, as the primary focus of the component should
    be to support the view. So, the service can be injected to components using a
    dependency injection. This approach will enable us to mock the service in order
    to unit test the component.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的应用程序处理大量的数据。大多数数据将从服务中检索，并且将在应用程序的各个部分重用。让我们创建一个可以使用`http`检索数据的服务。服务应该与组件松散耦合，因为组件的主要重点应该是支持视图。因此，可以使用依赖注入将服务注入到组件中。这种方法将使我们能够模拟服务以进行单元测试组件。
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that the service decorated with `@Injectable` is to let Angular know that
    this service is injectable.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，用`@Injectable`装饰的服务是为了让Angular知道这个服务是可注入的。
- en: 'We can inject the injectable `TodoService` to the constructor of `AppComponent`,
    as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将可注入的`TodoService`注入到`AppComponent`的构造函数中，如下所示：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When bootstrapping, we also need to pass `TodoService` so that Angular will
    create anÂ instance of the service and keep it available wherever it is injected.
    So, let''s pass `TodoService` to the `bootstrap` function, as illustrated, in
    the `main.ts` file:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '在引导过程中，我们还需要传递`TodoService`，这样Angular将创建服务的实例，并在其被注入的任何地方保持可用。因此，让我们在`main.ts`文件中如所示地向`bootstrap`函数传递`TodoService`： '
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that the injectable service is wrapped with square brackets. This is one
    way of applying the dependency injection. Refer toÂ [Chapter 2](Learning%20Angular%20for%20.NET%20Developers_split_000.html#),
    *Angular Building Blocks - Part 1*,Â for more information on the dependency injection
    in Angular. Angular has improved dependency injection that takes care of creating
    an instance of `TodoService` and injecting it to Component.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可注入服务用方括号括起来。这是一种应用依赖注入的方法。有关Angular依赖注入更多信息，请参考[第2章](Learning%20Angular%20for%20.NET%20Developers_split_000.html#),
    *Angular Building Blocks - Part 1*。Angular已经改进了依赖注入，可以创建`TodoService`的实例并将其注入到组件中。
- en: 'In the `app.component.html` template, we iterate each item of the `todos` property
    in `AppComponent` and list them:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.component.html`模板中，我们遍历`AppComponent`中`todos`属性的每个项目并列出它们：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The content of this template will be rendered under the `<my-service>` special
    tag in the body of the `index.html` file:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板的内容将在`index.html`文件的`<my-service>`特殊标签下呈现：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'On running, the application will render the list of `todo` items, as shown:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，应用程序将呈现如下的`todo`项目清单：
- en: '![](img/image_03_013.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_013.png)'
- en: The output of my to-do application
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我的待办事项应用程序的输出
- en: Observables
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察对象
- en: '* * *'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: In AngularJS, we consumed services to retrieve data asynchronously using promises
    in `$http`. In Angular, we have the `Http` service over `$http`, and it returns
    an observable object instead of a promise as it applies a pattern called the analogous
    pattern. Angular leverages the Observable class adopted from the ReactiveX library.
    ReactiveX is an API for asynchronous programming with Observables that is done
    by applying the observer andÂ iterator patterns and functional programming. You
    can find more information about Reactive programming atÂ [http://reactivex.io/](http://reactivex.io/).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AngularJS 中，我们使用服务以异步方式使用 `$http` 中的 promise 获取数据。在 Angular 中，我们有了 `Http`
    服务取代了 `$http`，它返回一个可观察对象而不是 promise，因为它应用了类似模式。 Angular 利用了从 ReactiveX 库采用的 Observable
    类。 ReactiveX 是一个用于应用观察者、迭代器模式和函数式编程完成异步编程的 API。你可以在 [http://reactivex.io/](http://reactivex.io/)
    找到有关反应式编程的更多信息。
- en: Observer pattern will notify the dependents if their dependency object is changed.
    Iterator pattern will facilitate access to a collection without the need to know
    about the structure of the element in the collection. Combining these patterns
    in ReactiveX enables the observer to subscribe to an observable collection objection.
    The observer doesn't need to wait until the observable collection object is available.
    Instead, the observer will react when it gets the notification ofÂ the changes
    in the observables.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Observer 模式将在依赖对象更改时通知依赖者。迭代器模式将方便地访问集合，无需了解集合中元素的结构。在 ReactiveX 中结合这些模式使观察者能够订阅可观察的集合对象。观察者不需要等到可观察的集合对象可用时才能做出反应，而是在获得可观察对象更改通知时做出反应。
- en: Angular uses the JavaScript implementation called RxJS, which is a set of libraries
    rather than a specific API. It uses Observables in the HTTPÂ service and event
    system. A promiseÂ always returns one value.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 使用名为 RxJS 的 JavaScript 实现，它是一组库而不是一个特定的 API。它在 HTTP 服务和事件系统中使用 Observables。promise
    总是返回一个值。
- en: The `http.get()` method will return Observables, and this can be subscribed
    by a client to get the data returned from the service. Observables can handle
    multiple values. So, we can also call multiple `http.get()` methods and wrap them
    under the `forkJoin` method that is exposed by Observables.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.get()` 方法将返回 Observables，并且客户端可以订阅以获取从服务返回的数据。 Observables 可以处理多个值。因此，我们还可以调用多个
    `http.get()` 方法，并将它们包装在 Observables 提供的 `forkJoin` 方法下。'
- en: We can also control the service call and delay the call using Observable by
    applying a rule to call the service only if the previous call to the service was
    500 milliseconds ago.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以控制服务调用并通过 Observable 延迟调用，通过应用一个规则，只有在上次对服务的调用是 500 毫秒前才调用服务。
- en: Observables are cancelable. So, it is also possible to cancel the previous request
    by unsubscribing to it and making a new request. We can cancel any previously
    unserved call anytime.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Observables 是可取消的。所以，我们也可以通过取消订阅来取消之前的请求，并发起新的请求。我们随时可以取消任何之前未完成的调用。
- en: 'Let''s modify `TodoService` to use Observable and replace the hardcoded JSON
    value with the `http.get()` call to a `todos.json` file. The updated `TodoService`
    is shownÂ here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 `TodoService` 以使用 Observable，并将硬编码的 JSON 值替换为对 `todos.json` 文件的 `http.get()`
    调用。更新后的 `TodoService` 如下所示：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that we have imported HTTPÂ modules, response from `@angular/http`, and
    the Observable module from `rsjs/Rx`, which is based on ReactiveX. The `getTodos`
    method is updated with an `http.get()` call that queries `todos.json` and returns
    a collection of to-do items.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们从 `@angular/http` 中导入了 HTTP 模块、`rsjs/Rx` 中的响应，以及基于 ReactiveX 的 Observable
    模块。`getTodos` 方法通过调用 `todos.json` 查询并返回一组待办事项来更新。
- en: '`AppComponent` and `TodoService` are bootstrapped in the `app.module.ts` file,
    as shown:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppComponent` 和 `TodoService` 在 `app.module.ts` 文件中进行了引导，如下所示：'
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Import `{bootstrap}` from `''@angular/platform-browser-dynamic''`; the template
    is updated to render the list of todos, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `'@angular/platform-browser-dynamic'` 中导入 `{bootstrap}`；模板被更新以渲染待办事项列表，如下所示：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Running the application will render the data subscribed from Observables that
    is returned by the methods in `TodoService`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用将呈现从 `TodoService` 中返回的从 Observables 订阅的数据：
- en: '![](img/image_03_014.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_014.png)'
- en: The output of index.html that renders the data subscribed from Observables
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Observables 订阅的渲染数据的 index.html 输出
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: '* * *'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Woohoo! You've completed learning the rest of the building blocks of the Angular
    architecture. We started the chapter with forms and walked through the types of
    forms available in Angular and how to implement them. Then, you learned about
    pipes, which is an alternative to filters in AngularJS 1.x. Next, we discussed
    routers, and you learned how easy it is to configure a router to a component in
    Angular.Â Finally, you learned how to create a service in Angular and how to access
    an external service using the HTTPÂ module. You also learned about the advantages
    of using Observables and implementing it in service calls.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 哇呜！你已经学习完了 Angular 架构的其余构建模块。我们从表单开始介绍本章，并讨论了 Angular 中可用的表单类型以及如何实现它们。然后，您了解了管道，这是
    AngularJS 1.x 中筛选器的替代方案。接下来，我们讨论了路由器，并学习了如何在 Angular 中配置路由器到组件是多么容易。最后，您学会了如何在
    Angular 中创建服务以及如何使用 HTTP 模块访问外部服务。您还了解了使用 Observables 的优势以及在服务调用中如何实现它。
- en: In the next chapter, we will discuss the fundamentals of TypeScript.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 TypeScript 的基础知识。
