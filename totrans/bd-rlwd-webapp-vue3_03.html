<html><head></head><body>
<div id="_idContainer033">
<h1 class="chapter-number" id="_idParaDest-45"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-46"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.2.1">Building a Local Weather App</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Now that we can build a small app, we can add a bit more complexity. </span><span class="koboSpan" id="kobo.3.2">In this case, we’ll take a look at including another browser API and combining it with an external data source for our app. </span><span class="koboSpan" id="kobo.3.3">We will build a small weather app that returns the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">current weather.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We will start applying a different means of styling, using Tailwind as our CSS framework of choice, and in order to provide some additional robustness, we will also take a look at including some tests in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We’ll cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Working with external data coming from different types </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">of APIs</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">How to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">asynchronous data</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Applying Tailwind to quickly style </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">any application</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Ensuring stability by adding unit tests </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">for features</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">Let’s see what requirements we have to fulfil to get our application up </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">and running.</span></span></p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">For this chapter, we are going to use a third-party API to provide us with actual data. </span><span class="koboSpan" id="kobo.20.2">We need to register an account at </span><a href="https://www.weatherapi.com/"><span class="koboSpan" id="kobo.21.1">https://www.weatherapi.com/</span></a><span class="koboSpan" id="kobo.22.1"> and retrieve the API keys for usage in </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">our app.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">We’ll add Tailwind CSS to apply styling to our app. </span><span class="koboSpan" id="kobo.24.2">The </span><a href="https://tailwindcss.com/"><span class="koboSpan" id="kobo.25.1">https://tailwindcss.com/</span></a><span class="koboSpan" id="kobo.26.1"> website offers extensive documentation as well as an </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">installation guide.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">For our unit test, we’ll use the Vitest </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">framework: </span></span><a href="https://vitest.dev/"><span class="No-Break"><span class="koboSpan" id="kobo.30.1">https://vitest.dev/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.31.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">You can find the source code </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">here: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/03.weather"><span class="No-Break"><span class="koboSpan" id="kobo.34.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/03.weather</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.35.1">.</span></span></p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.36.1">Initializing the app</span></h1>
<p><span class="koboSpan" id="kobo.37.1">Let’s begin by starting with a</span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.38.1"> slightly different configuration for the Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">CLI starter:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.40.1">
npm init vue@latest</span></pre> <p><span class="koboSpan" id="kobo.41.1">Hit </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">y</span></strong><span class="koboSpan" id="kobo.43.1"> to proceed, choose </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">vue-local-weather</span></strong><span class="koboSpan" id="kobo.45.1"> as the project name, and select the options shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.47.1"><img alt="Figure 3.1 – The setup configuration for the local weather app" src="image/B19563_03_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.48.1">Figure 3.1 – The setup configuration for the local weather app</span></p>
<p><span class="koboSpan" id="kobo.49.1">After following the instructions to install the dependencies and cleaning up the default files, we can get </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">to work!</span></span></p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.51.1">Working with different types of APIs</span></h1>
<p><span class="koboSpan" id="kobo.52.1">In order to </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.53.1">retrieve local weather, we need a way to retrieve a location. </span><span class="koboSpan" id="kobo.53.2">The weather service we will be using accepts different sorts of location data, but we’ll go with latitude and longitude for </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">this example.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">It’s convenient that the browser’s geolocation API can provide us with just that! </span><span class="koboSpan" id="kobo.55.2">Let’s start by building a component that requests this information and displays it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">user interface.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">Let’s create a file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">components</span></strong><span class="koboSpan" id="kobo.59.1"> folder, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">GetLocation.vue</span></strong><span class="koboSpan" id="kobo.61.1">. </span><span class="koboSpan" id="kobo.61.2">We’ll start in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">script</span></strong><span class="koboSpan" id="kobo.63.1"> tag by</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.64.1"> importing the utilities from Vue.js and define the data that’s expected to </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">be available:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.66.1">
&lt;script lang="ts" setup&gt;import { ref } from "vue";
import type { Ref } from "vue";
type Geolocation = {
  latitude: number;
  longitude: number;
};
const coords: Ref&lt;Geolocation | undefined&gt;= ref();
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.67.1">Now, we’re saying that we will expect the reactive property </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">coords</span></strong><span class="koboSpan" id="kobo.69.1"> to contain a latitude and longitude. </span><span class="koboSpan" id="kobo.69.2">Nothing fancy. </span><span class="koboSpan" id="kobo.69.3">Let’s write a function that retrieves the data from the geolocation API (</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/geolocation"><span class="koboSpan" id="kobo.70.1">https://developer.mozilla.org/en-US/docs/Web/API/Navigator/geolocation</span></a><span class="koboSpan" id="kobo.71.1">). </span><span class="koboSpan" id="kobo.71.2">Now, bear in mind that a user can deny access to this API, so we need a fallback </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">We’ll add a reactive Boolean property, </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">geolocationBlockedByUser</span></strong><span class="koboSpan" id="kobo.75.1">, to keep track of the success of calling the API and a function that does the </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">actual calling:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.77.1">
&lt;script lang="ts" setup&gt;import { ref } from "vue";
import type { Ref } from "vue";
type Geolocation = {
  latitude: number;
  longitude: number;
};
const coords: Ref&lt;Geolocation | undefined&gt; = ref();
</span><strong class="bold"><span class="koboSpan" id="kobo.78.1">const geolocationBlockedByUser: Ref&lt;boolean&gt; = ref(false);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.79.1">const getGeolocation = async (): Promise&lt;void&gt; =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.80.1">  await navigator.geolocation.getCurrentPosition(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.81.1">    () =&gt; {},</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.82.1">    (error: { message: string }) =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.83.1">      geolocationBlockedByUser.value = true;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.84.1">      console.error(error.message);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.85.1">    }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.86.1">  );</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.87.1">};</span></strong><span class="koboSpan" id="kobo.88.1">
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.89.1">There’s a couple of things going on here. </span><span class="koboSpan" id="kobo.89.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">getGeolocation</span></strong><span class="koboSpan" id="kobo.91.1"> function is being defined and, because it is dependent on user input, it is an asynchronous function by default. </span><span class="koboSpan" id="kobo.91.2">The promise it</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.92.1"> returns is empty because we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">successCallback</span></strong><span class="koboSpan" id="kobo.94.1"> to update our </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">reactive property.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">That bit is empty right now, but we’ll add it in the next step. </span><span class="koboSpan" id="kobo.96.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">errorCallback</span></strong><span class="koboSpan" id="kobo.98.1"> function only gets called if the geolocation cannot be retrieved, and for now, we’ll just assume that the user declined usage. </span><span class="koboSpan" id="kobo.98.2">So, we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">geolocationBlockedByUser</span></strong><span class="koboSpan" id="kobo.100.1"> value to true and log the error to </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">the console.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">Looking at the documentation (</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API/Using_the_Geolocation_API#getting_the_current_position"><span class="koboSpan" id="kobo.103.1">https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API/Using_the_Geolocation_API#getting_the_current_position</span></a><span class="koboSpan" id="kobo.104.1">), we see that </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">getCurrentPosition</span></strong><span class="koboSpan" id="kobo.106.1"> returns an object (position) that holds latitude and longitude on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">coords</span></strong><span class="koboSpan" id="kobo.108.1"> property. </span><span class="koboSpan" id="kobo.108.2">Since our </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">coords</span></strong><span class="koboSpan" id="kobo.110.1"> reactive property expects </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.111.1">a latitude and longitude, we process the data from the API </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.113.1">
const getGeolocation = async (): Promise&lt;void&gt; =&gt; {  await navigator.geolocation.getCurrentPosition(
    </span><strong class="bold"><span class="koboSpan" id="kobo.114.1">async (position: { coords: Geolocation }) =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.115.1">      coords.value = position.coords;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.116.1">    }</span></strong><span class="koboSpan" id="kobo.117.1">,
    (error: { message: string }) =&gt; {
      geolocationBlockedByUser.value = true;
      console.error(error.message);
    }
  );
};</span></pre>
<p><span class="koboSpan" id="kobo.118.1">This all works now, but the function hasn’t been executed yet. </span><span class="koboSpan" id="kobo.118.2">Like in the previous chapter, we’ll use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">onMounted</span></strong><span class="koboSpan" id="kobo.120.1"> hook to execute the function once the component gets mounted on the DOM. </span><span class="koboSpan" id="kobo.120.2">The entire </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">script</span></strong><span class="koboSpan" id="kobo.122.1"> tag should now look </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.124.1">
&lt;script lang="ts" setup&gt;import { ref, onMounted } from "vue";
import type { Ref } from "vue";
type Geolocation = {
  latitude: number;
  longitude: number;
};
const coords: Ref&lt;Geolocation | undefined&gt; = ref();
const geolocationBlockedByUser: Ref&lt;boolean&gt; = ref(false);
const getGeolocation = async (): Promise&lt;void&gt; =&gt; {
  await navigator.geolocation.getCurrentPosition(
    async (position: { coords: Geolocation }) =&gt; {
      coords.value = position.coords;
    },
    (error: { message: string }) =&gt; {
      geolocationBlockedByUser.value = true;
      console.error(error.message);
    }
  );
};
onMounted(async () =&gt; {
  await getGeolocation();
});
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.125.1">Let’s quickly add a</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.126.1"> template block that renders the output </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.128.1">
&lt;template&gt;  &lt;div v-if="coords &amp;&amp; !geolocationBlockedByUser"&gt;{{ coords.latitude }} {{ coords.longitude }}&lt;/div&gt;
  &lt;div v-if="geolocationBlockedByUser"&gt;User denied access&lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.129.1">Adding the component to </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">App.vue</span></strong><span class="koboSpan" id="kobo.131.1"> is a matter of importing the component and rendering it on </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">the template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.133.1">
&lt;script setup lang="ts"&gt;import GetLocation from "./components/GetLocation.vue";
&lt;/script&gt;
&lt;template&gt;
  &lt;GetLocation /&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.134.1">Start our development</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.135.1"> server with </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">npm run dev</span></strong><span class="koboSpan" id="kobo.137.1">. </span><span class="koboSpan" id="kobo.137.2">Now, if you open the app in the browser, you should expect to see a browser popup asking for permission to share your location. </span><span class="koboSpan" id="kobo.137.3">If you grant access, you should see coordinates that your browser determined as your location (results may vary). </span><span class="koboSpan" id="kobo.137.4">If you have denied access, you should see the message stating that </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">you did.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.139.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.140.1">If you inspect the console closely, you may notice a warning: </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">Only request geolocation information in response to a user gesture</span></strong><span class="koboSpan" id="kobo.142.1">. </span><span class="koboSpan" id="kobo.142.2">It is typically considered an anti-pattern or rude to immediately attempt to gather geo information. </span><span class="koboSpan" id="kobo.142.3">Not all browsers will always show a confirmation dialog and that could lead to users disclosing information without </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">them knowing!</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">The correct approach would be to add a button to the template that executes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">getGeolocation</span></strong><span class="koboSpan" id="kobo.146.1"> function using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">onClick</span></strong><span class="koboSpan" id="kobo.148.1"> directive. </span><span class="koboSpan" id="kobo.148.2">That way, a user actively initiates the request </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">for geoloca</span><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.150.1">tion.</span></span></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.151.1">Handling data from a third-party API</span></h1>
<p><span class="koboSpan" id="kobo.152.1">Now that we have </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.153.1">our coordinates, we can start to request localized weather data. </span><span class="koboSpan" id="kobo.153.2">For this example, we’ll make use of a public weather API (</span><a href="https://www.weatherapi.com/"><span class="koboSpan" id="kobo.154.1">https://www.weatherapi.com/</span></a><span class="koboSpan" id="kobo.155.1">). </span><span class="koboSpan" id="kobo.155.2">In order to make use of the service, we’ll need to request an API key. </span><span class="koboSpan" id="kobo.155.3">If you sign up for an account, the free tier will allow you to make 1,000,000 requests per month, which should be more </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">than enough!</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">It is common practice to store these sorts of access keys or secrets in a local environment variables file. </span><span class="koboSpan" id="kobo.157.2">This practice allows our build processes to detach local development operations from our production environments. </span><span class="koboSpan" id="kobo.157.3">It keeps those variables in one place, rather than being spread throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">For now, we’ll store the API key in a file at the root of your project called </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">.env</span></strong><span class="koboSpan" id="kobo.161.1">, with the </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">following contents:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.163.1">
VITE_APP_WEATHER_API_KEY=Replace this with the key</span></pre> <p><span class="koboSpan" id="kobo.164.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">VITE_APP_</span></strong><span class="koboSpan" id="kobo.166.1"> prefix makes sure that Vite automatically exposes the variable to </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">the application.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.168.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.169.1">With a client-based web application, the key will be exposed by default, since it will be attached to API calls that you can inspect via your browser’s network requests. </span><span class="koboSpan" id="kobo.169.2">For our purposes, this is fine. </span><span class="koboSpan" id="kobo.169.3">In a production-like environment, you would likely proxy the request via your own backend to obfuscate any secrets from </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">the p</span><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.171.1">ublic.</span></span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.172.1">Constructing the API call</span></h2>
<p><span class="koboSpan" id="kobo.173.1">Having our token </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.174.1">on hand, we can start to make the call. </span><span class="koboSpan" id="kobo.174.2">Let’s discover how we need to construct the endpoint address to retrieve our </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">relevant data.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">Using the API explorer (</span><a href="https://www.weatherapi.com/api-explorer.aspx"><span class="koboSpan" id="kobo.177.1">https://www.weatherapi.com/api-explorer.aspx</span></a><span class="koboSpan" id="kobo.178.1">), we see that we can fetch data from the service using a location. </span><span class="koboSpan" id="kobo.178.2">While the explorer shows a place name, if we dig into the request parameters (</span><a href="https://www.weatherapi.com/docs/#intro-request"><span class="koboSpan" id="kobo.179.1">https://www.weatherapi.com/docs/#intro-request</span></a><span class="koboSpan" id="kobo.180.1">), we see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">q</span></strong><span class="koboSpan" id="kobo.182.1"> parameter also accepts a latitude and longitude in decimal degrees, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">q=48.8567,2.3508</span></strong><span class="koboSpan" id="kobo.184.1">. </span><span class="koboSpan" id="kobo.184.2">This is something we </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">can use!</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">Looking at the docs, we need something </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.188.1">
https://api.weatherapi.com/v1/current.json?key=OUR_SECRET_KEY&amp;q=OUR_LATITUDE_AND_LONGITUDE</span></pre> <p><span class="koboSpan" id="kobo.189.1">We can manually call this by pasting this endpoint as a URL in the browser, replacing the variables with our actual data. </span><span class="koboSpan" id="kobo.189.2">You should see a formatted JSON object with weather data for your location! </span><span class="koboSpan" id="kobo.189.3">Now</span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.190.1"> that we’re assured that everything works, we can move the logic to a Vue component to include it in </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">our app.</span></span></p>
<p><span class="koboSpan" id="kobo.192.1">Let’s create a component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">WeatherReport.vue</span></strong><span class="koboSpan" id="kobo.194.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">component</span></strong><span class="koboSpan" id="kobo.196.1"> folder. </span><span class="koboSpan" id="kobo.196.2">We’ll start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">script</span></strong><span class="koboSpan" id="kobo.198.1"> block, and start by describing two types that we will be working with and defining the props that this component </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">needs (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">coords</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.202.1">
&lt;script lang="ts" setup&gt;type WeatherData = {
  location: {
    localtime: Date;
    name: string;
    region: string;
  };
  current: {
    temp_c: number;
    temp_f: number;
    precip_mm: number;
    condition: {
      text: string;
      icon: string;
    };
    wind_degree: number;
    wind_kph: number;
    wind_mph: number;
  };
};
type Coords = { latitude: number; longitude: number }
interface Props {
  coords: Coords;
}
const props = defineProps&lt;Props&gt;();
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.203.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">WeatherData</span></strong><span class="koboSpan" id="kobo.205.1"> type, I’ve taken a look at what the API returns to us, only describing the properties that we’re interested in. </span><span class="koboSpan" id="kobo.205.2">Feel free to pick metric or imperial units when implementing! </span><span class="koboSpan" id="kobo.205.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">Coords</span></strong><span class="koboSpan" id="kobo.207.1"> type is as simple as holding numerical values for latitude and longitude </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.208.1">and we can reuse that type within our </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">script</span></strong><span class="koboSpan" id="kobo.210.1"> block, for instance, to describe the </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">coords</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.212.1">component property.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">If we want to use the response from the endpoint, we need to make it reactive. </span><span class="koboSpan" id="kobo.213.2">We can do this using </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">ref</span></strong><span class="koboSpan" id="kobo.215.1"> and we’ll map it to a </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">data constant:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.217.1">
&lt;script lang="ts" setup&gt;</span><strong class="bold"><span class="koboSpan" id="kobo.218.1">import { ref } from "vue";</span></strong><span class="koboSpan" id="kobo.219.1">
import type { Ref } from 'vue'
type WeatherData = {
  …
};
type Coords = { latitude: number; longitude: number }
interface Props {
  coords: Coords;
}
const props = defineProps&lt;Props&gt;();
</span><strong class="bold"><span class="koboSpan" id="kobo.220.1">const data: Ref&lt;WeatherData | undefined&gt; = ref();</span></strong><span class="koboSpan" id="kobo.221.1">
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.222.1">With this in place, we’re ready to define the caller function, using the fetch API. </span><span class="koboSpan" id="kobo.222.2">In the function, we’ll take in a</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.223.1"> parameter representing the coordinates for our request. </span><span class="koboSpan" id="kobo.223.2">We’ll return the data so we can later map it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">data</span></strong><span class="koboSpan" id="kobo.225.1"> property we’ve </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">just created:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
&lt;script lang="ts" setup&gt;import { ref, </span><strong class="bold"><span class="koboSpan" id="kobo.228.1">onMounted</span></strong><span class="koboSpan" id="kobo.229.1"> } from "vue";
import type { Ref } from 'vue'
type WeatherData = {
  …
};
type Coords = { latitude: number; longitude: number }
interface Props {
  coords: Coords;
}
const props = defineProps&lt;Props&gt;();
const data: Ref&lt;WeatherData | undefined&gt; = ref();
</span><strong class="bold"><span class="koboSpan" id="kobo.230.1">const fetchWeather = async (coords: Coords): Promise&lt;WeatherData&gt; =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.231.1">  const { latitude, longitude } = coords;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.232.1">  const q = ${latitude},${longitude};</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.233.1">  const res = await fetch(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.234.1">    `https://api.weatherapi.com/v1/current.json?key=${</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.235.1">      import.meta.env.VITE_APP_WEATHER_API_KEY</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.236.1">    }&amp;q=${q}`</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.237.1">  );</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.238.1">  const data = await res &amp;&amp; res.json();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.239.1">  return data;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.240.1">};</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.241.1">onMounted(async () =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.242.1">  const { latitude, longitude } = props.coords;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.243.1">  const weatherResponse = await fetchWeather({latitude, longitude});</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.244.1">  data.value = weatherResponse;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.245.1">});</span></strong><span class="koboSpan" id="kobo.246.1">
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.247.1">As you can see, we’re describing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">fetchWeather</span></strong><span class="koboSpan" id="kobo.249.1"> function that returns a promise in the shape of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">WeatherData</span></strong><span class="koboSpan" id="kobo.251.1"> type. </span><span class="koboSpan" id="kobo.251.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">coords</span></strong><span class="koboSpan" id="kobo.253.1"> parameter to construct the URL, combining it with the secret key. </span><span class="koboSpan" id="kobo.253.2">On fulfilling the request with a response, we transform it to JSON and return </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">the value.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">Similar to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">GetLocation</span></strong><span class="koboSpan" id="kobo.257.1"> component, we want to fetch the data immediately, so we’ve used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">onMount</span></strong><span class="koboSpan" id="kobo.259.1"> hook in a</span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.260.1"> similar fashion. </span><span class="koboSpan" id="kobo.260.2">We’ve passed the component props to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">fetchWeather</span></strong><span class="koboSpan" id="kobo.262.1"> function and mapped the response to the reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">data variable.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">Now that we have our data, we can mark up the template to show the information! </span><span class="koboSpan" id="kobo.264.2">We’re dealing with asynchronous data, so we have a UI state where data is </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">still loading.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">Let’s start with adding the two states to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">WeatherReport.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.268.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.269.1">
&lt;template&gt;  &lt;div&gt;
    &lt;article
      v-if="data &amp;&amp; data.current"&gt;
      {{ data.current }}
    &lt;/article&gt;
    &lt;div v-else&gt;Loading...&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.270.1">Provided you have a quick response from the server, the data should show up </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">almost instantly.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">Now let’s take a look at how we can build our interface </span><a id="_idTextAnchor067"/><span class="No-Break"><span class="koboSpan" id="kobo.273.1">with style!</span></span></p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.274.1">Styling with Tailwind</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.275.1">Tailwind CSS</span></strong><span class="koboSpan" id="kobo.276.1"> is a popular </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.277.1">utility-based CSS framework that we can use to build and style user interfaces by using and combining predefined classes. </span><span class="koboSpan" id="kobo.277.2">Tailwind is very scalable due to abstracting the writing of CSS</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.278.1"> rules, which provides consistency and maintainability where it’s used. </span><span class="koboSpan" id="kobo.278.2">Let’s take a look at how we</span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.279.1"> can apply Tailwind CSS to our </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">little application.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">The installation guide (</span><a href="https://tailwindcss.com/docs/guides/vite"><span class="koboSpan" id="kobo.282.1">https://tailwindcss.com/docs/guides/vite</span></a><span class="koboSpan" id="kobo.283.1">) covers all of the steps we need </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">to</span></span><span class="No-Break"><a id="_idIndexMarker082"/></span><span class="No-Break"><span class="koboSpan" id="kobo.285.1"> execute:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.286.1">First, we will have to add the dependencies to </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">the project:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.288.1">npm install -D tailwindcss postcss autoprefixer</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.289.1">We’re installing Tailwind, but also the tooling to allow Vite to process the stylesheet using PostCSS. </span><span class="koboSpan" id="kobo.289.2">PostCSS is a powerful JS tool for transforming CSS using </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">JavaScript (</span></span><a href="https://postcss.org/"><span class="No-Break"><span class="koboSpan" id="kobo.291.1">https://postcss.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.292.1">).</span></span></p></li> <li><span class="koboSpan" id="kobo.293.1">Next, we’ll initialize the default configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">for Tailwind:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.295.1">npx tailwindcss init -p</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.296.1">The command will have generated two configuration files for us (a PostCSS config file and a Tailwind config file). </span><span class="koboSpan" id="kobo.296.2">Out of the box, they will already help us, but let’s add a good practice to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">tailwind.config.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.298.1"> file:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.299.1">/** @type {import('tailwindcss').Config} */export default {  </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">purge: ['./index.html', './src/**/*.{vue,js,ts,jsx,tsx}'],</span></strong><span class="koboSpan" id="kobo.301.1">  content: [</span><strong class="bold"><span class="koboSpan" id="kobo.302.1">'./src/**/*.{vue,js,ts,jsx,tsx}'</span></strong><span class="koboSpan" id="kobo.303.1">],  theme: {    extend: {},  },  plugins: [],}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.304.1">The line that we added will remove all unused styles from the production build of our application! </span><span class="koboSpan" id="kobo.304.2">The pattern in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">content</span></strong><span class="koboSpan" id="kobo.306.1"> property tells the plugin where Tailwind should be applied. </span><span class="koboSpan" id="kobo.306.2">The next step is exposing the utility classes of Tailwind to </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">the application.</span></span></p></li> <li><span class="koboSpan" id="kobo.308.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">style.css</span></strong><span class="koboSpan" id="kobo.310.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">./src</span></strong><span class="koboSpan" id="kobo.312.1"> folder and add the following lines to import Tailwind CSS utility</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.313.1"> classes in your development and </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">build steps:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.315.1">
@tailwind base;@tailwind components;@tailwind utilities;</span></pre></li> <li><span class="koboSpan" id="kobo.316.1">And finally, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">./src/main.ts</span></strong><span class="koboSpan" id="kobo.318.1"> file to import the CSS file into </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">the app:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.320.1">
import { createApp } from 'vue'</span><strong class="bold"><span class="koboSpan" id="kobo.321.1">import './style.css'</span></strong><span class="koboSpan" id="kobo.322.1">import App from './App.vue'createApp(App).mount('#app')</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.323.1">Bear in mind that an imported CSS file differs from how you would traditionally link a CSS stylesheet to an HTML file. </span><span class="koboSpan" id="kobo.323.2">By importing it, the CSS file will be part of the development and build pipelines, which allows us to perform advanced operations on the styles before they </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">are output.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">In our case, we’re importing references to Tailwind CSS, adding browser-specific prefixes, and removing unused classes from the stylesheet. </span><span class="koboSpan" id="kobo.325.2">Having this amount of control and power is very convenient for building </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">advanced apps!</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">With our setup in place, we can start to apply Tailwind CSS to our application. </span><span class="koboSpan" id="kobo.327.2">Tailwind uses utility classes to define the stylin</span><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.328.1">g of </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">an element.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.330.1">Utility classes</span></h2>
<p><span class="koboSpan" id="kobo.331.1">The approach of utility-class-based CSS frameworks is built around the notion of having CSS tightly coupled with a user interface while abstracting underlying rules and definitions. </span><span class="koboSpan" id="kobo.331.2">Instead of adding a class name to an element and then applying CSS styles within that class, you now</span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.332.1"> add multiple class names to an element that describe the </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">CSS behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">Having a tightly coupled relationship between an element and how it’s styled has the benefit of it being very maintainable, with few hidden rules or side effects that affect how an element will be rendered. </span><span class="koboSpan" id="kobo.334.2">The base CSS file remains the same size; it’s just the list of all </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">utility classes.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">We can even remove unused styles since we know what classes we’re using in the markup. </span><span class="koboSpan" id="kobo.336.2">This has a higher level of predictability than more traditional CSS, where the relation between a style definition and the element that depended on the style is a lot less clear. </span><span class="koboSpan" id="kobo.336.3">Especially for rapid prototyping, the utility-based approach really shines, so let’s put it </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">into practice.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">Let’s make a small change to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">index.html</span></strong><span class="koboSpan" id="kobo.340.1"> file to see Tailwind CSS in action. </span><span class="koboSpan" id="kobo.340.2">We’re going to add a list of classes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">&lt;div/&gt;</span></strong><span class="koboSpan" id="kobo.342.1"> element where our app </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">is mounted:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.344.1">
bg-gradient-to-b from-indigo-500 via-purple-500 to-pink-500 w-full h-screen flex items-center justify-center</span></pre> <p><span class="koboSpan" id="kobo.345.1">One of the strengths of Tailwind CSS is its readability. </span><span class="koboSpan" id="kobo.345.2">From the markup, we can visualize how the component will render in the browser. </span><span class="koboSpan" id="kobo.345.3">In this case, a multi-colored gradient as a background and the content at the horizontal and vertical center of the page. </span><span class="koboSpan" id="kobo.345.4">To learn more about the available Tailwind utility classes, the official docs provide a comprehensive list of all available </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">classes: </span></span><a href="https://tailwindcss.com/docs"><span class="No-Break"><span class="koboSpan" id="kobo.347.1">https://tailwindcss.com/docs</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.348.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">The file looks </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.351.1">
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;link rel="icon" type="image/svg+xml" href="/vite.svg" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;Vite + Vue + TS&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"</span><strong class="bold"><span class="koboSpan" id="kobo.352.1"> class="bg-gradient-to-b from-indigo-500 via-purple-500 to-pink-500 w-full h-screen flex items-center justify-center"</span></strong><span class="koboSpan" id="kobo.353.1">&gt;&lt;/div&gt;
    &lt;script type="module" src="/src/main.ts"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</span></pre>
<p><span class="koboSpan" id="kobo.354.1">If we look at the application in the </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.355.1">browser now, we can see the result of this change. </span><span class="koboSpan" id="kobo.355.2">Combining more of the utility classes, we’ll stylize the data we get from the </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">weather API.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">Let’s go over to </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">WeatherReport.vue</span></strong><span class="koboSpan" id="kobo.359.1"> and add some styling and </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">HTML elements:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.361.1">
&lt;template&gt;  &lt;div&gt;
    &lt;article
      v-if="data &amp;&amp; data.current"
      </span><strong class="bold"><span class="koboSpan" id="kobo.362.1">class="max-w-md w-96 rounded-lg shadow-lg p-4 flex bg-white text-black"</span></strong><span class="koboSpan" id="kobo.363.1">
    &gt;
      </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">&lt;div class="basis-1/4 text-left"&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.365.1">        &lt;img :src="data.current.condition.icon" class="h-16 w-16" /&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.366.1">      &lt;/div&gt;</span></strong><span class="koboSpan" id="kobo.367.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.368.1">&lt;div class="basis-3/4 text-left"&gt;</span></strong><span class="koboSpan" id="kobo.369.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.370.1">&lt;h1 class="text-3xl font-bold"&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.371.1">          {{ data.current.condition.text }}</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.372.1">          &lt;span class="text-2xl block"&gt;{{ data.current.temp_c }}&amp;#8451;&lt;/span&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.373.1">        &lt;/h1&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.374.1">        &lt;p&gt;{{ data.location.name }} {{ data.location.region }}&lt;/p&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.375.1">        &lt;p&gt;Precipitation: {{ data.current.precip_mm }}mm&lt;/p&gt;</span></strong><span class="koboSpan" id="kobo.376.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.377.1">&lt;/div&gt;</span></strong><span class="koboSpan" id="kobo.378.1">
    &lt;/article&gt;
    &lt;div v-else&gt;Loading...&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.379.1">This is already looking good! </span><span class="koboSpan" id="kobo.379.2">See how we’re combining Tailwind classes to determine how an element should be</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.380.1"> styled? </span><span class="koboSpan" id="kobo.380.2">You can experiment with all sorts of different ways of presenting </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">We have a couple of predefined properties not yet mapped to the template. </span><span class="koboSpan" id="kobo.382.2">Let’s take a look at them because they require so</span><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.383.1">me </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">extra attention.</span></span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.385.1">Formatting data</span></h2>
<p><span class="koboSpan" id="kobo.386.1">Let’s take a look at the</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.387.1"> timestamp from the service. </span><span class="koboSpan" id="kobo.387.2">We’re receiving it as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">datetime</span></strong><span class="koboSpan" id="kobo.389.1"> string. </span><span class="koboSpan" id="kobo.389.2">We can format it to show up as a bit more readable information. </span><span class="koboSpan" id="kobo.389.3">We can just use a formatting function to format any date string into something we like. </span><span class="koboSpan" id="kobo.389.4">We’ll create the function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.391.1"> block of </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">the component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.393.1">
const formatDate = (dateString: Date): string =&gt; {  const date = new Date(dateString);
  return new Intl.DateTimeFormat("default", {
    dateStyle: "long",
    timeStyle: "short",
  }).format(date);
};</span></pre>
<p><span class="koboSpan" id="kobo.394.1">We’re using the browser’s built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">Intl</span></strong><span class="koboSpan" id="kobo.396.1"> namespace (</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl"><span class="koboSpan" id="kobo.397.1">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl</span></a><span class="koboSpan" id="kobo.398.1">) to interpret date information and returning it to the user based on the browser’s settings. </span><span class="koboSpan" id="kobo.398.2">Now we can simply call the method </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.399.1">from </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">the template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.401.1">
&lt;template&gt;  &lt;div&gt;
    &lt;article
      v-if="data &amp;&amp; data.current"
      class="max-w-md w-96 rounded-lg shadow-lg p-4 flex bg-white text-black"
    &gt;
      &lt;div class="basis-1/4 text-left"&gt;
        &lt;img :src="data.current.condition.icon" class="h-16 w-16" /&gt;
      &lt;/div&gt;
      &lt;div class="basis-3/4 text-left"&gt;
        &lt;h1 class="text-3xl font-bold"&gt;
          {{ data.current.condition.text }}
          &lt;span class="text-2xl block"&gt;{{ data.current.temp_c }}&amp;#8451;&lt;/span&gt;
        &lt;/h1&gt;
        &lt;p&gt;{{ data.location.name }} {{ data.location.region }}&lt;/p&gt;
        &lt;p&gt;Precipitation: {{ data.current.precip_mm }}mm&lt;/p&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.402.1">        &lt;p&gt;{{ formatDate(data.location.localtime) }}&lt;/p&gt;</span></strong><span class="koboSpan" id="kobo.403.1">
      &lt;/div&gt;
    &lt;/article&gt;
    &lt;div v-else&gt;Loading...&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.404.1">Vue.js interprets the information between the brackets as an expression, so it will just evaluate the </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.405.1">output of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">formatDate</span></strong><span class="koboSpan" id="kobo.407.1"> method as the</span><a id="_idTextAnchor073"/> <span class="No-Break"><span class="koboSpan" id="kobo.408.1">rendered information.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.409.1">Custom style use cases</span></h2>
<p><span class="koboSpan" id="kobo.410.1">Now we’re left with information regarding wind: speed and direction. </span><span class="koboSpan" id="kobo.410.2">Representing the wind speed is straightforward: either </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.411.1">pick the metric value or the imperial value and render it in the template. </span><span class="koboSpan" id="kobo.411.2">Representing the wind direction, we can make it a bit more user-friendly by indicating direction using an arrow that points in a </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">certain direction.</span></span></p>
<p><span class="koboSpan" id="kobo.413.1">For such a specialized operation, it is best to create a new component. </span><span class="koboSpan" id="kobo.413.2">Let’s create one called </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">WindDirection.vue</span></strong><span class="koboSpan" id="kobo.415.1"> for the moment. </span><span class="koboSpan" id="kobo.415.2">It will receive a numerical property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">degrees</span></strong><span class="koboSpan" id="kobo.417.1">. </span><span class="koboSpan" id="kobo.417.2">We will use the property to create a dynamic (computed) style, depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">the input:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.419.1">
&lt;script lang="ts" setup&gt;import { computed } from "vue";
interface Props {
  degrees: number;
}
const props = defineProps&lt;Props&gt;();
const windStyle = computed(() =&gt; ({
  transform: "rotate(" + props.degrees + "deg)",
}));
&lt;/script&gt;
&lt;template&gt;
  &lt;span
    &gt;&lt;span aria-hidden="true" class="inline-block" :style="windStyle"&gt;⬇&lt;/span
    &gt;&lt;span class="sr-only"&gt;Wind direction: {{ degrees }} degrees&lt;/span&gt;&lt;/span
  &gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.420.1">In the file, there are two</span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.421.1"> interesting things going on. </span><span class="koboSpan" id="kobo.421.2">For starters, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">degrees</span></strong><span class="koboSpan" id="kobo.423.1"> property gets used to create a computed value called </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">windStyle</span></strong><span class="koboSpan" id="kobo.425.1">. </span><span class="koboSpan" id="kobo.425.2">That value holds a dynamic CSS property and thus will be responsive to any prop it will get. </span><span class="koboSpan" id="kobo.425.3">We apply the style by binding it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">:style</span></strong><span class="koboSpan" id="kobo.427.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">&lt;span&gt;</span></strong><span class="koboSpan" id="kobo.429.1"> element, which simply holds </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">an arrow.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">The second thing to point out is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">&lt;span&gt;</span></strong><span class="koboSpan" id="kobo.433.1"> element with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">sr-only</span></strong><span class="koboSpan" id="kobo.435.1"> class. </span><span class="koboSpan" id="kobo.435.2">This is a technique to make the content more accessible and it is something you should always consider. </span><span class="koboSpan" id="kobo.435.3">The arrow and its rotation only make sense when you can see the component being rendered. </span><span class="koboSpan" id="kobo.435.4">Not everybody can rely on sight when using the web. </span><span class="koboSpan" id="kobo.435.5">Some people use tools such as screen readers to process information on a </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">given page.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">Tailwind offers a special class utility to mark content for screen readers only, which means its contents are hidden by default browser behavior. </span><span class="koboSpan" id="kobo.437.2">A screen reader will likely read out the contents of the element. </span><span class="koboSpan" id="kobo.437.3">In this case, we’re describing the meaning of the arrow with </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">its rotation.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">Please be mindful of providing tools to make any website or application accessible for all </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">by default.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">Let’s now add this</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.442.1"> component to our application to wrap it </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">all up:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.444.1">
&lt;script lang="ts" setup&gt;import { ref, onMounted } from "vue";
import type { Ref } from 'vue'
</span><strong class="bold"><span class="koboSpan" id="kobo.445.1">import WindDirection from "./WindDirection.vue";</span></strong><span class="koboSpan" id="kobo.446.1">
// abbreviated…
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;article
      v-if="data &amp;&amp; data.current"
      class="max-w-md w-96 rounded-lg shadow-lg p-4 flex bg-white text-black"
    &gt;
      &lt;!-- abbreviated --&gt;
      &lt;/div&gt;
      &lt;div class="basis-3/4 text-left"&gt;
        &lt;h1 class="text-3xl font-bold"&gt;
          &lt;!-- abbreviated --&gt;
        &lt;/h1&gt;
        &lt;p&gt;{{ data.location.name }} {{ data.location.region }}&lt;/p&gt;
        &lt;p&gt;Precipitation: {{ data.current.precip_mm }}mm&lt;/p&gt;
        &lt;p&gt;{{ formatDate(data.location.localtime) }}&lt;/p&gt;
        </span><strong class="bold"><span class="koboSpan" id="kobo.447.1">&lt;p&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.448.1">          Wind: {{ data.current.wind_kph }} kph</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.449.1">          &lt;wind-direction :degrees="data.current.wind_degree" /&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.450.1">        &lt;/p&gt;</span></strong><span class="koboSpan" id="kobo.451.1">
      &lt;/div&gt;
    &lt;/article&gt;
    &lt;div v-else&gt;Loading...&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.452.1">That’s it! </span><span class="koboSpan" id="kobo.452.2">That’s our weather app! </span><span class="koboSpan" id="kobo.452.3">You can style it any way you want. </span><span class="koboSpan" id="kobo.452.4">If you want to add or remove properties, please finish the last part first, because it will help you maintain stability throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">your changes.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">In our next section, we’ll </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.455.1">add unit tests for specific features of the app. </span><span class="koboSpan" id="kobo.455.2">Unit tests take in small bits (units) of the code and validate that these parts have the same output when given certain conditions.</span><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.456.1"> Let’s see how </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">that works.</span></span></p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.458.1">Ensuring stability with Vitest</span></h1>
<p><span class="koboSpan" id="kobo.459.1">Now that we have a working</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.460.1"> app, adding or removing a property</span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.461.1"> can be done with ease. </span><span class="koboSpan" id="kobo.461.2">Just update the file and you’re ready. </span><span class="koboSpan" id="kobo.461.3">This is, however, not always a desirable situation. </span><span class="koboSpan" id="kobo.461.4">Having the ability to remove properties that easily could result in unwanted bugs in </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">your application!</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">We can add more control to our code by describing its behavior using tests. </span><span class="koboSpan" id="kobo.463.2">In this part, we’ll take a look at adding unit tests with Vitest and Vue Test Utils, to demonstrate where unit tests can help </span><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.464.1">you (and where </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">they cannot).</span></span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.466.1">Vue Test Utils</span></h2>
<p><span class="koboSpan" id="kobo.467.1">The official testing library for Vue.js projects is </span><strong class="bold"><span class="koboSpan" id="kobo.468.1">Vue Test Utils</span></strong><span class="koboSpan" id="kobo.469.1"> (</span><a href="https://test-utils.vuejs.org/"><span class="koboSpan" id="kobo.470.1">https://test-utils.vuejs.org/</span></a><span class="koboSpan" id="kobo.471.1">). </span><span class="koboSpan" id="kobo.471.2">A testing framework is a series of tools and functions that you can use to create isolated instances of a </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.472.1">component and manipulate it to assert </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">certain behaviors.</span></span></p>
<p><span class="koboSpan" id="kobo.474.1">The purpose of unit testing is to validate that each unit (or component) of the software is working as expected and meets the </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.475.1">specified requirements. </span><span class="koboSpan" id="kobo.475.2">In our case, we could write tests for our Vue components, but also for JavaScript files that just </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">export functions.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">With our selected preset, we’ve already included the test tooling in our app. </span><span class="koboSpan" id="kobo.477.2">It even added a test script as part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">package.json</span></strong><span class="koboSpan" id="kobo.479.1"> file to run our tests with, so we can get started with writing some tests. </span><span class="koboSpan" id="kobo.479.2">There are several ways of organizing and structuring code. </span><span class="koboSpan" id="kobo.479.3">I prefer to have tests next to the component that they are testing. </span><span class="koboSpan" id="kobo.479.4">Test files are identified by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">.spec.ts</span></strong><span class="koboSpan" id="kobo.481.1"> suffix in the filename, so you can always spot them </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">with ease.</span></span></p>
<p><span class="koboSpan" id="kobo.483.1">There are a couple of things to consider when it comes to writing good </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">unit tests:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.485.1">You should be able to test each functionality </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">in isolation</span></span></li>
<li><span class="koboSpan" id="kobo.487.1">Each unit test should be independent of all other tests, and not rely on the state of other tests </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">or functions</span></span></li>
<li><span class="koboSpan" id="kobo.489.1">Tests support your documentation, so use logical and descriptive names to help understand what a </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">test covers</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.491.1">We’ll discover what I mean while we are writing different sets of tests or both Vue components as plain </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">JavaScript files.</span></span></p>
<p><span class="koboSpan" id="kobo.493.1">Let’s start with something simple. </span><span class="koboSpan" id="kobo.493.2">Our entry point of the application is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">./src/app.vue</span></strong><span class="koboSpan" id="kobo.495.1"> component. </span><span class="koboSpan" id="kobo.495.2">Let’s quickly open </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.497.1">
&lt;script setup lang="ts"&gt;import GetLocation from "./components/GetLocation.vue";
&lt;/script&gt;
&lt;template&gt;
  &lt;GetLocation /&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.498.1">Now, in terms of functionality, little can go wrong. </span><span class="koboSpan" id="kobo.498.2">It imports the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">GetLocation</span></strong><span class="koboSpan" id="kobo.500.1"> component and mounts it to the template. </span><span class="koboSpan" id="kobo.500.2">If we consider this from a documentation point of view, you could describe the functionality of the component as </span><em class="italic"><span class="koboSpan" id="kobo.501.1">it should render the GetLocation component</span></em><span class="koboSpan" id="kobo.502.1">. </span><span class="koboSpan" id="kobo.502.2">We can assert this, and this is exactly how we will write our </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">first test.</span></span></p>
<p><span class="koboSpan" id="kobo.504.1">Create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">App.spec.ts</span></strong><span class="koboSpan" id="kobo.506.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">following content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.508.1">
import { describe, it, expect } from 'vitest'import { shallowMount } from "@vue/test-utils";
import GetLocation from "./components/GetLocation.vue";
import App from "./App.vue";
describe("App", ():void  =&gt; {
  it("renders the GetLocation component", ():void =&gt; {
    const wrapper = shallowMount&lt;App&gt;(App);
    expect(wrapper.findComponent(GetLocation).exists()).toBe(true);
  });
});</span></pre>
<p><span class="koboSpan" id="kobo.509.1">In this example, we import some tools to write our tests and assertions from Vitest. </span><span class="koboSpan" id="kobo.509.2">We also import a method to mount a component in our test and import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">GetLocation</span></strong><span class="koboSpan" id="kobo.511.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">App</span></strong><span class="koboSpan" id="kobo.513.1"> components. </span><span class="koboSpan" id="kobo.513.2">You can </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.514.1">execute the unit tests with </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">this command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.516.1">
npm run test:unit</span></pre> <p><span class="koboSpan" id="kobo.517.1">This command will execute all of the recognized test files and keep a watcher running to rerun any changed tests. </span><span class="koboSpan" id="kobo.517.2">The script automatically generates a report of the tests in </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">the console.</span></span></p>
<p><span class="koboSpan" id="kobo.519.1">A (shallow) mounted component will behave just as it would when being rendered by a browser, but we run this in isolation. </span><span class="koboSpan" id="kobo.519.2">With Vue Test Utils, you can either </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">mount</span></strong><span class="koboSpan" id="kobo.521.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">shallowMount</span></strong><span class="koboSpan" id="kobo.523.1"> a component, with the difference being that a mount also attempts to render any children. </span><span class="koboSpan" id="kobo.523.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">shallowMount</span></strong><span class="koboSpan" id="kobo.525.1"> function creates stubs for any children, which reduces side effects and focuses directly on the component itself. </span><span class="koboSpan" id="kobo.525.2">As a rule of thumb, I tend to always use </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">shallowMount</span></strong><span class="koboSpan" id="kobo.527.1"> unless I </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.528.1">need to assert specific </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">parent-child behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.530.1">We scope the test with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">describe</span></strong><span class="koboSpan" id="kobo.532.1"> block and make sure that we describe what the subject of our </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">test is.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">Then we write our test: </span><em class="italic"><span class="koboSpan" id="kobo.535.1">it renders the GetLocation component</span></em><span class="koboSpan" id="kobo.536.1">. </span><span class="koboSpan" id="kobo.536.2">This simply mounts the </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">App</span></strong><span class="koboSpan" id="kobo.538.1"> component and then asserts whether the stub of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">GetLocation</span></strong><span class="koboSpan" id="kobo.540.1"> compone</span><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.541.1">nt was found in the </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">render tree.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.543.1">Global test functions</span></h2>
<p><span class="koboSpan" id="kobo.544.1">We will use three functions in all </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.545.1">our tests to create our test assertions. </span><span class="koboSpan" id="kobo.545.2">These functions are used to create clear and organized testing code, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">describe</span></strong><span class="koboSpan" id="kobo.547.1"> function used to </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.548.1">group tests into logical test suites, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">it</span></strong><span class="koboSpan" id="kobo.550.1"> function used to define individual test cases, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">expect</span></strong><span class="koboSpan" id="kobo.552.1"> function used to define the expected behavior of the code </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">being tested.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">We can make a small modification in our project files that removes the need for manually importing those much </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">used functions.</span></span></p>
<p><span class="koboSpan" id="kobo.556.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">vite.config.ts</span></strong><span class="koboSpan" id="kobo.558.1"> file and look for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">test</span></strong><span class="koboSpan" id="kobo.560.1"> property. </span><span class="koboSpan" id="kobo.560.2">If we add a new property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">globals</span></strong><span class="koboSpan" id="kobo.562.1"> with the value </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">true</span></strong><span class="koboSpan" id="kobo.564.1"> as a child of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">test</span></strong><span class="koboSpan" id="kobo.566.1"> property, you should end up with something similar </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">to this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.568.1">
export default defineConfig({  plugins: [vue()],
  test: {
    </span><strong class="bold"><span class="koboSpan" id="kobo.569.1">globals: true,</span></strong><span class="koboSpan" id="kobo.570.1">
    environment: "jsdom",
  }
})</span></pre>
<p><span class="koboSpan" id="kobo.571.1">Now we can use the functions, but our IDE is not aware of those functions, so we need to configure some additional </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.572.1">settings. </span><span class="koboSpan" id="kobo.572.2">First, we need to install some types by</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.573.1"> running the following command in </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">the CLI:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.575.1">
npm i --save-dev @types/jest</span></pre> <p><span class="koboSpan" id="kobo.576.1">We’ll update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">tsconfig.vitest.json</span></strong><span class="koboSpan" id="kobo.578.1"> file with the following addition </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">types</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.582.1">
{  "extends": "./tsconfig.app.json",
  "exclude": [],
  "compilerOptions": {
    "composite": true,
    "lib": [],
    "types": ["node", "jsdom"</span><strong class="bold"><span class="koboSpan" id="kobo.583.1">, "jest"</span></strong><span class="koboSpan" id="kobo.584.1">]
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.585.1">Now our IDE is perfectly okay with directly using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">describe</span></strong><span class="koboSpan" id="kobo.587.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">it</span></strong><span class="koboSpan" id="kobo.589.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">expect</span></strong><span class="koboSpan" id="kobo.591.1"> functions. </span><span class="koboSpan" id="kobo.591.2">And that’s all you need to do in order to register them as globally available functions. </span><span class="koboSpan" id="kobo.591.3">You can remove that line f</span><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.592.1">rom our first test file if </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">you like.</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.594.1">A simple component test</span></h2>
<p><span class="koboSpan" id="kobo.595.1">Let’s work our way on to more complex </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.596.1">components now. </span><span class="koboSpan" id="kobo.596.2">Let’s start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">WindDirection</span></strong><span class="koboSpan" id="kobo.598.1"> component. </span><span class="koboSpan" id="kobo.598.2">We can assert a couple of things here that the component renders, but also that it adds the correct style to the direction indicator and that the screen reader text reflects the </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">same value.</span></span></p>
<p><span class="koboSpan" id="kobo.600.1">First, we’ll create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">WindDirection.spec.ts</span></strong><span class="koboSpan" id="kobo.602.1"> file, with the </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">following contents:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.604.1">
import { shallowMount } from "@vue/test-utils";import WindDirection from "./WindDirection.vue";
describe("WindDirection", () =&gt; {
  it("renders without crashing", (): void =&gt; {
    const wrapper = shallowMount(WindDirection, {
      props: {
        degrees: 90,
      },
    });
    expect(wrapper).toBeTruthy();
  });
});</span></pre>
<p><span class="koboSpan" id="kobo.605.1">This only asserts that the component should not error when provided with the minimum requirement of properties. </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">toBeTruthy</span></strong><span class="koboSpan" id="kobo.607.1"> is a loose assertion that asserts if the value is any expression or value that evaluates </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">to true.</span></span></p>
<p><span class="koboSpan" id="kobo.609.1">When we take into </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.610.1">consideration that we want to isolate tests as much as possible, we can add a test for rendering the wind direction arrow with the appropriate style. </span><span class="koboSpan" id="kobo.610.2">For that, we want to retrieve an element – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">span</span></strong><span class="koboSpan" id="kobo.612.1"> element the computed style is applied to. </span><span class="koboSpan" id="kobo.612.2">It is common practice in these cases to add a specific attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">data-testid</span></strong><span class="koboSpan" id="kobo.614.1"> to the element. </span><span class="koboSpan" id="kobo.614.2">Modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">span</span></strong><span class="koboSpan" id="kobo.616.1"> element to add the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">data-testid</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.618.1"> attribute:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.619.1">
&lt;span aria-hidden="true" class="inline-block" </span><strong class="bold"><span class="koboSpan" id="kobo.620.1">data-testid="direction"</span></strong><span class="koboSpan" id="kobo.621.1"> :style="windStyle"&gt;⬇&lt;/span&gt;</span></pre> <p><span class="koboSpan" id="kobo.622.1">Now we have something to have our tests point at. </span><span class="koboSpan" id="kobo.622.2">The benefit of adding a specific attribute for testing over targeting by class name or hierarchical structure is that this is far less likely to be subject to changes over time, which makes your tests </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">more robust:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.624.1">
import { shallowMount } from "@vue/test-utils";import WindDirection from "./WindDirection.vue";
describe("WindDirection", () =&gt; {
  it("renders without crashing", (): void =&gt; {
    const wrapper = shallowMount(WindDirection, {
      props: {
        degrees: 90,
      },
    });
    expect(wrapper).toBeTruthy();
  });
</span><strong class="bold"><span class="koboSpan" id="kobo.625.1">  it("renders the indicator with the correct wind direction", (): void =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.626.1">    const wrapper = shallowMount(WindDirection, {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.627.1">      props: {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.628.1">        degrees: 90,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.629.1">      },</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.630.1">    });</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.631.1">    const direction = wrapper.find("[data-testid=direction]");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.632.1">    expect(direction.attributes("style")).toContain("rotate(90deg)");</span></strong><span class="koboSpan" id="kobo.633.1">
    expect(direction.html()).toContain("⬇");
</span><strong class="bold"><span class="koboSpan" id="kobo.634.1">  });</span></strong><span class="koboSpan" id="kobo.635.1">
});</span></pre>
<p><span class="koboSpan" id="kobo.636.1">As you can see, we localized the element using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">[data-testid=direction]</span></strong><span class="koboSpan" id="kobo.638.1"> query and then asserted its style. </span><span class="koboSpan" id="kobo.638.2">By mapping it to the contents (a downward-pointing arrow), the combination of rotation with the arrow provides meaningful context. </span><span class="koboSpan" id="kobo.638.3">If we were to replace the downward-facing arrow with any other content, the component would lose its meaning</span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.639.1"> and the test would </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">rightfully fail.</span></span></p>
<p><span class="koboSpan" id="kobo.641.1">We can add the final assertion, aimed at screen reader usage. </span><span class="koboSpan" id="kobo.641.2">First, we’ll add another </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">data-testid</span></strong><span class="koboSpan" id="kobo.643.1"> attribute to the component. </span><span class="koboSpan" id="kobo.643.2">In this case, to the </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">screen-reader-related element:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.645.1">
&lt;span class="sr-only" </span><strong class="bold"><span class="koboSpan" id="kobo.646.1">data-testid="direction-sr"</span></strong><span class="koboSpan" id="kobo.647.1">&gt;Wind direction: {{ degrees }} degrees&lt;/span&gt;</span></pre> <p><span class="koboSpan" id="kobo.648.1">This value has to be unique in order for us to target it from the test file, which now looks </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.650.1">
import { shallowMount } from "@vue/test-utils";import WindDirection from "./WindDirection.vue";
describe("WindDirection", () =&gt; {
  it("renders without crashing", (): void =&gt; {
    const wrapper = shallowMount(WindDirection, {
      props: {
        degrees: 90,
      },
    });
    expect(wrapper).toBeTruthy();
  });
  it("renders with the correct wind direction", (): void =&gt; {
    const wrapper = shallowMount(WindDirection, {
      props: {
        degrees: 90,
      },
    });
    const direction = wrapper.find("[data-testid=direction]");
    expect(direction.attributes("style")).toContain("rotate(90deg)");
    expect(direction.html()).toContain("⬇");
  });
</span><strong class="bold"><span class="koboSpan" id="kobo.651.1">  it("renders the correct wind direction for screen readers", (): void =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.652.1">    const wrapper = shallowMount(WindDirection, {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.653.1">      props: {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.654.1">        degrees: 270,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.655.1">      },</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.656.1">    });</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.657.1">    const srOnly = wrapper.find("[data-testid=direction-sr]");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.658.1">    expect(srOnly.classes()).toContain('sr-only')</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.659.1">    expect(srOnly.html()).toContain("Wind direction: 270 degrees");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.660.1">  });</span></strong><span class="koboSpan" id="kobo.661.1">
});</span></pre>
<p><span class="koboSpan" id="kobo.662.1">In terms of isolation, we are executing this test on a new instance of the mounted component, and we are only looking at the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">direction-sr</span></strong><span class="koboSpan" id="kobo.664.1"> attributed component. </span><span class="koboSpan" id="kobo.664.2">We do this because, if a test fails, we should be able to immediately see what the cause and </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">effect is.</span></span></p>
<p><span class="koboSpan" id="kobo.666.1">We could add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">expect</span></strong><span class="koboSpan" id="kobo.668.1"> lines to the previous test block, but if any assertion failed, we would not be able to see the direct cause. </span><span class="koboSpan" id="kobo.668.2">In small code bases, it wouldn’t be a big concern, but you can imagine the</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.669.1"> complexity when you’re dealing with a code base made up of hundreds of components with their unit tests. </span><span class="koboSpan" id="kobo.669.2">That </span><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.670.1">is why isolation and simplicity </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">are key.</span></span></p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.672.1">Mocking external sources</span></h2>
<p><span class="koboSpan" id="kobo.673.1">The previous component </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.674.1">only dealt with its own state. </span><span class="koboSpan" id="kobo.674.2">But we’ve also incorporated external sources in our application. </span><span class="koboSpan" id="kobo.674.3">We can’t test what we can’t control, so we don’t have to test those external sources. </span><span class="koboSpan" id="kobo.674.4">We do have to test the way that our component interacts with external sources. </span><span class="koboSpan" id="kobo.674.5">To make that more predictable, we can use mocks to control </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">the output.</span></span></p>
<p><span class="koboSpan" id="kobo.676.1">A good example is the browser API we’re using to retrieve the geolocation of a user. </span><span class="koboSpan" id="kobo.676.2">Let’s create our </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">GetLocation.spec.ts</span></strong><span class="koboSpan" id="kobo.678.1"> file to test </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">the component!</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.680.1">
import { shallowMount } from "@vue/test-utils";import GetLocation from "./GetLocation.vue";
describe("GetLocation", () =&gt; {
  it("should render the component without crashing", (): void =&gt; {
    const wrapper = shallowMount(GetLocation);
    expect(wrapper).toBeTruthy();
  });
});</span></pre>
<p><span class="koboSpan" id="kobo.681.1">If we run our test now, it will fail. </span><span class="koboSpan" id="kobo.681.2">We need to fix two things here, to be honest. </span><span class="koboSpan" id="kobo.681.3">First of all, the test is an asynchronous test, since the retrieval of geolocation is </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">a promise:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.683.1">
import { shallowMount } from "@vue/test-utils";import GetLocation from "./GetLocation.vue";
describe("GetLocation", () =&gt; {
  it("should render the component without crashing", </span><strong class="bold"><span class="koboSpan" id="kobo.684.1">async</span></strong><span class="koboSpan" id="kobo.685.1"> (): </span><strong class="bold"><span class="koboSpan" id="kobo.686.1">Promise&lt;void&gt;</span></strong><span class="koboSpan" id="kobo.687.1"> =&gt; {
    const wrapper = </span><strong class="bold"><span class="koboSpan" id="kobo.688.1">await </span></strong><span class="koboSpan" id="kobo.689.1">shallowMount(GetLocation);
    expect(wrapper).toBeTruthy();
  });
});</span></pre>
<p><span class="koboSpan" id="kobo.690.1">Unfortunately, this still doesn’t work. </span><span class="koboSpan" id="kobo.690.2">This is because the tests are not executed in an actual browser, but in </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">jsdom</span></strong><span class="koboSpan" id="kobo.692.1">, which is</span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.693.1"> a JavaScript-based browser environment. </span><span class="koboSpan" id="kobo.693.2">It doesn’t support (all of the) native </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">browser APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.695.1">The component tries to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">navigator.geolocation.getCurrentPosition</span></strong><span class="koboSpan" id="kobo.697.1"> API, but it doesn’t exist! </span><span class="koboSpan" id="kobo.697.2">We need to mock it to allow our component to render. </span><span class="koboSpan" id="kobo.697.3">Mocking can be a bit abstract, but it is really about controlling the environment that affects our components. </span><span class="koboSpan" id="kobo.697.4">In our case, we can use a very </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">straightforward implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.699.1">
it("should render the component without crashing", async (): Promise&lt;void&gt; =&gt; {</span><strong class="bold"><span class="koboSpan" id="kobo.700.1">  global.navigator.geolocation = {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.701.1">    getCurrentPosition: () =&gt; {},</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.702.1">  };</span></strong><span class="koboSpan" id="kobo.703.1">
  const wrapper = await shallowMount(GetLocation);
  expect(wrapper).toBeTruthy();
});</span></pre>
<p><span class="koboSpan" id="kobo.704.1">In this case, we’re simply providing a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">getCurrentPosition</span></strong><span class="koboSpan" id="kobo.706.1"> so that it exists in the </span><em class="italic"><span class="koboSpan" id="kobo.707.1">browser</span></em><span class="koboSpan" id="kobo.708.1"> when we’re executing our test. </span><span class="koboSpan" id="kobo.708.2">This service doesn’t return any valid or useful information, but that’s not what we’re interested in here. </span><span class="koboSpan" id="kobo.708.3">We just want our component to be able </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">to render.</span></span></p>
<p><span class="koboSpan" id="kobo.710.1">Also bear in mind that this test </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.711.1">highlights a flaw in our application: it needs </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">navigator.geolocation.getCurrentPosit</span><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.713.1">ion</span></strong><span class="koboSpan" id="kobo.714.1"> to be present; otherwise, it </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">will fail!</span></span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.716.1">Mocking for success</span></h2>
<p><span class="koboSpan" id="kobo.717.1">To extend our testing scenario, we need to assert that our component is able to return a successfully resolved </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.718.1">geolocation. </span><span class="koboSpan" id="kobo.718.2">We are going to create a new test case, because of isolation, and improve upon our mocked navigator API. </span><span class="koboSpan" id="kobo.718.3">We’ll use Vitest,s </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">vi.fn()</span></strong><span class="koboSpan" id="kobo.720.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">for this.</span></span></p>
<p><span class="koboSpan" id="kobo.722.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">vi.fn()</span></strong><span class="koboSpan" id="kobo.724.1"> function (</span><a href="https://vitest.dev/api/vi.html#vi-fn"><span class="koboSpan" id="kobo.725.1">https://vitest.dev/api/vi.html#vi-fn</span></a><span class="koboSpan" id="kobo.726.1">) is a Vitest function that creates a spy on the function. </span><span class="koboSpan" id="kobo.726.2">This means it stores all call arguments, returns, and instances. </span><span class="koboSpan" id="kobo.726.3">By storing it in </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">mockGeoLocation</span></strong><span class="koboSpan" id="kobo.728.1">, we can assert its properties more easily. </span><span class="koboSpan" id="kobo.728.2">The function takes in an argument, which is a callable </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">mock instance.</span></span></p>
<p><span class="koboSpan" id="kobo.730.1">At the top of the test file, we’ll import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">vi</span></strong><span class="koboSpan" id="kobo.732.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.734.1">
import { vi } from 'vitest'</span></pre> <p><span class="koboSpan" id="kobo.735.1">Let’s have a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">the test:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.737.1">
it("displays when geolocation resolved successfully", async (): Promise&lt;void&gt; =&gt; {  const mockGeoLocation = vi.fn((successCallback: Function) =&gt; {
    const position = {
      coords: {
        latitude: 51.5074,
        longitude: -0.1278,
      },
    };
    successCallback(position);
  });
  global.navigator.geolocation = {
    getCurrentPosition: mockGeoLocation,
  };
  const wrapper = await shallowMount&lt;GetLocation&gt;(GetLocation);
  expect(wrapper.vm.coords).toEqual({
    latitude: 51.5074,
    longitude: -0.1278,
  });
});</span></pre>
<p><span class="koboSpan" id="kobo.738.1">In this case, instead of just having an empty function on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">navigator.geolocation.getCurrentPostition</span></strong><span class="koboSpan" id="kobo.740.1"> method, we’ve created a mock of what a successful resolution would look like. </span><span class="koboSpan" id="kobo.740.2">We can find out the specifications of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">getCurrentPosition</span></strong><span class="koboSpan" id="kobo.742.1"> API (</span><a href="https://w3c.github.io/geolocation-api/#dom-geolocation-getcurrentposition"><span class="koboSpan" id="kobo.743.1">https://w3c.github.io/geolocation-api/#dom-geolocation-getcurrentposition</span></a><span class="koboSpan" id="kobo.744.1">) in order to have our mock match the </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">expected behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.746.1">We’re providing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">successCallback</span></strong><span class="koboSpan" id="kobo.748.1"> function, which returns coordinates just as the browser API would, and we’re immediately</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.749.1"> invoking it to simulate a user granting access to the </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">geolocation data.</span></span></p>
<p><span class="koboSpan" id="kobo.751.1">Having a successful resolution, we can assert that the component received the sa</span><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.752.1">me </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">coords</span></strong><span class="koboSpan" id="kobo.754.1">  object that came from </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">the browser.</span></span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.756.1">Unhappy path</span></h2>
<p><span class="koboSpan" id="kobo.757.1">Having tested a successful resolution, the</span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.758.1"> last thing to test is what would happen if the user declined access to the location data. </span><span class="koboSpan" id="kobo.758.2">We will use a very similar approach, but instead of the successful callback, we will provide a secondary callback for failure. </span><span class="koboSpan" id="kobo.758.3">Again, this is according to </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">the specification:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.760.1">
it("displays a message when user denied access", async (): Promise&lt;void&gt; =&gt; {  const mockGeoLocation = vi.fn((successCallback: Function, errorCallback: Function) =&gt; {
    const error = new Error("User denied geolocation access");
    errorCallback(error);
  });
  global.navigator.geolocation = {
    getCurrentPosition: mockGeoLocation,
  };
  const wrapper = await shallowMount&lt;GetLocation&gt;(GetLocation);
  expect(wrapper.vm.geolocationBlockedByUser).toEqual(true);
  expect(wrapper.html()).toContain("User denied access");
});</span></pre>
<p><span class="koboSpan" id="kobo.761.1">As you can see, in this case, we’re completely ignoring </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">successCallback</span></strong><span class="koboSpan" id="kobo.763.1"> and instead defining and invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">errorCallback</span></strong><span class="koboSpan" id="kobo.765.1">. </span><span class="koboSpan" id="kobo.765.2">As the component dictates, the reactive </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">geolocationBlockedByUser</span></strong><span class="koboSpan" id="kobo.767.1"> property will be set to true and we will show an </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">error message.</span></span></p>
<p><span class="koboSpan" id="kobo.769.1">The complete test file now</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.770.1"> looks like this, where we assert that the component renders, and it can resolve a successful query and handle a </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">denied request:</span></span></p>
<p><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/03.weather/.notes/2.1-GetLocation.spec.ts"><span class="No-Break"><span class="koboSpan" id="kobo.772.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/03.weather/.notes/2.1-GetLocation.spec.ts</span></span></a></p>
<p><span class="koboSpan" id="kobo.773.1">We’ve made sure we’ve tested both the happy and the unhappy path. </span><span class="koboSpan" id="kobo.773.2">Let’s see how we can apply testing to components dealing with external data from </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">an endpoint.</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.775.1">Testing with APIs</span></h2>
<p><span class="koboSpan" id="kobo.776.1">Our final component </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.777.1">also has an external dependency. </span><span class="koboSpan" id="kobo.777.2">This is not much different from mocking a browser API, as we will discover in this section. </span><span class="koboSpan" id="kobo.777.3">If we look at our component, it has the following features: shows the loading state when no data is retrieved and displays the response from the service in a nicely </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">formatted way.</span></span></p>
<p><span class="koboSpan" id="kobo.779.1">Let’s start with assessing that the component can render in a file </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">WeatherRepost.spec.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.783.1">
import { shallowMount } from '@vue/test-utils'import WeatherReport from './WeatherReport.vue'
describe('WeatherReport', () =&gt; {
  it("should render the component without crashing", (): void =&gt; {
    global.fetch = vi.fn() as any
    const wrapper = shallowMount&lt;WeatherReport&gt;(WeatherReport, {
        props: {
            coords: {
                latitude: 0,
                longitude: 0
            }
        }
    });
    expect(wrapper).toBeTruthy();
  });
});</span></pre>
<p><span class="koboSpan" id="kobo.784.1">In this case, you see that instead of mocking a </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">navigator</span></strong><span class="koboSpan" id="kobo.786.1"> property, we’re mocking a global </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">fetch</span></strong><span class="koboSpan" id="kobo.788.1"> property. </span><span class="koboSpan" id="kobo.788.2">We don’t need to return anything, so we’re keeping this test as simple </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.790.1">On to testing the loading</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.791.1"> state. </span><span class="koboSpan" id="kobo.791.2">In fact, we’re actually cheating a little bit here. </span><span class="koboSpan" id="kobo.791.3">There is simply a state of not having data or having data. </span><span class="koboSpan" id="kobo.791.4">We’re treating not having data as a loading state for the sake </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">of simplicity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.793.1">
it('displays loading message when data is undefined', (): void =&gt; {  global.fetch = vi.fn(() =&gt; Promise.resolve({
    json: () =&gt; Promise.resolve()
  })) as any
  const wrapper = shallowMount(WeatherReport, {
    props: {
      coords: {
        latitude: 0,
        longitude: 0
      }
    }
  });
  expect(wrapper.text()).toContain('Loading...')
});</span></pre>
<p><span class="koboSpan" id="kobo.794.1">For this test, we’re just resolving the data as nothing. </span><span class="koboSpan" id="kobo.794.2">That means there’s no data available to render, which will keep the component in its loading state. </span><span class="koboSpan" id="kobo.794.3">We can assert that without data, the </span><strong class="bold"><span class="koboSpan" id="kobo.795.1">Loading…</span></strong><span class="koboSpan" id="kobo.796.1"> text </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">stays visible.</span></span></p>
<p><span class="koboSpan" id="kobo.798.1">We can also assert the situation when we did receive data from the service. </span><span class="koboSpan" id="kobo.798.2">This involves a similar approach, with </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.799.1">the difference that instead of resolving nothing, we resolve with a mock </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">weather report:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.801.1">
it('displays weather data when data is defined', async () =&gt; {  const mockData = {
    // ...abbreviated
  }
   global.fetch = vi.fn(() =&gt; Promise.resolve({
    json: () =&gt; Promise.resolve(mockData)
  })) as any
  const wrapper = shallowMount(WeatherReport, {
    props: {
      coords: {
        latitude: 0,
        longitude: 0
      }
    }
  })
  expect(wrapper.text()).toContain(mockData.current.condition.text)
  expect(wrapper.text()).toContain(mockData.current.temp_c)
  expect(wrapper.text()).toContain(mockData.location.name)
  expect(wrapper.text()).toContain(mockData.location.region)
  expect(wrapper.text()).toContain(mockData.current.wind_kph)
  expect(wrapper.text()).toContain(mockData.current.wind_degree)
});</span></pre>
<p><span class="koboSpan" id="kobo.802.1">We assert that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">mockData</span></strong><span class="koboSpan" id="kobo.804.1"> properties are being mapped to the wrapper. </span><span class="koboSpan" id="kobo.804.2">There is a problem, though: the assertions are failing! </span><span class="koboSpan" id="kobo.804.3">We have two problems, in fact. </span><span class="koboSpan" id="kobo.804.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">shallowMount</span></strong><span class="koboSpan" id="kobo.806.1"> function is flattening the HTML structure a bit and we have to wait for the promises to </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">be resolved.</span></span></p>
<p><span class="koboSpan" id="kobo.808.1">Luckily, Vue Test Utils has a useful utility for dealing with the promises: </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">flushPromises</span></strong><span class="koboSpan" id="kobo.810.1"> is a utility</span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.811.1"> function that makes sure all pending promises are resolved. </span><span class="koboSpan" id="kobo.811.2">We can import it at the top of our file together with our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">mount</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.813.1"> functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.814.1">
import { </span><strong class="bold"><span class="koboSpan" id="kobo.815.1">mount</span></strong><span class="koboSpan" id="kobo.816.1">, shallowMount, </span><strong class="bold"><span class="koboSpan" id="kobo.817.1">flushPromises</span></strong><span class="koboSpan" id="kobo.818.1"> } from '@vue/test-utils'</span></pre> <p><span class="koboSpan" id="kobo.819.1">If we rerun our test, it </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">will succeed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.821.1">
it('displays weather data when data is defined', async () =&gt; {  const mockData = {
// abbreviated
  }
  global.fetch = vi.fn(() =&gt; Promise.resolve({
    json: () =&gt; Promise.resolve(mockData)
  })) as any
  const wrapper = </span><strong class="bold"><span class="koboSpan" id="kobo.822.1">mount</span></strong><span class="koboSpan" id="kobo.823.1">(WeatherReport, {
    props: {
      coords: {
        latitude: 0,
        longitude: 0
      }
    }
  })
 </span><strong class="bold"><span class="koboSpan" id="kobo.824.1"> await flushPromises();</span></strong><span class="koboSpan" id="kobo.825.1">
  expect(wrapper.text()).toContain(mockData.current.condition.text)
  expect(wrapper.text()).toContain(mockData.current.temp_c)
  expect(wrapper.text()).toContain(mockData.location.name)
  expect(wrapper.text()).toContain(mockData.location.region)
  expect(wrapper.text()).toContain(mockData.current.wind_kph)
  expect(wrapper.text()).toContain(mockData.current.wind_degree)
});</span></pre>
<p><span class="koboSpan" id="kobo.826.1">There’s one final check since </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.827.1">we have a formatter for our timestamp. </span><span class="koboSpan" id="kobo.827.2">Let’s add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">data-testid</span></strong><span class="koboSpan" id="kobo.829.1"> attribute to </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">the element:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.831.1">
&lt;p </span><strong class="bold"><span class="koboSpan" id="kobo.832.1">data-testid="localtime"</span></strong><span class="koboSpan" id="kobo.833.1">&gt;{{ formatDate(data.location.localtime) }}&lt;/p&gt;</span></pre> <p><span class="koboSpan" id="kobo.834.1">For testing purposes, we can simplify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">mockData</span></strong><span class="koboSpan" id="kobo.836.1"> object because we are only interested in one</span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.837.1"> property (and not crashing </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">the component):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.839.1">
it('displays formats the datetime to a locale format', async () =&gt; {  const mockData = {
    location: {
      localtime: new Date(),
    },
    current: {
      condition: {},
    }
  }
  global.fetch = vi.fn(() =&gt; Promise.resolve({
    json: () =&gt; Promise.resolve(mockData)
  })) as any
  const wrapper = mount(WeatherReport, {
    props: {
      coords: {
        latitude: 0,
        longitude: 0
      }
    }
  })
  await flushPromises();
  const localtime = wrapper.find("[data-testid=localtime]");
  expect(localtime.text()).toEqual('January 31, 2001 at 11:45 AM')
});</span></pre>
<p><span class="koboSpan" id="kobo.840.1">Now this will only succeed once because the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">Date()</span></strong><span class="koboSpan" id="kobo.842.1"> function will constantly be refreshed with the date and time of executing the test! </span><span class="koboSpan" id="kobo.842.2">Again, we have an external factor that we need to </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.843.1">mock in order to isolate </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">our test.</span></span></p>
<p><span class="koboSpan" id="kobo.845.1">Vitest offers tooling to manipulate dates, times, and even the passing of timers (</span><a href="https://vitest.dev/api/vi.html#vi-setsystemtime"><span class="koboSpan" id="kobo.846.1">https://vitest.dev/api/vi.html#vi-setsystemtime</span></a><span class="koboSpan" id="kobo.847.1">). </span><span class="koboSpan" id="kobo.847.2">We can modify our test so that the test always assumes the exact same date and time. </span><span class="koboSpan" id="kobo.847.3">This way, we can assert the outcome based on a </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">fixed value.</span></span></p>
<p><span class="koboSpan" id="kobo.849.1">The updated version will look </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.851.1">
it('displays formats the datetime to a locale format', async () =&gt; {</span><strong class="bold"><span class="koboSpan" id="kobo.852.1">  const mockDateTime = new Date(2000, 12, 31, 11, 45, 0, 0)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.853.1">  vi.setSystemTime(mockDateTime)</span></strong><span class="koboSpan" id="kobo.854.1">
  const mockData = {
    location: {
      localtime: new Date(),
    },
    current: {
      condition: {},
    }
  }
  global.fetch = vi.fn(() =&gt; Promise.resolve({
    json: () =&gt; Promise.resolve(mockData)
  })) as any
  const wrapper = mount(WeatherReport, {
    props: {
      coords: {
        latitude: 0,
        longitude: 0
      }
    }
  })
  await flushPromises();
  const localtime = wrapper.find("[data-testid=localtime]");
  expect(localtime.text()).toEqual('January 31, 2001 at 11:45 AM')
</span><strong class="bold"><span class="koboSpan" id="kobo.855.1">  vi.useRealTimers()</span></strong><span class="koboSpan" id="kobo.856.1">
});</span></pre>
<p><span class="koboSpan" id="kobo.857.1">This makes it safe to assert the date based on a static value. </span><span class="koboSpan" id="kobo.857.2">I tend to pick my date and time values in such a way </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.858.1">that months, days, hours, and minu</span><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.859.1">tes are easily identifiable regardless of </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">the notation.</span></span></p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.861.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.862.1">At this point, we’ve added a bit more complexity to our app, any external resource calls for additional error handling, and we’ve learned how to deal with asynchronous data using a loading state. </span><span class="koboSpan" id="kobo.862.2">We’ve been able to quickly style our app using the utility style CSS framework Tailwind. </span><span class="koboSpan" id="kobo.862.3">With the unit test, we’ve made sure that we can assert that our application’s core features will continue to work as expected or alarm us if the output changes in </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">any way.</span></span></p>
<p><span class="koboSpan" id="kobo.864.1">In the next chapter, we’ll focus on connecting more extensively with a third-party API, by combining multiple endpoints from an API into a </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">single app.</span></span></p>
</div>
</body></html>