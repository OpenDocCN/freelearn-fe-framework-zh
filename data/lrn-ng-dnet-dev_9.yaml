- en: Chapter 9. What s New in Angular and ASP.NET Core
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章. Angular 和 ASP.NET Core 中的新功能
- en: We started this book with a discussion on Angular, building a hello world application,
    and the core architecture of Angular. Then, we dived into the building blocks
    of Angular. Next, we discussed the basics of TypeScript and how to use TypeScript
    in writing Angular applications. Later, we walked through creating an Angular
    single-page application in Visual Studio and learned about RESTful services and
    creating a RESTful service using Web API for Angular applications. After that,
    we did a complete step-by-step walk-through on creating an application using Angular,
    ASP.NET MVC, and Web API in Visual Studio. Finally, we learned about testing Angular
    applications using Karma and Jasmine.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从讨论 Angular、构建一个 Hello World 应用程序和 Angular 的核心架构开始了本书。然后，我们深入了解了 Angular 的构建块。接下来，我们讨论了
    TypeScript 的基础知识以及如何在编写 Angular 应用程序时使用 TypeScript。之后，我们在 Visual Studio 中逐步创建了一个
    Angular 单页面应用，并学习了 RESTful 服务以及如何使用 Web API 为 Angular 应用创建 RESTful 服务。之后，我们通过使用
    Angular、ASP.NET MVC 和 Web API 在 Visual Studio 中逐步创建了一个应用程序。最后，我们学习了如何使用 Karma
    和 Jasmine 测试 Angular 应用。
- en: 'This chapter will discuss what is new in Angular and ASP.NET Core. We will
    cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论 Angular 和 ASP.NET Core 中的新功能。我们将涵盖以下话题：
- en: Ahead-of-Time compilation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预编译
- en: Update on Templates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板更新
- en: Introducing titlecase pipes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入标题大小写管道
- en: Simplified parameter passing in HTTP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化 HTTP 参数传递
- en: Overriding templates in testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试中覆盖模板
- en: Introducing the Meta service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Meta 服务的引入
- en: New form validators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的表单验证器
- en: Introducing ParamMap in a router
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由器中引入 ParamMap
- en: Introducing .NET Core 1.0
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入 .NET Core 1.0
- en: Cross-platform development with the .NET Execution Environment
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 执行环境下的跨平台开发
- en: What's new in Angular
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 的新功能
- en: '* * *'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'The Angular team has dropped Angular 3 and proceeded with Angular 4 as they
    have decided to follow semantic versioning. This helps standardize the version
    for major, minor, and patch releases. The semantic version will have three segments
    in the version numbering. Any breaking change in syntax or concept will be considered
    as major and the first segment version number will be incremented. Any new features
    added will be considered as minor and the second segment version number will be
    incremented, and for any bug fixes, the third segment version number will be incremented,
    considering them as patch:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 团队已经放弃了 Angular 3，并决定遵循语义化版本控制推进Angular 4。这有助于标准化主要、次要和补丁版本的版本号。语义化版本控制的版本号将分为三个段。在语法或概念上的任何破坏性变化将被视为主要，第一个段的版本号将会递增。任何新增功能都将被视为次要，第二个段的版本号将会递增，并且对于任何bug修复，第三个段的版本号会递增，视它们为补丁：
- en: '![](img/image_09_001.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_001.png)'
- en: 'Fig 01: Semantic versioning'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图01：语义化版本控制
- en: Ahead-of-Time compilation
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预编译
- en: Angular introduces a major change that generates JavaScript code when building
    your application. This enables you to know whether there are any errors in templates
    when building rather than being notified at runtime. Also, it enables the application
    to run faster as the code generation has already been completed during the build
    phase. The new Angular view engine generates less code when using **Ahead**-**of**-**Time**
    (**AoT**).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 引入了一个重大改变，即在构建应用程序时生成 JavaScript 代码。这样可以在构建时了解模板中是否存在任何错误，而不是在运行时被通知。此外，它还可以让应用程序运行得更快，因为在构建阶段已经完成了代码生成。新的
    Angular 视图引擎在使用 **预编译**（**AoT**）时生成更少的代码。
- en: Update on templates
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板更新
- en: 'As the template is a real HTML tag for the web component, Angular introduced
    a new `ng-template` tag for templates. Angular enabled us to use `else` in `ngIf`
    in templates, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模板是 Web 组件的真实 HTML 标签，Angular 引入了一个新的 `ng-template` 标签来作为模板。Angular 允许我们在模板中使用
    `ngIf` 的 `else`，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, if `isOld` is true, the content of the old template will be displayed.
    Otherwise, the content of the new template will be displayed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `isOld` 为 true，则会显示旧模板的内容。否则，将显示新模板的内容。
- en: 'Next, let''s discuss the `as` keyword added to the template syntax. It is introduced
    to simplify the syntax of `let`. It enables us to store the results in a template
    variable:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们讨论模板语法中新增的 `as` 关键字。它被引入以简化 `let` 的语法，使我们能够将结果存储在模板变量中：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we used the `as` keyword to store the result of slice in the `topTenBooks`
    variable and further referenced it in theÂ `li` tag. Note that we also gave an
    alias name, `i`, to index, which is the short form of the `let i = index` syntax.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`as`关键字来将切片的结果存储在`topTenBooks`变量中，并在`li`标签中进一步引用它。请注意，我们还给了一个别名`i`，用于索引，这是`let
    i = index`语法的简写。
- en: 'We can also use the `as` keyword and `async` together, as shown:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将`as`关键字和`async`一起使用，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we have made our `books` collection as Observable. So, we have iterated
    through the array of books returned from Observable. Note that we also display
    the number of books returned from the Observable. However, this leads to a performance
    overhead as the async pipe used will rerun if there are changes. Further improvement,
    as follows, avoids such performance overhead:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的`books`集合作为Observable。因此，我们已经遍历了从Observable返回的书籍数组。请注意，我们还显示了从Observable返回的书籍数量。然而，这会导致性能开销，因为使用的异步管道会在发生更改时重新运行。以下是进一步的改进，避免了这种性能开销：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we used the `as` keyword to store a piped value in a parent component.
    Note that we used async only once.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`as`关键字来在父组件中存储管道值。请注意，我们仅使用了一次async。
- en: Introducing titlecase pipes
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍titlecase管道
- en: 'A titlecase pipe changes the first letter of a word to uppercase. We can use
    titlecase as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: titlecase管道将单词的第一个字母变为大写。我们可以如下使用titlecase：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Simplified parameter passing inÂ HTTP
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在HTTP中简化参数传递
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Overriding templates in testing
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在测试中重写模板
- en: 'Sometimes it is necessary to override templates during testing. Angular has
    now simplified overriding templates, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在测试期间需要重写模板。Angular现在简化了重写模板，如下所示：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before that, we need to build JSON and pass it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之前，我们需要构建JSON并传递它。
- en: Introducing the Meta service
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Meta服务
- en: '* * *'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Angular has introduced a new service called the Meta service that simplifies
    updating or getting the `meta` tags:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Angular引入了一个名为Meta服务的新服务，简化了更新或获取`meta`标签：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: New form validators
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的表单验证器
- en: 'New validator combines the existing validators such as `required`, `minLength`,
    `maxLength`, `email`, and `pattern`. Also, a new directive, `compareWith`, is
    introduced to compare options from a `select` control, as shown:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 新的验证器结合了现有的验证器，如`required`，`minLength`，`maxLength`，`email`和`pattern`。还介绍了一个新的指令`compareWith`，用于比较`select`控件中的选项，如下所示：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Introducing ParamMap in router
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍路由中的ParamMap
- en: 'Angular has introduced a new interface, `ParamMap`, to map the parameters in
    a URL. We can use `paramMap` or `queryParamMap` to access parameters of a URL.
    `ParamMap` has methods such as `get()` to get a value or `getAll()` to get all
    the values of the query parameters, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Angular引入了一个新的接口ParamMap，用于映射URL中的参数。我们可以使用`paramMap`或`queryParamMap`来访问URL的参数。`ParamMap`具有诸如`get()`获取值或`getAll()`获取所有查询参数值的方法，如下所示：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In an observable, we need to use `ParamMap` as illustrated:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在observable中，我们需要像下面这样使用`ParamMap`进行说明：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Introducing .NET Core 1.0
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍.NET Core 1.0
- en: '* * *'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: In this section, we will cover the basics of .NET Core 1.0 as a platform and
    the components involved in it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍.NET Core 1.0作为一个平台的基础知识以及其中涉及的组件。
- en: The .NET Core 1.0 platform was reinvented for various reasons. The web stack
    of ASP.NET was pretty old and was started back in .NET Framework 1.0\. ASP.NET
    was overweighed with a lot of old and unused code. Even the code it not used as
    it becomes unavoidable from loading them. The biggest one is `System.Web`, which
    is a linkage between the old ASP.NET and today's ASP.NET. MVC and Web API are
    trying to isolate themselves from `System.Web`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 1.0平台出于各种原因进行了改进。ASP.NET的Web堆栈非常古老，始于.NET Framework 1.0。ASP.NET存在大量古老和未使用的代码。即使代码不被使用，也难以避免加载它们。最大的问题是`System.Web`，它是老式ASP.NET和现在的ASP.NET之间的连接。MVC和Web
    API正在试图与`System.Web`隔离。
- en: Self-hosting of ASP.NET, MVC, and Web API is one of the objectives so that they
    can be hosted independently of the server platform. However, it was tied to the
    Windows platform on IIS. This becomes an issue when an application needs to be
    retested for any new bugs that were introduced due to the newer version of .NET
    when updated to servers as these depend on machine-level versions of .NET, and
    it is not possible to isolate the version of .NET from your application so that
    it can run independently of the newer version of .NET.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET、MVC 和 Web API 的自托管是其中一个目标，使它们能够独立于服务器平台进行托管。然而，它一直与 IIS 这个 Windows 平台绑定。当应用程序需要在更新到服务器时重新测试任何由于更新至新的.NET版本而引入的新
    bug 时，这就成了一个问题，因为它们依赖于机器级的.NET版本，所以没有办法将.NET版本与应用程序隔离开来，使其能够独立于新的.NET版本运行。
- en: The ASP.NET team had decided to rewrite the code from the ground up as the time
    frame was vulnerable by the amount of code that had to be loaded in, compiled,
    written to disk, loaded back into memory, and then executed. For good, a lot of
    things have been changed in .NET Core 1.0, and it is incredibly different from
    every other version of ASP.NET. That's why it is good to call it with a new name
    and new version as it is not an incremental change.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于必须加载大量代码、编译、写入磁盘、重新加载到内存中并执行，ASP.NET 团队决定从头开始重写代码，因为时间跨度受到了系统性能的影响。在 .NET
    Core 1.0 中，有很多事情发生了变化，它与任何其他版本的 ASP.NET 都有很大差异。这就是为什么给它起一个新的名字和新的版本号是合适的，因为它并不是一种渐进式的变化。
- en: A key difference is that .NET Core 1.0 is cross-platform and open source. .NET
    Core 1.0 is a single platform that combines both the concepts of MVC and Web API
    into one solid set of APIs and all the legacy code is gone. Everything is a dependency
    in .NET Core 1.0\. We can develop a .NET application as small as we want it to
    be. Some parts of .NET Core are now a NuGet. So, you can load only the required
    assemblies from NuGet, and this leads to a small memory footprint compared to
    the previous versions of ASP.NET.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键的区别是，.NET Core 1.0 是跨平台和开源的。.NET Core 1.0 是一个单一平台，将 MVC 和 Web API 的概念结合为一个坚实的
    API 集，并且所有的遗留代码都消失了。在.NET Core 1.0 中一切都是一个依赖项。我们可以以我们想要的任何大小开发一个.NET应用程序。.NET
    Core 的某些部分现在是一个 NuGet。因此，你可以从 NuGet 中仅加载所需的程序集，与之前版本的 ASP.NET 相比，这会导致内存占用更小。
- en: 'Multiple deployment support is possible today in .NET Core 1.0, and this enables
    us to deploy to clouds, such as Azure, AWS, and other cloud services. You can
    host it in IIS, or it can be self-hosted, which enables us to execute from the
    command line. .NET Core 1.0 supports true cross-platform, and it can be hosted
    on both Windows and OSX or Linux:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET Core 1.0 中今天可以实现多个部署支持，这使我们能够部署到 Azure、AWS 和其他云服务中。你可以在 IIS 中进行托管，或者可以进行自托管，这使我们可以从命令行执行。.NET
    Core 1.0 支持真正的跨平台，并且可以在 Windows 和 OSX 或 Linux 上进行托管：
- en: '![](img/image_09_002.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_002.png)'
- en: 'Fig 02: Building blocks of ASP.NET Core 1.0'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图02：ASP.NET Core 1.0 的构建模块
- en: As shown in the preceding figure, .NET Core includes a new CLR that is supported
    on both OSX/Linux and Windows. ASP.NET can also run on top of Mono. Using the
    native IIS loader, we can load and host our applications in IIS. This native IIS
    loader routes requests directly to ASP.NET without the need to go through ISAPI
    filters and others. On the Windows platform, you can also self-host the application
    from the command line using a tool called `dotnet.exe`. .NET Core 1.0 also supports
    self-hosting on Linux and OSX and can be done using some sort of tool, such as
    `dotnet.exe`, so that the application can be run just with a command line.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述图所示，.NET Core 包括一个新的 CLR，在 OSX/Linux 和 Windows 上都得到支持。ASP.NET 也可以在 Mono 上运行。使用原生的
    IIS 加载器，我们可以在 IIS 中加载和托管我们的应用程序。这个原生的 IIS 加载器直接将请求路由到 ASP.NET 而无需经过 ISAPI 过滤器等。在
    Windows 平台上，你还可以使用一个叫做 `dotnet.exe` 的工具从命令行自托管应用程序。.NET Core 1.0 也支持在 Linux 和
    OSX 上进行自托管，并且可以使用某种工具，比如 `dotnet.exe`，让应用程序只需使用命令行就可以运行。
- en: The self-hosted solutions are similar to Node. Running Node and then the root
    of your application is very similar to the way that self-hosting works in .NET
    Core with the `dotnet.exe` tool. So, being cross-platform supported, the code
    you write will not necessarily care about where it's being hosted.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 自托管解决方案与 Node 很相似。在 Node 中运行，并且应用程序的根目录与 .NET Core 中的 `dotnet.exe` 工具的自托管方式非常相似。因此，跨平台支持，你编写的代码并不一定关心它在哪里被托管。
- en: .NET Core is the new cross-platform and a subset of the .NET Framework. The
    .NET Core is meant to be as small as possible. The CoreCLR or .NET Core Framework
    is a subset of the .NET Framework. So, all functionalities will not be available
    in .NET Core. For example, sending a mail is achieved by the mail subsystem inside
    the .NET Framework in the System.Net namespace. However, this functionality doesn't
    exist, and it can be accomplished using some open source solutions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core是新的跨平台.NET Framework的子集。.NET Core旨在尽可能小。CoreCLR或.NET Core Framework是.NET
    Framework的子集。因此，.NET Core中并不是所有功能都可用。例如，通过System.Net命名空间中的.NET Framework内的邮件子系统来发送邮件。但是，这个功能并不存在，可以使用一些开源解决方案来实现。
- en: The .NET Core team wanted to compose everything via NuGet packages. So, everything
    precedingÂ the CLR and C# and VB compilers is a NuGet package. The .NET Core 1.0
    is really the bootstrap and the CLR is not a whole. The code knows how to load
    up an application and get it started, and then the CLR actually manages the execution
    of that code. Everything else will be a NuGet package. MVC looks at static files
    doing logging, configuration, and identity; they're all just packages that can
    be added to a project. So, as you talk about creating thicker or thinner applications,
    you can make decisions about what to include in your project. Everything in ASP.NET
    is optional.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core团队希望通过NuGet packages来构建所有东西。因此，CLR以及C#和VB编译器之前的一切都是NuGet包。.NET Core
    1.0实际上是引导，CLR并不完整。代码知道如何加载应用程序并启动它，然后CLR实际上管理该代码的执行。其他一切都将是NuGet包。MVC查看静态文件进行日志记录、配置和身份验证；它们只是可以添加到项目的软件包。因此，在讨论创建厚或薄应用程序时，您可以决定在项目中包含什么。在ASP.NET中的所有内容都是可选的。
- en: The ASP.NET 5 team has tried to embrace the Node package manager for different
    sorts of tooling support, using npm or Bower for client-side library support,
    using Grunt and Gulp for build automation, and NuGet for .NET packages.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET 5团队已尝试采用Node包管理器，用于不同类型的工具支持，使用npm或Bower支持客户端库，使用Grunt和Gulp进行构建自动化，并使用NuGet进行.NET包支持。
- en: Cross-platform development with the .NET Execution Environment
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用.NET Execution Environment进行跨平台开发
- en: '* * *'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: In this section, we will discuss what the roles of the full .NET Framework,
    the Core CLR, and the DNX are. We will start by explaining how the .NET Framework
    developers have usedÂ the Execution Environment since the beginning of .NET. Also,
    we will see Mono and .NET Core. Then, we will see some guidelines to decide which
    framework to use. Finally, we will see how the DNX binds everything together.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论完整.NET框架、Core CLR和DNX的角色。我们将首先解释.NET框架开发人员如何自.NET开始就使用了执行环境。此外，我们将看到Mono和.NET
    Core。然后，我们将看到一些决定使用哪个框架的准则。最后，我们将看到DNX如何将一切绑在一起。
- en: The traditional .NET Framework
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传统的.NET Framework
- en: Since the beginnings of .NET, the desktop and console applications have been
    bootstrapped by executable files and the traditional ASP.NET applications are
    bootstrapped by IIS using an ISAPI DLL. The applications written in any language
    supported by .NET are compiled to an assembly. An assembly is an EXE or DLL file
    containing **Intermediate Language** (**IL**). This IL file needs to be compiled
    to native code as the operating systems and CPUs don't understand IL, and this
    is called **just-in-time** (**JIT**) compiling.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 自.NET开始以来，桌面和控制台应用程序已由可执行文件进行引导，传统的ASP.NET应用程序则通过IIS使用ISAPI DLL进行引导。在.NET支持的任何语言中编写的应用程序都会被编译为程序集。程序集是包含**中间语言**（**IL**）的EXE或DLL文件。由于操作系统和CPU不理解IL，因此需要将此IL文件编译为本机代码，这称为**即时**（**JIT**）编译。
- en: JIT compiles the IL code to native code just before it executes on the machine
    where the assemblies are deployed. The JIT functionality is part of the .NET CLR
    or common language runtime.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JIT在部署程序集的机器上执行之前，将IL代码编译为本机代码。JIT功能是.NET CLR或公共语言运行时的一部分。
- en: The CLR is responsible for loading assemblies, checking types, and garbage collection.
    So, it is necessary to install the .NET Framework on the machine application runs.
    The big stack of classes and other types are available. It contains all types
    needed for Windows Forms, WCF, WPF, web forms, and types usable across these frameworks,
    such as file handling, reading, and manipulating XML, drawing, and cryptography.
    All applications use some of these classes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: CLR负责加载程序集、检查类型和垃圾回收。因此，在应用程序运行的机器上安装.NET Framework是必要的。大量的类和其他类型可用。它包含了所有Windows
    Forms、WCF、WPF、web forms所需的类型，以及在这些框架中可用的类型，例如文件处理、读取和操作XML、绘图和密码。所有应用程序都使用其中的一些类。
- en: 'The CLR is specifically designed to run on Windows. Also, some of the classes
    in the FCL are specifically for Windows. `System.web` is an assembly containing
    classes that are tied to IIS and therefore Windows. building blocks of legacy
    .NET Framework are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: CLR专门设计用于在Windows上运行。此外，FCL中的一些类专为Windows设计。`System.web`是一个包含与IIS和因此Windows相关联的类的程序集。传统.NET
    Framework的构建模块包括以下内容：
- en: '![](img/image_09_003.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_003.png)'
- en: 'Fig 03: Building blocks of legacy .NET Framework'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图03：传统.NET Framework的构建模块
- en: Mono Cross-platform .NET Framework
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mono跨平台.NET Framework
- en: Mono is an open source version of the .NET Framework developed by the community.
    It uses the exact same principles that Microsoft .NET Framework uses. It's compatible
    with the Microsoft .NET Framework. Even if you don't use ASP.NET 5, you can create
    assemblies on a Windows machine using the Microsoft .NET Framework and Visual
    Studio and run them on Mono on a Linux machine. So, an important difference with
    Microsoft .NET Framework is that it is cross-platform. Versions are available
    for Windows, macOS, and Linux. It's also used as the basis for Xamarin, which
    runs .NET on Android and iOS.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Mono是由社区开发的.NET Framework的开源版本。它使用了与Microsoft .NET Framework相同的原理。它与Microsoft
    .NET Framework兼容。即使你不使用ASP.NET 5，你也可以在Windows机器上使用Microsoft .NET Framework和Visual
    Studio创建程序集，然后在Linux机器上使用Mono运行它们。所以，与Microsoft .NET Framework的一个重要区别是它是跨平台的。版本适用于Windows、macOS和Linux。它还被用作Xamarin的基础，该基础在Android和iOS上运行.NET。
- en: NuGet package manager
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NuGet软件包管理器
- en: Microsoft has introduced NuGet to manage packages and download them easily for
    development. NuGet is a central place to get the libraries. Developers of these
    libraries and frameworks can easily apply new versions or bug fixes to NuGet.
    Microsoft began to use NuGet for assemblies that would normally be in the FCL.
    MVC is installed as a NuGet package in the application and not machine-wide like
    the FCL. This enables different applications to use different versions of MVC
    without the need to install different versions of the .NET Framework. Distributing
    MVC via NuGet gave Microsoft the ability to update MVC "out of band" with the
    .NET Framework, which enabled MVC to evolve much faster with more frequent updates.
    This was the upbeat of a completely modular framework class library with .NET
    Core.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft引入了NuGet来管理包并方便地下载它们用于开发。NuGet是获取库的中心位置。这些库和框架的开发人员可以轻松地向NuGet应用新版本或bug修复。Microsoft开始在FCL中通常会出现的程序集中使用NuGet。MVC安装为应用程序中的NuGet包，而不像FCL那样在整个机器上安装。这使不同的应用程序可以使用不同版本的MVC而无需安装不同版本的.NET
    Framework。通过NuGet分发MVC使Microsoft能够在.NET Framework之外"越分频"地更新MVC，从而使MVC能够更快地演进并得到更频繁的更新。这是一个完全模块化的框架类库与.NET
    Core的乐观预示。
- en: CoreFx and CoreCLR in .NET Core
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET Core中的CoreFx和CoreCLR
- en: Through the years, .NET has been reinvented multiple times. There is a .NET
    Framework for Windows Desktop, Windows Store apps, and Windows Phone. We also
    have the framework we used all along for ASP.NET 4 and earlier apps. Microsoft
    invented a way to share code between all the different platforms with portable
    class libraries and with the concept of universal apps. However, wouldn't it be
    a lot easier if we had a version of .NET for all platforms? Not only for Microsoft
    that has to keep all these stacks up to date, but also for us developers who have
    to learn and maintain all these versions. The purpose of .NET Core is to be the
    one .NET version that rules them all, and it all starts with ASP.NET! Another
    motivation for .NET Core is the need to reduce the overall footprint. From an
    ASP.NET perspective, using `system.web` isn't really an option anymore. Also,
    having a huge .NET Framework on a machine that causes versioning problems and
    contains lots of stuff you don't need is cumbersome. In this cloud-driven world,
    being fixed to Windows isn't of this time anymore. The most exciting feature of
    .NET Core is that it can run across operating systems using a new DNX.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，.NET已经被重新发明多次。有一个用于Windows桌面、Windows商店应用和Windows Phone的.NET Framework。我们还有一个我们一直用于ASP.NET
    4和更早版本应用的框架。微软发明了一种方法，可以使用可移植类库和通用应用概念在所有不同平台之间共享代码。然而，如果我们有一个所有平台通用的.NET版本，那不是更容易吗？不仅对于微软来说，要保持所有这些堆栈更新，而且对于我们这些必须学习和维护所有这些版本的开发者来说也是如此。.NET
    Core的目的是成为统治所有版本的唯一.NET版本，这一切都始于ASP.NET！.NET Core的另一个动机是减少总体占用空间。从ASP.NET的角度来看，使用`system.web`实际上已经不再是一个选项。此外，在一台机器上拥有一个庞大的.NET
    Framework，导致版本问题并包含许多不需要的东西是很麻烦的。在这个以云为驱动的世界里，被固定在Windows上已经不合时宜。.NET Core最激动人心的功能是它可以使用新的DNX跨操作系统运行。
- en: 'Just like the full .NET Framework, .NET Core also consists of two parts: a
    common language runtime, which is now portable and goes by the name CoreCLR, and
    a class library called CoreFX. CoreFX contains a set of types common across every
    .NET application. It doesn''t include complete frameworks such as WPF or web forms
    like the FCL in the full .NET Framework. There are, for example, classes to manipulate
    files and classes that are collections like a list. The different assemblies of
    CoreFX are individually distributed via NuGet. You have to get everything else
    you need outside of CoreFX, such as the MVC framework, from NuGet. Not only is
    CoreFX distributed in a NuGet package, the CoreCLR is as well. The .NET Core is
    what Microsoft calls cloud optimized. That basically means that it''s lightweight.
    It is not only much smaller than the full .NET Framework, it also contains optimizations:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像完整的.NET Framework一样，.NET Core也由两部分组成：一个是普通语言运行时，现在是可移植的，名为CoreCLR，另一个是称为CoreFX的类库。CoreFX包含一组类型，这些类型是所有.NET应用程序通用的。它不包括像完整的.NET
    Framework中的FCL那样的完整的框架，比如WPF或Web forms。例如，它包含用于操作文件的类和类似列表的集合类。CoreFX的不同程序集都是通过NuGet单独分发的。除了CoreFX之外，你还需要从NuGet中获取其他所需的一切，比如MVC框架。不仅CoreFX以NuGet包的形式分发，CoreCLR也是如此。.NET
    Core是微软所谓的云优化的。这基本上意味着它很轻量级。它不仅比完整的.NET Framework小得多，而且包含了一些优化：
- en: '![](img/image_09_004.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_004.png)'
- en: 'Fig 04: Building blocks of .NET Core'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '图 04: .NET Core 的构建模块'
- en: 'Just like any NuGet package, .NET Core can be restored from NuGet per project.
    When you publish your app to a server, you can also publish the CoreCLR with your
    app. So, there is no machine-wide installation necessary anymore. Each app on
    the server can have its own .NET Core version without affecting other applications.
    It''s also great that the .NET Core as well as the DNX are open source software.
    This means that besides Microsoft, the community is working on it, and you can
    also work on it. It also ensures that the projects will be continued should Microsoft
    decide to cease working on them:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何NuGet包一样，.NET Core可以在每个项目中从NuGet中恢复。当你将应用程序发布到服务器时，你还可以将CoreCLR与你的应用程序一起发布。因此，不再需要进行机器范围的安装。服务器上的每个应用程序都可以具有自己的.NET
    Core版本，而不会影响其他应用程序。.NET Core以及DNX都是开源软件，这意味着除了微软之外，社区也在进行相关工作，而你也可以参与其中。这还确保了如果微软决定停止工作的话，这些项目也会继续进行下去：
- en: '![](img/image_09_005.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_005.png)'
- en: 'Fig 05: .NET applications framework'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '图 05: .NET 应用程序框架'
- en: Choosing a Framework
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择一个框架
- en: How do you make a choice on which framework to use? Where the right version
    of the .NET Framework or Mono has to be installed machine-wide to support your
    app, you can have applications using different versions of .NET Core on one server.
    You can also update one application to use a newer version of .NET Core without
    affecting the others. With the .NET Framework or Mono, you have the best chance
    to use the existing code. It offers a huge selection of classes and other types.
    CoreFX is a different class library, and you will probably have to refactor when
    using the existing code. Also, CoreFX has a much smaller choice of usable types,
    and not everything you're used to is available using extra packages. It is an
    ecosystem that still has to evolve where the FCL is very complete, and it is proven
    technology. However, it contains a lot you probably don't need. Using Mono or
    .NET Core are your choices if your app has to run cross-platform. The .NET Framework
    runs on Windows only. Targeting multiple frameworks makes sense if you're developing
    component libraries for use in your own business or if you want to distribute
    them commercially. Your libraries can be used by applications using all the chosen
    frameworks.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如何选择要使用的框架？在必须全局安装正确版本的.NET Framework或Mono以支持应用程序的计算机上，您可以在一个服务器上开发使用不同版本的.NET
    Core的应用程序。您还可以更新一个应用程序以使用较新版本的.NET Core，而不影响其他应用程序。使用.NET Framework或Mono，您有最好的机会使用现有代码。它提供了大量的类和其他类型。
    CoreFX是一个不同的类库，当使用现有代码时，您可能需要重构。此外，CoreFX具有更少可用类型的选择，并且不是您习惯于使用额外包都可以提供的所有内容。它是一个仍需发展的生态系统，其中FCL非常完整，而且是经过验证的技术。然而，它包含了许多您可能不需要的内容。如果您的应用程序必须跨平台运行，那么使用Mono或.NET
    Core是您的选择。.NET Framework仅在Windows上运行。如果您正在为自己的业务开发组件库，或者想要商业分发它们，那么针对多个框架开发组件库是有意义的。您的库可以被使用所有选择的框架的应用程序所使用。
- en: 'Alternatively, maybe you have to write an app now and decide the framework
    it has to run on later. In the next section, we''ll see the role that DNX plays
    in all this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也许您现在必须编写一个应用程序，以后再决定它必须在哪个框架上运行。在下一节中，我们将看到DNX在所有这些过程中扮演的角色：
- en: '![](img/image_09_006.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_006.png)'
- en: 'Fig 06: Criteria of Choosing the Frameworks'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图06：选择框架的标准
- en: The Dotnet Execution Environment- DNX
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dotnet执行环境- DNX
- en: The primary role of DNX is to run the .NET applications by hosting the CLR in
    the framework. The newly introduced command-line interface dotnet cli has the
    executable part of the DNX. Dotnet cli helps run applications and restore packages
    that are specified in the `project.json`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: DNX的主要作用是通过在框架中托管CLR来运行.NET应用程序。新引入的命令行界面dotnet cli具有DNX的可执行部分。Dotnet cli有助于运行应用程序，并还原`project.json`中指定的包。
- en: The DNX command-line application has its own process to execute an application
    instead of Windows or IIS executing the app; the DNX hosts the CLR instead of
    the operating system. The DNX will look for an entry point in the form of a `Main`
    method and run the application from there. As a separate process runs the app
    and thus there is no dependency on the operating system anymore, the DNX command-line
    application can be developed for multiple operating systems, such as Windows,
    Linux, and macOS. Now, the app you developed in Visual Studio can run cross-platform.
    There is a DNX version available for each .NET Framework per operating system.
    There can also be versions supporting different CPU architectures. For the full
    .NET Framework, for example, there is an x86 version and an x64 version.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: DNX命令行应用程序有自己的处理过程来执行应用程序，而不是Windows或IIS执行应用程序；DNX托管CLR而不是操作系统。DNX将寻找一个`Main`方法形式的入口点并从那里运行应用程序。由于独立进程运行应用程序，因此不再依赖于操作系统，DNX命令行应用程序可以针对多个操作系统开发，如Windows、Linux和macOS。现在，在Visual
    Studio中开发的应用程序可以跨平台运行。对于每个操作系统都有针对相应.NET Framework的DNX版本。也可以有支持不同CPU架构的版本。例如，对于完整的.NET
    Framework，有x86版本和x64版本。
- en: 'Different versions of the DNX can coexist on one machine. You can either install
    them in a central location for the whole machine, or you can choose to make the
    DNX part of the deployment of your application. No machine-wide installation is
    needed at all using that method. If you publish the app in Visual Studio, you
    have to choose for what version of the DNX configured in the framework section
    of the `project.json` you want to publish. That version of the DNX will then be
    distributed with the deployed app:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不同版本的 DNX 可以共存于一台机器上。你可以选择将它们安装在整个机器的中央位置，也可以选择将 DNX 作为应用程序部署的一部分。使用该方法完全不需要进行整机安装。如果你在
    Visual Studio 中发布应用程序，你需要选择在`project.json`的框架部分中配置的 DNX 版本。该版本的 DNX 将随部署的应用程序一起分发：
- en: '![](img/image_09_007.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_007.png)'
- en: 'Fig 07: Building blocks of DNX'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 07：DNX 的构建模块
- en: The DNX is part of dotnet cli that exposes its functionality in the dotnet command-line
    application. When you run a DNX app in Visual Studio, all Visual Studio does is
    to execute a command line. When you run, for example, it will execute `dotnet
    run`, which will put the DNX to work. While running the app, the DNX also supports
    debugging. When you add NuGet packages to the `project.json` file, it will just
    execute `dotnet restore`. Also, there are commands for compiling and publishing
    the app among others. Dotnet cli is just a command given on the command line,
    so it doesn't need Visual Studio to execute. You can execute it directly by just
    typing in the commands or use some other tool to invoke it. An example of such
    a tool is Visual Studio Code, which also runs cross-platform. The `dotnet` command
    will be used in ASP.NET 5 versions RC2 and higher. The different command-line
    applications, such as DNX and DNU, are united in the dotnet command-line. When
    you execute dotnet restore, for example, it will read the `project.json` file
    and download and install packages where needed. So, the DNX is not only a runtime
    environment, it is also an SDK. The runtime part kicks in when you execute `dotnet
    run` in an app's folder.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: DNX 是 dotnet cli 的一部分，它在 dotnet 命令行应用程序中公开其功能。当你在 Visual Studio 中运行一个 DNX 应用程序时，Visual
    Studio 只是执行一个命令行。例如，当你运行时，它将执行`dotnet run`，这将使 DNX 开始工作。在运行应用程序时，DNX 也支持调试。当你向`project.json`文件添加
    NuGet 包时，它只会执行`dotnet restore`。此外，还有一些用于编译和发布应用程序的命令。Dotnet cli 只是在命令行上给出的一个命令，所以不需要使用
    Visual Studio 来执行。你可以直接输入命令来执行，或者使用其他工具来调用它。这样的一个例子就是可以跨平台运行的 Visual Studio Code。`dotnet`命令将在
    ASP.NET 5 版本 RC2 及更高版本中使用。不同的命令行应用程序，如 DNX 和 DNU，都统一在 dotnet 命令行中。例如，当你执行`dotnet
    restore`时，它将读取`project.json`文件，并根据需要下载和安装包。因此，DNX不仅是一个运行时环境，它还是一个 SDK。当你在应用程序的文件夹中执行`dotnet
    run`时，运行时部分就会启动。
- en: Deployment options
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署选项
- en: '* * *'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: There are four options for deployment. All the options are supported by the
    dotnet command-line interface. You can choose to copy over the app's project,
    let the DNX restore the packages, and run the app. A compatible DNX version has
    to be preinstalled; use the CLI command dotnet run for this one.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个部署选项。所有选项都受到 dotnet 命令行界面的支持。你可以选择复制应用程序的项目，让 DNX 恢复包，并运行应用程序。必须预先安装兼容的 DNX
    版本；使用CLI命令`dotnet run`。
- en: 'You can also let the CLI compile the project on your development machine. Copy
    over the assemblies and run:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以让 CLI 在你的开发机上编译项目。复制程序集并运行：
- en: '![](img/image_09_008.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_008.png)'
- en: 'Fig 08: Deployment Options'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 08：部署选项
- en: There is also the option to natively compile an app using a command-line switch.
    This means that instead of assemblies with IL, native binaries that can be directly
    executed without the help of the DNX or any .NET Framework are generated.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个选项是使用命令行开关本地编译应用程序。这意味着生成的不是 IL 的程序集，而是可以直接在没有 DNX 或任何 .NET Framework 帮助下直接执行的本机二进制文件。
- en: There is also an option to package your application into a NuGet package to
    easily share your project using dotnet pack. The package will contain support
    for all the configured frameworks in the `project.json` file. You can then upload
    it to a NuGet feed either globally or for your company only.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个选项是将你的应用程序打包成一个 NuGet 包，以便使用`dotnet pack`轻松共享你的项目。该包将包含`project.json`文件中配置的所有框架的支持。然后你可以将其上传到全局的
    NuGet feed，或者只针对你的公司上传。
- en: The final option is to let dotnet cli publish the app for you using dotnet publish.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项是使用 dotnet cli 发布应用程序，使用`dotnet publish`。
- en: All the required assemblies and the DNX itself is included in the deployment.
    As the deployed DNX is OS-specific, this option won't work without extra effort
    if you're deploying across operating systems.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所有所需的程序集和DNX本身都包括在部署中。由于部署的DNX是特定于操作系统的，如果您在不同操作系统上部署，则需要额外的工作才能使此选项起作用。
- en: Publishing with Visual Studio
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Visual Studio发布
- en: 'We will learn to deploy an application using Visual Studio. If we right-click
    on the web node of our project, we can pick Publish, and Publish will allow us
    to pick a target. Visual Studio will ask you to provide the name of the publishing
    profile to create and store the publishing profile for future use:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习使用Visual Studio部署应用程序。如果我们右键单击项目的web节点，我们可以选择发布，然后发布将允许我们选择目标。Visual Studio将要求您提供要创建和存储发布配置文件的名称，以备将来使用：
- en: '![](img/image_09_009.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_009.png)'
- en: 'Fig 09: Creating a publishingÂ profile'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图09：创建发布配置文件
- en: 'We can choose Azure Web Apps, filesystem, and other mode of deployment. InÂ **`Settings`**,
    we can also pick which configuration we will use and which of the DNX versions
    to use. Here, you will only see options that match what you specified in the `project.json`
    file under the frameworks section. Finally, we can Publish the application:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择Azure Web应用程序、文件系统和其他部署模式。在**`Settings`**中，我们还可以选择要使用的配置和要使用的DNX版本。在这里，您只会看到与您在`project.json`文件的frameworks部分中指定的匹配的选项。最后，我们可以发布应用程序：
- en: '![](img/image_09_010.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_010.png)'
- en: 'Fig 10: Choosing DNX version'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：选择DNX版本
- en: When published, it first runs the `prepare` statement and then the `prepublish`Â in
    order to package it all up in the temporary folder, and then it literally copies
    it out to the filesystem. Once the publishing is successful, open the command-line
    interface and navigate to the publish folder.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 发布时，它首先运行`prepare`语句，然后运行`prepublish`，以将所有内容打包到临时文件夹中，然后将其复制到文件系统。发布成功后，打开命令行界面并导航至发布文件夹。
- en: Note that the folder includes the commands and shell scripts that are defined
    in the project file. Also, note that the `approot` folder contains the packages
    and the runtimes necessary for the application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意文件夹中包括在项目文件中定义的命令和shell脚本。还要注意`approot`文件夹包含应用程序所需的软件包和运行时。
- en: If you are on the Windows platform, we can use the web command to start the
    application. You can simply open a browser and navigate to `localhost` with the
    `5000` port, and we can see our application actually running. The application
    is running directly from theÂ command shell and not under IIS.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows平台上，可以使用web命令启动应用程序。您只需打开浏览器并导航到带有`5000`端口的`localhost`，我们就可以看到我们的应用程序实际在运行。应用程序直接从命令shell而不是在IIS下运行。
- en: Publishing with dotnet command-line interface
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用dotnet命令行界面发布
- en: 'Let''s see how we can publish using dotnet command-line interface. From Visual
    Studio, open up a command shell directly in the project folder of our application.
    If we look at the `DOTNET` command, we can see that it has a number of commands
    where you can build your projects and install dependencies, especially NuGet-based
    dependencies. You can handle packages and publish the application. The followingÂ is
    the command that shows the Windows result that shows various options and arguments
    in the command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用dotnet命令行界面进行发布。从Visual Studio中，在我们应用程序的项目文件夹中直接打开命令shell。如果我们查看`DOTNET`命令，我们可以看到它有许多命令，您可以在其中构建您的项目并安装依赖项，尤其是基于NuGet的依赖项。您可以处理软件包并发布应用程序。以下是显示命令中各种选项和参数的Windows结果的命令：
- en: '`C:\Rajesh\Packt\Angular2>dotnet`.NET Command Line Interface Usage: dotnet
    [common-options] [command] [arguments]'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`C:\Rajesh\Packt\Angular2>dotnet`.NET命令行界面用法：dotnet [common-options] [command]
    [arguments]'
- en: 'Arguments: [command]: The command to execute [arguments]: Arguments to pass
    to the command'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数：[command]：要执行的命令 [arguments]：要传递给命令的参数
- en: 'Common Options: (passed before the command):`-v|--verbose` Enable verbose output'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用选项：(在命令之前传递)：`-v|--verbose` 启用详细输出
- en: 'Common Commands:`new`: Initialize a basic .NET project`restore`: Restore dependencies
    specified in the .NET project`compile`: Compiles a .NET project`publish`: Publishes
    a .NET project for deployment (including the `runtime)run`: Compiles and immediately
    executes a .NET project`repl`: Launch an interactive session (read, eval, print,
    loop)`pack`: Creates a NuGet package'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '常用命令:`new`: 初始化一个基本的.NET项目`restore`: 恢复.NET项目中指定的依赖项`compile`: 编译.NET项目`publish`:
    发布.NET项目以供部署（包括`运行时)run`: 编译并立即执行.NET项目`repl`: 启动交互式会话（读取、求职、打印、循环）`pack`: 创建一个NuGet包'
- en: The dotnet command-line interface is useful in that you can actually script
    all these processes, you can have it install the dependencies, run the build,
    and then publish it. So, it provides an easy way to automate a lot of these tasks.
    In fact, Visual Studio is just automating this using the Dotnet tool.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: dotnet命令行界面非常有用，因为您实际上可以编写脚本来完成所有这些过程，您可以让其安装依赖项，运行构建，然后发布。因此，它提供了一种轻松的方式来自动化许多这些任务。事实上，Visual
    Studio只是使用Dotnet工具来自动化这一切。
- en: The published folder contains the code of the application, all the dependencies,
    both the client dependencies, the tooling dependencies, and the NuGet dependencies,
    and contains the entire version of the runtime that's required. We can take this
    folder and put on any box and run. If you want to package this up for Linux or
    OS 10, you'll need a version of the runtime that is appropriate for those platforms,
    like CoreCLR would be. This folder has the self-contained application and can
    run on any browser. This doesn't use any framework that's installed on the machine;
    it's all within that one folder, completely portable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 发布的文件夹包含应用程序的代码，所有依赖项，客户端依赖项，工具依赖项和NuGet依赖项，并且包含所需的整个版本的运行时。我们可以将此文件夹放在任何计算机上并运行。如果要为Linux或OS
    10打包这个文件夹，您将需要适用于这些平台的运行时版本，如CoreCLR。该文件夹包含独立的应用程序，并可以在任何浏览器上运行。这不使用安装在计算机上的任何框架；它全部包含在一个文件夹中，完全可移植。
- en: Deploying to IIS
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署到IIS
- en: We need to ensure that theÂ `HttpPlatformHandler` module that acts as a reverse
    proxy is installed when you deploy to an IIS server. When the request comes in,
    IIS forwards it to another process, which is typically a command-line application.
    IIS will start and stop the process when needed and take care of concurrency.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当您部署到IIS服务器时，需要确保已安装作为反向代理的`HttpPlatformHandler`模块。当请求到来时，IIS将其转发到另一个进程，通常是一个命令行应用程序。IIS将根据需要启动和停止进程，并处理并发问题。
- en: 'In the IIS management application, our application is considered as another
    website, and can be configured in IIS. We need to inform IIS to execute the DNX
    when our application gets a request. We can achieve it using the `web.config`
    present in the project''s folder. IIS still uses `web.config` for `HttpPlatformHandler`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在IIS管理应用程序中，我们的应用程序被视为另一个网站，并且可以在IIS中进行配置。我们需要通知IIS在我们的应用程序收到请求时执行DNX。我们可以使用项目文件夹中的`web.config`来实现。IIS仍然使用`web.config`来使用`HttpPlatformHandler`：
- en: '![](img/image_09_011.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_011.png)'
- en: 'Fig 11: Configuring HttpPlatformHandler in the web.config file'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：在web.config文件中配置HttpPlatformHandler
- en: The `HttpPlatformHandler` extension is registered with IIS and is instructed
    to execute the batch file starting the DNX process when it gets a request. So,
    let's configure the app in IIS.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpPlatformHandler`扩展已经在IIS中注册，并被指示在收到请求时执行启动DNX进程的批处理文件。所以，让我们在IIS中配置应用程序。'
- en: 'To configure our application, start the IIS manager. Right-click on the root
    server node and choose **`Add Website`**, type the application name, and an application
    pool will automatically be generated for our application:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置我们的应用程序，请启动IIS管理器。右键单击根服务器节点，选择**`添加网站`**，输入应用程序名称，应用程序池将自动生成：
- en: '![](img/image_09_012.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_012.png)'
- en: 'Fig 12: Adding a website to IIS'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图12：向IIS添加网站
- en: 'Set the path to the `wwwroot` folder of the published application in the physical
    path textbox and click on **`OK`**. As the CLR is running in the exclusive process,
    we need to set **`No Managed Code`** under **`.NET CLR version`** on the application
    pool:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理路径文本框中设置发布应用程序的`wwwroot`文件夹的路径，然后点击**`OK`**。由于CLR正在独占进程中运行，我们需要在应用程序池下设置**`无托管代码`**：
- en: '![](img/image_09_013.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_013.png)'
- en: 'Fig 13: Setting No Managed Code in .NET CLR for App Pool'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图13：在应用程序池中设置.NET CLR中的无托管代码
- en: We are doing this because we don't need IIS to host the CLR for our application.
    Clicking on **`OK`** and browsing to theÂ `localhost` port `8080` will launch
    our application. In this way, we can use the features of IIS to power DNX application
    similar to any other web application hosted in IIS.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为我们不需要IIS为我们的应用程序托管CLR。点击**`OK`**并浏览到端口`8080`的`localhost`将启动我们的应用程序。这样一来，我们就可以使用IIS的功能来为DNX应用程序提供动力，就像在IIS中托管任何其他Web应用程序一样。
- en: Deploying to Microsoft Azure
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署到Microsoft Azure
- en: Azure deployment using its app service is very smooth. When an application is
    published to Azure, a new virtual machine is created, or it is hosted on an existing
    virtual machine that runs IIS, with `HttpPlatformHandler` installed. The deployment
    process is the same as deploying to IIS on a local server.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Azure的应用服务进行部署非常顺畅。当应用程序发布到Azure时，会创建一个新的虚拟机，或者它会托管在运行IIS的现有虚拟机上，该虚拟机装有`HttpPlatformHandler`。部署流程与在本地服务器上部署到IIS相同。
- en: 'A new website has to be created in IIS and the published content has to be
    uploaded to the server. All this can be done by creating a publish profile in
    Visual Studio, choosing **`Microsoft Azure App Service`**. We may need to log
    in to an Azure account, choose a subscription, and create a new app in Azure by
    giving a name. The URL will be `yourappname.azurewebsites.net`. Under **`Settings`**,
    we need to choose the DNX and click on **`Publish`**. Browsing to `yourappname.azurewebsites.net`
    will bring your application running from Azure:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在IIS中必须创建一个新的网站，并且发布的内容必须上传到服务器。所有这些都可以通过在Visual Studio中创建一个发布配置文件来完成，选择**`Microsoft
    Azure App Service`**。我们可能需要登录Azure账户，选择一个订阅，然后通过给出一个名称在Azure中创建一个新的应用。URL将是`yourappname.azurewebsites.net`。在**`设置`**下，我们需要选择DNX并点击**`发布`**。浏览到`yourappname.azurewebsites.net`将在Azure中运行您的应用程序：
- en: '![](img/image_09_014.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_014.png)'
- en: 'Fig 14: Selecting publish target'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图14：选择发布目标
- en: Deploying to Linux and macOS
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署到Linux和macOS
- en: Let's look at deploying apps from Visual Studio to Linux or macOS. We can also
    develop the application in the Linux or macOS platform using Visual Studio Code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何从Visual Studio部署应用程序到Linux或macOS上。我们还可以使用Visual Studio Code在Linux或macOS平台上开发应用程序。
- en: First, install a DNX for the framework, .NET Core or Mono. Next, copy the whole
    Visual Studio project, including source code and `project.json` and no assemblies.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为框架安装一个DNX，.NET Core或Mono。然后，复制整个Visual Studio项目，包括源代码和`project.json`，但不包括任何程序集。
- en: Then, use the dotnet cli to restore all the NuGet packages. This will include
    the assemblies the DNX needs to host the CLR in .NET Core. However, NuGet packages
    can have dependencies on other packages, so there has to be some kind of list
    of all packages needed before a restore can occur. The compilation of such a list
    takes time because all packages have to be inspected to see what their dependencies
    are. The lock file contains this compiled list, so the figuring out has to be
    done only once. All the subsequent restores use the lock file, provided that the
    list of packages in `project.json` hasn't changed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用dotnet cli来还原所有的NuGet包。这将包括DNX托管CLR在.NET Core中所需的程序集。然而，NuGet包可能依赖于其他包，因此在还原之前必须有某种包所需的所有包的列表。编制这样一个列表需要时间，因为所有的包都必须被检查，看看它们的依赖关系是什么。锁定文件包含了这个编制的列表，因此只需要做一次核实。所有后续的还原都使用锁定文件，前提是`project.json`中包的列表没有改变。
- en: Finally, instruct the DNX to run the program using Kestrel as the web server.
    The DNX will use Kestrel as an entry point, and Kestrel will then host the app.
    Kestrel gives me a notification that the app is running on port `5000`. Browsing
    to `localhost` as the domain name with port `5000` launches our application in
    Linux or macOS.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，指示DNX使用Kestrel作为Web服务器运行程序。DNX将使用Kestrel作为入口点，然后Kestrel将托管应用程序。Kestrel会通知我应用程序在端口`5000`上运行。通过使用端口`5000`的`localhost`作为域名浏览将在Linux或macOS中启动我们的应用程序。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '* * *'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: That's all, folks! We discussed what's new in Angular and .NET Core 1.0\. We
    started with the new features introduced in Angular.Â We explored the improvements
    done on the various existing approaches in Angular.Â Finally, we looked at .NET
    Core 1.0 and the cross-platform development with the .NET Execution Environment
    in detail. We learned the difference between the full .NET Framework, .NET Core,
    and Mono. Also, we covered what DNX is and its role in developing .NET apps in
    a completely new way.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部，伙计们！我们讨论了 Angular 和 .NET Core 1.0 中的新功能。我们首先介绍了 Angular 中引入的新特性。我们探讨了对
    Angular 中各种现有方法的改进。最后，我们详细了解了 .NET Core 1.0 和 .NET Execution Environment 中的跨平台开发。我们了解了完整的
    .NET Framework、.NET Core 和 Mono 之间的区别。此外，我们还介绍了 DNX 以及它在以全新方式开发 .NET 应用程序中的作用。
