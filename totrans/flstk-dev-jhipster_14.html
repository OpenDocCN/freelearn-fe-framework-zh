<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Best Practices with JHipster</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous chapters of the book, we learned about JHipster and the various tools and technologies it supports <span>in detail</span>. These are the things we have learned so far:</p>
<ul>
<li class="mce-root">We learned to develop monolithic and microservice applications. We also learned about differences in the architecture and reasons to choose one over the other.</li>
<li class="mce-root">We created entities using JDL, and we customized the generated applications for our business needs.</li>
<li>We created a CI-CD setup using Jenkins.</li>
<li class="mce-root">We deployed the monolith application to the Heroku cloud</li>
<li class="mce-root">We deployed the microservice architecture to the Google cloud using Kubernetes and Docker.</li>
<li>We learned about Spring Framework, Spring Boot, Angular, React, Docker, and much more.</li>
</ul>
<p class="mce-root">In this chapter, we will see what steps to take next and use what you have learned from this book, and we will also talk about some of the best practices, tips, tricks, and suggestions from the JHipster community. As core contributors of JHipster, we will also provide some insights and lessons learned by us in this chapter. The following are some of the topics that we will touch upon:</p>
<ul>
<li>The next steps to pursue</li>
<li>The best practices to keep in mind</li>
<li>Using JHipster modules</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The next steps to pursue</h1>
                </header>
            
            <article>
                
<p>JHipster supports a lot of technologies and learning about all of them would require an insane amount of time and effort; it cannot be done in a single book. Each technology supported would require a book on its own to learn and master it. If you are already familiar with the core concepts of web development, you will have a fairly good idea how a JHipster application works by now. We hope this book gave you a good introduction to the technologies and JHipster itself. But this in itself isn't sufficient; you will have to keep learning more to become a master. The following are some of the tasks that you can pursue to hone your skills in web development using JHipster further. But, before that, we would recommend that you learn more about Spring Framework and the Angular/React ecosystem to complement what you have learned in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a shopping cart for the application</h1>
                </header>
            
            <article>
                
<p>In <a href="63e6ed92-1616-40b7-86b8-1b3332fcbfb7.xhtml" target="_blank">Chapter 5</a><em>, Customization and Further Development</em>, we saw how the generated application can be customized to make it look and behave like an e-commerce website. As mentioned there, it is not enough to make the application truly usable. The following are some of the features that you can try to implement to make the application more feature complete:</p>
<ol>
<li><span>Add a simple shopping cart feature on the</span><span> </span>client-<span>side: </span>
<ol>
<li>Create a <kbd>ProductOrder</kbd> object to hold the <kbd>OrderItems</kbd>. The <kbd>ProductOrder</kbd> is related to the Customer so tag it to the customer using details of the currently logged-in user.</li>
<li><span>Add an <span class="packt_screen">add to cart</span> button to the product items in the list. On clicking the button, create a new <kbd>OrderItem</kbd> for the Product and add the <kbd>OrderItem</kbd> to the <kbd>ProductOrder</kbd>'s <kbd>OrderItems</kbd> array. If the same product is clicked more than once, increase the quantity attribute of the existing <kbd>OrderItem</kbd>. </span>Add a shopping cart dialog to list down all the <kbd>OrderItems</kbd> added to the <kbd><span>ProductOrder</span></kbd>. It can use a similar listing UI to the products, or a simple table to show the product, total price, and quantity.</li>
<li>Add a <kbd>view cart</kbd> button to the product list page to view the shopping cart dialog.</li>
</ol>
</li>
</ol>
<ol start="2">
<li>Add an order now feature:
<ol>
<li>Add an order now button to the product list page.</li>
<li>On clicking the button, send the <span><kbd>ProductOrder</kbd> to the REST API to create a new <kbd>ProductOrder</kbd></span>, <span>use the <kbd>product-order.service.ts</kbd> for this.</span></li>
<li>At the backend, modify the save method of <kbd>ProductOrderService.java</kbd> to create an Invoice and Shipment for the <kbd>ProductOrder</kbd> and save them all.</li>
<li>Let us assume that we accept cash on delivery so let us skip integrating with a payment gateway for now.</li>
</ol>
</li>
<li>Send an order confirmation to the customer:
<ol>
<li>JHipster comes with mail configuration and templates out of the box. You can configure your own SMTP server details in <kbd>src/main/resources/config/application-*.yml</kbd>. Refer to <a href="http://www.jhipster.tech/tips/011_tip_configuring_email_in_jhipster.html">http://www.jhipster.tech/tips/011_tip_configuring_email_in_jhipster.html</a> for instructions on how to configure popular SMTP services.</li>
<li>Create a new email template in <kbd>src/main/resources/mails</kbd> for order confirmation. Provide the details of products, total price, and quantity in the email.</li>
<li>Use the provided <kbd>sendEmailFromTemplate</kbd> method in <kbd>MailService.java</kbd> to send the email when an Invoice is successfully created.</li>
</ol>
</li>
<li>Create a customer profile when registering a new user:
<ol>
<li>Add fields to the registration page and create customer entity for every user from the details automatically.</li>
</ol>
</li>
</ol>
<p>Try to apply the changes to the microservice application as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving end-to-end tests</h1>
                </header>
            
            <article>
                
<p>In <a href="39f6bb2a-8691-42c6-b010-ba71ee36a6c9.xhtml" target="_blank">Chapter 6</a><span>, </span><em>Testing and Continuous Integration</em>, we saw that some of the e2e tests were commented out due to the difficulty in generating tests for an entity with a required relationship. Try to fix the tests with the following approach:</p>
<ol>
<li>Add a method to delete entities after creation, similar to what we saw in <a href="39f6bb2a-8691-42c6-b010-ba71ee36a6c9.xhtml" target="_blank">Chapter 6</a>, <em>Testing and Continuous Integration</em>, for the customer entity spec.</li>
</ol>
<p> </p>
<ol start="2">
<li>Uncomment the commented out e2e tests in the files under<span> </span><kbd>src/test/javascript/e2e/entities</kbd>.</li>
<li>Navigate the protractor to the related entity page and create a new item. If the related entity has required relationships then follow the same approach and nest them until all the required entities are in place. This can be done in a <kbd>beforeAll</kbd> method of the test as well.</li>
<li><span>Now go back to the entity under test and see whether the test works fine.</span></li>
<li>Once the test is complete, delete the created entities in the <kbd>afterAll</kbd> method of the test.</li>
<li>Explore whether you can automate the creation of an entity item on the page object of the entity and use it when needed.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving the CI/CD pipeline</h1>
                </header>
            
            <article>
                
<p>In <a href="39f6bb2a-8691-42c6-b010-ba71ee36a6c9.xhtml" target="_blank">Chapter 6</a>, <em>Testing and Continuous Integration</em>, when we created the <kbd>Jenkinsfile</kbd> using the CI/CD sub-generator, we commented out the deployment stage. Re-enable it and check whether the application is deployed to Heroku when you make new commits:</p>
<ul>
<li>See if you can add e2e tests to the pipeline. </li>
<li>If your application is on GitHub, try to add Travis to the project using the ci-cd sub-generator.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a JHipster module</h1>
                </header>
            
            <article>
                
<p>JHipster has two mechanisms to extend its features:</p>
<ul>
<li>A modules system, which lets users build their own Yeoman generators (<a href="http://www.jhipster.tech/modules/creating-a-module/">http://www.jhipster.tech/modules/creating-a-module/</a>)  to complement JHipster</li>
<li>A new blueprint mechanism introduced with JHipster 5 to customize required parts of the code generated by JHipster</li>
</ul>
<div class="packt_infobox">The difference between a <strong>module</strong> and a <strong>blueprint</strong> is that a blueprint lets you override certain parts of the generated application while JHipster scaffolds the remaining parts. For example, a blueprint can override the client-side code alone, while the server side is generated by JHipster. A module, on the other hand, can only change what is generated by JHipster and hence is more suitable for adding complementing features on top of the ones created by JHipster.</div>
<p>Try to build a module to add a simple page to your application. </p>
<div class="packt_tip">You can use the JHipster module generator (<a href="https://github.com/jhipster/generator-jhipster-module">https://github.com/jhipster/generator-jhipster-module</a>) to scaffold a new module.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Best practices to keep in mind</h1>
                </header>
            
            <article>
                
<p>Over the years, the JHipster community has identified and adopted a lot of best practices from the technologies and tools it supports and from the general technical community. While JHipster has tried to follow these best practices in the code it creates, the following are some best practices, tips, and tricks that you as a user should follow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Choosing a client-side framework</h1>
                </header>
            
            <article>
                
<p>When using JHipster you have an option to choose between Angular and React as the client-side framework. Do not choose something just for its hype, choose based on your requirement, team composition, and familiarity: </p>
<ul>
<li>If you come from a heavy Java/Spring background, then Angular will be much easier to follow and work with</li>
<li>If your application requires heavy state management and shared state, then React would be a more natural fit</li>
<li>If you are planning to build a native mobile client for your application then the more mature React is a good choice for this space, with React Native allowing you to reuse a lot of code between your web and mobile application</li>
<li>If your application depends heavily on HTML pages produced by a design team or a third-party, then Angular will be much easier to integrate than React</li>
</ul>
<p>If you need a lot of widgets that are not part of standard Bootstrap, then use an existing widget library, such as PrimeNG or<span> </span>VMware<span> </span><span>Clarity, rather than assembling widgets from different origins. However, if you need only a few more widgets on top of Bootstrap, then stick to Bootstrap and use a Bootstrap compatible widget for Angular or React.</span></p>
<p>Regardless of what you choose, follow the guidelines and best practices from that project's community.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Choosing a database option</h1>
                </header>
            
            <article>
                
<p>JHipster provides support for many kinds of databases, ranging from SQL to NoSQL. The following are some considerations when choosing a DB:</p>
<ul>
<li>For most cases, a SQL DB would be more than sufficient, hence if you do not see any reason to go with other NoSQL solutions, stick to SQL and choose from MySQL, Postgres, Oracle, MariaDB, and MS SQL:
<ul>
<li>If you are on an enterprise with Oracle or MS SQL subscriptions, then it would make sense to choose them as you would benefit from the support and enterprise features provided</li>
<li>If you need to store and query a lot of JSON data, then Postgres offers the best JSON support with full-text search capabilities</li>
<li>For most simple use cases, MySQL or MariaDB will suffice</li>
<li>Always choose a second-level Hibernate cache when working with a SQL DB</li>
<li>When choosing a development database for SQL:<br/>
<ul>
<li>Choose an H2 file DB if you want a simple development setup with persistent data.</li>
<li>Choose the same DB as the production DB if you want faster restarts and your persistent data doesn't need to be wiped every now and then. If you are using the provided Docker images, then wiping data will not be an issue.</li>
<li>Choose an H2 in-memory DB if you do not want any persistent data during development and would like a clean state on each restart</li>
</ul>
</li>
</ul>
</li>
<li>If your use case requires a lot of heavy data reads/writes, and if the data is not very relational, then Cassandra would be a perfect fit, as it is distributed and can work under extremely heavy loads.</li>
<li>For a normal, non-relational data structure, MongoDB may be sufficient. You could also use Postgres as a NoSQL JSON store if needed.</li>
<li>If you need enterprise support for NoSQL, CouchBase is a good option.</li>
<li>Use Elasticsearch along with the primary DB for full-text search. If you only need simple filtering, use the JPA filtering option provided. Refer to: <a href="http://www.jhipster.tech/entities-filtering/">http://www.jhipster.tech/entities-filtering/</a>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Architecture considerations</h1>
                </header>
            
            <article>
                
<p class="mce-root">We have already discussed choosing a microservice or monolithic architecture in <a href="498dbd6d-b882-4551-92dd-97cdde4b62ac.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to Modern Web Application Development</em>. Here are some more points when it comes to architecture:</p>
<ul>
<li class="mce-root"><span>Don't use a microservice architecture if you're a small team. Microservices are about scaling teams more than anything. It's often easier to break up your monolith than start with microservices.</span></li>
<li>Use asynchronous messaging in your monolith if you think you may need to refactor to microservices in the future. JHipster provides support for Apache Kafka, which is a good solution for asynchronous messaging. </li>
</ul>
<div class="packt_infobox">Asynchronous messaging is the best way of building stateless systems. It is important in a microservice architecture as you might often want communications to be stateless and non-blocking. Some of the popular solutions for this are Apache Kafka (<a href="http://kafka.apache.org/">http://kafka.apache.org/</a>), RabbitMQ (<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>), and gRPC (<a href="https://grpc.io">https://grpc.io</a>).  ReactiveX (<a href="http://reactivex.io/">http://reactivex.io/</a>) <span>and Spring Reactor (<a href="http://projectreactor.io/">http://projectreactor.io/</a>) are popular abstractions for working with asynchronous systems. </span><span>Asynchronous messaging also makes the systems loosely coupled.</span></div>
<ul>
<li><span><span>If you intend to expose an API to a third party, do <em>API first</em> development. We now have a good workflow to do it with Swagger Codegen. Refer to <a href="http://www.jhipster.tech/doing-api-first-development/">http://www.jhipster.tech/doing-api-first-development/</a> for more info.</span></span></li>
<li>When doing communication between microservices with REST, don't put interface code in a shared package; it would tightly couple APIs to their clients, thus arriving at a distributed monolith.</li>
<li>With JHipster, it is possible to split the client and server. Refer to <a href="http://www.jhipster.tech/separating-front-end-and-api/">http://www.jhipster.tech/separating-front-end-and-api/</a>. However, think twice before separating them, as it will require you to open up CORS, which makes the security more vulnerable, and such architecture brings its own issues. So do this only if you have a good reason to do so.</li>
<li>Use DTOs at the service layer so that you can aggregate entities and define a better API without exposing entities to the client. You will have to enable the service layer for your entities to use this with JHipster.</li>
<li>Learn the technology stack of your application before you start development.</li>
<li>Make yourself familiar with the provided toolbelt, such as build tools (Maven/Gradle/Webpack), BrowserSync, and so on.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Security considerations</h1>
                </header>
            
            <article>
                
<p>Security is one of the most important aspects of any application, and you should consider the following when choosing a security mechanism:</p>
<ul>
<li>For most use cases JWT authentication will be sufficient, so stick to that if you are not sure</li>
<li><span>If you want single-sign-on in your application, use OAuth 2.0 / OIDC rather than trying to make JWT or session authentication work as an SSO solution</span></li>
<li>If you already have Keycloak or Okta set up in your company, choose <span>OAuth 2.0/OIDC and connect to them</span></li>
<li>Choose session-based authentication only if you want a stateful authentication</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deployment and maintenance</h1>
                </header>
            
            <article>
                
<p>There are a lot of good practices here; some of the important ones are:</p>
<ul>
<li>Docker is a must-have for integration testing of microservices, but going into production with Docker is not easy so use an orchestration tool, such as Kubernetes, <span><span>for that.</span></span></li>
<li><span>Run a prod build immediately after the application is generated and d</span><span>eploy to prod immediately while your app is still very simple. This will help ease any deployment issues, as you will be sure that the app works fine out of the box.</span></li>
<li><span>The prod build is quite different from the dev build when it comes to the client side, as the resources are minified and optimized. When adding any frontend code, libraries always verify the prod build as well.</span></li>
<li>Always run end-to-end protractor tests with the prod profile.</li>
<li>Embrace the embedded servlet engine and forget about deploying to a JEE server such as WebLogic, WebSphere, JBoss, and so on. The artifacts produced are executable and have an embedded Undertow server.</li>
</ul>
<div class="packt_tip packt_infobox">Did you know that Java EE is being renamed to Jakarta EE? Refer to <a href="https://www.infoq.com/news/2018/03/java-ee-becomes-jakarta-ee">https://www.infoq.com/news/2018/03/java-ee-becomes-jakarta-ee</a> for more info.</div>
<ul>
<li>Upgrade often using the JHipster upgrade sub-generator. This will ensure the tools and technologies you use are up to date and secure.</li>
<li>Remove all secrets from<span> </span><kbd>application-prod.yml</kbd><span> </span>and use placeholders to inject values from the command line or environment variables. Never put any secrets or passwords in code or config files.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">General best practices</h1>
                </header>
            
            <article>
                
<p>In general, these are some best practices you should consider:</p>
<ul>
<li>If you start creating entities using the entity sub-generator, then use <kbd>export-jdl</kbd> and switch to JDL once you have more than a handful of entities.</li>
<li>Generate your application without any modules first and add required modules only when the need arises.</li>
<li>Evaluate a module <span>carefully </span>before adding it. Make sure it supports the stack you have chosen.</li>
<li>Follow each underlying technology's <em>best practices</em>. Angular best practices, Spring best practices, and so on. Change something only if there is a good reason to do so.</li>
<li>Use the provided library versions on the client side and server side. It's hard work to have them all working together, so stick to them. Update them when JHipster updates them or only if you really need to fix a bug or a security issue.</li>
<li>Follow the workflows provided by JHipster. They are here to help you. There is usually a very good reason to use them in the recommended way. <span>Read the JHipster </span>documentation<span> before looking for help outside. </span></li>
<li>You have a great working environment out of the box; don't break it.
<ul>
<li>Frontend and backend updates are automatic and fast using live reload. Make use of them.</li>
<li>Production deployment is easy using the provided sub-generators.</li>
</ul>
</li>
<li>Use the provided sub-generators for the cloud platform you are deploying to.</li>
<li>Git is your friend. Commit each time you add a module or an entity, or when using a sub-generator. Every mistake (including in the database) should be easy to rollback with Git.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using JHipster modules</h1>
                </header>
            
            <article>
                
<p>JHipster modules and blueprints are a great way to add more features and functionality to your generated code. There are many modules (55 at the time of writing) available to choose from in the JHipster marketplace (<a href="http://www.jhipster.tech/modules/marketplace">http://www.jhipster.tech/modules/marketplace</a>), and you can also build your own modules to suit your needs. Some of the modules worth noticing are as follows:</p>
<ul>
<li><strong>Ignite JHipster</strong>: This provides a React Native boilerplate for JHipster apps. An ideal way to kickstart your React Native application using JHipster as the backend.</li>
<li><strong>Entity Audit</strong>: This module enables entity audits. It uses Hibernate audit hooks to create a custom audit for entity CRUD operations. It also provides Javers as the auditing mechanism instead of the custom Hibernate auditing. It also provides a nice UI to view the audits in an Angular application. It will enable auditing for new entities as well as existing entities.</li>
<li><strong>Ionic</strong>: This provides an Ionic client for JHipster apps. It is an ideal solution if you want to create mobile applications with a JHipster backend and Angular frontend with Ionic.</li>
<li><strong>Swagger CLI</strong>: Module provides support for generating Swagger clients for a JHipster application.</li>
<li><strong>gRPC</strong>: This module generates gRPC reactive endpoints for a JHipster application. It supports entities as well, and is an ideal choice if you want a non-blocking reactive API for your JHipster application.</li>
<li><strong>VueJS</strong>: This module provides VueJS support for JHipster applications. It creates minimal boilerplate to start client-side development for JHipster apps using VueJS.</li>
</ul>
<p>Take a look at the following steps: </p>
<ol>
<li>To use a JHipster module first install it using <kbd>npm i -g generator-&lt;module-name&gt;</kbd> or <kbd>yarn add global generator-&lt;module-name&gt;</kbd>.</li>
<li>Once installed, go into the JHipster application directory and execute <kbd>yo &lt;module-name&gt;</kbd> to initiate the module and follow the prompts.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Contributing to JHipster</h1>
                </header>
            
            <article>
                
<p>One of the best ways to learn JHipster and the technologies it supports is by contributing to JHipster directly. Refer to the contribution guide (<a href="https://github.com/jhipster/generator-jhipster/blob/master/CONTRIBUTING.md">https://github.com/jhipster/generator-jhipster/blob/master/CONTRIBUTING.md</a>) for details about setting up JHipster for development.</p>
<p><span>You can contribute to the project in many ways; </span>some of them are as follows:</p>
<ul>
<li><span>If you find a bug, enter an issue in the </span>GitHub project (<a href="https://github.com/jhipster/generator-jhipster">https://github.com/jhipster/generator-jhipster</a>)<span>, follow the guidelines in the issue template, run </span><kbd>jhipster info</kbd><span>, and provide steps to reproduce. You can also try to fix the issue yourself and submit a PR if you're successful.</span></li>
<li>Work on open issues and feature requests. This way you will learn the internals of JHipster and the technologies used along the way.</li>
<li>Answer JHipster related questions on<span> </span>Stack Overflow (<a href="https://stackoverflow.com/questions/tagged/jhipster">https://stackoverflow.com/questions/tagged/jhipster</a>).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Our journey together through JHipster and full stack development has come to an end. In this chapter, we learned about many best practices identified by the JHipster community. Try to complete the assignments in the <em>Next steps to pursue</em> section, as it will help you to apply what you have learned and will help you understand the concepts better.</p>
<p>We hope you have had a fabulous learning experience, and hope what you have learned from the book about JHipster will help you with your next project.</p>
<p>Follow <kbd>@java_hipster</kbd> on Twitter so you can see when new releases come out and security vulnerabilities are revealed.</p>
<p>If you have questions or issues regarding JHipster, post your questions to Stack Overflow (<a href="https://stackoverflow.com/questions/tagged/jhipster">https://stackoverflow.com/questions/tagged/jhipster</a>) and add the <kbd>jhipster</kbd> tag. The team will be notified and will be happy to help!</p>


            </article>

            
        </section>
    </body></html>