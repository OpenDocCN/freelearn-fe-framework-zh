- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding React Components and JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define what exactly components are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build and use components effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize common naming conventions and code patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the relationship between components and JSX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write JSX code and understand why it’s used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write React components without using JSX code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write your first React apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about React in general, what it is, and
    why you should consider using it for building user interfaces. You also learned
    how to create React projects with the help of Vite, by running `npm create vite@latest
    <your-project-name>` .
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about one of the most important React concepts
    and building blocks. You will learn that components are reusable building blocks
    that are used to build user interfaces. In addition, JSX code will be discussed
    in greater detail so that you will be able to use the concept of components and
    JSX to build your own first basic React apps.
  prefs: []
  type: TYPE_NORMAL
- en: What Are Components?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key concept of React is the usage of so-called components. **Components**
    are reusable building blocks that are combined to compose the final user interface.
    For example, a basic website could be made up of a sidebar that includes navigation
    items and a main section that includes elements for adding and viewing tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: An example task management screen with sidebar and main area'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at this example page, you might be able to identify various building
    blocks (i.e., components). Some of these components are even reused:'
  prefs: []
  type: TYPE_NORMAL
- en: The sidebar and its navigation items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main page area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the main area, the header with the title and due date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A form for adding tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that some components are nested inside other components—i.e., components
    are also made up of other components. That’s a key feature of React and similar
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Why Components?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No matter which web page you look at, they are all made up of building blocks
    like this. It’s not a React-specific concept or idea. Indeed, HTML itself “thinks”
    in components if you take a closer look. You have elements like `<img>` , `<header>`
    , `<nav>` , etc., and you combine these elements to describe and structure your
    website content.
  prefs: []
  type: TYPE_NORMAL
- en: But React **embraces** this idea of breaking a web page into reusable building
    blocks because it is an approach that allows developers to work on small, manageable
    chunks of code. It’s easier and more maintainable than working on a single, huge
    HTML (or React code) file.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why other libraries—both frontend libraries like React or Angular as
    well as backend libraries and templating engines like **EJS** ( **Embedded JavaScript
    templates** )—also embrace components (though the names might differ, you also
    find *“partials”* or *“includes”* as common names).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: EJS is a popular templating engine for JavaScript. It’s especially popular for
    backend web development with Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: When working with React, it’s especially important to keep your code manageable
    and work with small, reusable components because React components are not just
    collections of HTML code. Instead, a React component also encapsulates JavaScript
    logic and often also CSS styling. For complex user interfaces, the combination
    of markup (JSX), logic (JavaScript), and styling (CSS) could quickly lead to large
    chunks of code, thus making it difficult to maintain that code. Think of a large
    HTML file that also includes JavaScript and CSS code. Working in such a code file
    wouldn’t be a lot of fun.
  prefs: []
  type: TYPE_NORMAL
- en: To make a long story short, when working on a React project, you will work with
    lots of components. You will split your code into small, manageable building blocks
    and then combine these components to form the overall user interface. It’s a key
    feature of React.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: When working with React, you should embrace this idea of working with components.
    But technically, they’re optional. You could, theoretically, build very complex
    web pages with one single component alone. It would not be much fun, and it would
    not be practical, but it would technically be possible without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: The Anatomy of a Component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Components are important. But what exactly does a React component look like?
    How do you write React components on your own?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Typically, you would store a code snippet like this in a separate file (e.g.,
    a file named `SubmitButton.jsx` , stored inside a `/components` folder, which
    in turn resides in the `/src` folder of your React project) and import it into
    other component files that need this component. `.jsx` is used as an extension
    since the file contains JSX code. Vite enforces the usage of `.jsx` as a file
    extension if you’re writing JSX code – storing such code in `.js` files is not
    allowed in Vite projects (even though it might work in other React project setups).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following component imports the component defined above and uses it in
    its `return` statement to output the `SubmitButton` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `import` statements you see in these examples are standard JavaScript `import`
    statements. Theoretically, in Vite-based projects, you could omit the file extension
    ( `.jsx` in this case) in the `import` statement. However, it might be a good
    idea to include the extension since that’s in line with standard JavaScript. When
    importing from third-party packages (like `useState` from the `react` package),
    no file extension is added though – you just use the package name. `import` and
    `export` are standard JavaScript keywords that help with splitting related code
    across multiple files. Things like variables, constants, classes, or functions
    can be exported via `export` or `export default` so that they can then be used
    in other files after importing them there.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: If the concept of splitting code into multiple files and using `import` and
    `export` is brand-new to you, you might want to dive into more basic JavaScript
    resources on this topic first. For example, MDN has an excellent article that
    explains the fundamentals, which you can find at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the components shown in these examples are highly simplified and
    also contain features that you haven’t learned about yet (e.g., `useState()` ).
    However, the general idea of having standalone building blocks that can be combined
    should be clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with React, there are two alternative ways to define components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class-based components** (or “class components”): Components defined via
    the `class` keyword'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional components** (or “function components”): Components that are defined
    via regular JavaScript functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all the examples covered in this book, components are built as JavaScript
    functions. As a React developer, you have to use one of these two approaches as
    React expects components to be functions or classes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Until late 2018, you had to use class-based components for certain kinds of
    tasks—specifically, for components that use state internally. (State will be covered
    in *Chapter 4* , *Working with Events and State* ). However, in late 2018, a new
    concept was introduced: **React Hooks** . This allows you to perform all operations
    and tasks with functional components. Consequently, while still supported by React,
    class-based components are on their way out and are not covered in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the examples above, there are a couple of other noteworthy things:'
  prefs: []
  type: TYPE_NORMAL
- en: The component functions carry capitalized names (e.g., `SubmitButton` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the component functions, other “inner” functions can be defined (e.g.,
    `handleSubmit` , typically written in **camelCase** )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component functions return *HTML-like* code (JSX code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Features like `useState()` can be used inside the component functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component functions are exported (via `export default` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certain features (like `useState` or the custom component `SubmitButton` ) are
    imported via the `import` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following sections will take a closer look at these different concepts that
    make up components and their code.
  prefs: []
  type: TYPE_NORMAL
- en: What Exactly Are Component Functions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In React, components are functions (or classes, but as mentioned above, those
    aren’t relevant anymore).
  prefs: []
  type: TYPE_NORMAL
- en: A function is a regular JavaScript construct, not a React-specific concept.
    This is important to note. React is a JavaScript library and consequently **uses
    JavaScript features** (like functions); React is **not a brand-new programming
    language** .
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with React, regular JavaScript functions can be used to encapsulate
    HTML (or, to be more precise, JSX) code and JavaScript logic that belongs to that
    markup code. However, it depends on the code you write in a function whether it
    qualifies to be treated as a React component or not. For example, in the code
    snippets above, the `handleSubmit` function is also a regular JavaScript function,
    but it’s not a React component. The following example shows another regular JavaScript
    function that doesn’t qualify as a React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, a function will be treated as a component and can therefore be used
    like an HTML element in JSX code if it returns a **renderable** value (typically
    JSX code). This is very important. You can only use a function as a React component
    in JSX code if it is a function that returns something that can be rendered by
    React. The returned value technically doesn’t have to be JSX code, but in most
    cases, it will be. You will see an example of non-JSX code being returned in *Chapter
    7* , *Portals and Refs* .
  prefs: []
  type: TYPE_NORMAL
- en: In the code snippet where functions named `SubmitButton` and `AuthForm` were
    defined, those two functions qualified as React components because they both returned
    JSX code (which is code that can be rendered by React, making it renderable).
    Once a function qualifies as a React component, it can be used like an HTML element
    inside of JSX code, just as `<SubmitButton />` was used like a (self-closing)
    HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: When working with vanilla JavaScript, you, of course, typically call functions
    to execute them. With functional components, that’s different. React calls these
    functions on your behalf, and for that reason, as a developer, you use them like
    HTML elements inside of this JSX code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: When referring to renderable values, it is worth noting that by far the most
    common value type being returned or used is indeed JSX code—i.e., markup defined
    via JSX. This should make sense because, with JSX, you can define the HTML-like
    structure of your content and user interface.
  prefs: []
  type: TYPE_NORMAL
- en: But besides JSX markup, there are a couple of other key values that also qualify
    as renderable and therefore could be returned by custom components (instead of
    JSX code). Most notably, you can also return strings or numbers as well as arrays
    that hold JSX elements or strings or numbers.
  prefs: []
  type: TYPE_NORMAL
- en: What Does React Do with All These Components?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you follow the trail of all components and their `import` and `export` statements
    to the top, you will find a `root.render(...)` instruction in the main entry script
    of the React project. Typically, this main entry script can be found in the `main.jsx`
    file, located in the project’s `src/` folder. This `render()` method, which is
    provided by the React library (to be precise, by the `react-dom` package), takes
    a snippet of JSX code and interprets and executes it for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete snippet you find in the root entry file ( `main.jsx` ) typically
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The exact code you find in your new React project might look slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: It may, for instance, include an extra `<StrictMode>` element that’s wrapped
    around `<App>` . `<StrictMode>` turns on extra checks that can help catch subtle
    bugs in your React code. But it can also lead to confusing behavior and unexpected
    error messages, especially when experimenting with React or learning React. As
    this book is primarily interested in the coverage of React core features and key
    concepts, `<StrictMode>` will not be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'While omitted here, strict mode will be covered in *Chapter 10* , *Behind the
    Scenes of React and Optimization Opportunities* . If you want to learn more about
    it right now, you can delve into the official documentation: [https://react.dev/reference/react/StrictMode](https://react.dev/reference/react/StrictMode)
    . Just be aware that some of the effects triggered by strict mode will be easier
    to understand after you’ve read more of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: To follow along smoothly then, cleaning up a newly created `main.jsx` file to
    look like the code snippet above is a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: The `createRoot()` method instructs React to create a new **entry point** ,
    which will be used to inject the generated user interface into the actual HTML
    document that will be served to website visitors. The argument passed to `createRoot()`
    therefore is a pointer to a DOM element that can be found in `index.html` —the
    single page that will be served to website visitors.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, `document.getElementById('root')` is used as an argument. This
    built-in vanilla JavaScript method yields a reference to a DOM element that is
    already part of the `index.html` document. Hence, as a developer, you must ensure
    that such an element with the provided `id` attribute value ( `root` , in this
    example) exists in the HTML file into which the React app script is loaded. In
    a default React project created via `npm create vite@latest` , this will be the
    case. You can find a `<div id="root">` element in the `index.html` file in the
    root project folder.
  prefs: []
  type: TYPE_NORMAL
- en: This `index.html` file is a relatively empty file that only acts as a shell
    for the React app. React just needs an entry point (defined via `createRoot()`
    ), which will be used to attach the generated user interface to the displayed
    website. The HTML file and its content, as a result, do not directly define the
    website content. Instead, the file just serves as a starting point for the React
    application, allowing React to then take over and control the actual user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the root entry point has been defined, a method called `render()` can
    be called on the `root` object created via `createRoot()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This `render()` method tells React which content (i.e., which React component)
    should be injected into that root entry point. In most React apps, this is a component
    called `App` . React will then generate appropriate DOM-manipulating instructions
    to reflect the markup defined via JSX in the `App` component on the actual web
    page.
  prefs: []
  type: TYPE_NORMAL
- en: This `App` component is a component function that is imported from some other
    file. In a default React project, the `App` component function is defined and
    exported in an `App.jsx` file, which is also located in the `src/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: This component, which is handed to `render()` ( `<App />` , typically), is also
    called the **root component** of the React app. It’s the main component that is
    rendered to the DOM. All other components are nested in the JSX code of that `App`
    component or the JSX code of even more nested descendent components. You can think
    of all these components building up a tree of components that is evaluated by
    React and translated into actual DOM-manipulating instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a product  Description automatically generated](img/B31339_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Nested React components form a component tree'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the previous chapter, React can be used on various platforms.
    With the `react-native` package, it could be used to build native mobile apps
    for iOS and Android. The `react-dom` package, which provides the `createRoot()`
    method (and therefore, implicitly, the `render()` method), is focused on the browser.
    It provides the “bridge” between React’s capabilities and the browser instructions
    that are required to bring the UI (described via JSX and React components) to
    life in the browser. If you build for different platforms, replacements for `ReactDOM.createRoot()`
    and `render()` are required (and, of course, such alternatives do exist).
  prefs: []
  type: TYPE_NORMAL
- en: Either way, no matter whether you use a component function like an HTML element
    inside of JSX code of other components or use it like an HTML element that’s passed
    as an argument to the `render()` method, React takes care of interpreting and
    executing the component function on your behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is not a new concept. In JavaScript, functions are **first-class
    objects** , which means that you can pass functions as arguments to other functions.
    This is basically what happens here, just with the extra twist of using this JSX
    syntax, which is not a default JavaScript feature.
  prefs: []
  type: TYPE_NORMAL
- en: React executes these component functions for you and translates the returned
    JSX code into DOM instructions. To be precise, React traverses the returned JSX
    code and dives into any other custom components that might be used in that JSX
    code until it ends up with JSX code that is only made up of native, built-in HTML
    elements (technically, it’s not really HTML, but that will be discussed later
    in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Take these two components as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `App` component uses the `Greeting` component inside its JSX code. React
    will traverse the entire JSX markup structure and derive this final JSX code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will instruct React and ReactDOM to perform the following DOM operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `<div>` element
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside that `<div>` , create two child elements: `<h2>` and `<p>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the text content of the `<h2>` element to `'Hello World!'`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the text content of the `<p>` element to `'Welcome to this book!'`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the `<div>` , with its children, into the already-existing DOM element,
    which has the ID `'root'`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a bit simplified, but you can think of React handling components and
    JSX code as described above.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: React doesn’t actually work with JSX code internally. It’s just easier to use
    as a developer. Later, in this chapter, you will learn what JSX code gets transformed
    into and what the actual code that React works with looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Built-In Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As shown in the earlier examples, you can create your own custom components
    by creating functions that return JSX code. And indeed, that’s one of the main
    things you will do all the time as a React developer: create component functions
    – lots of component functions.'
  prefs: []
  type: TYPE_NORMAL
- en: But, ultimately, if you were to merge all JSX code into just one big snippet
    of JSX code, as shown in the last example, you would end up with a chunk of JSX
    code that includes only standard HTML elements like `<div>` , `<h2>` , `<p>` ,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: When using React, you don’t create brand-new HTML elements that the browser
    would be able to display and handle. Instead, you create components that **only
    work inside the React environment** . Before they reach the browser, they have
    been evaluated by React and “translated” into DOM-manipulating JavaScript instructions
    (like `document.append(…)` ).
  prefs: []
  type: TYPE_NORMAL
- en: But keep in mind that all this JSX code is a feature that’s not part of the
    JavaScript language itself. It’s basically **syntactical sugar** (i.e., a simplification
    regarding the code syntax) provided by the React library and the project setup
    you’re using to write React code. Therefore, elements like `<div>` , when used
    in JSX code, also **aren’t normal HTML elements** because you **don’t write HTML
    code** . It might look like that, but it’s inside a `.jsx` file and it’s not HTML
    markup. Instead, it’s this special JSX code. It is important to keep this in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, these `<div>` and `<h2>` elements you see in all these examples
    are also just React components in the end. But they are not components built by
    you, but instead provided by React (or, to be precise, by ReactDOM).
  prefs: []
  type: TYPE_NORMAL
- en: When working with React, you consequently always end up with these primitives—these
    built-in component functions that are later translated to browser instructions
    that generate and append or remove normal DOM elements. The idea behind building
    custom components is to group these elements together such that you end up with
    reusable building blocks that can be used to build the overall UI. But, in the
    end, this UI is made up of regular HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your level of frontend web development knowledge, you might have
    heard about a web feature called **Web Components** . The idea behind this feature
    is that you can indeed build brand-new HTML elements with vanilla JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, React does not pick up this feature; you don’t build new custom
    HTML elements with React.
  prefs: []
  type: TYPE_NORMAL
- en: Naming Conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All component functions that you can find in this book carry names like `SubmitButton`
    , `AuthForm` , or `Greeting` .
  prefs: []
  type: TYPE_NORMAL
- en: You can generally name your React functions however you want—at least in the
    file where you are defining them. But it is a common convention to use the **PascalCase**
    naming convention, wherein the first character is uppercase and multiple words
    are grouped into one single word ( `SubmitButton` instead of `Submit Button` ),
    where every “subword” then starts with another uppercase character.
  prefs: []
  type: TYPE_NORMAL
- en: In the place where you define your component function, it is only a naming convention,
    not a hard rule. However, it **is** a hard rule in the place where you **use**
    the component functions—i.e., in the JSX code where you embed your own custom
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can’t use your own custom component function as a component like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: React forces you to use an uppercase starting character for your own custom
    component names when using them in JSX code. This rule exists to give React a
    clear and easy way of telling custom components apart from built-in components
    like `<div>` , etc. React only needs to look at the starting character to determine
    whether it’s a built-in element or a custom component.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the names of the actual component functions, it is also important to
    understand file naming conventions. Custom components are typically stored in
    separate files that live inside a `src/components/` folder. However, this is not
    a hard rule. The exact placement as well as the folder name is up to you, but
    it should be somewhere inside the `src/` folder. Using a folder named `components/`
    is the standard though.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas it is the standard to use PascalCase for the component functions, there
    is no general default regarding file names. Some developers prefer PascalCase
    for file names as well; and, indeed, in brand-new React projects, created as described
    in this book, the `App` component can be found inside a file named `App.jsx` .
    Nonetheless, you will also encounter many React projects where components are
    stored in files that follow the kebab-case naming convention. (All lowercase and
    multiple words are combined into a single word via a dash). With this convention,
    component functions could be stored in files named `submit-button.jsx` , for example.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, it is up to you (and your team) which file naming convention you
    want to follow. In this book, PascalCase will be used for file names.
  prefs: []
  type: TYPE_NORMAL
- en: JSX vs HTML vs Vanilla JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned above, React projects typically contain lots of JSX code. Most
    custom components will return JSX code snippets. You can see this in all the examples
    shared thus far, and you will see it in basically every React project you explore,
    no matter whether you are using React for the browser or other platforms like
    `react-native` .
  prefs: []
  type: TYPE_NORMAL
- en: But what exactly is this JSX code? How is it different from HTML? And how is
    it related to vanilla JavaScript?
  prefs: []
  type: TYPE_NORMAL
- en: JSX is a feature that’s not part of vanilla JavaScript. What can be confusing,
    though, is that it’s also not directly part of the React library.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, JSX is syntactical sugar that is provided by the build workflow that’s
    part of the overall React project. When you start the development web server via
    `npm run dev` or build the React app for production (i.e., for deployment) via
    `npm run build` , you kick off a process that transforms this JSX code back to
    regular JavaScript instructions. As a developer, you don’t see those final instructions
    but React, the library, actually receives and evaluates them.
  prefs: []
  type: TYPE_NORMAL
- en: So, what does the JSX code get transformed to?
  prefs: []
  type: TYPE_NORMAL
- en: 'In modern React projects, it gets transformed to rather complex, unintuitive
    code that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this code is not very developer-friendly. It’s not the kind of code
    you would write. Instead, it’s the code produced by Vite (i.e., by the underlying
    build process) for the browser to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'But you could, in theory, write code like this instead of using JSX—if, for
    some reason, you wanted to avoid writing JSX code. React has a built-in method
    you can use instead of JSX: you can use React’s `createElement(…)` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a concrete example, first in JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using JSX, you could also write this component code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`createElement()` is a method built into the React library. It instructs React
    to create a paragraph element with `''Hello World!''` as child content (i.e.,
    as inner, nested content). This paragraph element is then created internally first
    (via a concept called the **virtual DOM** , which will be discussed later in the
    book, in *Chapter 10* , *Behind the Scenes of React and Optimization Opportunities*
    ). Thereafter, once all elements for all JSX elements have been created, the virtual
    DOM is translated into real DOM-manipulating instructions that are executed by
    the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'It has been mentioned before that React (in the browser) is actually a combination
    of two packages: `react` and `react-dom` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the introduction of `React.createElement(…)` , it’s now easier to explain
    how these two packages work together: React creates this virtual DOM internally
    and then passes it to the `react-dom` package. This package then generates the
    actual DOM-manipulating instructions that must be executed in order to update
    the web page such that the desired user interface is displayed there.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, this will be covered in greater detail in *Chapter 10* .
  prefs: []
  type: TYPE_NORMAL
- en: The middle parameter value ( `{}` , in the example) is a JavaScript object that
    may contain extra configuration for the element that is to be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example where this middle argument becomes important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be transformed to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The last argument that’s passed to `React.createElement(…)` is the child content
    of the element—i.e., the content that should be between the element’s opening
    and closing tags. For nested JSX elements, nested `React.createElement(…)` calls
    would be produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be transformed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using React without JSX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since all JSX code gets transformed to these native JavaScript method calls
    anyway, you can actually build React apps and user interfaces with React without
    using JSX.
  prefs: []
  type: TYPE_NORMAL
- en: You can skip JSX entirely if you want to. Instead of writing JSX code in your
    components and all the places where JSX is expected, you can simply call `React.createElement(…)`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following two snippets will produce exactly the same user
    interface in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet will ultimately be the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it’s a different question whether you would want to do this. As you
    can see in this example, it’s way more cumbersome to rely on `React.createElement(…)`
    only. You end up writing a lot more code and deeply nested element structures
    will lead to code that can become almost impossible to read.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why, typically, React developers use JSX. It’s a great feature that makes
    building user interfaces with React way more enjoyable. But it is important to
    understand that it’s neither HTML nor a vanilla JavaScript feature, but that it
    instead is some syntactical sugar that gets transformed to function calls behind
    the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: JSX Elements Are Treated Like Regular JavaScript Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because JSX is just syntactical sugar that gets transformed, there are a couple
    of noteworthy concepts and rules you should be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: JSX elements are just **regular JavaScript values** (functions, to be precise)
    in the end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same rules that apply to all JavaScript values also apply to JSX elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result, in a place where only one value is expected (e.g., after the `return`
    keyword), you must only have one JSX element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This code would cause an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The code might look valid at first, but it’s actually incorrect. In this example,
    you would return two values instead of just one. That is not allowed in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following non-React code would also be invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can’t return more than one value. No matter how you write it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can return an array or an object though. For example, this code
    would be valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be valid because you only return one value: an array. This array contains
    multiple values, as arrays typically do. That would be fine and the same would
    be the case if you used JSX code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This kind of code would be allowed since you are returning one array with two
    elements inside of it. The two elements are JSX elements in this case, but as
    mentioned earlier, JSX elements are just regular JavaScript values. Thus, you
    can use them anywhere where values would be expected.
  prefs: []
  type: TYPE_NORMAL
- en: When working with JSX, you won’t see this array approach too often though—simply
    because it can become annoying to remember wrapping JSX elements via square brackets.
    It also looks less like HTML, which kind of defeats the purpose and core idea
    behind JSX (it was invented to allow developers to write HTML code inside JavaScript
    files).
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, if sibling elements are required, as in these examples, a special
    kind of wrapping component is used: a React **fragment** . That’s a built-in component
    that serves the purpose of allowing you to return or define sibling JSX elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This special `<>…</>` element is available in most modern React projects (for
    instance, ones created via Vite), and you can think of it wrapping your JSX elements
    with an array behind the scenes. Alternatively, you can also use `<React.Fragment>…</React.Fragment>`
    . Since some React projects might not support the shorter `<>…</>` syntax, this
    built-in component is always available.
  prefs: []
  type: TYPE_NORMAL
- en: The parentheses ( `()` ) that are wrapped around the JSX code in all these examples
    are required to allow for nice multiline formatting. Technically, you could put
    all your JSX code into one single line, but that would be pretty unreadable. In
    order to split the JSX elements across multiple lines, just as you typically do
    with regular HTML code in `.html` files, you need those parentheses; they tell
    JavaScript where the returned value starts and ends.
  prefs: []
  type: TYPE_NORMAL
- en: Since JSX elements are regular JavaScript values (after being translated by
    the build process at least), you can also use JSX elements in all the places where
    values can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus far, that has been the case for all these `return` statements, but you
    can also store JSX elements in variables or pass them as arguments to other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will be important once you dive into slightly more advanced concepts like
    conditional or repeated content—something that will be covered in *Chapter 5*
    , *Rendering Lists and Conditional Content* .
  prefs: []
  type: TYPE_NORMAL
- en: JSX Elements Must Have a Closing Tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another important rule related to JSX elements is that they must always have
    a closing tag. Therefore, JSX elements must be self-closing if there is no content
    between the opening and closing tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In regular HTML, you would not need that forward backslash at the end. Instead,
    regular HTML supports void elements (i.e., `<img src="img/…">` ). You can add
    that forward slash there as well, but it’s not mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: When working with JSX, these forward slashes are mandatory if your element doesn’t
    contain any child content.
  prefs: []
  type: TYPE_NORMAL
- en: Moving Beyond Static Content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far, in all these examples, the content that was returned was static. It
    was content like `<p>Hello World!</p>` —which of course is content that never
    changes. It will always output a paragraph that says, `'Hello World!'` .
  prefs: []
  type: TYPE_NORMAL
- en: But most websites, of course, need to output dynamic content that may change
    (e.g., due to user input). Similarly, you’ll have a hard time finding lots of
    websites without any images.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, as a React developer, it’s important to know how to output dynamic content
    (and what “dynamic content” actually means) and how to display images in a React
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Outputting Dynamic Content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point in the book, you don’t yet have any tools to make the content
    more dynamic. To be precise, React requires that state concept (which will be
    covered in *Chapter 4* , *Working with Events and State* ) to change the content
    that is displayed (e.g., upon user input or some other event).
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonetheless, since this chapter is about JSX, it is worth diving into the syntax
    for outputting dynamic content, even though it’s not yet truly dynamic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This example technically still produces static output since `userName` never
    changes, but you can already see the syntax for outputting dynamic content as
    part of the JSX code. You use opening and closing curly braces ( `{…}` ) with
    a JavaScript expression (like the name of a variable or constant, as is the case
    here) between those braces.
  prefs: []
  type: TYPE_NORMAL
- en: You can put any valid JavaScript expression between those curly braces. For
    example, you can also call a function (e.g., `{getMyName()}` ) or do simple inline
    calculations (e.g., `{1 + 1}` ).
  prefs: []
  type: TYPE_NORMAL
- en: You can’t add complex statements like loops or `if` statements between those
    curly braces though. Again, standard JavaScript rules apply. You output a (potentially)
    dynamic value, and therefore, anything that produces a single value is allowed
    in that place. However, it’s worth noting that a few value types can’t be used
    for outputting a value in JSX. For example, trying to output a JavaScript object
    in JSX will cause an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also worth noting that you’re not limited to outputting dynamic content
    between element tags. Instead, you can also set dynamic values for attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Rendering Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most websites do not just display plain text. Instead, you often need to render
    images as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, when working with React, you can use the default `<img />` element
    like in any other web project. But there are two important things to keep in mind
    when displaying images in React projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<img />` must be a self-closing tag.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When displaying local images stored inside of the `src/` folder, you must import
    them into your `.jsx` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As explained above, in the *JSX elements must have a closing tag* section, you
    can’t have void JSX elements, i.e., elements without any closing tag.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, when outputting locally stored images (i.e., images stored in the
    project’s `src/` folder, not on some remote server), you typically don’t set a
    string path to the image in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be used to outputting images like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: But React projects (e.g., when created with Vite) do involve some kind of build
    process. In most projects, the final project structure that will be deployed onto
    a server will look quite different from the project structure you work on during
    development.
  prefs: []
  type: TYPE_NORMAL
- en: That being the case, if you store an image in the `src/assets` folder in a Vite-based
    React project, and you use that as a path ( `<img src="img/my-image.jpg" />` ),
    the image will not load on the deployed website. It will not load there because
    the deployable folder structure will not contain a `src/assets` folder anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, you can get an idea of the production-ready folder structure by running
    `npm run build` . This will build the project for deployment and produce a new
    `dist` folder in your project directory. It’s the content of that `dist` folder
    that will be deployed onto some server. If you inspect that folder, you won’t
    find a `src` folder in there.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: The dist folder contains a different structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Put in other words: You can’t tell the exact path of a locally stored image
    in advance. That’s why you should import the image file into your `.jsx` file.
    As a result, you’ll get a string value that will contain the actual path (which
    will work in production). This value can then be set as a dynamic value for the
    `src` attribute of the `<img />` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This might look strange at first, but it is code that will work in pretty much
    all React projects. Behind the scenes, this import gets analyzed by the underlying
    build process. The `import` statement then gets removed, and the image path is
    hardcoded into the production-ready output code (i.e., the code that’s stored
    in the `dist` folder).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important exception though: if you store an image file (or, actually,
    any asset) in the `public/` folder of your project, you can directly reference
    its path.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a `demo.jpg` image file stored in `public/images/demo.jpg` can
    be rendered and displayed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This works because the contents of the `public/` folder are simply copied into
    the `dist/` folder. Unlike the `src/` folder and its nested files, the `public/`
    folder files skip the transpilation step.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the public folder name itself is not part of the paths referenced—it’s
    `src="img/demo.jpg"` , not `src="img/demo.jpg"` .
  prefs: []
  type: TYPE_NORMAL
- en: Which approach should you use then? Store images in `src/` or `public/` ?
  prefs: []
  type: TYPE_NORMAL
- en: For most images, `src/` is a sensible choice since the pre-processing step assigns
    a unique file name to each imported file. As a result, files can be cached more
    efficiently once the application is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Any files imported in the root `index.html` file, or files where the file name
    must never change (e.g., because it’s also referenced by some other app, running
    on some other server) should typically go into the `public/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, in most cases, when outputting images that are stored locally in your
    project, you should store them in the `src/` folder and then import them into
    your JSX files. When using images that are stored on some remote server, you would
    instead use the full image URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When Should You Split Components?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you work with React and learn more and more about it, and as you dive into
    more challenging React projects, you will most likely come up with one very common
    question: *When should I split a single React component into multiple separate
    components?*'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier in this chapter, React is all about components, and it
    is therefore very common to have dozens, hundreds, or even thousands of React
    components in a single React project.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to splitting a single React component into multiple smaller components,
    there is no hard rule you must follow. As mentioned earlier, you could put all
    your UI code into one single, large component. Alternatively, you could create
    a separate custom component for every single HTML element and piece of content
    that you have in your UI. Both approaches are probably not that great. Instead,
    a good rule of thumb is to create a separate React component for every **data
    entity** that can be identified.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you’re outputting a “to-do” list, you could identify two main
    entities: the individual to-do item and the overall list. In this case, it could
    make sense to create two separate components instead of writing one bigger component.'
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of splitting your code into multiple components is that the individual
    components stay manageable because there’s less code per component and component
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when it comes to splitting components into multiple components, a
    new problem arises: *How do you make your components reusable and configurable?*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this example, all “to-dos” would be the same because we use the same `<Todo
    />` component, which can’t be configured. You might want to make it configurable
    by either adding custom attributes ( `<Todo text="Learn React!" />)` or by passing
    content between the opening and closing tags `(<Todo>Learn React!</Todo>` ).
  prefs: []
  type: TYPE_NORMAL
- en: And, of course, React supports this. In the next chapter, you will learn about
    a key concept called **props** , which allows you to make your components configurable
    like this.
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Key Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React embraces **components** : reusable building blocks that are combined
    to define the final user interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components must return **renderable** content – typically, JSX code that defines
    the HTML code that should be produced in the end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'React provides a lot of built-in components: besides special components like
    `<>…</>` , you get components for all standard HTML elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To allow React to tell custom components apart from built-in components, custom
    component names have to start with capital letters when being used in JSX code
    (typically, PascalCase naming is used)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSX is neither HTML nor a standard JavaScript feature – instead, it’s **syntactical
    sugar** provided by build workflows that are part of all React projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could replace JSX code with `React.createElement(…)` calls, but since this
    leads to significantly more unreadable code, it’s typically avoided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using JSX elements, you must not have sibling elements in places where
    single values are expected (e.g., directly after the `return` keyword)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSX elements must always be self-closing if there is no content between the
    opening and closing tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic content can be output via curly braces (e.g., `<p>{someText}</p>` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images can be rendered by referencing their paths (if stored remotely or in
    the `public/` folder) or by importing the image files into JSX files and outputting
    them with the dynamic content syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most React projects, you split your UI code across dozens or hundreds of
    components, which are then exported and imported in order to be combined again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned a lot about components and JSX. The next chapter
    builds upon this key knowledge and explains how you can make components reusable
    by making them configurable.
  prefs: []
  type: TYPE_NORMAL
- en: Before you continue, you can also practice what you have learned up to this
    point by going through the questions and exercises below.
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Knowledge!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your knowledge about the concepts covered in this chapter by answering
    the questions below. You can then compare your answers to example answers that
    can be found here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/exercises/questions-answers.md)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: What’s the idea behind using components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you create a React component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What turns a regular function into a React component function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which core rules should you keep in mind regarding JSX elements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is JSX code handled by React and ReactDOM?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply What You Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this and the previous chapter, you have all the knowledge you need to create
    a React project and populate it with some first, basic components.
  prefs: []
  type: TYPE_NORMAL
- en: Below, you’ll find your first two practical activities for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2.1: Creating a React App to Present Yourself'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you are creating your personal portfolio page, and as part of that page,
    you want to output some basic information about yourself (e.g., your name or age).
    You could use React and build a React component that outputs this kind of information,
    as outlined in the following activity.
  prefs: []
  type: TYPE_NORMAL
- en: The aim is to create a React app as you learned in the previous chapter (i.e.,
    create it via `npm create vite@latest <your-project-name>` and run `npm run dev`
    to start the development server) and edit the `App.jsx` file such that you output
    some basic information about yourself. You could, for example, output your full
    name, address, job title, or other kinds of information. In the end, it is up
    to you what content you want to output and which HTML elements you choose.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind this first exercise is that you practice project creation and
    working with JSX code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new React project via `npm create vite@latest <project>` . Alternatively,
    you can use the starting project snapshot provided here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-1-start)
    .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `App.jsx` file in the `/src folder` of the created project and return
    JSX code with any HTML elements of your choice to output basic information about
    yourself. You can use the styles in the `index.css` file in the starting project
    snapshot to apply some styling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, store an image in the `src/assets` folder and output it in the `App` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get output like this in the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: The final activity result—some user information being output on
    the screen'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Styling will of course differ. To get the same styling as shown in the screenshot,
    use my prepared starting project, which you can find here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-1-start)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the `index.css` file in that project to determine how to structure your
    JSX code to apply the styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll find an example solution on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/activities/practice-1/SOLUTION-INSTRUCTIONS.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/activities/practice-1/SOLUTION-INSTRUCTIONS.md)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Besides the linked instructions, you will also find the finished example solution
    code in the project folder that contains the `SOLUTIONS-INSTRUCTIONS.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: However, before you explore this solution, you should consider trying to solve
    this task on your own. Even if your result deviates from the example solution,
    or if you fail to come up with a working application, you’ll learn more by at
    least giving it a try because, as always in life, only practice makes perfect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2.2: Creating a React App to Log Your Goals for This Book'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you are adding a new section to your portfolio site, where you plan
    to track your learning progress. As part of this page, you plan to define and
    output your main goals for this book (e.g., *“Learn about key React features”*
    , *“Do all the exercises”* , etc.).
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to create another new React project in which you
    add **multiple new components** . Each goal will be represented by a separate
    component, and all these goal components will be grouped together into another
    component that lists all the main goals. In addition, you can add an extra header
    component that contains the main title for the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to complete this activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new React project via `npm create vite@latest <project>` , or use
    the project starting snapshot provided here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-2-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-2-start)
    .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the new project, create a `components` folder that contains multiple
    component files (for the individual goals as well as for the list of goals and
    the page header).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the different component files, define and export multiple component functions
    ( `FirstGoal` , `SecondGoal` , `ThirdGoal` , etc.) for the different goals (one
    component per file).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, define one component for the overall list of goals ( `GoalList` ) and
    another component for the page header ( `Header` ).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the individual goal components, return JSX code with the goal text and a
    fitting HTML element structure to hold this content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `GoalList` component, import and output the individual goal components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import and output the `GoalList` and `Header` components in the root `App` component
    (replace the existing JSX code).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply any style of your choice. You can also use the `index.css` file that’s
    part of the starting project snapshot for inspiration.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get the following output in the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_02_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: The final page output, showing a list of goals'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll also find an example solution for this activity on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/activities/practice-2/SOLUTION-INSTRUCTIONS.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/02-components-jsx/activities/practice-2/SOLUTION-INSTRUCTIONS.md)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: As before, besides the linked instructions, you will also find the finished
    example solution code in the project folder that contains the `SOLUTIONS-INSTRUCTIONS.md`
    file.
  prefs: []
  type: TYPE_NORMAL
