- en: Manipulating Streams and Their Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with a recap of the previous chapter and remind ourselves how far
    we have come already in understanding RxJS. We learned about concepts such as
    `Observable`, `Observer`, and `Producer`, and how they interplay. Furthermore,
    we got insight into the subscription process so we could actually receive our
    coveted values. We also looked at how unsubscribing from streams works and in
    which cases it is necessary to define such a behavior. Lastly, we got our hands
    dirty by learning how to build a core implementation of RxJS and thereby got to
    see all those concepts in action. Armed with all that knowledge, we should feel
    quite confident about the foundation of RxJS, but as was mentioned in the last
    chapter, we need help from operators to actually do something meaningful with
    our streams.
  prefs: []
  type: TYPE_NORMAL
- en: Let's not delay any further and start talking about this chapter. Operators
    are functions we can call on our streams to perform manipulation in many different
    ways. Operators are immutable, which makes the stream easy to reason about and
    will also make it quite easy to test. As you will see throughout this chapter,
    we will seldom deal with just one stream, but many streams, and it is understanding
    how to forge and control these streams that allows you to go from thinking it's
    *dark magic* to actually being able to apply RxJS when and where you need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use basic operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging streams with operators as well as with existing tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digging deeper into different operator categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the mindset to solve a problem the Rx way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You almost always start out coding with RxJS by creating a stream of static
    values. Why static values? Well, there is no need to make it unnecessarily complex,
    and all you really need to start reasoning is an `Observable`. As you gradually
    progress in your problem solving, you might replace the static values with a more
    appropriate call to an AJAX call, or from another asynchronous source that your
    values originate from.
  prefs: []
  type: TYPE_NORMAL
- en: You then start thinking about what you want to achieve. This leads you to consider
    which operators you might need and in which order you need to apply them. You
    might also think about how to divide your problem up; this usually means creating
    more than one stream, where each stream solves a specific problem that connects
    to the larger problem you are trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with stream creation and see how we can take our first steps working
    with streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates a stream of static values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That is a very basic example of how we can create a stream. We use the `of()`
    creation operator, which takes any number of arguments. All the arguments are
    emitted, one by one, as soon as there is a subscriber. In the preceding code,
    we also subscribe to `staticValuesStream$` by calling the `subscribe()` method
    and passing a function that takes the emitted value as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's introduce an operator, `map()`, which acts like a projection and allows
    you to change what is being emitted. The `map()` operator gets called on each
    value in the stream before it is emitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'You use the `map()` operator by supplying it with a function and carrying out
    a projection, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have appended the `map()` operator to `staticValuesStream$`
    and we apply it to each value before emitting it and incrementing it by one. The
    resulting data is therefore changed. This is how you append operators to a stream:
    simply create the stream, or take an existing one, and append the operators one
    by one.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's add another operator, `filter()`, to ensure that we really understand
    how to work with operators. What does `filter()` do. Well, just like the `map()`
    operator, it is applied to each value, but instead of creating a projection, it
    decides which values will be emitted. `filter()` takes a Boolean. Any expression
    evaluated to `true` means the value will be emitted; if `false`, the expression
    will not be emitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'You use the `filter()` operator in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We add the `filter()` operator by chaining it to the existing `map()` operator.
    The condition we give our `filter()` operator says to only return `true` for values
    that are divisible by `2`, that's what the modulus operator does. We know from
    before that the `map()` operator alone ensures that the values `2`, `3` , `4`,
    and `5` are emitted. These are the values that are now being evaluated by the
    `filter()` operator. Out of those four values, only `2` and `4` fulfill the condition
    set out by the `filter()` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, when working on a stream and applying operators, things might not
    always be as simple as the preceding code. It might not be possible to anticipate
    exactly what gets emitted. For those occasions, we have a few tricks we can use.
    One such trick is to use the `do()` operator, which will allow us to inspect each
    value without changing it. This gives us ample opportunity to use it for debugging
    purposes. Depending on where we are in the stream, the `do()` operator will output
    different values. Let''s look at different situations where it matters where the
    `do()` operator is applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, just by using the `do()` operator, we have a nice way to debug
    our streams, which becomes necessary as our streams grow in complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have shown how to create a stream and use some very basic operators
    on it to change what values get emitted. We also introduced how to inspect your
    stream without changing it by using the `do()` operator. Not all operators are
    as easy to understand as the `map()`, `filter()`, and `do()` operators. There
    are different tactics you can use to try to understand what each operator does
    so you know when to use them. Using the `do()` operator is one way, but there
    is a graphical approach you can take. This approach is known as a marble diagram.
    It consists of an arrow that represents time passing from left to right. There
    are circles, or marbles, on this arrow that represent emitted values. The marbles
    have a value in them, but the distance between the marbles might also describe
    what is happening over time. A marble diagram usually consists of at least two
    arrows with marbles on them, as well as an operator. The idea is to represent
    what happens to a stream when an operator is applied. The second arrow usually
    represents the resulting stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a marble diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/507d307c-1f03-4121-84f7-72db33991da2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Most operators in RxJS are depicted by a marble diagram on the site RxMarbles:
    [http://rxmarbles.com/](http://rxmarbles.com/). This is a truly great resource
    to quickly gain an understanding of what operators do. However, to truly understand
    RxJS you need to code; there is no getting around it. There are different ways
    of doing that of course. You can easily set up your own project and install RxJS
    from NPM, refer to it through a CDN link, or you can use a page such as JS Bin
    ([www.jsbin.com](http://www.jsbin.com)), which gives you the ability to easily
    add RxJS as a library and allows you to start coding straight away. It looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/369e27bb-a874-4e66-976f-1231b6e63380.png)'
  prefs: []
  type: TYPE_IMG
- en: 'JS Bin makes it easy to start, but wouldn''t it be great if we could combine
    marble diagrams and JS Bin, and get a graphical representation of what you code,
    when you code? You can get just that with RxFiddle: [http://rxfiddle.net/](http://rxfiddle.net/).
    You can enter your code, click Run, and you are shown a marble diagram of what
    you just coded, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83235f79-246c-4f3e-be8c-d37e893bc8f8.png)'
  prefs: []
  type: TYPE_IMG
- en: Stream in a stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have been looking at different operators that change the values being emitted.
    There is another different aspect to streams: what if you need to create a new
    stream from an existing stream? Another good question is: when does such a situation
    usually occur? There are plenty of situations, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Based on a stream of keyUp events, do an AJAX call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Count the number of clicks and determine whether the user single, double, or
    triple-clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You get the idea; we are starting with one type of stream that needs to turn
    into another type of stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first have a look at creating a stream and see what happens when we
    try to create a stream as the result of using an operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, every value that passes through the `map()` operator produces
    a new `Observable`. When you subscribe to `stream$`, each value that is emitted
    will be a stream. Your first instinct might be to attach a `subscribe()` to each
    of those values, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Fight this urge. This will only create code that is hard to maintain. What you
    want to do is merge all these streams into one so, that you just need one `subscribe()`.
    There is an operator just for that, called `flatMap()`. What `flatMap()` does
    is to take your array of streams and turn them into one stream, a metastream.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, we get it, we don''t want a stream of Observables, but rather a stream
    of values. This operator seems really great. We still aren''t quite certain when
    to use though. Let''s make this a bit more realistic. Imagine you have a UI that
    consists of an input field. The user enters characters into that input field.
    Imagine that you want to react to one or more characters being entered and, for
    example, perform an AJAX request as the result of characters being entered. We
    focus on two things here: how to collect characters being entered and how to perform
    an AJAX request.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let'' start with the first thing, capturing characters entered into an input
    field. For this, we need an HTML page and a JavaScript page. Let''s start with
    the HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This depicts our input element and a script reference to RxJS, as well as a
    reference to the `app.js` file. Then we have `app.js` file, where we get a reference
    to the input element and start listening to keystrokes as soon as they are entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Worth highlighting is the fact that we start listening to `keyup` events being
    emitted by calling the `fromEvent()` creation operator. Thereafter, we apply the
    `map()` operator to dig out the character value store on `ev.key`. Lastly, we
    subscribe to the stream. As expected, running this code will lead to characters
    being typed in the console as soon as you input values in the HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make this more tangible by doing an AJAX request based on what we type.
    For this, we will be using the `fetch()` API and an online API called swapi (swapi.com),
    which contains a collection of APIs containing information on the Star Wars movies.
    Let's first define our AJAX call and then see how it fits into our existing stream
    of keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'We said we would use `fetch()`. It lets us formulate a GET request as simple
    as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we want to turn this request into an `Observable` so that it can
    play well with our `keyStream$`. Fortunately for us, this is easily accomplished
    through the use of the `from()` operator. Let''s, however, first rewrite our `fetch()`
    call into a method that''s easy to work with. The result of the rewrite looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This code allows us to provide an argument used to construct a URL which we
    use to fetch some data with AJAX. At this point, we are ready to connect our function
    to our existing stream. We do that by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We highlight the usage of the `flatmap()` operator in bold using our `from()`
    conversion operator. The operator mentioned last takes our `getStarwarsCharacterStream()`
    function as a parameter. The `from()` operator converts said function into a stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have learned how to connect two different streams, but also how to
    convert a `Promise` into a stream. As good as this approach seems on paper, using
    `flatMap()` has its limitations and it is important to understand what they are.
    For that reason, let''s talk about the `switchMap()` operator next. The benefits
    of using a `switchMap()` operator will become clearer when we execute long-running
    tasks. For argument''s sake, let''s define such a task, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we have a function that takes 5 seconds to execute; enough time
    to show the point we are trying to make. Next, let''s show what the effect is
    if we keep using the `flatMap()` operator in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code works in the following way: every time we hit a key, it
    generates an event. However, we have a `.filter()` operator in place that ensures
    an event is only generated when at least four keys are entered, `filter(key =>
    elem.value.length >3)`. Let''s talk about the user''s expectation at this point.
    If a user enters keys in an input control, they most likely expect a request to
    be made when they are done typing. A user defines being done as entering a few
    characters and also that they should be able to remove characters if they were
    mistyped. So, therefore, we can assume the following input sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, they have entered characters and, within a reasonable amount
    of time, edited their answer. The user expects to receive an answer based on `abcd`.
    Using the `flatMap()` operator, however, means the user will get two answers back
    because, in reality, they typed `abcde` and `abcd`. Imagine we get a results list
    based on these two inputs; it would most likely be two lists that looked somewhat
    different. The response based on our code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28c01006-1de6-4bc6-9a3a-4dde658279ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our code most likely would be able to handle the situation described by rerendering
    the results list as soon as a new response arrives. There are two problems with
    this though: firstly, we do an unnecessary network request for `abcde`, and secondly,
    if the backend is fast enough in responding, we will see a flickering in the UI
    as the result list is rendered once and then, shortly after, is rendered again,
    based on the second response. This is not good, and we want to have a situation
    where the first request will be abandoned if we keep on typing. This is where
    the `switchMap()` operator comes in. It does exactly that. Let''s therefore alter
    the preceding code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we simply switched our `flatMap()` to a `switchMap()`. When we
    now execute the code in the exact same way, that is, the user firstly typing `12345`
    and shortly altering that to `1234`, the end result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4903a7a2-7634-4617-9a3a-a56b3c16ad4a.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we get one request only. The reason for this is that the previous
    event is aborted when a new event happens—`switchMap()` is doing its magic. The
    user is happy and we are happy.
  prefs: []
  type: TYPE_NORMAL
- en: AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already touched upon the topic of making AJAX requests. There are many
    ways to make AJAX requests; the two most common approaches are:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the fetch API; the fetch API is a web standard and is thus built into
    most browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `ajax()` method, nowadays built into the RxJS library; it used to
    exist in a library called Rx.Dom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fetch()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fetch()` API is a web standard. You can find the official documentation
    at the following link: [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
    The `fetch()` API is `Promise`-based, which means we need to convert it to an
    `Observable` before use. The API exposes a `fetch()` method, which takes a mandatory
    URL parameter as the first argument, with the second argument being an optional
    object that allows you to control which body to send, if any, which HTTP verb
    to use, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already mentioned how to best deal with it in the context of RxJS.
    It is worth repeating though. It is not as simple as just taking our fetch and
    sticking it into the `from()` operator though. Let''s write some code and see
    why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We get our data right? Sorry, no, we get a `Response` object back. But that''s
    easy, just call a `json()` method in the `map()` operator and surely then we have
    our data? Again, sorry no, the `json()` method returns a `Promise` when you type
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already shown a possible solution to this in the previous section,
    and that is the following construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'What we did in this code was to simply take care of digging out our data before
    handing it over to the `from()` operator. It doesn''t feel quite RxJS to play
    around with Promises. There is a more stream-based approach you can take; we were
    almost there before, we just needed to make a minor adjustment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And there it is: our `fetch()` call is now providing us data like a stream.
    So what did we do? Well, we changed our `map()` call to a `flatMap()` call. The
    reason for that was that when we called `r.json()`, we got a `Promise`. We fixed
    that by wrapping it in a `from()` call, `Rx.Observable.from(r.json())`. That would
    make the stream emit a `PromiseObservable` unless we changed from `map()` to `flatMap()`.
    As we learned in the previous section, if we risk creating a stream within a stream,
    we need `flatMap()` to come to our rescue, which it did.'
  prefs: []
  type: TYPE_NORMAL
- en: ajax() operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike the `fetch()` API, which is `Promise`-based, the `ajax()` method is
    actually `Observable`-based, which makes our job a little easier. Using it is
    quite straightforward, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the preceding code calls the `ajax()` operator with a URL as
    an argument. The second thing worthy of mentioning is the call to the `map()`
    operator, which digs out our data from the `response` property. Because it is
    an `Observable`, we just have to subscribe to it as usual by calling the `subscribe()`
    method and providing it with a listener function as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'This covers a simple case when you want to fetch data using the HTTP verb `GET`.
    Fortunately for us, it is quite easy to create, update, or delete by using an
    overloaded version of the `ajax()` operator which takes an `AjaxRequest` object
    instance which has the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from this object specification, all the fields are optional and
    there are also quite a few things we can configure with our request, such as `headers`,
    `timeout`, `user`, `crossDomain`, and so on; pretty much what we would expect
    from a nice AJAX wrapping functionality. Except for the overload of the `ajax()`
    operator, a few shorthand options also exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get()`: Fetches data using the `GET` verb'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`put()`: Updates data using the `PUT` verb'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post()`: Creates data using the `POST` verb'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patch()`: The idea with using the `PATCH` verb is to update a partial resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete()`: Removes data using the `DELETE` verb'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getJSON()`: Fetches data using the `GET` verb and sets the response type to
    `application/json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cascading calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered the two main ways you will use AJAX to send or receive
    data. When it comes to receiving data, it's usually not as simple as fetching
    the data and rendering it. In fact, you will most likely have a dependency on
    when you can fetch which data. A typical example of this is needing to perform
    a login call before you can fetch the remaining data. In some cases, it might
    be that you need to first log in, then fetch the data of the logged in user, and
    once you have that you can fetch messages, orders, or whichever kind of data you
    need that might be specific to a certain user. This whole phenomenon of fetching
    data in this way is called cascading calls.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at how we use cascading calls with Promises and gradually
    learn how to do the same with RxJS. We are taking this little detour as we assume
    that most of you reading this book are familiar with Promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the dependent case we first mentioned, where we need to perform
    the following steps in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: The user first logs in to the system
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we fetch information about the user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we fetch information about the user's orders
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using promises, it would look something like this in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This code describes how we first log in to the system, using the `login()`
    method, and obtain a token. We use this token in any future calls to ensure we
    make authenticated calls. We also see how we perform the `getUser()` call and
    obtain a user instance. We use that same user instance to perform our last call,
    `getOrders()`, whereby the user ID is used as a routing parameter: `` `/orders/user/${user.id}`
    ``.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have shown how to perform cascading calls using promises; we did this to
    establish a common ground for the problem we are trying to solve. The RxJS approach
    is very similar: we have shown that the `ajax()` operator exists and makes our
    lives easier when dealing with AJAX calls. To achieve the cascading calls effect
    with RxJS, we simply need to use the `switchMap()` operator. This will lead to
    our code looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We have highlighted the parts that need changing in the preceding code. In
    short, the changes are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetch()` is replaced by the `ajax()` operator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We call `.map(r => r.response)` instead of `.then(r => r.json())`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do `.switchMap()` calls for each cascading call instead of `.then(getOrders)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is one more interesting aspect that we need to cover, namely that of
    parallel calls. When we fetched the user and the order, we waited for a previous
    call to fully complete before we initiated the next call. In a lot of cases, this
    might not be strictly necessary. Imagine that we have a similar case to the previous
    one, but there is a lot of interesting information surrounding the user that we
    want to fetch. Instead of just fetching orders, the user might have a friends
    collection or a collection of messages. The precondition for fetching that data
    is only that we fetched the user, so we know which collection of friends we should
    query for and which collection of messages we need. In the world of promises,
    we would use the `Promise.all()` construct to achieve parallelization. With that
    in mind, we update our `Promise` code to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the preceding code, we introduce the new `getUsersData()`
    method, which fetches orders, messages, and friends collections in parallel, making
    our app responsive sooner, as the data will arrive sooner than if we just fetched
    it one after another.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily achieve the same thing with RxJS by introducing the `forkJoin()`
    operator. It takes a list of streams and fetches everything in parallel. We therefore
    update our RxJS code to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A deeper look
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have had a look at some operators that will let you create streams
    or change streams with the `map()` and `filter()` operators, we have learned how
    to manage different AJAX scenarios, and so on. The basics are there, but we haven''t
    really approached the topic of operators in a structured way. What do we mean
    by that? Well, operators can be thought of as belonging to different categories.
    The number of operators at our disposal is a staggering 60 plus. It''s going to
    take us time to learn all that, if we ever do. Here is the thing though: we just
    need to know which different types of operators exist so that we can apply them
    where appropriate. This reduces our cognitive load and our memory. Once we know
    which categories we have, we just have to drill down, and most likely we will
    end up knowing 10-15 operators in total and the rest we can just look up when
    we need them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, we have the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creation operators**: These operators help us create streams in the first
    place. Almost anything can be converted into a stream with the help of these operators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Combination operators**: These operators help us combine values as well as
    streams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mathematical operators**: These operators perform mathematical evaluations
    on the values being emitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time-based operators**: These operators change at which speed values are
    emitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grouping operators**: The idea with these operators is to operate on a group
    of values rather than individual ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use creation operators to create the streams themselves, because let''s
    face it: what we need to turn into a stream isn''t always going to be a stream,
    but by making it into a stream, it will have to play nicely with other streams
    and, best of all, will get to leverage the full power of using operators.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what do these other non-streams consist of? Well, it could be anything asynchronous
    or synchronous. The important thing is that it is data that needs to be emitted
    at some point. Therefore, a range of creation operators exist. In the coming subsections,
    we will present a subset of all those that exist, enough for you to realize the
    power of turning anything into a stream.
  prefs: []
  type: TYPE_NORMAL
- en: of() operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already had the chance to use this operator a few times. It takes an
    unknown number of comma-separated arguments, which can be integers, strings, or
    objects. This is an operator you want to use if you just want to emit a limited
    set of values. To use it, simply type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen from the code, it really doesn't matter what we place in our
    `of()` operator, it is able to emit it anyway.
  prefs: []
  type: TYPE_NORMAL
- en: from() operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This operator can take arrays or a `Promise` as input and turn them into a
    stream. To use it, simply call it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This saves us a lot of headache by not having to deal with different types of
    asynchronous calls.
  prefs: []
  type: TYPE_NORMAL
- en: range() operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This operator lets you specify a range, a number to start from and a number
    to end on. This is a nice shorthand that quickly lets you create a stream with
    a range of numbers. To use it, simply type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: fromEvent() operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it gets really interesting. The `fromEvent()` operator allows us to mix
    a UI event such as a `click` or a `scroll` event and turn it into a stream. So
    far, we have operated under the assumption that asynchronous calls is something
    that only has to do with AJAX calls. This is far from true. The fact that we can
    mix UI events with any type of asynchronous calls creates a really interesting
    situation that allows us to compose really powerful, expressive code. We will
    touch on this topic further in the coming section, *Thinking in streams*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this operator, you need to provide it with two arguments: a DOM element
    and the name of an event, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Combination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Combination operators are about combining values from different streams. We
    have a few operators at our disposal that can help us out. This kind of operator
    makes sense when we, for some reason, don't have all the data in one place but
    need to acquire it from more than one place. Combining data structures from different
    sources could be tedious and error-prone work if it weren't for the powerful operators
    we are about to describe.
  prefs: []
  type: TYPE_NORMAL
- en: merge() operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `merge()` operator takes data from different streams and combines it. Here
    is the thing though: these streams can be of any kind as long as they are of type
    `Observable`. This means we can combine data from a timing operation, a promise,
    static data from an `of()` operator, and so on. What merging does is to interleave
    the emitted data. This means that it will emit from both streams at the same time
    in the following example. Using the operator comes in two flavors, as a static
    method but also as an instance method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The takeaway here is that if you just need to combine one stream with another,
    then use the instance method version of this operator, but if you have several
    streams, then use the static version. Furthermore, the order in which the streams
    are specified matters.
  prefs: []
  type: TYPE_NORMAL
- en: combineLatest()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you have a situation where you have set up connections with several
    endpoints that serve you with data. What you care about is the latest data that
    was emitted from each endpoint. You might be in a situation where one or several
    endpoints stop sending data after a while and you want to know what the last thing
    that happened was. In this situation, we want the ability to combine all the latest
    values from all of the involved endpoints. That''s where the `combineLatest()`
    operator comes in. You use it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: What we can see here is that `firstStream$` stops emitting values after a while
    thanks to the `take()` operator, which limits the number of items. However, the
    `combineLatest()` operator ensures we are still given the very last value `firstStream$`
    emitted.
  prefs: []
  type: TYPE_NORMAL
- en: zip()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The point of this operator is to stitch as many values together as possible.
    We may be dealing with continuous streams, but also with streams that have a limit
    to the number of values they emit. You use this operator in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, here, we stitch values together vertically, and by the least
    common denominator, `thirdStream$` is the shortest, calculating the number of
    emitted values. This means we will take values from left to right and zip them
    together. As `thirdStream$` only has two values, we end up with only two emits.
  prefs: []
  type: TYPE_NORMAL
- en: concat()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At first look, the `concat()` operator looks like another `merge()` operator,
    but this is not entirely true. The difference is that a `concat()` waits for other
    streams to be completed first before emitting a stream from the next stream in
    order. How you arrange your stream in your call to `concat()` matters. The operator
    is used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Mathematical
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mathematical operators are simply operators that carry out mathematical operations
    on values, such as finding the largest or smallest value, summarizing all values,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: max
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `max()` operator finds the largest value. This comes in two flavors: we
    either just call the `max()` operator with no arguments, or we give it a `compare`
    function. The `compare` function then decides whether something is larger than,
    smaller than, or equal to an emitted value. Let''s have a look at the two different
    versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding code that we get one result back and it is the largest
    one.
  prefs: []
  type: TYPE_NORMAL
- en: min
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `min()` operator is pretty much the opposite of the `max()` operator; it
    comes in two flavors: with parameter and without parameter. Its task is to find
    the smallest value. To use it, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: sum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There used to be an operator called `sum()`, but it hasn''t existed for several
    versions. What there is instead is `.reduce()`. With the `reduce()` operator,
    we can easily achieve the same thing. The following is how you would write a `sum()`
    operator using `reduce()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'What this does is to loop through all the emitted values and sum up the results.
    So, in essence, it sums up everything. Of course, this kind of operator can not
    only be applied to numbers, but to objects as well. The difference lies in how
    you carry out the `reduce()` operation. The following example covers such a scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, the `reduce()` operator ensures that
    all the object's properties get merged together into one object.
  prefs: []
  type: TYPE_NORMAL
- en: Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time is a very important concept when talking about streams. Imagine you have
    multiple streams that have different bandwidths, or one stream is just faster
    than the other, or you have a scenario where you want to retry an AJAX call within
    a certain time interval. In all of these situations, we need to control how fast
    the data is being emitted, and time plays an important role in all these scenarios.
    At our disposal, we have a ton of operators that, like a magician, enable us to
    craft and control our values as we see fit.
  prefs: []
  type: TYPE_NORMAL
- en: interval() operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JavaScript, there is a `setInterval()` function that enables you to execute
    code at regular intervals, up until the point that you choose to stop it. RxJS
    has an operator that behaves just like that, the `interval()` operator. It takes
    one parameter: normally, the number of milliseconds between emitted values. You
    use it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A word of caution is that this operator will continue emitting until you stop
    it. The best way to stop it is to combine it with a `take()` operator. A `take()`
    operator takes a parameter that specifies how many emitted values it wants before
    stopping. The updated code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: timer() operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `timer()` operator has the job of emitting values after a certain amount
    of time. It comes in two flavors: you either emit just one value after a number
    of milliseconds, or you keep on emitting values with a certain amount of delay
    between them. Let''s look at the two different flavors available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: delay() operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `delay()` operator delays all the values being emitted and is used in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: sampleTime() operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `sampleTime()` operator is used to only emit values after the sample period
    has passed. A good use case for this is when you want to have a *cooldown* functionality.
    Imagine you have users that press a Save button way too often. It might be that
    saving takes a few seconds to complete. A way to approach this is to disable the
    Save button while saving. Another valid approach is to simply ignore any presses
    of the button until the operation has had the chance to complete. The following
    code does just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: debounceTime() operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `sampleTime()` operator was able to ignore the user for a certain period
    of time, but the `debounceTime()` operator takes a different approach. Debounce
    as a concept means that we wait for things to calm down before emitting a value.
    Imagine an input element that the user types into. The user will stop typing eventually.
    We want to make sure the user has actually stopped, so we wait for a while before
    we actually do something. This is what the `debounceTime()` operator does for
    us. The following example shows how we can listen to the user typing into an input
    element, wait for the user to stop typing, and lastly, perform an AJAX call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: When the user then types a number in the text box, the keyup event will be triggered
    after 2 seconds of inactivity. After that, an AJAX call will be carried out using
    our text box input.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Grouping operators allow us to operate on a group of collected events rather
    than one emitted event at a time.
  prefs: []
  type: TYPE_NORMAL
- en: buffer() operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea with the `buffer()` operator is that we can collect a bunch of events
    without them being emitted straight away. The operator itself takes an argument,
    an `Observable` that defines when we should stop collecting events. At that point
    in time, we can choose what to do with those events. Here is how you can use this
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: What this does is to collect events until there has been 2 seconds of inactivity.
    At that point, we release all the key events we have buffered up. When we release
    all those events, we can, for example, send them somewhere via AJAX. This is a
    typical scenario in a chat application. Using the preceding code, we can always
    send the latest character that has been typed.
  prefs: []
  type: TYPE_NORMAL
- en: bufferTime() operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very similar operator to `buffer()` is `bufferTime()`. This one lets us specify
    how long we would like to buffer events for. It is a bit less flexible than `buffer()`,
    but can still be quite useful.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking in streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have gone through a bunch of scenarios that have shown us which
    operators are at our disposal and how they can be chained. We have also seen how
    operators such as `flatMap()` and `switchMap()` can really change things as we
    move from one type of observable to another. So, which approach should you take
    when working with Observables? Obviously, we need to express an algorithm using
    operators, but where do we start? The first thing we need to do is to think of
    the start and the end. Which types of events do we want to capture and what should
    the end result look like? That already gives us a hint as to the number of transformations
    we need to carry out to get there. If we want to transform the data only, then
    we can probably make do with a `map()` operator and a `filter()` operator. If
    we want to transform from one `Observable` to the next, then we need a `flatMap()`
    or a `switchMap()`. Do we have a specific behavior, such as waiting for the user
    to stop typing? If so, then we need to look at `debounceTime()` or similar. It''s
    really the same as all problems: break it down, see which parts you have, divide,
    and conquer. Let''s try to break this down into a list of steps though:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the inputs? UI events or something else?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the outputs? The end result?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the second bullet, which transformations do I need to get there?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do I deal with more than one stream?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do I need to handle errors, and if so, how?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This has hopefully introduced you to how to think about streams. Remember, start
    small and work your way toward your goal.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We set out to learn more about basic operators. In doing so, we encountered
    the `map()` and `filter()` operators, which allowed us to control what was being
    emitted. Knowledge of the `do()` operator gave us a way to debug our streams.
    Furthermore, we learned about the existence of sandboxed environments, such as
    JS Bin and RxFiddle, and how they can help us to quickly get started with RxJS.
    AJAX was the next topic that we delved into, and we built an understanding of
    the different scenarios that might occur. Moving on deeper into RxJS, we looked
    at different operator categories. We barely scratched the surface on that one,
    but it offered us a way to approach how to learn which types of operators are
    in the library. Finally, we finished off this chapter by looking at how to change
    and develop our mindset to thinking about streams.
  prefs: []
  type: TYPE_NORMAL
- en: It is with all this acquired knowledge that we are now ready to venture into
    more advanced Rx topics in the next chapter. We know our basics, now the time
    has come to master them.
  prefs: []
  type: TYPE_NORMAL
