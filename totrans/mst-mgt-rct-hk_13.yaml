- en: '*Chapter 10*: Use Case Scenario 4 – React Tracked'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 10 章*：用例场景 4 – React Tracked'
- en: React Tracked ([https://react-tracked.js.org](https://react-tracked.js.org))
    is a library for state usage tracking that optimizes re-renders automatically
    based on property access. It provides the same functionality to eliminate extra
    re-renders as Valtio, which we discussed in [*Chapter 9*](B17780_09_Final_VK_ePub.xhtml#_idTextAnchor116),
    *Use Case Scenario 3 – Valtio*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: React Tracked ([https://react-tracked.js.org](https://react-tracked.js.org))
    是一个用于状态使用跟踪的库，它根据属性访问自动优化重新渲染。它提供了与 Valtio 相同的功能，我们在 [*第 9 章*](B17780_09_Final_VK_ePub.xhtml#_idTextAnchor116)，*用例场景
    3 – Valtio* 中讨论过，以消除额外的重新渲染。
- en: React Tracked can be used with other state management libraries. The primary
    use case is `useState` or `useReducer`, but it can also be used with Redux ([https://redux.js.org](https://redux.js.org)),
    Zustand (discussed in [*Chapter 7*](B17780_07_Final_VK_ePub.xhtml#_idTextAnchor092),
    *Use Case Scenario 1 – Zustand*), and other similar libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: React Tracked 可以与其他状态管理库一起使用。主要用例是 `useState` 或 `useReducer`，但它也可以与 Redux ([https://redux.js.org](https://redux.js.org))、Zustand（在第
    [*第 7 章*](B17780_07_Final_VK_ePub.xhtml#_idTextAnchor092)，*用例场景 1 – Zustand*）和其他类似库一起使用。
- en: In this chapter, we will again discuss optimizing re-renders with state usage
    tracking and compare related libraries. We will learn two usages of React Tracked,
    one with `useState` and the other with React Redux ([https://react-redux.js.org](https://react-redux.js.org)).
    We will wrap up with a look at how React Tracked will work with the future version
    of React.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将再次讨论使用状态使用跟踪优化重新渲染，并比较相关库。我们将学习 React Tracked 的两种用法，一种与 `useState` 一起使用，另一种与
    React Redux ([https://react-redux.js.org](https://react-redux.js.org)) 一起使用。我们将以查看
    React Tracked 将如何与 React 的未来版本一起工作来结束。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding React Tracked
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 React Tracked
- en: Using React Tracked with `useState` and `useReducer`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Tracked 和 `useState` 以及 `useReducer`
- en: Using React Tracked with React Redux
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Tracked 和 React Redux
- en: Future prospects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来展望
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You are expected to have a moderate amount of knowledge about React, including
    React Hooks. Refer to the official site, [https://reactjs.org](https://reactjs.org),
    to learn more.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 预期你有一定的 React 知识，包括 React Hooks。请参考官方网站 [https://reactjs.org](https://reactjs.org)
    了解更多。
- en: In some code, we use TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org)),
    and you should have basic knowledge of it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些代码中，我们使用了 TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org))，你应该对其有基本了解。
- en: 'The code in this chapter is available on GitHub: [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_10](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_10).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_10](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_10)。
- en: To run the code snippets, you need a React environment – for example, Create
    React App ([https://create-react-app.dev](https://create-react-app.dev)) or CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码片段，你需要一个 React 环境 - 例如，Create React App ([https://create-react-app.dev](https://create-react-app.dev))
    或 CodeSandbox ([https://codesandbox.io](https://codesandbox.io))。
- en: Understanding React Tracked
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 React Tracked
- en: We have been learning about several global state libraries, but React Tracked
    is slightly different from the ones we have learned about so far. React Tracked
    doesn't provide state functionality, but what it does provide is render optimization
    functionality. We call this functionality **state usage tracking**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了几种全局状态库，但 React Tracked 与我们之前学过的略有不同。React Tracked 不提供状态功能，但它提供的是渲染优化功能。我们称这种功能为
    **状态使用跟踪**。
- en: Let's recap how React Context behaves because one of the use cases of state
    usage tracking in React Tracked is for a React Context.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 React Context 的行为，因为 React Tracked 中状态使用跟踪的一个用例是针对 React Context。
- en: 'Suppose we define a Context with `createContext` as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用 `createContext` 定义了一个 Context，如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`createContext` takes an initial value, which is an array in this case. The
    first item in the array is an initial state object. The second item in the array,
    `() => {}`, is a dummy updating function.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`createContext` 接收一个初始值，在这个例子中是一个数组。数组中的第一个元素是一个初始状态对象。数组中的第二个元素，`() => {}`，是一个占位符更新函数。'
- en: 'The reason we put such an array as the initial value is to match the return
    value of `useState`. We often define `NameProvider` with `useState` for a global
    state:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以将这样的数组作为初始值，是为了匹配 `useState` 的返回值。我们经常使用 `useState` 定义 `NameProvider` 以实现全局状态：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should usually use the `NameProvider` component in a root component or some
    component close to it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常应该在根组件或靠近根组件的某个组件中使用 `NameProvider` 组件。
- en: 'Now that we have the `NameProvider` component, we can consume it under its
    tree. To consume the Context value, we use `useContext`. Let''s assume we only
    need `firstName` and define a `useFirstName` hook:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `NameProvider` 组件，我们可以在其树结构下使用它。为了使用 Context 值，我们使用 `useContext`。假设我们只需要
    `firstName`，并定义一个 `useFirstName` 钩子：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This works fine. However, there's a possibility of extra re-renders. If we update
    only `lastName` without changing `firstName`, the new Context value will be propagated
    and `useContext(NameContext)` triggers a re-render. The `useFirstName` hook only
    reads `firstName` from the Context value. Hence, this becomes an extra re-render.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这没问题。然而，存在额外的重新渲染的可能性。如果我们只更新 `lastName` 而不改变 `firstName`，新的 Context 值将被传播，并且
    `useContext(NameContext)` 触发重新渲染。`useFirstName` 钩子只从 Context 值中读取 `firstName`。因此，这成为了一个额外的重新渲染。
- en: This behavior is obvious from an implementation point of view. But from a developer's
    point of view, it doesn't seem ideal because it only uses `firstName` from the
    Context value. From the developer's point of view, the expectation would be that
    it doesn't depend on other properties – in this case, `lastName`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从实现的角度来看，这种行为是明显的。但从开发者的角度来看，这并不理想，因为它只使用了 Context 值中的 `firstName`。从开发者的角度来看，期望它不依赖于其他属性——在这种情况下，`lastName`。
- en: State usage tracking is the feature that realizes this expected behavior. If
    we only use `firstName` in the state object, we expect the hook to trigger re-renders
    only when `firstName` changes. This can be accomplished with proxies.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 状态使用跟踪是实现这种预期行为的功能。如果我们只在状态对象中使用 `firstName`，我们期望钩子只在 `firstName` 变化时触发重新渲染。这可以通过代理实现。
- en: 'React Tracked allows us to define a hook called `useTracked`, which can be
    used instead of `useContext(NameContext)`. `useTracked` wraps the state with proxies
    and tracks its usage. The expected usage of `useTracked` looks like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: React Tracked 允许我们定义一个名为 `useTracked` 的钩子，它可以替代 `useContext(NameContext)`。`useTracked`
    使用代理包装状态并跟踪其使用情况。`useTracked` 的预期用法如下：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The usage doesn't differ from the usage of `useContext(NameContext)`. This is
    the whole point of state usage tracking. Our code looks just as usual, but behind
    the scenes, it tracks the state usage and optimizes renders automatically.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法与 `useContext(NameContext)` 的用法没有区别。这正是状态使用跟踪的全部要点。我们的代码看起来和平时一样，但幕后它跟踪状态使用并自动优化渲染。
- en: 'Automatic render optimization was discussed in [*Chapter 9*](B17780_09_Final_VK_ePub.xhtml#_idTextAnchor116),
    *Use Case Scenario 3 – Valtio*. React Tracked and Valtio use the same state usage
    tracking feature. Actually, they use the same internal library, which is called
    `proxy-compare`: [https://github.com/dai-shi/proxy-compare](https://github.com/dai-shi/proxy-compare).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 自动渲染优化在 [*第 9 章*](B17780_09_Final_VK_ePub.xhtml#_idTextAnchor116)，*用例场景 3 –
    Valtio* 中进行了讨论。React Tracked 和 Valtio 使用相同的状态使用跟踪功能。实际上，它们使用相同的内部库，称为 `proxy-compare`：[https://github.com/dai-shi/proxy-compare](https://github.com/dai-shi/proxy-compare)。
- en: In this section, we revisited state usage tracking and learned how it can optimize
    re-renders. In the next section, we will learn how to use React Tracked with `useState`
    and `useReducer`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了状态使用跟踪，并学习了它如何优化重新渲染。在下一节中，我们将学习如何使用 `useState` 和 `useReducer` 与 React
    Tracked 一起使用。
- en: Using React Tracked with useState and useReducer
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `useState` 和 `useReducer` 与 React Tracked
- en: The primary use case of React Tracked is to replace a use case of React Context.
    The API in React Tracked is specifically designed for this use case.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: React Tracked 的主要用例是替换 React Context 的一个用例。React Tracked 中的 API 专门为此用例设计。
- en: We will explore two usages with `useState` and `useReducer`. First, let's learn
    about the usage with `useState`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索使用 `useState` 和 `useReducer` 的两种用法。首先，让我们了解使用 `useState` 的用法。
- en: Using React Tracked with useState
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `useState` 和 React Tracked
- en: Before exploring the usage of React Tracked with `useState`, let's revisit how
    we can create a global state with React Context.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索使用 `useState` 的 React Tracked 用法之前，让我们回顾一下如何使用 React Context 创建全局状态。
- en: 'We first create a custom hook, which calls `useState` with an initial state
    value:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个自定义钩子，它使用初始状态值调用 `useState`：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Defining the custom hook is good for TypeScript because you can grab the type
    with the `typeof` operator.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 定义自定义钩子对于 TypeScript 来说是好的，因为你可以使用 `typeof` 操作符来获取类型。
- en: 'The following is a definition of our Context:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们 Context 的定义：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It has a type annotation in TypeScript. The default value is `null`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它在 TypeScript 中有一个类型注解。默认值是 `null`。
- en: 'To use the Context, we need a `Provider` component. The following is a custom
    `Provider` that uses `useValue` for the Context value:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Context，我们需要一个 `Provider` 组件。以下是一个使用 `useValue` 作为 Context 值的自定义 `Provider`：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is a component that injects the `StateContext.Provider` component. As we
    defined `useValue` separately, the implementation of `Provider` can use it in
    **JavaScript Syntax Extension** (**JSX**).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个注入 `StateContext.Provider` 组件的组件。由于我们单独定义了 `useValue`，`Provider` 的实现可以使用它，在
    **JavaScript 语法扩展**（**JSX**）中。
- en: 'To consume the Context''s value, we use `useContext`. We define a custom hook
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要消费 Context 的值，我们使用 `useContext`。我们如下定义一个自定义钩子：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This custom hook checks the existence of `Provider` by comparing `contextValue`
    with `null`. If it's `null`, it throws an error, and developers will notice that
    `Provider` is missing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义钩子通过比较 `contextValue` 与 `null` 来检查 `Provider` 的存在。如果是 `null`，它将抛出一个错误，开发者将注意到
    `Provider` 缺失。
- en: 'Now, it''s time to define some components for the app. The first component
    is `Counter`, which shows the `count` property of the state as well as a button
    to increment the `count` value:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候为应用定义一些组件了。第一个组件是 `Counter`，它显示状态中的 `count` 属性以及一个用于增加 `count` 值的按钮：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that `useStateContext` returns a tuple of the `state` value and the updating
    function. This is exactly the same as what `useValue` returns.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`useStateContext` 返回一个包含 `state` 值和更新函数的元组。这与 `useValue` 返回的内容完全相同。
- en: 'Next, we define the second component, `TextBox`, which shows an input field
    for the `text` property of the state:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义第二个组件，`TextBox`，它显示状态中 `text` 属性的输入字段：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We again use `useStateContext` and get the `state` value and the `setState`
    function. The `setText` function takes a string argument and invokes the `setState`
    function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用 `useStateContext` 并获取 `state` 值和 `setState` 函数。`setText` 函数接受一个字符串参数并调用
    `setState` 函数。
- en: 'Finally, we define the `App` component, which has the `Provider`, `Counter`,
    and `TextBox` components in it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义 `App` 组件，它包含 `Provider`、`Counter` 和 `TextBox` 组件：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How does this app behave? The Context handles the state object as a whole, and
    `useContext` will trigger re-renders when the state object changes. Even if only
    a single property changes in the state object, all `useContext` hooks trigger
    re-renders. This means that if we click a button in the `Counter` component, it
    increments the `count` property of the state object, and it causes both the `Counter`
    and `TextBox` components to re-render. While the `Counter` component re-renders
    with the new `count` value, the `TextBox` component re-renders with the same `text`
    value. This is an extra re-render.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用是如何工作的呢？Context 将状态对象作为一个整体处理，当状态对象发生变化时，`useContext` 将触发重新渲染。即使状态对象中只有一个属性发生变化，所有的
    `useContext` 钩子都会触发重新渲染。这意味着如果我们点击 `Counter` 组件中的按钮，它将增加状态对象的 `count` 属性，并导致 `Counter`
    和 `TextBox` 组件重新渲染。当 `Counter` 组件重新渲染时，会显示新的 `count` 值，而 `TextBox` 组件会重新渲染相同的
    `text` 值。这是一个额外的重新渲染。
- en: The extra re-render behavior with Context is expected, and if we want to avoid
    it, we should split it into smaller pieces. Refer to [*Chapter 3*](B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049),
    *Sharing the Component State with Context*, to learn more about best practices
    with React Context.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Context 的额外重新渲染行为是预期的，如果我们想避免它，我们应该将其拆分成更小的部分。请参阅 [*第 3 章*](B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049)，*使用
    Context 共享组件状态*，以了解更多关于 React Context 的最佳实践。
- en: 'Now, what does it look like with React Tracked? Let''s convert the previous
    example to a new example with React Tracked. First, we import `createContainer`
    from the React Tracked library:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，React Tracked 看起来是什么样子呢？让我们将之前的示例转换为一个新的示例，使用 React Tracked。首先，我们从 React
    Tracked 库中导入 `createContainer`：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then use the `useValue` hook defined in `const useValue = () => useState({
    count: 0, text: "hello" });` and call the `createContainer` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '我们随后使用在 `const useValue = () => useState({ count: 0, text: "hello" });` 中定义的
    `useValue` 钩子并调用 `createContainer` 函数：'
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From the results, `Provider` and `useTracked` are extracted. The `Provider`
    component can be used in the same way as in the previous example of this section.
    The `useTracked` hook can be used in the same way as the `useStateContext` hook
    we defined in the previous example of this section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中提取了 `Provider` 和 `useTracked`。`Provider` 组件可以像本节前一个示例中那样使用。`useTracked`
    钩子可以像本节前一个示例中定义的 `useStateContext` 钩子那样使用。
- en: 'Using the new `useTracked` hook, the `Counter` component becomes as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的 `useTracked` 钩子，`Counter` 组件如下所示：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We simply replaced `useStateContext` with `useTracked`. The rest of the code
    is the same.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将 `useStateContext` 替换为 `useTracked`。其余的代码保持不变。
- en: 'Likewise, the following is the new `TextBox` component:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以下是新 `TextBox` 组件：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The only change is the replacement of `useStateContext` with `useTracked`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的改变是将 `useStateContext` 替换为 `useTracked`。
- en: 'The `App` component is exactly the same as in the previous example of this
    section, using the new `Provider` component:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`App` 组件与该节前一个示例中的完全相同，使用新的 `Provider` 组件：'
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'How does this new app behave? The `state` object returned by `useTracked` is
    tracked, which means the `useTracked` hook remembers which properties of `state`
    are accessed. The `useTracked` hook will trigger a re-render only if the accessed
    properties are changed. Hence, if you click a button in the `Counter` component,
    only the `Counter` component re-renders, and the `TextBox` component doesn''t
    re-render, as shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新应用程序是如何表现的？`useTracked` 返回的 `state` 对象是受跟踪的，这意味着 `useTracked` 钩子会记住 `state`
    的哪些属性被访问。只有当访问的属性发生变化时，`useTracked` 钩子才会触发重新渲染。因此，如果你在 `Counter` 组件中点击按钮，只有 `Counter`
    组件会重新渲染，而 `TextBox` 组件不会重新渲染，如下所示：
- en: '![Figure 10.1 – A screenshot of the app with React Tracked and useState ](img/Figure_10.1_B17780.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 使用 React Tracked 和 useState 的应用程序截图](img/Figure_10.1_B17780.jpg)'
- en: Figure 10.1 – A screenshot of the app with React Tracked and useState
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 使用 React Tracked 和 useState 的应用程序截图
- en: Essentially, what we changed is `createContainer` instead of `createContext`,
    and `useTracked` instead of `useStateContext`. The result gives us optimized re-renders.
    This is the state usage tracking feature.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们改变的是 `createContainer` 而不是 `createContext`，以及 `useTracked` 而不是 `useStateContext`。这个结果给我们带来了优化的重新渲染。这是状态使用跟踪功能。
- en: The `useValue` custom hook we passed to the `createContainer` function can be
    anything as long as it returns a tuple such as `useState`. Let's look at another
    example using `useReducer`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给 `createContainer` 函数的 `useValue` 自定义钩子可以是任何东西，只要它返回一个类似于 `useState` 的元组即可。让我们看看另一个使用
    `useReducer` 的示例。
- en: Using React Tracked with useReducer
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 React Tracked 和 useReducer
- en: In this example, we use `useReducer` instead of `useState`. The `useReducer`
    hook is an advanced hook with more features, but it's mostly syntactic difference.
    Refer to the *Exploring the similarity and difference between useState and useReducer*
    section in [*Chapter 1*](B17780_01_Final_VK_ePub.xhtml#_idTextAnchor012), *What
    Is Micro State Management with React Hooks?*, for more detailed discussions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用 `useReducer` 而不是 `useState`。`useReducer` 钩子是一个具有更多功能的先进钩子，但它主要是语法上的差异。请参阅
    [*第 1 章*](B17780_01_Final_VK_ePub.xhtml#_idTextAnchor012) 中 *Exploring the similarity
    and difference between useState and useReducer* 部分，*What Is Micro State Management
    with React Hooks?*，以获取更详细的讨论。
- en: Important Note about useReducer
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `useReducer` 的重要注意事项
- en: The `useReducer` hook is an official React hook. It takes a reducer function
    to update states. A reducer function is a programming pattern, not related to
    React or even JavaScript. The `useReducer` hook applies the pattern to states.
    The reducer function in React is popularized by Redux. The `useReducer` covers
    Redux's use cases in terms of the reduce pattern. However, it doesn't cover the
    other Redux use cases, such as React Redux and store enhancer or middleware. The
    `useReducer` hook accepts any kind of actions unlike Redux, which requires an
    action to be an object with a `type` property.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`useReducer` 钩子是官方的 React 钩子。它接受一个用于更新状态的 reducer 函数。reducer 函数是一种编程模式，与 React
    或 JavaScript 无关。`useReducer` 钩子将此模式应用于状态。在 React 中，reducer 函数因 Redux 而流行。`useReducer`
    在 reduce 模式方面涵盖了 Redux 的使用案例。然而，它并没有涵盖 Redux 的其他使用案例，例如 React Redux 和 store enhancer
    或 middleware。与 Redux 不同，`useReducer` 钩子接受任何类型的动作。'
- en: 'The new `useValue` hook uses `useReducer` and `useEffect`. `useReducer` is
    defined with a reducer function and an initial state. `useEffect` has a function
    that logs the state value to the console. The following is the `useValue` code
    in TypeScript:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `useValue` 钩子使用 `useReducer` 和 `useEffect`。`useReducer` 使用一个还原函数和一个初始状态来定义。`useEffect`
    有一个将状态值记录到控制台的功能。以下是在 TypeScript 中的 `useValue` 代码：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The reducer function accepts action types of `INC` and `SET_TEXT`. The `useEffect`
    hook is used in console logging, but it's not limited to it. For example, it can
    interact with remote resources. The `useValue` hook returns a tuple of `state`
    and `dispatch`. As long as the return tuple follows this shape, we can implement
    the hook as we like. For example, we could use more than one `useState` hook.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer 函数接受 `INC` 和 `SET_TEXT` 的动作类型。`useEffect` 钩子在控制台日志中使用，但不仅限于它。例如，它可以与远程资源交互。`useValue`
    钩子返回一个包含 `state` 和 `dispatch` 的元组。只要返回的元组遵循这种形状，我们就可以按我们的喜好实现钩子。例如，我们可以使用多个 `useState`
    钩子。
- en: 'Using the new `useValue` hook, we run `createContainer`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的 `useValue` 钩子，我们运行 `createContainer`：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The way we use `createContainer` doesn't change, even if we change `useValue`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `createContainer` 的方式不会改变，即使我们改变了 `useValue`。
- en: 'Using the new `useTracked` hook, we implement the `Counter` component:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的 `useTracked` 钩子，我们实现 `Counter` 组件：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because `useTracked` returns the same shaped tuple as `useValue` returns, we
    name the second item in the tuple `dispatch`, which is a function that dispatches
    an action. The `Counter` component dispatches an `INC` action.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `useTracked` 返回的元组形状与 `useValue` 返回的形状相同，所以我们把元组的第二个项目命名为 `dispatch`，这是一个分发动作的函数。`Counter`
    组件分发一个 `INC` 动作。
- en: 'Next is the `TextBox` component:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `TextBox` 组件：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Likewise, the `dispatch` function is used for a `SET_TEXT` action.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`dispatch` 函数用于 `SET_TEXT` 动作。
- en: 'Finally, we have the `App` component:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `App` 组件：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The behavior of the new `App` component is exactly the same as the previous
    one. The difference between the examples with `useState` and `useReducer` is that
    `useValue` returns a tuple of `state` and `dispatch`; thus `useTracked` also returns
    a tuple of `state` and `dispatch`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `App` 组件的行为与上一个完全相同。与 `useState` 和 `useReducer` 的示例相比，区别在于 `useValue` 返回一个包含
    `state` 和 `dispatch` 的元组；因此 `useTracked` 也返回一个包含 `state` 和 `dispatch` 的元组。
- en: The reason why React Tracked can optimize re-renders is not only state usage
    tracking but also its internal library called `use-context-selector` ([https://github.com/dai-shi/use-context-selector](https://github.com/dai-shi/use-context-selector)).
    It allows us to subscribe to the Context value with a `selector` function. This
    subscription bypasses the limitations of React Context.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: React Tracked 可以优化重新渲染的原因不仅在于状态使用跟踪，还在于其内部库 `use-context-selector` ([https://github.com/dai-shi/use-context-selector](https://github.com/dai-shi/use-context-selector))。它允许我们使用
    `selector` 函数订阅 Context 值。这种订阅绕过了 React Context 的限制。
- en: In this section, we saw a basic example with bare React Context, and two examples
    with React Tracked with `useState` and `useReducer`. In the next section, we will
    learn a usage of React Tracked with React Redux, which uses the state usage tracking
    feature without `use-context-selector`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了一个基本的与裸 React Context 的示例，以及两个与 React Tracked 和 `useState`、`useReducer`
    一起的示例。在下一节中，我们将学习使用 React Redux 的 React Tracked 的一个用法，它使用状态使用跟踪功能而不使用 `use-context-selector`。
- en: Using React Tracked with React Redux
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Tracked 和 React Redux
- en: The primary use case of React Tracked is to replace a use case of React Context.
    This is done by using `use-context-selector` internally.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: React Tracked 的主要用途是替换 React Context 的一个用例。这是通过内部使用 `use-context-selector` 来实现的。
- en: 'React Tracked exposes a low-level function called `createTrackedSelector` to
    cover non-React Context use cases. It takes a hook called `useSelector` and returns
    a hook called `useTrackedState`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: React Tracked 提供了一个名为 `createTrackedSelector` 的低级函数，用于覆盖非 React Context 用例。它接受一个名为
    `useSelector` 的钩子，并返回一个名为 `useTrackedState` 的钩子：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`useSelector` is a hook that takes a selector function and returns the result
    of the selector function. It will trigger re-renders when the result changes.
    `useTrackedState` is a hook that returns an entire state wrapped in proxies to
    track the `state` usage.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`useSelector` 是一个钩子，它接受一个选择器函数并返回选择器函数的结果。当结果改变时，它将触发重新渲染。`useTrackedState`
    是一个钩子，它返回一个包裹在代理中的整个 `state` 以跟踪 `state` 的使用。'
- en: Let's look at a concrete example with React Redux. This provides a `useSelector`
    hook, and it's straightforward to apply `createTrackedSelector`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个具体的 React Redux 示例。这提供了一个 `useSelector` 钩子，应用 `createTrackedSelector`
    非常简单。
- en: Important Note about React Redux
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 React Redux 的重要说明
- en: React Redux uses React Context internally, but it doesn't use Context for propagating
    a state value. It uses React Context for dependency injection, and the state propagation
    is done by subscription. React Redux's `useSelector` is optimized to re-render
    only if the selector result changes. This is not possible with Context propagation
    at the time of writing. There are many other libraries that take the same approach,
    and in fact, the `use-context-selector` UserLand solution is the same too.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: React Redux 在内部使用 React Context，但它不使用 Context 来传播状态值。它使用 React Context 进行依赖注入，而状态传播是通过订阅完成的。React
    Redux 的 `useSelector` 被优化为仅在选择器结果改变时重新渲染。在撰写本文时，使用 Context 传播是不可能的。还有许多其他库采用相同的方法，实际上，`use-context-selector`
    UserLand 解决方案也是如此。
- en: 'First, we import some functions from libraries, namely `redux`, `react-redux`,
    and `react-tracked`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从库中导入一些函数，即 `redux`、`react-redux` 和 `react-tracked`：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first two import lines are a traditional React Redux setup. The third line
    is our addition.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行导入是传统的 React Redux 设置。第三行是我们的补充。
- en: 'Next, we define a Redux store with `initialState` and `reducer`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `initialState` 和 `reducer` 定义一个 Redux 存储：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is one traditional way to create a Redux store. Note that it has nothing
    to do with React Tracked, and any way of creating a Redux store would work.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种创建 Redux 存储的传统方式。请注意，它与 React Tracked 没有关系，任何创建 Redux 存储的方式都会工作。
- en: '`createTrackedSelector` allows us to create the `useTrackedState` hook from
    the `useSelector` hook, which is imported directly from `react-redux`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`createTrackedSelector` 允许我们通过从 `react-redux` 直接导入的 `useSelector` 钩子创建 `useTrackedState`
    钩子：'
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We need to explicitly type the hook with `<State>`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要显式地使用 `<State>` 类型化钩子。
- en: 'Using `useTrackedState`, the `Counter` component is defined as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `useTrackedState`，`Counter` 组件的定义如下：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This should be mostly like a normal React Redux pattern except for the `useTrackedState`
    line. In React Redux, it would be as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该与正常的 React Redux 模式大致相同，除了 `useTrackedState` 行。在 React Redux 中，它将是以下这样：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The change may seem trivial, but with `useSelector`, developers have more control
    and responsibility for re-renders, whereas with `useTrackedState`, the hook controls
    re-renders automatically.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化可能看起来微不足道，但使用 `useSelector`，开发者对重新渲染有更多的控制和责任，而使用 `useTrackedState`，钩子会自动控制重新渲染。
- en: 'Likewise, the `TextBox` component is implemented as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`TextBox` 组件的实现如下：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Again, we used `useTrackedState` instead of `useSelector` for automatic render
    optimization. To explain how automatic render optimization is useful, let''s imagine
    that `TextBox` takes a `showCount` prop property, which is a Boolean value to
    show the `count` value in `state`. We can modify the `TextBox` component as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们使用 `useTrackedState` 而不是 `useSelector` 来实现自动渲染优化。为了解释自动渲染优化如何有用，让我们想象一下
    `TextBox` 组件接受一个 `showCount` 属性，它是一个布尔值，用于在 `state` 中显示 `count` 值。我们可以按如下方式修改
    `TextBox` 组件：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that we didn't change the `useTrackedState` line at all. With a single
    `useSelector`, implementing the same behavior would be difficult.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有对 `useTrackedState` 行进行任何更改。使用单个 `useSelector` 实现相同的行为将是困难的。
- en: 'Finally, the following is the `App` component to combine all components:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是将所有组件组合在一起的 `App` 组件：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is exactly the same as using normal React Redux without React Tracked.
    The re-renders are optimized in this app, which means clicking a button only triggers
    the `Counter` component to re-render, and the `TextBox` component won''t re-render,
    as shown in the following figure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这与使用不带 React Tracked 的正常 React Redux 完全相同。在这个应用程序中，重新渲染被优化了，这意味着点击按钮只会触发 `Counter`
    组件的重新渲染，而 `TextBox` 组件不会重新渲染，如下面的图所示：
- en: '![Figure 10.2 – A screenshot of the app with React Tracked and React Redux
    ](img/Figure_10.2_B17780.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 使用 React Tracked 和 React Redux 的应用程序截图](img/Figure_10.2_B17780.jpg)'
- en: Figure 10.2 – A screenshot of the app with React Tracked and React Redux
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 使用 React Tracked 和 React Redux 的应用程序截图
- en: In this section, we learned how to use React Tracked with a non-React Context
    use case. Next, we will discuss what React Tracked can look like with a future
    version of React.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用 React Tracked 与非 React Context 用例。接下来，我们将讨论 React Tracked 在未来版本的
    React 中可能的样子。
- en: Future prospects
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来展望
- en: 'The implementation of React Tracked depends on two internal libraries:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: React Tracked 的实现依赖于两个内部库：
- en: '`proxy-compare` ([https://github.com/dai-shi/proxy-compare](https://github.com/dai-shi/proxy-compare))'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy-compare` ([https://github.com/dai-shi/proxy-compare](https://github.com/dai-shi/proxy-compare))'
- en: '`use-context-selector` ([https://github.com/dai-shi/use-context-selector](https://github.com/dai-shi/use-context-selector))'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use-context-selector` ([https://github.com/dai-shi/use-context-selector](https://github.com/dai-shi/use-context-selector))'
- en: As we learned in the *Using React Tracked with useState and useReducer* section
    and the *Using React Tracked with React Redux* section, there are two ways to
    use React Tracked. The first way is via React Context with `createContainer` and
    the second is via React Redux with `createTrackedSelector`. The base function
    is `createTrackedSelector`, which is implemented with the `proxy-compare` library.
    The `createContainer` function is a higher abstraction, which is implemented with
    `createTrackedSelector` and the `use-context-selector` library.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*使用React Tracked与useState和useReducer*部分以及*使用React Tracked与React Redux*部分所学的，使用React
    Tracked有两种方式。第一种是通过React Context使用`createContainer`，第二种是通过React Redux使用`createTrackedSelector`。基本函数是`createTrackedSelector`，它使用`proxy-compare`库实现。`createContainer`函数是一个高级抽象，它使用`createTrackedSelector`和`use-context-selector`库实现。
- en: In terms of the use of Context in React Tracked, the `use-context-selector`
    library is important. What is the role of `use-context-selector`? It provides
    a `useContextSelector` hook. As we learned in the *Understanding Context* section
    in [*Chapter 3*](B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049), *Sharing the
    Component State with Context*, React Context is designed so that all Context consumer
    components re-render when the Context value is changed. There is a proposal to
    improve the Context behavior – `useContextSelector`. The `use-context-selector`
    library is a Userland library that emulates the proposed `useContextSelector`
    hook as much as possible.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Tracked中关于Context的使用方面，`use-context-selector`库非常重要。`use-context-selector`的作用是什么？它提供了一个`useContextSelector`钩子。正如我们在[*第三章*](B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049)的*理解Context*部分所学的，*通过Context共享组件状态*，React
    Context被设计成当Context值发生变化时，所有Context消费者组件都会重新渲染。有一个提议旨在改进Context的行为——`useContextSelector`。`use-context-selector`库是一个Userland库，尽可能地模拟了提议的`useContextSelector`钩子。
- en: It's very uncertain at the point of writing, but a future version of React may
    implement `useContextSelector`, or a similar form of it. In this situation, React
    Tracked can easily migrate from the `use-context-selector` library to a native
    `useContextSelector`. Hopefully, this should give full compatibility with React
    features.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，情况非常不确定，但React的未来版本可能会实现`useContextSelector`，或者类似的形式。在这种情况下，React Tracked可以轻松地从`use-context-selector`库迁移到本地的`useContextSelector`。希望这应该能够提供与React特性完全兼容。
- en: Abstracting `use-context-selector` away in the implementation of React Tracked
    helps migration. If React has an official `useContextSelector` hook in the future,
    React Tracked can migrate without changing its public API. In this implementation
    design, `createTrackedSelector` is a building block function in React Tracked,
    and `createContainer` is a glue function. Exporting both functions allows us to
    have both usages.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Tracked的实现中将`use-context-selector`抽象出来有助于迁移。如果React在未来有一个官方的`useContextSelector`钩子，React
    Tracked可以迁移而不改变其公共API。在这个实现设计中，`createTrackedSelector`是React Tracked中的一个构建块函数，而`createContainer`是一个粘合函数。导出这两个函数允许我们使用这两种方式。
- en: In this section, we discussed the implementation design of React Tracked and
    how it can migrate to a possible future version of React.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了React Tracked的实现设计和它如何迁移到可能的未来版本。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about a library – React Tracked. This library has
    two purposes. One purpose is to replace the use case of React Context. The other
    purpose is to enhance the selector hook provided by some other libraries, such
    as React Redux.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了一个库——React Tracked。这个库有两个目的。一个目的是替代React Context的使用场景。另一个目的是增强一些其他库（如React
    Redux）提供的选择器钩子。
- en: Technically, the React Tracked library is not a global state library. It's to
    be used with state functions, such as `useState` and `useReducer`, or Redux. All
    React Tracked provides is a feature to optimize re-renders.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，React Tracked库不是一个全局状态库。它是与状态函数一起使用的，例如`useState`和`useReducer`，或者Redux。React
    Tracked提供的是优化重新渲染的功能。
- en: In the next chapter, we will compare the three libraries for global state, namely
    Zustand, Jotai, and Valtio, and discuss global state patterns to wrap up this
    book.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将比较三个全局状态库，即Zustand、Jotai和Valtio，并讨论全局状态模式，以结束本书。
