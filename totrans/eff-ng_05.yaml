- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Dynamic Angular Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are creating components, the flexibility and reusability of those components
    should be top priorities. You don’t want unnecessary dependencies inside your
    component and want to ensure the component can serve as many scenarios as possible
    without becoming overcomplicated.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will teach you how to create truly dynamic UI components using
    content projection, template references, and template outlets. We will learn how
    to dynamically render components using the component outlet directive and the
    view container reference.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know when and how to project content into
    UI components, effectively use templates inside your components, and output code
    in different places, depending on certain conditions. You will also be able to
    load and render components dynamically, enhancing the flexibility and performance
    of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A deep dive into Angular content projection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using template references and variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering components dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A deep dive into Angular content projection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, when creating a component, you need to display a wide variety of content
    inside it. Some good examples include a modal component, a card, or a tab component.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider the **modal component**; you want the component to have a visible
    and hidden state, a backdrop, and some shared styling so that all your modals
    have the same look and feel. Yet the content inside each instance of the modal
    component will be wildly different. Sometimes, you want to display a form inside
    the modal, while other times, you want to use it to display text or provide actions
    or configurations to the user. Most likely, each modal you have within your application
    will have different content inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a question arises: how do we facilitate this need and create a component
    that can house any content it needs within its HTML template?'
  prefs: []
  type: TYPE_NORMAL
- en: You could hardcode all the options and use inputs to configure the component,
    but this becomes unmaintainable really fast! Using **content projection** is the
    correct way to create a component that needs to display a wide variety of content
    inside its template. Angular content projection lets you define placeholders inside
    the HTML template of a component. You can fill these placeholders with any content
    by projecting the content inside the placeholder from the parent component HTML
    template where the dynamic component is declared. We will explore and use content
    projection ourselves by creating a modal component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a modal component using content projection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating a modal component inside the `common-components` library
    of your *Nx monorepo*. Inside the `component` class, add an input for the shown
    status of the modal and an output for the close event. Also, add input for the
    modal title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create the HTML template for the modal component. Start with an
    `ng-container` element. Inside the `ng-container` element sits the modal container
    and the backdrop. We must also place a `*ngIf` directive with the shown status
    on the `ng-container` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can add a modal header and modal content area inside the modal container.
    The modal header will contain the title and a “X” button to close the modal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, you have to add the modal content area. This is where we will create
    the placeholder for our content projection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find the CSS for the modal component in this book’s GitHub repository:
    [https://github.com/PacktPublishing/Effective-Angular/tree/feature/chapter-five/dynamic-components](https://github.com/PacktPublishing/Effective-Angular/tree/feature/chapter-five/dynamic-components).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, inside the modal content area, we defined an `ng-content` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This `ng-content` element is the placeholder for the projected content. The
    `ng-content` element will display everything we project from the parent component
    into the modal component.
  prefs: []
  type: TYPE_NORMAL
- en: 'You project content from the parent component into the modal component by placing
    content between the component’s opening and closing selector tags. To test the
    content projection of your modal, import the modal component inside the `expenses-overview`
    component and add a Boolean property, `addExpenseShown`. Next, add the model component
    to the HTML template and project `addExpenseForm`, which we created in the previous
    chapter, inside the modal component, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the modal is shown, it displays the add expense form we projected
    into the component. The `ng-content` element inside the HTML template of the modal
    will be replaced with the add expense form we projected into the modal component.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `ng-content` slot provides the flexibility you need for
    your modal component and allows you to project any content easily into the modal.
    Any logic related to the projected content is handled in the parent component
    and not inside the modal component itself, resulting in good separations of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of our projected form, if you want to handle the `addExpense` output
    event of the form component, you handle the event inside the `expenses-overview`
    component. The same goes for styling the projected content. If you want to style
    your projected content, you must do so inside the CSS file of the component where
    you project the content. In our example, this would be the `add-expense.component.scss`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to project content into a single `ng-content` slot. Next, you’ll
    learn how to handle more complex projection scenarios by using multiple `ng-content`
    slots.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring multi-slot content projection with ng-content select
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using a single `ng-content` slot provides a lot of flexibility, but sometimes,
    you need multiple places to project content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that in some of the modal designs you have, there is custom content
    between the title and closing buttons of the modal. To cover this use case, you
    need two places to project content: one in the content area and one in the header.
    When using multiple `ng-content` elements in a component, you need to use `ng-content`
    with a `select` attribute defined on the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we added the additional `ng-content` element inside the modal header and
    assigned the select attribute with a value of `header-content`. If we added the
    second `ng-content` element without defining the select attribute, all projected
    content would end up inside the last `ng-content` element in the HTML template
    of the modal.
  prefs: []
  type: TYPE_NORMAL
- en: 'For projected content to end up in a specific `ng-content` element, the projected
    content needs to match the select attribute value of `ng-content`. For the header’s
    `ng-content` element, this means you need to add a `header-content` attribute
    to the HTML you want to project to the header slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can project as much HTML as you want to a specific `ng-content` element.
    There are three scenarios when Angular determines where your content will be projected.
    Let’s explore these scenarios one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: If the projected content matches the select attribute value of an `ng-content`
    element in your template, the content is projected to `ng-content` with the matching
    select value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the content matches multiple `ng-content` selectors, the content is projected
    into the first `ng-content` element with a matching select value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the projected HTML doesn’t match any of the `ng-content` select values,
    the content is projected to the fallback `ng-content` element – that is, `ng-content`
    – without a `select` attribute assigned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our modal component, the fallback slot is defined inside the content area
    of the modal. If all content slots have a select attribute defined, there is no
    fallback slot. When there is no fallback `ng-content` element, any projected content
    that doesn’t match with at least one of the `select` attribute values will not
    be projected and rendered.
  prefs: []
  type: TYPE_NORMAL
- en: The `select` attribute of the `ng-content` tag allows you to create powerful
    selectors that can match various things. You can match HTML attributes like we
    did in our modal component, but you can also match HTML tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say we want to project all `div` HTML tags into the header
    slot. We can adjust the selector like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: <div>special header content</div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: <ng-content select="div, p"></ng-content>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: <ng-content select=".header"></ng-content>
  prefs: []
  type: TYPE_NORMAL
- en: <ng-content select="#header"></ng-content>
  prefs: []
  type: TYPE_NORMAL
- en: <ng-content select="[type='text']"></ng-content>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: <div *ngFor="let item of [1,2,3]">
  prefs: []
  type: TYPE_NORMAL
- en: <ng-content></ng-content>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: <bt-libs-modal [shown]="addExpenseShown" [title]="'Add expenses'">
  prefs: []
  type: TYPE_NORMAL
- en: <div *ngFor="let header of headers" header-content>{{header}}</div>
  prefs: []
  type: TYPE_NORMAL
- en: </bt-libs-modal>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '@Directive({'
  prefs: []
  type: TYPE_NORMAL
- en: 'selector: ‹[btLibsScalesProjection]'','
  prefs: []
  type: TYPE_NORMAL
- en: 'standalone: true,'
  prefs: []
  type: TYPE_NORMAL
- en: '})'
  prefs: []
  type: TYPE_NORMAL
- en: export class ScalesProjectionDirective {
  prefs: []
  type: TYPE_NORMAL
- en: 'constructor(public templateRef: TemplateRef<unknown>) { }'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '@Input({ required: true }) scaleSizes!: number[];'
  prefs: []
  type: TYPE_NORMAL
- en: '@ContentChild(ScalesProjectionDirective) content!: ScalesProjectionDirective;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: <div *ngFor="let size of scaleSizes; let i = index" [style.transform]="'scale('
    + size + ')'">
  prefs: []
  type: TYPE_NORMAL
- en: <ng-container [ngTemplateOutlet]=»content.templateRef»></ng-container>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <bt-libs-display-scales [scaleSizes]="[0.8, 1, 1.2, 1.4]">
  prefs: []
  type: TYPE_NORMAL
- en: <ng-template btLibsScalesProjection>I scale!</ng-template>
  prefs: []
  type: TYPE_NORMAL
- en: </bt-libs-display-scales>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '@QueryList, you need to loop over QueryList and create an ng-container element
    for each node in the list. You can achieve this by turning QueryList into an array
    and using the *ngFor directive to output each item in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to project content into different slots, as we did with the `ng-content`
    tags and `select` attribute, you need to create multiple projection directives
    like `ScalesProjectionDirective` and use multiple `@ContentChild` decorators to
    separate the project’s `ng-template` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: <ng-container [ngTemplateOutlet]="content.templateRef"></ng-container>
  prefs: []
  type: TYPE_NORMAL
- en: <ng-container [ngTemplateOutlet]="ng-template elements and use the *ngFor, *ngIf,
    and *ngSwitch directives or control flow syntax in combination with projected
    content.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s explore what else we can do with the `ng-template` element, what
    template variables are, and how we can use them effectively in our components.
    We will start by learning about template variables.
  prefs: []
  type: TYPE_NORMAL
- en: Using template variables effectively
  prefs: []
  type: TYPE_NORMAL
- en: When building components, we often need to use one part of the HTML template
    in another part of the HTML template. You can access elements from your HTML template
    using decorators such as `@ViewChild` or `@ContentChild`, but you can also use
    **template variables**. Using template variables helps simplify your code because
    you can handle situations where you need one part of the template in another place,
    all in your HTML; there’s no need to create a property in your component class
    and use this variable inside your HTML template.
  prefs: []
  type: TYPE_NORMAL
- en: 'A template variable can refer to five different elements:'
  prefs: []
  type: TYPE_NORMAL
- en: DOM elements within the HTML template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directives used within the HTML template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components used within the HTML template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TemplateRef` from `ng-template` elements used within the HTML template'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Template variables are created using the hashtag (`#`) sign combined with a
    variable name. For example, if you want to create a template variable from a `div`
    element in your template, you can use this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '<div>Template var says: {{exampleVar.innerText}} </div>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<input #name placeholder="Enter your name" />'
  prefs: []
  type: TYPE_NORMAL
- en: <button (click)="submitName(name.value)">Submit</button>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<bt-libs-modal #modal [(shown)]="addExpenseShown"> ………'
  prefs: []
  type: TYPE_NORMAL
- en: </bt-libs-modal>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '<form #expenseForm="ngForm"> ……… </form>'
  prefs: []
  type: TYPE_NORMAL
- en: <div *ngIf="!expenseForm.form.valid">
  prefs: []
  type: TYPE_NORMAL
- en: <p>Invalid form</p>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: <ng-template TemplateRef element, either by using the ng-template element (with
    or without a template variable) or by using the TemplateRef in your component
    class, is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using TemplateRef elements effectively
  prefs: []
  type: TYPE_NORMAL
- en: Template references can be defined inside your HTML templates using the `ng-template`
    element. You can access a `TemplateRef` element in your component and directive
    classes using the `TemplateRef` class. The `TemplateRef` class and the `ng-template`
    element are the same thing in different forms.
  prefs: []
  type: TYPE_NORMAL
- en: A `TemplateRef` element can be used for many use cases. As shown at the start
    of the *Using template references and variables* section of this chapter, `TemplateRef`
    can be used for content projection when you need to combine the projected content
    with a structural directive such as `*ngFor`, `*ngIf`, or `*ngSwitch`.
  prefs: []
  type: TYPE_NORMAL
- en: Another place where `TemplateRef` is used is within custom structural directives.
    Structural directives add or remove `TemplateRef` elements to/from the view container
    based on some logic. We added and removed template references to the view container
    in [*Chapter 3*](B21625_03.xhtml#_idTextAnchor058) when we created our custom
    structural directive.
  prefs: []
  type: TYPE_NORMAL
- en: A `TemplateRef` element can also be combined with template context to build
    truly dynamic components that can display different templates using different
    data sources. You can also use `TemplateRef` to display content in different places
    on your page – for example, when you have the same piece of content located on
    different locations of the page for your mobile and desktop designs.
  prefs: []
  type: TYPE_NORMAL
- en: Another place where the `ng-template` element shines is when you need to render
    content conditionally based on the outcome of a `*ngIf` directive. Let’s continue
    by exploring the use cases for `TemplateRef` and create some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Combining ng-template with *ngIf
  prefs: []
  type: TYPE_NORMAL
- en: 'You can display an `ng-template` element based on the outcome of a `*ngIf`
    statement. Often, you’ll see something like this in the HTML templates of Angular
    applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can do the same thing with the `ng-template` element and define a template
    that is shown when the `*ngIf` statement isn’t met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of declaring the `*ngIf` directive on both `div` elements, we used
    the `*ngIf` `else` syntax. We referenced the template variable that was placed
    on the `ng-template` element for the `else` statement. Now, when there are no
    expenses, the loading template is shown. This is just a simple example, but if
    you have large templates to display conditionally, using templates helps separate
    the HTML. Also, when your `*ngIf` statement uses the `async` pipe, which is often
    the case, you cannot use the first approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use the `async` pipe inside your `*ngIf` directive, you cannot use
    the logical not operator (`!`) in your template. You could set a value inside
    your component class using an RxJS pipe operator on your observable value. Still,
    it would be a lot simpler and cleaner to use the `*ngIf` `else` statement and
    an `ng-template` element, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using the syntax mentioned previously lets you use the `async` pipe to handle
    your observable and display an alternative template, so long as no value has been
    resolved by the observable or the result of the observable has been mapped to
    a false, null, or undefined value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even take it a step further and split up all your HTML into separate
    templates using the `*ngIf` `then-else` syntax combined with `ng-template` elements.
    Using the `if-then-else` syntax gives you a clear separation in your HTML and
    helps improve maintainability when you have large templates where you have to
    display multiple blocks of content conditionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What solution you use is primarily up to your preference and your team’s preference.
    There is no real convention or best practice. When working with the `async` pipe,
    I like to use the `ng-template` syntax instead of using a pipe operator on my
    observable to assign a component property, which can be used for the `*ngIf` statement
    with the logical not operator.
  prefs: []
  type: TYPE_NORMAL
- en: For simple scenarios with synchronous values, I mostly use `*ngIf` and `*ngIf`
    with the logical not operator to display the correct HTML content – unless there
    are two large blocks of HTML content, in which case I prefer using templates.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how you can use the `ng-template` element combined with the
    `*ngIf` directive to display templates conditionally, let’s explore how to use
    `ng-template` to display templates in different locations on the same page.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying content in the correct spot using ng-template
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, you have a design where the same block of content is placed on a different
    location of the page for your mobile and desktop view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Content placement for the mobile and desktop views](img/B21625_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Content placement for the mobile and desktop views'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 5**.1*, on mobile, the content blocks, *C* and *D*, are
    shown below element *B*; on the desktop view, the same content is shown above
    element *B*. The same goes for block *A*, only in reverse. You don’t want to duplicate
    the HTML for blocks *A*, *C*, and *D* and place it once above and once below block
    *B*. Duplicating the HTML would break the **Don’t Repeat Yourself** (**DRY**)
    principle and result in a harder-to-maintain and read HTML template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ng-template` element comes to the rescue in this scenario and lets you
    display the same template in different places on the page without duplicating
    the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding HTML snippet, we used one `ng-template` element
    to define the HTML for the `A` block and one `ng-template` element to define the
    HTML for the `C` and `D` blocks combined. We display the templates using `ng-container`
    elements with an `ngTemplateOutlet` directive referencing the template variables
    declared on the `ng-template` elements.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used an `isMobile` Boolean to hide or show the correct `ng-container`
    elements, but you can also wrap them inside a `div` element and hide them with
    CSS. Using the `ng-template` element combined with the `ng-container` element,
    we only have to create the HTML for the `A`, `C`, and `D` blocks once, resulting
    in a cleaner and more maintainable HTML template.
  prefs: []
  type: TYPE_NORMAL
- en: You can clean up the HTML even more and assign the `aboveB` and `belowB` templates
    inside your component class. I don’t like to add the additional logic for this
    inside my component class, but it’s a preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how you can handle this in your component class. First,
    adjust your HTML to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside your component class, get a reference to the `A` and `CD` templates
    by using the `@ViewChild()` decorator and create a variable for the `aboveB` and
    `belowB` `TemplateRef` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `ngAfterViewInit` life cycle hook, you can assign the variables
    with the correct template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If your component is set to the *OnPush* change detection strategy, you need
    to manually trigger change detection for the view to update and display the templates.
    If you don’t use the *OnPush* change detection strategy, your view will be updated
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something similar can be done when you have a page with multiple modals. Instead
    of defining multiple modal components and projecting the correct content into
    each modal, you can create one modal that contains an `ng-container` element with
    the `ngTemplateOutlet` directive and set the correct template when the modal is
    opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we created an `openModel` function, which will
    be called from the HTML template when one of the modal components needs to be
    opened. We will pass along a title for the modal and a `TemplateRef` element for
    the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the HTML, we now only display one modal and display the `TemplateRef` element
    inside, which is set in the `openModal` method in our component class. When the
    corresponding button is clicked, we send the `TemplateRef` element from the HTML
    template to our `openModal` function.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, the `ng-template` element and `ngTemplateOutlet` can
    bring a lot of flexibility to your components and let you easily display different
    templates in different locations. But `ng-template` can offer us even more flexibility
    by adding context and using `TemplateRef` as an input.
  prefs: []
  type: TYPE_NORMAL
- en: Creating dynamic components using templates and context
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen how we can combine content projection and the `ng-template`
    element. In this section, we will use `TemplateRef` as a component input and provide
    additional context to `TemplateRef` to make it even more dynamic. A good example
    to showcase `ng-template` with context is by creating a dynamic select component,
    so go ahead and create a select component inside the `common-components` library,
    next to the `modal` and `display-scales` components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve created the `select` component, start by adding an input for the
    select options and a `TemplateRef` element. Also, add an input for the default
    `selectedIndex` options and an output for when the selection changes. Lastly,
    add a function to set the selected index when a selection is made and emit the
    selected value using the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add the HTML for our dynamic select component. Start by creating
    a select element and an option for when there is no selected value. Next, add
    an `ng-container` element with a `*ngFor` directive looping over each option that’s
    received in the options input. We will also track the index of the `for` loop
    because we will use the index for the option value. Inside the `*ngFor` element,
    we’ll define an option element and another `ng-container` element that defines
    the `ngTemplateOutlet` directive to either display a default template or the template
    received as input. The default template can be used when the select options have
    no special display needs. In all other scenarios, a template can be provided through
    the `optionTemplate` input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we also added the `ngTemplateOutletContext` directive to the
    `ng-container` element, which will display the template. The `ngTemplateOutletContext`
    directive is assigned to an object containing a `$implicit` property. The object
    you assign to the `ngTemplateOutletContext` directive can be used within the `ng-template`
    element, as we did in the preceding code snippet. You can use the `$implicit`
    value from the preceding code example inside an `ng-template` element. To use
    the `$implicit` value, you must use the `let-propertyName` syntax, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[shown property so that it can be used in the ng-template element using this
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: <ng-template let-shownValue="shown">
  prefs: []
  type: TYPE_NORMAL
- en: <div>{{shownValue}}</div>
  prefs: []
  type: TYPE_NORMAL
- en: </ng-template>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: <bt-libs-select (selectedChange)="onOptionChange($event)" [options]="['Test',
    'Test 2']">
  prefs: []
  type: TYPE_NORMAL
- en: </bt-libs-select>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[{expense: ''Food'',amount: 10},{expense: ''Gas'',amount: 20}]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '<ng-template #expenseSelect let-expense>'
  prefs: []
  type: TYPE_NORMAL
- en: '<span>Product: {{ expense.expense }}, Amount: {{ expense.amount }}</span>'
  prefs: []
  type: TYPE_NORMAL
- en: </ng-template>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: <bt-libs-select (selectedChange)="onOptionChange($event)" [optionTemplate]="expenseSelect"
    [options]="expenses">
  prefs: []
  type: TYPE_NORMAL
- en: </bt-libs-select>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: <ng-container *ngComponentOutlet="widget.component" />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'export interface widget { component: Type<any> | null };'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '@Input() widget: widget = {component: null};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: <bt-libs-widget-container *ngIf="activeWidget" [widget]="activeWidget"></bt-libs-widget-container>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'activeWidget!: widget;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: protected readonly cd = inject(ChangeDetectorRef);
  prefs: []
  type: TYPE_NORMAL
- en: showWeather = true;
  prefs: []
  type: TYPE_NORMAL
- en: ngOnInit() {
  prefs: []
  type: TYPE_NORMAL
- en: setInterval(() => {
  prefs: []
  type: TYPE_NORMAL
- en: 'this.activeWidget = { component: this.showWeather ? WeatherWidgetComponent
    : ClockWidgetComponent };'
  prefs: []
  type: TYPE_NORMAL
- en: this.showWeather = !this.showWeather;
  prefs: []
  type: TYPE_NORMAL
- en: this.cd.detectChanges();
  prefs: []
  type: TYPE_NORMAL
- en: '}, 5000)'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '<ng-container *ngComponentOutlet="widget.component; injector property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'export interface WeatherWidgetData {city: string; message: string;}'
  prefs: []
  type: TYPE_NORMAL
- en: export const WEATHERWIDGET = new InjectionToken<WeatherWidgetData>('weather
    widgets');
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: widgetData = inject(WEATHERWIDGET);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '<p>{{widgetData.city}}: {{widgetData.message}}</p>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '{ component: WeatherWidgetComponent }'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Injector.create()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '{ providers: [{ provide: WEATHERWIDGET, useValue: { city: ''Amsterdam'', message:
    ''Sunny'' } }] }'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Injector.create({ providers: [{ provide: WEATHERWIDGET, useValue: { city: ''Amsterdam'',
    message: ''Sunny'' } }] })'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '{ component: WeatherWidgetComponent, injector: Injector.create({ providers:
    [{ provide: WEATHERWIDGET, useValue: { city: ''Amsterdam'', message: ''Sunny''
    } }] }) }'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '@Input() city: string;'
  prefs: []
  type: TYPE_NORMAL
- en: '@Input() message: string;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '<ng-container *ngComponentOutlet="widget.component; inputs property of the
    ngComponentOutlet directive needs to receive an object; in our case, we named
    the object widgetInputs. The object has a key for each input property of the component
    and a corresponding value. So, in our case, the widgetInputs object looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Using the `inputs` property is a lot easier, but it can only provide objects
    with simple values. Using the `injector` property provides more flexibility because
    it can provide simple values but also classes, services, and everything else you
    can inject within Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Our widget system can already render components dynamically and provide injectors
    to the dynamically created components. But the dynamically rendered components
    are still loaded eagerly, so we still need to improve a bit so that we only load
    the widget components when they need to be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading dynamic components
  prefs: []
  type: TYPE_NORMAL
- en: To improve things further, we can lazy load our dynamic components. Currently,
    when you load the page, all widgets will be loaded upfront. It would be better
    if we only loaded the widget components if we needed them, or in other terms lazy
    loaded the components. We need to change our widget container component so that
    it lazy loads our dynamically rendered components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new file named `widget-loaders.ts`. The `widget-loaders.ts`
    file will list some types and an object with the import statements for the lazy
    loaded widgets, a bit like lazy loading components with the router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We started by creating a `widgetKeys` constant; here, you define all the keys
    you can use inside the `widgetLoaders` object. Next, we make a type of the `widgetKeys`
    constant to create a type-safe `WidgetLoader` type. The `WidgetLoader` type defines
    a key-value pair where the keys can only be values declared inside the `widgetKeys`
    constant.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we created the `widgetLoaders` object, which types with the `WidgetLoader`
    type. The `widgetLoaders` object will hold key-value pairs where the keys are
    values from the `widgetKeys` constant and the values import statements for the
    lazy loaded widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we created a `WidgetOption` type, which allows you to take a single
    value of the `widgetLoaders` object and nothing else. Now that we’ve created a
    type-safe way to define and select widget loaders, we can start to adjust the
    widget container component.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must remove the widget input we had and replace it with a regular
    input property. Then, we can add an input for the `injector` property and one
    for a `WidgetOption` property from the `widgetLoaders` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to inject `ChangeDetectorRef` because we have to trigger change
    detection manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you must add the `ngOnChanges` life cycle hook with the `async` keyword
    in front because we will use async `await` to load the dynamic component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `ngOnChanges` life cycle hook, we will get the current value of
    the `widgetLoader` input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll use the `widgetLoader` value to lazy load the widget component.
    When the widget component is loaded, we will assign the widget property using
    the lazy-loaded component and the `injector` property. Lastly, we need to trigger
    change detection to reflect the changes within the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding changes added to the widget container component, everything
    is in place, and you can lazy load and render widget components dynamically. To
    test this, we need to use the widget container component inside another component
    and give it a widget loader and injector as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, if you want to alternate between the clock and weather widget,
    you can add the following code to the component class where you’ve added the widget
    container in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: When you inspect the **Network** tab of your browser’s developer tools, you
    will see the weather and clock widget components being loaded when they enter
    the view for the first time. When the widgets are displayed again, and the components
    are already loaded, the browser won’t load them again because the browser caches
    them for you. Now, you have a truly dynamic widget system where you can lazy load
    and render widgets on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering components dynamically using the defer control flow
  prefs: []
  type: TYPE_NORMAL
- en: In Angular 17, the `defer-widget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `DeferWidgetComponent` will have the same functionality as our `widget-container`
    component, only it will use the defer control flow instead of the `ngComponentOutlet`
    directive. You can start by creating a component named `defer-widget`, next to
    the `widget-container` component. Once you’ve created the component. create a
    `widgets.enum.ts` file in the newly created `defer-widget` folder. Add the following
    `enum` inside the `widgets.enum.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to add an input for the active widget, the widget data, and
    a property with a reference to the `Widgets` enum inside `DeferWidgetComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Inside the HTML template of `DeferWidgetComponent`, you need to add your widget
    components inside a defer block. Defer blocks receive a trigger as a parameter.
    When the defer trigger is triggered, the defer block will load and render the
    content that is inside the defer block. For your widget component, you need to
    use the `when` trigger. The `when` trigger loads and renders the content when
    the provided condition resolves to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also want our content to hide again when the condition is `false` again.
    To hide your content when the condition is `false`, you also need to add a `*ngIf`
    directive or use the `if` control flow. I will use the `*``ngIf` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Without the `*ngIf` directive or if control flow syntax, the widget will not
    disappear if the condition returns `false`. The `when` statement of the `defer`
    syntax will not evaluate the condition again after it has resolved to true.
  prefs: []
  type: TYPE_NORMAL
- en: The aforementioned code is everything you need to lazy load and render widgets.
    As you can see, this is a lot easier compared to using the `ngComponentOutlet`
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we already had some code in place, we still need to make some changes
    to the weather widget for our new defer solution to work. Inside the weather widget
    component, you have a `widgetData` property. You can place this under `comment`
    and replace it with a `@Input()` property, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The `widgetData` property we commented out is used for the `ngComponentOutlet`
    directive approach. For our new defer approach, we will use a regular component,
    `@Input()`. You can also update the HTML template of the weather component and
    only render the city and message if we receive the `widgetData` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, everything should work! To test `DeferWidgetComponent`, we can use it
    in `expensesOverviewComponent`, where we now use `widgetContainerComponent`. In
    the HTML template, you can swap the old widget container with the new defer widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we only need `widget` and `widgetData` properties inside `expensesOverviewComponent`
    and must set their values. You can comment out the old `widget` and `injector`
    properties we used for the widget container and add these two properties instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we have to change the logic inside `setInterval`. Once again, you can
    comment out the old code we used to alternate the weather and clock widgets for
    the widgets container and replace it with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you save everything, the new defer widget component should work identically
    to the widget container component. After 5 seconds, the clock widget will be lazy
    loaded and rendered, and 5 seconds after that, the weather widget will be lazy
    loaded and rendered. The two widgets will alternate every 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ve created a widget component with lazy loaded widgets using
    the `ngComponentOutlet` directive and the defer control flow syntax. With the
    `ngComponentOutlet` directive, you can provide injectors and you don’t have to
    remove the widgets with the `*ngIf` directive, but overall, the defer control
    flow syntax feels a lot cleaner and easier.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: We learned a lot in this chapter! First, you learned how to make components
    more flexible using content projection. We created a modal component and showcased
    content projection with a single slot and multiple slots. We also learned that
    you can’t combine structural directives on projected content.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we did a deep dive into template variables and template references. You
    learned how to create flexible and dynamic components using `ng-template`, how
    to access the values of components and input properties using template variables,
    and how to display different templates based on specific conditions. You also
    learned how to provide context to `ng-template` elements to build truly dynamic
    components that can fit almost all design needs you could have for a component.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you learned about dynamic component rendering and loading. You learned
    when you should use dynamically rendered or loaded components and how you can
    dynamically render and lazy load components at runtime using the `ngComponentOutlet`
    and `@``defer` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start to learn about conventions and design patterns
    within Angular so that we can improve the setup and implementation of our code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
