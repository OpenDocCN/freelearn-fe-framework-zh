- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying Your Code to the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, you had an in-depth look at testing and how it
    can benefit your application. Now that you’re confident in the stability and usability
    of your Vue.js application, it’s time to take a deeper look at how to get that
    code up on the web.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will be able to explain the benefits of a CI/CD workflow
    and how it ties into the release cycle, release cadence, and development workflows.
    To this end, you’ll be able to articulate the differences between Vue.js development
    and production builds and what trade-offs are made.
  prefs: []
  type: TYPE_NORMAL
- en: To test and deploy a Vue.js application, you’ll configure GitLab CI/CD with
    pipelines, jobs, and steps. You’ll become familiar with Netlify, **Amazon Web
    Services Simple Storage Service** (**AWS S3**), and AWS CloudFront, and their
    key similarities and differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the benefits of CI/CD as part of an agile software development process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building our apps for production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GitLab CI/CD to test our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to Netlify
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to AWS using S3 and CloudFront
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need the `git` CLI, which you will have already used.
    You will also need accounts with both Netlify and Amazon AWS.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may find this chapter’s source here: [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the benefits of CI/CD as part of an agile software development process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous integration** (**CI**) is the practice of integrating code multiple
    times a day. To support this, a modern **version control system** (**VCS**), such
    as Git, which supports multiple working states (branches) in a single repository,
    is necessary to allow developers to work on code independently, while still allowing
    them to collaborate and integrate their changes safely.'
  prefs: []
  type: TYPE_NORMAL
- en: To augment the abilities of the VCS, hosting and collaboration tools around
    repositories (such as GitLab or GitHub) have been created that allow developers
    to view and manage code changes more efficiently through a web **user** **interface**
    (**UI**).
  prefs: []
  type: TYPE_NORMAL
- en: As part of, or in addition to, these hosting platforms and the collaboration
    tools they provide, automated checks are crucial to maintaining high confidence
    in the quality of the code before, during, and after integration.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting a CI approach often entails including additional code quality steps,
    such as unit or integration tests, coverage checks, and building artifacts on
    the mainline branches (branches into which changes are integrated) every time
    any new code is integrated. The convention that a team follows for using Git for
    code collaboration and CI is called a **Git workflow**, which is often shortened
    to **Git flow**.
  prefs: []
  type: TYPE_NORMAL
- en: A Git flow will predicate branch naming conventions, as well as how and when
    changes are integrated. For example, a team might decide that branches should
    be prefixed with ticket numbers followed by a short dash-cased description, such
    as `WRK-2334-fix-ie-11-scroll`.
  prefs: []
  type: TYPE_NORMAL
- en: Other examples of conventions that are decided on and adhered to as part of
    a Git flow are commit message lengths and titles, the automated checks that should
    pass or are allowed to fail, and the number of reviewers required to merge a change
    request, which is a pull request or merge request in GitHub and GitLab parlance,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Git flows fall under two rough categories: (feature) branch-based development
    and trunk-based development. We’ll cover branch-based development first since
    its limitations have become quite clear and the majority of projects tend to use
    trunk-based development.'
  prefs: []
  type: TYPE_NORMAL
- en: In a branch-based Git workflow, multiple working branches are kept in the repository.
    Branch-based flows can be used to keep branches that mirror the state of environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows three branches – production, staging, and develop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – A branch-based Git commit/branch tree with three environment
    branches](img/Figure_13.01_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – A branch-based Git commit/branch tree with three environment branches
  prefs: []
  type: TYPE_NORMAL
- en: 'The *production* branch does not contain any changes from *staging* or *develop*.
    The *staging* is ahead of the *production* branch but has no changes in common
    with the *develop* branch other than the changes that are on the *production*
    branch. The *develop* branch is ahead of both the *staging* and *production* branches:
    it’s branched off the *production* branch at the same commit as the *staging*
    branch, but it doesn’t share any further commits with the *staging* branch.'
  prefs: []
  type: TYPE_NORMAL
- en: A branch-based workflow can also be used to keep track of changes going into
    release lines. This is useful in cases where a project has to maintain two versions
    of an application or library, but bug fixes or security patches need to be applied
    to both versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we have got a similar branching example as the environment
    branch one. Release 1.0.0 contains some changes that are not present in 1.0.1
    and 1.1.0 but does not share any of the newer code. Releases 1.0.1 and 1.1.0 are
    branched off of 1.0.0 at the same time, but they do not share further changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – A branch-based Git commit/branch tree with three release branches](img/Figure_13.02_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – A branch-based Git commit/branch tree with three release branches
  prefs: []
  type: TYPE_NORMAL
- en: 'In a trunk-based Git flow, each member of the team will create new branches
    off of a single branch, usually the *master* branch. This process is often referred
    to as **branching** **off of**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – A sample trunk-based Git commit/branch tree with two feature
    branches branched off of the master](img/Figure_13.03_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – A sample trunk-based Git commit/branch tree with two feature branches
    branched off of the master
  prefs: []
  type: TYPE_NORMAL
- en: An extreme case of a trunk-based workflow is to have a *single* branch that
    everyone commits on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In a trunk-based environment, an alternative to *release branches* is to use
    Git tags to keep track of release snapshots. This gives the same advantages as
    maintaining branches but with reduced branch noise and the added benefit of immutability
    since tags cannot be changed once they’re created.
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous delivery** (**CD**) is the ability of a team to deploy every good
    build to a production environment.'
  prefs: []
  type: TYPE_NORMAL
- en: A prerequisite to CD is CI since CI provides some initial confidence in the
    quality of a build. As part of CD, new systems, tools, and practices are required
    beyond CI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the tools and practices that relate more to CI
    and those that relate more to CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – The relationship between CI and CD practices](img/Figure_13.04_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – The relationship between CI and CD practices
  prefs: []
  type: TYPE_NORMAL
- en: The extra ingredient required to adopt CD is a high level of confidence that
    the application is going to keep working as expected (for the end user) and that
    new defects have not been unwittingly introduced. This means an additional end-to-end
    testing step is needed during or after the CI checks, to validate the build before
    being able to deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: These end-to-end tests can be conducted manually, or they can be automated.
    In an ideal CD setup, the latter (automated end-to-end tests) is preferred since
    it means deployments do not include manual interaction. If the end-to-end tests
    pass, the build can be deployed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate CD, systems that used to deploy software have had to be rethought.
    As part of CD, deployment cannot be a long-winded manual process. This has led
    to companies adopting cloud-native technologies, such as Docker, and **Infrastructure
    as Code** (**IaC**) tools, such as HashiCorp’s **Terraform**.
  prefs: []
  type: TYPE_NORMAL
- en: The emphasis on moving toward CD practices has led to the inception of ideas
    such as **GitOps** and **ChatOps**. In GitOps and ChatOps, deployments and operational
    tasks are driven by the tools that developers and stakeholders interact with daily.
  prefs: []
  type: TYPE_NORMAL
- en: In GitOps, deployments can be done through GitHub/GitLab (or another Git-hosting
    provider), directly with GitHub Actions or GitLab CI/CD, or through CI/CD software
    (such as CircleCI or Jenkins), which have tight integrations and reporting with
    GitHub/GitLab.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of ChatOps, conversational interfaces are used to deploy and operate
    the software. Some flavors of ChatOps can be considered a subset of GitOps – for
    example, interacting with tools such as **Dependabot** (a tool that keeps a project’s
    dependencies up to date) through comments on a GitHub pull request.
  prefs: []
  type: TYPE_NORMAL
- en: ChatOps can also be implemented right into real-time chat tools, such as Slack
    or Microsoft Teams. Someone might send a message such as `deploy <service-name>
    <environment>`, which will deploy the service to the relevant environment. Note
    that chat interfaces are very reminiscent of command-line interfaces, which developers
    might be used to but other stakeholders might take some time to adopt them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve looked at approaches to CI and CD, let’s discuss the advantages
    of using CI and CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Continuous Integration** | **Continuous Delivery** |'
  prefs: []
  type: TYPE_TB
- en: '| Ensures the changeset being integrated is small (at most, a couple of days’
    worth of work) | Delivering value to production can be done more often and more
    safely |'
  prefs: []
  type: TYPE_TB
- en: '| Reduces the chance of huge sweeping changes across the code base causing
    unforeseen bugs | A small changeset (a couple of days’ worth of work) can be rolled
    back without any issue |'
  prefs: []
  type: TYPE_TB
- en: '| Testing, code quality, and review steps give confidence in a clean integration
    | A larger changeset due to a longer fixed (monthly, weekly, or every sprint)
    release cadence (as opposed to CD) can have unforeseen consequences; the effect
    rollbacks have on a large release is complicated to grasp |'
  prefs: []
  type: TYPE_TB
- en: Figure 13.5 – Advantages of CI and CD
  prefs: []
  type: TYPE_NORMAL
- en: Both practices also have an impact on the team’s mindset and performance. Being
    able to see the changes you make integrated within a day and in production in
    less than a week means that contributors can see their work having an impact immediately.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD also helps promote agile principles, where changes are applied and deployed
    iteratively. This is as opposed to long timelines for projects, for which inaccuracies
    in estimations compound and can cause major delays.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ve had a deep look at CI and CD. While both certainly imply more
    work in your process, the benefits will pay for themselves down the road with
    better stability and the ability to more nimbly respond to issues and add new
    features. Now, let’s put this into practice.
  prefs: []
  type: TYPE_NORMAL
- en: Building our apps for production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying applications to production starts with creating an artifact that can
    be deployed. In the case of Vue.js, we’re building a client-side application,
    which means our build artifact will contain HTML, JavaScript, and CSS files.
  prefs: []
  type: TYPE_NORMAL
- en: A Vue project scaffolded with Vite will have a `build` command. As part of the
    build process, Vite will take JavaScript, Vue single-file components, and modules
    that are imported into each other and *bundle* them. **Bundling** means that related
    chunks of code that depend on each other will be output as a single JavaScript
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The Vue CLI build step also includes a `dead code elimination` step. This means
    that it can analyze the code being generated and if any of it is never used –
    for example, a statement such as `if (false) { /* do something */}` – then it
    will not be present in the build output.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Vite builds for production when we call `vite build`, which,
    in Vue projects, is aliased to the `build` script, which can be run with `npm
    run build` or `yarn build`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a sample Vue project, we’ll see something along these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Output of “npm run build” in a fresh Vue project](img/Figure_13.06_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Output of “npm run build” in a fresh Vue project
  prefs: []
  type: TYPE_NORMAL
- en: The `dist` folder is now ready to deploy using a static hosting solution such
    as Netlify or AWS S3 and CloudFront.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve seen how to build a Vue.js application for production using
    the Vite CLI with the `npm run build` command. Next, we will learn how to use
    GitLab CI/CD to test our code (before deploying it).
  prefs: []
  type: TYPE_NORMAL
- en: Using GitLab CI/CD to test our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitLab has a built-in CI/CD tool called GitLab CI/CD. To use GitLab CI/CD, you’ll
    need a GitLab account. To interact with Git repositories hosted on GitLab, you’ll
    also need to associate an SSH key from your machine to your GitLab account.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Instructions for adding an SSH key can be found in the GitLab documentation
    at [https://docs.gitlab.com/ee/ssh/index.html](https://docs.gitlab.com/ee/ssh/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve created an account, you can create a new repository using the **Create
    blank project** action, as shown in the following screenshot. If you are an existing
    user, you can use the **Create new project** button at the top right of the **Projects**
    page.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – The GitLab Projects page with the New Project button](img/Figure_13.07_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – The GitLab Projects page with the New Project button
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of your choice, you will be taken to the **New project** page, where
    you can create a project by giving it a name and a slug, as seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.8 – The GitLab New \uFEFFproject page](img/Figure_13.08_B18645.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – The GitLab New project page
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click **Create project**, the GitLab project page will appear in an
    empty state that displays instructions on how to clone it. You should run the
    commands required to clone the repository, which probably boils down to something
    similar to the following (which you are expected to run on your machine):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can find the proper URL by clicking on the blue **Clone** button.
  prefs: []
  type: TYPE_NORMAL
- en: On your machine, open the directory into which the repository was cloned. To
    add GitLab CI/CD, we need to add a `.gitlab-ci.yml` file to the root of the project.
    A sample `.gitlab-ci.yml` file that adds a `build` job to the `build` stage of
    the pipeline, installs dependencies (using `npm ci`), runs the production build
    (`npm run build`), and caches the output artifact is defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: It will begin with a job name that is defined by setting a top-level key in
    the YAML file – in this case, `build:`. In YAML syntax, we must increase the indent
    to denote that the `build` key points to an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `build job` object, we will define which Docker image is used to run
    the job, using `image: node:lts`. This means we want this job to run on a Node.js
    **Long-Term Support** (**LTS**) image, which will be Node.js 16 as of early 2022.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can access the up-to-date Node.js LTS schedule at [https://nodejs.org/en/about/releases/](https://nodejs.org/en/about/releases/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The other property we can define in our job is the stage. By default, GitLab
    CI/CD pipelines have three stages: **Build**, **Test**, and **Deploy**. These
    stages can be replaced using custom stages when a team’s workflow doesn’t fit
    into these three categories (for example, if there is more than one environment
    to deploy to). Our pipeline only has one stage and one job at the moment, so most
    of the preceding doesn’t apply to us.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you’re curious, `stages` is used to define stages that can be used by jobs,
    and it is defined globally ([https://docs.gitlab.com/ee/ci/yaml/#stages](https://docs.gitlab.com/ee/ci/yaml/#stages)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The specification of `stages` allows for flexible multistage pipelines. The
    ordering of elements in stages defines the ordering of jobs’ execution:'
  prefs: []
  type: TYPE_NORMAL
- en: a) Jobs of the same stage are run in parallel
  prefs: []
  type: TYPE_NORMAL
- en: b) Jobs of the next stage are run after the jobs from the previous stage have
    been completed successfully
  prefs: []
  type: TYPE_NORMAL
- en: 'See the documentation for more information: [https://docs.gitlab.com/ee/ci/yaml/#stages](https://docs.gitlab.com/ee/ci/yaml/#stages).'
  prefs: []
  type: TYPE_NORMAL
- en: The final properties we set are `script`, which defines steps that should be
    run when the job is running, and `artifacts`, which configures artifact storage.
    In our case, we’ll run `npm ci` to install all the dependencies, followed by `npm
    run build`, which will run the production Vue.js build. Our artifact has been
    set up to be held for a week and to contain the `dist` folder (which is where
    the Vite CLI `build` output is stored).
  prefs: []
  type: TYPE_NORMAL
- en: 'In full, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we push this `.gitlab-ci.yml` file to a repository containing a Vue CLI
    project, we will see the following in the repository view, where a pipeline with
    one step is running on the latest commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – GitLab repository view with the build job running on the latest
    commit](img/Figure_13.09_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – GitLab repository view with the build job running on the latest
    commit
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: GitLab now requires user verification before running pipelines. This can be
    done with a credit card; GitLab will *not* charge your card. It is only used as
    part of the validation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we click on the `Build` represents the `state` pipeline (which we set as
    `build`), which represents the job name (which we defined as `build`). We will
    see the same in-progress indicator until the job completes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – GitLab CI pipeline view with the build job complete](img/Figure_13.10_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.10 – GitLab CI pipeline view with the build job complete
  prefs: []
  type: TYPE_NORMAL
- en: Once the job completes, we will see a **Success** icon (green checkmark). We
    can click this icon or the job name to access the **Job** view while the job is
    running or after it has been completed (whether it has failed or succeeded). When
    a job has been completed, we will also see a **Retry** icon, which can be useful
    if we wish to retry a failed pipeline step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows that the job ran successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11 – GitLab CI pipeline view with the build job passing](img/Figure_13.11_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.11 – GitLab CI pipeline view with the build job passing
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking the job, we will see the `docker_machine` executor, which load
    up the Node.js Docker image, we can see the steps for running the script, as well
    as cache and artifact restores, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12 – The GitLab CI job view with the successful build job](img/Figure_13.12_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.12 – The GitLab CI job view with the successful build job
  prefs: []
  type: TYPE_NORMAL
- en: If we want to add a `test` step to our GitLab CI/CD runs, we need to be in a
    project that supports unit testing. Installing and adding unit tests was covered
    in depth in [*Chapter 11*](B18645_11.xhtml#_idTextAnchor444), *Unit Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to add a new job to the `.gitlab-ci.yml` file; we will call it
    `test`, use the `node:lts` image, and assign the job to the `test` state. In the
    job, we must run `npm ci`, followed by `npm run test:unit` (which is the `npm`
    script added by the `unit-jest` CLI plugin):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we push this new `.gitlab-ci.yml` file up, we will get the following view
    on the main repository page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13 – Repository view with GitLab CI/CD running the pipeline with
    the new test step](img/Figure_13.13_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.13 – Repository view with GitLab CI/CD running the pipeline with the
    new test step
  prefs: []
  type: TYPE_NORMAL
- en: 'We can click through to the pipeline view. The reason GitLab CI/CD uses pipelines
    is that a failing step at a certain stage will mean steps in any subsequent stages
    will not run. For example, if we get a failing `build` job, the jobs that are
    part of the `test` stage will not run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.14 – GitLab CI/CD pipeline view with a failed build job that stops
    the test job/stage from running](img/Figure_13.14_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.14 – GitLab CI/CD pipeline view with a failed build job that stops
    the test job/stage from running
  prefs: []
  type: TYPE_NORMAL
- en: 'If we push another commit or retry the build step (if the failure is not caused
    by changes) and navigate to the pipeline view again, we’ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.15 – GitLab CI/CD pipeline view with the test job running after
    the build stage jobs have all succeeded](img/Figure_13.15_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.15 – GitLab CI/CD pipeline view with the test job running after the
    build stage jobs have all succeeded
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `test` job has succeeded, we’ll see the following pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.16 – GitLab CI/CD pipeline view with all jobs succeeding in the
    build and test stages](img/Figure_13.16_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.16 – GitLab CI/CD pipeline view with all jobs succeeding in the build
    and test stages
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now added a GitLab CI/CD pipeline with the `build` and `test` stages that
    will validate that, on every push to the GitLab repository, the code still integrates
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 13.01 – adding a lint step to our GitLab CI/CD pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Linting** is a way to get automated formatting and code style checks. Integrating
    it as part of CI makes sure that all code merged into the mainline branches adheres
    to a team’s code style guide. It also reduces the number of code style review
    comments, which can be noisy and might detract from fundamental issues with the
    change request.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete code for this exercise at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Exercise13.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Exercise13.01)
  prefs: []
  type: TYPE_NORMAL
- en: 'To add linting, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to ensure that our `package.json` file includes the `lint` script.
    If it’s missing, we’ll need to add it. The `eslint-plugin-vue` website ([https://eslint.vuejs.org/](https://eslint.vuejs.org/))
    documents this. Once installed, use it in the lint script, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the lint on GitLab CI/CD, add a new `lint` job that will run in a Node.js
    LTS Docker image at the `test` stage of the GitLab CI/CD pipeline. We will do
    this in `.gitlab-ci.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `lint` job to run the `lint` script as per `package.json`, we need
    to add a `script` section in the `.gitlab-ci.yml` file. First, it needs to run
    `npm ci` to install the dependencies, and then `npm run lint` to start the linting
    process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, `commit` and `push` the code to GitLab using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the code has been pushed, we will see the pipeline run using the GitLab
    CI/CD UI, as follows (note how all the jobs at the `test` stage are run in parallel):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.17 – The GitLab CI/CD pipeline view with all the jobs succeeding,
    including “test” and “lint” running in parallel](img/Figure_13.17_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.17 – The GitLab CI/CD pipeline view with all the jobs succeeding,
    including “test” and “lint” running in parallel
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to use GitLab CI/CD to run builds and tests on every commit.
    Next, we’ll learn how to deploy a Vue.js application to Netlify.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Netlify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Netlify is a hosting provider that specializes in static hosting and relevant
    supporting services to provide a fully interactive site that uses static hosting.
    This includes offerings such as Netlify Functions (serverless functions), Netlify
    Forms (a no-backend form submission system), and Netlify Identity (an identity/authentication
    provider).
  prefs: []
  type: TYPE_NORMAL
- en: The following sections require you to have a free Netlify account (you can sign
    up for one at [https://app.netlify.com/signup](https://app.netlify.com/signup)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to deploy a site to Netlify is to use the drag-and-drop interface.
    You’ll find this at the bottom of the **Sites** page in the logged-in view, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.18 – Netlify’s drag-and-drop deployment section at the bottom of
    the App home page](img/Figure_13.18_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.18 – Netlify’s drag-and-drop deployment section at the bottom of the
    App home page
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can choose a project where we’ve run the `npm run build` command and
    deploy the `dist` folder by simply dragging it to the drag-and-drop deployment
    section, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.19 – Dragging and dropping the dist folder into the Netlify drag-and-drop
    deployment section](img/Figure_13.19_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.19 – Dragging and dropping the dist folder into the Netlify drag-and-drop
    deployment section
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the upload has succeeded, Netlify will redirect you to your new website’s
    administration page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.20 – The Netlify new app page for the drag-and-drop site](img/Figure_13.20_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.20 – The Netlify new app page for the drag-and-drop site
  prefs: []
  type: TYPE_NORMAL
- en: 'We can click on the link to the site. We’ll see the default Vue CLI home page
    template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.21 – Netlify new app displaying a greeting message](img/Figure_13.21_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.21 – Netlify new app displaying a greeting message
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve learned how to manually deploy a site to Netlify using the
    drag-and-drop interface.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to deploy our site from GitLab to Netlify.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Netlify app’s **Sites** page, we need to click the **Add new site**
    button, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.22 – Netlify home page with the New site from Git button](img/Figure_13.22_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.22 – Netlify home page with the New site from Git button
  prefs: []
  type: TYPE_NORMAL
- en: 'In the dropdown, select **Import an existing project**. We’ll see a page asking
    us to choose a Git provider to connect to. For this example, we will use **GitLab**.
    The following screenshot shows what the screen will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.23 – Netlify – Create a new site | Connect to Git provider](img/Figure_13.23_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.23 – Netlify – Create a new site | Connect to Git provider
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon clicking **GitLab**, we will get an OAuth authorization challenge from
    GitLab, which we need to accept by clicking on the **Authorize** button, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.24 – GitLab OAuth authorization modal](img/Figure_13.24_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.24 – GitLab OAuth authorization modal
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then be redirected to Netlify and asked to choose a repository to deploy,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.25 – Selecting a GitLab repository to deploy](img/Figure_13.25_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.25 – Selecting a GitLab repository to deploy
  prefs: []
  type: TYPE_NORMAL
- en: After selecting the repository we want to deploy, we will be met with a configuration
    page. Since we’re now building on Netlify’s build servers, we need to configure
    Netlify to build the application and deploy the correct folder.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Netlify figures out both the proper `build` command (`npm run build`)
    and publish directory (`dist`). If you need to change these values for some reason,
    you can, but the defaults should work for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we must click the **Deploy site** button, which will start the deployment
    process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.26 – The Netlify build configuration tab with configured settings](img/Figure_13.26_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.26 – The Netlify build configuration tab with configured settings
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then be redirected to the newly created app’s page, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.27 – New Netlify app](img/Figure_13.27_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.27 – New Netlify app
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to deploy an application to Netlify using the manual upload
    method while using GitLab as the Git hosting provider.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 13.02 – deploying a site to Netlify from GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous exercise, you saw how to deploy a site to Netlify from GitLab.
    In this exercise, we’ll modify that process to deploy from GitHub. How different
    is it from deploying it from GitLab? The answer is that they are very similar;
    the only notable difference is the first step in the **Connect to Git** **provider**
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by clicking the **Add new site** button on the **Sites** page, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.28 – Add new site on the Netlify dashboard](img/Figure_13.28_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.28 – Add new site on the Netlify dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Import an existing project** and choose **GitHub** as the Git hosting
    provider, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.29 – Continuous deployment](img/Figure_13.29_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.29 – Continuous deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'When we get the GitHub OAuth authorization challenge, as shown in the following
    screenshot, we must authorize Netlify:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.30 – GitHub authorization challenge](img/Figure_13.30_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.30 – GitHub authorization challenge
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the Vue CLI project we want to deploy from the repository list, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.31 – Selecting the correct repository](img/Figure_13.31_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.31 – Selecting the correct repository
  prefs: []
  type: TYPE_NORMAL
- en: On the `master` (or `main`, depending on your repository) as the branch to deploy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `npm` `run build`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `dist`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last two points look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.32 – The Netlify build configuration tab has been filled in with
    the proper settings](img/Figure_13.32_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.32 – The Netlify build configuration tab has been filled in with the
    proper settings
  prefs: []
  type: TYPE_NORMAL
- en: Click **Deploy site** to start the deployment process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve now seen how to deploy an application to Netlify using the manual upload
    method and using GitLab or GitHub as the Git hosting provider. Next, we will learn
    how to use AWS S3 and AWS CloudFront to deploy a Vue.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to AWS using S3 and CloudFront
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon S3 is a static storage offering that can be used as a host for static
    files, such as what is generated by the Vue CLI’s `build` script.
  prefs: []
  type: TYPE_NORMAL
- en: CloudFront is AWS’s **Content Delivery Network** (**CDN**) offering. A CDN can
    improve a web application’s performance by serving static content from an **edge**
    location. These servers are positioned around the world and are more likely to
    be geographically located close to the end user than the **origin** servers (the
    ones that serve the content). The edge servers in a CDN request resources from
    the origin if they don’t have them cached but will serve subsequent requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s learn how to configure S3 to host a Vue.js application (to do this, make
    sure that you have an AWS account):'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating and configuring an S3 bucket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do this, head to the S3 product page. It will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.33 – Selecting S3 from the AWS service list](img/Figure_13.33_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.33 – Selecting S3 from the AWS service list
  prefs: []
  type: TYPE_NORMAL
- en: 'On the S3 console home page, click the **Create bucket** button, which will
    take us to the bucket creation page, as seen here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF3.34 – The Create bucket button in the AWS S3 console](img/Figure_13.34_B18645.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.34 – The Create bucket button in the AWS S3 console
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we will start by naming our bucket. Bucket names must be unique,
    so consider using `vue-workshop-yourname`. For this example, we’ve called it `vue-workshop-ray`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.35 – Entering the bucket name on the bucket creation page](img/Figure_13.35_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.35 – Entering the bucket name on the bucket creation page
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to set the S3 bucket to be public. This can be done by unselecting
    the **Block all public access** checkbox. Once this is done, we must check the
    acknowledgment checkbox, as seen here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.36 – Setting the S3 bucket to be public and acknowledging the warning](img/Figure_13.36_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.36 – Setting the S3 bucket to be public and acknowledging the warning
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, we will be redirected to the bucket list page. We want to
    click into our new bucket. Then, we need to access the **Properties** tag to find
    the **Static website** **hosting** option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.37 – The Static website hosting option in the S3 bucket’s Properties
    tab](img/Figure_13.37_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.37 – The Static website hosting option in the S3 bucket’s Properties
    tab
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fill in the `index.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.38 – Filling out the Static website hosting S3 property](img/Figure_13.38_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.38 – Filling out the Static website hosting S3 property
  prefs: []
  type: TYPE_NORMAL
- en: 'After saving your changes, note the endpoint URL, which you will need for CloudFront:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.39 – Noting the endpoint URL](img/Figure_13.39_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.39 – Noting the endpoint URL
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now go back to the `dist` folders, as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.40 – Adding files to the vue-workshop S3 bucket through drag and
    drop](img/Figure_13.40_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.40 – Adding files to the vue-workshop S3 bucket through drag and drop
  prefs: []
  type: TYPE_NORMAL
- en: Once the files have been dropped onto the **Overview** page, we must click **Upload**
    to complete the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to set a bucket policy to allow for read access to the files
    we’ve just uploaded. To do this, click the **Permissions** tab, and then **Edit**
    in the **Bucket policy** section. In the **Policy editor** area, paste the following
    JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Be sure to change `vue-workshop-ray` to the bucket name you chose and click
    **Save changes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.41 – Setting file permissions to public on files being uploaded
    to the S3 bucket](img/Figure_13.41_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.41 – Setting file permissions to public on files being uploaded to
    the S3 bucket
  prefs: []
  type: TYPE_NORMAL
- en: 'Our S3 bucket should now be configured to host static content. By visiting
    the website endpoint (available under **Properties** | **Static website hosting**),
    we will see the following Vue.js application (which is what we uploaded):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.42 – The Vue.js application being served from our AWS S3 bucket](img/Figure_13.42_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.42 – The Vue.js application being served from our AWS S3 bucket
  prefs: []
  type: TYPE_NORMAL
- en: Note that S3 can only serve sites over HTTP, and domain names cannot be configured
    directly from S3 buckets. Beyond performance and robustness, being able to set
    custom domain names and HTTPS support are other reasons to set up AWS CloudFront
    as a CDN for our website.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by navigating to the CloudFront console and clicking the **Create
    distribution** button, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.43 – Selecting CloudFront from the AWS service list](img/Figure_13.43_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.43 – Selecting CloudFront from the AWS service list
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must fill out the `example.s3-website.us-west-1.amazonaws.com` for
    the `example` bucket in the `us-westwest-1` region. The following screenshot displays
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.44 – Entering the website’s endpoint domain  in the CloudFront
    distribution’s Origin domain field](img/Figure_13.44_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.44 – Entering the website’s endpoint domain in the CloudFront distribution’s
    Origin domain field
  prefs: []
  type: TYPE_NORMAL
- en: 'While we are setting up the distribution, it’s a good idea to select the **Redirect
    HTTP to HTTPS** option for the **Viewer protocol policy** field; this can be found
    in the **Default cache behavior** section, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 13.45 – Selecting Redirect HTTP to HTTPS for the Viewer \uFEFFprotocol\
    \ \uFEFFpolicy field](img/Figure_13.45_B18645.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.45 – Selecting Redirect HTTP to HTTPS for the Viewer protocol policy
    field
  prefs: []
  type: TYPE_NORMAL
- en: Once done, we are now ready to click the **Create distribution** button and
    wait for the changes to propagate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: CloudFront distribution changes take a while to propagate since they are being
    deployed to servers around the world.
  prefs: []
  type: TYPE_NORMAL
- en: We can open the domain name for the CloudFront distribution once the console’s
    status is **Deployed**. With that, we have seen how to set up S3 and CloudFront
    to serve a static website. We will now learn how to use the AWS CLI to synchronize
    a local directory to the S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: A prerequisite for the next section is to have a shell instance that has AWS
    credentials that have been injected using the `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`,
    and `AWS_DEFAULT_REGION` environment variables. The access key and secret key
    need to be generated from the **Account** dropdown by selecting **My Security
    Credentials** | **Access Keys**. It also requires version 2 of the AWS CLI.
  prefs: []
  type: TYPE_NORMAL
- en: If we’re in a Vue CLI project, we can deploy the `dist` folder (which can be
    built using `npm run build`) to our `vue-workshop` bucket using an AWS S3 CLI
    command. We want to update an `s3` resource so that our command will start with
    `aws s3`. The command we want to issue is to synchronize files, so we will use
    the `aws s3` `sync` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will sync `./dist` to the `vue-workshop` S3 bucket using the AWS URI syntax
    – that is, `s3://vue-workshop`. We also want to make sure that the files we upload,
    just like the bucket configuration, allow `public-read`. In full, the command
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s take what we’ve learned and apply it to our GitLab process.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 13.03 – deploying to S3 from GitLab CI/CD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: S3 is a very cost-effective and performant solution for storing static files
    at scale. In this exercise, we’ll learn how to integrate GitLab CI/CD and AWS
    S3 to deploy a Vue.js application. This automates the deployment of the Vue.js
    application. The deployment will run on every push to GitLab without any manual
    intervention.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete code for this exercise at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Exercise13.03](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Exercise13.03)
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy to the S3 bucket from GitLab CI/CD, we will need to set up credential
    management:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **CI/CD** in the **Settings** section of GitLab, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.46 – CI/CD in the Settings menu](img/Figure_13.46_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.46 – CI/CD in the Settings menu
  prefs: []
  type: TYPE_NORMAL
- en: 'We will want to add variables, so let’s expand that section. You will see an
    empty list of variables, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.47 – The Variables section of the GitLab CI/CD settings expanded](img/Figure_13.47_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.47 – The Variables section of the GitLab CI/CD settings expanded
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll add two variables, `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`,
    using the UI (the values of these are not shown since they’re sensitive API keys),
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.48 – Entering the AWS_ACCESS_KEY_ID environment variable](img/Figure_13.48_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.48 – Entering the AWS_ACCESS_KEY_ID environment variable
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add the default `AWS_REGION` variable using the UI (this isn’t
    so sensitive, so its value is shown in the following screenshot):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.49 – Entering the AWS_DEFAULT_REGION environment variable](img/Figure_13.49_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.49 – Entering the AWS_DEFAULT_REGION environment variable
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have set up our environment variables on GitLab CI/CD, we can start
    updating our `.``gitlab-ci.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we want to start caching the `dist` directory after our `build` step.
    To do this, we need to add a `cache` property to the `build` job:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now add our `deploy` job, which will be a part of the `deploy` stage.
    To access the AWS CLI, we will use a Python image (`python:latest`) and install
    the AWS CLI using `pip` (a Python package manager) in our `before_script` step.
    Once we’ve installed the AWS CLI, we will run the deployment in the `script` step
    using the `aws s3 sync` command we used to deploy from our local machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to invalidate caches since the Vite `build` command has built-in
    cache-busting, which it does by fingerprinting the contents of a file in the filename.
    Fingerprinting means that if the contents of a file change, its name/URL will
    change accordingly. When this new file is requested, it will be loaded from an
    uncached URL and will therefore get the latest version of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this update to the configuration is pushed to the GitLab repository, we
    will see the pipeline running three stages that all pass, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.50 – Passing the build, test, and deploy jobs](img/Figure_13.50_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.50 – Passing the build, test, and deploy jobs
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to configure and deploy a Vue.js application to S3 and
    CloudFront using the AWS CLI and GitLab CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 13.01 – adding CI/CD to a Book Search app with GitLab and deploying
    it to Netlify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s take a fully built Book Search Vue.js application that loads data
    from the Google Books API and deploy it to GitLab CI/CD and Netlify. We will start
    by running the production build locally and checking the output.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will switch to running the build and code quality steps (linting) on
    GitLab CI/CD. Finally, we will set up a new Netlify application sourced to the
    GitLab repository.
  prefs: []
  type: TYPE_NORMAL
- en: The starting code for this activity can be found at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Activity13.01_initial](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Activity13.01_initial);
    we will start with a **Book Search** application built with the Vue CLI. The solution
    can be found at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Activity13.01_solution](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Activity13.01_solution).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We will run a production build locally. We can use the command used to build
    all Vue CLI projects for production. We will also want to check that the relevant
    assets (JavaScript, CSS, and HTML) are generated correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We expect the `dist` folder to contain a similar structure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.51 – Sample contents of the dist folder (generated using the tree
    command) after a production build run](img/Figure_13.51_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.51 – Sample contents of the dist folder (generated using the tree
    command) after a production build run
  prefs: []
  type: TYPE_NORMAL
- en: To run GitLab CI/CD, we will need a `.gitlab-ci.yml` file. We will add a job
    to `.gitlab-ci.yml` in which we will install the packages followed by the production
    build into a Node.js LTS Docker container, at the `build` stage. We will also
    make sure to cache the output of the production build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we use `git add .gitlab-ci.yml` and commit and push the changes, we should
    see the following GitLab CI/CD pipeline run, which includes the `build` job while
    it is running (note the moon-like icon):'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF3.52 – The GitLab CI/CD pipeline with the build job running](img/Figure_13.52_B18645.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.52 – The GitLab CI/CD pipeline with the build job running
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot, on the other hand, shows the GitLab CI/CD pipeline
    when the `build` job has been completed and is in the `passed` state (look for
    the green check):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.53 – GitLab CI/CD pipeline with the build job passed](img/Figure_13.53_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.53 – GitLab CI/CD pipeline with the build job passed
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will want to add a code quality job to the `test` stage on GitLab CI/CD
    (by updating `.gitlab-ci.yml`). We’ll call the job `lint` and it will run an install
    of the dependencies as well as linting through the Vue CLI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we use `git add .gitlab-ci.yml` and commit and push the changes, we should
    see the following GitLab CI/CD pipeline run, which includes the `lint` job while
    it is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.54 – The GitLab CI/CD pipeline with the lint job running](img/Figure_13.54_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.54 – The GitLab CI/CD pipeline with the lint job running
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the GitLab CI/CD pipeline with the `lint` job
    completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.55 – GitLab CI/CD pipeline with the lint job completed](img/Figure_13.55_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.55 – GitLab CI/CD pipeline with the lint job completed
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy our application, we’ll need to create a new Netlify application.
    From the **Sites** menu, add a new site and select **GitLab** as the provider.
    You should see your repository in the list of repos:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.56 – Selecting the repository for the Netlify site](img/Figure_13.56_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.56 – Selecting the repository for the Netlify site
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, you can confirm that Netlify automatically recognizes how
    to build and deploy your site. Both the `build` command and `publish` directory
    should be set as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.57 – The S3 bucket properties page with web hosting enabled and
    configured with the index and error page set to index.html](img/Figure_13.57_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.57 – The S3 bucket properties page with web hosting enabled and configured
    with the index and error page set to index.html
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, click **Deploy site**. Netlify will fetch the code from GitLab and run
    its build script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.58 – Netlify running its deploy process](img/Figure_13.58_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.58 – Netlify running its deploy process
  prefs: []
  type: TYPE_NORMAL
- en: 'When done, you can click the URL for the site Netlify created and see the app
    running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.59 – The Vue application running on Netlify](img/Figure_13.59_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.59 – The Vue application running on Netlify
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now walked through the process of taking a real (if simple) Vue application
    and creating a CI/CD process that lets you go from development to production in
    an automated and safe manner. Congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ve looked at how to introduce CI and CD practices
    to Vue.js projects so that we can deploy to production safely and efficiently.
    We’ve also seen how CI and CD are beneficial in the context of an agile delivery
    process.
  prefs: []
  type: TYPE_NORMAL
- en: We used GitLab’s CI/CD features to run tests, linting, and builds on every commit.
    We also learned how to leverage Netlify to host a static website by connecting
    Netlify to our hosting provider. Finally, we looked at how to set up and deploy
    to AWS S3 and CloudFront.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, you have learned how to use Vue.js to successfully build
    powerful, yet easy-to-build, web applications. You’ve worked with data, animations,
    forms, and more to build multiple different types of applications with various
    styles of user interaction. You also learned how to test all aspects of the application
    and finally took the steps to get your application into a live, production environment!
  prefs: []
  type: TYPE_NORMAL
