- en: '*Chapter 9*: Use Case Scenario 3 – Valtio'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Valtio ([https://github.com/pmndrs/valtio](https://github.com/pmndrs/valtio))
    is yet another library for global state. Unlike Zustand and Jotai, it's based
    on the mutating update model. It's primarily for module states like Zustand. It
    utilizes proxies to get an immutable snapshot, which is required to integrate
    with React.
  prefs: []
  type: TYPE_NORMAL
- en: The API is just JavaScript and everything works behind the scenes. It also leverages
    proxies to automatically optimize re-renders. It doesn't require a selector to
    control re-renders. The automatic render optimization is based on a technique
    called **state usage tracking**. Using state usage tracking, it can detect which
    part of the state is used, and it can let a component re-render only if the used
    part of the state is changed. In the end, developers need to write less code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the basic usage of the Valtio library and
    how it deals with mutating updates. Snapshots are a key feature to create an immutable
    state. We will also discuss how snapshots and proxies allow us to optimize re-renders.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Valtio, another module state library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing proxies to detect mutations and create an immutable state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using proxies to optimize re-renders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating small application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pros and cons of this approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are expected to have moderate knowledge of React, including React Hooks.
    Refer to the official site, [https://reactjs.org](https://reactjs.org), to learn
    more.
  prefs: []
  type: TYPE_NORMAL
- en: In some code, we use TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org)),
    and you should have basic knowledge of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in this chapter is available on GitHub: [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_09](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_09).'
  prefs: []
  type: TYPE_NORMAL
- en: To run the code snippets, you need a React environment, for example, Create
    React App ([https://create-react-app.dev](https://create-react-app.dev)) or CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io)).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Valtio, another module state library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Valtio is a library primarily used for module state, which is the same as Zustand.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we learned in [*Chapter 7*](B17780_07_Final_VK_ePub.xhtml#_idTextAnchor092),
    *Use Case Scenario 1 – Zustand*, we create a store in Zustand as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `store` variable has some properties, one of which is `setState`. With
    `setState`, we can update the state. For example, the following is incrementing
    the `count` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Why do we need to use `setState` to update a state value? Because we want to
    update the state immutably. Internally, the previous `setState` works like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is the way to update an object immutably.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine a case where we don''t need to follow the immutable update rule.
    In this case, the code to increment the `count` value in `moduleState` would be
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Wouldn't it be nice if we could write code like that and make it work with React?
    Actually, we can implement this with proxies.
  prefs: []
  type: TYPE_NORMAL
- en: 'A proxy is a special object in JavaScript ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)).
    We can define some handlers to trap object operations. For example, you can add
    a `set` handler to trap object mutations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We create `proxyObject` with `new Proxy` with two arguments. The first argument
    is an object itself. The second argument is a collection object of handlers. In
    this case, we have a `set` handler, which traps the `set` operation and adds `console.log`
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '`proxyObject` is a special object and when you set a value, it will log to
    the console before and after setting the value. The following is the screen output
    if you run the code in the Node.js REPL ([https://nodejs.dev/learn/how-to-use-the-nodejs-repl](https://nodejs.dev/learn/how-to-use-the-nodejs-repl)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Conceptually, as a proxy can detect any mutations, we could technically use
    similar behavior to `setState` in Zustand. Valtio is a library that utilizes proxies
    to detect state mutations.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned that Valtio is a library that uses the mutating
    update model. Next up, we will learn how Valtio creates immutable states with
    mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing proxies to detect mutations and create an immutable state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Valtio creates immutable objects from mutable objects with proxies. We call
    the immutable object a **snapshot**.
  prefs: []
  type: TYPE_NORMAL
- en: To create a mutable object wrapped in a proxy object, we use the `proxy` function
    exported by Valtio.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is to create an object with a `count` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `state` object returned by the `proxy` function is a proxy object that detects
    mutations. This allows you to create an immutable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an immutable object, we use the `snapshot` function exported by Valtio,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Though the `state` variable is `{ count: 0 }` and the `snap1` variable is `{
    count: 0 }`, `state` and `snap1` have different references. `state` is a mutable
    object wrapped in a proxy, whereas `snap1` is an immutable object frozen with
    `Object.freeze` ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how snapshots work. We mutate the `state` object and create another
    snapshot, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `state` variable is `{ count: 1 }` and has the same reference as before.
    The `snap2` variable is `{ count: 1 }` and has a new reference. Because `snap1`
    and `snap2` are immutable, we can check the equality with `snap1 === snap2`, and
    know whether anything in the objects differs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `proxy` and `snapshot` functions work for nested objects and optimize snapshot
    creation. That means the `snapshot` function will create a new snapshot only if
    necessary, that is, when any of its properties are changed. Let''s look at another
    example. `state2` has two nested `c` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `snap21` variable is `{ obj1: { c: 0 }, obj2: { c: 0 } }`
    and the `snap22` variable is `{ obj1: { c: 1 }, obj2: { c: 0 } }`. `snap21` and
    `snap22` have difference references, hence `snap21 !== snap22` holds.'
  prefs: []
  type: TYPE_NORMAL
- en: How about nested objects? `snap21.obj1` and `snap22.obj1` are different, but
    `snap21.obj2` and `snap22.obj2` are the same. This is because the value of the
    internal `c` property of `obj2` isn't changed. `obj2` doesn't need to be changed,
    hence `snap21.obj2 === snap22.obj2` holds.
  prefs: []
  type: TYPE_NORMAL
- en: This snapshot optimization is an important feature. The fact that `snap21.obj2`
    and `snap22.obj2` have the same reference means they share memory. Valtio creates
    snapshots only if necessary, optimizing memory usage. This optimization can be
    done in Zustand, but it's the developer's responsibility to properly create new
    immutable states. In contrast, Valtio does the optimization behind the scenes.
    In Valtio, developers are free from the responsibility of creating new immutable
    states.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Valtio's optimization is based on caching with a previous snapshot. In other
    words, the cache size is 1\. If we increment the count with `++state.count` and
    then decrement it with `--state.count`, a new snapshot will be created.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how Valtio creates immutable state "snapshots" automatically.
    Next up, we will learn about Valtio's hooks for React.
  prefs: []
  type: TYPE_NORMAL
- en: Using proxies to optimize re-renders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Valtio uses proxies to optimize re-renders, as well as detecting mutations.
    This is the pattern of optimizing re-renders we learned about in the *Detecting
    property access* section of [*Chapter 6*](B17780_06_Final_VK_ePub.xhtml#_idTextAnchor080),
    *Introducing Global State Libraries*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn about the usage and behavior of Valtio hooks with a counter app.
    The hook is called `useSnapshot`. The implementation of `useSnapshot` is based
    on the `snapshot` function and another proxy to wrap it. This `snapshot` proxy
    has a different purpose from the proxy used in the `proxy` function. The `snapshot`
    proxy is used to detect the property access of a snapshot object. We will see
    how render optimization works, thanks to the `snapshot` proxy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with importing functions from Valtio to create a counter app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`proxy` and `useSnapshot` are two main functions provided by Valtio and they
    cover most use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create a `state` object with `proxy`. In our counter app, there are
    two counts – `count1` and `count2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `proxy` function takes an initial object and returns a new proxy object.
    We can mutate the `state` object as we like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the `Counter1` component, which uses the `state` object and
    shows the `count1` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It's our convention to set the name of the return value of `useSnapshot` to
    `name`. The `inc` action is a function to mutate the `state` object. We mutate
    the `state` proxy object; `snap` is only to read. The `snap` object is frozen
    with `Object.freeze` ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze))
    and it can't be mutated technically. Without `Object.freeze`, JavaScript objects
    are always mutable and we can only treat it as immutable by convention. `snap.count1`
    is accessing the `count1` property of the `state` object. The access is detected
    by the `useSnapshot` hook as tracking information, and based on the tracking information,
    the `useSnapshot` hook triggers re-renders only when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the `Counter2` component likewise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The difference from `Counter1` is it uses the `count2` property instead of the
    `count1` property. If we want to define a shared component, we can define a single
    component and take the property name in `props`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define the `App` component. As we don''t use Context, there are
    no providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'How does this app work? On the initial render, the `state` object is `{ count1:
    0, count2: 0 }` and so is its snapshot object. The `Counter1` component accesses
    the `count1` property of the snapshot object and the `Counter2` component accesses
    the `count2` property of the snapshot object. Each `useSnapshot` hook knows and
    remembers tracking information. The tracking information represents which property
    is accessed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we click the button in the `Counter1` component (the first button in *Figure
    9.1*), it increments the `count1` property of the `state` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – First screenshot of the counter app ](img/Figure_9.01_B17780.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – First screenshot of the counter app
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the `state` object becomes `{ count1: 1, count2: 0 }`. The `Counter1`
    component re-renders with the new number `1`. However, the `Counter2` component
    doesn''t re-render, because `count2` is still `0` and not changed (*Figure 9.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Second screenshot of the counter app ](img/Figure_9.02_B17780.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Second screenshot of the counter app
  prefs: []
  type: TYPE_NORMAL
- en: Re-renders are optimized with tracking information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our counter app, the `state` object is simple with two properties with number
    values. Valtio supports nested objects and arrays. A contrived example is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, any objects containing plain objects and arrays are fully supported
    even though they are nested deeply. For more information, please refer to the
    project site: [https://github.com/pmndrs/valtio](https://github.com/pmndrs/valtio).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how Valtio optimizes re-renders with snapshots and
    proxies. In the next section, we will learn how to structure an app with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating small application code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will learn how to create a small app. Our example app is a to-do app. Valtio
    is unopinionated about how to structure apps. This is one of the typical patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how a to-do app can be structured. First, we define the `Todo`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A `Todo` item has an `id` string value, a `title` string value, and a `done`
    Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then define a `state` object using the defined `Todo` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `state` object is created by wrapping an initial object with `proxy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manipulate the `state` object, we define some helper functions – `addTodo`
    to add a new to-do item, `removeTodo` to remove it, and `toggleTodo` to toggle
    the `done` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`nanoid` is a small function to generate a unique ID ([https://www.npmjs.com/package/nanoid](https://www.npmjs.com/package/nanoid)).
    Notice these three functions are based on normal JavaScript syntax. They treat
    `state` just like a normal JavaScript object. This is accomplished with proxies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `TodoItem` component, which has a checkbox toggle with
    the `done` status, text with a different style with the `done` status, and a button
    to remove the item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice this component receives the `id`, `title`, and `done` properties separately,
    instead of receiving the `todo` object. This is because we use the `memo` function
    and create the `MemoedTodoItem` component. Our state usage tracking detects property
    access, and if we pass an object to a memoed component, the property access is
    omitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `MemoedTodoItem` component, the `TodoList` component is defined
    with `useSnapshot`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This component takes `todos` from the result of `useSnapshot` and accesses all
    properties in objects in the `todos` array. Hence, `useSnapshot` triggers a re-render
    if any part of `todos` is changed. It's not a big issue and this is a valid pattern
    because the `MemoedTodoItem` component won't re-render unless `id`, `title`, or
    `done` is changed. We will learn about another pattern later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new to-do item, the following is a small component that has a local
    state for the input field and invokes `createTodo` when the **Add** button is
    clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we combine the defined components in the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at how this app works:'
  prefs: []
  type: TYPE_NORMAL
- en: At first, it has only a text field and an **Add** button (*Figure 9.3*):![Figure
    9.3 – First screenshot of the todos app ](img/Figure_9.03_B17780.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.3 – First screenshot of the todos app
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we click the **Add** button, a new item is added (*Figure 9.4*):![Figure
    9.4 – Second screenshot of the todos app ](img/Figure_9.04_B17780.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.4 – Second screenshot of the todos app
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can add as many items as we want (*Figure 9.5*):![Figure 9.5 – Third screenshot
    of the todos app ](img/Figure_9.05_B17780.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.5 – Third screenshot of the todos app
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Clicking a checkbox will toggle the `done` status (*Figure 9.6*):![Figure 9.6
    – Fourth screenshot of the todos app ](img/Figure_9.06_B17780.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.6 – Fourth screenshot of the todos app
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Clicking the **Delete** button will delete the item (*Figure 9.7*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Fifth screenshot of the todos app ](img/Figure_9.07_B17780.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Fifth screenshot of the todos app
  prefs: []
  type: TYPE_NORMAL
- en: The app we created so far works pretty well. But there is room for improvement
    in terms of extra re-renders. When we toggle the `done` state of an existing item,
    not only the corresponding `TodoItem` component but also the `TodoList` component
    will re-render. As noted, this is not a big issue as long as the `TodoList` component
    itself is fairly lightweight.
  prefs: []
  type: TYPE_NORMAL
- en: We have another pattern to eliminate the extra re-render in the `TodoList` component.
    This doesn't mean the overall performance can always be improved. Which approach
    we should take depends on the app in question.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the new approach, we use `useSnapshot` in each `TodoItem` component. The
    `TodoItem` component only receives the `id` property. The following is the modified
    `TodoItem` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Based on the `id` property, it finds `todoState`, uses `useSnapshot` with `todoState`,
    and gets the `title` and `done` properties. This component will re-render only
    if the `id`, `title`, or `done` properties are changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the modified `TodoList` component. Unlike the previous
    one, it only needs to pass the `id` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So, `todoIds` is created from the `id` property of each `todo` object. This
    component will only re-render if the order of `id` is changed, or if some `id`
    is added or removed. If only the `done` status of an existing item is changed,
    this component won't re-render. Hence, the extra re-render is eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: In medium-sized apps, the change in the two approaches is subtle in terms of
    performance. The two approaches are more meaningful for different coding patterns.
    Developers can choose the one that is more comfortable with their mental model.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about `useSnapshot` use cases with a small app.
    Next up, we will discuss some pros and cons of this library and the approach in
    general.
  prefs: []
  type: TYPE_NORMAL
- en: The pros and cons of this approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how Valtio works and one question is when we should use it and
    when we should not.
  prefs: []
  type: TYPE_NORMAL
- en: One big aspect is the mental model. We have two state-updating models. One is
    for immutable updates and the other for mutable updates. While JavaScript itself
    allows mutable updates, React is built around immutable states. Hence, if we mix
    the two models, we should be careful not to confuse ourselves. One possible solution
    would be to clearly separate the Valtio state and React state so that the mental
    model switch is reasonable. If it works, Valtio can fit in. Otherwise, maybe stick
    with immutable updates.
  prefs: []
  type: TYPE_NORMAL
- en: The major benefit of mutable updates is we can use native JavaScript functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, removing an item from an array with an `index` value can be written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In immutable updates, this is not so easy. For example, it can be written with
    `slice`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example is to change the value in a deeply nested object. It can be
    done in mutable updates as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In immutable updates, it has to be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is not very pleasant to write. Valtio helps to reduce application code
    with mutable updates.
  prefs: []
  type: TYPE_NORMAL
- en: Valtio also helps to reduce application code with proxy-based render optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a state with the `count` and `text` properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use only `count` in a component, we can write the following in Valtio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In comparison, with Zustand, this will be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The difference is trivial, but we have `count` in two places.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a contrived scenario. Suppose we want to show the `text` value
    if the `showText` property is truthy. With `useSnapshot`, it can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementing the same behavior with selector-based hooks is tough. One solution
    is to use a hook twice. With Zustand, it will be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This means if we have more conditions, we need more hooks.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a disadvantage of proxy-based render optimization can be
    less predictability. Proxies take care of render optimization behind the scenes
    and sometimes it's hard to debug the behavior. Some may prefer explicit selector-based
    hooks.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, there's no one-size-fits-all solution. It's up to developers to
    choose the solution that fits their needs.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the approach taken in the Valtio library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about a library called Valtio. It utilizes proxies
    extensively. We've seen examples and learned how it can be used. It allows mutating
    state, which feels like using normal JavaScript objects, and the proxy-based render
    optimization helps reduce application code. It depends on developers' requirements
    whether this approach is a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about another library, called React Tracked,
    which is a library that is based on Context and has proxy-based render optimization
    like Valtio.
  prefs: []
  type: TYPE_NORMAL
