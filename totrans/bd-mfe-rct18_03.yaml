- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Key Principles and Components of Microfrontends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microfrontends are a double-edged sword. When done right, they can bring a great
    amount of joy and productivity to teams; however, if not implemented the right
    way, they can make things way worse.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, there are a couple of key principles and considerations we
    need to keep in mind when building a microfrontend architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at the key design principles of a microfrontend
    architecture and why it is important to treat them as sacrosanct. The reason we
    emphasize these principles is that they lay the foundation of the microfrontend
    architecture. Teams may not be able to extract all the benefits of a microfrontend
    pattern if they choose to ignore these principles. Then, we will look at the key
    components that are critical to any microfrontend architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Key Principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key Components of a Microfrontend Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a better understanding of the guiding
    principles and key considerations that teams need to keep in mind when designing
    a microfrontend architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Key Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s important that all software teams lay down a set of rules and guiding principles
    that all team members and the code they write adhere to. This ensures that when
    teams discuss certain technical approaches, they can validate them against these
    guidelines. This, in turn, ensures that the teams can focus on the outcomes by
    mapping them against these key guidelines and not get too obsessed with the nuances
    of the process. This helps teams to arrive at decisions a lot faster.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will look at the key principles that teams must
    adhere to when following a microfrontend pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Domain Driven Teams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Dan Abramov*, who leads the React project at Meta, once tweeted the question,
    “*Is Microfrontends solving a technology problem or an* *organizational problem?*”'
  prefs: []
  type: TYPE_NORMAL
- en: When you think about it, a lot of problems we see in today’s software development
    do stem from the way teams are organized.
  prefs: []
  type: TYPE_NORMAL
- en: Domain Driven Design is a well-established concept in the microservices world.
    Backend microservice teams are commonly organized around these domain models.
    With microfrontends, we extend the same thinking to the frontend world, and by
    re-organizing the frontend teams within these domain models, we are now able to
    create vertically sliced teams, where a domain-driven team can own the responsibility
    of a business functionality from end to end and is able to work independently.
  prefs: []
  type: TYPE_NORMAL
- en: For us to be successful with microfrontends, it is critical that the micro apps
    and teams that own them are mapped to these domain models and the business value
    they aim to provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a quick look at what a Domain Driven Team might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Domain-driven teams](img/Figure_2.01_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Domain-driven teams
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows three domain-driven teams for an e-commerce application,
    namely **Catalog Team**, **Checkout Team**, and **User Account Team**. Within
    each team, you will see that they have dedicated team members who play the roles
    of frontend, backend, and integration engineers.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating Failure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microfrontends are inherently designed to be “decentralized.” One of the many
    benefits of that is isolating failures and reducing the blast radius of an error.
    A common problem with monolith **Single Page Apps** (**SPAs**) is that a single
    line of error in any one of the modules would prevent an entire application from
    being compiled, or a runtime error would cause an entire page to error out.
  prefs: []
  type: TYPE_NORMAL
- en: When designing a microfrontend architecture, you need to ensure graceful service
    degradation if one or more of the microfrontends fail.
  prefs: []
  type: TYPE_NORMAL
- en: If one microfrontend is dependent on another for its functioning, then we are
    breaking one of the key principles of microfrontends, which should be avoided
    at all costs.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Independently
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another key principle of a microfrontend architecture is the ability to deploy
    each app independently without having to redeploy the other apps.
  prefs: []
  type: TYPE_NORMAL
- en: When a new app is deployed, it should immediately be available to a user and
    should not require a restart of the host app or the servers for the changes to
    take effect.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting observation with different teams working on microfrontends is
    that while, from an architecture standpoint, these micro apps can be updated independently,
    the DevOps pipelines that deploy these microfrontends are designed to deploy all
    the apps simultaneously, thereby negating the benefits of independent deployment.
  prefs: []
  type: TYPE_NORMAL
- en: It is critical that the DevOps pipelines are also designed such that when any
    app is ready for deployment, only the relevant pipeline runs and deploys the app,
    without impacting the other apps.
  prefs: []
  type: TYPE_NORMAL
- en: This misconfiguration of the DevOps pipelines mainly stems from the problem
    where there are separate DevOps teams that are responsible for building the pipelines
    and production deployments.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to fix this is to ensure that we have “full life cycle teams,”
    who are responsible for building the app and also responsible for deploying it
    to production. These teams work closely with the DevOps teams to build the CI
    and CD pipelines and then take over the control of managing and running them.
  prefs: []
  type: TYPE_NORMAL
- en: Preferring Runtime Integrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common discussion in the context of microfrontends is build time integrations
    versus runtime integrations. With build time integrations, the different teams
    build and publish their micro apps either to a version control system or an artifact
    repository, such as NPM or Nexus.
  prefs: []
  type: TYPE_NORMAL
- en: Then, during building time, all these micro apps are brought together to build
    a single app bundle, which is then deployed to production. We strongly discourage
    this pattern of build-time integration, as it breaks the aforementioned principle
    of independent deployment. A pattern like this may be suitable where you have
    scheduled releases that happen either once or twice a month. However, in that
    case, you probably would be better off with a monolith single-page app and don’t
    really have to deal with all the complexities of a microfrontend architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Always prefer runtime integrations when designing a microfrontend architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Your micro apps should immediately be available for use the moment they are
    deployed. This ensures that each team can continuously deploy their micro apps
    to production and are not dependent on other teams to make their app available.
  prefs: []
  type: TYPE_NORMAL
- en: In most microfrontend patterns, we can make use of a host application or a shell
    app that keeps a tab of the different micro apps that load within it, but care
    must be taken to ensure that this host/app shell is built with scalability in
    mind. If the process of checking for new versions of a micro app takes up a lot
    of CPU or memory resources, then there is a high risk that it will become a single
    point of failure when your application scales, in terms of the micro apps and
    the traffic it receives.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding the “Distributed Monolith” trap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Don’t Repeat Yourself** (**DRY**) has a slightly different meaning in the
    microservice/microfrontend world. Most developers associate DRY with code reusability.
    When working with microfrontends, teams can go overboard creating libraries and
    utilities, which eventually get imported and used in each of the micro apps. Now,
    as each team’s needs grow, they start adding functionality to these common libraries
    and utilities, in the hope that it will be beneficial to other teams. However,
    the problem it creates is that additional unused code is now being imported into
    the other micro apps (while tree shaking will solve this problem, in most cases,
    mainly due to poor coding practices, tree shaking doesn’t work well, and we end
    up with unnecessary code imported into the apps). Another problem with these shared
    libraries is that there is a much higher risk of introducing breaking changes,
    with changes made for one micro app now breaking the other micro apps. By going
    overboard with code reusability, we end up with what’s commonly called a “distributed
    monolith,” which is essentially the worst of both worlds.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s okay to have some shared libraries or, if using TypeScript, a shared types/interfaces
    file, but we must avoid creating large common libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In the microservice/microfrontend world, DRY essentially refers to automating
    tasks so that you don’t have to manually repeat the steps for each microservice
    or micro app. These could be things such as automating quality gates, or performance
    and security checks as part of the developers’ pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Technology agnostic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another principle of a microfrontend architecture is that it should be technology
    agnostic, meaning that each of the micro apps could “in theory” be built using
    different frameworks/languages. However, just because it’s possible doesn’t mean
    teams should go all out and use either Vue, Angular, or React to build out different
    micro apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple reasons why this should be avoided:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple libraries/frameworks mean an additional payload being sent down the
    wire to users’ devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes it difficult to rotate team members, and moving from one team to another
    means having to get comfortable with a new framework/library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary reason for this principle is to allow for incremental upgrades,
    either from an older version to a newer version of the same library or to explore
    the benefits of a new framework.
  prefs: []
  type: TYPE_NORMAL
- en: Granular Scaling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When planning out a deployment strategy for your microfrontend, you must ensure
    that it supports granular scaling. By granular scaling, what we mean is that if
    a certain set of pages is getting a lot of traffic, either due to a marketing
    campaign or something similar, then only the servers serving those pages should
    scale, while the rest of the pods serving other parts of your microfrontend can
    remain at their regular levels. This ensures optimal cloud and hosting costs.
  prefs: []
  type: TYPE_NORMAL
- en: Culture of Automation and DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A strong culture of automation and DevOps is critical for the long-term success
    of a microfrontend architecture.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine with microfrontends, since we break up a single app into
    smaller apps, all the activities associated with tasks such as compiling the app
    and running quality, performance, and security checks will now need to be done
    multiple times for each of the apps. If we don’t have automation processes for
    all of the aforementioned items, then the overall development and release of these
    apps will take a lot longer than what it would have been with a monolith.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, it is important to invest time and effort into building these automation
    processes, most of which are generally done as part of the DevOps pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Teams can also invest in tooling and building code generators and micro app
    templates that can help speed up the creation of newer micro apps. They can also
    run linters, security, and other quality checks automatically as part of the DevOps
    pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we come to the end of this section, where we saw some of the important
    principles that teams must keep in mind when designing a microfrontend architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how principles such as domain-driven teams, independent deployments,
    and granular scaling allow teams to move consistently and quickly. We saw how
    teams should avoid falling into the trap of a distributed monolith and build a
    pattern that uses build-time integrations, and finally, we saw how keeping the
    architecture technology agnostic and focusing on automation helps an architecture
    to easily evolve and become future-proof.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at some of the important components of the
    microfrontend architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The key Components of a Microfrontend Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After spending time going through the principles of a microfrontend, now let’s
    look at some of the key components of a microfrontend architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at the essential components any microfrontend
    architecture needs to have, and we will look at some of the nuances associated
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: After completing this section, you will be aware of the four basic components
    that make up any microfrontend architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Routing Engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the previous chapter, depending on the type of microfrontend pattern
    you aim to build, the routing engine for your app will be partially or fully decoupled
    from your apps.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple approaches we can take. We can use NGINX as a reverse proxy
    and have a list of all the primary routes that map to the respective apps in the
    multi-SPA pattern. If the apps are deployed in a Kubernetes cluster, we can make
    use of Ingress routes to map the primary routes to the respective apps. We will
    go into more detail about this in [*Chapter 8*](B18987_08.xhtml#_idTextAnchor119),
    *Deploying Microfrontends to Kubernetes*, where we will look at deploying these
    microfrontends in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: A global state and a Communication Channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to routing, the next important thing to design well in your microfrontend
    architecture is the communication channel between the different apps and also
    the notion of a global state, which can be shared between the different apps.
  prefs: []
  type: TYPE_NORMAL
- en: With a monolith SPA, the most common practice is to use a single global store
    such as Redux or MobX, where everything is written into that store and read from
    it. With microfrontends, the recommendation is to avoid such global client-side
    stores and instead let each micro app get its data from the backend API, as that
    is the real source of truth.
  prefs: []
  type: TYPE_NORMAL
- en: However, there would be a genuine need for client-side state management to avoid
    making unnecessary calls to the backend, to fetch things such as `user_id` or
    a cart count. For things such as these, we can look to use a really thin global
    store in the app shell or maybe even look toward `localStorage` or `IndexedDB`
    to store the values that are needed to make API calls.
  prefs: []
  type: TYPE_NORMAL
- en: With a micro app microfrontend pattern, it also becomes important to establish
    a common communication channel that the different apps use to communicate with
    each other. A classic use case would be when clicking on the **Add to Cart** button
    on a product page, the mini cart present in the header is automatically incremented.
    In such cases, an event-driven communication channel works best.
  prefs: []
  type: TYPE_NORMAL
- en: Source code Version Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important item that teams need to agree on is how they plan to organize
    their Git repositories. Two schools of thought prevail here – organizing your
    apps in a polyrepo or a monorepo. Let’s look at their nuances.
  prefs: []
  type: TYPE_NORMAL
- en: Polyrepos
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Polyrepos are where you have each of your multi-SPAs or micro apps managed in
    its own independent Git repository. These are easiest to start with and give complete
    team independence. From a DevOps standpoint too, they are a lot easier to manage.
    However, this approach has a few drawbacks. There is a higher risk of teams becoming
    siloed and reduced inter-team collaboration. Another drawback is duplication and
    higher maintenance costs for tooling, such as DevOps pipelines and automation
    scripts, which need to be duplicated and updated in each of the repos.
  prefs: []
  type: TYPE_NORMAL
- en: Monorepos
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a monorepo structure, all your multi-SPAs or micro apps are co-located in
    a single Git repo, with each app located within its own individual folder.
  prefs: []
  type: TYPE_NORMAL
- en: Monorepos are starting to become a de facto approach for many frontend teams
    to manage their code repositories. The main advantage of monorepos is increased
    team collaboration, as everybody is able to see every other team’s code and provide
    valuable feedback. Tooling and automation scripts can be centralized, whereby
    optimizations done by one team are immediately available for other teams to follow.
    Some of the drawbacks of monorepos include DevOps setups being a bit complicated.
    Teams also need to set up fine-grained folder-level permissions to prevent teams
    from overwriting each other’s code. In the grand scheme of things, monorepos provide
    more advantages and, hence, are a preferred approach to managing the source code
    for your microfrontends.
  prefs: []
  type: TYPE_NORMAL
- en: A Component Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building microfrontends, it is critical to ensure a consistent look and
    feel as a user navigates through the different apps. The way we achieve that is
    by ensuring all apps make use of a common design system and component library.
    It is also recommended that all teams use a common theming and styling engine
    to ensure that all the components look and behave the same, irrespective of which
    app they are served in.
  prefs: []
  type: TYPE_NORMAL
- en: A common pattern is to publish a component library as an NPM module and set
    up all the other apps to import and use it. Each time a new version of the component
    library is published, teams will need to update their respective apps to the latest
    version.
  prefs: []
  type: TYPE_NORMAL
- en: An emerging trend, thanks to monorepos, is to build directly from source. What
    this means is that a component library is stored within the `libs` section of
    the monorepo and the components are directly linked from the library path. The
    main advantage of this method is that every time teams build their app, they automatically
    receive the latest version of the component library.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the key components of a microfrontend architecture,
    namely a routing engine, a global state, and a communication channel. We also
    saw the distinctions between a polyrepo and monorepo and saw why frontend teams
    prefer to use monorepos. Finally, we also learned about the component library
    and different ways teams consume components from a common library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that, we come to the end of our second chapter. We started the chapter
    by looking at the key principles we need to keep in mind. We saw why it is important
    to break teams down based on domain models, and why it is critical for teams to
    be able to independently deploy their own apps. We learned about the misconceptions
    associated with code reuse and how it can lead to a distributed monolith trap.
    We also saw the importance of DevOps and an automation culture. Finally, we learned
    about the four key components of a microfrontend. Everything that we learned in
    this chapter we will put into practice in the coming chapters, as we go about
    building our very own microfrontend application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deeper into monorepos versus polyrepos and
    learn how it’s more about team culture than technology. We will also start off
    by setting up our code repository as a monorepo to set up the foundation for future
    work.
  prefs: []
  type: TYPE_NORMAL
