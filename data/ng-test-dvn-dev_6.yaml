- en: Chapter 6. The First Step
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。第一步
- en: The first step is always the most difficult. This chapter provides an initial
    introductory walk-through of how to use TDD to build an Angular application with
    a component, class, and model. We will be able to begin the TDD journey and see
    the fundamentals in action. Up to this point, this book has focused on a foundation
    of TDD and the tools required for it. Now, we will switch gear and dive into TDD
    with Angular.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步总是最困难的。本章提供了如何使用TDD构建具有组件、类和模型的Angular应用程序的初始介绍性漫游。我们将能够开始TDD之旅，并看到基本原理的实际应用。到目前为止，本书侧重于TDD的基础和所需的工具。现在，我们将转变思路，深入研究Angular中的TDD。
- en: 'This chapter will be the first step of TDD. We have already seen how to install
    Karma and Protractor, in addition to small examples and a walk-through on how
    to apply them. In this chapter, we will focus on:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将是TDD的第一步。我们已经看到如何安装Karma和Protractor，以及如何应用它们的小例子和漫游。在本章中，我们将重点关注：
- en: Creating a simple comments application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的评论应用程序
- en: Integrating Karma and Protractor with the application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Karma和Protractor与应用程序集成
- en: Covering the components of testing and its associated classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涵盖测试的组件及其相关类
- en: Preparing the application's specifications
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备应用程序的规格
- en: 'Create an application to enter comments. The specifications of the application
    are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个输入评论的应用程序。应用程序的规格如下：
- en: If I am posting a new comment, when I click on the **Submit** button, the comment
    should be added to the comment list
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我发布了一个新评论，当我点击**提交**按钮时，评论应该被添加到评论列表中
- en: For a comment, when I click on the **Like** button, the number of likes for
    the comment should increase
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我点击**喜欢**按钮时，评论的喜欢数量应该增加
- en: 'Now that we have the specifications of the application, we can create our development
    to-do list. It won''t be easy to create an entire to-do list of the whole application.
    Based on the user specifications, we have an idea of what needs to be developed.
    Here is a rough sketch of the UI:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了应用程序的规格，我们可以创建我们的开发待办事项列表。创建整个应用程序的待办事项列表并不容易。根据用户的规格，我们知道需要开发什么。以下是UI的草图：
- en: '![Preparing the application''s specifications](graphics/image_06_001-1.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![准备应用程序的规格](graphics/image_06_001-1.jpg)'
- en: Hold back from jumping into the implementation and thinking about how we will
    use a component class, `*ngFor`, and so on. Resist, resist, resist! Although we
    can think of how this will be developed in the future, it is never clear until
    we delve into the code, and that is where we will start getting into trouble.
    TDD and its principles are here to help us get our mind and focus in the right
    place.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不要急于进行实现，考虑我们将如何使用组件类、`*ngFor`等。抵制，抵制，抵制！虽然我们可以考虑未来的开发方式，但直到我们深入代码，这一切才会变得清晰，这也是我们开始遇到麻烦的地方。TDD及其原则在这里帮助我们将思绪和注意力放在正确的地方。
- en: Setting up the Angular project
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Angular项目
- en: In previous chapters, we discussed in detail how a project should be set up,
    looked at the different components involved, and walked through the entire process
    of testing. We will skip these details and provide a list in the following section
    for the initial actions to get the project set up and ready with a test configuration
    for unit and end-to-end testing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们详细讨论了如何设置项目，查看了涉及的不同组件，并走过了整个测试过程。我们将跳过这些细节，并在下一节中提供一个列表，用于初始化操作，以便设置项目并准备好进行单元测试和端到端测试的测试配置。
- en: Loading an existing project
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载现有项目
- en: We will get a simple Angular project from the Angular team's examples and modify it for
    our implementation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Angular团队的示例中获取一个简单的Angular项目，并对其进行修改以适应我们的实现。
- en: We will clone the `quickstart` project from the Angular GitHub repo and start
    with that one. We should have Git installed globally besides `node`/`npm`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Angular GitHub仓库克隆`quickstart`项目，并从那个开始。除了`node`/`npm`之外，我们应该在全局安装Git。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will copy the project locally as `angular-project`; this project may contain
    some extra files (they may be updated continuously), but we will try to keep our
    project folder structure looking like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把项目本地复制为`angular-project`；这个项目可能包含一些额外的文件（它们可能会不断更新），但我们将尽量保持我们的项目文件夹结构看起来像这样：
- en: '![Loading an existing project](graphics/image_06_002.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![加载现有项目](graphics/image_06_002.jpg)'
- en: We will keep it simple initially, and then, we will add our required files step
    by step. This will make us more confident.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们将保持简单，然后逐步添加所需的文件。这将使我们更加自信。
- en: 'Let''s proceed with it and run the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行并运行以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `npm install` command will install the required modules for project dependencies
    that are defined in the `package.json` file that is in the project's root.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm install`命令将安装项目依赖项所需的模块，这些模块在项目根目录中的`package.json`文件中定义。'
- en: Setting up the directory
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置目录
- en: In previous examples, we put the component, unit test spec, and e2e test spec
    in the same folder just to keep it simpler. For a larger project, it's difficult
    to manage all in the same folder.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的示例中，我们将组件、单元测试规范和端到端测试规范放在同一个文件夹中，以保持简单。对于一个更大的项目，在同一个文件夹中管理所有这些是困难的。
- en: To make that manageable, we will put the test spec in a separate folder. Here,
    our sample `quickstart` project has already put test specs in the default folder,
    but we will have a new structure and will put our test files in the new structure.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更易管理，我们将把测试规范放在一个单独的文件夹中。在这里，我们的示例`quickstart`项目已经将测试规范放在默认文件夹中，但我们将有一个新的结构，并将我们的测试文件放在新的结构中。
- en: 'Let''s start setting up the project directory:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设置项目目录：
- en: 'Navigate to the project''s root folder:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到项目的根文件夹：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Initialize the test (`spec`) directory:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化测试（`spec`）目录：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Initialize the `unit` test directory:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化`unit`测试目录：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Initialize the end-to-end (`e2e`) test directory:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化端到端（`e2e`）测试目录：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the initialization is complete, our folder structure should look as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化完成后，我们的文件夹结构应如下所示：
- en: '![Setting up the directory](graphics/image_06_003.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![设置目录](graphics/image_06_003.jpg)'
- en: Setting up Karma
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Karma
- en: The details for Karma can be found in [Chapter 3](ch03.html "Chapter 3. The
    Karma Way"), *The Karma Way*. Here, we will mostly take a look at the Karma configuration
    file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Karma的详细信息可以在[第3章](ch03.html "第3章。Karma之道")中找到，*Karma之道*。在这里，我们将主要看一下Karma配置文件。
- en: In this `quickstart` project, we have already installed and configured Karma,
    and we have the `karma.conf.js` file in the project directory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`quickstart`项目中，我们已经安装并配置了Karma，并且在项目目录中有`karma.conf.js`文件。
- en: 'To confirm that we have Karma in the system, let''s install it globally using
    the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认系统中有Karma，让我们使用以下命令在全局安装它：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As mentioned before, we already have Karma configured in this project as part
    of a `quickstart` project, and we have the `karma.conf.js` file in the project
    directory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们已经在这个项目中配置了Karma作为`quickstart`项目的一部分，并且我们在项目目录中有`karma.conf.js`文件。
- en: Now we will look at some basic configuration options that everyone should know.
    In this configuration file, there are some advanced options, such as test reporting
    and bug reporting. We will skip those as they are not very important to know at
    this initial stage.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一些每个人都应该知道的基本配置选项。在这个配置文件中，还有一些高级选项，比如测试报告和错误报告。我们将跳过这些，因为在这个初始阶段并不是非常重要。
- en: Let's know more about a few of the configurations that we will need to proceed
    further.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下我们将需要进一步进行的一些配置。
- en: The `basePath` should be updated when we have a custom path for the project
    in the server. For now, it's `''`, as this project is running in the root path.
    The next option is the `frameworks`; by default, we are using `jasmine` here,
    but we can change the framework name if we want to use others, such as `mocha`.
    One point to remember is that if we plan for a different framework, we will have
    to add the relevant plugin.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在服务器上有自定义路径的项目时，`basePath`应该进行更新。目前是`''`，因为该项目在根路径上运行。下一个选项是`frameworks`；默认情况下，我们在这里使用`jasmine`，但是如果我们想使用其他框架，比如`mocha`，我们可以更改框架名称。需要记住的一点是，如果我们计划使用不同的框架，我们将不得不添加相关的插件。
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Plugins are required, as Karma will use these `npm` modules inside to perform
    the actions; for example, if we plan to use PhantomJS as the browser, we will
    need to add `''karma-phantomjs-launcher''` to the list:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 需要插件，因为Karma将使用这些`npm`模块来执行操作；例如，如果我们计划使用PhantomJS作为浏览器，我们需要将`'karma-phantomjs-launcher'`添加到列表中：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The next and most important option is `files[]`; with this, Karma will include
    all the required files for testing. It loads a file based on dependency. We will
    have all the required files in the `files[]` array.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个最重要的选项是`files[]`；通过这个，Karma将包含所有测试所需的文件。它根据依赖加载文件。我们将在`files[]`数组中包含所有所需的文件。
- en: First, we will add `System.js` since we use `systemjs` as the module loader
    in the app. Then, add `polyfills` for shim support on all browsers, `zone.js`
    for Async support in the app, RxJS as the reactive library, Angular library files,
    shim for Karma test, the components file, and, finally, the test specs. There
    might be some other files in the list for debug and reporting; we are skipping
    their explanations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加`System.js`，因为我们在应用程序中使用`systemjs`作为模块加载器。然后，添加`polyfills`以在所有浏览器上支持shim，`zone.js`以支持应用程序中的异步操作，RxJS作为响应式库，Angular库文件，Karma测试的shim，组件文件，最后是测试规范。列表中可能还有一些其他文件用于调试和报告；我们将跳过它们的解释。
- en: 'This is what our `files[]` array will look like:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`files[]`数组将如下所示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That's all we need to know for now in the `karma.conf` file. We will proceed
    by updating these settings if needed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们现在在`karma.conf`文件中需要知道的全部。如果需要，我们将通过更新这些设置来进行。
- en: 'Let''s take a look at the complete `karma.conf.js` file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看完整的`karma.conf.js`文件：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Test directory updated
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试目录已更新
- en: We have seen details of `karma-test-shim.js` in [Chapter 3](ch03.html "Chapter 3. The
    Karma Way"), *The Karma Way*. This is needed to run unit testing via Karma.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](ch03.html "第3章。Karma方式")中看到了`karma-test-shim.js`的详细信息，*Karma方式*。这是通过Karma运行单元测试所需的。
- en: We have changed the test specs directory/location, and `karma-test-shim.js`
    is configured based on the default structure of the project. Because we have moved
    the test to a different location and out of the `app/` folder, we need to update
    `karma-test-shim.js` accordingly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更改了测试规范目录/位置，并且`karma-test-shim.js`是根据项目的默认结构进行配置的。因为我们已经将测试移动到不同的位置并且不在`app/`文件夹中，我们需要相应地更新`karma-test-shim.js`。
- en: 'Here is the change that will need to be made:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是需要进行的更改：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Setting up Protractor
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Protractor
- en: In [Chapter 4](ch04.html "Chapter 4. End-to-End Testing with Protractor"), *End-to-End
    Testing with Protractor*, we discussed the full installation and setup of Protractor.
    This sample application already has Protractor installed and configured. So, we
    will just take a look at the `protractor.conf.js` file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。使用Protractor进行端到端测试")中，*使用Protractor进行端到端测试*，我们讨论了Protractor的完整安装和设置。这个示例应用程序已经安装和配置了Protractor。因此，我们只需要查看`protractor.conf.js`文件。
- en: This configured Protractor instance has test reporting implemented. We will
    skip those parts from the config file here and just have a look at the common
    setting options.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的Protractor实例已实现了测试报告。我们将跳过配置文件中的这些部分，只看一下常见的设置选项。
- en: 'Before we go to the config file overview, to be sure, we will install Protractor
    globally on the system:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入配置文件概述之前，为了确保，我们将在系统上全局安装Protractor：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Update Selenium WebDriver:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 更新Selenium WebDriver：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We will have to make sure that Selenium is installed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保Selenium已安装。
- en: 'As expected, `protractor.conf.js` is located at the root of the application.
    Here is the complete configuration of the `protractor.conf.js` file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`protractor.conf.js`位于应用程序的根目录。这是`protractor.conf.js`文件的完整配置：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Top-down versus bottom-up approach - which one do we use?
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自上而下与自下而上的方法-我们使用哪种？
- en: 'From a development perspective, we have to determine where to start. The approaches
    that we will discuss in this book are as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发的角度来看，我们必须确定从哪里开始。本书将讨论的方法如下：
- en: '**The bottom-up approach**: With this approach, we think about the different
    components we will need (class, service, module, and so on) and then pick the
    most logical one and start coding.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自下而上的方法**：采用这种方法，我们考虑我们将需要的不同组件（类、服务、模块等），然后选择最合乎逻辑的组件并开始编码。'
- en: '**The top-down approach**: With this approach, we work from the user scenario
    and UI. We then create the application around the components in the application.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自上而下的方法**：采用这种方法，我们从用户场景和UI开始工作。然后我们围绕应用程序中的组件创建应用程序。'
- en: There are merits to both these approaches, and the choice can be based on your
    team, the existing components, requirements, and so on. In most cases, it is best
    for you to make the choice based on the least resistance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有其优点，选择可以基于您的团队、现有组件、需求等。在大多数情况下，最好根据最小阻力来做出选择。
- en: In this chapter, the approach of the specification is top-down; everything is
    laid out for you from the user scenario and will allow you to organically build
    the application around the UI.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，规范的方法是自上而下的；一切都为您准备好，从用户场景开始，将允许您有机地围绕UI构建应用程序。
- en: Testing a component
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试一个组件
- en: Before getting into the specifications and the mindset of the feature being
    delivered, it is important to understand the fundamentals of testing a component
    class. A component in Angular is a key feature used in most applications.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入交付功能的规范和思维方式之前，重要的是要了解测试组件类的基本知识。在大多数应用程序中，Angular中的组件是一个关键特性。
- en: Getting ready to go
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好开始
- en: Our sample application (`quickstart`) has some very basic test specs for unit
    and end-to-end testing. We will start the TDD approach from the very beginning,
    so we will not use any of the test specs and the existing component's code in
    our implementation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序（`quickstart`）有一些非常基本的单元测试和端到端测试规范。我们将从一开始采用TDD方法，因此在实现过程中不会使用任何测试规范和现有组件的代码。
- en: For that, what can we do is just clean up this sample application, and we will
    just keep the folder structure and application bootstrap files.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以做的就是清理这个示例应用程序，只保留文件夹结构和应用程序引导文件。
- en: So, first of all, we will have to remove the unit test file (`app.component.spec.ts`)
    and end-to-end test files (`app.e2e-spec.ts`). These are two test specs that existed
    in the application structure.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们必须删除单元测试文件（`app.component.spec.ts`）和端到端测试文件（`app.e2e-spec.ts`）。这两个测试规范存在于应用程序结构中。
- en: Setting up a simple component test
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置一个简单的组件测试
- en: When testing a component, it's important to inject the component into the test
    suite and then initiate the component class as the second task. The tests confirm
    that either the objects or methods in the component's scope are available as expected.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试组件时，将组件注入测试套件中，然后将组件类初始化为第二个任务非常重要。测试确认组件范围内的对象或方法是否按预期可用。
- en: 'To have the component instance in the test suite, we will use the simple `import`
    statement in the test suite and initiate the component object in the `beforeEach`
    method so that we have a new instance of the component object for every test spec
    with that test suite. Here is an example of what this will look like:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在测试套件中拥有组件实例，我们将在测试套件中使用简单的`import`语句，并在`beforeEach`方法中初始化组件对象，以便在测试套件中的每个测试规范中都有组件对象的新实例。以下是一个示例：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, as long as the component class is initiated for every test spec, it will
    have a new instance for every spec, and the internal scope will act based on that.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只要为每个测试规范初始化组件类，它就会为每个规范创建一个新实例，并且内部范围将根据此进行操作。
- en: Initializing the component
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化组件
- en: To test a component, it's important to initialize the component class so that
    we have the component object available to the test suite's scope and all the members
    of the object are available around the specific test suite.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试组件，重要的是初始化组件类，以便在测试套件的范围内拥有组件对象，并且对象的所有成员都在特定的测试套件周围可用。
- en: As long as the component contains the template to render the UI, it's important
    to initialize the component before beginning e2e testing, and it depends on DOM
    elements.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 只要组件包含渲染UI的模板，就需要在开始端到端测试之前初始化组件，并且这取决于DOM元素。
- en: 'So when we plan to do e2e testing for any component, we should initiate that
    in the DOM, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们计划对任何组件进行端到端测试时，我们应该在DOM中初始化它，如下所示：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: End-to-end versus unit test for components
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端到端与组件的单元测试
- en: In the preceding example, we looked at the component test suite, which is for
    unit testing, and we have to import and create an instance of the component class
    as the unit test. We will test the functionality or feature of every method that
    is defined in the component.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看了组件测试套件，这是用于单元测试的，我们需要导入并创建组件类的实例作为单元测试。我们将测试组件中定义的每个方法的功能或特性。
- en: On the other hand, for end-to-end testing, we do not need to import or create
    an instance of the component class as we will not need to comment with the competent
    object or all its members. Rather, it needs to interact with the DOM elements
    of the landing page of the application that is running.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于端到端测试，我们不需要导入或创建组件类的实例，因为我们不需要使用组件对象或其所有成员进行交互。相反，它需要与正在运行的应用程序的登陆页面的DOM元素进行交互。
- en: So, for that, we will need to run the application and navigate the test suite
    to the application landing page, and we can do so with the global `browser` object
    provided by Protractor itself.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为此，我们需要运行应用程序并将测试套件导航到应用程序的登陆页面，我们可以使用Protractor本身提供的全局`browser`对象来实现这一点。
- en: 'Here is an example of what it should look like:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，它应该是这样的：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can navigate to all the URLs of the application using `browser.get('path')`
    as needed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据需要使用`browser.get('path')`导航到应用程序的所有URL。
- en: Diving into our comment application
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入我们的评论应用程序
- en: 'Now that the setup and approach have been decided, we can start our first test.
    From a testing point of view, as we will be using a top-down approach, we will
    write our Protractor tests first and then build the application. We will follow
    the same TDD life cycle we have already reviewed: test first, make it run, and
    make it better.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在设置和方法已经确定，我们可以开始我们的第一个测试。从测试的角度来看，由于我们将使用自顶向下的方法，我们将首先编写我们的 Protractor 测试，然后构建应用程序。我们将遵循我们已经审查过的相同的
    TDD 生命周期：首先测试，使其运行，然后使其更好。
- en: Test first
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首先测试
- en: 'The scenario given is already in a well-specified format and fits our Protractor
    testing template:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的场景已经以规范的格式给出，并符合我们的 Protractor 测试模板：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Placing the scenario in the template, we get the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将场景放入模板中，我们得到以下代码：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Following the 3 A's (assemble, act, assert), we will fit the user scenario in
    the template.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循 3A 原则（组装、行动、断言），我们将把用户场景放入模板中。
- en: Assemble
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组装
- en: 'The browser will need to point to the first page of the application. As the
    base URL has already been defined, we can add the following to the test:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器将需要指向应用程序的第一个页面。由于基本 URL 已经定义，我们可以将以下内容添加到测试中：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that the test has been prepared, we can move on to the next step: act.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试已经准备好，我们可以继续下一步：行动。
- en: Act
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行动
- en: The next thing we need to do, based on the user specification, is to add an
    actual comment. The easiest thing is to just put some text into an input box.
    The test for this, again without knowing what the element will be called or what
    it will do, is to write it based on what it should be.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户的规范，我们需要做的下一件事是添加一个实际的评论。最简单的方法就是将一些文本放入输入框中。对于这个测试，再次不知道元素将被称为什么或者它将做什么，我们将根据它应该是什么来编写它。
- en: 'Here is the code to add the comment section for the application:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为应用程序添加评论部分的代码：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The last assembly component, as a part of the test, is to click on the **Submit**
    button. This can be easily achieved in Protractor using the `click` function.
    Even though we don''t have a page yet, or any attributes, we can still name the
    button that will be created:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 作为测试的一部分，最后一个组件是点击“提交”按钮。在 Protractor 中可以很容易地通过 `click` 函数实现这一点。即使我们还没有页面，或者任何属性，我们仍然可以命名将要创建的按钮：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, we will hit the crux of the test and assert the user's expectations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将击中测试的关键点，并断言用户的期望。
- en: Assert
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: The user expectation is that once the **Submit** button is clicked on, the comment
    is added. This is a little ambiguous, but we can determine that somehow the user
    needs to get notified that the comment was added.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 用户期望是一旦点击“提交”按钮，评论就会被添加。这有点模糊，但我们可以确定用户需要以某种方式收到评论已添加的通知。
- en: 'The easiest approach is to display all comments on the page. In Angular, the
    easiest way to do this is to add an `*ngFor` object that displays all comments.
    To test this, we will add the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是在页面上显示所有评论。在 Angular 中，这样做的最简单方法是添加一个 `*ngFor` 对象来显示所有评论。为了测试这一点，我们将添加以下内容：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now the test has been constructed and meets the user specifications. It is
    small and concise. Here is the completed test:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试已经构建并满足用户的规范。它既小又简洁。以下是完成的测试：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Make it run
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使其运行
- en: Based on the errors and output of the test, we will build our application as
    we go.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 基于测试的错误和输出，我们将在构建应用程序的过程中进行。
- en: 'Start the web server using the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动 Web 服务器：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the Protractor test to see the first error:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Protractor 测试以查看第一个错误：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Alternatively, we can run this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以运行这个：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our first error could be that it''s not getting the element the locator expected:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个错误可能是没有得到定位器期望的元素：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The reason for the error is simple: it''s not getting the element as defined
    in the locator. We can see the current application and why it''s not getting the
    element.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的原因很简单：它没有按照定位器中定义的元素获取。我们可以看到当前的应用程序以及为什么它没有获取到元素。
- en: Recap the present application
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结当前应用程序
- en: As long as we have cloned the sample Angular `quickstart` project as our application
    to test, it has a ready Angular environment. It Bootstraps the Angular project
    with a simple application component defined with `My First Angular 2 App` as the
    output.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们将示例Angular“quickstart”项目克隆为我们要测试的应用程序，它就具有一个准备好的Angular环境。它使用一个简单的应用程序组件定义了“我的第一个Angular
    2应用程序”作为输出来引导Angular项目。
- en: So, in our TDD approach, we should not have any environment/Angular Bootstrap-related
    error, and it seems we are on the right path.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的TDD方法中，我们不应该有任何与环境/Angular引导相关的错误，看起来我们走在了正确的道路上。
- en: Let's take a look at what we have right now in our sample application. On our
    landing page, `index.html`, we have included all required library files and implemented
    `system.js` to load the application files.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的示例应用程序现在有什么。在我们的首页`index.html`中，我们已经包含了所有必需的库文件，并实现了`system.js`来加载应用程序文件。
- en: 'In the `<body>` tag in the `index.html` file, we have initiated the application
    as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`文件中的`<body>`标签中，我们已经启动了应用程序，如下所示：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The HTML tag expects a component with `my-app` as the selector for that component,
    and yes, we have that as `app.component.ts`, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: HTML标签期望一个带有`my-app`作为该组件选择器的组件，是的，我们有`app.component.ts`如下：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Angular introduced `ngModule` as an `appModule` to modularize and manage dependencies
    for every component. With this `appModule`, an application can define all the
    required dependencies at a glance. Besides that, it helped lazy-load the modules.
    We will look at the details of `ngModule` in the Angular docs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Angular引入了`ngModule`作为`appModule`，以模块化和管理每个组件的依赖关系。通过这个`appModule`，应用程序可以一目了然地定义所有所需的依赖关系。除此之外，它还帮助延迟加载模块。我们将在Angular文档中详细了解`ngModule`的细节。
- en: It imports all the required modules in the application, declares all the modules
    from a single entry point, and also defines the Bootstrapping component.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它在应用程序中导入了所有必需的模块，从单一入口点声明了所有模块，并且还定义了引导组件。
- en: The application always Bootstraps based on this file's configuration.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序总是基于该文件的配置进行引导。
- en: 'The file is located at the application root as `app.module.ts`, and it looks
    as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件位于应用程序根目录下，名为`app.module.ts`，其内容如下：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The entry point to the application is the `main.ts` file, which will import
    the `appModule` file and instruct to Bootstrap the application based on that:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的入口点是`main.ts`文件，它将导入`appModule`文件，并指示根据该文件引导应用程序：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The test couldn't find our input locator. We need to add the input to the page,
    and we need to do that via the component's template.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 测试找不到我们的输入定位器。我们需要将输入添加到页面，并且我们需要通过组件的模板来做到这一点。
- en: Adding the input
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加输入
- en: 'Here are the steps we need to follow to add the input to the page:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要遵循的步骤来将输入添加到页面：
- en: 'We will have to add a simple `input` tag to the template of the application
    component, as shown here:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将不得不在应用程序组件的模板中添加一个简单的`input`标签，如下所示：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After running the test again, it seems that there are no more errors related
    to the input locator, but it has a new error as the `button` tag was missing:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试后，似乎与输入定位器相关的错误已经没有了，但是出现了一个新的错误，即`button`标签丢失：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Just like the previous error, we need to add a `button` to the template with
    the appropriate text:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像之前的错误一样，我们需要在模板中添加一个`button`，并附上适当的文本：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After running the test again, it seems that there are no more errors related
    to the `button` locator, but again, it has a new error, as follows, as the repeater
    locator is missing:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试后，似乎没有与`button`定位器相关的错误，但是又出现了新的错误，如下所示，重复器定位器丢失：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This appears to be a result of our assumption that a submitted comment will
    be available on the page through `*ngFor`. To add this to the page, we will use
    a method in the component class to provide the data for the repeater.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是我们假设提交的评论将通过`*ngFor`在页面上可用的结果。为了将其添加到页面上，我们将在组件类中使用一个方法来为重复器提供数据。
- en: Component
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件
- en: As mentioned in the preceding section, the error occurs because there is no
    `comments` object. In order to add the `comments` object, we will use the component
    class that has an array of `comments` in its scope.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，错误是因为没有`comments`对象。为了添加`comments`对象，我们将使用具有`comments`数组的组件类。
- en: 'Perform the following steps to add a `comments` object to the scope:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤将`comments`对象添加到作用域中：
- en: 'As we already have `AppComponent` as a class in our component, we will need
    to define the comments array, which we can use in a repeater:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经在组件中有`AppComponent`作为一个类，我们需要定义评论数组，我们可以在重复器中使用：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we will add a repeater for the comments in the template, as shown here:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在模板中为评论添加一个重复器，如下所示：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s run the Protractor test and see where we are:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行Protractor测试，看看我们的进展：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Oops! We are still getting the same error. However, don't worry; there might
    be some other issue.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！我们仍然得到相同的错误。不过别担心，可能还有其他问题。
- en: Let's look at the actual page that gets rendered and see what's going on. In
    Chrome, navigate to `http://localhost:3000` and open the console to see the page
    source (*Ctrl + Shift + J*). Note that the repeater and component are both there;
    however, the repeater is commented out. Since Protractor is only looking at visible
    elements, it won't find the list.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际呈现的页面，看看发生了什么。在Chrome中，导航到`http://localhost:3000`并打开控制台以查看页面源代码（*Ctrl
    + Shift + J*）。请注意，重复器和组件都在那里；但是，重复器被注释掉了。由于Protractor只查看可见元素，它不会找到列表。
- en: Great! Now we know why the repeater list isn't visible, but we have to fix it.
    In order for a comment to show up, it has to exist on the component's `comments`
    scope.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们知道为什么重复列表不可见，但是我们必须修复它。为了使评论显示出来，它必须存在于组件的`comments`作用域中。
- en: 'The smallest change is to add something to the array to initialize it, as shown
    in the following code snippet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的更改是向数组中添加一些内容以初始化它，如下面的代码片段所示：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, if we run the test, we get the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行测试，我们会得到以下输出：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Great, it seems we are getting closer as the errors have gone down! We have
    tackled almost all the unexpected errors and met our expectations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，看起来我们离成功更近了！我们已经解决了几乎所有意外错误并达到了我们的期望。
- en: So let's take a look at the changes that we have made so far and what our codes
    look like.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们迄今为止所做的更改以及我们的代码是什么样子的。
- en: 'Here''s the `body` tag of the `index.html` file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`index.html`文件的`body`标签：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The application component file is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 应用组件文件如下：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Make it pass
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使其通过
- en: With TDD, we want to add the smallest possible component to make the test pass.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD，我们希望添加最小可能的组件来使测试通过。
- en: Since we have hard coded the comments array for the moment to be initialized
    to three items and the first items to be `First comment`, change `First comment`
    to `a sample comment`; this should make the test pass.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前已经将评论数组硬编码为初始化为三个项目，并且第一个项目为`First comment`，将`First comment`更改为`a sample
    comment`，这应该使测试通过。
- en: 'Here is the code to make the test pass:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使测试通过的代码：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the test, and bam! We get a passing test:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试，哇！我们得到了一个通过的测试：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Wait a second! We still have some work to do. Although we got the test to pass,
    it is not done. We added some hacks just to get it to pass. Two things stand out:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！我们还有一些工作要做。虽然我们让测试通过了，但还没有完成。我们添加了一些黑客技巧，只是为了让它通过。有两件事引人注目：
- en: We clicked on the **Submit** button, which really doesn't have any functionality
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们单击了实际上没有任何功能的“提交”按钮
- en: We hardcoded the initialization of the expected value for a comment
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对评论的预期值进行了硬编码初始化
- en: The preceding changes are critical steps that we need to perform before we move
    forward. They will be tackled in the next phase of the TDD life cycle, that is,
    make it better (refactor).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，上述更改是我们需要执行的关键步骤。它们将在TDD生命周期的下一个阶段中解决，即使其更好（重构）。
- en: Make it better
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使其更好
- en: 'The two components that need to be reworked are as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 需要重新设计的两个组件如下：
- en: Adding behavior to the **Submit** button
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为“提交”按钮添加行为
- en: Removing the hardcoded value of the comments
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除评论的硬编码值
- en: Implementing the Submit button
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现“提交”按钮
- en: The **Submit** button needs to actually do something. We were able to sidestep
    the implementation by just hardcoding the value. Using our tried-and-trusted TDD
    techniques, switch to an approach focused on unit testing. So far, the focus has
    been on the UI and pushing changes to the code; we haven't written a single unit
    test.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: “提交”按钮需要实际做一些事情。我们可以通过硬编码值来绕过实现。使用我们经过验证的TDD技术，转而采用专注于单元测试的方法。到目前为止，重点一直放在UI上并将更改推送到代码上；我们还没有编写单个单元测试。
- en: For this next bit of work, we will switch gears and focus on driving the development
    of the **Submit** button through tests. We will be following the TDD life cycle
    (test first, make it run, and make it better).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的工作中，我们将转变思路，专注于通过测试驱动“提交”按钮的开发。我们将遵循TDD生命周期（先测试，使其运行，然后使其更好）。
- en: Configuring Karma
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置卡尔玛
- en: We did something very similar for the to-do list application in [Chapter 3](ch03.html
    "Chapter 3. The Karma Way"), *The Karma Way*. We won't spend as much time diving
    into the code, so review the previous chapters for a deeper discussion of some
    of the attributes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](ch03.html "第3章。卡尔玛方式")中为待办事项列表应用程序做了非常类似的事情，“卡尔玛方式”。我们不会花太多时间深入到代码中，所以请查看以前的章节，以深入讨论一些属性。
- en: 'Here are the steps we need to follow to configure Karma:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要遵循的配置卡尔玛的步骤：
- en: 'Update the `files` section with the added files:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用添加的文件更新`files`部分：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Start Karma:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动卡尔玛：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Confirm that Karma is running:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认卡尔玛正在运行：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Test first
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 先测试
- en: 'Let''s start with a new file in the `spec/unit` folder, called `app.component.spec.ts`.
    This will contain the test spec for the unit test. We will use the base template,
    including all necessary imports, such as `TestBed`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`spec/unit`文件夹中的新文件开始，名为`app.component.spec.ts`。这将包含单元测试的测试规范。我们将使用基本模板，包括所有必要的导入，如`TestBed`：
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: According to the specification, when the **Submit** button is clicked on, it
    needs to add a comment. We will need to fill in the blanks of the three components
    of a test (assemble, act, and assert).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规范，当单击“提交”按钮时，需要添加评论。我们需要填写测试的三个组成部分（组装、行动和断言）的空白。
- en: '**Assemble**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 组装
- en: 'The behavior needs to be part of a component for the frontend to use it. The
    object under testing in this case is the component''s scope. We need to add this
    to the assembly of this test. Like we did in [Chapter 3](ch03.html "Chapter 3. The
    Karma Way"), *The Karma Way*, we will do the same in the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 行为需要成为前端组件的一部分来使用。在这种情况下，测试的对象是组件的范围。我们需要将这一点添加到这个测试的组装中。就像我们在[第3章](ch03.html
    "第3章。卡尔玛方式")中所做的那样，“卡尔玛方式”，我们将在以下代码中做同样的事情：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, the component object and its member are available in the test suite and
    will be testable as expected.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`component`对象及其成员在测试套件中可用，并将如预期般进行测试。
- en: '**Act**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**行动**'
- en: 'The specification determines that we need to call an `add` method in the component
    object. Add the following code to the `beforeEach` section of the test:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 规范确定我们需要在组件对象中调用`add`方法。将以下代码添加到测试的`beforeEach`部分：
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, the assertion should get the first comment to test.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，断言应该获取第一个评论进行测试。
- en: '**Assert**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**断言**'
- en: 'Assert that the comment items in the `component` object now contain any comment
    as the first element. Add the following code to the test:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 断言`component`对象中的评论项现在包含任何评论作为第一个元素。将以下代码添加到测试中：
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Save the file, and let's move on to the next step of the life cycle and make
    it run (execute).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，让我们继续进行生命周期的下一步并运行它（执行）。
- en: Make it run
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让它运行
- en: 'Now that we have prepared the test, we need to make the test pass. Looking
    at the output of the console where Karma is running, we see the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好测试，我们需要让测试通过。查看Karma运行时的控制台输出，我们看到以下内容：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Looking at our unit test, we see that this is the `add` function. Let''s go
    ahead and put in an `add` function into the controller''s `scope` object using
    the following steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的单元测试，我们看到这是`add`函数。让我们继续按照以下步骤将`add`函数放入控制器的`scope`对象中：
- en: 'Open the controller scope and create a function named `add`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制器范围并创建一个名为`add`的函数：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Check Karma''s output, and let''s see where we are:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查Karma的输出，让我们看看我们的进展：
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we have hit the expectation. Remember to think of the smallest change
    to get this to work. Modify the `add` function to set the `$scope.comments` array
    to any comment when called:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经达到了期望。记住要考虑最小的改变来使其工作。修改`add`函数，将`$scope.comments`数组设置为任何评论：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `unshift` function is a standard JavaScript function that adds an item to
    the front of an array.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`unshift`函数是一个标准的JavaScript函数，它将一个项目添加到数组的开头。'
- en: 'When we check Karma''s output, we''ll see the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查Karma的输出时，我们会看到以下内容：
- en: '[PRE57]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Success! The test passes, but again needs some work. Let's move on to the next
    stage and make it better (refactor).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！测试通过了，但还需要一些工作。让我们继续进行下一阶段并改进它（重构）。
- en: Make it better
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让它变得更好
- en: 'The main point that needs to be refactored is the `add` function. It doesn''t
    take any arguments! This should be straightforward to add, and simply confirms
    that the test still runs. Update the `add` function of `app.component.ts` to take
    an argument and use that argument to add to the `comments` array:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 需要重构的主要点是`add`函数。它不接受任何参数！这应该很容易添加，并且只是确认测试仍然运行。更新`app.component.ts`的`add`函数，以接受一个参数并使用该参数添加到`comments`数组中：
- en: '[PRE58]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Check the output window of Karma and ensure that the test still passes. The
    complete unit test looks as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Karma的输出窗口，并确保测试仍然通过。完整的单元测试如下所示：
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `AppComponent` class file now looks like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppComponent`类文件现在是这样的：'
- en: '[PRE60]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Backing up the test chain
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备份测试链
- en: 'We completed the unit test and added the `add` function. Now we can add the
    function to specify the behavior of the **Submit** button. The way to link the
    `add` method to the button is to use the `(click)` event. The steps to add the
    behavior to the **Submit** button are as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了单元测试并添加了`add`函数。现在我们可以添加函数来指定**提交**按钮的行为。将`add`方法链接到按钮的方法是使用`(click)`事件。添加行为到**提交**按钮的步骤如下：
- en: 'Open the `app.component.ts` file and update it as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.component.ts`文件并进行以下更新：
- en: '[PRE61]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Hold on! Is the value hardcoded? Well, again, we want to make the smallest change
    and ensure that the test still passes. We will work through our refactors until
    the code is how we want it to be, but instead of a Big Bang approach, we want
    to make small, incremental changes.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！这个值是硬编码的吗？好吧，我们再次希望做出最小的更改，并确保测试仍然通过。我们将不断进行重构，直到代码达到我们想要的状态，但我们不想采取大爆炸的方式，而是希望进行小的、增量的改变。
- en: Now, let's rerun the Protractor test and ensure that it still passes. The output
    says that it passed, and we are okay. The hardcoded value wasn't removed from
    the comments. Let's go ahead and remove that now.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们重新运行 Protractor 测试，并确保它仍然通过。输出显示它通过了，我们没问题。硬编码的值没有从注释中删除。让我们继续并立即删除它。
- en: 'The `AppComponent` class file should now look as follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AppComponent` 类文件现在应该如下所示：'
- en: '[PRE62]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Run the test and see that we still get a passing test.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试，看到我们仍然得到一个通过的测试。
- en: The last thing we need to mop up is the hardcoded value in `(click)`. The comment
    being added should be determined by the input in the comment input text.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要清理的最后一件事是 `(click)` 中的硬编码值。添加的评论应该由评论输入文本中的输入确定。
- en: Binding the input
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定输入
- en: 'Here are the steps we need to follow to bind the input:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要遵循的绑定输入的步骤：
- en: 'To be able to bind the input to something meaningful, add an `ngModel` attribute
    to the `input` tag:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够将输入绑定到有意义的东西，将 `ngModel` 属性添加到 `input` 标签中：
- en: '[PRE63]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, in the `(click)` attribute, simply use the `newComment` model as the
    input:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `(click)` 属性中，简单地使用 `newComment` 模型作为输入：
- en: '[PRE64]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We will have to import the form module in the app module (`app.module.ts`)
    as it''s a dependency for `ngModel`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将不得不在应用程序模块（`app.module.ts`）中导入表单模块，因为它是 `ngModel` 的依赖项：
- en: '[PRE65]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Run the Protractor test and confirm that everything has passed and is good to
    go.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Protractor 测试，并确认一切都通过了，可以进行。
- en: Onward and upward
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向前迈进
- en: Now that we have the first specification working, and it is end-to-end and unit
    tested, we can start the next specification. The next specification states that
    the user wants the ability to like a comment.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让第一个规范工作了，并且它是端到端和单元测试的，我们可以开始下一个规范。下一个规范说明用户希望能够喜欢一条评论。
- en: 'We will use the top-down approach and start our test from Protractor. We will
    continue to follow the TDD life cycle: test first, make it run, and make it better.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用自上而下的方法，从 Protractor 开始我们的测试。我们将继续遵循 TDD 生命周期：先测试，使其运行，然后使其更好。
- en: Test first
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先测试
- en: 'Following the pattern, we will start with a basic Protractor test template:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 按照模式，我们将从一个基本的 Protractor 测试模板开始：
- en: '[PRE66]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When we fill in the specification, we get the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们填写规范时，我们得到以下结果：
- en: '[PRE67]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: With the template in place, we are ready to construct the test.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有了模板，我们准备构建测试。
- en: Assemble
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组装
- en: 'The assembly of this test will require a comment to exist. Place the comment
    within the existing posted comment test. It should look similar to this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的组装将需要存在一个评论。将评论放在现有的发布评论测试中。它应该看起来类似于这样：
- en: '[PRE68]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Act
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行动
- en: 'The user specification we test is that the **Like** button performs an action
    for a specific comment. Here are the steps that will be required and the code
    required to carry them out (note that the following steps will be added to the
    `beforeEach` text):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试的用户规范是**Like**按钮对特定评论执行操作。以下是需要的步骤和执行它们所需的代码（请注意，以下步骤将添加到 `beforeEach` 文本中）：
- en: 'Store the first comment so that it can be used in the test:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储第一条评论，以便在测试中使用：
- en: '[PRE69]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Find the first comment''s `likeButton`:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到第一条评论的 `likeButton`：
- en: '[PRE70]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The code for the **Like** button when it is clicked on is as follows:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击**Like**按钮时，代码如下：
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Assert
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: 'The specification expectation is that once the comment has been liked, it is
    liked. This is best done by putting an indicator of the number of likes and ensuring
    that the count is `1`. The code will then be as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 规范的期望是一旦评论被点赞，它就会被点赞。最好的方法是通过放置点赞数量的指示器，并确保计数为`1`。然后代码将如下所示：
- en: '[PRE72]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The created test now looks like this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建的测试看起来是这样的：
- en: '[PRE73]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Make it run
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让它运行
- en: 'The test has been prepared and is itching to run. We will now run it and fix
    the code until the test passes. The following steps will detail the error and
    fix the cycle required to make the test path:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 测试已经准备就绪，迫不及待地要运行。我们现在将运行它并修复代码，直到测试通过。以下步骤将详细说明需要进行的错误和修复循环，以使测试路径：
- en: Run Protractor.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Protractor。
- en: 'View the error message in the command line:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中查看错误消息：
- en: '[PRE74]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'As the error states, there is no **like** button. Go ahead and add the button:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如错误所述，没有**like**按钮。继续添加按钮：
- en: '[PRE75]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Run Protractor.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Protractor。
- en: 'View the next error message:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看下一个错误消息：
- en: '[PRE76]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: By adding the **like** button, we caused our other test to fail. The reason
    is our use of the `getText()` method. Protractor's `getText()` method gets the
    inner text, including inner elements.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加**like**按钮，我们导致其他测试失败。原因是我们使用了`getText()`方法。Protractor的`getText()`方法获取内部文本，包括内部元素。
- en: 'To fix this, we need to update the previous test to include **like** as part
    of the test:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要更新先前的测试，将**like**作为测试的一部分包括进去：
- en: '[PRE77]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Run Protractor.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Protractor。
- en: 'View the next error message:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看下一个错误消息：
- en: '[PRE78]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'It''s time to add a `likes` binding. This one is a little more involved. The `likes`
    needs to be bound to a comment. We need to change the way the comments are held
    in the component. Comments need to hold the `comment` title and the number of
    likes. A comment should be an object like this:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是添加`likes`绑定的时候了。这个稍微复杂一些。`likes`需要绑定到一个评论。我们需要改变组件中保存评论的方式。评论需要保存`comment`标题和点赞数。评论应该是这样的一个对象：
- en: '[PRE79]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Again, the focus of this step is just to get the test to pass. The next step
    is to update the component's `add` function to create comments based on the object
    that we described in the preceding steps.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次强调，这一步的重点只是让测试通过。下一步是更新组件的`add`函数，以根据我们在前面步骤中描述的对象创建评论。
- en: 'Open `app.component.ts` and edit the `add` function, as follows:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.component.ts`并编辑`add`函数，如下所示：
- en: '[PRE80]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Update the page to use the value for the comment:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新页面以使用评论的值：
- en: '[PRE81]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Before rerunning the Protractor test, we need to add the new `comment.likes`
    binding to the HTML page:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重新运行Protractor测试之前，我们需要将新的`comment.likes`绑定添加到HTML页面中：
- en: '[PRE82]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now rerun the Protractor tests, and let''s see where the errors are:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在重新运行Protractor测试，让我们看看错误在哪里：
- en: '[PRE83]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'As the inner text of the comment has changed, we need to change the expectation
    of the test:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于评论的内部文本已更改，我们需要更改测试的期望：
- en: '[PRE84]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Run Protractor:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Protractor：
- en: '[PRE85]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Finally, we are down to the expectation of the test. In order to make this
    test pass, the smallest change will be to make the **like** button update the
    likes on the `comment` array. The first step is to add a `like` method to the
    controller, which will update the number of likes:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们来到了测试的期望。为了使这个测试通过，最小的更改将是使**like**按钮更新`comment`数组上的点赞数。第一步是在控制器中添加一个`like`方法，它将更新点赞数：
- en: '[PRE86]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Link the `like` method to the HTML page using a `(click)` attribute on the
    button, as follows:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`like`方法与HTML页面链接，使用按钮上的`(click)`属性，如下所示：
- en: '[PRE87]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Run Protractor and confirm that the tests pass!
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Protractor并确认测试通过！
- en: 'The page now looks like the following screenshot:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 页面现在看起来如下截图：
- en: '![Make it run](graphics/image_06_004.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![让它运行](graphics/image_06_004.jpg)'
- en: Compared with the diagram at the beginning of this chapter, all the features
    have been created. Now that we've made the test pass in Protractor, we need to
    check the unit tests to ensure that our changes didn't break the them.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章开头的图表相比，所有功能都已创建。现在我们已经让Protractor中的测试通过了，我们需要检查单元测试以确保我们的更改没有破坏它们。
- en: Fixing the unit tests
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复单元测试
- en: 'One of the primary changes required was to make the comment an object consisting
    of a value and the number of likes. Before thinking too much about how the unit
    tests could have been affected, let''s kick them off. Execute the following command:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的主要更改之一是将评论作为一个包含值和点赞数量的对象。在过多考虑单元测试可能受到影响之前，让我们开始吧。执行以下命令：
- en: '[PRE88]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'As expected, the error is related to the new `comment` object:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，错误与新的`comment`对象有关：
- en: '[PRE89]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Reviewing the expectation, it seems like the only thing required is for `comment.value`
    to be used in the expectation, as opposed to the `comment` object itself. Change
    the expectation as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 审查期望，似乎唯一需要的是在期望中使用`comment.value`，而不是`comment`对象本身。将期望更改如下：
- en: '[PRE90]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Save the file and check the Karma output. Confirm that the test passes. Both
    the Karma and Protractor tests pass, and we have completed the primary user behaviors
    of adding a comment and liking it. We are now free to move on to the next step
    and make things better.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并检查Karma输出。确认测试通过。Karma和Protractor测试都通过了，我们已经完成了添加评论和点赞的主要用户行为。现在我们可以继续下一步，让事情变得更好。
- en: Make it better
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让它变得更好
- en: All in all, the approach ended with the result we wanted. Users are now able
    to like a comment in the UI and see the number of likes. The major thing from
    a refactor standpoint is that we have not unit-tested the `like` method.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这种方法最终得到了我们想要的结果。用户现在可以在UI中点赞评论并看到点赞数量。从重构的角度来看，我们没有对`like`方法进行单元测试。
- en: Reviewing our development to-do list, we see that the list is an action that
    we wrote down. Before completely wrapping up the feature, let's discuss the option
    of adding a unit test for the `like` functionality.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 审查我们的开发待办清单，我们看到列表是我们写下的一个动作。在完全结束该功能之前，让我们讨论一下是否要为`like`功能添加单元测试的选项。
- en: Coupling the test
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 耦合测试
- en: As already discussed, tests are tightly coupled to the implementation. This
    is a good thing when there is a complicated logic involved or we need to ensure
    that certain aspects of the application behave in certain ways. It is important
    to be aware of the coupling and know when it is important to bring it into the
    application and when it is not. The `like` function, which we created, simply
    increments a counter on an object. This can be easily tested; however, the coupling
    that we will bring in with a unit test will not give us the extra value.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 正如已经讨论过的，测试与实现紧密耦合。当涉及复杂逻辑或需要确保应用程序的某些方面以特定方式行为时，这是一件好事。重要的是要意识到耦合，并知道何时将其引入应用程序以及何时不需要。我们创建的`like`函数只是简单地增加了对象上的计数器。这可以很容易地进行测试；然而，单元测试将引入的耦合不会给我们带来额外的价值。
- en: In this case, we will not add another unit test for the `like` method. As the
    application progresses, we may find the need to add a unit test in order to develop
    and extend the function.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不会为`like`方法添加另一个单元测试。随着应用程序的进展，我们可能会发现需要添加单元测试以开发和扩展功能。
- en: 'Here are some things I consider when adding a test:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加测试时，以下是我考虑的一些事项：
- en: Does adding a test outweigh the cost of maintaining it?
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加测试的价值是否超过了维护成本？
- en: Is the test adding value to the code?
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试是否为代码增加了价值？
- en: Does it help other developers understand the code better?
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否帮助其他开发人员更好地理解代码？
- en: Is the functionality being tested in some or the other way?
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能是否以某种方式进行了测试？
- en: Based on our decision, there is no more refactoring or testing required. In
    the next section, we will take a step back and review the main points of this
    chapter.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的决定，不需要进行更多的重构或测试。在下一节中，我们将退一步，回顾本章的要点。
- en: Self-test questions
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: Q1\. Karma needs the Selenium WebDriver to run tests.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. 卡尔玛需要Selenium WebDriver来运行测试。
- en: 'True'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: 'Q2\. Given the following code segment, how would you select the following button:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. 鉴于以下代码片段，您将如何选择以下按钮：
- en: '[PRE91]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '`element.all(by.button(''button''))`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element.all(by.button(''button''))`'
- en: '`element.all(by.css(''type=button''))`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element.all(by.css(''type=button''))`'
- en: '`element(by.buttonText(''Click Me'')`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element(by.buttonText(''Click Me'')`'
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we walked through the TDD techniques of using Protractor and
    Karma together. As the application was developed, we were able to see where, why,
    and how to apply TDD testing tools and techniques.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用Protractor和Karma的TDD技术。随着应用程序的开发，我们能够看到何时、为什么以及如何应用TDD测试工具和技术。
- en: The approach, top-down, was different from the bottom-up approach discussed
    in [Chapter 3](ch03.html "Chapter 3. The Karma Way"), *The Karma Way*, and [Chapter
    4](ch04.html "Chapter 4. End-to-End Testing with Protractor"), *End-to-End Testing
    with Protractor*. With the bottom-up approach, the specifications are used to
    build unit tests and then build the UI layer on top of that. In this chapter,
    a top-down approach was shown to focus on the user's behavior.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自上而下的方法与[第3章](ch03.html "第3章。卡尔玛方式")中讨论的自下而上的方法不同，*卡尔玛方式*，以及[第4章](ch04.html
    "第4章。使用Protractor进行端到端测试")中讨论的自下而上的方法，*使用Protractor进行端到端测试*。在自下而上的方法中，规范用于构建单元测试，然后在其上构建UI层。在本章中，展示了一种自上而下的方法，重点放在用户行为上。
- en: 'The top-down approach tests the UI and then filters the development through
    the other layers. Both the approaches have their merits. When applying TDD, it
    is essential to know how to use both. In addition to walking through a different
    TDD approach, we saw some of the core testing components of Angular, such as the
    following:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 自上而下的方法测试UI，然后通过其他层过滤开发。这两种方法都有其优点。在应用TDD时，了解如何同时使用两者是至关重要的。除了介绍不同的TDD方法之外，我们还看到了Angular的一些核心测试组件，例如以下内容：
- en: Testing a component from end-to-end and unit perspectives
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从端到端和单元角度测试一个组件
- en: Importing a component class to the test suite and initiating it for unit testing
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将组件类导入测试套件并为单元测试启动它
- en: Protractor's ability to bind to `ngModel`, send keystrokes to input columns,
    and get an element's text by its inner HTML code and all subelements
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Protractor绑定到`ngModel`，向输入列发送按键，并通过其内部HTML代码和所有子元素获取元素的文本的能力
- en: The next chapter will build on the techniques used here and look into headless
    browser testing, advanced techniques for Protractor, and how to test Angular routes.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将基于此处使用的技术，并研究无头浏览器测试、Protractor的高级技术以及如何测试Angular路由。
