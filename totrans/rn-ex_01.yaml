- en: First Project - Creating a Basic To-Do List App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个项目 - 创建基本待办事项应用程序
- en: 'Having set up our environment for React Native development in the preface,
    let''s start developing the application. Throughout this book, I''ll refer to
    this application by the project name I began with--`Tasks`. In this chapter, we
    will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前言中我们已经为React Native开发设置了环境，现在让我们开始开发应用程序。在整个本书中，我将使用我最初开始的项目名称——“Tasks”来指代这个应用程序。在本章中，我们将涵盖以下主题：
- en: Planning the features that a to-do list app should have
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划待办事项应用程序应具备的功能
- en: Basic project architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本项目架构
- en: Introducing `StyleSheet`, the React Native component for working with styles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍`StyleSheet`，这是React Native用于处理样式的组件
- en: An overview of Flexbox, a layout mode inspired by CSS for styling in React Native
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flexbox概述，这是一种受CSS启发的布局模式，用于在React Native中进行样式设计
- en: Become acquainted with ES6, the new JavaScript syntax we will be writing our
    code in
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉ES6，我们将使用的新JavaScript语法
- en: Creating the building blocks of `Tasks` with `TextInput`, `ListView`, `AsyncStorage`,
    `Input`, state, and props
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`TextInput`、`ListView`、`AsyncStorage`、`Input`、状态和属性创建`Tasks`的构建块
- en: Learning about the iOS Simulator's Developer menu, which can help us during
    the writing of our app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解iOS模拟器的开发者菜单，这有助于我们在编写应用程序时
- en: Initializing a new project
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化新项目
- en: 'With the React Native SDK already installed, initializing a new React Native
    project is as simple as using the following command line:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于已经安装了React Native SDK，因此初始化新的React Native项目就像使用以下命令行一样简单：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let the React Native command line interface do its work for a few moments, then
    open the directory titled `Tasks` once it is completed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让React Native命令行界面工作一会儿，然后完成后再打开名为“Tasks”的目录。
- en: 'From there, running your app in iOS Simulator is as easy as typing the following
    command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里开始，在iOS模拟器中运行您的应用程序就像输入以下命令一样简单：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will start a process to build and compile your React Native app, launch
    the iOS Simulator, import your app to the Simulator, and start it. Whenever you
    make a change to the app, you will be able to reload and see those changes immediately.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动构建和编译您的React Native应用程序的过程，启动iOS模拟器，将应用程序导入模拟器，并启动它。每次您对应用程序进行更改时，您都可以立即重新加载并看到这些更改。
- en: Feature planning
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能规划
- en: Before writing any code, I'd like to take the time to plan out what I want to
    accomplish in my project and scope out a **minimum viable product** (**MVP**)
    to aim for prior to building out any advanced functionalities. This helps with
    the prioritization of what key components of our app are necessary to have a functioning
    prototype so that we can have something up and running.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，我想花时间规划我在项目中的目标，并确定一个**最小可行产品（MVP**）作为构建任何高级功能之前的目标。这有助于确定我们应用程序的关键组件，以便我们有一个可以运行的原型。
- en: 'For me, the MVP is a fantastic way to quantify my ideas into something I can
    interact with and use to validate any assumptions I have, or catch any edge cases,
    while spending the minimum amount of time necessary on coming to those conclusions.
    Here''s how I approach feature planning:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，最小可行产品（MVP）是一种将我的想法量化为可以互动并用于验证任何假设或捕捉任何边缘情况的方法，同时将所需的时间降到最低。以下是我如何进行功能规划：
- en: What does the product I'm building do?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我正在构建的产品做什么？
- en: Ideally, what are some of the highlighting features that make this application
    stand out?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想情况下，有哪些突出特点使这个应用程序脱颖而出？
- en: Which of the features on the preceding list are necessary to have a working
    product? Once you know the necessary features, cut out everything that doesn't
    give you the bare-bones functionality.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的列表中，哪些功能是构建一个工作产品所必需的？一旦你知道了必要的功能，就删除所有不提供基本功能的东西。
- en: Give some thought to its design, but don't stress on every single detail just
    yet.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑其设计，但暂时不要对每个细节都过于纠结。
- en: 'With these intentions in mind, here''s what I''ve come up with:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些意图，以下是我想到的：
- en: This is an application that will let me create and track a list of tasks that
    I have. These can be as small as a shopping list or as big as long-term goals.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个让我能够创建和跟踪任务列表的应用程序。这些可以小到购物清单，也可以大到长期目标。
- en: I'd like to set a reminder for each unique task so that I can get to each one in
    an orderly fashion. Ideally, the items on the list can be grouped into categories.
    Category grouping could perhaps be simplified by something like icons. This way,
    I can also sort and filter my list by icons.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我希望为每个独特的任务设置一个提醒，这样我就可以有序地完成每个任务。理想情况下，列表中的项目可以按类别分组。类别分组可能可以通过某种像图标这样的东西来简化。这样，我也可以通过图标对列表进行排序和筛选。
- en: The only things that are necessary from the beginning are that I can use a text
    input field to type a task, have it rendered onto a list of items, and mark them
    off as they are completed; everything else is secondary.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一开始，唯一必要的事情是，我可以用一个文本输入字段来输入任务，将其渲染到项目列表中，并在完成时标记它们；其他所有事情都是次要的。
- en: 'Now that we''ve got a clearer picture of our app, let''s break down some actionable
    steps we can take to make it a reality:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对应用有了更清晰的了解，让我们分解一些我们可以采取的具体步骤来实现它：
- en: Let's *generate a list of default items*. These don't have to be manually entered
    as we just want to see our list populated in the app itself.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们*生成一个默认项列表*。这些项不需要手动输入，因为我们只想在应用本身中看到我们的列表被填充。
- en: After that, your users should be able to *input their own tasks* using a text
    field and the native keyboard.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你的用户应该能够使用文本字段和原生键盘*输入他们自己的任务*。
- en: Next, I'd like to *make that list scrollable* in case my list of tasks spans
    past an entire vertical screen's height.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我想*使那个列表可滚动*，以防我的任务列表超过了整个垂直屏幕的高度。
- en: Then, we should *let items be marked as complete* with some sort of visual indicator.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们应该通过某种视觉指示器*让项目标记为完成*。
- en: That's it! These are the four goals we currently have. As I previously mentioned,
    everything else is secondary for the time being. For now, we just want to get
    an MVP up and running, and then we will tweak it to our hearts' content later.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！这是我们目前拥有的四个目标。正如我之前提到的，其他所有事情目前都是次要的。现在，我们只想尽快推出一个最小可行产品（MVP），然后我们将在之后根据我们的意愿对其进行调整。
- en: Let's move ahead and start thinking about architecture.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，开始思考架构。
- en: Project architecture
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目架构
- en: The next important thing I'd like to tackle is architecture; this is about how
    our React Native app will be laid out. While the projects we build for this book
    are meant to be done individually, I firmly believe that it is important to always
    write and architect code in a manner that expects the next person to look at it
    to be an axe-murderer with a short temper. The idea here is to make it simple
    for anyone to look at your application's structure and be able to follow along.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的事情是我想要解决的问题是架构；这是关于我们的React Native应用如何布局的问题。虽然我们为这本书构建的项目旨在单独完成，但我坚信，始终以期望下一个人查看它时是一个脾气暴躁的斧头杀手的方式来编写和架构代码是很重要的。这里的想法是使任何人都能查看你的应用程序的结构，并能够跟随。
- en: 'First, let''s take a look at how the React Native CLI scaffolds our project;
    comments on each relevant file are noted to the right-hand side of the double
    slashes (`//`):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看React Native CLI是如何构建我们的项目的；每个相关文件的注释都记在双斜杠（`//`）的右侧：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Android` and `iOS` folders will go several layers deep, but this is all
    part of its scaffolding and something we will not need to concern ourselves with
    at this point.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Android`和`iOS`文件夹将深入几层，但这都是其构建过程的一部分，我们目前不需要担心这一点。'
- en: Based on this layout, we see that the entry point for the iOS version of our
    app is `index.ios.js` and that a specific `iOS` folder (and `Android` for that
    matter) is generated.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个布局，我们可以看到我们应用的iOS版本入口是`index.ios.js`，并且生成了一个特定的`iOS`文件夹（以及相应的`Android`文件夹）。
- en: Rather than using these platform-specific folders to store components that are
    only applicable to one platform, I'd like to propose a folder named `app` alongside
    these which will encapsulate all the logic that we write.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用这些特定平台的文件夹来存储仅适用于一个平台的组件，我建议在这些文件夹旁边创建一个名为`app`的文件夹，它将封装我们编写的所有逻辑。
- en: Within this `app` folder, we'll have subfolders that contain our components
    and assets. With components, I'd like to keep its style sheet coupled alongside
    the JS logic within its own folder.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`app`文件夹内，我们将有包含我们的组件和资源的子文件夹。对于组件，我希望将它的样式表与其JS逻辑耦合在其自己的文件夹中。
- en: Additionally, component folders should never be nested--it ends up being way
    too confusing to follow and search for something. Instead, I prefer to use a naming
    convention that makes it immediately obvious what one component's relation to
    its parent/child/sibling happens to be.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，组件文件夹不应该嵌套，否则会变得非常难以跟踪和搜索。相反，我更喜欢使用一种命名约定，使一个组件与其父/子/兄弟的关系立即显而易见。
- en: 'Here''s how my proposed structure will look:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我的建议结构将看起来：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From just a quick observation, you might be able to infer that `TasksList` is
    the component that deals with our list of tasks shown on the screen. `TasksListCell`
    will be each individual row of that list, and `TasksListInput` will deal with
    the keyboard input field.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 只从快速观察中，你可能能够推断出`TasksList`是处理屏幕上显示的任务列表的组件。`TasksListCell`将是列表中的每一行，而`TasksListInput`将处理键盘输入字段。
- en: This is very bare-bones and there are optimizations that we can make. For example,
    we can think about things such as platform-specific extensions for iOS and Android,
    as well as building in further architecture for Redux; but for the purpose of
    this specific app, we will just start with the basics.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常基础，我们可以进行一些优化。例如，我们可以考虑iOS和Android的平台特定扩展，以及为Redux构建更进一步的架构；但出于这个特定应用的目的，我们只需从基础开始。
- en: StyleSheet
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式表
- en: React Native's core visual components accept a prop called `style` and the names
    and values more or less match up with CSS's naming conventions, with one major
    exception--kebab-case is swapped out for camelCase, similar to how things are
    named in JavaScript. For example, a CSS property of `background-color` will translate
    to `backgroundColor` in React Native.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: React Native的核心视觉组件接受一个名为`style`的属性，其名称和值与CSS的命名约定大致相同，但有一个主要例外——kebab-case被替换为camelCase，这与JavaScript中的命名方式相似。例如，CSS属性`background-color`在React
    Native中会转换为`backgroundColor`。
- en: For readability and reuse, it's beneficial to break off inline styling into
    its own `styles` object by defining all of our styles into a `styles` object using
    React Native's `StyleSheet` component to create a style object and reference it
    within our component's `render` method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性和重用，将内联样式拆分到自己的`styles`对象中是有益的，通过使用React Native的`StyleSheet`组件定义所有样式到`styles`对象中，并在组件的`render`方法中引用它。
- en: Taking it a step further, with larger applications, it's best to separate the
    style sheet into its own JavaScript file for readability's sake. Let's take a
    look at how each of these compare, using a very annotated version of the Hello
    World sample that's generated for us. These samples will contain only the code
    necessary to make my point.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 再进一步，对于大型应用，最好将样式表分离到自己的JavaScript文件中以提高可读性。让我们看看这些如何比较，使用为我们生成的非常注解的Hello World示例。这些示例将只包含使我的观点成立的必要代码。
- en: Inline styles
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联样式
- en: 'An inline style is one that is defined within the markup of your code. Check
    this sample out:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 内联样式是在你的代码标记内定义的样式。看看这个示例：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, you can see how inline style can create a very convoluted
    and confusing mess, especially when there are several style properties that we
    want to apply to each component. It's not practical for us to write our styles
    like this in a large-scale application, so let's break apart the styles into a
    `StyleSheet` object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到内联样式如何创建一个非常复杂和混乱的混乱，特别是当我们想要将多个样式属性应用到每个组件上时。在大型应用中，我们这样编写样式并不实用，所以让我们将样式拆分成一个`StyleSheet`对象。
- en: With StyleSheet, within the same file
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用样式表，在同一个文件中
- en: 'This is how a component accesses a `StyleSheet` created in the same file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是组件如何访问同一文件中创建的`StyleSheet`：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is much better. We're moving our styles into an object we can reference
    without having to rewrite the same inline styles over and over. However, the problem
    we face is an extraordinarily long file with a lot of application logic, where
    a future maintainer might have to scroll through lines and lines of code to get
    to the styles. We can take it one step further and separate the styles into their
    own module.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这样要好得多。我们将样式移动到一个对象中，这样我们就可以引用它，而无需反复重写相同的内联样式。然而，我们面临的问题是文件非常长，包含大量的应用逻辑，未来的维护者可能需要滚动查看一行又一行的代码才能找到样式。我们可以更进一步，将样式分离到它们自己的模块中。
- en: StyleSheet as an imported module
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为导入模块的样式表
- en: 'In your component, you can import your styles, as shown:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的组件中，你可以像下面这样导入你的样式：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, you can define them in a separate file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在一个单独的文件中定义它们：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is much better. By encapsulating our style logic into its own file, we
    are separating our concerns and making it easier for everyone to read it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这要好得多。通过将我们的样式逻辑封装到自己的文件中，我们正在分离我们的关注点，使每个人都能更容易地阅读它。
- en: Flexbox
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flexbox
- en: One thing you might have noted in our `StyleSheet` is a property called `flex`.
    This pertains to Flexbox, a CSS layout system that provides consistency in your
    layout across different screen sizes. Flexbox in React Native works similar to
    its CSS specification, with only a couple of differences. The most important differences
    to be noted are that the default `flex` direction has been flipped to `column`
    on React Native, as opposed to `row` on the Web, aligning items, by default, to
    the `stretch` property for React Native instead of `flex-start` in the browser,
    and the `flex` parameter only supports a single number as its value in React Native.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到了我们的 `StyleSheet` 中有一个名为 `flex` 的属性。这与 Flexbox 有关，Flexbox 是一种 CSS 布局系统，它可以在不同屏幕尺寸之间提供布局的一致性。React
    Native 中的 Flexbox 与其 CSS 规范类似，只有一些差异。需要注意的最重要差异是，在 React Native 中，默认的 `flex` 方向被反转到
    `column`，而在 Web 中是 `row`，默认将项目对齐到 `stretch` 属性，而不是浏览器中的 `flex-start`，React Native
    中的 `flex` 参数只支持单个数字作为其值。
- en: We will pick up a lot on Flexbox as we go through these projects; we'll start
    by taking a look at just the basics.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们通过这些项目，我们将深入了解 Flexbox；我们将从查看基础知识开始。
- en: flex
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: flex
- en: The `flex` property of your layout works a bit differently from how it operates
    in CSS. In React Native, it accepts a single digit number. If its number is a
    positive number (meaning greater than 0), the component that has this property
    will become flexible.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你的布局的 `flex` 属性在操作上与 CSS 中的操作略有不同。在 React Native 中，它接受一个单个数字。如果这个数字是正数（意味着大于
    0），具有此属性的组件将变得灵活。
- en: flexDirection
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: flexDirection
- en: 'Your layout also accepts a property called `flexDirection`. There are four
    options for this: `row`, `row-reverse`, `column`, and `column-reverse`. These
    options dictate the direction that the children of your flex container will be
    laid out in.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你的布局也接受一个名为 `flexDirection` 的属性。这个属性有四个选项：`row`、`row-reverse`、`column` 和 `column-reverse`。这些选项决定了你的
    flex 容器子项的布局方向。
- en: Writing in ES6
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ES6 编写
- en: '**ECMAScript version 6** (**ES6**) is the latest specification of the JavaScript
    language. It is also referred to as ES2016\. It brings new features and syntax
    to JavaScript, and they are the ones you should be familiar with to be successful
    in this book.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**ECMAScript 版本 6**（**ES6**）是 JavaScript 语言的最新规范。它也被称为 ES2016。它为 JavaScript
    带来了新的特性和语法，这些是你在本书中取得成功应该熟悉的内容。'
- en: 'Firstly, `require` statements are now `import` statements. They are used to
    `import` functions, object, and so on from an external module or script. In the
    past, to include React in a file, we would write something like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`require` 语句现在是 `import` 语句。它们用于从外部模块或脚本中导入函数、对象等。在过去，为了在文件中包含 React，我们会写类似这样的内容：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using ES6 `import` statements, we can rewrite it to this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ES6 的 `import` 语句，我们可以将其重写为：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The importing of `Component` around a curly brace is called destructuring assignment.
    It's an assignment syntax that lets us extract specific data from an array or
    object into a variable. With `Component` imported through destructuring assignment,
    we can simply call `Component` in our code; it's automatically declared as a variable
    with the exact same name.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在花括号周围导入 `Component` 的操作称为解构赋值。这是一种赋值语法，允许我们从数组或对象中提取特定数据到变量中。通过解构赋值导入 `Component`，我们可以在代码中直接调用
    `Component`；它自动声明为具有相同名称的变量。
- en: 'Next up, we''re replacing `var` with two different statements: `let` and `const`.
    The first statement, `let`, declares a block-scoped variable whose value can be
    mutated. The second statement, `const`, declares another block-scoped variable
    whose value cannot change through reassignment nor redeclaration.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将用两个不同的语句替换 `var`：`let` 和 `const`。第一个语句 `let` 声明了一个块级作用域变量，其值可以被修改。第二个语句
    `const` 声明了一个块级作用域变量，其值不能通过重新赋值或重新声明来改变。
- en: In the prior syntax, exporting modules used to be done using `module.exports`.
    In ES6, this is done using the `export default` statement.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的语法中，导出模块通常使用 `module.exports` 完成。在 ES6 中，这通过 `export default` 语句来实现。
- en: Building the app
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建应用
- en: 'Going back to our list from a few pages back, this is the first thing I''d
    like to do with the app:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 回到几页前的列表，这是我想在应用中做的第一件事：
- en: Let's generate a list of default items. These don't have to be manually entered;
    we just want to see our list populated in the app itself.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们生成一个默认项的列表。这些项不必手动输入；我们只想看到我们的列表在应用本身中被填充。
- en: ListView
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ListView
- en: While looking at the documentation for React Native's components, you may note
    a component named `ListView`. This is a core component that is meant to display
    vertically scrolling lists of data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看React Native组件的文档时，你可能会注意到一个名为`ListView`的组件。这是一个旨在显示垂直滚动数据列表的核心组件。
- en: Here's how `ListView` works. We will create a data source, fill it up with an
    array of data blobs, create a `ListView` component with that array as its data
    source, and pass it some JSX in its `renderRow` callback, which will take the
    data and render a row for each blob within the data source.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何`ListView`工作的。我们将创建一个数据源，用数据块数组填充它，创建一个以该数组作为数据源的`ListView`组件，并在其`renderRow`回调中传递一些JSX，该回调将获取数据并为数据源中的每个数据块渲染一行。
- en: 'On a high level, here is how it looks:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，它看起来是这样的：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s look at what''s going on. In the `constructor` of our component, we
    create an instance of `ListViewDataSource`. The constructor for a new `ListViewDataSource`
    accepts, as a parameter, an argument that can contain any of these four:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看发生了什么。在我们组件的`constructor`中，我们创建了一个`ListViewDataSource`的实例。一个新的`ListViewDataSource`的构造函数接受一个参数，该参数可以包含以下四个之一：
- en: '`getRowData(dataBlob`, `sectionID`, `rowID)`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRowData(dataBlob`, `sectionID`, `rowID)`'
- en: '`getSectionHeaderData(dataBlob`, `sectionID)`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSectionHeaderData(dataBlob`, `sectionID)`'
- en: '`rowHasChanged(previousRowData`, `nextRowData)`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rowHasChanged(previousRowData`, `nextRowData)`'
- en: '`sectionHeaderHasChanged(previousSectionData`, `nextSectionData)`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sectionHeaderHasChanged(previousSectionData`, `nextSectionData)`'
- en: The `getRowData` is a function that gets the data required to render the row.
    You can customize the function however you like as you pass it in to the constructor
    of `ListViewDataSource`, but `ListViewDataSource` will provide a default if you
    don't specify.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRowData`是一个获取渲染行所需数据的函数。你可以按自己的喜好自定义该函数，并将其传递给`ListViewDataSource`的构造函数，但如果未指定，`ListViewDataSource`将提供默认值。'
- en: The `getSectionHeaderData` is a function that accepts a blob of data and a section
    ID and returns just the data needed to render a section header. Like `getRowData`,
    it provides a default if not specified.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSectionHeaderData`是一个函数，它接受一个数据块和一个部分ID，并返回仅用于渲染部分标题所需的数据。像`getRowData`一样，如果没有指定，它将提供默认值。'
- en: The `rowHasChanged` is a function that serves as a performance optimization
    designed to only re-render any rows that have their source data changed. Unlike
    `getRowData` and `getSectionHeaderData`, you will need to pass your own version
    of `rowHasChanged`. The preceding example, which takes in the current and previous
    values of the row and returns a Boolean to show if it has changed, is the most
    common implementation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`rowHasChanged`是一个函数，它作为性能优化设计，仅重新渲染其源数据已更改的任何行。与`getRowData`和`getSectionHeaderData`不同，你需要传递自己的`rowHasChanged`版本。先前的示例，它接受当前和之前的行值并返回一个布尔值以显示它是否已更改，是最常见的实现。'
- en: The `sectionHeaderHasChanged` is an optional function that compares the section
    headers' contents to determine whether they need to be re-rendered.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`sectionHeaderHasChanged`是一个可选函数，它比较部分标题的内容以确定它们是否需要重新渲染。'
- en: 'Then, in our `TasksView` constructor, our state receives a property of `dataSource`
    whose value is equal to calling `cloneWithRows` on the `ListViewDataSource` instance
    we created earlier. `cloneWithRows` takes in two parameters: a `dataBlob` and
    `rowIdentities`. The `dataBlob` is any arbitrary blob of data passed to it, and
    `rowIdentities` represents a two-dimensional array of row identifiers. The `rowIdentities`
    is an optional parameter--it isn''t included in the preceding sample code. Our
    sample code passes a hardcoded blob of data--two strings: `''row 1''` and `''row
    2''`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`TasksView`构造函数中，我们的状态接收一个名为`dataSource`的属性，其值等于调用我们之前创建的`ListViewDataSource`实例上的`cloneWithRows`。`cloneWithRows`接受两个参数：一个`dataBlob`和一个`rowIdentities`。`dataBlob`是传递给它的任何任意数据块，而`rowIdentities`代表行标识符的二维数组。`rowIdentities`是一个可选参数——它不包括在先前的示例代码中。我们的示例代码传递了一个硬编码的数据块——两个字符串：`'row
    1'`和`'row 2'`。
- en: It's also important to mention right now that the data within our `dataSource`
    is immutable. If we want to change it later, we'll have to extract the information
    out of the `dataSource`, mutate it, and then replace the data within the `dataSource`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在也很重要地提到，我们`dataSource`中的数据是不可变的。如果我们想稍后更改它，我们必须从`dataSource`中提取信息，对其进行修改，然后替换`dataSource`中的数据。
- en: The `ListView` component itself, which is rendered in our `TasksList`, can accept
    a number of different properties. The most important one, which we're using in
    our example, is `renderRow`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TasksList` 中渲染的 `ListView` 组件本身可以接受许多不同的属性。其中最重要的一个，我们在我们的示例中使用，是 `renderRow`。
- en: The `renderRow` function takes data from the `dataSource` of your `ListView`
    and returns a component to render for each row of data in your `dataSource`. In
    our preceding example, `renderRow` takes each string inside our `dataSource` and
    renders it in a `Text` component.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderRow` 函数从你的 `ListView` 的 `dataSource` 中获取数据，并为你的 `dataSource` 中的每一行数据返回一个要渲染的组件。在我们的前一个例子中，`renderRow`
    从我们的 `dataSource` 中的每个字符串中获取数据，并在 `Text` 组件中渲染它。'
- en: 'With the preceding code, here is how `TasksList` will render. Because we have
    not yet styled it, you will see that the iOS Status Bar overlaps the first row:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，以下是 `TasksList` 将如何渲染。因为我们还没有给它添加样式，所以你会看到 iOS 状态栏覆盖了第一行：
- en: '![](img/image_01_001-1.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_01_001-1.png)'
- en: 'Great! There''s not much to see, but we accomplished something: we created
    a `ListView` component, passed it some data, and got that data to be rendered
    on our screen. Let''s take a step back and create this component in our application
    properly.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！没有太多可以看的，但我们已经完成了一些事情：我们创建了一个 `ListView` 组件，传递了一些数据，并将这些数据渲染到了我们的屏幕上。让我们退后一步，在我们的应用程序中正确地创建这个组件。
- en: Creating the TasksList component
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 TasksList 组件
- en: 'Going back to the proposed file structure from earlier, your project should
    look like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 回到之前提出的文件结构，你的项目应该看起来像这样：
- en: '![](img/Screen-Shot-2017-01-03-at-11.03.09-PM.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Screen-Shot-2017-01-03-at-11.03.09-PM.png)'
- en: Let's start by writing our first component--the `TasksList` module.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写我们的第一个组件——`TasksList` 模块开始。
- en: 'The first thing we will need to do is import our dependency on React:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是导入我们对 React 的依赖：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we''ll import just the building blocks we need from the React Native
    (`react-native`) library:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将从 React Native (`react-native`) 库中导入我们需要的构建块：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s write the component. The syntax for creating a new component in
    ES6 is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写组件。在 ES6 中创建新组件的语法如下：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From here, let''s give it a constructor function to fire during its creation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，让我们给它一个在创建时触发的构造函数：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our constructor sets up a `dataSource` property in the `TasksList` state as
    equal to an array of hardcoded strings. Again, our first goal is to simply render
    a list on the screen.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构造函数在 `TasksList` 的状态中设置一个 `dataSource` 属性，等于一个硬编码的字符串数组。我们的首要目标仍然是简单地在一个屏幕上渲染一个列表。
- en: 'Next up, we''ll utilize the `render` method of the `TasksList` component to
    do just that:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将利用 `TasksList` 组件的 `render` 方法来完成这个任务：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Consolidated, the code should look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 合并起来，代码应该看起来像这样：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Great! That should do it. However, we need to link this component over to our
    application's entry point. Let's hop over to `index.ios.js` and make some changes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！这应该就足够了。然而，我们需要将这个组件链接到我们应用程序的入口点。让我们跳转到 `index.ios.js` 并做一些更改。
- en: Linking TasksList to index
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 TasksList 链接到 index
- en: Our iOS app's entry point is `index.ios.js` and everything that it renders starts
    from here. Right now, if you launch iOS Simulator using the `react-native run-ios`
    command, you will see the same Hello World sample application that we were acquainted
    with in the preface.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 iOS 应用程序的入口点是 `index.ios.js`，它渲染的所有内容都从这里开始。现在，如果你使用 `react-native run-ios`
    命令启动 iOS 模拟器，你将看到我们在前言中熟悉的相同的 Hello World 示例应用程序。
- en: 'What we need to do right now is link the `TasksList` component we just built
    to the `index` and remove all the unnecessary JSX automatically generated for
    us. Let''s go ahead and clear nearly everything in the `render` method of our
    `Tasks` component, except the top layer `View` container. When you''re done, it
    should look like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要做的是将我们刚刚构建的 `TasksList` 组件链接到 `index`，并自动移除所有不必要的 JSX。让我们继续清除 `Tasks`
    组件的 `render` 方法中的几乎所有内容，除了顶层的 `View` 容器。当你完成时，它应该看起来像这样：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We''ll want to insert `TasksList` within that `View` container. However, before
    we do that, we have to give the `index` file access to that component. Let''s
    do so using an `import` statement:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在 `View` 容器中插入 `TasksList`。然而，在我们这样做之前，我们必须让 `index` 文件能够访问该组件。让我们使用一个 `import`
    语句来完成：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While this `import` statement just points to the folder that our `TasksList`
    component is in, React Native intelligently looks for a file named `index` and
    assigns it what we want.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个 `import` 语句只是指向我们的 `TasksList` 组件所在的文件夹，但 React Native 智能地寻找一个名为 `index`
    的文件，并将其分配给我们想要的。
- en: 'Now that `TasksList` is readily available for us to use, let''s include it
    in the `render` method for `Tasks`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`TasksList`已经可以供我们使用了，让我们将其包含在`Tasks`的`render`方法中：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you don''t have an iOS Simulator running anymore, let''s get it back up
    and running using the `react-native run-ios` command from before. Once things
    are loaded, this is what you should see:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不再运行iOS模拟器，让我们使用之前提到的`react-native run-ios`命令将其重新启动并运行。一旦加载完成，你应该看到以下内容：
- en: '![](img/image_01_003-1.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_01_003-1.png)'
- en: This is awesome! Once it's loaded, let's open up the iOS Simulator Developer
    menu by pressing *Command* + *D* on your keyboard and search for an option that
    will help us save some time during the creation of our app.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！一旦加载完成，让我们通过按键盘上的*Command* + *D*来打开iOS模拟器开发者菜单，并搜索一个可以帮助我们在创建应用程序时节省时间的选项。
- en: 'At the end of this section, your `index.ios.js` file should look like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的结尾，你的`index.ios.js`文件应该看起来像这样：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following code renders the `TasksList` component:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码渲染了`TasksList`组件：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The iOS Simulator Developer menu
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS模拟器开发者菜单
- en: 'When you open the Developer menu, you''ll see the following options:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开开发者菜单时，你会看到以下选项：
- en: '![](img/image_01_004-1.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_01_004-1.png)'
- en: I would like to go through some of the options available in this menu, which
    will help you make the development of your applications a lot smoother. Some of
    the options are not covered here, but are available for you to read about in the
    React Native documentation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要介绍一下这个菜单中的一些选项，这将帮助你使应用程序的开发过程更加顺畅。一些选项在这里没有涵盖，但你可以在React Native文档中阅读有关这些选项的内容。
- en: 'First, we will cover the options for reloading:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍重载的选项：
- en: 'Reload: This reloads your application code. Similar to using *Command* + *R*
    on the keyboard, the Reload option takes you to the beginning of your application
    flow.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载：这个选项会重新加载你的应用程序代码。类似于在键盘上使用*Command* + *R*，重载选项会将你带到应用程序流程的开始。
- en: 'Enable Live Reload: Turning Live Reload on will result in your application
    automatically performing a reload action whenever your code has changed while
    you save a file in your project. Live Reload is great because you can enable it
    once and have your app show you its latest changes whenever you save your file.
    It''s important to know that both Reload and Enable Live Reload perform a *full*
    reload of your application, including resetting your application state.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用实时重载：开启实时重载会导致你的应用程序在你在项目中保存文件时自动执行重载操作。实时重载很棒，因为你一旦启用它，每次你保存文件时，你的应用程序都会显示其最新的更改。重要的是要知道，重载和启用实时重载都会执行一个*完整*的重载操作，包括重置你的应用程序状态。
- en: 'Enable Hot Reloading: Hot Reloading is a new feature introduced in React Native
    in March 2016\. If you''ve worked with React on the Web, this term might be familiar
    to you. The idea of a Hot Reload is to keep your app running and to inject new
    code at runtime, which prevents you from losing your application state like with
    a Reload (or, by extension, Enable Live Reload).'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用热重载：热重载是React Native在2016年3月引入的一个新功能。如果你在Web上使用过React，这个术语可能对你来说很熟悉。热重载的想法是保持你的应用程序运行，并在运行时注入新代码，这样可以防止你像重载（或扩展到启用实时重载）那样丢失应用程序状态。
- en: One of the bottlenecks of building a feature with Live Reload turned on is when
    you work on a feature several layers deep and rely on your application's state
    to properly note changes to it. This adds several seconds to the feedback loop
    of writing and reloading your application. A Hot Reload solves this issue, letting
    your feedback loop be reduced to less than a second or two.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开启实时重载的情况下构建功能的一个瓶颈是，当你处理一个多层深度的功能并且依赖于你的应用程序状态来正确地记录对其的更改时。这会给你的应用程序编写和重载的反馈循环增加几秒钟。热重载可以解决这个问题，让你的反馈循环减少到一秒或两秒以下。
- en: Something to be aware of with Hot Reloading is that, in its current iteration,
    it's not perfect. The React Native documentation notes that, in some instances,
    you will need to use a regular Reload to reset your app when Hot Reloading fails.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在热重载方面需要注意的一点是，在其当前版本中，它并不完美。React Native文档指出，在某些情况下，你需要使用常规的重载来重置你的应用程序，因为热重载失败了。
- en: It's equally important to know that if you ever add new assets to your application
    or modify native Objective-C/Swift or Java/C++ code, your application will need
    to be fully rebuilt before the changes will take effect.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是要知道，如果你在应用程序中添加新的资产或修改原生Objective-C/Swift或Java/C++代码，你的应用程序在更改生效之前需要完全重新构建。
- en: 'The next set of options have to do with debugging:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一组选项与调试有关：
- en: 'Debug JS Remotely: Enabling this will open up Chrome on your machine and take
    you to a Chrome tab that will allow you to use Chrome Developer Tools to debug
    your application.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程调试 JS：启用此功能将在您的机器上打开 Chrome，并带您到一个 Chrome 标签页，允许您使用 Chrome 开发者工具来调试您的应用程序。
- en: 'Show Inspector: Similar to inspecting an element on the Web, you can use the
    Inspector in React Native development to inspect any element of your application
    and have it open up parts of your code and the source code that affect that element.
    You can also view the performance of each specific element this way.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示检查器：类似于在 Web 上检查元素，您可以使用 React Native 开发中的检查器来检查您的应用程序中的任何元素，并打开影响该元素的部分代码和源代码。您还可以通过这种方式查看每个特定元素的性能。
- en: Using the Developer menu, we will enable Hot Reloading. It will give us the
    quickest feedback loop on the code we're writing, allowing us to move efficiently.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用开发者菜单，我们将启用热重载。这将给我们提供关于我们正在编写的代码的最快反馈循环，使我们能够高效地工作。
- en: Now that we've got Hot Reloading enabled and a basic list of tasks rendering
    to the screen, it's time to think about an input--we'll come back to styling later.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启用了热重载并有一个基本的任务列表渲染到屏幕上，是时候考虑输入了--我们稍后再回来讨论样式。
- en: TextInput
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`TextInput`'
- en: 'The second goal for building out an MVP was as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 构建最小可行产品（MVP）的第二个目标如下：
- en: Our users should be able to input their own tasks using a text field and the
    native keyboard
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的用户应该能够使用文本字段和原生键盘输入他们自己的任务
- en: 'To successfully create this input, we have to break down the problem into some
    necessary requirements:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功创建这个输入，我们必须将问题分解为一些必要的要求：
- en: We need to have an input field that will spring up our keyboard to type with
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个输入字段，以便弹出键盘进行输入
- en: The keyboard should hide itself when we tap outside of it
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们点击键盘外部时，键盘应该自动隐藏
- en: When we successfully add a task, it needs to be added to `dataSource` in `TasksList`,
    which is stored in its state
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们成功添加一个任务时，它需要添加到 `TasksList` 中的 `dataSource`，它存储在其状态中
- en: The list of tasks needs to be stored locally in the application so that a state
    reset doesn't delete the entire list of tasks we've created
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要将任务列表存储在应用程序的本地，这样在状态重置时不会删除我们创建的所有任务列表
- en: 'There''re also a couple of forks in the road we should address:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还应该解决几条道路上的分歧：
- en: What happens when the user hits return on the keyboard? Does that automatically
    create a task? Alternatively, do we implement and support a line break?
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户在键盘上按回车键时会发生什么？它会自动创建一个任务吗？或者，我们实现并支持换行？
- en: Is there a dedicated *Add this task* button?
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有一个专门的 *添加此任务* 按钮？
- en: Does the successful act of adding a task cause the keyboard to go away, requiring
    the user to tap on the input field again? Alternatively, do we allow the user
    to keep adding tasks until they tap outside the keyboard?
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功添加任务的动作会导致键盘消失，需要用户再次点击输入字段吗？或者，我们允许用户在点击键盘外部之前继续添加任务？
- en: How many characters do we support? How long is too long for a task? What kind
    of feedback is presented to the user of our software if they exceed that limit?
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们支持多少个字符？任务的长度有多长才算太长？如果用户超过这个限制，我们的软件用户将得到什么样的反馈？
- en: This is a lot to take in, so let's take it one step at a time! I will propose
    that we ignore the big decisions for now and have the simple act of having an
    input on the screen, and then having that input be added to our list of tasks.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要吸收很多信息，所以让我们一步一步来！我将建议我们现在忽略重大决策，先实现屏幕上的输入，然后让这个输入添加到我们的任务列表中。
- en: Since input should be saved to state and then rendered in the `ListView`, it
    makes sense for the input component to be a sibling of the `ListView`, allowing
    them to share the same state.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输入应该保存到状态并在 `ListView` 中渲染，因此输入组件作为 `ListView` 的兄弟组件是有意义的，这样它们就可以共享相同的状态。
- en: 'Architecturally, this is how the `TasksList` component will look:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构上讲，`TasksList` 组件将看起来是这样的：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: React Native has a `TextInput` component in its API that fulfills our need for
    a keyboard input. Its code is customizable and will allow us to take input and
    add it to our list of tasks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 的 API 中有一个 `TextInput` 组件，它满足了我们对键盘输入的需求。其代码是可定制的，并允许我们将输入添加到我们的任务列表中。
- en: 'This `TextInput` component can accept a multitude of props. I have listed the
    ones we will use here, but the documentation for React Native will provide much
    more depth:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `TextInput` 组件可以接受多种属性。我在这里列出了我们将使用的属性，但 React Native 的文档将提供更多深度：
- en: '`autoCorrect`: This is a Boolean that turns autocorrection on and off. It is
    set to `true` by default'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoCorrect`: 这是一个布尔值，用于开启和关闭自动更正。默认设置为`true`'
- en: '`onChangeText`: This is a callback that is fired when the input field''s text
    changes. The value of the component is passed as an argument to the callback'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onChangeText`: 这是一个回调，当输入字段的文本发生变化时触发。组件的值作为参数传递给回调'
- en: '`onSubmitEditing`: This is a callback that is fired when a single-line input''s
    submit button is pressed'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSubmitEditing`: 这是一个回调，当单行输入的提交按钮被按下时触发'
- en: '`returnKeyType`: This sets the title of the return key to one of many different
    strings; `done`, `go`, `next`, `search`, and `send` are the five that work across
    both the platforms'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`returnKeyType`: 这设置返回键的标题为许多不同的字符串之一；`done`、`go`、`next`、`search`和`send`是两个平台都支持的五个选项'
- en: 'We can break down the task at hand into a couple of bite-sized steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将当前任务分解为几个小步骤：
- en: Update container styling in `index.ios.js` so that its contents take up the
    entire screen and not just the center
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`index.ios.js`中更新容器样式，使其内容占据整个屏幕而不是只是中央
- en: Add a `TextInput` component to our `TasksList` component's `render` method
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个`TextInput`组件添加到`TasksList`组件的`render`方法中
- en: Create a submit handler for the `TextInput` component that will take the value
    of the text field and add it to `ListView`
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`TextInput`组件创建一个提交处理程序，该处理程序将文本字段的值添加到`ListView`
- en: Clear the contents of the `TextInput` once submitted, leaving a blank field
    for the next task to be added
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交后清除`TextInput`的内容，为下一个要添加的任务留下一个空白字段
- en: Take some time to try and add this first feature into our app! In the next section,
    I will share some screenshots of my results and break down the code I wrote for
    it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 抽点时间尝试将这个第一个功能添加到我们的应用中！在下一节中，我将分享一些我的结果截图，并分解我为它编写的代码。
- en: 'Here''s a screen to show how my input looks at this stage:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个屏幕来展示我这一阶段的输入：
- en: '![](img/image_01_005-1.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_01_005-1.png)'
- en: 'It meets the four basic requirements listed in the preceding section: the contents
    aren''t centered on the screen, a `TextInput` component is rendered at the top,
    the submit handler takes the value of the `TextInput` component and adds it to
    the `ListView`, and the contents of the `TextInput` are emptied once that happens.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 它符合前面章节中列出的四个基本要求：内容不在屏幕中央，顶部渲染了一个`TextInput`组件，提交处理程序将`TextInput`组件的值添加到`ListView`，并且一旦发生，`TextInput`的内容就会被清空。
- en: 'Let''s look at the code to see how I tackled it--yours may be different!:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码，看看我是如何处理的——你的可能不同！：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is the updated styling for `TasksList`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`TasksList`的更新样式：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What I did here was remove the `justifyContent` and `alignItems` properties
    of the container so that items weren't constrained to just the center of the display.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里所做的就是移除了容器的`justifyContent`和`alignItems`属性，这样项目就不会仅限于显示的中央。
- en: 'Moving on to the `TasksList` component, I made a couple of major changes:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`TasksList`组件，我进行了一些重大更改：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The constructor now saves three things to state: our local instance of `ListView.DataSource`,
    an empty string to keep track of the value of `TextInput`, and an array to store
    the list of tasks.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数现在将三件事保存到状态中：我们的本地`ListView.DataSource`实例、一个空字符串以跟踪`TextInput`的值，以及一个用于存储任务列表的数组。
- en: 'The `render` function creates a reference to a `dataSource` that we will use
    for our `ListView` component, cloning the `listOfTasks` array stored in state.
    Once again, the `ListView` just presents plain text:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`函数创建了一个`dataSource`的引用，我们将使用它来为`ListView`组件，克隆状态中存储的`listOfTasks`数组。再次强调，`ListView`只呈现纯文本：'
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `TextInput` component has a couple of options. It binds the `value` of
    its input field to the `text` value of our state, changing it repeatedly as the
    field is edited. On submitting it by pressing the *done* key on the keyboard,
    it fires a callback called `_addTask`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextInput`组件有几个选项。它将其输入字段的`value`绑定到我们的状态中的`text`值，随着字段的编辑而重复更改。通过在键盘上按下*完成*键提交它时，它触发一个名为`_addTask`的回调：'
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It renders a `ListView` component with the `_renderRowData` method being responsible
    for returning each individual row of the component:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 它渲染一个`ListView`组件，其中`_renderRowData`方法负责返回组件的每一行：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I like to start the name of methods that I personally create in a React component
    with an underscore so that I can visually distinguish them from the default life
    cycle methods.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在我自己创建的React组件的方法名前加上下划线，这样我就可以从默认的生命周期方法中视觉上区分它们。
- en: 'The `_addTask` method uses the array spread operator introduced in ES6 to create
    a new array and copy over an existing array''s values, adding the newest task
    to the list at the end. Then, we assign it to the `listOfTasks` property in state.
    Remember that we have to treat our component state as an immutable object and
    simply pushing to it will be an anti-pattern:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`_addTask` 方法使用 ES6 中引入的数组扩展运算符来创建一个新的数组，并将现有数组的值复制过来，将最新的任务添加到列表的末尾。然后，我们将它分配给状态中的
    `listOfTasks` 属性。记住，我们必须将组件状态视为不可变对象，直接向其推送将是一个反模式：'
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we call `_changeTextInputValue` so that the `TextInput` box is emptied:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `_changeTextInputValue` 以清空 `TextInput` 框：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For now, just returning the name of the to-do list item is fine.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只返回待办事项列表项的名称就足够了。
- en: 'When setting the `listOfTasks` property in the `_addTask` method and the `text`
    property in `_changeTextInputValue`, I''m using a new notation feature of ES6,
    called shorthand property names, to assign a value to a key with the same name
    as the value. This is the same as if I were to write as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_addTask` 方法中设置 `listOfTasks` 属性和在 `_changeTextInputValue` 中设置 `text` 属性时，我正在使用
    ES6 的新特性，称为简写属性名，将值分配给与值同名的键。这相当于我写下以下内容：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Moving on, you might note that, as you refresh the application, you lose your
    state! This is impractical for a to-do list app, since we should never expect
    the user to re-enter the same list whenever they re-open the app. What we want
    is to store this list of tasks locally in the device so that we can access it
    whenever needed. This is where `AsyncStorage` comes into play.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，你可能注意到，当你刷新应用程序时，你会丢失你的状态！这对于待办事项列表应用来说是不切实际的，因为我们不应该期望用户在重新打开应用时重新输入相同的列表。我们想要的是将此任务列表本地存储在设备上，以便我们可以在需要时访问它。这就是
    `AsyncStorage` 发挥作用的地方。
- en: AsyncStorage
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`AsyncStorage`'
- en: The `AsyncStorage` component is a simple key-value store that is globally available
    to your React Native application. It's persistent, meaning that data within `AsyncStorage`
    will continue to exist through quitting or restarting the application or your
    phone. If you've worked with HTML `LocalStorage` and `SessionStorage`, `AsyncStorage`
    will seem familiar. It's powerful for light usage, but Facebook recommends that
    you use an abstraction layer on top of `AsyncStorage` for anything more than that.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncStorage` 组件是一个简单的键值存储，它对您的 React Native 应用程序全局可用。它是持久的，这意味着 `AsyncStorage`
    中的数据将在退出或重新启动应用程序或手机时继续存在。如果你已经使用过 HTML 的 `LocalStorage` 和 `SessionStorage`，那么
    `AsyncStorage` 将看起来很熟悉。它适用于轻量级使用，但 Facebook 建议你在 `AsyncStorage` 之上使用抽象层，以处理更复杂的情况。'
- en: As the name implies, `AsyncStorage` is asynchronous. If you haven't yet been
    introduced to asynchronous JavaScript, this means the methods of this storage
    system can run concurrently with the rest of your code. The methods of `AsyncStorage`
    return a `Promise`--an object that represents an operation that hasn't yet completed,
    but is expected to in the future.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`AsyncStorage` 是异步的。如果你还没有接触过异步 JavaScript，这意味着这个存储系统的方法可以与你的其他代码并发运行。`AsyncStorage`
    的方法返回一个 `Promise`——一个表示尚未完成但预期将来会完成的操作的对象。
- en: Each of the methods in `AsyncStorage` can accept a callback function as an argument,
    and will fire that callback once the `Promise` is fulfilled. This means that we
    can write our `TasksList` component to work around these promises, saving and
    retrieving our array of tasks when needed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncStorage` 中的每个方法都可以接受一个回调函数作为参数，并在 `Promise` 履行后触发该回调。这意味着我们可以编写我们的 `TasksList`
    组件来处理这些承诺，在需要时保存和检索我们的任务数组。'
- en: One final thing about `AsyncStorage` though--it's a simple key-value store.
    It expects a string for both its key and value, which means that we'll need to
    transform the data we send using `JSON.stringify` to turn the array into a string
    when sending it into storage and `JSON.parse` to transform it back into an array
    when retrieving it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `AsyncStorage` 的最后一件事——它是一个简单的键值存储。它期望其键和值都是字符串，这意味着我们需要使用 `JSON.stringify`
    将发送到存储的数据转换为字符串，并在检索时使用 `JSON.parse` 将其转换回数组。
- en: 'Play with `AsyncStorage` and update your `TasksList` component to support it.
    Here are some goals you''ll want to have with `AsyncStorage`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 玩转 `AsyncStorage` 并更新你的 `TasksList` 组件以支持它。以下是你希望使用 `AsyncStorage` 达成的目标：
- en: Once `TasksList` is loaded, we want to see whether any tasks exist locally in
    storage. If they do, present this list to the user. If they don't, start off with
    an empty array for storage. Data should always persist through a restart.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦 `TasksList` 加载，我们希望查看是否在本地存储中存在任何任务。如果存在，向用户展示这个列表。如果不存在，从空数组开始存储。数据应该始终在重启后持久化。
- en: When a task is entered, we should update the list of tasks, save the updated
    list into `AsyncStorage`, and then update the `ListView` component.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当输入任务时，我们应该更新任务列表，将更新后的列表保存到 `AsyncStorage` 中，然后更新 `ListView` 组件。
- en: 'Here''s the code I ended up writing:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终写出的代码：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Import the `AsyncStorage` API from the React Native SDK.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 从 React Native SDK 中导入 `AsyncStorage` API。
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Call the `_updateList` method during the `componentDidMount` life cycle.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `componentDidMount` 生命周期中调用 `_updateList` 方法。
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Update `_addTask` to use the `async` and `await` keywords as well as `AsyncStorage`.
    Refer to the following for details on using `async` and `await`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `_addTask` 更新为使用 `async` 和 `await` 关键字以及 `AsyncStorage`。有关使用 `async` 和 `await`
    的详细信息，请参阅以下内容：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: What we are doing with `AsyncStorage` in `_updateTask` is grabbing the value
    locally stored using the `listOfTasks` key. From here, we parse the result, transforming
    the string back into an array. Then, we check to see whether the array exists
    and set it to an empty array if it returns `null`. Finally, we set the state of
    our component by updating `listOfTasks` and firing `_changeTextInputValue` to
    reset `TextInput` value.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_updateTask` 中，我们使用 `AsyncStorage` 做的是获取使用 `listOfTasks` 键本地存储的值。从这里，我们解析结果，将字符串转换回数组。然后，我们检查数组是否存在，如果返回
    `null`，则将其设置为空数组。最后，我们通过更新 `listOfTasks` 并触发 `_changeTextInputValue` 来重置 `TextInput`
    值来设置我们组件的状态。
- en: The preceding example also uses the new `async` and `await` keywords that are
    part of the ES7 specification proposal and readily available to use with React
    Native.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例还使用了 ES7 规范提案中的一部分新 `async` 和 `await` 关键字，并且可以与 React Native 一起使用。
- en: Using the Async and Await keywords
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Async 和 Await 关键字
- en: 'Normally, to deal with an asynchronous function, we would chain some promises
    to it in order to grab our data. We can write `_updateList`, like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了处理异步函数，我们会将其与一些承诺链式调用，以便获取我们的数据。我们可以这样写 `_updateList`：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, this can become quite complicated. Instead, we will use the `async`
    and `await` keywords to create a simpler solution:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能会变得相当复杂。相反，我们将使用 `async` 和 `await` 关键字来创建一个更简单的解决方案：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `async` keyword in front of `_updateList` declares it as an asynchronous
    function. It automatically returns promises for us and can take advantage of the
    `await` keyword to tell the JS interpreter to temporarily exit the asynchronous
    function and resume running when the asynchronous call is completed. This is great
    for us because we can express our intent in a sequential order in a single function
    and still receive the exact same results that we would enjoy with a promise.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`_updateList` 前面的 `async` 关键字将其声明为异步函数。它自动为我们返回承诺，并可以利用 `await` 关键字告诉 JS 解释器暂时退出异步函数，并在异步调用完成后恢复运行。这对我们来说很棒，因为我们可以在单个函数中以顺序表达我们的意图，并且仍然获得与承诺相同的精确结果。'
- en: Custom RenderRow component
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义 RenderRow 组件
- en: The final thing on our list to have a usable minimum viable product is to allow
    each task to be marked as complete. This is where we'll create the `TasksListCell`
    component and render that in our `renderRow` function of `ListView` instead of
    just the text.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的最后一项，即要有一个可用的最小可行产品，是允许每个任务被标记为完成。这就是我们将创建 `TasksListCell` 组件并在 `ListView`
    的 `renderRow` 函数中渲染该组件，而不是仅仅显示文本的地方。
- en: 'Our goals for this component should be as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这个组件的目标应该是以下内容：
- en: Accept text from the parent component as a prop, rendering it in `TasksListCell`
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从父组件接受文本作为 prop，并在 `TasksListCell` 中渲染它
- en: Update `listOfTasks` to take in an array of objects rather than an array of
    strings, allowing each object to track the name of the task and whether or not
    it's completed
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `listOfTasks` 更新为接受对象数组而不是字符串数组，允许每个对象跟踪任务的名称以及它是否已完成
- en: Provide some sort of visual indicator when a task is tapped, marking it as complete
    both visually and within the task's `data` object, so this persists through application
    reloads
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任务被点击时，提供某种视觉指示器，将任务标记为完成，不仅在视觉上，而且在任务的 `data` 对象中，这样在应用程序重新加载时也能持久化。
- en: Custom RenderRow example
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义 RenderRow 示例
- en: 'Let''s look at how I created this component:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我是如何创建这个组件的：
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Firstly, tasks are now represented as objects within the array. This allows
    us to add properties to each task, such as its completed state, and leaves room
    for future additions.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，任务现在在数组中以对象的形式表示。这允许我们为每个任务添加属性，例如其完成状态，并为未来的添加留出空间。
- en: '[PRE39]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `_renderRowData` method is also updated to render a new `TasksListCell`
    component. Four `props` are shared to `TasksListCell`: the task''s completed state,
    its row identifier (provided by `renderRow`), a callback to alter the task''s
    completed state, and the details of that task itself.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`_renderRowData` 方法也被更新，以渲染新的 `TasksListCell` 组件。四个 `props` 被共享到 `TasksListCell`：任务的完成状态、其行标识符（由
    `renderRow` 提供）、一个用于更改任务完成状态的回调函数，以及该任务本身的详细信息。'
- en: 'Here''s how that `TasksListCell` component was written:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `TasksListCell` 组件的编写方式：
- en: '[PRE40]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Use `PropTypes` to explicitly declare the data this component expects to be
    given. Read on for an explanation on prop validation in React.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `PropTypes` 明确声明组件期望接收的数据。 继续阅读以了解 React 中 prop 验证的解释。
- en: '[PRE41]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Use a ternary operator to calculate styling for a task if it is completed.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三元运算符来计算任务完成时的样式。
- en: '[PRE42]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding component provides a `TouchableHighlight` for each task on the
    list, giving us visual opacity feedback when an item is tapped on. It also fires
    the `_completeTask` method of `TasksListCell`, which subsequently calls the `onPress`
    prop that was passed to it and makes a visual change to the style of the cell,
    marking it *completed* with a *line through* the horizontal center of the task.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的组件为列表中的每个任务提供了一个 `TouchableHighlight`，当点击项目时，给我们视觉上的不透明度反馈。它还会触发 `TasksListCell`
    的 `_completeTask` 方法，随后调用传递给它的 `onPress` prop，并对单元格的样式进行视觉更改，通过在任务的水平中心画一条线来标记它为*完成*。
- en: Prop validation in React
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 中的 prop 验证
- en: By declaring a propTypes object for a component, I can specify the expected
    props and their types for a given component. This is helpful for future maintainers
    of our code and provides helpful warnings when props are incorrectly entered or
    missing.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为组件声明一个 `propTypes` 对象，我可以指定给定组件期望的 props 和它们的类型。这对我们代码的未来维护者很有帮助，并在 props
    错误输入或缺失时提供有用的警告。
- en: 'To take advantage of prop validation, first import the `PropTypes` module from
    React:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用 prop 验证，首先从 React 导入 `PropTypes` 模块：
- en: '[PRE43]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, in our component, we give it a static property of `propTypes`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的组件中，我们给它一个静态属性 `propTypes`：
- en: '[PRE44]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding example, `foo` and `baz` are the required props for the `Example`
    component. `foo` is expected to be a string, while `baz` is expected to be a number.
    `bar`, on the other hand, is expected to be a function but is not a required prop.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`foo` 和 `baz` 是 `Example` 组件的必需 `props`。`foo` 预期是一个字符串，而 `baz` 预期是一个数字。另一方面，`bar`
    预期是一个函数，但不是必需的 `props`。
- en: Moving beyond MVP
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越 MVP
- en: Now that we have a very bare-bones MVP completed, the next goal is to add some
    features to the application so that it's fully-fledged.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了一个非常基础的 MVP，下一个目标是向应用程序添加一些功能，使其变得完整。
- en: 'Here''s what I wrote earlier regarding some nice-to-have features:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我之前提到的某些有用的功能：
- en: I'd like to set a reminder for each unique task so that I can get to each one in
    an orderly fashion. Ideally, the items on the list can be grouped into categories.
    Category grouping could perhaps be simplified by something like icons. This way,
    I can also sort and filter my list by icons.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望为每个独特的任务设置一个提醒，这样我就可以有序地完成每个任务。理想情况下，列表中的项目可以按类别分组。类别分组可能可以通过类似图标的东西来简化。这样，我也可以通过图标对列表进行排序和筛选。
- en: In addition to the features, we should tweak the styling of the application
    so that it looks better. In my sample code, the app's components conflict with
    the iOS's status bar and the rows aren't formatted at all. We should give the
    app its own identity.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 除了功能之外，我们还应该调整应用程序的样式，使其看起来更好。在我的示例代码中，应用程序的组件与 iOS 的状态栏冲突，并且行格式完全没有设置。我们应该给应用程序一个自己的身份。
- en: The next chapter will dive deeper into our MVP and transform it into a fully-featured
    and styled application. We'll also look at things we would do differently if the
    app were written for Android instead.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将更深入地探讨我们的 MVP，并将其转变为一个功能齐全且样式丰富的应用程序。我们还将探讨如果应用程序是为 Android 编写的，我们会做哪些不同的事情。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you started out strong by planning a minimum viable product
    version of a to-do list app, complete with adding tasks to the list and marking
    them as completed. Then, you learned about basic styling in React Native with
    Flexbox and became acquainted with new syntax and functionalities of the ES6 specification.
    You also discovered the iOS simulator debugging menu, which is a helpful tool
    for writing apps.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你通过规划一个最小可行产品版本的待办事项应用开始了你的学习，其中包括向列表中添加任务并将它们标记为已完成。然后，你学习了React Native中的基本样式设计，使用Flexbox，并熟悉了ES6规范的新语法和功能。你还发现了iOS模拟器的调试菜单，这是一个编写应用的非常有用的工具。
- en: Afterward, you created a `ListView` component to render an array of items, and
    then implemented a `TextInput` component to save user input and render that into
    the `Listview`. Then, you used `AsyncStorage` to persist the data added to the
    app by the user, utilizing the new `async` and `await` keywords to write clean
    asynchronous functions. Finally, you implemented a `TouchableHighlight` cell that
    marks tasks as completed.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你创建了一个`ListView`组件来渲染一系列项目，然后实现了一个`TextInput`组件来保存用户输入并将它渲染到`Listview`中。接着，你使用了`AsyncStorage`来持久化用户添加到应用中的数据，利用新的`async`和`await`关键字编写了干净的异步函数。最后，你实现了一个`TouchableHighlight`单元格，用于标记任务为已完成。
