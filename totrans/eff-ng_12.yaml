- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Deploying Angular Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署 Angular 应用程序
- en: In this last chapter, you will deploy the demo application we created to GitHub
    Pages. You will learn to lint and build Angular applications and libraries inside
    your Nx monorepo. We will explore what Angular and Nx create for you when you
    build an Angular application and what it is you deploy to your hosting platform.
    When you know how to build your Angular applications, we will inspect the application
    build and analyze the different bundles inside our build to determine where we
    can make some improvements to reduce the size of our application bundles. After
    analyzing the application bundles, we will first host the production build of
    our application locally. Next, we will dive into GitHub Pages and GitHub Actions
    to create an automated deployment process. GitHub Pages is a static website hosting
    service that allows you to host your static websites and applications for free.
    GitHub actions are used to set up **continuous integration and continuous delivery**
    (**CI/CD**) flows to automate your linting, testing, and deployment process. The
    CI/CD process you create will automatically lint, test, and deploy your Angular
    app inside the Nx monorepo to GitHub Pages when you merge code to your main GitHub
    branch.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章的最后部分，你将把我们所创建的演示应用程序部署到 GitHub Pages。你将学习如何在你的 Nx 单一代码库中检查和构建 Angular 应用程序和库。我们将探讨
    Angular 和 Nx 在构建 Angular 应用程序时为你创建的内容，以及你部署到托管平台上的内容。当你知道如何构建你的 Angular 应用程序后，我们将检查应用程序的构建并分析构建中的不同包，以确定我们可以从哪里进行一些改进来减小应用程序包的大小。在分析应用程序包之后，我们首先将在本地托管我们的应用程序的生产构建。接下来，我们将深入研究
    GitHub Pages 和 GitHub Actions 以创建自动部署流程。GitHub Pages 是一个静态网站托管服务，允许你免费托管你的静态网站和应用程序。GitHub
    Actions 用于设置**持续集成和持续交付**（**CI/CD**）流程来自动化你的代码检查、测试和部署过程。你创建的 CI/CD 流程将在你将代码合并到主
    GitHub 分支时自动在 Nx 单一代码库中检查、测试和部署你的 Angular 应用程序。 '
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Building and linting Angular applications inside your Nx monorepo
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的 Nx 单一代码库中构建和检查 Angular 应用程序
- en: Analyzing your build output
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析构建输出
- en: Automatically deploying Angular applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动部署 Angular 应用程序
- en: Building and linting Angular applications inside your Nx monorepo
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的 Nx 单一代码库中构建和检查 Angular 应用程序
- en: This section will explore the steps required to build and lint Angular applications
    within an Nx monorepo. We start by learning how to lint projects inside your Nx
    monorepo. Next, we will explore different configurations for the linting process
    and how to apply them. Once you know how and why to lint your projects before
    you create a build, we will learn about building projects inside the Nx monorepo.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探讨在 Nx 单一代码库中构建和检查 Angular 应用程序的步骤。我们首先学习如何在你的 Nx 单一代码库中检查项目。接下来，我们将探索不同的代码检查过程配置以及如何应用它们。一旦你知道在创建构建之前如何以及为什么要检查你的项目，我们将学习如何在
    Nx 单一代码库中构建项目。
- en: Furthermore, we’ll explore how Nx enhances the build process by leveraging advanced
    caching and parallel task execution to optimize build times. Nx’s incremental
    builds significantly reduce the build times for large and complex projects, ensuring
    that only necessary parts of the application are rebuilt. The incremental builds
    and Nx cache will speed up your CI/CD pipelines and the overall deployment process.
    Let’s start at the beginning and learn about linting projects inside your Nx monorepo.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将探讨 Nx 如何通过利用高级缓存和并行任务执行来优化构建时间来增强构建过程。Nx 的增量构建显著减少了大型和复杂项目的构建时间，确保只有应用程序的必要部分被重新构建。增量构建和
    Nx 缓存将加速你的 CI/CD 管道和整体部署过程。让我们从开始学习如何在你的 Nx 单一代码库中检查项目代码检查。
- en: Linting Nx projects
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 Nx 项目
- en: '**Linting** is a crucial step in the software development process. It involves
    analyzing your code for potential errors, enforcing coding standards, and maintaining
    code quality. Linting helps catch issues early in the development cycle, reducing
    the likelihood of bugs and ensuring that your code base adheres to best practices.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码检查**是软件开发过程中的关键步骤。它涉及分析你的代码以查找潜在的错误、强制执行编码标准和维护代码质量。代码检查有助于在开发周期早期捕捉问题，降低出现错误的可能性，并确保你的代码库遵循最佳实践。'
- en: Linting improves the maintainability and readability of your code and enhances
    collaboration within your team by providing a consistent coding style. We already
    talked about linting in [*Chapter 1*](B21625_01.xhtml#_idTextAnchor014). Depending
    on your setup, you will be notified about linting errors during your development
    process by ESLint. Still, it’s important to always run the linting process in
    your CI/CD pipelines before your code is merged or deployed. Running the linting
    process inside your CI/CD pipelines ensures code that doesn’t adhere to your configured
    guidelines is not merged. By integrating linting into your pipelines, you can
    ensure that your projects are robust, reliable, and ready for production, leading
    to more efficient and error-free builds.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代码风格检查可以提高您代码的可维护性和可读性，并通过提供一致的编码风格来增强团队内部的协作。我们已经在[*第一章*](B21625_01.xhtml#_idTextAnchor014)中讨论了代码风格检查。根据您的配置，您将在开发过程中通过
    ESLint 获得关于代码风格检查错误的提示。然而，在代码合并或部署之前始终运行代码风格检查过程是很重要的。在 CI/CD 管道中运行代码风格检查过程确保不符合您配置的指南的代码不会被合并。通过将代码风格检查集成到您的管道中，您可以确保项目健壮、可靠且适用于生产，从而实现更高效和更无错误的构建。
- en: As with all other tasks such as testing and building, you can perform linting
    using the Nx console or by running a terminal command.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他任务（如测试和构建）一样，您可以使用 Nx 控制台或通过运行终端命令来进行代码风格检查。
- en: Linting using the Nx console
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Nx 控制台进行代码风格检查
- en: 'If you want to lint a project using the Nx console, follow these steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用 Nx 控制台对项目进行代码风格检查，请按照以下步骤操作：
- en: Click on the Nx logo on the left side of VS Code.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 左侧点击 Nx 标志。
- en: Locate the project you wish to lint under the **PROJECTS** tab.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **项目** 选项卡下找到您想要进行代码风格检查的项目。
- en: Hover over `lint`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在 `lint` 上。
- en: 'Click the play button:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放按钮：
- en: '![Figure 12.1: Nx console lint](img/B21625_12_001.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1：Nx 控制台代码风格检查](img/B21625_12_001.jpg)'
- en: 'Figure 12.1: Nx console lint'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：Nx 控制台代码风格检查
- en: '*Figure 12**.1* shows a visual representation of the Nx console and where to
    find the `lint` task. When you click the play button for the `lint` task, a terminal
    will open inside VS Code, where you can see the result of the linting process.
    In the case of the *finance-expenses-registration application*, the linting process
    will pass without any error or warning regarding your linting rules. There will
    be a warning for Nx Cloud, but this can be ignored because we aren’t using Nx
    Cloud. When using the Nx console, you can only lint your projects individually.
    Alternatively, with the Nx console, you can lint your projects using terminal
    commands.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12.1* 展示了 Nx 控制台的视觉表示以及如何找到 `lint` 任务。当您点击 `lint` 任务的播放按钮时，VS Code 内部将打开一个终端，您可以在其中看到代码风格检查的结果。在
    *finance-expenses-registration 应用程序* 的例子中，代码风格检查过程将无任何错误或警告通过您的代码风格检查规则。对于 Nx
    Cloud 将会有一个警告，但可以忽略，因为我们没有使用 Nx Cloud。当使用 Nx 控制台时，您只能单独对项目进行代码风格检查。或者，您也可以使用终端命令通过
    Nx 控制台对项目进行代码风格检查。'
- en: Linting using the terminal command
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用终端命令进行代码风格检查
- en: 'You can lint a single project by running the following terminal command at
    the root of your Nx monorepo:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 Nx 单个项目仓库的根目录下运行以下终端命令来对单个项目进行代码风格检查：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding terminal command, you need to replace `<project name>` with
    the name of the project you want to lint. This project name can be found inside
    the `project.json` file of the project you want to target. So, to lint the *finance-expenses-registration
    application*, you run the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的终端命令中，您需要将 `<project name>` 替换为您想要进行代码风格检查的项目名称。这个项目名称可以在您想要目标项目的 `project.json`
    文件中找到。因此，要对 *finance-expenses-registration 应用程序* 进行代码风格检查，您需要运行以下命令：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Running the linting process for a second time was a lot faster due to the Nx
    cache. Inside the terminal, you’ll find Nx read the output from the cache instead
    of running the command for 1 out of 1 tasks, indicating Nx took the linting output
    from the cache because it detected nothing changed since we last linted the project.
    When running the linting process for multiple projects, the Nx cache can significantly
    reduce the time needed for your linting to complete, greatly improving your development
    process and experience.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Nx 缓存，第二次运行代码风格检查过程要快得多。在终端中，您会发现 Nx 从缓存中读取输出而不是为 1 个任务中的 1 个运行命令，这表明 Nx
    从缓存中获取了代码风格检查的输出，因为它检测到自上次代码风格检查以来项目没有发生变化。当对多个项目运行代码风格检查时，Nx 缓存可以显著减少代码风格检查完成所需的时间，大大提高您的开发过程和体验。
- en: Linting multiple projects
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对多个项目进行代码风格检查
- en: In the preceding examples, we’ve seen how to run linting for a single project,
    but in most cases, especially inside your CI/CD pipelines, you want to lint multiple
    projects. When you run linting in a CI pipeline (a pipeline you run before each
    code merge), you commonly wish to lint projects that are affected by the changes
    you’re about to merge; alternatively, when running a CD pipeline that deploys
    your system, you commonly run linting on all projects inside your monorepo or
    all projects related to the deployment.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到了如何为单个项目运行linting，但在大多数情况下，尤其是在您的CI/CD管道中，您希望lint多个项目。当您在CI管道（在每次代码合并之前运行的管道）中运行linting时，您通常希望lint受您即将合并的更改影响的项目；或者，当运行部署您的系统的CD管道时，您通常会在您的monorepo中的所有项目或与部署相关的所有项目中运行linting。
- en: 'To run linting for all projects affected by your changes, you can utilize the
    `nx affected` command. The terminal command is similar to the `affected` command
    we used when running tests for affected projects; you only change the target job
    from `test` to `lint`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行受您更改影响的所有项目的linting，您可以使用`nx affected`命令。终端命令与我们在为受影响的项目运行测试时使用的`affected`命令类似；您只需更改目标作业从`test`到`lint`：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see in the preceding command, you use the `affected` keyword, add
    the `-t` flag, and define the target task you want to run. In this scenario, it
    is `lint`. After defining the task, we also need to configure the `–base` flag
    and provide it with the base branch to compare the changes with; commonly, this
    will be your main branch. Instead of manually defining the `–base` flag, you can
    also configure the `defaultBase` property inside your `nx.json` file. To configure
    your default base branch, add the following inside the root of your `nx.json`
    file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的命令中看到的，您使用`affected`关键字，添加`-t`标志，并定义您想要运行的目标任务。在这个场景中，它是`lint`。在定义任务之后，我们还需要配置`–base`标志，并为其提供要与之比较更改的基分支；通常，这将是你主分支。您不必手动定义`–base`标志，也可以在您的`nx.json`文件中配置`defaultBase`属性。要配置您的默认基分支，请在您的`nx.json`文件的根目录下添加以下内容：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After adding the preceding code, you can run the `affected` command without
    providing the `–base` flag. Currently, if you run the `affected` command, you’ll
    notice all projects inside the monorepo are linted. All projects are linted because
    Nx doesn’t have an affected lint cached for your `defaultBase` property. Besides
    all projects being linted, you will also notice that the linting process fails
    for 4 out of 13 projects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加上述代码之后，您可以在不提供`–base`标志的情况下运行`affected`命令。目前，如果您运行`affected`命令，您会注意到monorepo中的所有项目都被linted。所有项目都被linted，因为Nx没有为您的`defaultBase`属性缓存受影响的lint。除了所有项目都被linted之外，您还会注意到linting过程中有4个项目中的4个失败了。
- en: Fixing linting errors
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复linting错误
- en: Before we continue, let’s fix the linting errors so that all linted projects
    succeed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们修复linting错误，以便所有linted项目都能成功。
- en: The --fix flag
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`--fix`标志'
- en: 'You can manually go through all the errors in the terminal output and fix them
    one by one, but most linting errors are easy to fix, and the Nx linting process
    provides a way to solve all easy linting errors for you. Simply append the `–-fix`
    flag to your terminal command, and Nx will automatically fix the issues it can
    fix for you. To get the best result when using the `--fix` flag, you need to run
    the linting process for each project individually. So, let’s take the projects
    with linting errors and run them one by one with the `–-fix` flag appended to
    the command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以手动逐个查看终端输出中的所有错误并逐一修复它们，但大多数linting错误很容易修复，Nx的linting过程提供了一种为您解决所有简单linting错误的方法。只需将`–-fix`标志附加到您的终端命令中，Nx将自动修复它可以修复的问题。要使用`--fix`标志获得最佳结果，您需要为每个项目单独运行linting过程。所以，让我们取有linting错误的项目，并逐个运行它们，命令中附加了`–-fix`标志：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After running the aforementioned commands, all your linting errors are fixed.
    You can now rerun the affected `lint` command, and the linting for all projects
    will succeed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上述命令之后，所有的linting错误都已被修复。现在您可以重新运行受影响的`lint`命令，所有项目的linting都将成功。
- en: The fix option
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修复选项
- en: 'As you might imagine, running the linting command for each project with linting
    errors can become cumbersome, especially when your monorepo grows. Alternatively,
    you can configure the `fix` option inside the `project.json` file of individual
    projects. Inside the `project.json` file, you’ll find a `lint` section, and inside
    this section, you can add the `fix` option like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，为每个有linting错误的工程运行linting命令可能会变得繁琐，尤其是在您的monorepo增长时。另外，您可以在各个项目的`project.json`文件内配置`fix`选项。在`project.json`文件中，您会找到一个`lint`部分，在这个部分内，您可以添加`fix`选项，如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After adding the preceding configuration to each project’s `project.json` file,
    you can simply run the `lint affected` command, and Nx will fix the linting issues
    it can for each project.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在将前面的配置添加到每个项目的`project.json`文件后，您只需运行`lint affected`命令，Nx将为每个项目修复其可以修复的linting问题。
- en: Other configurations
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他配置
- en: 'Besides the `--fix` flag and configuration, there are other useful configurations,
    such as allowing a maximum number of warnings before the linting process fails,
    outputting your lint results to a file, or passing the linting process even if
    there are linting errors. You can find all configurations in the official Nx documentation
    at the following URL: [https://nx.dev/nx-api/eslint/executors/lint](https://nx.dev/nx-api/eslint/executors/lint).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`--fix`标志和配置之外，还有其他有用的配置，例如在linting过程失败之前允许最大警告数，将您的linting结果输出到文件，或者即使存在linting错误也传递linting过程。您可以在以下URL的官方Nx文档中找到所有配置：[https://nx.dev/nx-api/eslint/executors/lint](https://nx.dev/nx-api/eslint/executors/lint)。
- en: Targeting multiple projects when running a linting command
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行linting命令时针对多个项目
- en: 'After looking into the remaining configuration options, I will briefly explain
    how you can target multiple projects simultaneously when running a linting command.
    You can use the `run-many` command to do this, similar to what we did in [*Chapter
    11*](B21625_11.xhtml#_idTextAnchor200) when testing multiple projects with a single
    command. You use the `run-many` command combined with the `-p` flag. The `run-many`
    command allows you to run tasks for many projects, whereas the `-p` flag will
    enable you to specify specific projects:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看剩余的配置选项后，我将简要解释如何在运行linting命令时同时针对多个项目。您可以使用`run-many`命令来完成此操作，类似于我们在[*第11章*](B21625_11.xhtml#_idTextAnchor200)中用单个命令测试多个项目时所做的那样。您使用`run-many`命令结合`-p`标志。`run-many`命令允许您为许多项目运行任务，而`-p`标志将允许您指定特定的项目：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding example, you perform linting for `project1` and `project2`.
    Alternatively, you can run the linting process for projects with a specific tag
    by using the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您为`project1`和`project2`执行了linting。另外，您可以通过以下命令为具有特定标签的项目运行linting过程：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see in the preceding command, instead of defining project names,
    we defined the tag we wanted to target.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的命令中所见，我们不是定义项目名称，而是定义了我们想要针对的标签。
- en: 'Now that you know how to lint specific projects and how to configure the linting
    process, let’s dive into the next topic: building your projects inside the Nx
    monorepo.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道了如何lint特定的项目以及如何配置linting过程，让我们深入下一个主题：在Nx monorepo内部构建您的项目。
- en: Building your Angular libraries and applications
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建您的Angular库和应用程序
- en: To deploy your Angular projects, you need to create an application build. When
    you create an application build, the build process creates a bundle of code that
    your runtime can execute and run. In the case of Angular applications, the browser
    will be the runtime that interprets and runs the application code. So, to deploy
    the demo application we created, you first need to make an application build using
    the `nx` `build` command.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署您的Angular项目，您需要创建一个应用程序构建。当您创建应用程序构建时，构建过程会创建一个代码包，您的运行时可以执行和运行它。在Angular应用程序的情况下，浏览器将是解释和运行应用程序代码的运行时。因此，要部署我们创建的演示应用程序，您首先需要使用`nx`
    `build`命令创建一个应用程序构建。
- en: Behind the scenes of creating an application build
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建应用程序构建的幕后
- en: 'Before running the `nx build` command for our *expenses-registration application*,
    let’s examine in detail what happens when we run a `build` command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行我们的*expenses-registration应用程序的`nx build`命令之前，让我们详细检查运行`build`命令时会发生什么：
- en: '`project.json` files of the projects you’re about to build. This is similar
    to the standard Angular CLI but with support for multiple projects in a monorepo,
    and Nx analyzes the `project.json` files instead of the `angular.json` file in
    a regular Angular project.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您即将构建的项目中的 `project.json` 文件。这与标准 Angular CLI 类似，但支持单仓库中的多个项目，Nx 分析 `project.json`
    文件而不是常规 Angular 项目中的 `angular.json` 文件。
- en: '`project.json` file. If you configured file replacements for the build targets,
    Nx will replace the files before continuing the build process.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`project.json` 文件。如果您为构建目标配置了文件替换，Nx 将在继续构建过程之前替换文件。'
- en: '`ngc`, to transpile TypeScript code into JavaScript, handling Angular decorators
    and templates.'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ngc`，将 TypeScript 代码转换为 JavaScript，处理 Angular 装饰器和模板。'
- en: '**Ahead-of-time (AOT) compilation**: As with the Angular CLI, Nx performs AOT
    compilation for production builds (unless configured differently), converting
    Angular templates and components into efficient JavaScript code that can be executed
    by the browser without the need to compile the code before it can be rendered.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预编译（AOT）**：与 Angular CLI 类似，Nx 对生产构建执行 AOT 编译（除非配置不同），将 Angular 模板和组件转换为浏览器可以执行的效率高的
    JavaScript 代码，而无需在渲染之前编译代码。'
- en: '**Bundling phase**'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**捆绑阶段**'
- en: '**Module resolution**: Nx uses the configured build tool for module resolution
    and creating a dependency graph, starting from the entry point(s).'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块解析**：Nx 使用配置的构建工具进行模块解析和创建依赖图，从入口点（s）开始。'
- en: '**Tree shaking**: Nx performs tree shaking to remove unused code, reducing
    the final bundle size.'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摇树优化**：Nx 执行摇树优化以删除未使用的代码，减小最终捆绑包的大小。'
- en: '**Code splitting**: Nx splits different parts of your application into multiple
    JavaScript bundles that can be lazy loaded by the browser.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码拆分**：Nx 将应用程序的不同部分拆分为多个 JavaScript 捆绑包，这些捆绑包可以被浏览器懒加载。'
- en: '**Asset optimization**: Nx optimizes CSS, HTML, images, and other assets, similar
    to the Angular CLI.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资产优化**：Nx 优化 CSS、HTML、图像和其他资产，类似于 Angular CLI。'
- en: '**Minification** **and uglification**'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**压缩** **和压缩**'
- en: '**JavaScript minification**: Nx minifies JavaScript code to reduce file size.'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript 压缩**：Nx 压缩 JavaScript 代码以减小文件大小。'
- en: '**Uglification**: Nx further obfuscates the JavaScript code.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压缩**：Nx 进一步混淆 JavaScript 代码。'
- en: '**Hashing and** **cache busting**'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哈希和缓存失效**'
- en: '**File hashing**: Nx appends hashes to filenames of generated bundles and assets
    for cache busting.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件哈希**：Nx 将哈希值附加到生成的捆绑包和资产的文件名上，以实现缓存失效。'
- en: '`index.html` file, including references to the hashed JavaScript and CSS bundles.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`index.html` 文件，包括对哈希过的 JavaScript 和 CSS 捆绑的引用。'
- en: '`dist` folder or some other configured output path.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dist` 文件夹或某些其他配置的输出路径。'
- en: The preceding steps resemble the regular build flow when using the Angular CLI.
    Yet, Nx has some additional features such as affected builds, the `run-many` command,
    incremental builds, and caching, making it easier to create application builds
    for multiple projects inside a monorepo and speeding up build times. Now that
    you have a better grasp of what is happening when building your projects, let’s
    create an application build for the expense registration application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤与使用 Angular CLI 时的常规构建流程相似。然而，Nx 有一些额外的功能，例如受影响构建、`run-many` 命令、增量构建和缓存，这使得在单仓库内为多个项目创建应用程序构建更加容易，并加快了构建时间。现在您已经更好地了解了构建项目时发生的情况，让我们为费用注册应用程序创建一个应用程序构建。
- en: Important notice!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要通知！
- en: The *expenses-registration application* we made is just a simple demo application
    and not really meant for production purposes. There are still plenty of improvements
    to make, pages to add, and code to clean up before you actually deploy the application.
    For demonstration purposes, we will be deploying the application to GitHub Pages,
    but it’s not meant to be used for anything other than demonstration purposes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们制作的 *费用注册应用程序* 只是一个简单的演示应用程序，并不真正适用于生产目的。在您实际部署应用程序之前，还有很多改进可以做出，需要添加页面，以及需要清理的代码。为了演示目的，我们将把应用程序部署到
    GitHub Pages，但这并不是为了其他任何目的而使用。
- en: Running the build command
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行构建命令
- en: 'You can run the `build` command for the *expenses-registration application*
    in the terminal or Nx console. As shown in *Figure 12**.2*, you can find the `build`
    command in the Nx console above the `lint` command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在终端或 Nx 控制台中运行 *费用注册应用程序* 的 `build` 命令。如图 *图 12.2* 所示，您可以在 Nx 控制台中找到 `build`
    命令，它在 `lint` 命令之上：
- en: '![Figure 12.2: Nx console build](img/B21625_12_002.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2：Nx 控制台构建](img/B21625_12_002.jpg)'
- en: 'Figure 12.2: Nx console build'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：Nx控制台构建
- en: To run the `build` command, click the play button next to the `build` keyword
    in the Nx console. Nx configures the production build as your default; if you
    want to target another build configuration, you can expand `build` inside the
    Nx console to see all build configurations you have. You can then run a specific
    build configuration by clicking on the play button next to the name of the build
    configuration you want to run. For each project, Nx creates a production and development
    build configuration for you inside the `project.json` files. When needed, you
    can create additional build configurations; for example, when you have multiple
    staging environments such as test and acceptance that require a deviation from
    the production or development build.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行`build`命令，在Nx控制台中点击`build`关键字旁边的播放按钮。Nx将生产构建配置为默认配置；如果你想针对另一个构建配置，你可以在Nx控制台中展开`build`以查看所有构建配置。然后，你可以通过点击你想要运行的构建配置名称旁边的播放按钮来运行特定的构建配置。对于每个项目，Nx都会在`project.json`文件中为你创建一个生产和开发构建配置。当需要时，你可以创建额外的构建配置；例如，当你有多个预发布环境，如测试和验收，这些环境需要从生产或开发构建中有所偏差时。
- en: 'The Nx console is an extension for your code editor, and as such, it isn’t
    available inside your CI/CD pipelines. Because the Nx console isn’t available,
    you need to use the Nx CLI inside your pipelines to create application builds
    and perform other tasks such as building and testing your applications. The syntax
    for the `nx build` command is similar to the `test` and `lint` commands we used
    earlier; you only change the build target from `lint` or `test` to `build`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Nx控制台是代码编辑器的扩展，因此它不可用于你的CI/CD管道中。由于Nx控制台不可用，你需要在管道中使用Nx CLI来创建应用程序构建并执行其他任务，例如构建和测试你的应用程序。`nx
    build`命令的语法与之前使用的`test`和`lint`命令类似；你只需将构建目标从`lint`或`test`更改为`build`：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see in the aforementioned command, we type `nx` to target the Nx
    CLI, followed by the task we want to run, and lastly, add the project name of
    the project we want to target. Nx will use the default build configuration, which
    is production unless you change it. If you want to target a different build configuration,
    you can add the `–-configuration` flag to the `build` command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如上述命令所示，我们输入`nx`来指定Nx CLI，然后是我们要运行的任务，最后添加我们想要针对的项目名称。Nx将使用默认的构建配置，除非你更改它。如果你想针对不同的构建配置，你可以在`build`命令中添加`–-configuration`标志：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By adding the preceding flag at the end of your CLI command, you’ll use the
    `development` build configuration instead of the production configuration. Alternatively,
    you can use the following syntax:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在CLI命令的末尾添加前面的标志，你将使用`development`构建配置而不是生产配置。或者，你也可以使用以下语法：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding command runs the production build for the `finance-expenses-registration`
    project. As we’ve seen with the `lint` and `test` commands, you can also use `affected`
    and `run-many` to build multiple projects or projects affected by your changes.
    Now that you know how to run `build` commands using the Nx console and the Nx
    CLI, go ahead and run the production build for the `finance-expenses-registration`
    project.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令为`finance-expenses-registration`项目运行了生产构建。正如我们通过`lint`和`test`命令所看到的，你也可以使用`affected`和`run-many`来构建多个项目或受你更改影响的项目。现在，你已经知道了如何使用Nx控制台和Nx
    CLI运行`build`命令，那么就继续为`finance-expenses-registration`项目运行生产构建吧。
- en: Fixing failing builds
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复失败的构建
- en: 'After running the production build for the `finance-expenses-registration`
    project, you’ll notice Nx tries to build the `finance-expenses-registration` project
    and all projects it depends on – in our case, three other libraries (`shared-ui-common-components`,
    `finance-data-access-expenses`, and `shared-util-form-validator`) – in our Nx
    monorepo. You’ll also notice that three out of four builds fail. The three failing
    builds are the three libraries, and they all have the same error: `''updateBuildableProjectDepsInPackageJson''
    is not found` `in schema`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在为`finance-expenses-registration`项目运行生产构建后，你会注意到Nx试图构建`finance-expenses-registration`项目以及它所依赖的所有项目——在我们的案例中，是三个其他库（`shared-ui-common-components`、`finance-data-access-expenses`和`shared-util-form-validator`）——在我们的Nx单仓库中。你还会注意到，四个构建中有三个失败了。这三个失败的构建是三个库，它们都有相同的错误：`'updateBuildableProjectDepsInPackageJson'`在`schema`中未找到。
- en: 'To fix your builds, you need to remove the following configuration inside the
    `project.json` files of your libraries:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复你的构建，你需要在你的库的`project.json`文件中移除以下配置：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After removing the preceding configuration inside your `project.json` files,
    you can run the `build` command for the `finance-expenses-registration` project
    again, and your build process will now succeed. After the build is finished, you’ll
    notice a `dist` folder has been created in the root of your Nx monorepo. The build
    output for the `finance-expenses-registration` project and all dependent buildable
    projects are located inside this `dist` folder. The build output for the `finance-expenses-registration`
    project can be found at this path: `dist/apps/finance/expenses-registration`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`project.json`文件中移除前面的配置后，你可以再次运行`finance-expenses-registration`项目的`build`命令，现在你的构建过程将成功。构建完成后，你会在Nx单体仓库的根目录下注意到已创建一个`dist`文件夹。`finance-expenses-registration`项目及其所有依赖的可构建项目的构建输出都位于这个`dist`文件夹内。`finance-expenses-registration`项目的构建输出可以在以下路径找到：`dist/apps/finance/expenses-registration`。
- en: When you deploy your application, you upload the output inside `dist/apps/finance/expenses-registration`
    to your hosting service. In the case of an Angular application, you can use a
    static hosting service such as GitHub Pages, Azure Blob Storage, Amazon **Simple
    Storage Service** (**S3**), or any other static website hosting service you prefer.
    If you are using Angular Universal and **server-side rendering** (**SSR**), you
    need a different hosting service, such as Azure App Service, but we will not cover
    that in this book.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你部署你的应用程序时，你需要将`dist/apps/finance/expenses-registration`目录内的输出上传到你的托管服务。在Angular应用程序的情况下，你可以使用诸如GitHub
    Pages、Azure Blob Storage、Amazon **简单存储服务** (**S3**) 或你偏好的任何其他静态网站托管服务。如果你正在使用Angular
    Universal和**服务器端渲染** (**SSR**)，你需要一个不同的托管服务，例如Azure App Service，但在这本书中我们不会涉及这一点。
- en: In the last section of this chapter, we will use GitHub Actions to automatically
    deploy and host our demo application on GitHub Pages, but for now, let’s see how
    we can serve our production build locally on our machine using `http-server`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将使用GitHub Actions自动部署和托管我们的演示应用程序到GitHub Pages，但现在，让我们看看如何使用`http-server`在我们的机器上本地托管我们的生产构建。
- en: Locally serving the production build
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地托管生产构建
- en: 'To serve our production build, we need a server that can host our static files.
    There are many services out there that can do this, but we will be using `http-server`.
    To start, you need to install `http-server` on your machine using the following
    command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了托管我们的生产构建，我们需要一个可以托管我们的静态文件的服务器。市面上有许多可以做到这一点的服务，但我们将使用`http-server`。首先，你需要使用以下命令在你的机器上安装`http-server`：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After installing `http-server`, you can use it to host the production build
    of your Angular application locally. If you don’t have staging environments such
    as test and acceptance, using something such as `http-server` allows you to test
    if your build works as expected before deploying it to your production environment;
    still, in a professional setting, I would always recommend using a testing and
    acceptance environment where you can test your application in an environment that
    mimics the production environment.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`http-server`后，你可以使用它来本地托管你的Angular应用程序的生产构建。如果你没有诸如测试和验收之类的预发布环境，使用像`http-server`这样的工具可以在部署到生产环境之前测试你的构建是否按预期工作；然而，在专业设置中，我总是推荐使用一个测试和验收环境，在那里你可以在一个类似于生产环境的环境中测试你的应用程序。
- en: 'To locally host your application using `http-server`, you need to run the following
    terminal command at the root of your Nx monorepo:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`http-server`在本地托管你的应用程序，你需要在Nx单体仓库的根目录下运行以下终端命令：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After running the preceding command, a server will be created, hosting the static
    files inside the `dist\apps\finance\expenses-registration` folder. Inside the
    terminal, you’ll find two URLs starting with your private IP addresses and ending
    with the `8080` port. You can visit either of these URLs inside your browser to
    see your application. When you visit the application in your browser, you’ll see
    the requests that are made by your application inside the terminal. You may notice
    that the `api/expenses` request is failing; the reason for the failing API request
    is that we don’t have a running API, and the mock API interceptor is disabled
    in a production build.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的命令后，将创建一个服务器，托管`dist\apps\finance\expenses-registration`文件夹内的静态文件。在终端中，你会找到两个以你的私有IP地址开头并以`8080`端口结尾的URL。你可以在浏览器中访问这两个URL中的任何一个来查看你的应用程序。当你通过浏览器访问应用程序时，你会在终端中看到你的应用程序发出的请求。你可能注意到`api/expenses`请求失败；导致API请求失败的原因是我们没有运行中的API，并且在生产构建中禁用了模拟API拦截器。
- en: 'Because we disabled the mock data interceptor and we don’t have a running API,
    you don’t see any data inside the application when you visit it in the browser.
    For testing purposes, you can enable the mock interceptor for your production
    build by removing the following inside the `mock.interceptor.ts` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们禁用了模拟数据拦截器并且我们没有运行中的 API，所以当你用浏览器访问它时，你不会在应用程序中看到任何数据。为了测试目的，你可以通过在 `mock.interceptor.ts`
    文件中移除以下内容来为你的生产构建启用模拟拦截器：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After removing the preceding code, the mock interceptor will also work for your
    production build. Create a new application build, serve the build using `http-server`,
    and revisit the application inside your browser (you probably need to remove the
    browser cache by opening the developer tools, right-clicking on the reload symbol
    in the browser, and selecting `api/expenses` request succeeds. Don’t forget to
    revert the changes inside the `mock.interceptor.ts` file, as this is just for
    testing purposes; in a real production application, you want to use a real API.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 移除前面的代码后，模拟拦截器也将适用于你的生产构建。创建一个新的应用程序构建，使用 `http-server` 提供服务，然后在浏览器中重新访问应用程序（你可能需要通过打开开发者工具，右键单击浏览器中的重新加载符号，并选择
    `api/expenses` 请求成功来清除浏览器缓存）。别忘了在 `mock.interceptor.ts` 文件中撤销更改，因为这只是为了测试目的；在实际的生产应用程序中，你希望使用真实的
    API。
- en: So, to summarize, you learned how to lint projects inside your Nx monorepo and
    how you can automatically fix basic lint errors by using the `–-fix` flag. You
    learned what happens behind the scenes when you create an application build for
    your Angular applications. You also learned how to run the `build` command for
    specific build configurations and where to find the output of your application
    build. Lastly, you hosted the build output locally using the `http-server` `npm`
    package. In the next section, you will learn how to analyze your application build
    so that you can easily identify which sections of your build can be worked on
    to reduce your bundle sizes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，你学习了如何在 Nx 单一代码库内部对项目进行代码检查，以及如何通过使用 `–-fix` 标志自动修复基本的代码检查错误。你学习了当你为
    Angular 应用程序创建应用程序构建时幕后发生了什么。你还学习了如何为特定的构建配置运行 `build` 命令以及在哪里可以找到应用程序构建的输出。最后，你使用
    `http-server` `npm` 包在本地托管了构建输出。在下一节中，你将学习如何分析应用程序构建，以便你可以轻松地识别哪些构建部分可以工作以减小你的包大小。
- en: Analyzing your build output
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析你的构建输出
- en: Inside your build output, you’ll find different JavaScript files. Some of these
    files are your application bundles, which the browser will load to render the
    application for the end user. The size of these bundles directly impacts the performance
    of your application. JavaScript is slow to load for a browser, so the bigger your
    bundle size, the longer it takes for the browser to download the files, render
    something on the screen, and make the web page respond so that the user can interact
    with it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的构建输出中，你会找到不同的 JavaScript 文件。其中一些文件是你的应用程序包，浏览器将加载这些包来为最终用户渲染应用程序。这些包的大小直接影响到你应用程序的性能。JavaScript
    对浏览器来说加载较慢，因此你的包越大，浏览器下载文件、在屏幕上渲染内容以及使网页响应用户交互所需的时间就越长。
- en: To reduce your bundle sizes, you need an effective way to analyze your bundles.
    If you run the `build` command for the `finance-expenses-registration` project,
    you’ll see a small report inside the terminal
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减小你的包大小，你需要一种有效的方法来分析你的包。如果你为 `finance-expenses-registration` 项目运行 `build`
    命令，你会在终端看到一个小的报告
- en: The build report inside your terminal includes a list of the created bundles
    and the size of each bundle. While this list gives you some indication of the
    size of your bundles, you don’t see what the bundles are made up of and where
    you can make some improvements to reduce the bundle sizes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 终端内的构建报告包括创建的包列表以及每个包的大小。虽然这个列表给你一些关于包大小的指示，但你看不到包由什么组成以及你可以在哪里进行一些改进以减小包的大小。
- en: 'There is a tool named `npm` packages with the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `npm` 的工具包，使用以下命令：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After installing the package globally, you need to install it as a dev dependency
    inside your Nx monorepo. You add the Webpack Bundle Analyzer tool as a dev dependency
    by running the following command in the root of your Nx monorepo:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局安装包之后，你需要在 Nx 单一代码库内部将其安装为开发依赖。你通过在 Nx 单一代码库的根目录下运行以下命令来将 Webpack Bundle
    Analyzer 工具作为开发依赖项添加：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After running the preceding `npm` commands, you can start using Webpack Bundle
    Analyzer. The first step is creating a new production build for your application
    and including a `–-stats-json` flag with the `build` command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By adding the `–-stats-json` flag, Webpack Bundle Analyzer will create a `stats.json`
    file inside the build output. The `stats.json` file is located inside the `dist\apps\finance\expenses-registration`
    folder, next to the rest of your application build. To inspect the `stats.json`
    file, you can run the following command at the root of your Nx monorepo:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Running the preceding command will give you a visual and detailed overview
    of your application bundles. The overview is opened in the browser and should
    look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: Webpack Bundle Analyzer](img/B21625_12_003.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: Webpack Bundle Analyzer'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 12**.3*, the Webpack Bundle Analyzer tool gives you a detailed
    and easy-to-read overview of your bundles and what is in each bundle. You can
    easily identify the large parts of each bundle so that you can see where you can
    make improvements. Because we have a simple application, there isn’t much to adjust,
    but you can, for instance, see that the `ngrx-store` and `transloco` bundles are
    one of the largest elements we’ve added to our project. If your bundle sizes are
    becoming too large, you can try to find replacements for large `npm` packages
    you import, only import small sub-modules if they are available, or move code
    and other resources to lazy-loaded modules so that the browser can first render
    the page and lazy load additional resources.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in *Figure 12**.3*, in the sidebar of Webpack Bundle Analyzer,
    you can control which bundles you show on the screen; this makes it easier to
    focus on specific bundles in your build output. Additionally, you can see the
    bundle sizes in three different formats – the **Stat**, **Parsed**, and **Gzipped**
    formats:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '**Stat** is the largest; this indicates the raw size of your bundle without
    any compressions or optimizations.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parsed** is the same size as shown in the build output report of your terminal.
    This is the size of your bundles after some optimizations and compressions are
    applied.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content-Encoding: Gzip` header, you know your hosting service enabled Gzipping
    for you; if the header is not included, you need to add Gzipping yourself. How
    to add Gzipping yourself falls out of the scope of this book. GitHub Pages will
    Gzip your Angular application for you.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, you now know how to analyze your application bundles effectively
    using Webpack Bundle Analyzer. If bundles are too large, you can try to move code
    to lazy-loaded modules and find replacements for large `npm` packages you import.
    You also learned that Gzipping your content significantly reduces your bundle
    sizes and that most modern hosting services handle Gzipping and the necessary
    configuration for you. In this book’s next and last section, we will use GitHub
    Actions to create a CI/CD process that automatically deploys our demo application
    to GitHub Pages.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Automatically deploying Angular applications
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last section, you will learn how to automatically deploy Angular applications
    inside your Nx monorepo to GitHub Pages. You will set up a CI/CD pipeline using
    GitHub Actions that deploys the demo application we’ve created whenever you merge
    code to your main branch on GitHub. We will create a `.yml` file containing all
    the steps necessary for the deployment. Inside the `.yml` file, we will use the
    YAML language, which is commonly used to create configuration files for various
    DevOps tools and programs.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Creating an access token
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you start creating a `.yml` file, you need to create an access token
    inside your GitHub account. GitHub needs to know you’re authenticated to deploy
    applications to GitHub Pages before it can perform the deployment. You provide
    the necessary authentication to GitHub, providing an access token to the deployment
    step inside your `.yml` file. So, the first thing you need to do is create an
    access token inside your GitHub account. Follow these steps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Start by clicking on your account icon in GitHub and select **Settings**.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the profile settings page, you need to scroll down and select **Develop settings**
    on the left side of the screen.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, again on the left side of the screen, click on **Personal access tokens**
    and then select **Tokens (classic)** in the drop-down menu.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you need to click on the **Generate new token** button, and in the drop-down
    menu, you select **Generate new** **token (classic)**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After following *steps 1* to *4*, you should land on the page shown in *Figure
    12**.4*:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.4: GitHub personal access token](img/B21625_12_004.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: GitHub personal access token'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Now, on the `GH_PAGES` under the `GH_PAGES` name.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Expiration** field, select **No expiration**. In a real production
    environment, you might want an expiration date for security reasons, but this
    means you need to renew your token for the set expiration interval.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the `gist`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After selecting the checkboxes under **Select scopes**, you can scroll down
    and select **Generate token**. After clicking on **Generate token**, you will
    see the key of your personal access token; it will look similar to this:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Copy the key to your access token and store it safely; you will need it in the
    next step of your automated deployment configuration.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After copying and saving your key, go to the GitHub repository where you stored
    the code you created during the course of this book.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you need to navigate to the repository settings by clicking on **Settings**
    in your navigation items, as shown in *Figure 12**.5*:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5: GitHub repository settings](img/B21625_12_005.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: GitHub repository settings'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Now, on the left side of the screen under **Security**, click on **Secrets and
    variables**, and in the dropdown, click on **Actions**.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will bring you to the **Actions secrets and variables** page, as shown
    in *Figure 12**.6*:'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.6: Actions secrets and variables](img/B21625_12_006.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: Actions secrets and variables'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: On the **Actions secrets and variables** page, you need to click on the **New
    repository** **secret** button.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you’ll be asked to provide a name and secret. Inside the `GH_PAGES` again,
    and in the **Secret** field, paste the key you saved from the personal access
    token.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After entering the necessary values, click on the **Add secret** button to save
    your repository secret.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If successful, you should now see your `GH_PAGES` secret under the **Repository
    secrets** section on the **Actions secrets and** **variables** page.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .yml file
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve created a personal access token and a repository secret, we
    can continue by creating a `.``yml` file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `.yml` file, follow these steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Start by clicking on **Actions** inside your repository navigation.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on **Set up a** **workflow yourself**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will bring you to a page as shown in *Figure 12**.7*:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.7: main.yml](img/B21625_12_007.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: main.yml'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 12**.7*, GitHub created an empty `main.yml` file for you
    inside the `.github/workflows` folder. You can directly edit the `main.yml` file
    in GitHub, alternatively, you can commit the file and edit it inside VS Code.
    For now, we will simply edit the file inside GitHub and start to add the necessary
    steps to deploy our demo application to GitHub Pages.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Adding a trigger
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You start by adding a trigger to the `.yml` file. In our case, we want our
    `.yml` file to be triggered when we push changes to the main branch of our GitHub
    repository. You add this trigger by adding the following content to the `.``yml`
    file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code snippet starts with a comment; next, we give a name to the
    step we’re declaring, then we use the `on:` keyword to indicate we’re defining
    a trigger, and underneath it, we define the configuration of our trigger – in
    this case, on push of the main branch. The indentation in `.yml` files is important,
    so make sure each line has an extra tab compared to the line above it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Defining jobs to run and the related steps
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After defining the trigger, you need to define jobs to run and the steps for
    the jobs you want to run.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we only have one job, which is a `build` job consisting of multiple
    steps. Start by defining `jobs` and `build` keywords, followed by defining the
    OS for the VM the build job will run on:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Underneath the `runs-on` configuration of the build job, we will define the
    steps needed to perform the build job. The first step you need to perform is to
    check out the GitHub repository:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see in the preceding snippet, the indentation for this step starts
    at the same place as the `runs-on` configuration. We start by defining a comment;
    next, we define a name for the step and what action the step uses. Lastly, we
    provide additional configurations for the step – in this case, `fetch-depth: 0`,
    which indicates the fetch history of all branches and tags inside your GitHub
    repository.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'After fetching the GitHub repository, you need to install NodeJS on the Ubuntu
    machine with the following step:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After installing NodeJS, you need to install `node_modules`. To speed up the
    build job, we will use `pnpm` instead of `npm`. Simply add the following step
    to your `.yml` file to install `node_modules` for your Nx monorepo:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next step in our process will be linting all affected projects:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, we added a new flag to the command we haven’t seen before.
    We’ve added the `–-no-cloud` flag to indicate we’re not using Nx Cloud; otherwise,
    your pipeline will fail by trying to connect with Nx Cloud. Next, we will add
    an extra step to unit test our application:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For simplicity, we will skip `finance-expenses-registration` project. If you
    already fixed all unit tests within the monorepo, you can change the `.yml` file
    to run tests for all affected projects. After running the `lint` and `test` commands,
    we will build the `finance-expenses-registration` project with the following step:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you may have noticed, we added the `–-base-href` flag to the `build` command.
    We need to add a base `href` attribute because GitHub will deploy your application
    to `<GitHub account name>.github.io/<repository name>`. If you don’t use `Effective-Angular`
    as your repository name, you need to change the value of the `–-base-href` flag
    to your own repository name.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'After building the repository, you need to initialize Git on the VM so that
    you can deploy it to GitHub Pages. Simply add the following step to your `.``yml`
    file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After adding the preceding step, we can move to the last step inside our build
    job, this being the deployment of our application to GitHub Pages.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application to GitHub Pages
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be using an `npm` package named `angular-cli-ghpages` to do the deployment
    of the application. Add the following step to your `.``yml` file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see in the preceding code, we run a terminal command using `angular-cli-ghpages`
    to deploy the application, and we need to provide the `GH_PAGES` token we created
    earlier so that GitHub knows we have the necessary authorization to do the deployment.
    After adding the deployment step, you’ve added all steps needed to automatically
    deploy your demo application to GitHub Pages.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: You can now click on the `.yml` file to your main branch, the `.yml` file will
    immediately be triggered. You can see this by navigating back to the **Actions**
    tab of your repository, and there you should see your running workflow. Unfortunately,
    the workflow currently fails.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Fixing workflow fails
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The GitHub Actions workflow failed because of multiple reasons, so let’s fix
    the problems one by one. First, you need to install the `angular-cli-ghpages`
    packages inside your Nx monorepo. Simply run the following command to install
    the package in your monorepo:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we use `pnpm` instead of `npm` in our GitHub Actions workflow. Because
    of this, we need to commit a `pnpm-lock.yaml` file to our GitHub repository. To
    generate this `pnpm-lock.yaml` file, start by globally installing `pnpm` with
    the following `npm` command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After installing `pnpm`, you can start using `pnpm` instead of `npm` for all
    `npm` commands you normally run. I would advise using `pnpm` as it’s a lot faster
    compared to `npm`. Now, to generate your `pnpm-lock.yaml` file, simply run the
    following command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The aforementioned command is similar to the `npm install` command, only using
    `pnpm` instead of `npm`. After running the `pnpm install` command, you can commit
    your changes and merge them with your main branch on GitHub to trigger the workflow
    again. As shown in *Figure 12**.8*, under the **Actions** tab of your repository,
    you should now see two workflow runs, and the second run should succeed:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8: GitHub Actions workflow runs](img/B21625_12_008.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: GitHub Actions workflow runs'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'You now have a successful build, yet you still need to handle the deployment
    step. Go to your repository settings, and on the left side, click on **Pages**
    and add the configuration as shown in *Figure 12**.9*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9: Build and deployment](img/B21625_12_009.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: Build and deployment'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: After configuring the branch to `gh-pages`, as shown in *Figure 12**.9*, the
    deployment process will automatically start, and after a couple of minutes, you
    can find the URL of your application at the top of this GitHub page. Each time
    your workflow runs successfully, the deployment will now be done automatically.
    When you visit the demo application on the deployed URL, you’ll notice nothing
    but your navbar is shown, because the application is deployed on the `<GitHub
    account name>.github.io/<repository name>` URL, and we need to account for the
    repository name when fetching the language files inside our application, so there
    is one last fix to be made.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `app.config.ts` file of the `finance-expenses-registration` project,
    and add the following provider at the top of your `providers` array:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, go to your `transloco-loader.ts` file and adjust it to contain the following
    content:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, we injected the `APP_BASE_HREF` injectable into the file and
    included the `baseHref` property into the URL used to fetch the translations.
    You can now push the changes and merge them with your main branch to trigger the
    workflow again. After your workflow run succeeds, you can click on **Deployments**,
    as shown in *Figure 12**.10*:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10: Deployments](img/B21625_12_010.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.10: Deployments'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on **Deployments**, as shown in *Figure 12**.10*, you’ll be
    navigated to a page where you can see all deployments of your application. On
    this same page, you’ll also find the URL of your deployed application and when
    it was last updated:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11: Deployments list](img/B21625_12_011.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.11: Deployments list'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: When your new deployment is ready, as shown in *Figure 12**.11*, you can navigate
    to your deployed application in the browser again, and now you should see a working
    application, including a table and translated values. There is no data inside
    the table because the mock interceptor is disabled for your production build,
    and there is no API your application can connect with. You now have everything
    in place, and your application is linted, tested, built, and deployed automatically
    each time you push changes to your main GitHub repository.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, this is just a demo application, and there are still plenty
    of improvements to make. So, if you want, you can add more pages, create separate
    library components for the table and other features you want to have, and create
    and convert the application into something truly suited for production purposes.
    You now have all the building blocks needed to effectively use Nx and the Angular
    framework to develop robust and scalable applications.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve reached the end of this book, and first of all, I want to thank you for
    reading the book and congratulate you on finishing it! You learned and did a lot
    during the course of this book. You created your own Nx monorepo, ready to scale
    to hundreds of Angular applications and libraries. You know how to configure the
    Nx monorepo to your personal needs and add the first libraries and applications
    inside your monorepo. After creating the monorepo and adding projects, you learned
    about built-in and custom Nx generators and how to use them to generate boilerplate
    code and bring consistency into your monorepo.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Next, we moved on to Angular and learned about the latest developments of the
    framework, as well as how to utilize powerful features such as component communication,
    Angular routes, and **dependency injection** (**DI**). You learned about pipes,
    directives, and animation after exploring the framework’s newest and most powerful
    features. You saw how to create custom pipes and directives, learned about directive
    composition, and created reusable animation to make your application more appealing
    to the end user.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Further, we did a deep dive into the Angular `forms` module, learning about
    template-driven, reactive, and dynamic forms. Among other things, you learned
    about form validations, the form builder, error handling and creating dynamic
    forms, and form fields. After finishing with Angular forms, we returned to theoretical
    knowledge, exploring different best practices, conventions, and design patterns
    commonly used within Angular applications. You learned about some design patterns
    and best practices, setting you up for the next section of this book, which focused
    on reactive programming and state management. You also learned how to utilize
    RxJS and Signals to create reactive code. You learned about Observable streams,
    pipeable operators, and handling nested data streams. We converted code from RxJS
    to Signals to demonstrate the difference between the two and explained when to
    use which tool to reach the desired outcome. We also explored combining RxJS and
    Signals to get the best of both worlds. When we finished with the basics of RxJS
    and Signals, we used both tools to create a custom state management solution and
    connected it with the component layer of our application using a facade service.
    To finish our state management journey, we converted our custom state management
    solution to an implementation using NgRx, the Angular ecosystem’s most powerful
    and popular state management solution.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: When we finished with reactive programming and state management, we moved on
    to the last section of this book. You learned how to develop applications accessible
    to people from all over the world and of all abilities. You used `transloco` to
    add localization and internationalization to your applications so that people
    of different countries and languages can use your application with their preferred
    formats and languages. Next, you created unit and e2e tests using Jest and Cypress.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we finished the book by creating an automated deployment process that
    uses GitHub Actions to deploy your application to GitHub Pages. After finishing
    this book, you will have all the knowledge needed to develop robust and scalable
    Angular applications using Nx and the latest Angular techniques. You can continue
    with the demo application we created by adding more pages, abstracting the table
    into its own component, creating a feature component for the expenses registration
    so that the page only has to declare one component, adding new features such as
    grouping expenses, planning expenses, uploading receipts, and whatever you seem
    fit. You can also start creating multiple applications within the Nx monorepo
    or start from scratch with your own project. Whatever you want to develop, you
    now have the tools and knowledge to effectively use Angular for applications of
    any scale.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
