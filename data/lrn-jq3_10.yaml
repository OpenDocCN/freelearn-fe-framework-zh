- en: Advanced Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级事件
- en: To build interactive web applications, we need to observe the user's activities
    and respond to them. We have seen that jQuery's event system can simplify this
    task, and we have already used this event system many times.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建交互式的 Web 应用程序，我们需要观察用户的活动并对其做出响应。 我们已经看到，jQuery 的事件系统可以简化此任务，而且我们已经多次使用了这个事件系统。
- en: 'In [Chapter 3](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml), *Handling Events*,
    we touched upon a number of features that jQuery provides for reacting to events.
    In this more advanced chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml)，*处理事件*，我们提到了 jQuery 提供的一些用于对事件做出反应的功能。
    在这一更高级的章节中，我们将涵盖：
- en: Event delegation and the challenges it presents
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件委托及其带来的挑战
- en: Performance pitfalls associated with certain events and how to address them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与某些事件相关的性能陷阱以及如何解决它们
- en: Custom events that we define ourselves
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们自己定义的自定义事件
- en: The special event system that jQuery uses internally for sophisticated interactions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery 内部使用的特殊事件系统用于复杂的交互。
- en: Revisiting events
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视事件
- en: 'For our sample document, we will create a simple photo gallery. The gallery
    will display a set of photos with an option to display additional photos upon
    the click of a link. We''ll also use jQuery''s event system to display textual
    information about each photo when the cursor is over it. The HTML that defines
    the gallery is as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例文档，我们将创建一个简单的照片画廊。 画廊将显示一组照片，并在点击链接时显示额外的照片。 我们还将使用 jQuery 的事件系统在鼠标悬停在照片上时显示每个照片的文本信息。
    定义画廊的 HTML 如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Getting the example code
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 获取示例代码
- en: You can access the example code from the following GitHub repository: [https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下 GitHub 存储库访问示例代码：[https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3).
- en: 'When we apply styles to the photos, arranging them into rows of three will
    make the gallery look like the following screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对照片应用样式时，将它们排列成三行将使画廊看起来像以下屏幕截图：
- en: '![](img/5297_10_01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_10_01.png)'
- en: Loading additional pages of data
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载更多数据页面
- en: 'By now, we are experts at the common task of reacting to a click on a page
    element. When the More Photos link is clicked on, we need to perform an Ajax request
    for the next set of photos and append them to `<div id="gallery">` as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经是对于页面元素点击的常见任务的专家了。当点击“更多照片”链接时，我们需要执行一个 Ajax 请求以获取下一组照片，并将它们附加到 `<div
    id="gallery">` 如下所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Listing 10.1
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.1
- en: 'We also need to update the destination of the More Photos link to point to
    the next page of photos:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新“更多照片”链接的目标，以指向下一页照片：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Listing 10.2
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2
- en: Our `.click()` handler now uses the `pageNum` variable to track the next page
    of photos to request, and uses this to build the new `href` value for the link.
    Since `pageNum` is defined outside the function, its value persists between the
    clicks of the link. We remove the link once we have reached the last page of photos.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `.click()` 处理程序现在使用 `pageNum` 变量来跟踪要请求的下一页照片，并使用它来构建链接的新 `href` 值。 由于 `pageNum`
    在函数外部定义，因此它的值在链接的点击之间保持不变。 当我们到达最后一页照片时，我们会删除该链接。
- en: We should also consider using the HTML5 history API to allow the user to bookmark
    our Ajax-loaded content. You can learn about this API at Dive into HTML5 ([http://diveintohtml5.info/history.html](http://diveintohtml5.info/history.html))
    and implement it quite easily using the History plugin ([https://github.com/browserstate/history.js](https://github.com/browserstate/history.js)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应考虑使用 HTML5 历史记录 API，以允许用户标记我们加载的 Ajax 内容。 您可以在 Dive into HTML5 ([http://diveintohtml5.info/history.html](http://diveintohtml5.info/history.html))
    了解有关此 API 的信息，并使用 History 插件 ([https://github.com/browserstate/history.js](https://github.com/browserstate/history.js))
    很容易地实现它。
- en: Displaying data on hover
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在悬停时显示数据
- en: 'The next feature we want to provide on this page is to display the details
    relating to each photo when the user''s mouse is in that area of the page. For
    our first pass at displaying this information, we can use the `.hover()` method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要在此页面上提供的下一个功能是，当用户的鼠标位于页面的该区域时，显示与每张照片相关的详细信息。 对于显示此信息的首次尝试，我们可以使用 `.hover()`
    方法：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Listing 10.3
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.3
- en: 'When the cursor enters a photo''s boundary, the associated information fades
    in to 70 percent opacity, and when it leaves, the information fades back out:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当光标进入照片的边界时，相关信息以 70% 的不透明度淡入，当光标离开时，信息再次淡出：
- en: '![](img/5297_10_02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_10_02.png)'
- en: 'There are, of course, multiple ways to perform this task. Since a portion of
    each handler is the same, it''s possible to combine the two handlers. We can bind
    a handler to both `mouseenter` and `mouseleave` at the same time by separating
    the event names with a space, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，执行此任务的方法有多种。由于每个处理程序的一部分是相同的，因此可以将两个处理程序合并。我们可以通过用空格分隔事件名称来同时绑定处理程序到`mouseenter`和`mouseleave`，如下所示：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Listing 10.4
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4
- en: With the same handler bound to both events, we check for the event's type to
    determine whether to fade the details in or out. The code locating `<div>`, however,
    is the same for both events, so we can write it just once.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个事件都绑定了相同处理程序，我们检查事件的类型以确定是淡入还是淡出详情。然而，定位`<div>`的代码对于两个事件是相同的，因此我们可以只写一次。
- en: 'This example is admittedly a little contrived, since the shared code in this
    instance is so brief. In other cases, though, this technique can significantly
    reduce code complexity. If we had chosen to add a class on `mouseenter` and remove
    it on `mouseleave`, for example, rather than animate opacity, we could have taken
    care of it with a single statement inside the handler, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 坦率地说，这个例子有点做作，因为此示例中的共享代码如此简短。但是，在其他情况下，这种技术可以显著减少代码复杂性。例如，如果我们选择在`mouseenter`上添加一个类，并在`mouseleave`上删除它，而不是动画化透明度，我们可以在处理程序内部用一个语句解决它，如下所示：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In any case, our script is now working as intended, except that we haven't accounted
    for the additional photos that we load when the user clicks the More Photos link.
    As we noted in [Chapter 3](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml), *Handling
    Events*, event handlers are only attached to the elements that are there when
    we make the `.on()` call. Elements added later, such as from an Ajax call, won't
    have the behavior. We saw that two approaches to addressing this issue are to
    *rebind* event handlers after the new content is introduced, or to initially bind
    the handlers to a containing element and rely on event bubbling. The second approach,
    *event delegation*, is the one we'll pursue here.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们的脚本现在正在按预期工作，除了我们还没有考虑用户点击更多照片链接时加载的附加照片。正如我们在[第三章](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml)中所述，*处理事件*，事件处理程序仅附加到在我们进行`.on()`调用时存在的元素上。稍后添加的元素，例如来自
    Ajax 调用的元素，不会具有行为。我们看到解决此问题的两种方法是在引入新内容后重新绑定事件处理程序，或者最初将处理程序绑定到包含元素并依赖事件冒泡。第二种方法，*事件委托*，是我们将在这里追求的方法。
- en: Event delegation
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件委托
- en: Recall that to implement event delegation by hand, we check the `target` property
    of the `event` object to see if it matches the element that we want to trigger
    the behavior. The event target represents the innermost, or most deeply nested,
    element that is receiving the event. With our sample HTML this time, however,
    we're presented with a new challenge. The `<div class="photo">` elements are unlikely
    to be the event target, since they contain other elements, such as the image itself
    and the image details.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，为了手动实现事件委托，我们会检查事件对象的`target`属性，以查看它是否与我们想要触发行为的元素匹配。事件目标表示接收事件的最内部或最深嵌套的元素。然而，这次我们的示例
    HTML 提出了一个新的挑战。`<div class="photo">`元素不太可能是事件目标，因为它们包含其他元素，比如图像本身和图像详情。
- en: 'What we need is the `.closest()` method, which works its way up the DOM from
    parent to parent until it finds an element that matches a given selector expression.
    If no elements are found, it acts like any other DOM traversal method, returning
    a new empty jQuery object. We can use `.closest()` to find `<div class="photo">`
    from any element it contains, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是`.closest()`方法，它会从父级元素向上遍历 DOM，直到找到与给定选择器表达式匹配的元素为止。如果找不到任何元素，则它会像任何其他
    DOM 遍历方法一样，返回一个新的空 jQuery 对象。我们可以使用`.closest()`方法从任何包含它的元素中找到`<div class="photo">`，如下所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Listing 10.5
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.5
- en: Note that we also needed to change the event types from `mouseenter` and `mouseleave`
    to `mouseover` and `mouseout`, because the former types are only triggered when
    the mouse first enters the gallery `<div>` and finally leaves it, we need the
    handlers to be fired whenever the mouse enters any of the photos *within* that
    wrapping `<div>`. But the latter types introduce yet another scenario, in that
    the detail `<div>` will fade in and out repeatedly unless we include an additional
    check for the `event` object's `relatedTarget` property. Even with the additional
    code, repeated quick mouse movements over and out of photos are handled unsatisfactorily,
    leaving an occasional detail `<div>` visible when it should have faded out.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还需要将事件类型从`mouseenter`和`mouseleave`更改为`mouseover`和`mouseout`，因为前者仅在鼠标首次进入画廊`<div>`并最终离开时触发，我们需要处理程序在鼠标进入该包装`<div>`内的任何照片时被触发。但后者引入了另一种情况，即除非我们包含对`event`对象的`relatedTarget`属性的附加检查，否则详细信息`<div>`将重复淡入和淡出。即使有了额外的代码，快速重复的鼠标移动到照片上和移出照片时的处理也不令人满意，导致偶尔会出现详细信息`<div>`可见，而应该淡出。
- en: Using jQuery's delegation capabilities
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 jQuery 的委托能力
- en: 'Event delegation can be frustratingly difficult to manage by hand when tasks
    become more complex. Fortunately, jQuery''s `.on()` method has delegation built
    into it, which can make life easier for us. Using this capability, our code can
    return to the simplicity of *Listing 10.4*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务变得更加复杂时，手动管理事件委托可能会非常困难。幸运的是，jQuery 的`.on()`方法内置了委托，这可以使我们的生活变得更加简单。利用这种能力，我们的代码可以回到*第
    10.4 编列*的简洁性：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Listing 10.6
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第 10.6 编列
- en: The selector, `#gallery`, remains the same as in *Listing 10.5*, but the event
    types return to the `mouseenter` and `mouseleave` of *Listing 10.4*. When we pass
    in `'div.photo'` as the second argument to `.on()`, jQuery maps `e.currentTarget` to
    the element(s) matched by that selector within `'#gallery'`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器`#gallery`与*第 10.5 编列*保持不变，但事件类型返回到*第 10.4 编列*的`mouseenter`和`mouseleave`。当我们将`'div.photo'`作为`.on()`的第二个参数传入时，jQuery将`e.currentTarget`映射到`'#gallery'`中与该选择器匹配的元素。
- en: Choosing a delegation scope
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择委托范围
- en: 'Because all of the photo elements we are dealing with are contained inside
    `<div id="gallery">`, we have used `#gallery` as our delegation scope in the previous
    example. However, any element that is an ancestor of all of the photos could be
    used as this scope. For example, we could bind our handler to `document`, which
    is the common ancestor of everything on the page:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们处理的所有照片元素都包含在`<div id="gallery">`中，所以我们在上一个示例中使用了`#gallery`作为我们的委托范围。然而，任何一个所有照片的祖先元素都可以用作这个范围。例如，我们可以将处理程序绑定到`document`，这是页面上所有内容的公共祖先：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Listing 10.7
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第 10.7 编列
- en: It can be convenient to attach event handlers directly to `document` when setting
    up event delegation. Since all page elements descend from `document`, we don't
    need to worry about picking the right container. However, this convenience comes
    at a potential performance cost.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置事件委托时，将事件处理程序直接附加到`document`可能会很方便。由于所有页面元素都是从`document`继承而来的，我们不需要担心选择正确的容器。但是，这种便利可能会带来潜在的性能成本。
- en: In a DOM of deeply nested elements, relying on events to bubble all the way
    up a multitude of ancestor elements could be costly. Regardless of which elements
    we are actually observing (by passing in their selector as the second argument
    of `.on()`), if we bind our handler to `document` then an event happening anywhere
    on the page needs to be examined. In *Listing 10.6*, for example, whenever the
    mouse enters any element on the page, jQuery needs to check to see whether it
    is entering a `<div class="photo">` element or not. This can grow costly on large
    pages, especially if delegation is used a lot. By being more specific in our delegation
    context, this work can be reduced.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在深度嵌套的元素 DOM 中，依赖事件冒泡直到多个祖先元素可能是昂贵的。无论我们实际观察的是哪些元素（通过将它们的选择器作为`.on()`的第二个参数传递），如果我们将处理程序绑定到`document`，那么页面上发生的任何事件都需要被检查。例如，在*第
    10.6 编列*中，每当鼠标进入页面上的任何元素时，jQuery 都需要检查它是否进入了一个`<div class="photo">`元素。在大型页面上，这可能会变得非常昂贵，特别是如果委托被大量使用。通过在委托上下文中更加具体，可以减少这种工作。
- en: Delegating early
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 早期委托
- en: 'Despite these efficiency concerns, there are reasons we may yet choose to use
    `document` as our delegation context. In general, we can only bind event handlers
    once the DOM elements they are attached to are loaded, which is why we typically
    place our code inside `$(() => {})`. However, the `document` element is available
    immediately, so we don''t need to wait for the whole DOM to be ready before we
    bind to it. Even if the script is referenced in the `<head>` of the document,
    as it is in our example, we can call `.on()` right away, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些效率问题，但仍有理由选择将`document`作为我们的委托上下文。一般来说，我们只能在DOM元素加载后绑定事件处理程序，这就是为什么我们通常将代码放在`$(()
    => {})`内的原因。但是，`document`元素是立即可用的，因此我们无需等待整个DOM准备就绪才能绑定它。即使脚本被引用在文档的`<head>`中，就像我们的示例中一样，我们也可以立即调用`.on()`，如下所示：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Figure 10.8
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8
- en: Because we're not waiting for the entire DOM to be ready, we can be assured
    that the `mouseenter` and `mouseleave` behaviors will apply to all `<div class="photo">`
    elements as soon as they are rendered on the page.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不是在等待整个DOM准备就绪，所以我们可以确保`mouseenter`和`mouseleave`行为将立即适用于所有页面上呈现的`<div class="photo">`元素。
- en: To see the benefit of this technique, consider a `click` handler directly bound
    to a link. Suppose this handler performs some actions, and also prevents the default
    action of the link (navigating to another page). If we were to wait until the
    whole document was ready, we would run the risk of the user clicking on that link
    before the handler was registered, thereby leaving the current page rather than
    getting the enhanced treatment provided by the script. In contrast, binding a
    delegated event handler to `document` gives us the benefit of binding the event
    early without the cost of having to scan through a complex DOM structure.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这种技术的好处，考虑一个直接绑定到链接的`click`处理程序。假设此处理程序执行某些操作，并且还阻止链接的默认操作（导航到另一个页面）。如果我们等待整个文档准备就绪，我们将面临用户在处理程序注册之前单击该链接的风险，从而离开当前页面而不是得到脚本提供的增强处理。相比之下，将委托事件处理程序绑定到`document`使我们能够在不必扫描复杂的DOM结构的情况下提前绑定事件。
- en: Defining custom events
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义自定义事件
- en: The events that get triggered naturally by the DOM implementations of browsers
    are crucial to any interactive web application. However, we aren't limited to
    this set of events in our jQuery code. We can also add our own custom events.
    We saw this briefly in [Chapter 8](091dd3f4-9663-47df-af02-817487c3038f.xhtml),
    *Developing Plugins*, when we saw how jQuery UI widgets trigger events, but here
    we will investigate how we can create and use custom events outside of plugin
    development.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器的DOM实现自然触发的事件对于任何交互式Web应用程序都至关重要。但是，在我们的jQuery代码中，我们不仅限于此事件集合。我们还可以添加自己的自定义事件。我们在[第8章](091dd3f4-9663-47df-af02-817487c3038f.xhtml)中简要介绍了这一点，*开发插件*，当我们看到jQuery
    UI小部件如何触发事件时，但在这里，我们将研究如何创建和使用自定义事件，而不是插件开发。
- en: Custom events must be triggered manually by our code. In a sense, they are like
    regular functions that we define, in that we can cause a block of code to be executed
    when we invoke it from another place in the script. The `.on()` call for a custom
    event behaves like a function definition, while the `.trigger()` call acts like
    a function invocation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义事件必须由我们的代码手动触发。从某种意义上说，它们就像我们定义的常规函数一样，我们可以在脚本的另一个地方调用它时执行一块代码。对于自定义事件的`.on()`调用的行为类似于函数定义，而`.trigger()`调用的行为类似于函数调用。
- en: However, event handlers are decoupled from the code that triggers them. This
    means that we can trigger events at any time, without knowing in advance what
    will happen when we do. A regular function call causes a single piece of code
    to be executed. A custom event, however, could have no handlers, one handler,
    or many handlers bound to it. In any case, all of the bound handlers will be executed
    when the event is triggered.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，事件处理程序与触发它们的代码是解耦的。这意味着我们可以在任何时候触发事件，而无需预先知道触发时会发生什么。常规函数调用会导致执行单个代码块。但是，自定义事件可能没有处理程序，一个处理程序或许多处理程序绑定到它。无论如何，当事件被触发时，所有绑定的处理程序都将被执行。
- en: 'To illustrate this, we can revise our Ajax loading feature to use a custom
    event. We will trigger a `nextPage` event whenever the user requests more photos,
    and bind handlers that watch for this event and perform the work previously done
    by the `.click()` handler:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们可以修改我们的Ajax加载功能以使用自定义事件。每当用户请求更多照片时，我们将触发一个`nextPage`事件，并绑定处理程序来监视此事件并执行以前由`.click()`处理程序执行的工作：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Listing 10.9
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.9
- en: 'The `.click()` handler now does very little work itself. It triggers the custom
    event and also prevents the default link behavior by calling `.preventDefault()`.
    The heavy lifting is transferred to the new event handlers for the `nextPage`
    event, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`.click()` 处理程序现在几乎不做任何工作。它触发自定义事件，并通过调用 `.preventDefault()` 阻止默认的链接行为。重要的工作转移到了对
    `nextPage` 事件的新事件处理程序中，如下所示：'
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Listing 10.10
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.10
- en: 'Our code really hasn''t changed much since *Listing 10.2*. The largest difference
    is that we''ve split what was once a single function into two. This is simply
    to illustrate that a single event trigger can cause multiple bound handlers to
    fire. Clicking on the More Photos link results in the next group of pictures being
    appended and the link''s `href` attribute being updated, as shown in the following
    screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 *列表 10.2* 以来，我们的代码并没有太多改变。最大的区别在于，我们将曾经的单个函数拆分为两个。这只是为了说明单个事件触发器可以导致多个绑定的处理程序触发。单击“更多照片”链接会导致下一组图片被追加，并且链接的
    `href` 属性会被更新，如下图所示：
- en: '![](img/image_10_001-1.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_10_001-1.jpg)'
- en: With the code changed in *Listing 10.10,* we are also illustrating another application
    of event bubbling. The `nextPage` handlers could be bound to the link that triggers
    the event, but we would need to wait to do this until the DOM was ready. Instead,
    we are binding the handlers to the document itself, which is available immediately,
    so we can do the binding outside of `$(() => {})`. This is, in fact, the same
    principle we took advantage of in *Listing 10.8*, when we moved the `.on()` method
    outside of `$(() => {})`. The event bubbles up and, so long as another handler
    doesn't stop the event propagation, our handlers will be fired.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 *列表 10.10* 中的代码更改，我们还展示了事件冒泡的另一个应用。 `nextPage` 处理程序可以绑定到触发事件的链接上，但我们需要等到DOM准备就绪才能这样做。相反，我们将处理程序绑定到文档本身，这个文档立即可用，因此我们可以在
    `$(() => {})` 外部进行绑定。这实际上是我们在 *列表 10.8* 中利用的相同原理，当我们将 `.on()` 方法移到了 `$(() => {})`
    外部时。事件冒泡起作用，只要另一个处理程序不停止事件传播，我们的处理程序就会被触发。
- en: Infinite scrolling
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限滚动
- en: Just as multiple event handlers can react to the same triggered event, the same
    event can be triggered in multiple ways. We can demonstrate this by adding an
    infinite scrolling feature to our page. This technique lets the user's scroll
    bar manage the loading of content, fetching additional content whenever the user
    reaches the end of what has been loaded thus far.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如多个事件处理程序可以对同一触发的事件作出反应一样，同一事件可以以多种方式触发。我们可以通过为页面添加无限滚动功能来演示这一点。这种技术允许用户的滚动条管理内容的加载，在用户达到到目前为止已加载内容的末尾时，获取更多内容。
- en: 'We''ll begin with a simple implementation, then improve it in successive examples.
    The basic idea is to observe the `scroll` event, measure the current scroll bar
    position when scrolling occurs, and load new content if needed. The following
    code will trigger the `nextPage` event we defined in *Listing 10.10*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的实现开始，然后在后续示例中改进它。基本思想是观察 `scroll` 事件，测量滚动时的当前滚动条位置，并在需要时加载新内容。以下代码将触发我们在
    *列表 10.10* 中定义的 `nextPage` 事件：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Listing 10.11
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.11
- en: The `checkScrollPosition()` function we've introduced here is set as a handler
    for the window's `scroll` event. This function computes the distance from the
    top of the document to the bottom of the window and then compares this distance
    to the total height of the main container in the document. As soon as these reach
    equality, we need to fill the page with additional photos, so we trigger the `nextPage`
    event.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里介绍的 `checkScrollPosition()` 函数被设置为窗口 `scroll` 事件的处理程序。此函数计算文档顶部到窗口底部的距离，然后将此距离与文档中主容器的总高度进行比较。一旦它们达到相等，我们就需要用额外的照片填充页面，因此我们触发
    `nextPage` 事件。
- en: 'As soon as we bind the `scroll` handler, we immediately trigger it with a call
    to `.trigger(''scroll'')`. This kick-starts the process, so that if the page is
    not initially filled with photos, an Ajax request is made right away to append
    more photos:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们绑定了 `scroll` 处理程序，我们立即通过调用 `.trigger('scroll')` 触发它。这启动了这个过程，因此如果页面最初未填充照片，则立即进行Ajax请求以附加更多照片：
- en: '![](img/image_10_002-1.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_10_002-1.jpg)'
- en: Custom event parameters
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义事件参数
- en: When we define functions, we can set up any number of parameters to be filled
    with argument values when we actually call the function. Similarly, when triggering
    a custom event, we may want to pass along additional information to any registered
    event handlers. We can accomplish this by using custom event parameters.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义函数时，我们可以设置任意数量的参数，以在实际调用函数时填充参数值。同样，当触发自定义事件时，我们可能想向任何注册的事件处理程序传递额外信息。我们可以通过使用自定义事件参数来实现这一点。
- en: The first parameter defined for any event handler, as we've seen, is the DOM
    event object, as enhanced and extended by jQuery. Any additional parameters we
    define are available for our discretionary use.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 任何事件处理程序定义的第一个参数，正如我们所见，是 DOM 事件对象，由 jQuery 增强和扩展。我们定义的任何额外参数都可供自行决定使用。
- en: 'To see this in action, we''ll add a new option to the `nextPage` event from
    *Listing 10.10*, allowing us to scroll the page down to display the newly-added
    content:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到此功能的实际效果，我们将在 *清单 10.10* 的`nextPage`事件中添加一个新选项，允许我们向下滚动页面以显示新添加的内容：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Listing 10.12
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10.12
- en: We have now added a `scrollToVisible` parameter to the event callback. The value
    of this parameter determines whether we perform the new functionality, which entails
    measuring the position of the new content and scrolling to it. Measurement is
    easy using the `.offset()` method, which returns the top and left coordinates
    of the new content. To move down the page, we call the `.scrollTop()` method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为事件回调添加了一个`scrollToVisible`参数。该参数的值决定了我们是否执行新功能，该功能包括测量新内容的位置并滚动到该位置。使用`.offset()`方法来进行测量非常容易，该方法返回新内容的顶部和左侧坐标。要向页面下移，我们调用`.scrollTop()`方法。
- en: 'Now, we need to pass an argument into the new parameter. All that is required
    is providing an extra value when invoking the event using `.trigger()`. When `newPage`
    is triggered via scrolling, we don''t want the new behavior to occur, as the user
    is already manipulating the scroll position directly. When the More Photos link
    is clicked, on the other hand, we want the newly added photos to be displayed
    on screen, so we will pass a value of `true` to the handler:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要向新参数传递一个参数。所需的一切就是在使用`.trigger()`调用事件时提供额外的值。当通过滚动触发`newPage`时，我们不希望出现新行为，因为用户已经直接操作了滚动位置。另一方面，当点击更多照片链接时，我们希望新添加的照片显示在屏幕上，因此我们将一个值为`true`传递给处理程序：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Listing 10.13
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10.13
- en: In the call to `.trigger()`, we are now providing an array of values to pass
    to event handlers. In this case, the value of `true` will be given to the `scrollToVisible`
    parameter of the event handler in *Listing 10.12*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`.trigger()`时，我们现在提供了一个值数组以传递给事件处理程序。在这种情况下，值`true`将被传递到 *清单 10.12* 中事件处理程序的`scrollToVisible`参数。
- en: Note that custom event parameters are optional on both sides of the transaction.
    We have two calls to `.trigger('nextPage')` in our code, only one of which provides
    argument values; when the other is called, this does not result in an error, but
    rather each parameter in the handler has the value `undefined`. Similarly, the
    lack of a `scrollToVisible` parameter in one of our `.on('nextPage')` calls is
    not an error; if a parameter does not exist when an argument is passed, that argument
    is simply ignored.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，自定义事件参数在交易的双方都是可选的。我们的代码中有两个对`.trigger('nextPage')`的调用，其中只有一个提供了参数值；当调用另一个时，这不会导致错误，而是处理程序中的每个参数都具有值`undefined`。同样，一个`.on('nextPage')`调用中缺少`scrollToVisible`参数也不是错误；如果在传递参数时不存在参数，那么该参数将被简单地忽略。
- en: Throttling events
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件节流
- en: A major issue with the infinite scrolling feature as we've implemented it in
    *Listing 10.10* is its performance impact. While our code is brief, the `checkScrollPosition()`
    function does need to do some work to measure the dimensions of the page and window.
    This effort can accumulate rapidly, because in some browsers the `scroll` event
    is triggered repeatedly during the scrolling of the window. The result of this
    combination could be choppy or sluggish performance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *清单 10.10* 中实现的无限滚动功能的一个主要问题是性能影响。虽然我们的代码很简洁，但`checkScrollPosition()`函数确实需要做一些工作来测量页面和窗口的尺寸。这种努力可能会迅速积累，因为在一些浏览器中，`scroll`事件在滚动窗口时会重复触发。这种组合的结果可能是不流畅或性能低下。
- en: 'Several native events have the potential for frequent triggering. Common culprits
    include `scroll`, `resize`, and `mousemove`. To account for this, we will implement
    **event throttling**. This technique involves limiting our expensive calculations
    so that they only occur after some of the event occurrences, rather than each
    one. We can update our code from *Listing 10.13* to implement this technique as
    follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 几个本地事件有可能频繁触发。常见的罪魁祸首包括 `scroll`、`resize` 和 `mousemove`。为了解决这个问题，我们将实现**事件节流**。这种技术涉及限制我们的昂贵计算，使其仅在一些事件发生之后才发生，而不是每次都发生。我们可以更新我们的代码，以实现这种技术，如下所示：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Listing 10.14
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10.14
- en: Rather than setting `checkScrollPosition()` directly as the `scroll` event handler,
    we are using the JavaScript `setTimeout` function to defer the call by `250` milliseconds.
    More importantly, we are checking for a running timer first before doing any work.
    Since checking the value of a simple variable is extremely fast, most of the calls
    to our event handler will return almost immediately. The `checkScrollPosition()`
    call will only happen when a timer completes, which will at most be every 250
    milliseconds.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不直接将 `checkScrollPosition()` 设置为 `scroll` 事件处理程序，而是使用 JavaScript 的 `setTimeout`
    函数将调用推迟了 `250` 毫秒。更重要的是，在做任何工作之前，我们首先检查是否有正在运行的计时器。由于检查一个简单变量的值非常快，我们的大多数事件处理程序调用几乎立即返回。`checkScrollPosition()`
    调用只会在定时器完成时发生，最多每 250 毫秒一次。
- en: We can easily adjust the `setTimeout()` value to a comfortable number that strikes
    a reasonable compromise between instant feedback and low performance impact. Our
    script is now a good web citizen.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松调整 `setTimeout()` 的值，以达到舒适的数值，从而在即时反馈和低性能影响之间取得合理的折中。我们的脚本现在是一个良好的网络公民。
- en: Other ways to perform throttling
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他执行节流的方式
- en: 'The throttling technique we''ve implemented is efficient and simple, but it
    is not the only solution. Depending on the performance characteristics of the
    action being throttled and typical interaction with the page, we may, for instance,
    want to institute a single timer for the page rather than create one when an event
    begins:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实施的节流技术既高效又简单，但这并不是唯一的解决方案。根据节流的操作的性能特征和与页面的典型交互，我们可能需要建立页面的单个定时器，而不是在事件开始时创建一个定时器：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Listing 10.15
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10.15
- en: Unlike our previous throttling code, this polling solution uses a single call
    to the JavaScript `setInterval()` function to begin checking the state of the
    `scrolled` variable every `250` milliseconds. Any time a scroll event occurs,
    `scrolled` is set to `true`, ensuring that the next time the interval passes,
    `checkScrollPosition()` will be called. The result is similar to that of *Listing
    10.14*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们以前的节流代码不同，这种轮询解决方案使用一次 JavaScript `setInterval()` 函数调用来开始每`250`毫秒检查 `scrolled`
    变量的状态。每次发生滚动事件时，`scrolled` 被设置为 `true`，确保下次间隔经过时将调用 `checkScrollPosition()`。其结果类似于*清单
    10.14*。
- en: A third solution for limiting the amount of processing performed during frequently-repeated
    events is **debouncing**. This technique, named after the post-processing required
    to handle repeated signals sent by electrical switches, ensures that only a single,
    final event is acted upon even when many have occurred. We will see an example
    of this technique in [Chapter 13](6bf83967-6247-454a-b1d2-3f3f48937865.xhtml),
    *Advanced Ajax*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 限制在频繁重复事件期间执行的处理量的第三种解决方案是**去抖动**。这种技术以电子开关发送的重复信号需要处理后的名字命名，确保即使发生了很多事件，也只有一个单一的最终事件被执行。我们将在[第
    13 章](6bf83967-6247-454a-b1d2-3f3f48937865.xhtml)*高级 Ajax*中看到这种技术的示例。
- en: Extending events
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展事件
- en: Some events, such as `mouseenter` and `ready`, are designated as **special events**
    by the jQuery internals. These events use the elaborate event extension framework
    offered by jQuery. Such events get the opportunity to take action at various times
    in the life cycle of an event handler. They may react to handlers being bound
    or unbound, and they can even have preventable default behaviors like clicked
    links or submitted forms do. The event extension API lets us create sophisticated
    new events that act much like native DOM events.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一些事件，如 `mouseenter` 和 `ready`，被 jQuery 内部指定为**特殊事件**。这些事件使用 jQuery 提供的复杂事件扩展框架。这些事件有机会在事件处理程序的生命周期中的各个时刻采取行动。它们可能会对绑定或解绑的处理程序做出反应，甚至可以有可阻止的默认行为，如点击链接或提交表单。事件扩展
    API 允许我们创建类似于本机 DOM 事件的复杂新事件。
- en: The throttling behavior we implemented for scrolling in *Listing 10.13* is useful,
    and we may want to generalize it for use in other projects. We can accomplish
    this by creating a new event that encapsulates the throttling technique within
    the special event hooks.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为*Listing 10.13*中的滚动实现的节流行为是有用的，我们可能想要将其推广到其他项目中使用。我们可以通过在特殊事件钩子内封装节流技术来实现这一点。
- en: 'To implement special behavior for an event, we add a property to the `$ .event.special`
    object. This added property, which is itself an object, has our event name as
    its key. It can contain callbacks called at many different specific times in an
    event''s life cycle, including the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要为事件实现特殊行为，我们向`$ .event.special`对象添加一个属性。这个添加的属性本身是一个对象，它的键是我们的事件名称。它可以包含在事件生命周期中许多不同特定时间调用的回调函数，包括以下内容：
- en: '`add`: This is called every time a handler for this event is bound'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add`: 每当为该事件的处理程序绑定时调用'
- en: '`remove`: This is called every time a handler for the event is unbound'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove`: 每当为事件的处理程序解绑时调用'
- en: '`setup`: This is called when a handler is bound for the event, but only if
    no other handlers for that event are bound to the element'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup`: 当为事件绑定处理程序时调用，但仅当没有为元素绑定该事件的其他处理程序时'
- en: '`teardown`: This is the converse of `setup`, called when the last handler for
    the event is unbound from an element'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`teardown`: 这是`setup`的反义词，当从元素解绑事件的最后一个处理程序时调用'
- en: '`_default`: This becomes the default behavior of the event, called unless the
    default action is prevented by an event handler'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_default`: 这将成为事件的默认行为，在事件处理程序阻止默认操作之前调用'
- en: 'These callbacks can be used in some very creative ways. A fairly common scenario,
    which we''ll explore in our example code, is to automatically trigger the event
    in response to a browser condition. It would be wasteful to monitor the state
    and trigger events if no handlers are listening for the event, so we can use the
    `setup` callback to initiate this work only when needed:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些回调函数可以以一些非常有创意的方式使用。一个相当普遍的情景，我们将在我们的示例代码中探讨，就是根据浏览器条件自动触发事件。如果没有处理程序监听事件，监听状态并触发事件是很浪费的，所以我们可以使用`setup`回调仅在需要时启动这项工作：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Listing 10.16
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 10.16
- en: For our scroll throttling event, we need to bind a regular `scroll` handler
    that uses the same `setTimeout` technique as the one we developed in *Listing
    10.14*. Whenever a timer completes, the custom event will be triggered. Since
    we only need one timer per element, the `setup` callback will serve our needs.
    By supplying a custom namespace for the `scroll` handler, we can easily remove
    the handler when `teardown` is called.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的滚动节流事件，我们需要绑定一个常规的`scroll`处理程序，该处理程序使用与我们在*Listing 10.14*中开发的相同的`setTimeout`技术。每当计时器完成时，将触发自定义事件。由于我们每个元素只需要一个计时器，因此`setup`回调将满足我们的需求。通过为`scroll`处理程序提供自定义命名空间，我们可以在调用`teardown`时轻松地移除处理程序。
- en: 'To use this new behavior, all we have to do is bind handlers to the `throttledScroll`
    event. This greatly simplifies the event binding code, and gives us a nicely reusable
    throttling mechanism, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种新行为，我们只需为`throttledScroll`事件绑定处理程序。这极大地简化了事件绑定代码，并为我们提供了一个非常可重用的节流机制，如下所示：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Listing 10.17
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 10.17
- en: More about special events
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于特殊事件的更多信息
- en: 'While this chapter covers advanced techniques for dealing with events, the
    event extension API is very advanced indeed, and a detailed investigation is beyond
    the scope of this book. The previous `throttledScroll` example covers the simplest
    and most common usage of the facility. Other possible applications include the
    following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章涵盖了处理事件的高级技术，但事件扩展 API 确实非常先进，详细的调查超出了本书的范围。前面的`throttledScroll`示例涵盖了该功能的最简单和最常见的用法。其他可能的应用包括以下内容：
- en: Modifying the event object, so that event handlers have different information
    available to them
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改事件对象，以便事件处理程序可以获得不同的信息
- en: Causing events that occur in one place in the DOM to trigger behaviors associated
    with different elements
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致在 DOM 中的一个位置发生的事件触发与不同元素相关联的行为
- en: Reacting to new and browser-specific events that are not standard DOM events
    and allowing jQuery code to react to them as if they are standard
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对不是标准 DOM 事件的新的和特定于浏览器的事件做出反应，并允许 jQuery 代码对其做出反应，就像它们是标准的一样
- en: Changing the way event bubbling and delegation are handled
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变事件冒泡和委托的处理方式
- en: Many of these tasks can be quite complicated. For an in-depth take on the possibilities
    offered by the event extension API, we can investigate the jQuery Learning Center's
    documentation at [http://learn.jquery.com/events/event-extensions/](http://learn.jquery.com/events/event-extensions/).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务中的许多都可能非常复杂。要深入了解事件扩展API提供的可能性，我们可以查阅jQuery学习中心的文档[http://learn.jquery.com/events/event-extensions/](http://learn.jquery.com/events/event-extensions/)。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The jQuery event system can be very powerful if we choose to leverage it fully.
    In this chapter, we have seen several aspects of the system, including event delegation
    methods, custom events, and the event extension API. We have also found ways of
    sidestepping pitfalls associated with delegation and with events that are triggered
    frequently.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择充分利用jQuery事件系统，它可以非常强大。在本章中，我们已经看到了系统的几个方面，包括事件委托方法、自定义事件和事件扩展API。我们还找到了绕过委托和频繁触发事件相关问题的方法。
- en: Further reading
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: A complete list of event methods is available in [Appendix B](d9485d2d-4300-48c1-825b-1c26c9b57a66.xhtml),
    *Quick Reference,* of this book, or in the official *jQuery documentation* at
    [http://api.jquery.com/](http://api.jquery.com/).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的[附录 B](d9485d2d-4300-48c1-825b-1c26c9b57a66.xhtml)，*快速参考*中提供了完整的事件方法列表，或者在官方的*jQuery文档*中查看[http://api.jquery.com/](http://api.jquery.com/)。
- en: Exercises
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The following challenge exercise may require the use of the official jQuery
    documentation at [http://api.jquery.com/](http://api.jquery.com/).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下挑战练习可能需要使用官方jQuery文档[http://api.jquery.com/](http://api.jquery.com/)。
- en: When the user clicks on a photo, add or remove the `selected` class on the photo
    `<div>`. Make sure this behavior works even for photos added later using the Next
    Page link.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击照片时，在照片`<div>`上添加或删除`selected`类。确保即使是使用下一页链接后添加的照片，这种行为也能正常工作。
- en: Add a new custom event called `pageLoaded` that fires when a new set of images
    has been added to the page.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`pageLoaded`的新自定义事件，当新的图像集已添加到页面上时触发。
- en: Using the `nextPage` and `pageLoaded` handlers, show a Loading message at the
    bottom of the page only while a new page is being loaded.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`nextPage`和`pageLoaded`处理程序，仅在加载新页面时在页面底部显示一个加载消息。
- en: Bind a `mousemove` handler to photos that logs the current mouse position (using
    `console.log()`).
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`mousemove`处理程序绑定到照片上，记录当前鼠标位置（使用`console.log()`）。
- en: Revise this handler to perform the logging no more than five times a second.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改此处理程序，以使日志记录不超过每秒五次。
- en: 'Challenge: Create a new special event named `tripleclick` that fires when the
    mouse button is clicked on three times within 500 milliseconds. To test the event,
    bind a `tripleclick` handler to the `<h1>` element which hides and reveals the
    contents of `<div id="gallery">`.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挑战：创建一个名为`tripleclick`的新特殊事件，当鼠标按钮在500毫秒内点击三次时触发。为了测试该事件，将一个`tripleclick`处理程序绑定到`<h1>`元素上，该处理程序隐藏和显示`<div
    id="gallery">`的内容。
