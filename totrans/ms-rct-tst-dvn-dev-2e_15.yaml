- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding Animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animation lends itself to test-driven development just as much as any other
    feature. In this chapter, we’ll animate the Logo turtle movement as the user inputs
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of animation in Spec Logo:'
  prefs: []
  type: TYPE_NORMAL
- en: First, when the turtle moves forward. For example, when the user enters `forward
    100` as an instruction, the turtle should move 100 units along, at a fixed speed.
    As it moves, it will draw a line behind it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, when the turtle rotates. For example, if the user types `rotate 90`,
    then the turtle should rotate slowly until it has made a quarter turn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Much of this chapter is about test-driving the `window.requestAnimationFrame`
    function. This is the browser API that allows us to animate visual elements on
    the screen, such as the position of the turtle or the length of a line. The mechanics
    of this function are explained in the third section of this chapter, *Animating
    with requestAnimationFrame*.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of manual testing
  prefs: []
  type: TYPE_NORMAL
- en: When writing animation code, it’s natural to want to visually check what we’re
    building. Automated tests aren’t enough. Manually testing is also important because
    animation is not something that most programmers do every day. When something
    is new, it’s often better to do lots of manual tests to verify behavior in addition
    to your automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, while preparing for this chapter, I did a *lot* of manual testing.
    The walk-through presented here experiments with several different approaches.
    There were many, many times that I opened my browser to type `forward 100` or
    `right 90` to visually verify what was happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an animated line component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating with `requestAnimationFrame`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling animations with `cancelAnimationFrame`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Varying animation behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code we’ll write is relatively complicated compared to the code in the rest
    of the book, so we need to do some upfront design first.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have gained a deep understanding of how to
    test-drive one of the more complicated browser APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter15)'
  prefs: []
  type: TYPE_NORMAL
- en: Designing animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you read through this section, you may wish to open `src/Drawing.js` and
    read the existing code to understand what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: The current `Drawing` component shows a static snapshot of how the drawing looks
    at this point. It renders a set of **Scalable Vector Graphics** (**SVG**) lines
    to represent the path the turtle has taken to this point, and a triangle to represent
    the turtle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component makes use of two child components:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Turtle` component is displayed once and draws an SVG triangle at the given
    location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `StaticLines` component is a set of SVG lines that are drawn onscreen to
    represent the drawn commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will add a new `AnimatedLine` component that represents the current line
    being animated. As lines complete their animation, they will move into the `StaticLines`
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll need to do some work to convert this from a static view to an animated
    representation.
  prefs: []
  type: TYPE_NORMAL
- en: As it stands, the component takes a `turtle` prop and a `drawCommands` prop.
    The `turtle` prop is the current position of the turtle, given that all the draw
    commands have already been drawn.
  prefs: []
  type: TYPE_NORMAL
- en: In our new animated drawing, we will still treat `drawCommands` as a list of
    commands to execute. But rather than relying on a `turtle` prop to tell us where
    the turtle is, we’ll store the *current* position of the turtle as a component
    state. We will work our way through the `drawCommands` array, one instruction
    at a time, and update the turtle component state as it animates. Once all instructions
    are completed, the turtle component state will match what would have originally
    been set for the `turtle` prop.
  prefs: []
  type: TYPE_NORMAL
- en: The turtle always starts at the `0,0` coordinate with an angle of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to keep track of which commands have already been animated. We’ll
    create another component state variable, `animatingCommandIndex`, to denote the
    index of the array item that is currently being animated.
  prefs: []
  type: TYPE_NORMAL
- en: We start animating at the `0` index. Once that command has been animated, we
    increment the index by `1`, moving along to the next command, and animate that.
    The process is repeated until we reach the end of the array.
  prefs: []
  type: TYPE_NORMAL
- en: This design means that the user can enter new `drawCommands` at the prompt even
    if animations are currently running. The component will take care to redraw with
    animations at the same point it left off at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, are two types of draw commands: `drawLine` and `rotate`. Here are
    a couple of examples of commands that will appear in the `drawCommands` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each type of animation will need to be handled differently. So, for example,
    the `AnimatedLine` component will be hidden when the turtle is rotating.
  prefs: []
  type: TYPE_NORMAL
- en: 'That about covers it. We’ll follow this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with building the `AnimatedLine` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `useEffect` hook in `Drawing` that calls the `window.requestAnimationFrame`
    function to animate `drawLine` commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancel the animation of `drawLine` commands when new instructions are added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the animation of turtle rotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started with the `AnimatedLine` component.
  prefs: []
  type: TYPE_NORMAL
- en: Building an animated line component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll create a new `AnimatedLine` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'This component contains no animation logic itself but, instead, draws a line
    from the start of the line being animated to the current turtle position. Therefore,
    it needs two props: `commandToAnimate`, which would be one of the `drawLine` command
    structures shown previously, and the `turtle` prop, containing the position.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `test/AnimatedLine.test.js`, and prime it with the following
    imports and `describe` block setup. Notice the inclusion of the sample instruction
    definition for `horizontalLine`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the first test, which checks the starting position of the line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file, `src/AnimatedLine.js`, and make your test pass by using
    the following implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On to the next test. In this one, we explicitly set the turtle values so that
    it’s clear to see where the expected values come from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, we just need to set the `x2` and `y2` props on the line
    element, pulling that in from the turtle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we need two tests to set the `strokeWidth` and `stroke` props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finish off the component by adding in those two props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That completes the `AnimatedLine` component.
  prefs: []
  type: TYPE_NORMAL
- en: Next, it’s time to add it into `Drawing`, by setting the `commandToAnimate`
    prop to the current line that’s animating and using `requestAnimationFrame` to
    vary the position of the `turtle` prop.
  prefs: []
  type: TYPE_NORMAL
- en: Animating with requestAnimationFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will use the `useEffect` hook in combination with `window.requestAnimationFrame`
    to adjust the positioning of `AnimatedLine` and `Turtle`.
  prefs: []
  type: TYPE_NORMAL
- en: The `window.requestAnimationFrame` function is used to animate visual properties.
    For example, you can use it to increase the length of a line from 0 units to 200
    units over a given time period, such as 2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this work, you provide it with a callback that will be run at the next
    repaint interval. This callback is provided with the current animation time when
    it’s called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you know the start time of your animation, you can work out the elapsed animation
    time and use that to calculate the current value of your animated property.
  prefs: []
  type: TYPE_NORMAL
- en: The browser can invoke your callback at a very high refresh rate, such as 60
    times per second. Because of these very small intervals of time, your changes
    appear as a smooth animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the browser only invokes your callback once for every requested frame.
    That means it’s your responsibility to repeatedly call the `requestAnimationFrame`
    function until the animation time reaches your defined end time, as in the following
    example. The browser takes care of only invoking your callback when the screen
    is due to be repainted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we progress through this section, you’ll see how you can use this to modify
    the component state (such as the position of `AnimatedLine`), which then causes
    your component to rerender.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by getting rid of the existing turtle value from the Redux store—we’re
    no longer going to use this, and instead, rely on the calculated turtle position
    from the `drawCommands` array:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `test/Drawing.test.js` and find the test with the name `passes the turtle
    x, y and angle as props to Turtle`. Replace it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in `src/Drawing.js`, you can remove the turtle value that was extracted
    from the Redux store, by replacing the `useSelector` call with this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll replace the existing turtle value with a new state variable. This will
    come in useful later when we start moving the position of the turtle. Start by
    importing `useState` into `src/Drawing.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, just below the call to `useSelector`, add another call to `useState`.
    After this change, your test should be passing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in `test/Drawing.test.js`, stub out the `requestAnimationFrame` function
    in the `describe` block’s `beforeEach`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following new `describe` block and test to the bottom of the existing
    `describe` block, inside the existing `describe` block (so it’s nested). It defines
    an initial state of `horizontalLineDrawn` that has a single line—this line is
    defined in the `sampleInstructions` file. The test states that we expect `requestAnimationFrame`
    to be invoked when the component mounts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, open `src/Drawing.js` and start by importing the `useEffect`
    hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the new `useEffect` hook into the `Drawing` component. Add the following
    three lines, just above the `return` statement JSX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we’re now in the realms of `useEffect`, any actions that cause updates
    to the component state must occur within an `act` block. That includes any triggered
    animation frames, and we’re about to trigger some. So, back in `test/Drawing.test.js`,
    add the `act` import now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need an import for `AnimatedLine` because, in the next test, we’ll
    assert that we render it. Add the following import, together with its spy setup,
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The call to `requestAnimationFrame` requires a `handler` function as an argument.
    The browser will then call this function during the next animation frame. For
    the next test, we’ll check that the turtle is at the start of the first line when
    the timer first fires. We need to define a new helper to do this, which is `triggerRequestAnimationFrame`.
    In a browser environment, this call would happen automatically, but in our test,
    we play the role of the browser and trigger it in code. It’s this call that must
    be wrapped in an `act` function call since our handler will cause the component
    state to change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’re ready to write tests for the animation cycle. The first one is a
    simple one: at time zero, the turtle position is placed at the *start* of the
    line. If you check the definition in `test/sampleInstructions.js`, you’ll see
    that `horizontalLine` starts at position `100,100`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the turtle position for animation
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the `AnimatedLine` component draws a line from the start position
    of the `drawLine` instruction to the current turtle position. That turtle position
    is then animated, which has the effect of the `AnimatedLine` instance growing
    in length until it finds the end position of the `drawLine` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making this test pass will be a bit of a *big bang*. To start, extend `useEffect`
    as shown. We define two variables, `commandToAnimate` and `isDrawingLine`, which
    we use to determine whether we should animate at all. The `isDrawingLine` test
    is necessary because some of the existing tests send no draw commands at all to
    the component, in which case `commandToAnimate` will be `null`. Yet another test
    passes a command of an unknown type into the component, which would also blow
    up if we tried to pull out `x1` and `y1` from it. That explains the call to `isDrawLineCommand`—a
    function that is defined already at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the functional update setter
  prefs: []
  type: TYPE_NORMAL
- en: This code uses the *functional update* variant of `setTurtle` that takes a function
    rather than a value. This is used when the new state value depends on the old
    value. Using this form of setter means that the turtle doesn’t need to be in the
    dependency list of `useEffect` and won’t cause the `useEffect` hook to reset itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we still aren’t rendering `AnimatedLine`, which is what our
    test expects. Let’s fix that now. Start by adding the import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert this just below the JSX for `StaticLines`. At this point, your test
    should be passing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need a further test to check that we don’t render `AnimatedLine` if no lines
    are being animated. Add the next test as shown, but don’t add it in the `movement
    animation` block; instead, place it into the parent context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by wrapping the `AnimatedLine` component with a ternary. We
    simply return `null` if `isDrawingLine` is false:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ve handled what the *first* animation frame should do; now let’s code up
    the *next* animation frame. In the following test, there are *two* calls to `triggerRequestAnimationFrame`.
    The first one is used to signify that animation is started; the second one allows
    us to move. We need the first call (with a time index of `0`) to be able to mark
    the time at which the animation started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using animation duration to calculate the distance moved
  prefs: []
  type: TYPE_NORMAL
- en: The `handleDrawLineFrame` function, when called by the browser, will be passed
    a time parameter. This is the current duration of the animation. The turtle travels
    at a constant velocity, so knowing the duration allows us to calculate where the
    turtle is.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this pass, first, we need to define a couple of functions. Scroll up
    `src/Drawing.js` until you see the definition for `isDrawLineCommand` and add
    these two new definitions there. The `distance` and `movementSpeed` functions
    are used to calculate the duration of the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can calculate the duration of the animation; modify `useEffect` as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By declaring `duration` as the very first line in the `useEffect` block, the
    variable is in scope for the `requestAnimationFrame` handler to read it to calculate
    distance. To do that, we take the elapsed time and divide it by the total duration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’re making great progress! In the previous test, we assumed that the starting
    time is `0`, but actually, the browser could give us any time as the start time
    (the time it gives us is known as the **time origin**). So, let’s make sure our
    calculations work for a non-zero start time. Add the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by introducing the `start` and `elapsed` times, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our components need to call `requestAnimationFrame` repeatedly until the duration
    is reached. At that point, the line should have been fully drawn. In this test,
    we trigger three animation frames, and we expect `requestAnimationFrame` to have
    been called three times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, we need to ensure that `handleDrawLineFrame` triggers another
    `requestAnimationFrame` when it’s run. However, we should only do that until the
    time that the duration has been reached. Make that pass happen by wrapping the
    `setTurtle` and `requestAnimationFrame` calls with the following conditional:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the next test, we will check that when a line has “finished” being drawn,
    we move on to the next one, if there is one (otherwise, we stop). Add a new `describe`
    block below the `describe` block we’ve just implemented, with the following test.
    The second time stamp, `500`, is after the duration that is required for `horizontalLine`
    to be drawn and therefore, `AnimatedLine` should show `verticalLine` instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, we need to introduce a pointer to the command that is currently
    being animated. This will start at the `0` index, and we’ll increment it each
    time the animation finishes. Add the following new state variable at the top of
    the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `commandToAnimate` constant to use this new variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `else` clause to the conditional in `handleDrawLineFrame` that increments
    the value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the final test, we want to make sure that only previously animated commands
    are sent to `StaticLines`. The currently animating line will be rendered by `AnimatedLine`,
    and lines that haven’t been animated yet shouldn’t be rendered at all:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, update `lineCommands` to take only the portion of `drawCommands`
    up until the current `animatingCommandIndex` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although the latest test will now pass, the existing test, `sends only line
    commands to StaticLines`, will now break. Since our latest test covers essentially
    the same functionality, you can safely delete that test now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you run the app, you’ll now be able to see lines being animated as they are
    placed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll ensure the animations behave nicely when multiple
    commands are entered by the user at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling animations with cancelAnimationFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `useEffect` hook we’ve written has `commandToAnimate` and `isDrawingLine`
    in its dependency list. That means that when either of these values updates, the
    `useEffect` hook is torn down and will be restarted. But there are other occasions
    when we want to cancel the animation. One time this happens is when the user resets
    their screen.
  prefs: []
  type: TYPE_NORMAL
- en: If a command is currently animating when the user clicks the **Reset** button,
    we don’t want the current animation frame to continue. We want to clean that up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a test for that now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test at the bottom of `test/Drawing.test.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll also need to change the `beforeEach` block, making the `requestAnimationFrame`
    stub return a dummy cancel token, and adding in a new stub for the `cancelAnimationFrame`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make the test pass, update the `useEffect` hook to store the `cancelToken`
    value that the `requestAnimationFrame` function returns when it’s called. Then
    return a cleanup function from the `useEffect` hook, which uses that token to
    cancel the next requested frame. This function will be called by React when it
    tears down the hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we don’t want to run this cleanup if `cancelToken` hasn’t been set.
    The token won’t have been set if we aren’t currently rendering a line. We can
    prove that with the following test, which you should add now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unmounting a component
  prefs: []
  type: TYPE_NORMAL
- en: This test shows how you can mimic an *unmount* of a component in React, which
    is simply by rendering `<React.Fragment />` in place of the component under test.
    React will unmount your component when this occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make that pass, simply wrap the returned cleanup function in a conditional:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s all we need to do for animating the `drawLine` commands. Next up is rotating
    the turtle.
  prefs: []
  type: TYPE_NORMAL
- en: Varying animation behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our lines and turtle are now animating nicely. However, we still need to handle
    the second type of draw command: rotations. The turtle will move at a constant
    speed when rotating to a new angle. A full rotation should take 1 second to complete,
    and we can use this to calculate the duration of the rotation. For example, a
    quarter rotation will take 0.25 seconds to complete.'
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, we started with a test to check that we were calling `requestAnimationFrame`.
    This time, that test isn’t essential because we’ve already proved the same design
    with drawing lines. We can jump right into the more complex tests, using the same
    `triggerRequestAnimationFrame` helper as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update `Drawing` to animate the turtle’s coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test to the bottom of the `Drawing` `describe` block. Create
    it in another nested `describe` block, just below the last test you wrote. The
    test follows the same principle as our tests for drawing lines: we trigger two
    animation frames, one at time `0` ms and one at time `500` ms, and then expect
    the rotation to have occurred. Both the *x* and *y* coordinates are tested in
    addition to the *angle*; that’s to make sure we continue to pass those through:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Moving to `src/Drawing.js`, start by adding a definition of `isRotateCommand`,
    just below the definition of `isDrawLineCommand`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Drawing` component, add a new constant, `isRotating`, just below the
    definition of `isDrawingLine`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `useEffect` hook, define a new handler for rotations, `handleRotationFrame`,
    just below the definition of `handleDrawLineFrame`. For the purposes of this test,
    it doesn’t need to do much other than set the angle to the new value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can make use of that to call `requestAnimationFrame` when a rotation command
    is being animated. Modify the last section of the `useEffect` hook to look as
    follows, ensuring that you add `isRotating` to the dependency list. The test should
    pass after this change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add a test to get the duration in and use it within our calculation.
    This is essentially the same as the last test, but with a different duration and,
    therefore, a different expected rotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, first, we need to define `rotateSpeed`. You can add this
    definition just below the definition for `movementSpeed`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, update the conditional at the bottom of the `useEffect` handler to calculate
    the duration for the `rotate` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `handleRotationFrame` to use the duration to calculate a proportionate
    angle to move by:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just as with `handleDrawLineFrame`, we need to ensure that we can handle start
    times other than `0`. Add the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by adding the `start` and `elapsed` variables. After this, the
    test should be passing. You’ll notice the similarity between `handleDrawLineFrame`
    and `handleRotationFrame`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a test to make sure we’re calling `requestAnimationFrame` repeatedly. This
    is the same test that we used for the `drawLine` handler, except now we’re passing
    in the `rotate90` command. Remember to make sure the test belongs in the nested
    context, so you can be sure that there’s no name clash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, we need to do a couple of things. First, we need to modify
    `handleRotationFrame` in the same way we did with `handleDrawLineFrame`, by adding
    a conditional that stops animating after the duration has been reached. Second,
    we also need to fill in the second part of the conditional to set the turtle location
    when the animation is finished:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Handling the end animation state
  prefs: []
  type: TYPE_NORMAL
- en: 'This `else` clause wasn’t necessary with the `drawLine` handler because, as
    soon as a line finishes animating, it will be passed to `StaticLines`, which renders
    all lines with their full length. This isn’t the case with the rotation angle:
    it remains fixed until the next rotation. Therefore, we need to ensure it’s at
    its correct final value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve got one final test. We need to increment the current animation command
    once the animation is done. As with the same test in the previous section, this
    test should live *outside* the `describe` block we’ve just used since it has a
    different test setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, add the call to `setNextCommandToAnimate` into the `else`
    condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s it! If you haven’t done so already, it’s worth running the app to try
    it out.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve explored how to test the `requestAnimationFrame` browser
    API. It’s not a straightforward process, and there are multiple tests that need
    to be written if you wish to be fully covered.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, you’ve seen that it is entirely possible to write automated tests
    for onscreen animation. The benefit of doing so is that the complex production
    code is fully documented via the tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at adding WebSocket communication into Spec
    Logo.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Update `Drawing` so that it resets the turtle position when the user clears
    the screen with the **Reset** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our tests have a lot of duplication due to the repeated calls to `triggerRequestAnimationFrame`.
    Simplify how this is called by creating a wrapper function called `triggerAnimationSequence`
    that takes an array of frame times and calls `triggerRequestAnimationFrame` for
    each of those times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loading an existing script (for example, on startup) will take a long time to
    animate all instructions, and so will pasting in code snippets. Add a **Skip animation**
    button that can be used to skip all the queued animations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **Undo** button works correctly when animations are in progress.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
