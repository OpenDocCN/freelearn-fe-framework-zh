<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer047">
<h1 class="chapter-number" id="_idParaDest-252"><a id="_idTextAnchor306"/>15</h1>
<h1 id="_idParaDest-253"><a id="_idTextAnchor307"/>Adding Animation</h1>
<p>Animation lends itself to test-driven development just as much as any other feature. In this chapter, we’ll animate the Logo turtle movement as the user inputs commands.</p>
<p>There are two types of animation in Spec Logo:</p>
<ul>
<li>First, when the turtle moves forward. For example, when the user enters <strong class="source-inline">forward 100</strong> as an instruction, the turtle should move 100 units along, at a fixed speed. As it moves, it will draw a line behind it.</li>
<li>Second, when the turtle rotates. For example, if the user types <strong class="source-inline">rotate 90</strong>, then the turtle should rotate slowly until it has made a quarter turn.</li>
</ul>
<p>Much of this chapter is about test-driving the <strong class="source-inline">window.requestAnimationFrame</strong> function. This is the browser API that allows us to animate visual elements on the screen, such as the position of the turtle or the length of a line. The mechanics of this function are explained in the third section <a id="_idIndexMarker1371"/>of this chapter, <em class="italic">Animating with requestAnimationFrame</em>. </p>
<p class="callout-heading">The importance of manual testing</p>
<p class="callout">When writing<a id="_idIndexMarker1372"/> animation code, it’s natural to want to visually check what we’re building. Automated tests aren’t enough. Manually testing is also important because animation is not something that most programmers do every day. When something is new, it’s often better to do lots of manual tests to verify behavior in addition to your automated tests.</p>
<p class="callout">In fact, while preparing for this chapter, I did a <em class="italic">lot</em> of manual testing. The walk-through presented here experiments with several different approaches. There were many, many times that I opened my browser to type <strong class="source-inline">forward 100</strong> or <strong class="source-inline">right 90</strong> to visually verify what was happening.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Designing animation</li>
<li>Building an animated line component</li>
<li>Animating with <strong class="source-inline">requestAnimationFrame</strong></li>
<li>Canceling animations with <strong class="source-inline">cancelAnimationFrame</strong></li>
<li>Varying animation behavior</li>
</ul>
<p>The code we’ll write is relatively complicated compared to the code in the rest of the book, so we need to do some upfront design first.</p>
<p>By the end of the chapter, you’ll have gained a deep understanding of how to test-drive one of the more complicated browser APIs.</p>
<h1 id="_idParaDest-254"><a id="_idTextAnchor308"/>Technical requirements</h1>
<p>The code files for this chapter can be found here: </p>
<p><a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter15">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter1<span id="_idTextAnchor309"/>5</a></p>
<h1 id="_idParaDest-255"><a id="_idTextAnchor310"/>Designing animation</h1>
<p>As you read through <a id="_idIndexMarker1373"/>this section, you may wish to open <strong class="source-inline">src/Drawing.js</strong> and read the existing code to understand what it’s doing.</p>
<p>The current <strong class="source-inline">Drawing</strong> component shows a static snapshot of how the drawing looks at this point. It renders a <a id="_idIndexMarker1374"/>set of <strong class="bold">Scalable Vector Graphics</strong> (<strong class="bold">SVG</strong>) lines to represent the path the turtle has taken to this point, and a triangle to represent the turtle.</p>
<p>The component makes use of two child components:</p>
<ul>
<li> The <strong class="source-inline">Turtle</strong> component is displayed once and draws an SVG triangle at the given location</li>
<li>The <strong class="source-inline">StaticLines</strong> component is a set of SVG lines that are drawn onscreen to represent the drawn commands</li>
</ul>
<p>We will add a new <strong class="source-inline">AnimatedLine</strong> component that represents the current line being animated. As lines complete their animation, they will move into the <strong class="source-inline">StaticLines</strong> collection.</p>
<p>We’ll need to do some work to convert this from a static view to an animated representation.</p>
<p>As it stands, the component takes a <strong class="source-inline">turtle</strong> prop and a <strong class="source-inline">drawCommands</strong> prop. The <strong class="source-inline">turtle</strong> prop is the current position of the turtle, given that all the draw commands have already been drawn.</p>
<p>In our new animated drawing, we will still treat <strong class="source-inline">drawCommands</strong> as a list of commands to execute. But rather than relying on a <strong class="source-inline">turtle</strong> prop to tell us where the turtle is, we’ll store the <em class="italic">current</em> position of the turtle as a component state. We will work our way through the <strong class="source-inline">drawCommands</strong> array, one instruction at a time, and update the turtle component state as it animates. Once all instructions are completed, the turtle component state will match what would have originally been set for the <strong class="source-inline">turtle</strong> prop.</p>
<p>The turtle always <a id="_idIndexMarker1375"/>starts at the <strong class="source-inline">0,0</strong> coordinate with an angle of <strong class="source-inline">0</strong>.</p>
<p>We will need to keep track of which commands have already been animated. We’ll create another component state variable, <strong class="source-inline">animatingCommandIndex</strong>, to denote the index of the array item that is currently being animated.</p>
<p>We start animating at the <strong class="source-inline">0</strong> index. Once that command has been animated, we increment the index by <strong class="source-inline">1</strong>, moving along to the next command, and animate that. The process is repeated until we reach the end of the array.</p>
<p>This design means that the user can enter new <strong class="source-inline">drawCommands</strong> at the prompt even if animations are currently running. The component will take care to redraw with animations at the same point it left off at.</p>
<p>Finally, are two types of draw commands: <strong class="source-inline">drawLine</strong> and <strong class="source-inline">rotate</strong>. Here are a couple of examples of commands that will appear in the <strong class="source-inline">drawCommands</strong> array:</p>
<pre class="source-code">
{
  drawCommand: "drawLine",
  id: 123,
  x1: 100,
  y1: 100,
  x2: 200,
  y2: 100
}
{
  drawCommand: "rotate",
  id: 234,
  previousAngle: 0,
  newAngle: <a id="_idTextAnchor311"/>90
}</pre>
<p>Each type of animation<a id="_idIndexMarker1376"/> will need to be handled differently. So, for example, the <strong class="source-inline">AnimatedLine</strong> component will be hidden when the turtle is rotating.</p>
<p>That about covers it. We’ll follow this approach:</p>
<ul>
<li>Start with building the <strong class="source-inline">AnimatedLine</strong> component</li>
<li>Create a <strong class="source-inline">useEffect</strong> hook in <strong class="source-inline">Drawing</strong> that calls the <strong class="source-inline">window.requestAnimationFrame</strong> function to animate <strong class="source-inline">drawLine</strong> commands</li>
<li>Cancel the animation of <strong class="source-inline">drawLine</strong> commands when new instructions are added</li>
<li>Add the animation of turtle rotations</li>
</ul>
<p>Let’s get started with the <strong class="source-inline">AnimatedLine</strong> component.</p>
<h1 id="_idParaDest-256"><a id="_idTextAnchor312"/>Building an animated line component</h1>
<p>In this <a id="_idIndexMarker1377"/>section, we’ll create a new <strong class="source-inline">AnimatedLine</strong> component.</p>
<p>This component contains no animation logic itself but, instead, draws a line from the start of the line being animated to the current turtle position. Therefore, it needs two props: <strong class="source-inline">commandToAnimate</strong>, which would be one of the <strong class="source-inline">drawLine</strong> command structures shown previously, and the <strong class="source-inline">turtle</strong> prop, containing the position.</p>
<p>Let’s begin:</p>
<ol>
<li>Create a new file, <strong class="source-inline">test/AnimatedLine.test.js</strong>, and prime it with the following imports and <strong class="source-inline">describe</strong> block setup. Notice the inclusion of the sample instruction definition for <strong class="source-inline">horizontalLine</strong>:<p class="source-code">import React from "react";</p><p class="source-code">import ReactDOM from "react-dom";</p><p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">  element,</p><p class="source-code">} from "./reactTestExtensions";</p><p class="source-code">import { AnimatedLine } from "../src/AnimatedLine";</p><p class="source-code">import { horizontalLine } from "./sampleInstructions";</p><p class="source-code">const turtle = { x: 10, y: 10, angle: 10 };</p><p class="source-code">describe("AnimatedLine", () =&gt; {</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    initializeReactContainer();</p><p class="source-code">  });</p><p class="source-code">  const renderSvg = (component) =&gt;</p><p class="source-code">    render(&lt;svg&gt;{component}&lt;/svg&gt;);</p><p class="source-code">  const line = () =&gt; element("line");</p><p class="source-code">});</p></li>
<li>Now add the <a id="_idIndexMarker1378"/>first test, which checks the starting position of the line:<p class="source-code">it("draws a line starting at the x1,y1 co-ordinate of the command being drawn", () =&gt; {</p><p class="source-code">  renderSvg(</p><p class="source-code">    &lt;AnimatedLine</p><p class="source-code">      commandToAnimate={horizontalLine}</p><p class="source-code">      turtle={turtle}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  expect(line()).not.toBeNull();</p><p class="source-code">  expect(line().getAttribute("x1")).toEqual(</p><p class="source-code">    horizontalLine.x1.toString()</p><p class="source-code">  );</p><p class="source-code">  expect(line().getAttribute("y1")).toEqual(</p><p class="source-code">    horizontalLine.y1.toString()</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>Create a new file, <strong class="source-inline">src/AnimatedLine.js</strong>, and make your test pass by using the following implementation:<p class="source-code">import React from "react";</p><p class="source-code">export const AnimatedLine = ({</p><p class="source-code">  commandToAnimate: { x1, y1 }</p><p class="source-code">}) =&gt; (</p><p class="source-code">  &lt;line x1={x1} y1={y1} /&gt;</p><p class="source-code">);</p></li>
<li>On to the next test. In this one, we explicitly set the turtle values so that it’s clear to see<a id="_idIndexMarker1379"/> where the expected values come from:<p class="source-code">it("draws a line ending at the current position of the turtle", () =&gt; {</p><p class="source-code">  renderSvg(</p><p class="source-code">    &lt;AnimatedLine</p><p class="source-code">      commandToAnimate={horizontalLine}</p><p class="source-code">      turtle={{ x: 10, y: 20 }}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  expect(line().getAttribute("x2")).toEqual("10");</p><p class="source-code">  expect(line().getAttribute("y2")).toEqual("20");</p><p class="source-code">});</p></li>
<li>To make that pass, we just need to set the <strong class="source-inline">x2</strong> and <strong class="source-inline">y2</strong> props on the line element, pulling that in from the turtle:<p class="source-code">export const AnimatedLine = ({</p><p class="source-code">  commandToAnimate: { x1, y1 }<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">  turtle: { x, y }</strong></p><p class="source-code">}) =&gt; (</p><p class="source-code">  &lt;line x1={x1} y1={y1} <strong class="bold">x2={x} y2={y}</strong> /&gt;</p><p class="source-code">);</p></li>
<li>Then we need <a id="_idIndexMarker1380"/>two tests to set the <strong class="source-inline">strokeWidth</strong> and <strong class="source-inline">stroke</strong> props:<p class="source-code">it("sets a stroke width of 2", () =&gt; {</p><p class="source-code">  renderSvg(</p><p class="source-code">    &lt;AnimatedLine</p><p class="source-code">      commandToAnimate={horizontalLine}</p><p class="source-code">      turtle={turtle}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  expect(</p><p class="source-code">    line().getAttribute("stroke-width")</p><p class="source-code">  ).toEqual("2");</p><p class="source-code">});</p><p class="source-code">it("sets a stroke color of black", () =&gt; {</p><p class="source-code">  renderSvg(</p><p class="source-code">    &lt;AnimatedLine</p><p class="source-code">      commandToAnimate={horizontalLine}</p><p class="source-code">      turtle={turtle}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  expect(</p><p class="source-code">    line().getAttribute("stroke")</p><p class="source-code">  ).toEqual("black");</p><p class="source-code">});</p></li>
<li>Finish off the <a id="_idIndexMarker1381"/>component by adding in those two props:<p class="source-code">export const AnimatedLine = ({</p><p class="source-code">  commandToAnimate: { x1, y1 },</p><p class="source-code">  turtle: { x, y }</p><p class="source-code">}) =&gt; (</p><p class="source-code">  &lt;line</p><p class="source-code">    x1={x1}</p><p class="source-code">    y1={y1}</p><p class="source-code">    x2={x}</p><p class="source-code">    y2={y}</p><p class="source-code">    <strong class="bold">strokeWidth="2"</strong></p><p class="source-code">    <strong class="bold">stroke="black"</strong></p><p class="source-code">  /&gt;</p><p class="source-code">);</p></li>
</ol>
<p>That completes the <strong class="source-inline">AnimatedLine</strong> component.</p>
<p>Next, it’s time to<a id="_idIndexMarker1382"/> add it into <strong class="source-inline">Drawing</strong>, by setting the <strong class="source-inline">commandToAnimate</strong> prop to the current line that’s <a id="_idIndexMarker1383"/>animating and using <strong class="source-inline">requestAnimationFrame</strong> to vary the position of the <a id="_idTextAnchor313"/><strong class="source-inline">turtle</strong> prop.</p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor314"/>Animating with requestAnimationFrame</h1>
<p>In this section, you<a id="_idIndexMarker1384"/> will use the <strong class="source-inline">useEffect</strong> hook in combination with <strong class="source-inline">window.requestAnimationFrame</strong> to adjust the positioning of <strong class="source-inline">AnimatedLine</strong> and <strong class="source-inline">Turtle</strong>.</p>
<p>The <strong class="source-inline">window.requestAnimationFrame</strong> function is used to animate visual properties. For example, you can use it to increase the length of a line from 0 units to 200 units over a given time period, such as 2 seconds.</p>
<p>To make this work, you provide it with a callback that will be run at the next repaint interval. This callback is provided with the current animation time when it’s called:</p>
<pre class="source-code">
const myCallback = time =&gt; {
  // animating code here
};
window.requestAnimationFrame(myCallback);</pre>
<p>If you know the start time of your animation, you can work out the elapsed animation time and use that to calculate the current value of your animated property.</p>
<p>The browser can invoke your callback at a very high refresh rate, such as 60 times per second. Because of these very small intervals of time, your changes appear as a smooth animation.</p>
<p>Note that the browser only invokes your callback once for every requested frame. That means it’s your responsibility to repeatedly call the <strong class="source-inline">requestAnimationFrame</strong> function until the animation time reaches your defined end time, as in the following example. The browser takes care of only invoking your callback when the screen is due to be repainted:</p>
<pre class="source-code">
let startTime;
let endTimeMs = 2000;
const myCallback = time =&gt; {
  if (startTime === undefined) startTime = time;
  const elapsed = time - startTime;
  // ... modify visual state here ...
  if (elapsed &lt; endTimeMs) {
    window.requestAnimationFrame(myCallback);
  }
};
// kick off the first animation frame
window.requestAnimationFrame(myCallback);</pre>
<p>As we progress through this section, you’ll see how you can use this to modify the component state (such <a id="_idIndexMarker1385"/>as the position of <strong class="source-inline">AnimatedLine</strong>), which then causes your component to rerender.</p>
<p>Let’s begin by getting rid of the existing turtle value from the Redux store—we’re no longer going to use this, and instead, rely on the calculated turtle position from the <strong class="source-inline">drawCommands</strong> array:</p>
<ol>
<li value="1">Open <strong class="source-inline">test/Drawing.test.js</strong> and find the test with the name <strong class="source-inline">passes the turtle x, y and angle as props to Turtle</strong>. Replace it with the following:<p class="source-code">it("initially places the turtle at 0,0 with angle 0", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;Drawing /&gt;);</p><p class="source-code">  expect(Turtle).toBeRenderedWithProps({</p><p class="source-code">    x: 0,</p><p class="source-code">    y: 0,</p><p class="source-code">    angle: 0</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Now, in <strong class="source-inline">src/Drawing.js</strong>, you can remove the turtle value that was extracted from the Redux store, by replacing the <strong class="source-inline">useSelector</strong> call with this one:<p class="source-code">const { drawCommands } = useSelector(</p><p class="source-code">  ({ script }) =&gt; script</p><p class="source-code">);</p></li>
<li>We’ll replace the existing turtle value with a new state variable. This will come in useful later when we start moving the position of the turtle. Start by importing <strong class="source-inline">useState</strong> into <strong class="source-inline">src/Drawing.js</strong>:<p class="source-code">import React<strong class="bold">, { useState }</strong> from "react";</p></li>
<li>Then, just <a id="_idIndexMarker1386"/>below the call to <strong class="source-inline">useSelector</strong>, add another call to <strong class="source-inline">useState</strong>. After this change, your test should be passing:<p class="source-code">const [turtle, setTurtle] = useState({</p><p class="source-code">  x: 0,</p><p class="source-code">  y: 0,</p><p class="source-code">  angle: 0</p><p class="source-code">});</p></li>
<li>Back in <strong class="source-inline">test/Drawing.test.js</strong>, stub out the <strong class="source-inline">requestAnimationFrame</strong> function in the <strong class="source-inline">describe</strong> block’s <strong class="source-inline">beforeEach</strong>:<p class="source-code">beforeEach(() =&gt; {</p><p class="source-code">  ...</p><p class="source-code"><strong class="bold">  jest</strong></p><p class="source-code"><strong class="bold">    .spyOn(window, "requestAnimationFrame");</strong></p><p class="source-code">});</p></li>
<li>Add the following new <strong class="source-inline">describe</strong> block and test to the bottom of the existing <strong class="source-inline">describe</strong> block, inside the existing <strong class="source-inline">describe</strong> block (so it’s nested). It defines an initial state of <strong class="source-inline">horizontalLineDrawn</strong> that has a single line—this line is defined in the <strong class="source-inline">sampleInstructions</strong> file. The test states that we expect <strong class="source-inline">requestAnimationFrame</strong> to be<a id="_idIndexMarker1387"/> invoked when the component mounts:<p class="source-code">describe("movement animation", () =&gt; {</p><p class="source-code">  const horizontalLineDrawn = {</p><p class="source-code">    script: {</p><p class="source-code">      drawCommands: [horizontalLine],</p><p class="source-code">      turtle: { x: 0, y: 0, angle: 0 },</p><p class="source-code">    },</p><p class="source-code">  };</p><p class="source-code">  it("invokes requestAnimationFrame when the timeout fires", () =&gt; {</p><p class="source-code">    renderWithStore(&lt;Drawing /&gt;, horizontalLineDrawn);</p><p class="source-code">    expect(window.requestAnimationFrame).toBeCalled();</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>To make this pass, open <strong class="source-inline">src/Drawing.js</strong> and start by importing the <strong class="source-inline">useEffect</strong> hook:<p class="source-code">import React, { useState<strong class="bold">, useEffect</strong> } from "react";</p></li>
<li>Then, add the new <strong class="source-inline">useEffect</strong> hook into the <strong class="source-inline">Drawing</strong> component. Add the following three lines, just above the <strong class="source-inline">return</strong> statement JSX:<p class="source-code">export const Drawing = () =&gt; {</p><p class="source-code">  ...</p><p class="source-code"><strong class="bold">  useEffect(() =&gt; {</strong></p><p class="source-code"><strong class="bold">    requestAnimationFrame();</strong></p><p class="source-code"><strong class="bold">  }, []);</strong></p><p class="source-code">  return ...</p><p class="source-code">};</p></li>
<li>Since we’re now in the realms of <strong class="source-inline">useEffect</strong>, any actions that cause updates to the component state must occur within an <strong class="source-inline">act</strong> block. That includes any triggered animation frames, and we’re about to trigger some. So, back in <strong class="source-inline">test/Drawing.test.js</strong>, add the <strong class="source-inline">act</strong> import now:<p class="source-code">import { act } from "react-dom/test-utils";</p></li>
<li>We also need<a id="_idIndexMarker1388"/> an import for <strong class="source-inline">AnimatedLine</strong> because, in the next test, we’ll assert that we render it. Add the following import, together with its spy setup, as shown:<p class="source-code">import { AnimatedLine } from "../src/AnimatedLine";</p><p class="source-code">jest.mock("../src/AnimatedLine", () =&gt; ({</p><p class="source-code">  AnimatedLine: jest.fn(</p><p class="source-code">    () =&gt; &lt;div id="AnimatedLine" /&gt;</p><p class="source-code">  ),</p><p class="source-code">}));</p></li>
<li>The call to <strong class="source-inline">requestAnimationFrame</strong> requires a <strong class="source-inline">handler</strong> function as an argument. The browser will then call this function during the next animation frame. For the next test, we’ll check that the turtle is at the start of the first line when the timer first fires. We need to define a new helper to do this, which is <strong class="source-inline">triggerRequestAnimationFrame</strong>. In a browser environment, this call would happen automatically, but in our test, we play the role of the browser and trigger it in code. It’s this call that must be wrapped in an <strong class="source-inline">act</strong> function call since our handler will <a id="_idIndexMarker1389"/>cause the component state to change:<p class="source-code">const triggerRequestAnimationFrame = time =&gt; {</p><p class="source-code">  act(() =&gt; {</p><p class="source-code">    const mock = window.requestAnimationFrame.mock</p><p class="source-code">    const lastCallFirstArg =</p><p class="source-code">      mock.calls[mock.calls.length - 1][0]</p><p class="source-code">    lastCallFirstArg(time);</p><p class="source-code">  });</p><p class="source-code">};</p></li>
<li>Now, we’re ready to write tests for the animation cycle. The first one is a simple one: at time zero, the turtle position is placed at the <em class="italic">start</em> of the line. If you check the definition in <strong class="source-inline">test/sampleInstructions.js</strong>, you’ll see that <strong class="source-inline">horizontalLine</strong> starts at position <strong class="source-inline">100,100</strong>:<p class="source-code">it("renders an AnimatedLine with turtle at the start position when the animation has run for 0s", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;Drawing /&gt;, horizontalLineDrawn);</p><p class="source-code">  triggerRequestAnimationFrame(0);</p><p class="source-code">  expect(AnimatedLine).toBeRenderedWithProps({</p><p class="source-code">    commandToAnimate: horizontalLine,</p><p class="source-code">    turtle: { x: 100, y: 100, angle: 0 }</p><p class="source-code">  });</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Using the turtle position for animation</p>
<p class="callout">Remember<a id="_idIndexMarker1390"/> that the <strong class="source-inline">AnimatedLine</strong> component draws a line<a id="_idIndexMarker1391"/> from the start position of the <strong class="source-inline">drawLine</strong> instruction to the current turtle position. That turtle position is then animated, which has the effect of the <strong class="source-inline">AnimatedLine</strong> instance growing in length until it finds the end position of the <strong class="source-inline">drawLine</strong> instruction.</p>
<ol>
<li value="13">Making this test pass will be a bit of a <em class="italic">big bang</em>. To start, extend <strong class="source-inline">useEffect</strong> as shown. We define two variables, <strong class="source-inline">commandToAnimate</strong> and <strong class="source-inline">isDrawingLine</strong>, which we use to determine whether we should animate at all. The <strong class="source-inline">isDrawingLine</strong> test is necessary because some of the existing tests send no draw commands at all to the component, in which case <strong class="source-inline">commandToAnimate</strong> will be <strong class="source-inline">null</strong>. Yet another test passes a command of an unknown type<a id="_idIndexMarker1392"/> into the component, which would also blow up if we tried to pull out <strong class="source-inline">x1</strong> and <strong class="source-inline">y1</strong> from it. That explains the call to <strong class="source-inline">isDrawLineCommand</strong>—a function that is defined already at the top of the file:<p class="source-code"><strong class="bold">const commandToAnimate = drawCommands[0];</strong></p><p class="source-code"><strong class="bold">const isDrawingLine =</strong></p><p class="source-code"><strong class="bold">  commandToAnimate &amp;&amp;  </strong></p><p class="source-code"><strong class="bold">  isDrawLineCommand(commandToAnimate);</strong></p><p class="source-code">useEffect(() =&gt; {</p><p class="source-code"><strong class="bold">  const handleDrawLineFrame = time =&gt; {</strong></p><p class="source-code"><strong class="bold">    setTurtle(turtle =&gt; ({</strong></p><p class="source-code"><strong class="bold">      ...turtle,</strong></p><p class="source-code"><strong class="bold">      x: commandToAnimate.x1,</strong></p><p class="source-code"><strong class="bold">      y: commandToAnimate.y1,</strong></p><p class="source-code"><strong class="bold">    }));</strong></p><p class="source-code"><strong class="bold">  };</strong></p><p class="source-code"><strong class="bold">  if (isDrawingLine) {</strong></p><p class="source-code">    requestAnimationFrame(<strong class="bold">handleDrawLineFrame</strong>);</p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">}, [<strong class="bold">commandToAnimate, isDrawingLine</strong>]);</p></li>
</ol>
<p class="callout-heading">Using the functional update setter</p>
<p class="callout">This code<a id="_idIndexMarker1393"/> uses the <em class="italic">functional update</em> variant of <strong class="source-inline">setTurtle</strong> that <a id="_idIndexMarker1394"/>takes a function rather than a value. This is used when the new state value depends on the old value. Using this form of setter means that the turtle doesn’t need to be in the dependency list of <strong class="source-inline">useEffect</strong> and won’t cause the <strong class="source-inline">useEffect</strong> hook to reset itself.</p>
<ol>
<li value="14">At this point, we <a id="_idIndexMarker1395"/>still aren’t rendering <strong class="source-inline">AnimatedLine</strong>, which is what our test expects. Let’s fix that now. Start by adding the import:<p class="source-code">import { AnimatedLine } from "./AnimatedLine";</p></li>
<li>Insert this just below the JSX for <strong class="source-inline">StaticLines</strong>. At this point, your test should be passing:<p class="source-code">&lt;AnimatedLine</p><p class="source-code">  commandToAnimate={commandToAnimate}</p><p class="source-code">  turtle={turtle}</p><p class="source-code">/&gt;</p></li>
<li>We need a further test to check that we don’t render <strong class="source-inline">AnimatedLine</strong> if no lines are being animated. Add the next test as shown, but don’t add it in the <strong class="source-inline">movement animation</strong> block; instead, place it into the parent context:<p class="source-code">it("does not render AnimatedLine when not moving", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;Drawing /&gt;, {</p><p class="source-code">    script: { drawCommands: [] }</p><p class="source-code">  });</p><p class="source-code">  expect(AnimatedLine).not.toBeRendered();</p><p class="source-code">});</p></li>
<li>Make that pass by wrapping the <strong class="source-inline">AnimatedLine</strong> component with a ternary. We simply<a id="_idIndexMarker1396"/> return <strong class="source-inline">null</strong> if <strong class="source-inline">isDrawingLine</strong> is false:<p class="source-code"><strong class="bold">{isDrawingLine ? (</strong></p><p class="source-code">  &lt;AnimatedLine</p><p class="source-code">    commandToAnimate={commandToAnimate}</p><p class="source-code">    turtle={turtle}</p><p class="source-code">/&gt; <strong class="bold">: null}</strong></p></li>
<li>We’ve handled what the <em class="italic">first</em> animation frame should do; now let’s code up the <em class="italic">next</em> animation frame. In the following test, there are <em class="italic">two</em> calls to <strong class="source-inline">triggerRequestAnimationFrame</strong>. The first one is used to signify that animation is started; the second one allows us to move. We need the first call (with a time index of <strong class="source-inline">0</strong>) to be able to mark the time at which the animation started:<p class="source-code">it("renders an AnimatedLine with turtle at a position based on a speed of 5px per ms", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;Drawing /&gt;, horizontalLineDrawn);</p><p class="source-code">  triggerRequestAnimationFrame(0);</p><p class="source-code">  triggerRequestAnimationFrame(250);</p><p class="source-code">  expect(AnimatedLine).toBeRenderedWithProps({</p><p class="source-code">    commandToAnimate: horizontalLine,</p><p class="source-code">    turtle: { x: 150, y: 100, angle: 0 }</p><p class="source-code">  });</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Using animation duration to calculate the distance moved</p>
<p class="callout">The <strong class="source-inline">handleDrawLineFrame</strong> function, when called by the browser, will be passed a time parameter. This is the current duration of the animation. The turtle travels at a constant velocity, so knowing the duration allows us to calculate where the turtle is.</p>
<ol>
<li value="19">To make this pass, first, we need to define a couple of functions. Scroll up <strong class="source-inline">src/Drawing.js</strong> until you see the definition for <strong class="source-inline">isDrawLineCommand</strong> and add<a id="_idIndexMarker1397"/> these two new definitions there. The <strong class="source-inline">distance</strong> and <strong class="source-inline">movementSpeed</strong> functions are used to calculate the duration of the animation:<p class="source-code">const distance = ({ x1, y1, x2, y2 }) =&gt;</p><p class="source-code">  Math.sqrt(</p><p class="source-code">    (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)</p><p class="source-code">  );</p><p class="source-code">const movementSpeed = 5;</p></li>
<li>Now we can calculate the duration of the animation; modify <strong class="source-inline">useEffect</strong> as shown:<p class="source-code">useEffect(() =&gt; {</p><p class="source-code"><strong class="bold">  let duration;</strong></p><p class="source-code">  const handleDrawLineFrame = time =&gt; {</p><p class="source-code">    setTurtle(...);</p><p class="source-code">  };</p><p class="source-code">  if (isDrawingLine) {</p><p class="source-code"><strong class="bold">    duration =</strong></p><p class="source-code"><strong class="bold">      movementSpeed * distance(commandToAnimate);</strong></p><p class="source-code">    requestAnimationFrame(handleDrawLineFrame);</p><p class="source-code">  }</p><p class="source-code">}, [commandToAnimate, isDrawingLine]);</p></li>
<li>By declaring <strong class="source-inline">duration</strong> as the very first line in the <strong class="source-inline">useEffect</strong> block, the variable is in scope for the <strong class="source-inline">requestAnimationFrame</strong> handler to read it to calculate distance. To do that, we take the elapsed time and divide it by the total <a id="_idIndexMarker1398"/>duration:<p class="source-code">useEffect(() =&gt; {</p><p class="source-code">  let duration;</p><p class="source-code">  const handleDrawLineFrame = time =&gt; {</p><p class="source-code">    <strong class="bold">const { x1, x2, y1, y2 } = commandToAnimate;</strong></p><p class="source-code"><strong class="bold">    setTurtle(turtle =&gt; ({</strong></p><p class="source-code"><strong class="bold">      ...turtle,</strong></p><p class="source-code"><strong class="bold">      x: x1 + ((x2 - x1) * (time / duration)),</strong></p><p class="source-code"><strong class="bold">      y: y1 + ((y2 - y1) * (time / duration)),</strong></p><p class="source-code"><strong class="bold">    }));</strong></p><p class="source-code">  };</p><p class="source-code">  if (isDrawingLine) {</p><p class="source-code">    ...</p><p class="source-code">  }</p><p class="source-code">}, [commandToAnimate, isDrawingLine]);</p></li>
<li>We’re making great progress! In the previous test, we assumed that the starting time is <strong class="source-inline">0</strong>, but actually, the browser could give us any time as the start time (the time it gives us is known<a id="_idIndexMarker1399"/> as the <strong class="bold">time origin</strong>). So, let’s make sure our calculations work for a non-zero start time. Add the following test:<p class="source-code">it("calculates move distance with a non-zero animation start time", () =&gt; {</p><p class="source-code">  const startTime = 12345;</p><p class="source-code">  renderWithStore(&lt;Drawing /&gt;, horizontalLineDrawn);</p><p class="source-code">  triggerRequestAnimationFrame(startTime);</p><p class="source-code">  triggerRequestAnimationFrame(startTime + 250);</p><p class="source-code">  expect(AnimatedLine).toBeRenderedWithProps({</p><p class="source-code">    commandToAnimate: horizontalLine,</p><p class="source-code">    turtle: { x: 150, y: 100, angle: 0 }</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make that pass by <a id="_idIndexMarker1400"/>introducing the <strong class="source-inline">start</strong> and <strong class="source-inline">elapsed</strong> times, as shown:<p class="source-code">useEffect(() =&gt; {</p><p class="source-code">  let<strong class="bold"> start,</strong> duration;</p><p class="source-code">  const handleDrawLineFrame = time =&gt; {</p><p class="source-code"><strong class="bold">    if (start === undefined) start = time;</strong></p><p class="source-code"><strong class="bold">    const elapsed = time - start;</strong></p><p class="source-code">    const { x1, x2, y1, y2 } = commandToAnimate;</p><p class="source-code">    setTurtle(turtle =&gt; ({</p><p class="source-code">      ...turtle,</p><p class="source-code">      x: x1 + ((x2 - x1) * (<strong class="bold">elapsed</strong> / duration)),</p><p class="source-code">      y: y1 + ((y2 - y1) * (<strong class="bold">elapsed</strong> / duration)),</p><p class="source-code">    }));</p><p class="source-code">  };</p><p class="source-code">  if (isDrawingLine) {</p><p class="source-code">    ...</p><p class="source-code">  }</p><p class="source-code">}, [commandToAnimate, isDrawingLine]);</p></li>
<li>Our components need to call <strong class="source-inline">requestAnimationFrame</strong> repeatedly until the duration is reached. At that point, the line should have been fully drawn. In this test, we trigger three animation frames, and we expect <strong class="source-inline">requestAnimationFrame</strong> to have been called three times:<p class="source-code">it("invokes requestAnimationFrame repeatedly until the duration is reached", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;Drawing /&gt;, horizontalLineDrawn);</p><p class="source-code">  triggerRequestAnimationFrame(0);</p><p class="source-code">  triggerRequestAnimationFrame(250);</p><p class="source-code">  triggerRequestAnimationFrame(500);</p><p class="source-code">  expect(</p><p class="source-code">    window.requestAnimationFrame.mock.calls </p><p class="source-code">  ).toHaveLength(3);</p><p class="source-code">});</p></li>
<li>To make that <a id="_idIndexMarker1401"/>pass, we need to ensure that <strong class="source-inline">handleDrawLineFrame</strong> triggers another <strong class="source-inline">requestAnimationFrame</strong> when it’s run. However, we should only do that until the time that the duration has been reached. Make that pass happen by wrapping the <strong class="source-inline">setTurtle</strong> and <strong class="source-inline">requestAnimationFrame</strong> calls with the following conditional:<p class="source-code">const handleDrawLineFrame = (time) =&gt; {</p><p class="source-code">  if (start === undefined) start = time;</p><p class="source-code"><strong class="bold">  if (time &lt; start + duration) {</strong></p><p class="source-code">    const elapsed = time - start;</p><p class="source-code">    const { x1, x2, y1, y2 } = commandToAnimate;</p><p class="source-code">    setTurtle(...);</p><p class="source-code">    requestAnimationFrame(handleDrawLineFrame);</p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">};</p></li>
<li>For the next test, we will check that when a line has “finished” being drawn, we move on <a id="_idIndexMarker1402"/>to the next one, if there is one (otherwise, we stop). Add a new <strong class="source-inline">describe</strong> block below the <strong class="source-inline">describe</strong> block we’ve just implemented, with the following test. The second time stamp, <strong class="source-inline">500</strong>, is after the duration that is required for <strong class="source-inline">horizontalLine</strong> to be drawn and therefore, <strong class="source-inline">AnimatedLine</strong> should show <strong class="source-inline">verticalLine</strong> instead:<p class="source-code">describe("after animation", () =&gt; {</p><p class="source-code">  it("animates the next command", () =&gt; {</p><p class="source-code">    renderWithStore(&lt;Drawing /&gt;, {</p><p class="source-code">      script: {</p><p class="source-code">        drawCommands: [horizontalLine, verticalLine]</p><p class="source-code">      }</p><p class="source-code">    });</p><p class="source-code">    triggerRequestAnimationFrame(0);</p><p class="source-code">    triggerRequestAnimationFrame(500);</p><p class="source-code">    expect(AnimatedLine).toBeRenderedWithProps(</p><p class="source-code">      expect.objectContaining({</p><p class="source-code">        commandToAnimate: verticalLine,</p><p class="source-code">      })</p><p class="source-code">    );</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>To make that pass, we need to introduce a pointer to the command that is currently being animated. This will start at the <strong class="source-inline">0</strong> index, and we’ll increment it each time the animation finishes. Add the following new state variable at the top of the component:<p class="source-code">const [</p><p class="source-code">  animatingCommandIndex,</p><p class="source-code">  setAnimatingCommandIndex</p><p class="source-code">] = useState(0);</p></li>
<li>Update<a id="_idIndexMarker1403"/> the <strong class="source-inline">commandToAnimate</strong> constant to use this new variable:<p class="source-code">const commandToAnimate = </p><p class="source-code">  drawCommands[<strong class="bold">animatingCommandIndex</strong>];</p></li>
<li>Add an <strong class="source-inline">else</strong> clause to the conditional in <strong class="source-inline">handleDrawLineFrame</strong> that increments the value:<p class="source-code">if (time &lt; start + duration) {</p><p class="source-code">  ...</p><p class="source-code">} <strong class="bold">else {</strong></p><p class="source-code"><strong class="bold">  setAnimatingCommandIndex(</strong></p><p class="source-code"><strong class="bold">    animatingCommandIndex =&gt; animatingCommandIndex + 1</strong></p><p class="source-code"><strong class="bold">  );</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
<li>For the final test, we want to make sure that only previously animated commands are sent to <strong class="source-inline">StaticLines</strong>. The currently animating line will be rendered by <strong class="source-inline">AnimatedLine</strong>, and lines that haven’t been animated yet shouldn’t <a id="_idIndexMarker1404"/>be rendered at all:<p class="source-code">it("places line in StaticLines", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;Drawing /&gt;, {</p><p class="source-code">    script: {</p><p class="source-code">      drawCommands: [horizontalLine, verticalLine]</p><p class="source-code">    }</p><p class="source-code">  });</p><p class="source-code">  triggerRequestAnimationFrame(0);</p><p class="source-code">  triggerRequestAnimationFrame(500);</p><p class="source-code">  expect(StaticLines).toBeRenderedWithProps({ </p><p class="source-code">    lineCommands: [horizontalLine]</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>To make that pass, update <strong class="source-inline">lineCommands</strong> to take only the portion of <strong class="source-inline">drawCommands</strong> up until the current <strong class="source-inline">animatingCommandIndex</strong> value:<p class="source-code">const lineCommands = drawCommands</p><p class="source-code"><strong class="bold">  .slice(0, animatingCommandIndex)</strong></p><p class="source-code">  .filter(isDrawLineCommand);</p></li>
<li>Although the latest test will now pass, the existing test, <strong class="source-inline">sends only line commands to StaticLines</strong>, will now break. Since our latest test covers essentially the same functionality, you can safely delete that test now.</li>
</ol>
<p>If you run the app, you’ll now be able to see lines being animated as they are placed on the screen.</p>
<p>In the next <a id="_idIndexMarker1405"/>section, we’ll ensure the animations behave nicely when multiple commands are ent<a id="_idTextAnchor315"/>ered by the user at the same time.</p>
<h1 id="_idParaDest-258"><a id="_idTextAnchor316"/>Canceling animations with cancelAnimationFrame</h1>
<p>The <strong class="source-inline">useEffect</strong> hook <a id="_idIndexMarker1406"/>we’ve written<a id="_idIndexMarker1407"/> has <strong class="source-inline">commandToAnimate</strong> and <strong class="source-inline">isDrawingLine</strong> in its dependency list. That means that when either of these values updates, the <strong class="source-inline">useEffect</strong> hook is torn down and will be restarted. But there are other occasions when we want to cancel the animation. One time this happens is when the user resets their screen.</p>
<p>If a command is currently animating when the user clicks the <strong class="bold">Reset</strong> button, we don’t want the current animation frame to continue. We want to clean that up.</p>
<p>Let’s add a test for that now:</p>
<ol>
<li value="1">Add the following test at the bottom of <strong class="source-inline">test/Drawing.test.js</strong>:<p class="source-code">it("calls cancelAnimationFrame on reset", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;Drawing /&gt;, {</p><p class="source-code">    script: { drawCommands: [horizontalLine] }</p><p class="source-code">  });</p><p class="source-code">  renderWithStore(&lt;Drawing /&gt;, {</p><p class="source-code">    script: { drawCommands: [] }</p><p class="source-code">  });</p><p class="source-code">  expect(window.cancelAnimationFrame).toBeCalledWith(</p><p class="source-code">    cancelToken</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>You’ll also need to change the <strong class="source-inline">beforeEach</strong> block, making the <strong class="source-inline">requestAnimationFrame</strong> stub return a dummy cancel token, and adding in a new stub for the <strong class="source-inline">cancelAnimationFrame</strong> function:<p class="source-code">describe("Drawing", () =&gt; {</p><p class="source-code"><strong class="bold">  const cancelToken = "cancelToken";</strong></p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    ...</p><p class="source-code">    jest</p><p class="source-code">      .spyOn(window, "requestAnimationFrame")</p><p class="source-code"><strong class="bold">      .mockReturnValue(cancelToken);</strong></p><p class="source-code"><strong class="bold">    jest.spyOn(window, "cancelAnimationFrame");</strong></p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>To make<a id="_idIndexMarker1408"/> the <a id="_idIndexMarker1409"/>test pass, update the <strong class="source-inline">useEffect</strong> hook to store the <strong class="source-inline">cancelToken</strong> value that the <strong class="source-inline">requestAnimationFrame</strong> function returns when it’s called. Then return a cleanup function from the <strong class="source-inline">useEffect</strong> hook, which uses that token to cancel the next requested frame. This function will be called by React when it tears down the hook:<p class="source-code">useEffect(() =&gt; {</p><p class="source-code">  let start, duration<strong class="bold">, cancelToken</strong>;</p><p class="source-code">  const handleDrawLineFrame = time =&gt; {</p><p class="source-code">    if (start === undefined) start = time;</p><p class="source-code">    if (time &lt; start + duration) {</p><p class="source-code">      ...</p><p class="source-code"><strong class="bold">      cancelToken =</strong> requestAnimationFrame(</p><p class="source-code">        handleDrawLineFrame</p><p class="source-code">      );</p><p class="source-code">    } else {</p><p class="source-code">      ...</p><p class="source-code">    }</p><p class="source-code">  };</p><p class="source-code">  if (isDrawingLine) {</p><p class="source-code">    duration =</p><p class="source-code">      movementSpeed * distance(commandToAnimate);</p><p class="source-code"><strong class="bold">    cancelToken =</strong> requestAnimationFrame(</p><p class="source-code">      handleDrawLineFrame</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code"><strong class="bold">  return () =&gt; {</strong></p><p class="source-code"><strong class="bold">    cancelAnimationFrame(cancelToken);</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">});</p></li>
<li>Finally, we don’t <a id="_idIndexMarker1410"/>want <a id="_idIndexMarker1411"/>to run this cleanup if <strong class="source-inline">cancelToken</strong> hasn’t been set. The token won’t have been set if we aren’t currently rendering a line. We can prove that with the following test, which you should add now:<p class="source-code">it("does not call cancelAnimationFrame if no line animating", () =&gt; {</p><p class="source-code">  jest.spyOn(window, "cancelAnimationFrame");</p><p class="source-code">  renderWithStore(&lt;Drawing /&gt;, {</p><p class="source-code">    script: { drawCommands: [] }</p><p class="source-code">  });</p><p class="source-code">  renderWithStore(&lt;React.Fragment /&gt;);</p><p class="source-code">  expect(</p><p class="source-code">    window.cancelAnimationFrame</p><p class="source-code">  ).not.toHaveBeenCalled();</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Unmounting a component</p>
<p class="callout">This test shows <a id="_idIndexMarker1412"/>how you can mimic an <em class="italic">unmount</em> of a component in React, which is simply by rendering <strong class="source-inline">&lt;React.Fragment /&gt;</strong> in place of the component under test. React will unmount your component when this occurs.</p>
<ol>
<li value="5">To make<a id="_idIndexMarker1413"/> that<a id="_idIndexMarker1414"/> pass, simply wrap the returned cleanup function in a conditional:<p class="source-code">return () =&gt; {</p><p class="source-code"><strong class="bold">  if (cancelToken) {</strong></p><p class="source-code">    cancelAnimationFrame(cancelToken);</p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">};</p></li>
</ol>
<p>That’s all we need to do for animating the <strong class="source-inline">drawLine</strong> commands. Next up is rotating the turtle.</p>
<h1 id="_idParaDest-259"><a id="_idTextAnchor317"/>Varying animation behavior</h1>
<p>Our lines and <a id="_idIndexMarker1415"/>turtle are now animating nicely. However, we still need to handle the second type of draw command: rotations. The turtle will move at a constant speed when rotating to a new angle. A full rotation should take 1 second to complete, and we can use this to calculate the duration of the rotation. For example, a quarter rotation will take 0.25 seconds to complete.</p>
<p>In the last section, we started<a id="_idIndexMarker1416"/> with a test to check that we were calling <strong class="source-inline">requestAnimationFrame</strong>. This time, that test isn’t essential because we’ve already proved the same design with drawing lines. We can jump right into the more complex tests, using the same <strong class="source-inline">triggerRequestAnimationFrame</strong> helper as before.</p>
<p>Let’s update <strong class="source-inline">Drawing</strong> to animate the turtle’s coordinates:</p>
<ol>
<li value="1">Add the following test to the bottom of the <strong class="source-inline">Drawing</strong> <strong class="source-inline">describe</strong> block. Create it in another nested <strong class="source-inline">describe</strong> block, just below the last test you wrote. The test follows the same principle as our tests for drawing lines: we trigger two animation frames, one at time <strong class="source-inline">0</strong> ms and one at time <strong class="source-inline">500</strong> ms, and then expect the rotation to have occurred. Both the <em class="italic">x</em> and <em class="italic">y</em> coordinates are tested in addition to the <em class="italic">angle</em>; that’s to make sure we continue to pass those through:<p class="source-code">describe("rotation animation", () =&gt; {</p><p class="source-code">  const rotationPerformed = {</p><p class="source-code">    script: { drawCommands: [rotate90] },</p><p class="source-code">  };</p><p class="source-code">  it("rotates the turtle", () =&gt; {</p><p class="source-code">    renderWithStore(&lt;Drawing /&gt;, rotationPerformed);</p><p class="source-code">    triggerRequestAnimationFrame(0);</p><p class="source-code">    triggerRequestAnimationFrame(500);</p><p class="source-code">    expect(Turtle).toBeRenderedWithProps({</p><p class="source-code">      x: 0,</p><p class="source-code">      y: 0,</p><p class="source-code">      angle: 90</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Moving to <strong class="source-inline">src/Drawing.js</strong>, start by adding a definition of <strong class="source-inline">isRotateCommand</strong>, just below the definition of <strong class="source-inline">isDrawLineCommand</strong>:<p class="source-code">const isRotateCommand = command =&gt;</p><p class="source-code">  command.drawCommand === "rotate";</p></li>
<li>In the <strong class="source-inline">Drawing</strong> component, add a new constant, <strong class="source-inline">isRotating</strong>, just below the <a id="_idIndexMarker1417"/>definition of <strong class="source-inline">isDrawingLine</strong>:<p class="source-code"><strong class="bold">const isRotating =</strong></p><p class="source-code"><strong class="bold">  commandToAnimate &amp;&amp;</strong></p><p class="source-code"><strong class="bold">    isRotateCommand(commandToAnimate);</strong></p></li>
<li>In the <strong class="source-inline">useEffect</strong> hook, define a new handler for rotations, <strong class="source-inline">handleRotationFrame</strong>, just below the definition of <strong class="source-inline">handleDrawLineFrame</strong>. For the purposes of this test, it doesn’t need to do much other than set the angle to the new value:<p class="source-code">const handleRotationFrame = time =&gt; {</p><p class="source-code">  setTurtle(turtle =&gt; ({</p><p class="source-code">    ...turtle,</p><p class="source-code">    angle: commandToAnimate.newAngle</p><p class="source-code">  }));</p><p class="source-code">};</p></li>
<li>We can make use of that<a id="_idIndexMarker1418"/> to call <strong class="source-inline">requestAnimationFrame</strong> when a rotation command is being animated. Modify the last section of the <strong class="source-inline">useEffect</strong> hook to look as follows, ensuring that you add <strong class="source-inline">isRotating</strong> to the dependency list. The test should pass after this <a id="_idIndexMarker1419"/>change:<p class="source-code">useEffect(() =&gt; {</p><p class="source-code">  ...</p><p class="source-code">  if (isDrawingLine) {</p><p class="source-code">    ...</p><p class="source-code">  } <strong class="bold">else if (isRotating) {</strong></p><p class="source-code"><strong class="bold">    requestAnimationFrame(handleRotationFrame);</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">}, [commandToAnimate, isDrawingLine<strong class="bold">, isRotating</strong>]);</p></li>
<li>Let’s add a test to get the duration in and use it within our calculation. This is essentially the same as the last test, but with a different duration and, therefore, a different expected rotation:<p class="source-code">it("rotates part-way at a speed of 1s per 180 degrees", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;Drawing /&gt;, rotationPerformed);</p><p class="source-code">  triggerRequestAnimationFrame(0);</p><p class="source-code">  triggerRequestAnimationFrame(250);</p><p class="source-code">  expect(Turtle).toBeRenderedWithProps({</p><p class="source-code">    x: 0,</p><p class="source-code">    y: 0,</p><p class="source-code">    angle: 45</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>To make this pass, first, we need to define <strong class="source-inline">rotateSpeed</strong>. You can add this definition just below the definition for <strong class="source-inline">movementSpeed</strong>:<p class="source-code">const rotateSpeed = 1000 / 180;</p></li>
<li>Next, update the conditional at the bottom of the <strong class="source-inline">useEffect</strong> handler to calculate<a id="_idIndexMarker1420"/> the duration for the <strong class="source-inline">rotate</strong> command:<p class="source-code">} else if (isRotating) {</p><p class="source-code"><strong class="bold">  duration =</strong></p><p class="source-code"><strong class="bold">    rotateSpeed *</strong></p><p class="source-code"><strong class="bold">    Math.abs(</strong></p><p class="source-code"><strong class="bold">      commandToAnimate.newAngle -</strong></p><p class="source-code"><strong class="bold">        commandToAnimate.previousAngle</strong></p><p class="source-code"><strong class="bold">    );</strong></p><p class="source-code"> requestAnimationFrame(handleRotationFrame);</p><p class="source-code">}</p></li>
<li>Update <strong class="source-inline">handleRotationFrame</strong> to use the duration to calculate a proportionate angle to move by:<p class="source-code">const handleRotationFrame = (time) =&gt; {</p><p class="source-code"><strong class="bold">  const {</strong></p><p class="source-code"><strong class="bold">    previousAngle, newAngle</strong></p><p class="source-code"><strong class="bold">  } = commandToAnimate;</strong></p><p class="source-code">  setTurtle(turtle =&gt; ({</p><p class="source-code">    ...turtle,</p><p class="source-code">    angle:</p><p class="source-code"><strong class="bold">      previousAngle +</strong></p><p class="source-code"><strong class="bold">      (newAngle - previousAngle) * (time / duration)</strong></p><p class="source-code">  }));</p><p class="source-code">};</p></li>
<li>Just as with <strong class="source-inline">handleDrawLineFrame</strong>, we need to ensure that we can handle start times <a id="_idIndexMarker1421"/> other than <strong class="source-inline">0</strong>. Add the following test:<p class="source-code">it("calculates rotation with a non-zero animation start time", () =&gt; {</p><p class="source-code">  const startTime = 12345;</p><p class="source-code">  renderWithStore(&lt;Drawing /&gt;, rotationPerformed);</p><p class="source-code">  triggerRequestAnimationFrame(startTime);</p><p class="source-code">  triggerRequestAnimationFrame(startTime + 250);</p><p class="source-code">  expect(Turtle).toBeRenderedWithProps({</p><p class="source-code">    x: 0,</p><p class="source-code">    y: 0,</p><p class="source-code">    angle: 45</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make that pass by adding the <strong class="source-inline">start</strong> and <strong class="source-inline">elapsed</strong> variables. After this, the test should be passing. You’ll notice the similarity between <strong class="source-inline">handleDrawLineFrame</strong> and <strong class="source-inline">handleRotationFrame</strong>:<p class="source-code">const handleRotationFrame = (time) =&gt; {</p><p class="source-code"><strong class="bold">  if (start === undefined) start = time;</strong></p><p class="source-code"><strong class="bold">  const elapsed = time - start;</strong></p><p class="source-code">  const {</p><p class="source-code">   previousAngle, newAngle</p><p class="source-code">  } = commandToAnimate;</p><p class="source-code">  setTurtle(turtle =&gt; ({</p><p class="source-code">    ...turtle,</p><p class="source-code">    angle:</p><p class="source-code">      previousAngle +</p><p class="source-code">      (newAngle - previousAngle) *</p><p class="source-code">      (<strong class="bold">elapsed</strong> / duration)</p><p class="source-code">  }));</p><p class="source-code">};</p></li>
<li>Add a test to make sure<a id="_idIndexMarker1422"/> we’re calling <strong class="source-inline">requestAnimationFrame</strong> repeatedly. This is the same test that we used for the <strong class="source-inline">drawLine</strong> handler, except now we’re passing in the <strong class="source-inline">rotate90</strong> command. Remember <a id="_idIndexMarker1423"/>to make sure the test belongs in the nested context, so you can be sure that there’s no name clash:<p class="source-code">it("invokes requestAnimationFrame repeatedly until the duration is reached", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;Drawing /&gt;, rotationPerformed);</p><p class="source-code">  triggerRequestAnimationFrame(0);</p><p class="source-code">  triggerRequestAnimationFrame(250);</p><p class="source-code">  triggerRequestAnimationFrame(500);</p><p class="source-code">  expect(</p><p class="source-code">    window.requestAnimationFrame.mock.calls </p><p class="source-code">  ).toHaveLength(3);</p><p class="source-code">});</p></li>
<li>To make this pass, we need to do a couple of things. First, we need to modify <strong class="source-inline">handleRotationFrame</strong> in the same way we did with <strong class="source-inline">handleDrawLineFrame</strong>, by adding a conditional that stops animating after the duration has been reached. Second, we also need to fill in the second part of the conditional<a id="_idIndexMarker1424"/> to set the turtle location when the animation is finished:<p class="source-code">const handleRotationFrame = (time) =&gt; {</p><p class="source-code">  if (start === undefined) start = time;</p><p class="source-code"><strong class="bold">  if (time &lt; start + duration) {</strong></p><p class="source-code">    ...</p><p class="source-code"><strong class="bold">  } else {</strong></p><p class="source-code"><strong class="bold">    setTurtle(turtle =&gt; ({</strong></p><p class="source-code"><strong class="bold">      ...turtle,</strong></p><p class="source-code"><strong class="bold">      angle: commandToAnimate.newAngle</strong></p><p class="source-code"><strong class="bold">    }));</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">};</p></li>
</ol>
<p class="callout-heading">Handling the end animation state</p>
<p class="callout">This <strong class="source-inline">else</strong> clause wasn’t necessary with the <strong class="source-inline">drawLine</strong> handler because, as soon as a line finishes animating, it will be passed to <strong class="source-inline">StaticLines</strong>, which renders all lines with their full length. This isn’t the case with the rotation angle: it remains fixed until the next rotation. Therefore, we need to ensure it’s at its correct final value.</p>
<ol>
<li value="14">We’ve got one final test. We need to increment the current animation command once the animation is done. As with the same test in the previous section, this test should live <em class="italic">outside</em> the <strong class="source-inline">describe</strong> block we’ve just used since it has a different test setup:<p class="source-code">it("animates the next command once rotation is complete", async () =&gt; {</p><p class="source-code">  renderWithStore(&lt;Drawing /&gt;, {</p><p class="source-code">    script: {</p><p class="source-code">      drawCommands: [rotate90, horizontalLine]</p><p class="source-code">    }</p><p class="source-code">  });</p><p class="source-code">  triggerRequestAnimationFrame(0);</p><p class="source-code">  triggerRequestAnimationFrame(500);</p><p class="source-code">  triggerRequestAnimationFrame(0);</p><p class="source-code">  triggerRequestAnimationFrame(250);</p><p class="source-code">  expect(Turtle).toBeRenderedWithProps({</p><p class="source-code">    x: 150,</p><p class="source-code">    y: 100,</p><p class="source-code">    angle: 90</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>To make<a id="_idIndexMarker1425"/> that pass, add the call to <strong class="source-inline">setNextCommandToAnimate</strong> into the <strong class="source-inline">else</strong> condition:<p class="source-code">} else {</p><p class="source-code">  setTurtle(turtle =&gt; ({</p><p class="source-code">    ...turtle,</p><p class="source-code">    angle: commandToAnimate.newAngle</p><p class="source-code">  }));</p><p class="source-code"><strong class="bold">  setAnimatingCommandIndex(</strong></p><p class="source-code"><strong class="bold">    (animatingCommandToIndex) =&gt;</strong></p><p class="source-code"><strong class="bold">      animatingCommandToIndex + 1</strong></p><p class="source-code"><strong class="bold">  );</strong></p><p class="source-code">}</p></li>
</ol>
<p>That’s it! If <a id="_idIndexMarker1426"/>you haven’t don<a id="_idTextAnchor318"/>e so already, it’s worth running the app to try it out.</p>
<h1 id="_idParaDest-260"><a id="_idTextAnchor319"/>Summary</h1>
<p>In this chapter, we’ve explored how to test the <strong class="source-inline">requestAnimationFrame</strong> browser API. It’s not a straightforward process, and there are multiple tests that need to be written if you wish to be fully covered.</p>
<p>Nevertheless, you’ve seen that it is entirely possible to write automated tests for onscreen animation. The benefit of doing so is that the complex production code is fully documented via the tests.</p>
<p>In the next chapter, we’ll <a id="_idTextAnchor320"/>look at adding WebSocket communication into Spec Logo.</p>
<h1 id="_idParaDest-261"><a id="_idTextAnchor321"/>Exercises</h1>
<ol>
<li value="1">Update <strong class="source-inline">Drawing</strong> so that it resets the turtle position when the user clears the screen with the <strong class="bold">Reset</strong> button.</li>
<li>Our tests have a lot of duplication due to the repeated calls to <strong class="source-inline">triggerRequestAnimationFrame</strong>. Simplify how this is called by creating a wrapper function called <strong class="source-inline">triggerAnimationSequence</strong> that takes an array of frame times and calls <strong class="source-inline">triggerRequestAnimationFrame</strong> for each of those times.</li>
<li>Loading an existing script (for example, on startup) will take a long time to animate all instructions, and so will pasting in code snippets. Add a <strong class="bold">Skip animation</strong> button that can be used to skip all the queued animations.</li>
<li>Ensure that the <strong class="bold">Undo</strong> button works correctly when animations are in progress.</li>
</ol>
</div>
<div>
<div id="_idContainer048">
</div>
</div>
</div></body></html>