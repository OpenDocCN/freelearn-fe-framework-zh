- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Software Design Principles and Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件设计原则和模式
- en: Software development is fundamentally a *human-intensive discipline.* This means
    that it requires knowledge of both techniques and technology, but also comprehension
    of the problem and the ability to make decisions to implement a solution on multiple
    levels of abstraction. Programming has much to do with how a developer thinks.
    Over the years, and within each context and language, guidelines and solutions
    have emerged to solve recurring problems. Knowledge of these *patterns* will help
    you identify when to apply them and speed your development on a sure footing.
    On the other hand, *principles* are guiding concepts that should be applied at
    every stage of the process and have more to do with how you approach the process.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发本质上是一门*人密集型学科*。这意味着它需要了解技术和技术，同时也需要理解问题和在多个抽象层次上实施解决方案的决策能力。编程与开发者的思维方式有很大关系。多年来，在每个上下文和语言中，都出现了解决重复问题的指南和解决方案。了解这些*模式*将帮助您确定何时应用它们，并确保您的开发工作稳步推进。另一方面，*原则*是指导概念，应在过程的每个阶段应用，并且更多关乎您如何处理这个过程。
- en: In this chapter, we will take a look at a non-exclusive and non-exhaustive list
    of principles and patterns that are common in Vue 3 application development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在Vue 3应用程序开发中常见的非排他性和非详尽性的原则和模式列表。
- en: '| **Principles** | **Patterns** |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| **原则** | **模式** |'
- en: '|'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Separation of concerns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点分离
- en: Composition over inheritance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合优于继承
- en: Single responsibility
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责
- en: Encapsulation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: KIC – keep it clean
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KIC – 保持清洁
- en: DRY – don’t repeat yourself
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DRY – 不要重复自己
- en: KISS – keep it simple stupid
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KISS – 简单就是聪明
- en: Code for the next
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为未来编写代码
- en: '|'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Singleton
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例
- en: Dependency injection
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Observer
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: Command
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Proxy
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Decorator
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰者
- en: Façade
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 门面
- en: Callbacks
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调
- en: Promises
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺
- en: '|'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Table 2.1 – The principles and patterns covered in this chapter
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 – 本章涵盖的原则和模式
- en: Understanding these principles and patterns will help you use the framework
    more efficiently and more often than not, it will prevent you from “reinventing
    the wheel”. Together with the first chapter, this will conclude the *foundational
    part* of this book and will give you the basis to follow the practical parts and
    implementation of application examples in the rest of the book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些原则和模式将帮助您更有效地使用框架，并且通常情况下，它将防止您“重新发明轮子”。与第一章一起，这将结束本书的*基础部分*，并为您跟随本书剩余部分的实际部分和应用示例的实现提供基础。
- en: What are the principles of software design?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件设计原则是什么？
- en: In software development, design principles are high-level conceptual guidelines
    that should apply to the entire process. Not every project will use the same principles,
    and these are not mandatory rules to be enforced. They can appear in a project
    from the architecture down to the **user interface** (**UI**) and the last bit
    of code. In practice, some of these principles can also influence software attributes,
    such as maintainability and re-usability.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，设计原则是适用于整个过程的宏观概念性指南。并非每个项目都会使用相同的原理，这些也不是必须强制执行的规则。它们可以从架构到用户界面（**UI**）和最后一段代码出现在项目中。在实践中，这些原则中的一些也可以影响软件属性，如可维护性和可重用性。
- en: A non-exclusive list of design principles
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计原则的非排他性列表
- en: Design principles vary somewhat depending on the context, domain, and even the
    team one may be part of at the time. The principles included in this chapter are,
    therefore, non-exclusive.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 设计原则因上下文、领域，甚至一个人可能参与的团队而异。因此，本章包含的原则是非排他性的。
- en: Separation of concerns
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点分离
- en: This is perhaps the most important principle in software engineering. Separation
    of concerns implies that a system must be divided into subsystems of elements
    grouped by their function or service (the **concern**). For example, we can consider
    the human body as a *system* composed of many subsystems (respiratory, circulatory,
    digestive, etc.). These, in turn, are integrated by different organs, which are
    made of tissues, and so forth, down to the smallest cell. Following the same idea
    in software, an application can be divided into elements grouped by concerns,
    from the large architecture all the way down to the last function. Without this
    breakdown of complexity into manageable parts, creating a functional system would
    be much harder, if not impossible.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是软件工程中最重要的原则。关注点的分离意味着一个系统必须被划分为由功能或服务（即**关注点**）组成的子系统。例如，我们可以将人体视为由许多子系统（呼吸、循环、消化等）组成的**系统**。这些子系统再由不同的器官整合，器官由组织构成，以此类推，直至最小的细胞。在软件中遵循同样的理念，一个应用程序可以被划分为按关注点分组的不同元素，从大型架构一直到最后的函数。如果没有将复杂性分解为可管理的部分，创建一个功能系统将会更加困难，甚至不可能。
- en: In general, the application of this principle starts with the big picture of
    what the system should be, looks into what it should do to accomplish that, and
    then breaks it down into manageable working parts.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这一原则的应用从系统应该是什么的大图景开始，考虑它应该做什么来实现这一点，然后将它分解为可管理的可工作部分。
- en: As an example, here is a crude graphical representation of separation of concerns
    for a web application. Each box in this diagram identifies a different *concern*
    that, in turn, can be detailed into smaller functional parts. Even better, you
    can see how this principle allows you to identify the integrating parts of a system.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个关于Web应用程序关注点分离的粗略图形表示。这个图中的每个框都标识了一个不同的**关注点**，这些关注点反过来又可以细分为更小的功能部分。更好的是，你可以看到这一原则如何帮助你识别系统的整合部分。
- en: '![Figure 2.1 – A simple architectural view of a web application showing separation
    of concerns](img/Figure_2.01_B18602.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 一个简单的Web应用程序架构视图，展示了关注点的分离](img/Figure_2.01_B18602.jpg)'
- en: Figure 2.1 – A simple architectural view of a web application showing separation
    of concerns
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 一个简单的Web应用程序架构视图，展示了关注点的分离
- en: If we were to drill down into any of these small boxes within their respective
    domains, we could still find more concerns to subdivide until we reach an indivisible
    atomic element (a component or function, for example). This principle has much
    to do with and benefits from other principles, such as abstraction and single
    responsibility. We will review them further down the line in this same chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要深入到各自领域内的任何这些小框中，我们仍然可以找到更多需要进一步细分的关注点，直到达到不可分割的原子元素（例如组件或函数）。这一原则与许多其他原则有很大关系，并从中受益，如抽象和单一职责。我们将在本章的后面进一步讨论它们。
- en: Composition over inheritance
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合优于继承
- en: The principle of *composition over inheritance* comes directly from **Object-Oriented
    Programming** (**OOP**). It states that an object should attempt to use other
    objects’ functionality when needed, by referencing or instantiating them instead
    of creating a large and complex inheritance family tree of classes to add such
    functionality. Now, JavaScript is fundamentally a *functional* language, even
    though it supports multiple paradigms, including features from OOP, so this principle
    applies as well. There is one note of warning for those migrating from OOP into
    JavaScript, and that is to avoid the temptation to treat JavaScript as a pure
    OOP language. Doing so could create unnecessary complexity instead of benefiting
    from the virtues of the language.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合优于继承**的原则直接来源于**面向对象编程**（**OOP**）。它指出，一个对象在需要时应该尝试使用其他对象的功能，通过引用或实例化它们，而不是创建一个庞大而复杂的继承家族树来添加这样的功能。现在，JavaScript本质上是一种**函数式**语言，尽管它支持多种范式，包括来自OOP的特性，所以这一原则同样适用。对于那些从OOP迁移到JavaScript的人来说，有一个警告需要注意，那就是避免将JavaScript视为纯粹的OOP语言。这样做可能会创造不必要的复杂性，而不是从语言的优点中受益。'
- en: In Vue 3, there is no extension or inheritance of components. When we need shared
    or inherited functionality, we have a nice toolset of options to replace the inheritance
    paradigm. We will see later how we can comply with this principle by using *composable
    components* in [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102), *User Interface
    Composition* *with Components.*
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue 3 中，没有组件的扩展或继承。当我们需要共享或继承功能时，我们有一套很好的工具集来替代继承范式。我们将在[第 4 章](B18602_04.xhtml#_idTextAnchor102)“用户界面组件组合”中看到如何通过使用*组合组件*来遵守这一原则。
- en: Single responsibility principle
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: This principle can be found in OOP as well as in functional programming. Simply
    put, it states that a class, method, function, or *component* should deal with
    only one responsibility or functionality. If you have worked in other disciplines
    and languages, this comes naturally. Multipurpose functions are hard to maintain
    and tend to grow out of control, especially in a language such as JavaScript,
    which is loosely typed and highly dynamic. The same concept also applies directly
    to Vue 3 components. Each component should deal with one specific operation and
    avoid attempting to do too much by itself. In practice, when a component grows
    beyond a certain scope, it is best to split it into multiple components or extract
    the behavior into external modules. There are cases when you may end up with a
    many-thousand-lines-long component, but in my experience, this is rarely necessary
    and can and should be avoided. A warning, though, is that too much specificity
    could also lead to unnecessary complexity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这一原则在面向对象编程以及函数式编程中都可以找到。简单来说，它指出一个类、方法、函数或*组件*应该只处理一个职责或功能。如果你在其他学科和语言中工作过，这会自然而然地发生。多功能函数难以维护，并且往往会失去控制，尤其是在像
    JavaScript 这样松散类型和高度动态的语言中。同样的概念也直接适用于 Vue 3 组件。每个组件应该处理一个特定的操作，避免试图自己完成太多。在实践中，当一个组件超出一定范围时，最好将其拆分为多个组件或将行为提取到外部模块中。有时你可能会得到一个数千行长的组件，但根据我的经验，这很少是必要的，并且可以也应该避免。不过，有一个警告，即过多的具体性也可能导致不必要的复杂性。
- en: 'As an example, let’s imagine a sign-in screen that also displays a sign-up
    option. This approach is common on many sites today. You could include all the
    functionalities inside just one component, but that would break this principle.
    A better alternative would be to split the components into at least three components
    for this task:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象一个同时显示注册选项的登录屏幕。这种做法在许多网站上都很常见。您可以将所有功能都包含在一个组件中，但这会违背这一原则。更好的选择是将组件拆分为至少三个组件来完成这项任务：
- en: A parent component that handles the UI logic. This component decides when to
    show/hide the sign-in and sign-up components.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 UI 逻辑的父组件。该组件决定何时显示/隐藏登录和注册组件。
- en: A child component that handles the sign-in function.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理登录功能的子组件。
- en: A child component that handles the sign-up function.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理注册功能的子组件。
- en: 'Here is a graphical representation of this configuration:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个配置的图形表示：
- en: '![Figure 2.2 – The composition of a sign-in/up interface using multiple components](img/Figure_2.02_B18602.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 使用多个组件组合的登录/注册界面](img/Figure_2.02_B18602.jpg)'
- en: Figure 2.2 – The composition of a sign-in/up interface using multiple components
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 使用多个组件组合的登录/注册界面
- en: I think that you can quickly grasp the benefits of this principle. It makes
    the code easy to manage, maintain, and adapt since web applications have the tendency
    to mutate and evolve very, very quickly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你可以很快地理解这一原则的好处。它使得代码易于管理、维护和适应，因为网络应用有快速变异和演化的趋势。
- en: Best practice tip
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践技巧
- en: Give components a single responsibility and functionality. Avoid mammoth monolithic
    components as much as possible.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 给组件赋予单一职责和功能。尽可能避免庞大的单体组件。
- en: Encapsulation
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: Encapsulation is the notion that you should wrap data and methods to act as
    a single unit while exposing a well-defined **application programming interface**
    (**API**). Often, this is done in the form of classes, modules, or libraries.
    JavaScript is not an exception, and it is highly recommended to follow this principle.
    In Vue 3, this concept applies to not only components but also CSS styles and
    HTML. The introduction of *single-file components* is a clear example of how the
    framework promotes this principle in action and how important it is for today’s
    development. With only a few edge-case situations, we should consider the (**UI**)
    components as black boxes that receive incoming parameters and provide outgoing
    data. Other components should not be *aware* of their inner workings, only the
    API. As we build example applications throughout this book, you will see this
    principle in action.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是指你应该将数据和函数包装成一个单一单元，同时暴露一个定义良好的**应用程序编程接口**（**API**）。通常，这以类、模块或库的形式完成。JavaScript也不例外，强烈建议遵循这个原则。在Vue
    3中，这个概念不仅适用于组件，也适用于CSS样式和HTML。*单文件组件*的引入是框架如何在实际中促进这个原则的一个明显例子，以及它对当今开发的重要性。在只有少数边缘情况的情况下，我们应该将（**UI**）组件视为接收传入参数并提供输出数据的黑盒，其他组件不应*了解*它们的内部工作方式，只有API。随着我们在本书中构建示例应用程序，你将看到这个原则是如何发挥作用的。
- en: KIC – keep it clean
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KIC – 保持清洁
- en: 'This principle refers mainly to the way *you write* code. I should emphasize
    here that KIC applies directly to two categories that strongly affect web and
    Vue 3 applications:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则主要指的是你编写代码的方式。我应该在这一点上强调，KIC直接应用于两个强烈影响Web和Vue 3应用程序的类别：
- en: How you format your code
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何格式化你的代码
- en: How you tidy up events and variables
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何整理事件和变量
- en: The first item includes the use of code conventions, comments, and indentation
    to the organization of the code and logical grouping of functions. For example,
    if you have methods that deal with **create, read, update, and delete** (**CRUD**)
    operations, it would be best to place them near each other in the code, rather
    than spread around the source file. Many **integrated development environments**
    (**IDEs**) contain features to collapse or expand the inner code of functions.
    This helps to quickly review and locate sections in the code with similar logic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项包括使用代码约定、注释和缩进来组织代码以及函数的逻辑分组。例如，如果你有处理**创建、读取、更新和删除**（**CRUD**）操作的方法，最好将它们放在代码的附近，而不是分散在源文件中。许多**集成开发环境**（**IDE**）包含折叠或展开函数内部代码的功能。这有助于快速审查和定位具有相似逻辑的代码部分。
- en: The second part of this principle has to do with memory and reference handling.
    JavaScript has a very good garbage collector, the function of which is to discard
    unused data to reclaim memory. However, there are occasions when the algorithm
    is prevented from freeing up resources because a reference is still pending. If
    you have worked with other languages, such as C/C++, this issue may sound familiar
    as you need to manually reserve and release memory when not in use. In JavaScript,
    if you register a function to listen to an event, it is best to manually deregister
    it at the appropriate life cycle event of your component when no longer needed.
    This will prevent memory leaks and waste of memory and also prevent some security
    risks (which are out of the scope of this book).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则的第二部分与内存和引用处理有关。JavaScript有一个非常好的垃圾回收器，其功能是丢弃未使用的数据以回收内存。然而，有时算法因为引用仍然挂起而无法释放资源。如果你使用过其他语言，如C/C++，这个问题可能听起来很熟悉，因为你需要在不再使用时手动分配和释放内存。在JavaScript中，如果你注册一个函数来监听一个事件，当不再需要时，最好在你的组件适当的生命周期事件中手动注销它。这将防止内存泄漏和内存浪费，同时也防止一些安全风险（这些风险超出了本书的范围）。
- en: 'We will review the component’s life cycle in [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102)*,
    User Interface Composition with Components,* but for now, take the following example
    as a good application of this principle and keep it as best practice. In this
    example, we will create a *composable* component to detect when the window size
    changes, so in the `script setup` section we will find something like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第4章*](B18602_04.xhtml#_idTextAnchor102)*，使用组件的用户界面组合*中回顾组件的生命周期，但到目前为止，以下示例是这一原则的良好应用，并作为最佳实践保留。在这个例子中，我们将创建一个*可组合*组件来检测窗口大小的变化，因此，在`script
    setup`部分，我们会找到如下内容：
- en: Registers a function on the window object’s resize event during the mounting
    state.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在挂载状态下，在窗口对象的resize事件上注册一个函数。
- en: Deregisters the event before the component is unmounted.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件卸载之前注销事件。
- en: 'Here is the code fragment:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码片段：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `onMounted` and `onBeforeUnmount` functions are part of the Vue 3 framework
    and are triggered by the appropriate component life cycle event. Here, we attach
    our function to the `resize` event when the component is mounted to the **Document
    Object Model** (**DOM**), and we release it just before it is removed. The important
    concept to remember is to clean up after yourself and *keep* *it clean*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMounted`和`onBeforeUnmount`函数是Vue 3框架的一部分，并由适当的组件生命周期事件触发。在这里，当组件挂载到**文档对象模型**（**DOM**）时，我们将函数附加到`resize`事件上，并在它被移除之前释放它。需要记住的重要概念是清理自己的工作并保持其整洁。'
- en: DRY – don’t repeat yourself
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DRY – 不要重复自己
- en: This principle is quite famous, almost to the point of turning into a cliché.
    Sadly, it is easily forgotten. It is credited to Andrew Hunt and David Thomas,
    who used it in the book *The Pragmatic Programmer*. It is mostly thought of as
    *don’t write the same thing twice* and is not far off, but it goes beyond that.
    It encompasses the notion of avoiding redundancy in the process as well as in
    the logic of the application. The core idea is that each process that executes
    business logic should exist in only one place in your entire application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则相当有名，几乎到了变成陈词滥调的地步。遗憾的是，它很容易被遗忘。它归功于安德鲁·亨特和大卫·托马斯，他们在《实用程序员》一书中使用了它。它主要被认为是“不要重复写同一件事”，虽然接近，但它的含义更广。它包括在过程以及应用程序的逻辑中避免冗余的概念。核心思想是，执行业务逻辑的每个过程应该只存在于整个应用程序的一个地方。
- en: For example, most web applications have some asynchronous connection with a
    server through the use of an API. There may also be multiple elements in the application
    that will use or need to use this remote computer/server communication. If you
    were going to code the entire code/logic to communicate with the server in each
    component, we would end up with not only duplication of code but also application
    logic. Maintaining such a system would open up the door to an amazing number of
    negative side effects and security concerns, poor user experience, and much more.
    According to this principle, a better approach is to abstract all communication
    code related to the server API into a single module, or class. In practice, in
    JavaScript this can even be delegated to a web worker in a separate thread. We
    will explore this implementation later in [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186),
    *Multithreading with* *Web Workers*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，大多数Web应用程序都通过API使用与服务器的一些异步连接。应用程序中可能还有多个元素将使用或需要使用这种远程计算机/服务器通信。如果你打算在每个组件中编写与服务器通信的整个代码/逻辑，我们最终会得到代码重复以及应用程序逻辑。维护这样的系统会打开通往大量负面副作用和安全问题的门，包括糟糕的用户体验等等。根据这个原则，更好的方法是将与服务器API相关的所有通信代码抽象成一个单独的模块或类。在实践中，在JavaScript中，这甚至可以委托给一个单独线程中的Web
    Worker。我们将在[*第8章*](B18602_08.xhtml#_idTextAnchor186)，*使用Web Workers进行多线程*中探讨这种实现。
- en: As a rule of thumb, if you see yourself writing kind-of-the-same-code” in different
    components or classes, it is a clear opportunity to abstract the functionality
    into its own module or component.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，如果你发现自己正在不同的组件或类中编写“有点相似”的代码，那么将功能抽象成其自己的模块或组件是一个明显的机遇。
- en: KISS – keep it simple and short
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KISS – 保持简单和简洁
- en: 'This principle is not exclusive to the software design realm. It was coined
    by the US Navy back in the ’60s (according to Wikipedia, [https://en.wikipedia.org/wiki/KISS_principle](https://en.wikipedia.org/wiki/KISS_principle)).
    The idea is pure common sense: it is better to build simple, small functional
    parts that work together than attempt to create a big and complex program in one
    go. Also, algorithms should be implemented in the most simple and efficient way.
    In web development, this principle is essential. Modern web applications are composed
    of hundreds of working parts spread over multiple computers, servers, and environments.
    The more complex a system or code implementation is, the harder it is also to
    maintain and adapt.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则并不仅限于软件开发领域。它是在20世纪60年代由美国海军提出的（根据维基百科，[https://en.wikipedia.org/wiki/KISS_principle](https://en.wikipedia.org/wiki/KISS_principle)）。这个想法纯粹是常识：构建简单、小巧且能协同工作的功能部件，比一次性尝试创建一个庞大而复杂的程序要好。此外，算法应以最简单和最有效的方式进行实现。在Web开发中，这个原则至关重要。现代Web应用程序由数百个工作部件组成，这些部件分布在多个计算机、服务器和环境上。系统或代码实现越复杂，维护和适应的难度也越大。
- en: There is a warning, though. Keeping things simple does not mean over-simplification
    or unnecessary segregation. Too many small parts can introduce unnecessary complexity
    in the system. Applying the KISS principle means staying in that sweet middle
    point where things are manageable and easy to understand.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个警告。保持简单并不意味着过度简化或不必要的隔离。太多的部分可能会在系统中引入不必要的复杂性。应用KISS原则意味着保持在那个事物可管理和易于理解的美好中间点。
- en: Code for the next
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为未来编写代码
- en: This principle is the idea that you should make your code readable and easy
    to understand for someone else besides you. Naming conventions, logic flow, and
    inter-line comments are all part of this. Not only for the case when you may need
    to delegate your code to another but also when you come back in a year or two
    to the same code. The last thing you want to do is to waste time thinking about
    what the past inexperienced you did with that clever line of spaghetti code Smart
    developers code as if they were going to teach somebody else, simply and elegantly.
    Especially if you are using or contributing to open-source code, this principle
    is vital for group collaboration. In this case, it is worth mentioning the *Boy
    Scout Principle,* which is similar but applies in groups. It states that when
    you find a hard-to-read or “spaghetti” code, you refactor it to make it clean.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则是指你应该让你的代码对除了你自己之外的其他人来说也是可读和易于理解的。命名约定、逻辑流程和行间注释都是这个原则的一部分。这不仅是为了在你可能需要将代码委托给其他人时，也是为了当你一年或两年后回到相同的代码时。你不想做的事情就是浪费时间思考过去那个缺乏经验的你用那行巧妙的意大利面代码做了什么。聪明的开发者编写代码就像他们要教给别人一样，简单而优雅。特别是如果你在使用或为开源代码做出贡献，这个原则对于团队协作至关重要。在这种情况下，值得提到的是*童子军原则*，它与前者类似，但适用于团队。它指出，当你发现难以阅读或“意大利面”代码时，你应该重构它以使其变得干净。
- en: Best practice tip
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践技巧
- en: Keep your code clean with on-source comments and documentation explaining your
    logic, as if teaching somebody else. More often than not, you will be teaching
    yourself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用源代码注释和文档来解释你的逻辑，保持你的代码干净，就像在教别人一样。大多数情况下，你实际上是在教自己。
- en: Design principles apply to many different scenarios, some beyond the practice
    of software development. It is important to consider them until they become second
    nature. In general, the application of these and other principles, together with
    the application of design patterns, make an important mark on your professional
    development.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 设计原则适用于许多不同的场景，一些场景甚至超出了软件开发实践。考虑它们直到它们成为第二天性是很重要的。一般来说，这些原则以及其他原则的应用，以及设计模式的应用，对你的职业发展留下了重要的影响。
- en: What is a software design pattern?
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是软件设计模式？
- en: In software development, it is common for certain processes and tasks to appear
    in multiple projects, in one way or another, or with some degree of variation.
    A *design pattern* is a proven solution for such similar problems. It does not
    prescribe code but acts like a reasoning template, an approach that has been abstracted
    independent of the implementation to be reused and adapted to particular circumstances.
    In practice, there is plenty of room for creativity to apply a pattern. Entire
    books have been dedicated to this subject and provide more detail than the scope
    of this book allows. In the following pages, we will take a look at what I consider
    to be the most recurrent patterns to keep in mind for Vue 3 applications. Even
    though we see them in isolation for the purposes of studying them, the reality
    is that often the implementation overlaps, mixes, and encapsulates multiple patterns
    in a single piece of code. For example, you can use a **singleton** to act as
    a **decorator** and a **proxy** to simplify or alter the communication between
    services in your application (we will do this quite often, actually, and the full
    code can be seen in [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186)*, Multithreading
    with* *Web Workers*).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，某些流程和任务以某种方式或某种程度的变化出现在多个项目中是很常见的。*设计模式*是解决此类类似问题的有效解决方案。它不规定代码，而更像是一个推理模板，一种独立于实现进行抽象、可重用和适应特定情况的方法。在实践中，有足够的空间发挥创意来应用模式。已经有许多书籍致力于这个主题，并提供了比本书范围更详细的信息。在接下来的几页中，我们将探讨我认为对于Vue
    3应用程序来说最常见且需要记住的模式。尽管我们为了研究它们而单独看待它们，但现实情况是，通常实现会重叠、混合和封装多个模式在一个代码块中。例如，你可以使用**单例**来充当**装饰器**和**代理**，以简化或改变应用程序中服务之间的通信（我们实际上会这样做很多次，完整的代码可以在[*第8章*](B18602_08.xhtml#_idTextAnchor186)*，使用*
    *Web Workers* *进行多线程* *中查看*）。
- en: Design patterns can also be understood as software engineering and development
    *best practices*. And the opposite of that, *bad practice*, is often referred
    to as an **anti-pattern**. Anti-patterns are “solutions” that, even though they
    fix an issue in the short term, create problems and bad consequences along the
    line. They generate the need to work around the problem and destabilize the whole
    structure and implementation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式也可以理解为软件工程和开发*最佳实践*。而与之相反的，*不良实践*通常被称为**反模式**。反模式是“解决方案”，尽管它们在短期内解决了问题，但沿着这条线会引发问题和不良后果。它们产生了绕过问题的需要，并使整个结构和实现不稳定。
- en: Let’s now view a list of patterns that should be part of your toolbox for Vue
    3 projects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们查看一个列表，这些模式应该是Vue 3项目工具箱的一部分。
- en: A quick reference list of patterns
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式快速参考列表
- en: 'Patterns are classified according to the type of function or problem they solve.
    There are plenty of patterns according to the context, language, and architecture
    of a system. Here is a non-exclusive list of patterns that we will use throughout
    this book and that, in my experience, are more likely to appear in Vue applications:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 模式根据它们解决的问题或功能类型进行分类。根据系统的上下文、语言和架构，有许多模式。以下是我们将在本书中使用的模式列表，以及根据我的经验，这些模式更有可能在Vue应用程序中出现：
- en: '**Creational patterns**: These deal with the approach to creating classes,
    objects, and data structures:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建型模式**：这些处理创建类、对象和数据结构的方法：'
- en: Singleton pattern
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: Dependency injection pattern
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入模式
- en: Factory pattern
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式
- en: '**Behavioral patterns**: These deal with communication between objects, components,
    and other elements of the application:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为模式**：这些处理应用程序中对象、组件和其他元素之间的通信：'
- en: Observer pattern
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式
- en: Command pattern
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式
- en: '**Structural patterns**: These provide templates that affect the design of
    your application and the relationship between components:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构模式**：这些提供模板，影响应用程序的设计和组件之间的关系：'
- en: Proxy pattern
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式
- en: Decorator pattern
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: Façade pattern
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 门面模式
- en: '**Asynchronous patterns**: These deal with data and process flow with asynchronous
    requests and events in single-threaded applications (heavily used in web applications):'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步模式**：这些模式处理单线程应用程序（在Web应用程序中大量使用）中的异步请求和事件的数据和流程：'
- en: Callbacks pattern
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调模式
- en: Promises pattern
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺模式
- en: Not by any means this list of patterns is exclusive. There are many more patterns
    and classifications, and a full library is dedicated to this subject. It is worth
    mentioning that the description and application for some of these may differ from
    one literature to another and there is some overlapping depending on the context
    and implementation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这个模式列表并不是唯一的。还有许多其他模式和分类，一个完整的库专门用于这个主题。值得一提的是，这些描述和应用可能因文献而异，并且根据上下文和实现可能存在一些重叠。
- en: With that introduction to design patterns, let’s look at them in detail with
    examples.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍完设计模式之后，让我们通过示例来详细探讨它们。
- en: The singleton pattern
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例模式
- en: This is a very common pattern in JavaScript and perhaps one of, if not the most
    important. The basic concept defines that one object’s instance must only exist
    once in the entire application, and all references and function calls are done
    through this object. A singleton can act as a gateway to resources, libraries,
    and data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 JavaScript 中非常常见的一种模式，也许是最重要的一种。基本概念定义了一个对象实例在整个应用程序中只能存在一次，所有的引用和函数调用都通过这个对象进行。单例可以作为资源、库和数据的网关。
- en: When to use it
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时使用
- en: 'Here is a short rule of thumb to know when to apply this pattern:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的规则，可以帮助您了解何时应用此模式：
- en: When you need to make sure a resource is accessed through only one gateway,
    for example, the global application state
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要确保资源只通过一个网关访问时，例如，全局应用程序状态
- en: When you need to encapsulate or simplify behavior or communications (used in
    conjunction with other patterns). For example, the API access object.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要封装或简化行为或通信（与其他模式结合使用时）。例如，API 访问对象。
- en: When the *cost* of multiple instantiations is detrimental. For example, the
    creation of web workers.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当多次实例化的 *成本* 有害时。例如，创建网络工作者。
- en: Implementations
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: There are many ways that you can apply this pattern in JavaScript. In some cases,
    the implementation from other languages is migrated to JavaScript, often following
    Java examples with the use of a `getInstance()` method to obtain the singleton.
    However, there are better ways to implement this pattern in JavaScript. Let’s
    see them next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 JavaScript 中以多种方式应用此模式。在某些情况下，从其他语言迁移的实现会遵循 Java 示例，通常使用 `getInstance()`
    方法来获取单例。然而，在 JavaScript 中实现此模式有更好的方法。让我们看看下面的例子。
- en: Method 1
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法 1
- en: 'The simplest way is through a module that exports a plain object literal or
    a **JavaScript Object Notation** (**JSON**), which is a static object:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是通过导出一个普通的对象字面量或 **JavaScript 对象表示法**（**JSON**），这是一个静态对象：
- en: ./chapter 2/singleton-json.js
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/singleton-json.js
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You then can import this module into other modules and still always have the
    same object. This works because bundlers and browsers are smart enough to avoid
    the repetition of imports, so once this object has been brought in the first time,
    it will ignore the next requests. When not using a bundler, the ES6 implementation
    of JavaScript also defines that modules are singletons.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此模块导入其他模块，并且始终拥有相同的对象。这是因为打包器和浏览器足够智能，可以避免重复导入，所以一旦这个对象第一次被引入，它将忽略后续的请求。当不使用打包器时，JavaScript
    的 ES6 实现也定义了模块是单例的。
- en: Method 2
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法 2
- en: 'This method creates a class and then, on the first instantiation, saves the
    reference for future calls. In order for this to work, we use a variable (traditionally
    called `_instance`) from the class and save the reference to the instance in the
    constructor. In the following calls, we check whether the `_instance` value exists,
    and if so, return it. Here is the code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建一个类，然后在第一次实例化时保存对未来的引用。为了使此方法生效，我们使用类中的一个变量（传统上称为 `_instance`）并在构造函数中保存对实例的引用。在后续调用中，我们检查
    `_instance` 值是否存在，如果存在，则返回它。以下是代码：
- en: ./chapter 2/singleton-class.js
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ./chapter 2/singleton-class.js
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This second method may be more familiar to other language developers. Notice
    how we are also exporting a new instance of the class and not the class directly.
    This way, the invoker will not have to remember to instantiate the class every
    time, and the code will be the same as in *method 1*. This use case is something
    that needs to be coordinated with your team to avoid different implementations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法可能对其他语言开发者来说更为熟悉。注意我们也是导出一个新的类实例，而不是直接导出类。这样，调用者就不必每次都记住实例化类，代码将与 *方法 1*
    中的代码相同。这种情况需要与您的团队协调，以避免不同的实现。
- en: 'The invoker then can call methods from each one directly (assuming the singleton
    has a function/method called `myFunction()`):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/singleton-invoker.js
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The singleton pattern is extremely useful, though it rarely exists *in isolation*.
    Often, we use singletons to wrap the implementation of other patterns and make
    sure we have a single point of access. In our examples, we will use this pattern
    quite often.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The dependency injection pattern
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern simply states that the dependencies for a class or function are
    provided as inputs, for example, as parameters, properties, or other types of
    implementations. This simple statement opens a very wide range of possibilities.
    Let’s take, for example, a class that works with the browser’s `dbManager.js`
    file exposes an object that handles the operations with the database, and the
    `projects` object deals with CRUD operations for the projects table (or collection).
    Without using dependency injection, you will have something like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/dependency-injection-1.js
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code shows a “normal” approach, where we import the dependencies
    at the beginning of the file and then use them in our code. Now, let’s tweak this
    same code to use dependency injection:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/dependency-injection-2.js
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the main difference is that `dbManager` is now passed as a parameter
    to the function. This is what is called **injection**. This opens up many ways
    to manage dependencies and, at the same time, pushes the hardcoding of dependencies
    up the implementation tree. This makes this class highly reusable, at least for
    as long as the dependency respects the expected API.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example is not the only way to inject a dependency. We could,
    for example, assign it to a property for the object’s internal use. For example,
    if the `projects.js` file was implemented using the property approach instead,
    it would look like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/dependency-injection-3.js
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this case, the invoker of the object (a singleton, by the way) needs to
    be aware of the property and assign it before calling on any of its functions.
    Here is an example of how that would look:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/dependency-injection-4.js
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But this approach is not recommended. You can clearly see that it breaks the
    principle of encapsulation, as we are directly assigning a property for the object.
    It also doesn’t feel like clean code even though it is valid code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing the dependencies one function at a time is also not recommended. So,
    what is a better approach? It depends on the implementation:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: In a class, it is convenient to require the dependencies in the constructor
    (and if not found, throw an error)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a plain JSON object, it is convenient to provide a function to set the dependency
    explicitly and let the object decide how to use it internally
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This last approach is also recommended for passing a dependency after the instantiation
    of an object when the dependency is not ready at the time of implementation
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example for the first point mentioned in the preceding list:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/dependency-injection-5.js
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the constructor, we declare the expected parameter with a default value.
    If the dependency is not provided, we throw an error. Otherwise, we assign it
    to an internal private attribute for the use of the instance. In this case, the
    invoker should look like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In an alternative implementation, we could have a function that basically does
    the same by receiving the dependency and assigning it to a private attribute:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This approach is better than directly assigning the internal attribute, but
    you still need to remember to do the assignment before using any of the methods
    in the object.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Best practice note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Whatever approach you use for dependency injection, remain constant throughout
    your code base.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we have mainly been focusing on objects. As you may
    have already guessed, passing a dependency to a function is just the same as passing
    another parameter, so it does not deserve special attention.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'This example has just moved the dependency implementation responsibility up
    to another class in the hierarchy. But what if we implement a singleton pattern
    to handle all or most of the dependencies in our application? This way, we could
    just delegate the loading of the dependencies to one class or object at a determined
    point in our application life cycle. But how do we implement such a thing? We
    will need the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: A method to register the dependency
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method to retrieve the dependency by name
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A structure to keep the reference to each dependency
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s put that into action and create a very *naive* implementation of such
    a singleton. Please keep in mind that this is an academic exercise, so we are
    not considering error checking, de-registration, or other considerations:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/dependency-injection-6.js
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this bare minimum implementation, let’s look at each line by the line
    comment:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: We create a simple JavaScript object literal as a singleton.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We declare an empty object to use as a dictionary to hold our dependencies by
    name.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `provide` function lets us register a dependency by name.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we just use the name as the field name and assign the dependency passed
    by argument (notice we are not checking pre-existing names, etc.).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we return the source object, mainly for convenience so we can chain the
    invocation.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `inject` function will take the name as registered in the `provide` function.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We return the dependency or `null` if not found.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With that singleton on board, we can now use it across our application to distribute
    the dependencies as needed. For that, we need a parent object to import them and
    populate the service. Here is an example of how that might look:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/dependency-injection-7.js
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, this module has hard-coded dependencies, and its work is to
    load them into the `dependencyService` object. Then, the dependent function or
    object needs only to import the service and retrieve the dependency it needs by
    the registration name like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This approach does create a tight coupling between components but is here as
    a reference. It has the advantage that we can control all the dependencies in
    a single location so that the maintenance benefits could be significant. The choice
    of names for the methods of the `dependencyService` object was not random either:
    these are the same used by Vue 3 inside the component’s hierarchy. This is very
    useful for implementing some User Interface design patterns. We will see this
    in more detail in [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102), *User Interface
    Composition with Components* and [*C**hapter 7*](B18602_07.xhtml#_idTextAnchor173),
    *Data* *Flow Management*.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this pattern is very important and is implemented in Vue 3 with
    the `provide`/`inject` functions. It's a great addition to our toolset, but there
    is more still. Let’s move on to the next one.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The factory pattern
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The factory pattern provides us with a way to create objects without creating
    a direct dependency. It works through a function that, based on the input, will
    return an instantiated object. The use of such an implementation will be made
    through a common or standard interface. For example, consider two classes: `Circle`
    and `Square`. Both implement the same `draw()` method, which draws the figure
    to a canvas. Then, a `factory` function would work something like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method is quite popular, especially in conjunction with other patterns,
    as we will see multiple times in this book.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The observer pattern is very useful and one of the basis of a reactive framework.
    It defines a relationship between objects where one is being observed (the **subject**)
    for changes or events, and other(s) are notified of such changes (the **observers**).
    The observers are also called **listeners**. Here is a graphical representation:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – The subject emits an event and notifies the observers](img/Figure_2.03_B18602.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – The subject emits an event and notifies the observers
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the subject emits an event to notify the observers. It is for
    the subject to define what events and parameters it will **publish**. Meanwhile,
    the observers **subscribe** to each event by registering a function with the publisher.
    This implementation is why this pattern is often referred to as the **pub/sub**
    pattern, and it can have several variations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'When looking into the implementation of this pattern, it is important to notice
    the cardinality of the publication: `1` event to `0..N` observers (functions).
    This means that the subject must implement, on top of its main purpose, the functionality
    to publish events and keep track of the subscribers. Since this would break a
    principle or two in the design (separation of concerns, single responsibility,
    etc.), it is common to extract this functionality into a middle object. The previous
    design then changes to add a middle layer:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – An observer implementation with a dispatcher middle object](img/Figure_2.04_B18602.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – An observer implementation with a dispatcher middle object
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'This middle object, sometimes referred to as an “**event dispatcher** encapsulates
    the basic functionality to register observers, receive events from the subject,
    and dispatch them to the observers. It also does some clean-up activities when
    an observer is no longer observing Let’s put these concepts into a simple and
    naive implementation of an event dispatcher in plain JavaScript:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/Observer-1.js
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding implementation is, again, naive. It doesn’t contain the necessary
    error and edge case handling that you would use in production, but it does have
    the bare basics for an event dispatcher. Let’s look into it line by line:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, we declare an object to use internally as a dictionary for
    our events.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `on` method allows the observers to register their functions. In this line,
    if the event is not initialized, we create an empty array.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this line, we just push the function to the array (as I said, this is a naive
    implementation, as we don’t check for duplicates, for example).
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `emit` method allows the subject to publish an event by its name and pass
    some data to it. Here, we run over the array and execute each function passing
    the data we received as a parameter.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `off` method is necessary to deregister the function once it is not used
    (see the *keep it clean* principle, earlier in this chapter).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order for this implementation to work, every observer and the subject need
    to reference the same implementation of the `ObserverClass`. The easiest way to
    secure this is to implement it through a *singleton pattern*. Once imported, each
    observer registers with the dispatcher with this line:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, the subject emits the event and passes the data with the following lines:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, when the observer no longer needs to watch the subject, it needs to
    clean up the reference with the `off` method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are a good number of edge cases and controls that we have not covered
    here, and rather than reinventing the wheel, I suggest using a ready-made solution
    for these cases. In our book, we will use one named `mitt` ([https://www.npmjs.com/package/mitt](https://www.npmjs.com/package/mitt)).
    That has the same methods as in our example. We will see how to install packaged
    dependencies in [*Chapter 3*](B18602_03.xhtml#_idTextAnchor079), *Setting up a*
    *Working Project*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern is very useful and easy to understand and implement. Instead of
    executing a function right away, the basic concept is to create an object or structure
    with the information necessary for the execution. This data package (the **command**)
    is then delegated to another object that will perform the execution according
    to some logic to handle it. For example, the commands can be serialized and queued,
    scheduled, reversed, grouped together, and transformed. Here is a graphical representation
    of this pattern with the necessary parts:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – A graphical implementation of the command pattern](img/Figure_2.05_B18602.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – A graphical implementation of the command pattern
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shows how the clients submit their commands to the **Invoker**.
    The invoker usually implements some sort of queue or task array to handle the
    commands and then routes the execution to the proper **Receiver**. If there is
    any data to return, it also returns it to the proper client. It is also common
    that the invoker attaches additional data to the command to keep track of clients
    and receives, especially in the case of asynchronous executions. It also provides
    a single point of “entry” to the receivers and decouples the “clients” from them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s again work on a naive implementation of an `Invoker` class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/Command-1.js
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we have implemented a bare-bones example of what an
    `Invoker` should have line by line:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The `Invoker` exposes a method to add commands to the object. This is only necessary
    when the commands will be somehow queued, serialized, or processed according to
    some logic.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This line executes the command according to the `action` field contained in
    the `command_data` parameter.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on the `action` field, the *invoker* routes the execution to the proper
    receiver.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are many ways to implement the logic for routing the execution. It is
    important to notice that this pattern can be implemented on a larger scale depending
    on the context. For example, the invoker might not even be in the web client application
    and be on the server or on a different machine. We will see an implementation
    of this pattern in [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186), *Multithreading
    with Web Workers*, where we use this pattern to process tasks between different
    threads and unload the main thread (where Vue 3 runs).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The proxy pattern
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The definition for this pattern comes directly from its name, as the word “proxy”
    means something or someone who acts on behalf of another as if it was the same.
    That is a mouthful, but it will make you remember it. Let’s look into an example
    to clarify how this works. We will need at least three entities (components, objects,
    etc.):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: A **client** entity that needs to access the API of a target entity
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **target** entity that exposes a well-known API
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **proxy** object that sits in between and exposes the same API as the target
    while at the same time intercepting every communication from the client and relaying
    it to the target
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can graphically represent the relationship between these entities in this
    way:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – The proxy object exposes the same API as the target](img/Figure_2.06_B18602.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – The proxy object exposes the same API as the target
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'The key factor for this pattern is that the proxy behaves and exposes the same
    API as the target, in such a way that the client does not know or doesn’t need
    to know that it is dealing with a proxy and not the target object directly. So,
    why would we want to do such a thing? There are many good reasons, such as the
    following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to maintain the original unmodified API, but at the same time:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need to process the inputs or outputs for the client
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Need to intercept each API call to add internal functionality, such as maintenance
    operations, performance improvements, error checking, and validation
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The target is an expensive resource, so a proxy could implement logic to leverage
    their operations (for example, a cache)
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to change the client or the target but can’t modify the API
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to maintain backward compatibility
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more reasons that you may come across, but I hope that by now you
    can see how this can be useful. Being a pattern, this template can be implemented
    on multiple levels, from a simple object proxy to a full application or server.
    It is quite common when performing partial upgrades of a system or application.
    On a lower level, JavaScript even natively includes a constructor for proxying
    objects that Vue 3 uses internally to create reactivity.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B18602_01.xhtml#_idTextAnchor017), *The Vue 3 Framework*, we
    reviewed the options for reactivity with the `ref()` but this new version of Vue
    also includes another alternative for complex structures, called `reactive()`.
    The first one uses pub/sub methods (the observer pattern!), but the latter uses
    native proxy handlers (this pattern!). Let’s look into an example of how this
    native implementation may work with a naive partial implementation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'In this simple example, we will make an object with reactive properties automatically
    convert Celsius degrees to and back from Fahrenheit using a `Proxy` object:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/proxy-1.js
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s review the code line by line to see how this works:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: In this line, we declare the `temperature` object, which is going to be our
    target to be proxied. We initialize its two properties with an equal converted
    value.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We declare a `handler` object, which will be our proxy for the temperature object.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `set` function in the proxy handler receives three arguments: the target
    object, the key referred to, and the value attempted to be assigned. Notice that
    I say “attempted”, as the operation has been intercepted by the proxy.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On this line, we perform the assignment as intended to the object property.
    Here, we could have done other transformations or logic, such as validation or
    raised an event (the observer pattern again!).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice how we use a switch to filter the property names that we are interested
    in. When the key is `celsius`, we calculate and assign the value in Fahrenheit.
    The opposite happens when we receive an assignment for `fahrenheit` degrees. This
    is where the **reactivity** comes into play.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the `get` function, at least in this example, we just specifically return
    the value requested. In the way this is implemented, it would be the same as if
    we skip the `getter` function. However, it is here as an example that we could
    operate and transform the value to be returned as this operation is also intercepted.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in line 7, we declare the `degrees` object as the proxy for `temperature`
    with the handler.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On this line, we test the reactivity by assigning a value in *Celsius* to the
    member of the `degrees` object, just like we normally would to any other object.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we print the `degrees` object to the console, we notice that the `fahrenheit`
    property has been automatically updated.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a rather limited and simple example of how the native `Proxy()` constructor
    works and applies the pattern. Vue 3 has a more complex approach to reactivity
    and tracking dependencies, using the proxy and observer patterns. However, this
    gives us a good idea of what approach is happening behind the scenes when we see
    the HTML updated live in front of our very eyes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of proxying between a client and a target is also related to the
    next two patterns: the *decorator and the façade patterns* since they are also
    a sort of proxy implementation. The distinguishing key factor is that the proxy
    retains the same API as the original target object.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The decorator pattern
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern may, at first sight, seem very similar to the *proxy pattern*,
    and indeed it is, but it adds a few distinctive features that set it apart. It
    does have the same moving parts as the proxy, meaning there is a **Client**, a
    **Target**, and a **Decorator** in between that implements the same interface
    as the target (yes, just like in the proxy pattern). However, while in the *Proxy
    pattern* the intercepted API calls mainly deal with the data and internal maintenance
    (“housekeeping”), the decorator augments the functionality of the original object
    to do more. This is the defining factor that separates them.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: In the proxy example, notice how the additional functionality was an *internal
    reactivity* to keep the degrees in each scale synchronized. When you change one,
    it internally and automatically updates the other. In a decorator pattern, the
    proxy object performs additional operations before, during, or after executing
    the API call to the target object. Just like in the proxy pattern, all of this
    is transparent for the client object.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, building on the previous code, imagine that now we want to log
    each call to the API of a certain target while keeping the same functionality.
    Graphically, it would look like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – An example of a decorator that augments the target with a logging
    feature](img/Figure_2.07_B18602.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – An example of a decorator that augments the target with a logging
    feature
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, what was first a simple proxy, now by the mere act of performing a humble
    logging call, has now become a decorator. In the code, we only need to add this
    line before the end of the `set()` method (assuming there is also a function named
    `getTimeStamp()`):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Of course, this is a simple example just to make a point. In the real world,
    decoratorsare very useful for adding functionality to your application without
    having to rewrite the logic or significant portions of your code. On top of this,
    decorators can be *stackable* or *chainable*, meaning that you can create “decorators
    for decorators” if needed, so each one will represent one step of added functionality
    that would maintain the same API of the target object. And just like that, we
    are beginning to step into the boundaries of a **middleware pattern**, but we
    will not cover it in this book. Anyway, the idea behind that other pattern is
    to create layers of middleware functions with a specified API, each one that performs
    one action, but with the difference that any step can decide to abort the operation,
    so the target may or may not be called. But that is another story... let’s get
    back to decorators.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Previously in this book, we mentioned that Vue 3 components do not have inheritance
    like plain JavaScript classes implemented by extending from one another. Instead,
    we can use the decorator pattern on components to add functionality or change
    the visual appearance. Let’s look at a brief example now, as we will see components
    and UI design in detail in [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102), *User
    Interface Composition* *with Components*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that we have the simplest of components that displays a humble `h1`
    tag with a title that receives the following as input:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/decorator-1.vue
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this simple component, we declare a single input named `label` in line `//1`.
    Don’t worry about the syntax for now, as we will see this in detail in [*Chapte**r
    4*](B18602_04.xhtml#_idTextAnchor102)*,* *User Interface Composition with Components.*
    On line `//2`, we are interpolating the value plainly inside the `h1` tags just
    as expected.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to create a decorator for this component we need to apply the following
    simple rules:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: It has to act on behalf of the component (object)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has to respect the same API (inputs, outputs, function calls, etc.)
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has to augment the functionality or visual representation before, after,
    or during the execution of the target API
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that in mind, we can create a decorator component that intercepts the
    label attribute, changes it a bit, and also modifies the visual appearance of
    the target component:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/decorator-2.vue
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this code, in line `//1`, you can see that we keep the same interface as
    the target component (that we imported in the previous line), and then in line
    `//2`, we modify (augment) the `color` attribute and in line `//3` we are also
    modifying the data passed to the target component by adding three exclamation
    marks. With those simple tasks, we have kept the conditions to build a decorator
    pattern extrapolated to Vue 3 components. Not bad at all.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Decorators are very useful, but there is still one more proxy-like pattern
    that is also very common and handy: the façade pattern.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: The façade pattern
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, you may have seen the progressive pattern in these, well, patterns.
    We started with a proxy to act on behalf of another object or entity, we augmented
    it with the use of decorators while keeping the same API, and now is the turn
    for the façade pattern. Its job is, in addition to the functions of a proxy and
    decorator, to simplify the API and hide the large complexity behind it. So, a
    façade sits between a client and a target, but now the target is highly complex,
    being an object or even a system or multiple subsystems. This pattern is also
    used to change the API of an object or to limit the exposure to the client. We
    can picture the interactions as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – A façade object simplifying the interaction with a complex API
    or system](img/Figure_2.08_B18602.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – A façade object simplifying the interaction with a complex API
    or system
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the main purpose of the façade is to offer a simpler approach
    to a complex interaction or API. We will use this pattern many times during our
    examples to simplify native implementations in the browser with more developer-friendly
    approaches. We will use libraries to encapsulate the use of IndexedDB and create
    our own simplified communication with web workers in [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186),
    *Multithreading with* *Web Workers*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, you will have seen this pattern in action before, as it is
    one of the foundational concepts of modern technology. *Hiding complexity* behind
    a simple interface (API) is all around us and is a big part of web development.
    After all, the entire internet is extremely complicated, with thousands of moving
    parts, and the technology that makes up web pages is close to magic. Without this
    pattern, we would still be programming with zeros and ones.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, you will add layers of simplification to your own applications
    to break down complexity. One way to do it is to use third-party libraries that
    provide a simplified interface. In the following chapters, we will use some of
    these, such as the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '**Axios**: To handle all **Asynchronous JavaScript and XML** (**AJAX**) communications
    with the server'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DexieDB**: To handle the API to IndexedDB (the browser’s local database)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mitt**: To create event pipelines (we mentioned this in the Observer pattern)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vue 3**: To create amazing UIs'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, there are façade libraries for most of the native implementations
    of web technologies, which are well battle tested. Developers are very good at
    simplifying these and sharing the code with others, thanks to the open source
    movement. Still, when using other people’s modules, make sure they are “safe.”
    Don’t reinvent the wheel, and don’t repeat yourself But now, it is time to move
    on to the next pattern in our list.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The callback pattern
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The callback pattern is easy to understand. It applies when an operation needs
    to be executed after a **synchronous** or **asynchronous** operation has finished.
    For this, the function invocation includes, as one of the parameters, a function
    to be executed when the operations are completed. Having said that, we need to
    distinguish between the following two types of code flow:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous operations are executed one after another in sequential order. It
    is the basic code flow, top to bottom.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous operations are executed out of the normal flow once invoked. Their
    length is uncertain, as well as their success or failure.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is for asynchronous cases that the *callback pattern* is especially useful.
    Think, for example, of a network call. Once invoked, we don’t know how long it
    will take to get an answer from the server and whether it will succeed, fail,
    or throw an error. If we didn’t have asynchronous operations, our application
    would be *frozen*, waiting until a resolution happens. That would not be a good
    user experience, even though it would be computationally correct.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: One important feature in JavaScript is that, being single-threaded, asynchronous
    functions don’t block the main thread allowing the execution to continue. This
    is important since the rendering functions of the browser run on the same thread.
    However, this is not free as they do consume resources, but they won’t freeze
    the UI, at least in theory. In practice, it will depend on a number of factors
    heavily influenced by the browser environment and the hardware. Still, let’s stick
    to the theory.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of a synchronous callback function and turn it asynchronous.
    The example function is very simple: we will calculate the Fibonacci value of
    a given number using the callback pattern. But first, a refresher on the formula
    for the calculation:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'So, here is a JavaScript function that applies the formula and receives a callback
    to return the value. Notice that this function is synchronous:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/callback-1.js - Synchronous Fibonacci
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notice how instead of returning the value with `return`, we are passing it
    as a parameter to the `callback` function. When is it useful to use such a thing?
    Consider these simple examples:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Just by replacing the callback function, we can considerably alter how the
    result is presented. However, the example function has a fundamental flaw affecting
    the user experience. Being synchronous, the calculation time is proportional to
    the parameter passed: the larger `n`, the more time it will take. With a sufficiently
    large number, we can easily hang up the browser, but also, much before that, we
    can freeze the interface. You can test that the execution is synchronous with
    the following snippet:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To turn this simple function into an asynchronous function, you can simply
    wrap the logic inside a `setImmediate` call. This will take the execution out
    of the normal workflow. The new function now looks like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, we use an arrow function to wrap up the code without any modifications.
    Now, see the difference when we execute the same snippet as before with this function:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see by the output, the snippet outputs `After` before `34`. This
    is because our asynchronous operation has been taken out of the normal flow as
    expected. When calling an asynchronous function, the execution *does not wait*
    for a result and continues executing the next instruction. This can be confusing
    at times but is very powerful and useful. However, the pattern does not prescribe
    how to handle errors or failed operations or how to chain or sequentially run
    multiple calls. There are different ways to deal with those cases, but they are
    not part of the pattern. There is another way to handle asynchronous operations
    that offers more flexibility and control: *promises.* We will see this next, and
    in most cases, you can use either pattern interchangeably. I say, “in most cases,”
    not all!'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The promise pattern
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *promises pattern* is made primarily to deal with asynchronous operations.
    Just like with callbacks, the invocation of a promised function takes the execution
    out of the normal flow, but it returns a special object called `Promise`. This
    object exposes a simple API with three methods: `then`, `catch`, and `finally`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: The `then` method receives two callback functions, traditionally called `resolve`
    and `reject`. They are used in the asynchronous code to return a successful value
    (`resolve`) or a failed or negative value (`reject`).
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `catch` method receives an `error` parameter and is triggered when the process
    throws an `error` and the execution is interrupted.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `finally` method executes in either case and receives a callback function.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While a promise is running, it is said to be in an *indeterminate* state until
    it is resolved or rejected. There is no time limit for how long a promise will
    wait in this state, something that makes it especially useful for lengthy operations
    such as network calls and **inter-process** **communication** (**IPC**).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to implement the previous example with the Fibonacci series using
    promises:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At first sight, it is easy to see that the implementation has changed a bit.
    We start on line `//1` by immediately returning a `new Promise()` object. This
    constructor receives a callback function, that will, in turn, receive two callbacks
    named `resolve()` and `reject()`. We need to use these in our logic to return
    a value in case of success (`resolve`) or failure (`reject`). Also notice that
    we don’t have to wrap our code in a `setImmediate` function, as a promise is by
    nature asynchronous. We now check for negative numbers and then reject the operation
    in that case (line `//2`). The other change we make is to replace the `callback()`
    invocation for `resolve()` in lines`//3` and `//4`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'The invocation now also changes:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can see, we chain to the invocation, the `then` method, and pass to
    it the two functions for success and failure (`resolve` and `reject` in our code).
    Just like before, we get the same output. Now, this may seem more verbose (it
    is), but the benefits greatly outweigh the extra typing. Promises are chainable,
    meaning that for successful operations, you can return a new promise and, that
    way, have a sequential operation. Here is an example:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are other methods exposed by the `Promise` constructor, such as `.all`,
    but I will refer you to the documentation to dig deeper into the possibilities
    and syntax ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)).
    Still, quite verbose. Lucky for us, JavaScript provides us with a simplified syntax
    to handle promises, **async/await,** and think of them as a way to code in a more
    “traditional” way. This only applies to the invocation of promised functions and
    can only be used in functions.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this as an example, let’s imagine that we have three functions that
    return promises, named `MyFuncA`, `MyFuncB`, and `MyFuncC` (yes, I know, not the
    greatest names). Each one returns, in case of success, *one single value* (this
    is a condition). These are then used within `MyProcessFunction` with the new syntax.
    Here is the declaration:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We start by declaring our function with the `async` keyword (line `//1`). This
    signals to the interpreter that we will use the `await` syntax inside our function.
    One condition is to wrap the code in a `try...catch` block. Then, we can use the
    `await` keyword in front of the invocation of each promised function call, as
    in line `//3`. By line `//4`, we are certain that each variable has received a
    value. Certainly, this approach is easier to follow and read.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s investigate the equivalences for the line:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will match the *thenable* (using `.``then`) syntax:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, the problem with this last syntax is that we need to make sure that
    all the variables `a`, `b`, and `c` have values before we can run line `//4`,
    `console.log(a+b+c)`, which would mean chaining the invocations like this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This format is harder to follow and certainly more verbose. For these cases,
    the `async/await` syntax is preferred.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: The use of promises is great for wrapping lengthy or uncertain operations and
    integrating with other patterns that we have seen (façade, decorator, etc.). It
    is an important pattern to keep in mind that we will use extensively in our applications.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen principles for software development and important
    design patterns, with examples in plain JavaScript and, when appropriate, hinted
    at implementations with Vue 3\. These patterns can be hard to grasp the first
    time you see them, but we will use them and return to them in the rest of the
    book so that this chapter will work as a reference. This will give you a better
    idea of when and how to apply different patterns according to the needs of your
    application.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start to implement a project from scratch and will
    set the foundations for the applications we will build in the rest of the book.
    As we move forward, we will reference these patterns to help you consolidate their
    application.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between a principle and a pattern?
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is the singleton pattern so important?
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you manage dependencies?
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What patterns make reactivity possible?
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do patterns intertwine? Why? Can you give an example?
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is asynchronous programming, and why is it so important?
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you think of use cases for *promised* functions?
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
