<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Dealing with Data and State</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will go one step further in structuring our application and work on the data architecture that serves as the base for our task management system. So far, we've obtained task data synchronously from the task service which we created in the previous chapter. However, in real-world scenarios, this will rarely be the case. In a real application, we would obtain data in an asynchronous way where we need to manage client state, and we need to ensure the integrity of our state and data at all times. In this chapter, we'll look at how we can restructure our application to deal with a RESTful interface using the HTTP client module which comes with Angular. We will use an in-memory database to simulate our HTTP backend. Furthermore, we will be looking at some critical concepts like reactive programming, immutability, and "pure" components to help us build a data architecture that shines on both a small as well as large scale.</p>
<p>In this chapter, we will look at the following topics:</p>
<ul>
<li>Reactive programming, the basics of RxJS, and its operators to deal with asynchronous data</li>
<li>Restructuring our application to deal with simulated HTTP calls to an in-memory database</li>
<li>The concept of immutability</li>
<li>Using pure components in Angular</li>
<li>The introduction of container components to separate our user interface from application state</li>
<li>Using <kbd>ChangeDetectionStrategy.OnPush</kbd> for pure components</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive programming with RxJS</h1>
                </header>
            
            <article>
                
<p>So far, we have used simple array data structures in the task list that we created. That is not really what we'll find in real-world scenarios. In real applications, we have to deal with asynchronous data coming from a server.</p>
<p>Handling data in applications behaves very similarly to streams. You take input, transform it, combine it, merge it, and finally, write it into the output. In systems such as this, it's also very likely that input is in a continuous form and sometimes even of infinite duration. Just take a live feed as an example; this type of data flows continuously, and the data also flows infinitely. Functional and reactive programming are paradigms to help us deal with this kind of data more cleanly:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/857c6a52-fa81-44e7-ac6d-39dc549bc8fa.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">A simple observable subscription with value emission and a transformation</div>
<p>Angular is reactive at its very core, and the whole change detection and bindings are built using a reactive architecture. The input and output of components, which we've learned about in the previous chapter, is nothing but a data flow that is established using a reactive event-driven approach. Angular uses RxJS, a functional and reactive programming library for JavaScript, to implement this data flow. In fact, the <kbd>EventEmitter</kbd>, which we've used to send output from within our components, is just a wrapper around a RxJS observable.</p>
<p>Before we mess around with RxJS within our task management system, let's take a look at a straightforward RxJS example first to see how we can deal with observable streams in general:</p>
<pre>import {from} from 'rxjs';<br/>import {map, filter} from 'rxjs/operators';<br/><br/>from([1, 2, 3, 4])<br/>  .pipe(<br/>    map((num) =&gt; num * num),<br/>    filter((num) =&gt; num &lt; 10)<br/>  )<br/>  .subscribe((num) =&gt; console.log(num));<br/><br/>// This script is finishing with the following output on the console:<br/>// 1<br/>// 4<br/>// 9</pre>
<p>This simple script will generate an observable sequence from an array of numbers. We pass each number through the observable stream, item by item. We're using two simple operators before we subscribe to the observable and print the resulting items to the console. The map operator is squaring each number, which flows through the observable stream. The filter operator is then filtering out items which are greater or equal to <kbd>10</kbd>.</p>
<p><span>Observables provide a large number of so-called operators that allow you to transform the data stream that originated at the source observable. You might already know about some of these functional operators from the ECMAScript 5 array extra functions, such as </span><kbd>map</kbd><span> and </span><kbd>filter</kbd><span>. Using operators, you can model a whole transformation flow until you finally subscribe to the data.</span></p>
<p>I often use the analogy of water pipes when talking about RxJS observables. If you think of your transformation operators as pieces within a pipeline, then the <kbd>subscribe</kbd> function is the final drain valve within the pipe. If you don't open the drain of a water pipe, no water will flow. The behaviour of RxJS is very similar. Without the final subscribe call, RxJS will not perform any of the operators. Only if you subscribe to an observable will it become active. Within the subscribe callback, you can then use the resulting items which flow through the stream.</p>
<p>Now, building pipelines come with a significant advantage. A transformation system which is built like a pipe is expecting input, and it will deliver some output. However, we don't perform anything immediately. Instead, we're setting up a system which knows how to deal with the data, when there's data flowing through it. This pipeline system is entirely stateless and reactiveâ€”<span>r</span>eactive in the sense that it will react to incoming data and produce a new output of each input.</p>
<p>We can treat any source which emits items over time as an observable. Let's take a look at another example:</p>
<pre>import {fromEvent} from 'rxjs';<br/>import {throttleTime, map} from 'rxjs/operators';<br/><br/>fromEvent(window, 'mousemove')<br/>  .pipe(<br/>    throttleTime(200),<br/>    map((event: MouseEvent) =&gt; `Move(${event.screenX}, ${event.screenY})`)<br/>  )<br/>  .subscribe((move) =&gt; console.log(move));</pre>
<p>In this example, we're using the <kbd>fromEvent</kbd> observable helper to create an observable source from the mouse move event on the window object. For each mouse move event, the event object will be emitted through the observable stream. We will then use the <kbd>throttleTime</kbd> operator to limit the amount of event emitted by the stream. This operator will block subsequent emissions within a given time frame, therefore throttling the steam. Within a <kbd>map</kbd> operator, we then format the emitted mouse event and finally subscribe to write the results to the console.</p>
<p>Using only a few lines of code, we've implemented an excellent little pipeline which transforms a source into a usable result. There lies the power of observables, reactive programming, and RxJS. We can solve difficult problems regarding building a reactive system in a very lovely and declarative way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP client and in-memory web APIs</h1>
                </header>
            
            <article>
                
<p>At the beginning of this chapter, we decided that we'd like to change the way how we handle data within our application. Currently, our task data is embedded within our task service and retrieving as well as manipulating are both happening synchronously. Going forward, we want to change that and come as close as <span>possible </span>to a real-world situation. At the same time, we should keep an eye on the complexity costs of our solution.</p>
<p>Angular comes with a very nice utility for these use cases. Using the in-memory web API module, we can create a mock back-end service which will allow us to use a RESTful interface the same way as if we would connected to a real server. All remote calls using the Angular HTTP client will, however, be redirected to our local in-memory database. The way we deal with our data will be entirely authentic. At some point, we could even create a real backend server and connect our application to it, while our frontend code would stay the same.</p>
<p>Let's look into the necessary changes in order to implement our data layer using the in-memory web API. As a first step, we need to install the package using npm. Open a command line and navigate to your project directory. Then, execute the following command:</p>
<pre><strong>npm install --save angular-in-memory-web-api@0.5.1</strong></pre>
<p>Running this command will install the in-memory web API package and save it to our project <kbd>package.json</kbd> file. As a next step, we want to create our application's in-memory database. We're creating a new TypeScript file on the path <kbd>src/app/database.ts</kbd> and adding the following content:</p>
<pre>import {InMemoryDbService} from 'angular-in-memory-web-api';<br/>import {Task} from './model';<br/><br/>export class Database implements InMemoryDbService {<br/>  createDb() {<br/>    const tasks: Task[] = [<br/>      {id: 1, title: 'Task 1', done: false},<br/>      {id: 2, title: 'Task 2', done: false},<br/>      {id: 3, title: 'Task 3', done: true},<br/>      {id: 4, title: 'Task 4', done: false}<br/>    ];<br/>    return {tasks};<br/>  }<br/>}</pre>
<p>Using the Angular in-memory web API, we can create a class which holds all our initial data. The class is implementing the <kbd>InMemoryDbService</kbd> interface, which demands that we create a method named <kbd>createDb</kbd>. Within this function, we can create resources which will be made available for use with the Angular HTTP client in a RESTful style.</p>
<p>Next, we're going to update our main application module located in the path <kbd>src/app/app.module.ts</kbd>, and set up our application for using the in-memory web API with our newly created database. You should only add the highlighted parts of the following code excerpt. The ellipsis character is indicating that there's more code existing, which is irrelevant for the changes you need to apply to your code:</p>
<pre>...<br/><strong>import {HttpClientModule} from '@angular/common/http';</strong><br/><strong>import {HttpClientInMemoryWebApiModule} from 'angular-in-memory-web-api';</strong><br/><br/><strong>import {Database} from './database';</strong><br/>...<br/><br/>@NgModule({<br/>  ...<br/>  imports: [<br/>    BrowserModule,<br/>    <strong>HttpClientModule,</strong><br/><strong>    HttpClientInMemoryWebApiModule.forRoot(Database, {</strong><br/><strong>      delay: 0</strong><br/><strong>    })</strong><br/>  ],<br/>  ...<br/>})<br/>export class AppModule {<br/>}</pre>
<p>We've added two more modules to the import section of our main application module. We've added the Angular HTTP client module which we'll use to call our simulated REST endpoint in our database. As discussed earlier, this library would also be used in the same way if we were to call a remote server.</p>
<p>The second module we are importing is the HTTP client adapter of the in-memory web API module. This module will intercept all HTTP calls executed by the Angular HTTP client and redirect the requests to our local database. We're using the factory method <kbd>HttpClientInMemoryWebApiModule.forRoot</kbd> to configure the adapter module before we import it. In the first argument to the factory function, we're passing the database class we've created. In the second argument, we can provide some additional options for the adapter. In our case, we're setting the delay to zero. Using higher values will artificially delay the responses from our database, which is nice if you want to simulate a network delay.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using behaviour subjects</h1>
                </header>
            
            <article>
                
<p>The HTTP client is using RxJS to return observable streams for all HTTP request methods. The response body will then be emitted through the observable streams, and we can subscribe to the streams to retrieve the results:</p>
<pre>this.http.get&lt;Task[]&gt;('/api/tasks')<br/>  .subscribe((tasks) =&gt; console.log(tasks));</pre>
<p>Since we know how to deal with observable streams within our components, we could go ahead and directly return the observable resulting from the HTTP client call.</p>
<p>However, instead, we want to make use of a RxJS class called <kbd>BehaviorSubject</kbd>. The problem with directly returning the observable from the HTTP client is that we're always returning a new observable when the tasks are loaded from the server. That would be impractical, and after reloading tasks when performing updates or adding new tasks, we'd like to be able to reuse the same observable stream to re-emit the updated task list. This way, all components of our system will be notified when we reload our tasks. You can use a behaviour subject whenever you want to create your own source of an observable stream. You can control what should be emitted and when. Let's look at a simplified example of how a behaviour subject can be used:</p>
<pre>const subject = new BehaviorSubject&lt;number&gt;(0);<br/>subject.asObservable().subscribe(num =&gt; console.log(`Item: ${num}`));<br/>// console output -&gt; Item: 0<br/><br/>subject.next(1);<br/>// console output -&gt; Item: 1<br/><br/>subject.next(2);<br/>// console output -&gt; Item: 2<br/><br/>subject.asObservable().subscribe(num =&gt; console.log(`Second subscription: ${num}`));<br/>// console output -&gt; Second subscription: 2</pre>
<p>Within the constructor of a behaviour subject, we can specify the initial value or item which will be emitted initially to all subscribers. Behaviour subjects are also always emitting the most recent item they have to their new subscribers.</p>
<p>A behaviour subject is both an observer as well as an observable. Therefore, it would be possible to directly call the<span> </span><kbd>subscribe</kbd><span> </span>method on the subject. However, if you'd like to convert your subject into a plain observable again, you can use the<span> </span><kbd>asObservable</kbd><span> </span>method. This is especially useful for encapsulation. When you're returning your observable stream to be used outside of your immediate program logic, you don't want to give the outside world the power to emit items. It should only be possible to observe the stream.</p>
<p>Finally, whenever you want to emit a new item through the observable stream, you can use the<span> </span><kbd>next</kbd><span> </span>method on the subject.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading data in the task service</h1>
                </header>
            
            <article>
                
<p>It's time to change our task service and make use of the Angular HTTP client to obtain the task data from our database. Let's open up the <kbd>src/app/tasks/task.service.ts</kbd> file and change the file content to the following:</p>
<pre>import {Injectable} from '@angular/core';<br/>import {HttpClient} from '@angular/common/http';<br/>import {BehaviorSubject} from 'rxjs';<br/>import {Task} from '../model';<br/><br/>@Injectable()<br/>export class TaskService {<br/>  private tasks = new BehaviorSubject&lt;Task[]&gt;([]);<br/><br/>  constructor(private http: HttpClient) {<br/>    this.loadTasks();<br/>  }<br/><br/>  private loadTasks() {<br/>    this.http.get&lt;Task[]&gt;('/api/tasks')<br/>      .subscribe((tasks) =&gt; this.tasks.next(tasks));<br/>  }<br/><br/>  getTasks() {<br/>    return this.tasks.asObservable();<br/>  }<br/><br/>  addTask(task: Task) {<br/>    return this.http<br/>      .post&lt;Task&gt;('/api/tasks', task)<br/>      .subscribe(() =&gt; this.loadTasks());<br/>  }<br/><br/>  updateTask(task: Task) {<br/>    return this.http<br/>      .post(`/api/tasks/${task.id}`, task)<br/>      .subscribe(() =&gt; this.loadTasks());<br/>  }<br/>}</pre>
<p>We are injecting the Angular HTTP client into our constructor so we can use it within our service. In the <kbd>loadTasks</kbd> method, we're executing a GET call on the RESTful <span>tasks </span>resource which is provided by our database.</p>
<p>The <kbd>tasks</kbd> member of our service is holding a behaviour subject which is initialised with an empty array. Whenever we call the internal <kbd>loadTasks</kbd> method, the resulting task list array is emitted through our behaviour subject by calling the next method.</p>
<p>The <kbd>loadTasks</kbd> method is first called within the service constructor. That will ensure that the resulting task list obtained from the HTTP call is initially emitted through our behaviour subject. We also call the <kbd>loadTasks</kbd> method right after we've completed the POST requests within the <kbd>addTask</kbd> and <kbd>updateTask</kbd> methods. That will guarantee that we're reloading the updated task list from the "server" and emitting it through our behaviour subject.</p>
<p>Within the <kbd>getTasks</kbd> method, we're converting our subject to an observable and returning it. This way, we can ensure that no one outside of the service will have the power to emit items through our subject. Using the observable of our behaviour subject, we can have hundreds of components subscribing, which will all receive the most recent task list whenever there is a change in our data.</p>
<p>The in-memory web API will automatically generate IDs for our tasks when we add new tasks by executing a post request to the tasks resource. This means that when we call the <kbd>addTask</kbd> method with a task object, we can skip adding the ID property and the in-memory database will take care of finding the next possible ID value for us.</p>
<p>Now, let's use our updated task service in the task list component. Open up the <kbd>src/app/tasks/task-list/task-list.component.ts</kbd> file and apply the following changes. Again, effective changes are in bold:</p>
<pre>import {Component, ViewEncapsulation} from '@angular/core';<br/>import {TaskService} from '../../tasks/task.service';<br/>import {Task, TaskListFilterType} from '../../model';<br/><strong>import {Observable, combineLatest, BehaviorSubject} from 'rxjs';</strong><br/><strong>import {map} from 'rxjs/operators';</strong><br/><br/>@Component({<br/>  selector: 'mac-task-list',<br/>  templateUrl: './task-list.component.html',<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class TaskListComponent {<br/>  tasks: <strong>Observable&lt;Task[]&gt;;</strong><br/>  filteredTasks: <strong>Observable&lt;Task[]&gt;;</strong><br/>  taskFilterTypes: TaskListFilterType[] = ['all', 'open', 'done'];<br/>  activeTaskFilterType = <strong>new BehaviorSubject&lt;TaskListFilterType&gt;('all');</strong><br/><br/>  constructor(private taskService: TaskService) {<br/>    this.tasks = taskService.getTasks();<br/><br/>    <strong>this.filteredTasks = combineLatest(this.tasks, this.activeTaskFilterType)</strong><br/><strong>      .pipe(</strong><br/><strong>        map(([tasks, activeTaskFilterType]) =&gt; {</strong><br/><strong>          return tasks.filter((task: Task) =&gt; {</strong><br/><strong>            if (activeTaskFilterType === 'all') {</strong><br/><strong>              return true;</strong><br/><strong>            } else if (activeTaskFilterType === 'open') {</strong><br/><strong>              return !task.done;</strong><br/><strong>            } else {</strong><br/><strong>              return task.done;</strong><br/><strong>            }</strong><br/><strong>          });</strong><br/><strong>        })</strong><br/><strong>      );</strong><br/>  }<br/><br/>  activateFilterType(type: TaskListFilterType) {<br/>    <strong>this.activeTaskFilterType.next(type);</strong><br/>  }<br/><br/>  addTask(title: string) {<br/>    const task: Task = {<br/>      title, done: false<br/>    };<br/>    this.taskService.addTask(task);<br/>    <strong>// Two lines got removed from there</strong><br/>  }<br/><br/>  updateTask(task: Task) {<br/>    this.taskService.updateTask(task);<br/><strong>    // Two lines got removed from there</strong><br/>  }<br/>}</pre>
<p>We have changed the type of our <kbd>tasks</kbd> member, which is now holding an observable with a task array generic type. In TypeScript, RxJS makes use of generics to specify what type of items will be emitted through the observable stream. The <kbd>tasks</kbd> member will store the observable stream which we obtain by calling our task service. It will make the basis for our filtering inside of the component. </p>
<p>In the constructor of our task list component, we're still calling the <kbd>getTasks</kbd> method of our service. However, this time, we won't receive a list of tasks synchronously. Instead, we're an observable stream which will emit a list of tasks when we subscribe. <span>Since we're using a behaviour subject inside of the task service, we will never need to call the task service again to obtain tasks. If there are updates to the task list data, we will receive a new item through the connected observable stream containing the most recent task list.</span></p>
<p>We have also changed our <kbd>activeTaskFilterType</kbd> member to a behavior subject. That will help us in building a consistent reactive data flow within our component. Instead of storing the active filter type directly, we're using a subject to emit the filter type. Within the <kbd>activateFilterType</kbd> method, we do precisely this. When this method is called from our view, as a filter toggle button is clicked, we will emit the new active filter type using the behavior subject.</p>
<p>Our <kbd>tasks</kbd> observable will always emit the latest list when the underlying data is changed. Also, the <kbd>activeTaskFilterType</kbd> subject is emitting an item when we change the active task filter. Now, we can combine both streams to implement our filter logic reactively. Again, think of a pipeline system. Instead of filtering immediately, we are building a network of pipes which will filter whenever new data arrives. So, how can we combine two observable streams into one? There are many ways to do this using the broad variety of operators RxJS provides. However, in our current situation, the <kbd>combineLatest</kbd> operator will work best.</p>
<p>Let's look at a small illustration of how this operator combines multiple observable streams into one single observable stream:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/66f0af12-df90-4861-bc4d-68c8203391a4.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Combining two observables into one by using the combineLatest operator</div>
<p>The <kbd>combineLatest</kbd> operator is combining two or more input observables into a single output observable. The first item will be emitted on the output observable when all input observables have emitted at least one item. The emitted item on the output observable is always an array which contains the most recent, or latest items of all input observables. In the preceding example, you can see that the first item is emitted when <strong>Observable 2</strong> emits its item labelled with <strong>(a)</strong>. The emitted item is an array containing both values <strong>(1)</strong> from <strong>Observable 1</strong> and <strong>(a)</strong> from <strong>Observable 2</strong>. After the first combined item was emitted, if one of the input streams is emitting a new item, the output observable by <kbd>combineLatest</kbd> will emit an updated item which again contains the latest items of all input observables.</p>
<p>This is exactly the behaviour we're looking for when we're building our filter observable. Just switch <strong>Observable 1</strong> from the preceding example with our tasks observable and <strong>Observable 2</strong> with our active filter type. Now, if we either input an observable, the tasks observable, the active filter subject, or emit a new item, our filtered output observable will also produce a new item. This is reactive programming at its best. We never need to be concerned about updating our state <span>anymore</span>. It's all taken care of using reactive streams.</p>
<p>Since <kbd>combineLatest</kbd> will just produce an array of all the latest values emitted by the input observables, we need to use an additional map operator to provide the desired filtered list output. We're destructuring the value pair emitted by <kbd>combineLatest</kbd> into a <kbd>tasks</kbd> and <kbd>activeTaskFilterType</kbd> variable and performing the filtering based on that data. The resulting filtered list is returned and will be emitted by the output observable of the map operator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Subscribing in the view using the async pipe</h1>
                </header>
            
            <article>
                
<p>We have learned about RxJS observables and that they will not start to emit items if we don't subscribe to them. You can compare this to the analogy of the drain valve of a water pipe. If you don't open the drain, the water will not flow.</p>
<p>Within our updated task list component, we now have a <kbd>filteredTasks</kbd> observable to which we can subscribe to and obtain the latest filtered tasks. However, there's a slightly better way to handle RxJS subscriptions, which we're going to take a look at now.</p>
<p>The problem with subscriptions is that they always want to be cleaned up too. Imagine your subscription is causing many event handlers to be added and other resources which might get allocated for observing your stream. Calling the <kbd>subscribe</kbd> method will return a subscription object, and on that subscription object, you will find a method called <kbd>unsubscribe</kbd>. Usually, it's always a good idea to call this method when you don't need the observable subscription anymore. In the case of Angular components, we can say that when a component gets removed from the view, it's a good time to clean up the observable subscriptions.</p>
<p>Luckily, there's a life cycle hook called <kbd>OnDestroy</kbd> for detecting when a component is removed from the view. We can use this hook to clean up any subscriptions to RxJS observables. Let's take a look at a straightforward example of a component subscribing to an observable and unsubscribing within the <kbd>OnDestroy</kbd> life cycle hook:</p>
<pre>import {OnDestroy} from '@angular/core';<br/>import {Observable, Subscription, fromEvent} from 'rxjs';<br/><br/>...<br/>export class MousePositionComponent implements OnDestroy {<br/>  mouseObservable: Observable&lt;MouseEvent&gt; = fromEvent(window, 'mousemove')<br/>    .map(e =&gt; `${e.screenX}, ${e.screenY}`);<br/>  mousePosition: string;<br/>  mouseSubscription: Subscription = this.mouseObservable<br/>    .subscribe((position: string) =&gt; this.mousePosition = position);<br/><br/>  ngOnDestroy() {<br/>    this.mouseSubscription.unsubscribe();<br/>  }<br/>}</pre>
<p>In the preceding example, we're creating an observable stream from the mouse move events on the window object. All we'd like to do is display the most recent mouse position, which was emitted by the observable stream, within our component view. You can immediately see that this is quite a bit of code just for dealing with one observable. We need to store three things for each observable:</p>
<ul>
<li>The observable itself</li>
<li>A property to store the most recent emitted item by the stream</li>
<li>The subscription object which allows us to unsubscribe and clean up when our component gets destroyed</li>
</ul>
<p>This might be okay if we're only dealing with one single observable, however, imagine if your component needs to deal with several observables at the same time. This is going to be quite a mess.</p>
<p>Another problematic thing is that we need to manually unsubscribe when our component gets destroyed using the <kbd>OnDestroy</kbd> life cycle hook. This is a manual, error-prone process and we can lose track over our subscriptions quite easily.</p>
<p>Luckily, Angular comes with a genius solution for this problem. Instead of dealing with the subscription manually, we will use a view pipe with the name <kbd>AsyncPipe</kbd> to subscribe directly within the view of our component. This means that we don't need to subscribe in our component class and extract the latest emitted item manually. Instead, the async pipe will extract the item for us and update our view automatically whenever there's a new item coming through the stream. The async pipe will also store the subscription internally and automatically unsubscribe for us if it detects that the component has been destroyed.</p>
<p>Let's look at the same example from before, but now using the async pipe. The component class would look like this:</p>
<pre>import {Observable, fromEvent} from 'rxjs';<br/><br/>...<br/>export class MousePositionComponent implements OnDestroy {<br/>  mouseObservable: Observable&lt;MouseEvent&gt; = fromEvent(window, 'mousemove')<br/>    .map(e =&gt; `${e.screenX}, ${e.screenY}`);<br/>}</pre>
<p>Wow! That's a radical simplification, isn't it? All we need to store now is the observable itself. Extracting the latest emitted item as well as unsubscribing from the stream is all handled by the async pipe. Let's take a look at how we would need to change our view to use the async pipe:</p>
<pre>&lt;strong&gt;Mouse position:&lt;/strong&gt;<br/>&lt;p&gt;{{<strong>mouseObservable | async</strong>}}&lt;/p&gt;</pre>
<p>How cool is that! By only using the async pipe in our view, we can create a subscription to the observable, render the latest item emitted by the stream, and unsubscribe when our component gets destroyed. Additionally, from a functional and reactive standpoint, we also enhanced our code in a way that we don't create any side effects within our component class. We don't hold any intermediate state, and all we store is the observable stream itself. The async pipe is an excellent addition to your toolset when dealing with asynchronous data, and you should always make use of it when working with RxJS observables.</p>
<p>Okay, I hope you felt the power and simplicity of using the async pipe within the previous example. Now, we'll use that knowledge and refactor our task list component to use the async pipe to subscribe to our observables within the component view.</p>
<p><span>Since we've already updated our component logic to expose an observable to emit our filtered task list, we can go directly to the view of our task list component and apply the changes to use the async pipe.</span> Let's open the <kbd>src/app/tasks/task-list/task-list.component.html</kbd> file and implement the following changes:</p>
<pre>&lt;mac-toggle [buttonList]="taskFilterTypes"<br/>            [activeButton]="activeTaskFilterType<strong> | async</strong>"<br/>            (outActivate)="activateFilterType($event)"&gt;<br/>&lt;/mac-toggle&gt;<br/>&lt;mac-enter-task (outEnterTask)="addTask($event)"&gt;&lt;/mac-enter-task&gt;<br/>&lt;div class="tasks"&gt;<br/>  &lt;mac-task *ngFor="let task of filteredTasks<strong> | async</strong>"<br/>            [task]="task"<br/>            (outUpdateTask)="updateTask($event)"&gt;&lt;/mac-task&gt;<br/>&lt;/div&gt;</pre>
<p>We've added two async pipes. The first one is to subscribe to our <kbd>activeTaskFilterType</kbd> behaviour subject. The async pipe will create a subscription directly from the view, and it will update our binding automatically whenever there's a new item emitted through the stream.</p>
<p>The second async pipe is used directly in the binding of the <kbd>NgFor</kbd> directive. We're subscribing to our <kbd>filteredTasks</kbd> observable, which will always emit the latest result of our filtered task list.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recap</h1>
                </header>
            
            <article>
                
<p>Congratulations! We've successfully updated our code to establish a reactive data flow within our application using the in-memory web API and the Angular HTTP client. We are using RxJS observables, transforming them using operators, and resolving our data directly within the view using the Angular async pipe. This refactoring was quite a technical but significant change. We're now following a very clean approach on how to react to application state changes. Our observable streams are router down directly into the view where we then subscribe using the async pipe. If Angular destroys our task list component, the async pipe will also take care of the necessary unsubscriptions. We've learned about the following topics:</p>
<ul>
<li>The Angular in-memory API to simulate a RESTful backend and using HTTP client to obtain data</li>
<li>RxJS basics, basic operators, as well as behaviour subject and the <kbd>combineLatest</kbd> operator</li>
<li>Using the async pipe to subscribe from the view of our components</li>
<li>Establishing an end-to-end reactive data architecture within our application</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Immutability</h1>
                </header>
            
            <article>
                
<p>Within this section, we're going to learn about the concept of immutability. This knowledge will help us for the upcoming refactoring exercises of our application.</p>
<p>Immutable data has initially been a core concept of functional programming. This section will not cover immutable data in much depth, but it will explain the core concept so that we can talk about how to apply this idea to Angular components.</p>
<p>Immutable data structures force you to create a full copy of the data before you modify it. You'll never operate on the data directly, but on a copy of this same data. This approach has many benefits over mutable data operations, the most obvious probably being clean application state management. When you always operate on new copies of data, there's no chance that you're messing up data that you didn't want to modify.</p>
<p>Let's take this simple example, which illustrates the issues object references can cause:</p>
<pre>const list = [1, 2, 3]; 
console.log(list === list.reverse()); // true </pre>
<p>Although this seems odd at first, it makes sense that the output of this case is valid. <kbd>Array.reverse()</kbd> is a mutable operation, and it will modify the innards of the array. The actual reference will stay the same because JavaScript will not create a copy of the array to reverse it. Although technically this makes a lot of sense, this is not what we expected in the first place when we looked at this code.</p>
<p>We can quickly change this example to an immutable procedure by creating a copy of the array before we reverse it:</p>
<pre>const list = [1, 2, 3]; 
console.log(list === list.slice().reverse()); // false </pre>
<p>The issue with references is that they can cause a lot of unexpected side effects. Also, if we come back to our encapsulation topic from <a href="237031a7-f616-4811-8486-08b5113d316f.xhtml"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Component-Based User Interfaces</em>, object references are entirely against the concept of encapsulation. Although we might think that it would be safe to pass complex data types into a capsule, it's not. As we're dealing with references here, the data can still be modified from the outside, and our capsule will not have complete ownership. Consider the following example:</p>
<pre>class Sum { 
  constructor(data) { 
    this.data = data; 
    this.data.sum = data.a + data.b; 
  } 
  getSum() { 
    return this.data.sum; 
  } 
} 
 
const data = {a: 5, b: 8}; 
var sum = new Sum(data); 
console.log(sum.getSum()); // 13 
console.log(data.sum); // 13 </pre>
<p>Even if we only wanted to store the data internally in our <kbd>Sum</kbd> class, we would have created the unwanted side effect of referencing and modifying the data object which is outside the instance. Multiple <kbd>sum</kbd> instances would also share the same data from outside and cause more side effects. As a developer, you've learned to treat object references correct, but they still can cause a lot of problems.</p>
<p>We don't have these problems with immutable data, which can be illustrated easily with primitive data types in JavaScript. Primitive data types don't use references, and they are immutable by design:</p>
<pre>let originalString = 'Hello there!'; 
let modifiedString = originalString.replace(/e/g, 3); 
console.log(originalString); // Hello there! 
console.log(modifiedString); // H3llo th3r3! </pre>
<p>There's no way we can modify an instance of a string. Every modification that we perform on a string will generate a new string, and this prevents the unwanted side effects.</p>
<p>So, why do we still have object references within programming languages, even though they cause so many issues? Why aren't we performing all these operations on immutable data, and why aren't we only dealing with values rather than object references?</p>
<p>Of course, mutable data structures also come with their benefits, and it always depends on the context if immutable data brings value.</p>
<p>One of the main reasons that is often used against immutable data is its lousy performance. Of course, it costs some performance if we need to create tons of copies of our data every time we want to modify it. However, there are significant optimization techniques which eliminate the performance issues that we would usually expect from immutable data structures. Using a tree data structure that allows internal structural sharing, copies of the data will be shared internally. This technique allows for very efficient memory management, which in some situations even outperforms mutable data structures. I can highly recommend the paper by Chris Okasaki about <em>Purely Functional Data Structures</em> if you would like to read more about performance in immutable data structures.</p>
<div class="packt_tip"><span>JavaScript does not support immutable data structures out of the box. However, you can use libraries, such as </span><kbd>Immutable.js</kbd><span> by Facebook, which provide you with an excellent API to deal with immutable data. </span><kbd>Immutable.js</kbd><span> even implements structural sharing and makes it a perfect power tool if you decide to build on an immutable architecture in your application.</span></div>
<p>As with every paradigm, there are pros and cons, and depending on the context, one concept may fit better than another one. In our application, we won't use immutable data structures that are provided by third-party libraries, but we'll borrow some of the benefits that you get from immutable data by going by the following immutable idioms:</p>
<ul>
<li><strong>It's much easier to reason about immutable data</strong>: You can always tell why your data is in a given state because you know the exact transformation path. This may sound irrelevant, but in practice, this is a huge benefit not only for humans to write code but also for compilers and interpreters to optimize it.</li>
<li><strong>Using immutable objects makes change detection much faster</strong>: If we rely on immutable patterns to treat our data, we can rely on object reference checks to detect change. We no longer need to perform complex data analysis and comparison for dirty checking, and can fully rely on checking references. We have the guarantee that object properties don't change without the object identity changing as well. This makes change detection as easy as <kbd>oldObject === newObject</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Immutability with TypeScript</h1>
                </header>
            
            <article>
                
<p>With TypeScript 2, new type features were added which help you to embrace immutable operations. Using the <kbd>readonly</kbd> type modifier, we can achieve a compile-time immutability guard.</p>
<p>Let's look at the following example of how to use the <kbd>readonly</kbd> modifier to define some immutable data structures:</p>
<pre>export interface Person {<br/>  readonly firstName: string;<br/>  readonly lastName: string;<br/>}<br/><br/>let person: Person = {<br/>  firstName: 'Peter',<br/>  lastName: 'Griffin'<br/>};<br/><br/>// This will result in a compile time error<br/>person.firstName = 'Mag';</pre>
<p>As you can see from the preceding example, we can use the <kbd>readonly</kbd> modifier to prevent object properties from being modified. Instead, if we'd like to modify the <kbd>person</kbd> object, we'll need to create a copy of that object. There are many ways to do this, however, using the object property spread operator is probably the most convenient of all. Let's see how we can update our person object in an immutable way using the object property spread operator:</p>
<pre>export interface Person {<br/>    readonly firstName: string;<br/>    readonly lastName: string;<br/>}<br/><br/>let person: Person = {<br/>    firstName: 'Peter',<br/>    lastName: 'Griffin'<br/>};<br/><br/>person = {<br/>  ...person,<br/>  firstName: 'Mag'<br/>};</pre>
<p>Using the object property spread operator, we can spread all existing properties and their values of the existing person object into a new object literal. In the same step, we can then override any properties, right after the spread operation. This allows us to easily create a copy of an existing object and add or override specific properties. The preceding code could also be written by using <kbd>Object.assign</kbd>:</p>
<pre>person = Object.assign({}, person, {<br/>  firstName: 'Meg'<br/>});</pre>
<p>Actually, this is how the object spread operator is desugaring to JavaScript. However, it's much more convenient to use the spread operator than <kbd>Object.assign</kbd>. The object spread operator is proposed to the future JavaScript standard and is currently at stage 3.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pure components</h1>
                </header>
            
            <article>
                
<p>The idea of a "pure" component is that its whole state is represented by its inputs, where all inputs are immutable. This is effectively a stateless component, but additionally, all the inputs are immutable.</p>
<p>I like to call such components "pure" because their behaviour can be compared to the concept of pure functions in functional programming. A pure function is a function which has the following properties:</p>
<ul>
<li>It does not rely on any state outside of the function scope</li>
<li>It always behaves the same <span>and returns the same result</span> if input parameters don't change </li>
<li>It never changes any state outside the function scope (side effect)</li>
</ul>
<p>With pure components, we have a simple guarantee. A pure component will never change without its input parameters being changed. <span>Sticking to this idea about components gives us several advantages. Besides having a complete trust in your component state, we can also gain some performance benefits by optimizing the change detection of Angular. We know that a component will render exactly the same if its inputs don't change. This means that w</span>e can ignore all components and their subcomponents in change detection if there are no input changes. </p>
<p>It's very easy to reason about pure components. Their behaviour can be predicted very easily. Let's look at a simple illustration of a component tree with only pure components:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4ecbe63d-591d-4b00-9fff-f10b11700f8a.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">A component tree with immutable components</div>
<p>Usually, Angular performs change detection for every single binding in all of your components within the component tree. It does that on every browser event, which could change your system state. This eventually comes with a large performance overhead.</p>
<p>If we have the guarantee that each component in our tree has a stable state until an immutable input property changes, we can safely ignore change detection that would usually be triggered by Angular. The only way that such a component could change is if an input of the component changes. Let's say that there's an event that causes the root component (<strong>A</strong>) to change the input binding value of component (<strong>B</strong>), which will change the value of a binding on component (<strong>E</strong>). This event and the resulting procedure would mark a certain path in our component tree to be checked by change detection:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/53dd7069-784c-4b89-8b69-541b23283468.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">A marked path for change detection (in black) with "pure" components</div>
<p>Although the state of the root component changed, which also changed input properties of the subcomponents on two levels, we only need to be concerned about a given path when thinking about possible changes in the system. Pure components give us the promise that they will not change if their inputs don't change. Immutability plays a big role here. Imagine that you're binding a mutable object to component (<strong>B</strong>), and component (<strong>A</strong>) would change a property of this object. As we use object references and mutable objects, the property would also be changed for component (<strong>B</strong>). However, there's no way for component (<strong>B</strong>) to notice this change and it would leave our component tree in an unstable state. Basically, we'd need to go back to the regular dirty checking of the whole tree again.</p>
<p>By knowing that all our components are pure and that their inputs are immutable, we can tell Angular to disable change detection until an input property value changes. This makes our component tree very efficient, and Angular can optimize change detection effectively. When thinking about large component trees, this can make the difference between a stunningly fast application and a slow one.</p>
<p>The change detection of Angular is very flexible, and each component gets its own change detector. We can configure the change detection of a component by specifying the <kbd>changeDetection</kbd> property of the component decorator.</p>
<p>Using <kbd>ChangeDetectionStrategy</kbd>, we can choose from two strategies that apply for the change detection of our component. In order to tell Angular that our component should only be checked if an immutable input was changed, we can use the <kbd>OnPush</kbd> strategy. This change detection mode is specifically designed for the purpose of pure components.</p>
<p>Let's take a look at the two different configuration possibilities of component change-detection strategies and some possible use cases:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<thead>
<tr>
<td>
<p><strong>Change-detection strategy</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p><kbd>OnPush</kbd></p>
</td>
<td>
<p>This strategy tells Angular that a given component subtree will only change under one of the following conditions:</p>
<ul>
<li>One of the input properties changes where changes need to be immutable. Inputs are always checked for reference changes (using the triple-equals operator <kbd>===</kbd>)</li>
<li>An event binding within the component subtree is receiving an event. This condition tells Angular that there might be a change inside of the component itself and it will trigger change detection, even if none of the inputs have changed.</li>
</ul>
</td>
</tr>
<tr>
<td>
<p>Default</p>
</td>
<td>
<p>The default strategy of Angular's change detection will perform change detection for every single browser event which occurs within your application.</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing container components</h1>
                </header>
            
            <article>
                
<p><span>The main topic of this book is to learn how to create scalable user interfaces using Angular components. You can probably already see a trend within this chapter. From a simple task list component holding its own state, we're slowly moving into a more serious and maintainable application architecture. We've already been going through some major refactorings which can be summarized as follows:</span></p>
<ul>
<li>Creating a simple task list component to list some tasks coming from a simple list of plain objects</li>
<li>Splitting the task list component into various subcomponents and finding the right size for our components (task list, task, checkbox, toggle)</li>
<li>Introducing a service in order to store our task data and remove any data which was directly embedded into our components</li>
<li>Using the Angular HTTP client and the in-memory web API to simulate asynchronous data fetching and using RxJS observables in our service and components</li>
</ul>
<p>Within this section, we're going to learn about another concept which will enhance our maintainability even further. The concept of container components helps us to separate our user interface from our application state. This might sound difficult at the beginning but it's actually a concept which blends really nicely into our existing approach. With the introduction of container components, we're setting clear responsibilities when it comes to state management. Let's look at the following illustration to see the concept in action:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/76242032-1ff5-46bb-9c26-f662dd4781e6.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Container component and interactions with regular UI components</div>
<p>Container components are in charge of your application state. They are the only components of your system which are allowed to manipulate state and data. They are passing this state and data down into your user interface component through component input. Within the preceding illustration, we have a container component surrounding <strong>Component A</strong>. <strong>Component A</strong> is again consisting of a subcomponent, <strong>B</strong>. Data is flowing down from our container component into component <strong>A</strong> and <strong>B</strong>. Whenever the container provides new data, that data is seeping down into your user interface components through their inputs.</p>
<p>Now, here comes the tricky part of this concept. User interface components, like component <strong>A</strong> and <strong>B </strong>within our illustration, are never, ever manipulating data directly. They will always delegate to their parent component. I often explain this concept as a kind of <strong>inversion of control</strong> (<strong>IoC</strong>). Instead of performing the action which was triggered by a user controlling the user interface directly, we just delegate to the parent component and tell it to perform this action. If the parent component is a simple UI component too, we delegate again. This goes on until we reach a container component. The container component then has the ability to effectively perform the desired operation on the application state. Once performed, the updated data will then seep back down the component tree. This approach of building user interfaces comes with an amazing list of positive effects on your application <span>architecture:</span></p>
<ul>
<li><strong>All your data manipulation is handled in a central location</strong>:<br/>
This is really beneficial since we can always go to one single place if we need to change the way we manipulate our state and data.</li>
<li><strong>All user interface components can be "pure"</strong>:<br/>
Since we won't have any user interface components which manipulate data directly, and they are only dependent on the data which is flowing down the component tree into their inputs, we can build "pure" components in most cases. This gives all the benefits of "pure" components, including the performance boost.</li>
<li><strong>Container components act as adapter layers</strong>:<br/>
Since the container components are the only components which interact with your data services, database, state machine, or whatever else you're using to manage your state and data, we can see them as adapters of your application user interface to your data layer. When you decide to go differently about your state management and data sources, the only place where you need to apply changes is your container components.</li>
<li><strong>Separation of state and user interface</strong>:<br/>
The separation of your application's state from your user interface is underestimated by far. By building a simple UI component which just accepts data through its inputs, we can build highly flexible and reusable components. If we would like to include them in a completely different context of state and data, we simply create another container component.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Purifying our task list</h1>
                </header>
            
            <article>
                
<p>In the previous three sections, we looked into the basics of using immutable data structures and that Angular can be configured to assume that components only change when their input changes. We learned about the concept of "pure" components and how we can configure Angular's change detection to gain some performance benefits. We also learned about the concept of container components to separate our UI components from our application state.</p>
<p>Within this section, we would like to refactor our application to include our newly learned skills about immutability, "pure" components, and container components.</p>
<p>Let's start with our existing task list component. Currently, this component is directly interacting with data coming from the task service. However, we have learned that "pure" UI components should never directly retrieve or manipulate the state or data of our application. Instead, they should only depend on their inputs to retrieve data.</p>
<p>Open up the <kbd>src/app/tasks/task-list/task-list.component.ts</kbd> file and apply the following changes. The code changes are highlighted in bold:</p>
<pre>import {Component, <strong>ChangeDetectionStrategy,</strong> <strong>EventEmitter, Input, Output,</strong> ViewEncapsulation} from '@angular/core';<br/>import {Task, TaskListFilterType} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-task-list',<br/>  templateUrl: './task-list.component.html',<br/>  encapsulation: ViewEncapsulation.None<strong>,</strong><br/><strong>  changeDetection: ChangeDetectionStrategy.OnPush</strong><br/>})<br/>export class TaskListComponent {<br/> <strong> @Input() taskFilterTypes: TaskListFilterType[];</strong><br/><strong>  @Input() activeTaskFilterType: TaskListFilterType;</strong><br/><strong>  @Input() tasks: Task[];</strong><br/><strong>  @Output() outAddTask = new EventEmitter&lt;string&gt;();</strong><br/><strong>  @Output() outActivateFilterType = new EventEmitter&lt;TaskListFilterType&gt;();</strong><br/><strong>  @Output() outUpdateTask = new EventEmitter&lt;Task&gt;();</strong><br/><br/>  addTask(title: string) {<br/>    <strong>this.outAddTask.emit(title);</strong><br/>  }<br/><br/>  activateFilterType(filterType: TaskListFilterType) {<br/>    <strong>this.outActivateFilterType.emit(filterType);</strong><br/>  }<br/><br/>  updateTask(task: Task) {<br/>    <strong>this.outUpdateTask.emit(task);</strong><br/>  }<br/>}</pre>
<p>You can immediately see that our component is now much simpler. Instead of it containing all the filter logic, we're just relying on the tasks passed to the component using the <kbd>tasks</kbd> input. Our task list component is now assuming that the tasks coming into the component input are already filtered and that it's no longer in control of the filtering itself. It still renders the filters, however, as you can see from the <kbd>activateFilterType</kbd> method, we're now using output properties to delegate the filter action to the parent component. We've also added outputs for adding a task as well as for updating a task. We've learned from the previous section about container components that our UI components use inversion of control. That's exactly what is happening here. We're no longer manipulating our state, but instead delegating the manipulation to our parent component using output properties. The <kbd>addTask</kbd> method, as well as the <kbd>updateTask</kbd> method, are both just emitting output, nothing else.</p>
<p>The same principle which we used for the tasks is also applied to the filter type list and the active filter type. We're using the input properties <kbd>taskFilterTypes</kbd> and <kbd>activeTaskFilterType</kbd> so that we can pass this information down from the parent component. The task list is no longer in charge of controlling the state of the active filter type and we can control this state from the parent container component.</p>
<p>Since we're now assuming that tasks passed into the component using the task's input property are already filtered, we need to apply a small change to our component template, too. Also, we no longer need the async pipe in our task list component, since our component will receive the resolved array of filtered tasks directly. We'll let our container component deal with the observables. Let's open the <span><kbd>src/app/tasks/task-list/task-list.component.html</kbd> file and apply some changes. Changed code is highlighted in bold and the ellipsis symbol is indicating more hidden but irrelevant code:</span></p>
<pre>...<br/>&lt;div class="tasks"&gt;<br/>  &lt;mac-task *ngFor="let task of <strong>tasks</strong>"<br/>            [task]="task"<br/>            (outUpdateTask)="updateTask($event)"&gt;&lt;/mac-task&gt;<br/>&lt;/div&gt;</pre>
<p>That's already it in our task list component. We're now only relying on input properties for obtaining the data required to render our component. This makes our component so much simpler, doesn't it?</p>
<p>Let's continue with the container component for our task list. We're creating a new component using the Angular CLI. This time, we're creating the component into a separate subfolder called <kbd>container</kbd>. As our application grows, and we have more container components that need to be created, we will put them all into this folder.</p>
<p>Also, note that we're now starting to use the <kbd>-cd onpush</kbd> option for generating components using the Angular CLI. This will add the change detection strategy <kbd>OnPush</kbd> onto our generated component stubs for us:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush container/task-list-container</strong></pre>
<p>The task list container is now responsible for dealing with the data necessary to render a task list component. It will also perform all the state and data manipulation required to cover the behaviour of our task list. Let's open the generated component class file: </p>
<pre>import {ChangeDetectionStrategy, Component, ViewEncapsulation} from '@angular/core';<br/>import {TaskService} from '../../tasks/task.service';<br/>import {Task, TaskListFilterType} from '../../model';<br/>import {Observable, combineLatest, BehaviorSubject} from 'rxjs';<br/>import {map} from 'rxjs/operators';<br/><br/>@Component({<br/>  selector: 'mac-task-list-container',<br/>  templateUrl: './task-list-container.component.html',<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class TaskListContainerComponent {<br/>  tasks: Observable&lt;Task[]&gt;;<br/>  filteredTasks: Observable&lt;Task[]&gt;;<br/>  taskFilterTypes: TaskListFilterType[] = ['all', 'open', 'done'];<br/>  activeTaskFilterType = new BehaviorSubject&lt;TaskListFilterType&gt;('all');<br/><br/>  constructor(private taskService: TaskService) {<br/>    this.tasks = this.taskService.getTasks();<br/><br/>    this.filteredTasks = combineLatest(this.tasks, this.activeTaskFilterType)<br/>      .pipe(<br/>        map(([tasks, activeTaskFilterType]) =&gt; {<br/>          return tasks.filter((task: Task) =&gt; {<br/>            if (activeTaskFilterType === 'all') {<br/>              return true;<br/>            } else if (activeTaskFilterType === 'open') {<br/>              return !task.done;<br/>            } else {<br/>              return task.done;<br/>            }<br/>          });<br/>        })<br/>      );<br/>  }<br/><br/>  activateFilterType(type: TaskListFilterType) {<br/>    this.activeTaskFilterType.next(type);<br/>  }<br/><br/>  addTask(title: string) {<br/>    const task: Task = {<br/>      title, done: false<br/>    };<br/>    this.taskService.addTask(task);<br/>  }<br/><br/>  updateTask(task: Task) {<br/>    this.taskService.updateTask(task);<br/>  }<br/>}</pre>
<p>When looking at the code of our new task list container component, you should notice something. The code is an exact copy of the code we had in our task list component before we turned it into a "pure" UI component. Well, does this look right? If you look at the code again, now that we have learned about separating the user interface concerns from our application state, you will notice that none of this code is actually the responsibility of a UI task list component. It's code that is mainly concerned with data manipulation and retrieval. It should actually never have been part of our task list UI component. This code clearly belongs to a container component.</p>
<p>The next step is to create the view template of our container component. A container component should actually never contain much code in the template. Ideally, the only thing you want to do within the view of a container component is to render the UI component which you're concerned with in that specific container. Let's open the <kbd>src/app/container/task-list-container/task-list-container.component.html</kbd> file and change its content to the following:</p>
<pre>&lt;mac-task-list<br/>  [tasks]="filteredTasks | async"<br/>  [taskFilterTypes]="taskFilterTypes"<br/>  [activeTaskFilterType]="activeTaskFilterType | async"<br/>  (outUpdateTask)="updateTask($event)"<br/>  (outActivateFilterType)="activateFilterType($event)"<br/>  (outAddTask)="addTask($event)"&gt;<br/>&lt;/mac-task-list&gt;</pre>
<p>As you will have noticed, the only things we're concerned about in the view of our task list container component is to render a task list UI component. We're passing the list of filtered tasks into the task list component. Since we're using an observable within our container component, we use the async pipe again to subscribe and resolve to the most recently filtered task list. Similarly, we're passing the list of filter types and the currently active filter, which we both now store in our container, down into the task list component.</p>
<p>On the other hand, we're binding the outputs of the task list UI component and calling the necessary method within the container when we get notified about updated tasks, filter changes, and newly added tasks. The task list UI component just tells us <strong>what</strong> to do, and inside of the container component, that we know <strong>how</strong> to do it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have learned how to deal with data and application state in a way which is best for the maintainability of our application. We have switched our task service from synchronous operations on tasks stored within the service directly to using the Angular in-memory web API and the HTTP client.</p>
<p>We learned about how we can profit from concepts, such as reactive programming, observable data structures, and immutable objects, in order to make our application perform better, and most importantly, simple and easy to reason about.</p>
<p>We have also learned about the separation of user interface from application state and implemented the concept of container components into our application.</p>
<p>In the next chapter, we're going to organize our application on a larger scale. By introducing a new project layer, we can start organizing tasks within projects. We will create the necessary state and UI components in order to view and edit tasks within projects.</p>


            </article>

            
        </section>
    </body></html>