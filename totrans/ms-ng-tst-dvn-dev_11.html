<html><head></head><body>
		<div id="_idContainer194">
			<h1 id="_idParaDest-148" class="chapter-number"><a id="_idTextAnchor413"/><st c="0">11</st></h1>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor414"/><st c="3">Refactoring and Improving Angular Code through TDD</st></h1>
			<p><st c="54">Refactoring your Angular code </st><a id="_idIndexMarker441"/><st c="85">using </st><strong class="bold"><st c="91">test-driven development</st></strong><st c="114"> (</st><strong class="bold"><st c="116">TDD</st></strong><st c="119">) is a systematic and effective approach to improving the quality of your code. </st><st c="200">TDD involves writing tests before writing the actual code, thus ensuring that the code addresses the desired requirements and is robust, maintainable, and reliable. </st><st c="365">This methodology is particularly beneficial for Angular applications, where it ensures that the code is well structured, efficient, and easy </st><span class="No-Break"><st c="506">to maintain.</st></span></p>
			<p><st c="518">In this section, we delve into the significance of adopting a “tests first” strategy, exploring the advantages of TDD during refactoring processes, selecting the optimal tests to create, understanding what</st><a id="_idIndexMarker442"/><st c="724"> constitutes </st><strong class="bold"><st c="737">code smells</st></strong><st c="748">, emphasizing the importance of addressing code smells within Angular projects, and identifying prevalent code smells in </st><span class="No-Break"><st c="869">Angular applications.</st></span></p>
			<p><st c="890">In summary, here are the main topics that will be covered in </st><span class="No-Break"><st c="952">this chapter:</st></span></p>
			<ul>
				<li><st c="965">Refactoring Angular code </st><span class="No-Break"><st c="991">through TDD</st></span></li>
				<li><st c="1002">Identifying code smells and areas for improvement in </st><span class="No-Break"><st c="1056">Angular applications</st></span></li>
				<li><st c="1076">Iterative improvement – red-green-refactor cycle for continuous </st><span class="No-Break"><st c="1141">code enhancement</st></span></li>
			</ul>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor415"/><st c="1157">Technical requirements</st></h1>
			<p><st c="1180">To follow along with the examples and exercises in this chapter, you will need to have a basic understanding of Angular and TypeScript, as well as the following </st><span class="No-Break"><st c="1342">technical requirements:</st></span></p>
			<ul>
				<li><st c="1365">Node.js and npm installed on </st><span class="No-Break"><st c="1395">your computer</st></span></li>
				<li><st c="1408">Angular CLI </st><span class="No-Break"><st c="1421">installed globally</st></span></li>
				<li><st c="1439">A code editor, such as Visual Studio Code, installed on </st><span class="No-Break"><st c="1496">your computer</st></span></li>
			</ul>
			<p><st c="1509">The code files required for this chapter can be found </st><span class="No-Break"><st c="1564">at </st></span><a href="https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%2011"><span class="No-Break"><st c="1567">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%2011</st></span></a><span class="No-Break"><st c="1666">.</st></span></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor416"/><st c="1667">Refactoring Angular code with TDD</st></h1>
			<p><st c="1701">Refactoring existing</st><a id="_idIndexMarker443"/><st c="1722"> code in complex Angular applications can be a nerve-wracking task. </st><st c="1790">You want to improve the</st><a id="_idIndexMarker444"/><st c="1813"> code’s structure and organization without accidentally breaking existing functionalities. </st><st c="1904">This is where TDD comes into play, offering a structured approach to navigate refactoring with confidence. </st><st c="2011">In this section, we’ll see the power of the test-first approach, the benefits of TDD in refactoring, and how to choose the right tests </st><span class="No-Break"><st c="2146">to write.</st></span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor417"/><st c="2155">The power of the test-first approach</st></h2>
			<p><st c="2192">TDD flips</st><a id="_idIndexMarker445"/><st c="2202"> the traditional coding script. </st><st c="2234">Instead of writing code first and then testing it, TDD emphasizes writing tests before making any modifications to the code. </st><st c="2359">These tests essentially define the expected behavior of the code you intend to refactor. </st><st c="2448">Here’s how </st><span class="No-Break"><st c="2459">it works:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="2468">The red state</st></strong><st c="2482">: You start by writing a test for a specific functionality within the code you want to refactor. </st><st c="2580">This initial test will likely fail, signifying that the desired behavior isn’t yet implemented. </st><st c="2676">This </st><em class="italic"><st c="2681">red</st></em><st c="2684"> state acts as a </st><span class="No-Break"><st c="2701">starting point.</st></span></li>
				<li><strong class="bold"><st c="2716">The green state</st></strong><st c="2732">: With the failing test as your guide, you write just enough code to make the test pass. </st><st c="2822">This initial implementation might be basic, but the focus is on ensuring it accurately reflects the intended behavior defined by the test. </st><st c="2961">Now, the test is in a </st><em class="italic"><st c="2983">green</st></em><st c="2988"> state, indicating </st><span class="No-Break"><st c="3007">successful implementation.</st></span></li>
				<li><strong class="bold"><st c="3033">Refactor</st></strong><st c="3042">: Here’s where the magic happens. </st><st c="3077">With the safety net of a passing test, you can now refactor the code to improve its readability, maintainability, and efficiency. </st><st c="3207">This might involve </st><span class="No-Break"><st c="3226">the following:</st></span><ul><li><st c="3240">Breaking down long methods into smaller, </st><span class="No-Break"><st c="3282">well-defined functions</st></span></li><li><st c="3304">Extracting reusable components or services from </st><span class="No-Break"><st c="3353">large components</st></span></li><li><st c="3369">Applying design patterns for better </st><span class="No-Break"><st c="3406">code organization</st></span></li><li><st c="3423">Simplifying logic to </st><span class="No-Break"><st c="3445">enhance clarity</st></span></li></ul></li>
			</ul>
			<p><st c="3460">Throughout</st><a id="_idIndexMarker446"/><st c="3471"> this refactoring stage, the passing test ensures that these changes don’t introduce any unintended side effects. </st><st c="3585">Essentially, you’re improving the code’s internal workings without altering its external behavior as verified by the test. </st><st c="3708">As an example, let’s start with this block of code from our </st><strong class="source-inline"><st c="3768">calculator.component.ts</st></strong><st c="3791"> component in the </st><span class="No-Break"><strong class="source-inline"><st c="3809">Chapter 9</st></strong></span> <span class="No-Break"><st c="3818">folder (</st></span><a href="https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%209/getting-started-angular-tdd"><span class="No-Break"><st c="3827">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%209/getting-started-angular-</st><span id="_idTextAnchor418"/><st c="3951">tdd</st></span></a><span class="No-Break"><st c="3955">):</st></span></p>
			<pre class="source-code"><st c="3958">
calculate(): void {
    if (this.calculatorForm.get('operator')?.value === '+') {
      this.add(
        this.calculatorForm.get('operand1')?.value,
        this.calculatorForm.get('operand2')?.value
      );
    }
    if (this.calculatorForm.get('operator')?.value === '-') {
      this.substract(
        this.calculatorForm.get('operand1')?.value,
        this.calculatorForm.get('operand2')?.value
      );
    }
    if (this.calculatorForm.get('operator')?.value === '*') {
      this.multiply(
        this.calculatorForm.get('operand1')?.value,
        this.calculatorForm.get('operand2')?.value
      );
    }
    if (this.calculatorForm.get('operator')?.value === '/') {
      this.divide(
        this.calculatorForm.get('operand1')?.value,
        this.calculatorForm.get('operand2')?.value
      );
    }
  }</st></pre>			<p><st c="4634">Here is the </st><a id="_idIndexMarker447"/><st c="4647">source code for the tests corresponding to this function in our </st><span class="No-Break"><strong class="source-inline"><st c="4711">calculator.component.spec.ts</st></strong></span><span class="No-Break"><st c="4739"> file:</st></span></p>
			<pre class="source-code"><st c="4745">
  it('should be valid when all of the fields are filled in correctly', () =&gt; {
    calculator.calculatorForm.get('operand1')?.setValue(123);
    calculator.calculatorForm.get('operand2')?.setValue(456);
    calculator.calculatorForm.get('operator')?.setValue('+');
    expect(calculator.calculatorForm.valid).toBe(true);
  });
  it('should be invalid when one of the field is not filled in correctly', () =&gt; {
    calculator.calculatorForm.get('operand1')?.setValue(123);
    calculator.calculatorForm.get('operator')?.setValue('+');
    expect(calculator.calculatorForm.valid).toBe(false);
  });
  it('should add when the + operator is selected and the calculate button is clicked', () =&gt; {
    calculator.calculatorForm.get('operand1')?.setValue(2);
    calculator.calculatorForm.get('operand2')?.setValue(3);
    calculator.calculatorForm.get('operator')?.setValue('+');
    calculator.calculate();
    expect(calculator.result).toBe(5);
  });
  it('should subtract when the - operator is selected and the calculate button is clicked', () =&gt; {
    calculator.calculatorForm.get('operand1')?.setValue(2);
    calculator.calculatorForm.get('operand2')?.setValue(3);
    calculator.calculatorForm.get('operator')?.setValue('-');
    calculator.calculate();
    expect(calculator.result).toBe(-1);
  });
  it('should multiply when the * operator is selected and the calculate button is clicked', () =&gt; {
    calculator.calculatorForm.get('operand1')?.setValue(2);
    calculator.calculatorForm.get('operand2')?.setValue(3);
    calculator.calculatorForm.get('operator')?.setValue('*');
    calculator.calculate();
    expect(calculator.result).toBe(6);
  });
  it('should divide when the / operator is selected and the calculation button is clicked.', () =&gt; {
    calculator.calculatorForm.get('operand1')?.setValue(3);
    calculator.calculatorForm.get('operand2')?.setValue(2);
    calculator.calculatorForm.get('operator')?.setValue('/');
    calculator.calculate();
    expect(calculator.result).toBe(1.5);
  });</st></pre>			<p><st c="6629">As a reminder, all </st><a id="_idIndexMarker448"/><st c="6649">tests are green, as shown in the following screenshot of Karma launched on </st><span class="No-Break"><st c="6724">a browser:</st></span></p>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/B21146_11_1.jpg" alt="Figure 11.1 – Calculator component test succeeded in the terminal"/><st c="6734"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="7953">Figure 11.1 – Calculator component test succeeded in the terminal</st></p>
			<p><st c="8018">We will now </st><a id="_idIndexMarker449"/><st c="8031">refactor the </st><a id="_idTextAnchor419"/><st c="8044">code</st><a id="_idTextAnchor420"/><st c="8048"> of our </st><strong class="source-inline"><st c="8056">calculate()</st></strong><st c="8067"> function in the </st><strong class="source-inline"><st c="8084">calculator.component.ts</st></strong><st c="8107"> component </st><span class="No-Break"><st c="8118">as follows:</st></span></p>
			<pre class="source-code"><st c="8129">
calculate(): void {
  const operator = this.calculatorForm.get('operator')?.value;
  const operand1 = this.calculatorForm.get('operand1')?.value;
  const operand2 = this.calculatorForm.get('operand2')?.value;
  if (!operator ||!operand1 ||!operand2) return;
  switch (operator) {
    case '+':
      this.add(operand1, operand2);
      break;
    case '-':
      this.subtract(operand1, operand2);
      break;
    case '*':
      this.multiply(operand1, operand2);
      break;
    case '/':
      this.divide(operand1, operand2);
      break;
    default:
      console.error(`Unsupported operator: ${operator}`);
      break;
  }
}</st></pre>			<p><st c="8672">Now, what’s </st><a id="_idIndexMarker450"/><st c="8685">going on with our tests? </st><st c="8710">They’re still all green as the following </st><span class="No-Break"><st c="8751">screenshot shows:</st></span></p>
			<div>
				<div id="_idContainer193" class="IMG---Figure">
					<img src="image/B21146_11_2.jpg" alt="Figure 11.2 – Green tests"/><st c="8768"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="10014">Figure 11.2 – Green tests</st></p>
			<p><st c="10039">This means that our refactoring is correct because if it wasn’t, our tests would be red. </st><st c="10129">We now understand the importance of TDD, because we can concentrate on refactoring our methods with peace of mind. </st><st c="10244">In the next section, we’ll learn some benefits of TDD </st><span class="No-Break"><st c="10298">in refactoring.</st></span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor421"/><st c="10313">Benefits of TDD in refactoring</st></h2>
			<p><st c="10344">This section delves</st><a id="_idIndexMarker451"/><st c="10364"> into the rewarding benefits of utilizing TDD during Angular code refactoring. </st><st c="10443">Here are some </st><span class="No-Break"><st c="10457">of them:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="10465">Increased confidence</st></strong><st c="10486">: The passing test acts as a safety net, allowing you to experiment with different refactoring techniques without worrying about breaking existing functionality. </st><st c="10649">This boosts your confidence during </st><span class="No-Break"><st c="10684">the process.</st></span></li>
				<li><strong class="bold"><st c="10696">Improved design</st></strong><st c="10712">: Thinking about the tests first encourages you to write modular code with well-defined functions. </st><st c="10812">This leads to cleaner and more maintainable code in the </st><span class="No-Break"><st c="10868">long run.</st></span></li>
				<li><strong class="bold"><st c="10877">Enhanced maintainability</st></strong><st c="10902">: A comprehensive test suite becomes a living documentation of the code’s expected behavior. </st><st c="10996">This simplifies future modifications and bug fixes, as you can rely on the tests to </st><span class="No-Break"><st c="11080">catch regressions.</st></span></li>
				<li><strong class="bold"><st c="11098">Better code coverage</st></strong><st c="11119">: TDD naturally encourages you to focus on covering various code paths with tests. </st><st c="11203">This results in more robust applications with fewer </st><span class="No-Break"><st c="11255">hidden bugs.</st></span></li>
			</ul>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor422"/><st c="11267">Examples in action</st></h2>
			<p><st c="11286">Let’s see how</st><a id="_idIndexMarker452"/><st c="11300"> TDD can be applied to common refactoring scenarios </st><span class="No-Break"><st c="11352">in Angular:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="11363">Refactoring a long service method</st></strong><st c="11397">: Imagine a service method responsible for fetching and processing a massive amount of data. </st><st c="11491">You can write a test that focuses on a specific aspect of the data processing logic. </st><st c="11576">Initially, the test would fail. </st><st c="11608">Then, you’d refactor the service method to extract that logic into a separate, well-tested function. </st><st c="11709">This improves code readability and maintainability while the test ensures the core functionality </st><span class="No-Break"><st c="11806">remains intact.</st></span></li>
				<li><strong class="bold"><st c="11821">Transforming a god component</st></strong><st c="11850">: A “god component” refers to an overly complex component, often violating the single responsibility principle by handling too many responsibilities or functionalities within itself. </st><st c="12034">This term is used to highlight the negative aspects of having components that grow too large and become difficult to manage, test, and understand. </st><st c="12181">Such components tend to inject numerous services, perform multiple tasks, and can lead to significant maintenance challenges o</st><a id="_idTextAnchor423"/><st c="12307">ver time. </st><st c="12318">This type of component performing a large number of tasks can therefore be redesigned by creating services dedicated to specific functionalities. </st><st c="12464">Tests can be written to verify the behavior of the refactored component and the newly </st><span class="No-Break"><st c="12550">created services.</st></span></li>
			</ul>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor424"/><st c="12567">Choosing the right tests to write</st></h2>
			<p><st c="12601">When prioritizing</st><a id="_idIndexMarker453"/><st c="12619"> tests for refactoring with TDD, consider </st><span class="No-Break"><st c="12661">these strategies:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="12678">Focus on pain points</st></strong><st c="12699">: Start with functionalities that are causing problems in your codebase, such as areas prone to errors or difficult </st><span class="No-Break"><st c="12816">to understand.</st></span></li>
				<li><strong class="bold"><st c="12830">Start small</st></strong><st c="12842">: Begin with smaller, well-defined tests that target specific functionalities. </st><st c="12922">This allows for quicker iterations through the </st><span class="No-Break"><st c="12969">red-green-refactor cycle.</st></span></li>
				<li><strong class="bold"><st c="12994">Test integration points</st></strong><st c="13018">: When refactoring components that interact with services or other components, write tests that verify these interactions alongside the</st><a id="_idIndexMarker454"/> <span class="No-Break"><st c="13154">component itself.</st></span></li>
			</ul>
			<p><st c="13172">In the next section, we’ll explain how to identify code smells and areas for improvement in </st><span class="No-Break"><st c="13265">Angular applications.</st></span></p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor425"/><st c="13286">Identifying code smells and areas for improvement in Angular applications</st></h1>
			<p><st c="13360">While your </st><a id="_idIndexMarker455"/><st c="13372">Angular application might seem functional on the surface, there could be underlying issues waiting to erupt. </st><st c="13481">These issues, known as code smells, don’t necessarily cause immediate problems but indicate areas in your codebase </st><a id="_idIndexMarker456"/><st c="13596">that could benefit from refactoring. </st><st c="13633">Just like a cluttered room can be stressful and unproductive, smelly code can make it difficult to maintain, understand, and extend your application. </st><st c="13783">This section delves into</st><a id="_idIndexMarker457"/><st c="13807"> the world of code smells in Angular applications. </st><st c="13858">We’ll explore what they are, why they matter, and how to identify them proactively. </st><st c="13942">By understanding these code smells, you’ll be equipped to prioritize refactoring efforts using TDD, ultimately leading to a cleaner, more maintainable, and robust </st><span class="No-Break"><st c="14105">code base.</st></span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor426"/><st c="14115">What are code smells?</st></h2>
			<p><st c="14137">Imagine </st><a id="_idIndexMarker458"/><st c="14146">walking into a kitchen where dirty dishes are piled up high in the sink, spices are scattered across the counter, and expired food lingers in the fridge. </st><st c="14300">This unpleasant scene might not prevent you from cooking a basic meal, but it certainly wouldn’t be an enjoyable or efficient experience. </st><st c="14438">Code smells are analogous to this messy kitchen in the software </st><span class="No-Break"><st c="14502">development world.</st></span></p>
			<p><st c="14520">Coined by Martin Fowler in his book, </st><em class="italic"><st c="14558">Refactoring: Improving the Design of Existing Code</st></em><st c="14608">, code smells are indicators of potential problems within your code base. </st><st c="14682">They don’t necessarily represent functional bugs that cause the application to crash. </st><st c="14768">Instead, they signify </st><a id="_idIndexMarker459"/><st c="14790">areas that could be improved for better readability, maintainability, and long-term health of </st><span class="No-Break"><st c="14884">your code.</st></span></p>
			<p><st c="14894">Code smells are not bugs, but they can attract bugs in the future. </st><st c="14962">They act like red flags, warning you of potential trouble spots that could become problematic as your </st><span class="No-Break"><st c="15064">application evolves.</st></span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor427"/><st c="15084">Why should we care about code smells in Angular?</st></h2>
			<p><st c="15133">Ignoring a messy kitchen might lead to unpleasant odors, fruit flies, and frustration when you need to cook a meal. </st><st c="15250">Similarly, neglecting code smells in your Angular application can</st><a id="_idIndexMarker460"/><st c="15315"> have several </st><span class="No-Break"><st c="15329">negative consequences:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="15351">Decreased maintainability</st></strong><st c="15377">: Smelly code becomes difficult to understand and modify over time. </st><st c="15446">As your application grows and features are added, the complexity of tangled code can make changes cumbersome and </st><span class="No-Break"><st c="15559">error prone.</st></span></li>
				<li><strong class="bold"><st c="15571">Increased debugging time</st></strong><st c="15596">: When bugs arise in smelly code, it can be challenging to pinpoint the root cause. </st><st c="15681">The lack of clear structure and organization makes it like searching for a needle in a haystack, wasting valuable </st><span class="No-Break"><st c="15795">developer time.</st></span></li>
				<li><strong class="bold"><st c="15810">Reduced team productivity</st></strong><st c="15836">: Working with smelly code can be frustrating and demotivating for developers. </st><st c="15916">The cognitive overhead of deciphering tangled logic slows down development and </st><span class="No-Break"><st c="15995">hinders collaboration.</st></span></li>
				<li><strong class="bold"><st c="16017">Technical debt</st></strong><st c="16032">: Unattended code smells accumulate over time, creating a technical debt that needs to be addressed eventually. </st><st c="16145">This debt can become a significant burden, requiring dedicated resources and potentially delaying new </st><span class="No-Break"><st c="16247">feature development.</st></span></li>
			</ul>
			<p><st c="16267">By proactively </st><a id="_idIndexMarker461"/><st c="16283">identifying and refactoring code smells, you can do </st><span class="No-Break"><st c="16335">the following:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="16349">Improve code readability</st></strong><st c="16374">: Clean and well-structured code is easier to understand for both you and other developers working on the project. </st><st c="16490">This reduces onboarding time for new team members and fosters </st><span class="No-Break"><st c="16552">better collaboration.</st></span></li>
				<li><strong class="bold"><st c="16573">Enhance maintainability</st></strong><st c="16597">: Refactored code is easier to modify and adapt as your </st><a id="_idIndexMarker462"/><st c="16654">application’s requirements evolve. </st><st c="16689">This allows you to introduce new features and bug fixes </st><span class="No-Break"><st c="16745">more efficiently.</st></span></li>
				<li><strong class="bold"><st c="16762">Reduce debugging time</st></strong><st c="16784">: Cleaner code with a clear separation of concerns makes it easier to isolate and fix problems when </st><span class="No-Break"><st c="16885">bugs arise.</st></span></li>
				<li><strong class="bold"><st c="16896">Boost team productivity</st></strong><st c="16920">: Working with well-structured code improves developer experience and satisfaction. </st><st c="17005">This leads to higher productivity and a more positive </st><span class="No-Break"><st c="17059">development environment.</st></span></li>
				<li><strong class="bold"><st c="17083">Minimize technical debt</st></strong><st c="17107">: By addressing code smells early on, you prevent them from accumulating and becoming a significant burden in </st><span class="No-Break"><st c="17218">the future.</st></span></li>
			</ul>
			<p><st c="17229">In essence, prioritizing code smell refactoring is an investment in the long-term health and maintainability of your </st><span class="No-Break"><st c="17347">Angular application.</st></span></p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor428"/><st c="17367">Identifying the most common code smells in Angular applications</st></h2>
			<p><st c="17431">Now that we</st><a id="_idIndexMarker463"/><st c="17443"> understand the importance </st><a id="_idIndexMarker464"/><st c="17470">of identifyi</st><a id="_idTextAnchor429"/><st c="17482">ng code smells, let’s take a look at some of the most common offenses you might encounter in your </st><span class="No-Break"><st c="17581">Angular application:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="17601">The long and winding method</st></strong><st c="17629">: Imagine a method in your service that stretches across dozens of lines, handling various tasks. </st><st c="17728">This is a prime example of a long method, a code smell suggesting a lack of modularity. </st><st c="17816">These methods can be difficult to understand, test, and modify. </st><st c="17880">Refactoring involves breaking down such behemoths into smaller, well-defined functions, each focusing on a specific task. </st><st c="18002">This enhances code readability </st><span class="No-Break"><st c="18033">and maintainability.</st></span></li>
				<li><strong class="bold"><st c="18053">The god component</st></strong><st c="18071">: Have you encountered a component overloaded with responsibilities? </st><st c="18141">This is a “god component,” handling everything from data fetching to complex UI logic. </st><st c="18228">Such components become maintenance nightmares as changes in one area can ripple through the entire component, causing </st><a id="_idIndexMarker465"/><st c="18346">unintended consequences. </st><st c="18371">Refactoring can involve </st><span class="No-Break"><st c="18395">the following:</st></span><ul><li><strong class="bold"><st c="18409">Creating dedicated services</st></strong><st c="18437">: Extract functionalities related to data access, business logic, or calculations into separate services. </st><st c="18544">These services can be reused</st><a id="_idIndexMarker466"/><st c="18572"> by multiple components, promoting </st><span class="No-Break"><st c="18607">better organization.</st></span></li><li><strong class="bold"><st c="18627">Splitting the component</st></strong><st c="18651">: Break down the god component into smaller, more focused components, each handling a specific aspect of the UI </st><span class="No-Break"><st c="18764">or functionality.</st></span></li></ul></li>
				<li><strong class="bold"><st c="18781">The code duplication monster</st></strong><st c="18810">: Seeing the same block of code copy-pasted across different parts of your application? </st><st c="18899">This code duplication not only wastes space but also makes maintenance a challenge. </st><st c="18983">Any bug fix in one instance needs to be replicated across all copies. </st><st c="19053">Refactoring involves identifying these repetitive code snippets and creating </st><span class="No-Break"><st c="19130">the following:</st></span><ul><li><strong class="bold"><st c="19144">Reusable components</st></strong><st c="19164">: If the duplicated code deals with UI elements, consider creating a reusable component that can be used in </st><span class="No-Break"><st c="19273">multiple places.</st></span></li><li><strong class="bold"><st c="19289">Services or utility functions</st></strong><st c="19319">: For duplicated logic unrelated to the UI, extract them into services or utility functions that can be shared </st><span class="No-Break"><st c="19431">across components.</st></span></li><li><strong class="bold"><st c="19449">The magic number mystery</st></strong><st c="19474">: Scattered numeric constants with no clear meaning throughout your code base are like magic tricks; they are confusing and difficult to maintain. </st><st c="19622">Imagine having a constant </st><strong class="source-inline"><st c="19648">10</st></strong><st c="19650"> used for pagination but its purpose is unclear. </st><st c="19699">Refactoring involves replacing these magic numbers with named variables or constants. </st><st c="19785">For example, use </st><strong class="source-inline"><st c="19802">ITEMS_PER_PAGE</st></strong><st c="19816"> instead of </st><strong class="source-inline"><st c="19828">10</st></strong><st c="19830">, making the code more self-documenting and easier </st><span class="No-Break"><st c="19881">to understand.</st></span></li></ul></li>
				<li><strong class="bold"><st c="19895">The spaghetti code maze</st></strong><st c="19919">: Imagine code that winds and twists, lacking clear structure and organization. </st><st c="20000">This is spaghetti code, making it a challenge to navigate, understand, and modify. </st><st c="20083">TDD can be a powerful tool to combat spaghetti code. </st><st c="20136">By</st><a id="_idIndexMarker467"/><st c="20138"> writing tests first and then refactoring the code to meet those tests, you can introduce structure and improve the overall organization of your </st><span class="No-Break"><st c="20283">code base.</st></span></li>
			</ul>
			<p><st c="20293">In the next section, we </st><a id="_idIndexMarker468"/><st c="20318">will learn about iterative improvement: the red-green-refactor cycle for continuous </st><span class="No-Break"><st c="20402">code enhancement.</st></span></p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor430"/><st c="20419">Iterative improvement – red-green-refactor cycle for continuous code enhancement</st></h1>
			<p><st c="20500">Refactoring </st><a id="_idIndexMarker469"/><st c="20513">existing code in Angular applications can be a daunting task. </st><st c="20575">You want to improve the code’s structure and organization, but the fear of introducing regressions (bugs) often looms large. </st><st c="20700">This is where TDD steps in, offering a structured and iterative approach to</st><a id="_idIndexMarker470"/><st c="20775"> navigate refactoring with confidence. </st><st c="20814">At the heart of TDD lies the “red-green-refactor” cycle, a </st><a id="_idIndexMarker471"/><st c="20873">powerful technique for making incremental improvements to your code base while ensuring its functionality </st><span class="No-Break"><st c="20979">remains intact.</st></span></p>
			<p><st c="20994">Imagine you’re a sculptor working on a large block of marble. </st><st c="21057">The red-green-refactor cycle is like your roadmap to transforming that raw material into a masterpiece. </st><st c="21161">Here’s a breakdown of each stage and its significance in the context of refactoring </st><span class="No-Break"><st c="21245">Angular code:</st></span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor431"/><st c="21258">Red – setting the stage with failing tests</st></h2>
			<p><st c="21301">The cycle begins </st><a id="_idIndexMarker472"/><st c="21319">with red, signifying a failing test. </st><st c="21356">This might seem counterintuitive – why write a </st><a id="_idTextAnchor432"/><st c="21403">test that’s destined to fail? </st><st c="21433">The purpose of this initial red test is to define the desired behavior of the code you intend to refactor. </st><st c="21540">Think of it as a blueprint outlining the functionality you want to achieve. </st><st c="21616">He</st><a id="_idTextAnchor433"/><st c="21618">re’s what creating a red </st><span class="No-Break"><st c="21644">test entails:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="21657">Identify the refactoring target</st></strong><st c="21689">: Start by pinpointing a specific area of your Angular application that exhibits code smells or requires improvement. </st><st c="21808">This could be a long method in service, a god component handling numerous tasks, or duplicated </st><span class="No-Break"><st c="21903">code snippets.</st></span></li>
				<li><strong class="bold"><st c="21917">Define the expected outcome</st></strong><st c="21945">: Clearly outline what the refactored code should do. </st><st c="22000">What data should it process? </st><st c="22029">How should it interact with the UI? </st><st c="22065">Write a test that reflects this expected behavior. </st><st c="22116">Remember, this test will initially fail, as the desired functio</st><a id="_idTextAnchor434"/><st c="22179">nality isn</st><a id="_idTextAnchor435"/><st c="22190">’t </st><span class="No-Break"><st c="22194">implemented yet.</st></span></li>
			</ul>
			<p><st c="22210">A failing red test</st><a id="_idIndexMarker473"/><st c="22229"> serves a critical purpose. </st><st c="22257">It establishes a baseline – a clear understanding of the functionality that’s currently missing. </st><st c="22354">This provides a safety net during the refactoring process. </st><st c="22413">As you make code changes, the failing test ensures you’re on the right track and haven’t accidentally broken </st><span class="No-Break"><st c="22522">existing functionalities.</st></span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor436"/><st c="22547">Green – making the test pass with minimal code</st></h2>
			<p><st c="22594">Once you </st><a id="_idIndexMarker474"/><st c="22604">have your red test in place, it’s time to move to the green stage. </st><st c="22671">Here, the objective is to write just enough code to make the failing test pass. </st><st c="22751">Don’t get caught up in writing perfectly optimized or elegant code at this point. </st><st c="22833">Focus on the core functionality defined by the test. </st><st c="22886">Here are some key considerations for the </st><span class="No-Break"><st c="22927">green stage:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="22939">Simple implementations</st></strong><st c="22962">: The initial code you write to make the test pass might be basic. </st><st c="23030">It doesn’t have to be the most efficient or well-structured solution yet. </st><a id="_idTextAnchor437"/><st c="23104">The priority is to get the test passing and establish a baseline </st><span class="No-Break"><st c="23169">for refactoring.</st></span></li>
				<li><strong class="bold"><st c="23185">Focus on functionality</st></strong><st c="23208">: Ensure the code you write fulfills the specific behavior outlined in the test. </st><st c="23290">Don’t introduce unnecessary f</st><a id="_idTextAnchor438"/><st c="23319">eatures or</st><a id="_idTextAnchor439"/><st c="23330"> logic at </st><span class="No-Break"><st c="23340">this stage.</st></span></li>
			</ul>
			<p><st c="23351">A passing green test signifies a crucial milestone. </st><st c="23404">It verifies that the core functionality you’re refactoring is now implemented, albeit potentially in a basic form. </st><st c="23519">This green test acts as a safety net throughout the refactoring process. </st><st c="23592">As you make further code changes, you can rely on the test to ensure you haven’t strayed from the </st><span class="No-Break"><st c="23690">desired outcome.</st></span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor440"/><st c="23706">Refactor – transforming the code with confidence</st></h2>
			<p><st c="23755">With a </st><a id="_idIndexMarker475"/><st c="23763">passing green test as your safety net, you’ve reached the heart of the cycle – the refactor stage. </st><st c="23862">Here’s where you can unleash your refactoring skills to improve the code’s readability, maintainability, and efficiency. </st><st c="23983">Here are some potential areas you might want to focus on </st><span class="No-Break"><st c="24040">during refactoring:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="24059">Modularize long methods</st></strong><st c="24083">: Break down those long, monolithic methods into smaller, well-defined functions. </st><st c="24166">This enhances code readability and makes it easier to understand the </st><span class="No-Break"><st c="24235">logic flow.</st></span></li>
				<li><strong class="bold"><st c="24246">Extract reusable components and services</st></strong><st c="24287">: If your component has become a god component handling numerous tasks, consider extracting functionalities into dedicated services or reusable components. </st><st c="24444">This promotes better organization and separation </st><span class="No-Break"><st c="24493">of concerns.</st></span></li>
				<li><strong class="bold"><st c="24505">Eliminate duplication</st></strong><st c="24527">: Identify and refactor repetitive code snippets into reusable components, services, or utility functions. </st><st c="24635">This reduces code redundancy and </st><span class="No-Break"><st c="24668">simplifies maintenance.</st></span></li>
				<li><strong class="bold"><st c="24691">Apply design patterns</st></strong><st c="24713">: Consider incorporating design patterns that promote better code structure and organization. </st><st c="24808">This can make your code more maintainable and easier to understand for </st><span class="No-Break"><st c="24879">other developers.</st></span></li>
				<li><strong class="bold"><st c="24896">Simplify logic</st></strong><st c="24911">: Look for opportunities to streamline complex logic and enhance code clarity. </st><st c="24991">This can involve using more descriptive variable names, breaking down complex conditional statements, or utilizing </st><span class="No-Break"><st c="25106">helper functions.</st></span></li>
			</ul>
			<p><st c="25123">Throughout the refactoring process, keep the green test in mind. </st><st c="25189">Repeat this cycle iteratively, tackling one aspect of the code at a time. </st><st c="25263">Each completed cycle leaves you with cleaner, more maintainable code, with robust tests guaranteeing its continued functionality. </st><st c="25393">The emphasis on small, incremental changes promotes a more controlled, less error-prone </st><span class="No-Break"><st c="25481">refactoring process.</st></span></p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor441"/><st c="25501">Summary</st></h1>
			<p><st c="25509">In conclusion, refactoring and improving Angular code through TDD is a powerful approach to enhancing the quality, maintainability, and efficiency of your Angular applications. </st><st c="25687">By following the TDD methodology, developers can ensure that their code is robust, well structured, and easy to understand. </st><st c="25811">This approach not only helps in identifying and addressing code smells but also in developing a solid foundation for future enhancements and modifications. </st><st c="25967">TDD encourages developers to write tests before writing the actual code, ensuring that the code meets the defined requirements and behaves as expected. </st><st c="26119">This iterative process of writing tests, making them pass, and then refactoring the code for improvement is at the heart of TDD. </st><st c="26248">It fosters a culture of continuous improvement, where code is always in a state that is ready for </st><span class="No-Break"><st c="26346">further development.</st></span></p>
			<p><st c="26366">Moreover, TDD facilitates the development of isolated, testable units of code, making it easier to identify and fix issues early in the development process. </st><st c="26524">This is particularly beneficial in Angular applications, where components, services, and modules often have complex dependencies and interactions. </st><st c="26671">By testing these units in isolation, developers can ensure that each part of the application works correctly before integrating them into the </st><span class="No-Break"><st c="26813">larger system.</st></span></p>
			<p><st c="26827">Furthermore, TDD promotes the development of high-quality, maintainable code by encouraging developers to write clear, concise, and well-documented tests. </st><st c="26983">These tests serve as documentation, making it easier for other developers (or even the original developers in the future) to understand the purpose and functionality of </st><span class="No-Break"><st c="27152">the code.</st></span></p>
			<p><st c="27161">In the context of Angular, TDD can be particularly effective in developing services, components, and pipes, as demonstrated in the examples provided. </st><st c="27312">By starting with a clear definition of what the code should do, developers can write tests that guide the implementation process, ensuring that the code meets the desired specifications. </st><st c="27499">This approach not only leads to better-designed code but also makes the development process more efficient </st><span class="No-Break"><st c="27606">and enjoyable.</st></span></p>
			<p><st c="27620">In summary, refactoring and improving Angular code through TDD is a valuable practice that can significantly enhance the quality of your Angular applications. </st><st c="27780">By adopting TDD, developers can ensure that their code is robust, maintainable, and ready for future enhancements. </st><st c="27895">This approach not only benefits the current development cycle but also sets a solid foundation for future development efforts, making it a worthwhile investment for any </st><span class="No-Break"><st c="28064">Angular developer.</st></span></p>
			<p><st c="28082">This is the end of the book. </st><st c="28112">This book serves as a comprehensive guide for developers looking to adopt or improve their TDD practices in Angular projects. </st><st c="28238">By following the principles and techniques described in this book, developers can significantly improve the reliability, performance, and maintainability of their Angular applications. </st><st c="28423">The book emphasizes the value of a thorough testing strategy, the importance of using the right tools and practices, and the benefits of adopting a test-first approach to development. </st><st c="28607">Whether you’re new to Angular or an experienced developer looking to hone your skills, this book offers valuable insights and practical advice for mastering TDD </st><span class="No-Break"><st c="28768">in Angular.</st></span></p>
		</div>
	<div id="charCountTotal" value="28779"/></body></html>