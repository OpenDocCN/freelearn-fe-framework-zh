- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Scalable Front-End Architecture for Angular Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 应用程序的可扩展前端架构
- en: Angular is a powerful and extensive framework for building web applications.
    According to the 2023 Stack Overflow developer survey, it is the fourth most used
    web technology after ReactJS, NodeJS, and jQuery among professional developers.
    Due to the structure and tools it provides, Angular is often chosen when building
    large web applications or enterprise solutions comprised of several applications
    and libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 是一个强大且功能丰富的框架，用于构建 Web 应用程序。根据 2023 年 Stack Overflow 开发者调查，在专业开发者中，它排在
    ReactJS、NodeJS 和 jQuery 之后，是第四大最受欢迎的 Web 技术。由于其提供的结构和工具，Angular 在构建大型 Web 应用程序或由多个应用程序和库组成的企业解决方案时经常被选中。
- en: This book will guide you through the process of effectively using the Angular
    framework to develop and test applications of any size. You’ll start by learning
    about front-end architecture and setting up a scalable workspace with Nx that’s
    ready for hundreds of Angular applications. Next, you’ll explore the most powerful
    and newest features within the Angular framework. You’ll learn about reactive
    programming and state management using RxJS, Signals, and NgRx, and will be able
    to test Angular applications with Jest and Cypress. Upon completing this book,
    you’ll be able to effectively use the Angular framework and develop scalable,
    enterprise-ready Angular applications, utilizing all the tools Angular has to
    offer while implementing best practices and sound design patterns.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将指导你有效地使用 Angular 框架来开发和测试任何规模的应用程序。你将从了解前端架构和设置一个可扩展的工作空间开始，该工作空间使用 Nx 准备好处理数百个
    Angular 应用程序。接下来，你将探索 Angular 框架中最强大和最新的功能。你将学习使用 RxJS、Signals 和 NgRx 进行响应式编程和状态管理，并能够使用
    Jest 和 Cypress 测试 Angular 应用程序。完成本书后，你将能够有效地使用 Angular 框架，并开发可扩展的企业级 Angular 应用程序，利用
    Angular 提供的所有工具，同时实施最佳实践和良好的设计模式。
- en: In this chapter, you will create your Angular workspace using Nx. You’ll start
    by learning what we mean by scalable front-end architecture and why it is essential
    to think about your architecture before you start writing code. You will also
    learn about different patterns in front-end architecture and what to consider
    when building enterprise-ready solutions from scratch.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用 Nx 创建你的 Angular 工作空间。你将从了解我们所说的可扩展前端架构及其在开始编写代码之前考虑架构的重要性开始。你还将了解前端架构的不同模式，以及从头开始构建企业级解决方案时应考虑的因素。
- en: Lastly, you will explore and use Nx, the build tool that allows you to create
    scalable Angular monorepos. By the end of this chapter, you will understand crucial
    aspects of front-end architecture and have your own Nx monorepo for Angular, ready
    to handle hundreds of applications easily.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将探索并使用 Nx，这是一个构建工具，允许你创建可扩展的 Angular 单仓库。在本章结束时，你将了解前端架构的关键方面，并拥有自己的 Nx
    单仓库用于 Angular，可以轻松处理数百个应用程序。
- en: 'This chapter will cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Understanding scalable front-end applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解可扩展的前端应用程序
- en: Different approaches to scalable front-end architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展前端架构的不同方法
- en: What is Nx and why should you use it?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nx 是什么？为什么你应该使用它？
- en: Setting up a scalable Angular workspace
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置可扩展的 Angular 工作空间
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: By the end of this chapter, we will create an Nx monorepo with an Angular application
    and library in it. To follow along, you’ll need to install some tools. Note that
    we will only use freely available tools.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将创建一个包含 Angular 应用程序和库的 Nx 单仓库。为了跟上进度，你需要安装一些工具。请注意，我们只会使用免费可用的工具。
- en: 'You will require the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下工具：
- en: '**Visual Studio Code** (**VS Code**) as your **integrated development** **environment**
    (**IDE**)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**（**VS Code**）作为你的**集成开发环境**（**IDE**）'
- en: Chrome web browser
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome 浏览器
- en: Angular 17.1 or higher
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 17.1 或更高版本
- en: NodeJS version v20.11.0 or higher
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NodeJS 版本 v20.11.0 或更高版本
- en: TypeScript version 5.3.3 or higher
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 版本 5.3.3 或更高版本
- en: Nx version v18.0.7 or higher
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nx 版本 v18.0.7 或更高版本
- en: Throughout this book, we will use Angular 17.1, NodeJS 20.11.0, TypeScript 5.3.3,
    and Nx 18.0.7.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将使用 Angular 17.1、NodeJS 20.11.0、TypeScript 5.3.3 和 Nx 18.0.7。
- en: The GitHub repository for this book is available at [https://github.com/PacktPublishing/Effective-Angular](https://github.com/PacktPublishing/Effective-Angular).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本书对应的 GitHub 仓库可在 [https://github.com/PacktPublishing/Effective-Angular](https://github.com/PacktPublishing/Effective-Angular)
    找到。
- en: Understanding scalable front-end applications
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解可扩展的前端应用程序
- en: Modern web applications are constantly getting bigger and more complex. Because
    of this, developing scalable front-end applications is more critical than ever.
    To create scalable front-end applications, we need to understand what scalability
    means in the context of a front-end application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络应用程序不断变得更大、更复杂。因此，开发可扩展的前端应用程序比以往任何时候都更加关键。为了创建可扩展的前端应用程序，我们需要了解在应用程序上下文中可扩展性的含义。
- en: What is scalability?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性是什么？
- en: The first thing that might come to mind when you hear the term **scalability**
    is handling more traffic. However, in the context of front-end applications, when
    talking about scalability, we mostly mean the scalability of the code base. Or,
    more concisely, the code is easy to extend, and modules or micro front-ends can
    be added to the software without much work. Components and libraries are reusable;
    the code is easy to maintain, test, and debug, even when the application grows.
    You can work with different teams on separate parts of the application, and onboarding
    new teams that write similar code is easy to achieve and enforce. The application
    has good performance and small bundle sizes. Compile and build times remain low,
    and deployment can be done swiftly to different staging environments if needed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你听到**可扩展性**这个词时，可能会首先想到处理更多的流量。然而，在前端应用程序的上下文中，当我们谈论可扩展性时，我们主要指的是代码库的可扩展性。或者，更简洁地说，代码易于扩展，模块或微前端可以轻松添加到软件中，而无需做太多工作。组件和库是可重用的；代码易于维护、测试和调试，即使应用程序规模扩大。你可以与不同的团队一起在应用程序的不同部分工作，并且加入编写类似代码的新团队既容易实现也容易执行。应用程序具有良好的性能和较小的包大小。编译和构建时间保持较低，如果需要，可以迅速部署到不同的预发布环境中。
- en: To achieve these feats within your front-end applications, you must create a
    good architecture, a set of tools, and rules everyone can adhere to. Your architecture
    will include elements such as your repository type, folder structure, architectural
    patterns, design patterns, a programming language, framework, and tools for building,
    testing, linting, and deploying your application. Making the right decisions for
    each part of your architecture helps with creating scalable applications that
    are easy to maintain and extend.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的前端应用程序中实现这些成就，您必须创建一个良好的架构、一套工具和规则，让每个人都能遵守。您的架构将包括诸如您的存储库类型、文件夹结构、架构模式、设计模式、编程语言、框架以及构建、测试、代码检查和部署应用程序的工具等元素。为架构的每个部分做出正确的决策有助于创建可扩展的应用程序，这些应用程序易于维护和扩展。
- en: When making architectural decisions, you should aim to create a fast, loosely
    coupled, testable system. You want to avoid direct dependencies between different
    parts of your system so that you don’t get stuck and need to refactor the entire
    application when the business introduces changes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出架构决策时，你应该旨在创建一个快速、松散耦合、可测试的系统。你希望避免系统不同部分之间的直接依赖，这样当业务引入变化时，你就不需要重构整个应用程序。
- en: With this brief introduction to what a scalable front-end application is, let’s
    understand the importance of a good front-end architecture.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要介绍了什么是可扩展的前端应用程序之后，让我们了解良好的前端架构的重要性。
- en: Why is front-end architecture important?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么前端架构很重要？
- en: Good architecture is essential to maintain a good workflow for the developers
    working on the software and makes it easy for new teams and team members to join.
    If developers spend much time refactoring or waiting for builds or tests to complete,
    they wander off and do less productive things.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的架构对于维护软件开发者的良好工作流程至关重要，并使得新团队和团队成员的加入变得容易。如果开发者花费大量时间重构或等待构建或测试完成，他们就会分心去做更不
    productive 的事情。
- en: With good architecture in place, the code base remains manageable, even when
    your applications grow. Without good architecture, the code becomes messy and
    hard to debug or extend. As time progresses, such problems will pile up, and developers
    will be wasting more time on bugs and refactoring than creating new features,
    especially in large enterprise solutions where business needs are constantly changing.
    Before you know it, you will have a web of dependencies, and adding simple things
    will become very time-consuming.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在良好的架构支持下，即使应用规模扩大，代码库仍然可以管理。没有良好的架构，代码会变得杂乱无章，难以调试或扩展。随着时间的推移，这些问题会越积越多，开发者将花费更多的时间在调试和重构上，而不是创建新功能，尤其是在业务需求不断变化的大型企业解决方案中。不知不觉中，你将面临一个错综复杂的依赖关系网，添加简单的东西将变得非常耗时。
- en: Suppose you’re building an application for employee scheduling that includes
    a calendar component. You want to avoid tight coupling between the calendar and
    scheduling applications. When management lets you know the company is adding another
    application – let’s say a project management tool that also includes a calendar
    – you don’t want to redo the entire calendar component and scheduling application
    because the two are tightly coupled.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开发一个包含日历组件的员工排班应用程序。你希望避免日历和排班应用程序之间的紧密耦合。当管理层告诉你公司正在添加另一个应用程序——比如说一个包含日历的项目管理工具——你不想因为两者紧密耦合而重新设计整个日历组件和排班应用程序。
- en: 'The following figure shows the development process with and without architecture.
    Without architecture, you start fast, but in the end, you are crawling. With architecture,
    you will have a consistent and predictable work pace:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了有和无架构的开发过程。没有架构时，你开始得快，但最终你会缓慢前行。有了架构，你将有一个一致且可预测的工作节奏：
- en: '![Figure 1.1: Development speed](img/B21625_01_1.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1：开发速度](img/B21625_01_1.jpg)'
- en: 'Figure 1.1: Development speed'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：开发速度
- en: Now that you understand what we mean by scalable front-end applications and
    why having good architecture is essential to achieve them, we will dive into some
    approaches to scaling front-end applications and learn about their advantages
    and trade-offs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了我们所说的可扩展前端应用程序的含义以及为什么良好的架构对于实现它们至关重要，我们将深入了解一些扩展前端应用程序的方法，并了解它们的优缺点。
- en: Different approaches to scaling front-end applications
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端应用程序的扩展方法
- en: When it comes to architecting software, it’s essential to think of what you
    are building, what it can grow into, what the context is, and who will work on
    it. Depending on these parameters, you’ll want to create an architecture that’s
    flexible enough to grow and adapt without overengineering it, making things more
    complex and time-consuming than needed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到软件架构时，考虑你正在构建的内容、它能够发展到什么程度、所处的环境以及谁将负责它，这是至关重要的。根据这些参数，你将希望创建一个足够灵活的架构，以便在不过度设计的情况下增长和适应，避免使事情比必要的更复杂和耗时。
- en: For example, if you’re building a simple website for a small family-owned business,
    you don’t need elaborate architecture and complex design patterns; this will make
    things more complex and time-consuming than they need to be. The needs for the
    website will probably stay mostly the same, and the code base will remain small
    and manageable. But when you’re building enterprise software comprised of multiple
    applications, the needs and utility of those applications will change quite a
    bit, and you’ll want to ensure that the software is set up for that.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在为一家小型家族企业构建一个简单的网站，你不需要复杂的架构和设计模式；这会使事情比必要的更复杂和耗时。网站的需求可能保持大致相同，代码库将保持小而易于管理。但是，当你构建由多个应用程序组成的商业软件时，这些应用程序的需求和效用将发生很大变化，你需要确保软件为此做好准备。
- en: In this section, you will learn about different architectural choices so that
    you can ensure you don’t over or under-engineer your front-end applications. You
    will learn about different repository structures and architectural patterns that
    are commonly used within Angular applications. Without further ado, let’s learn
    about the differences between mono and poly repositories.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解不同的架构选择，以确保你不会过度或不足设计你的前端应用程序。你将了解在 Angular 应用程序中常用的一些仓库结构和架构模式。无需多言，让我们了解单仓库和多仓库之间的差异。
- en: Monorepo or polyrepo
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单仓库或多仓库
- en: '**Monorepo** and **polyrepo** are two options for storing code within a source
    control application such as GitHub. If you create a new repository for each project
    or application, it’s called a polyrepo or multi-repos structure. Meanwhile, when
    all applications are in one large repository, it’s called a monorepo structure.
    For large companies, a monorepo can easily contain hundreds of applications.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**单仓库**和**多仓库**是两种在源代码管理应用程序（如 GitHub）中存储代码的选项。如果你为每个项目或应用程序创建一个新的仓库，它被称为多仓库或多仓库结构。同时，当所有应用程序都在一个大型仓库中时，它被称为单仓库结构。对于大型公司来说，单仓库可以轻松包含数百个应用程序。'
- en: What option should you pick when developing a large front-end environment? Let’s
    start exploring the advantages and disadvantages of both solutions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发大型前端环境时，你应该选择哪个选项？让我们开始探讨这两种解决方案的优缺点。
- en: Advantages of monorepos
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单仓库的优势
- en: 'Some of the key advantages of monorepos are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 单仓库的一些关键优势如下：
- en: '**Easy code sharing**: Monorepos make it easy to share code among different
    projects and teams. You have the code of all projects in one directory, so inspecting
    or reusing code from another project and sharing things in libraries is simple.
    This helps prevent duplicate code, gives you inspiration and guidance on solving
    similar issues, and allows you to quickly check if a bug originates in your code
    or the implementation of a library.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于代码共享**：单一代码库使得在不同项目和团队之间共享代码变得容易。你可以在一个目录中拥有所有项目的代码，因此检查或重用另一个项目的代码，以及在库中共享事物变得简单。这有助于防止代码重复，为你解决类似问题提供灵感和指导，并允许你快速检查错误是否起源于你的代码或库的实现。'
- en: '**Uniformity among different applications**: Because all code resides in one
    repository, enforcing uniformity among different applications is easier. You can
    ensure that the same tooling is used, code conventions and best practices are
    applied, and all applications are tested similarly. Also, testing the entire system
    is easier with a monorepo.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同应用程序之间的统一性**：因为所有代码都存放在一个仓库中，所以在不同应用程序之间强制统一性更容易。你可以确保使用相同的工具，应用代码约定和最佳实践，并且所有应用程序都进行类似的测试。此外，使用单一代码库进行整个系统的测试也更容易。'
- en: '**No versioning conflicts**: In a monorepo, dependencies commonly share the
    same version among all applications. This ensures that no versioning conflicts
    occur and implementations are equal in all applications. Furthermore, it ensures
    that applications that are not actively developed still get regular updates for
    their dependencies.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无版本冲突**：在单一代码库中，依赖项通常在所有应用程序中共享相同的版本。这确保了不会发生版本冲突，并且所有应用程序中的实现都是一致的。此外，这也确保了那些没有积极开发的应用程序仍然会定期更新其依赖项。'
- en: '**Cross-project refactoring**: If you want to refactor something that occurs
    in many applications, you can do it in one go for all applications or efficiently
    run scripts to perform these actions.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨项目重构**：如果你想要重构在许多应用程序中出现的某些内容，你可以一次性对所有应用程序进行重构，或者高效地运行脚本来执行这些操作。'
- en: '**Quick code movement and debugging**: Code can quickly be moved from one project
    to another, and when you encounter a bug within a library, you can fix the bug
    without holdups and continue your work.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速代码移动和调试**：代码可以快速从一个项目移动到另一个项目，当你遇到库中的错误时，你可以立即修复错误，而无需中断工作，继续你的工作。'
- en: '**Shared commit timeline**: Lastly, a monorepo has one shared commit timeline.
    This makes it safe to create atomic commits with changes in multiple applications.
    This happens because if anything goes wrong, you can always revert to a common
    state of all applications through the commit timeline.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享提交时间线**：最后，单一代码库有一个共享的提交时间线。这使得在多个应用程序中创建原子提交变得安全。这是因为如果出现问题，你总是可以通过提交时间线回滚到所有应用程序的共同状态。'
- en: Regardless of these advantages, monorepos have some shortcomings too. We’ll
    look at them in detail in the following section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这些优势如何，单一代码库也有一些缺点。我们将在下一节中详细探讨。
- en: Disadvantages of monorepos
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单一代码库的缺点
- en: 'Some of the disadvantages of monorepos are as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 单一代码库的一些缺点如下：
- en: '**Large folder structure**: A monorepo can be daunting because all code and
    libraries live in one large solution. If you have yet to work with a monorepo,
    this might take some time to get used to. Because it’s so easy to use code from
    other projects, you need to be extra careful not to create unwanted dependencies
    between applications.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大型文件夹结构**：单一代码库可能会让人望而生畏，因为所有代码和库都生活在一个大解决方案中。如果你还没有使用过单一代码库，这可能需要一些时间来适应。因为很容易使用其他项目的代码，所以你需要格外小心，不要在应用程序之间创建不必要的依赖关系。'
- en: '**Complex package updates**: Updating packages and dependencies in a monorepo
    can be complicated because, often, all projects need to update at once.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的包更新**：在单一代码库中更新包和依赖项可能很复杂，因为通常所有项目都需要同时更新。'
- en: '**Breaking changes**: Because there are no different versions, when you make
    changes in libraries, you can break other applications without noticing it.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**破坏性变更**：因为没有不同的版本，当你对库进行更改时，你可能会在不注意的情况下破坏其他应用程序。'
- en: '**Slow build times**: In a monorepo, building and testing can become time-consuming
    if not managed correctly.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建时间慢**：在单一代码库中，如果管理不当，构建和测试可能会变得耗时。'
- en: '**Challenges in deployment**: Deploying applications modularly can be more
    challenging compared to polyrepos, where everything is separated and modular by
    nature.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署挑战**：与所有内容都按性质分离和模块化的多代码库相比，模块化部署应用程序可能更具挑战性。'
- en: Most disadvantages can be mitigated with the right tools. For monorepos comprised
    of Angular applications, you can use Nx, giving you everything to handle a monorepo
    without these disadvantages. In this book, we will work with a monorepo and Nx.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数缺点都可以通过合适的工具来缓解。对于由 Angular 应用程序组成的单仓库，你可以使用 Nx，这样你就可以处理单仓库而无需这些缺点。在这本书中，我们将使用单仓库和
    Nx。
- en: Now, let’s move on to the advantages and disadvantages of polyrepos.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论多仓库的优点和缺点。
- en: Advantages of polyrepos
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多仓库的优点
- en: 'The key advantages of polyrepos are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 多仓库的关键优点如下：
- en: '**A higher level of isolation between applications**: The most apparent advantage
    of a polyrepo is higher levels of isolation between your applications. Each project
    has a repository and developers can do whatever they want within that repository
    without affecting other projects too much.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序之间的高隔离度**：多仓库最明显的优点是应用程序之间的高隔离度。每个项目都有一个仓库，开发者可以在该仓库内做任何他们想做的事情，而不会过多地影响其他项目。'
- en: '**Flexibility with dependency management**: When using a polyrepo, each project
    can manage versions of its dependencies on its own. This gives the teams working
    on the projects more freedom when updating dependencies and offers more stability.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖管理的灵活性**：当使用多仓库时，每个项目可以独立管理其依赖项的版本。这为项目团队在更新依赖项时提供了更多的自由度，并提供了更多的稳定性。'
- en: '**Individual tooling**: With a polyrepo, there is more flexibility for using
    different tools and programming languages.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单个工具**：在使用多仓库时，有更多的灵活性来使用不同的工具和编程语言。'
- en: '**Easy to manage**: A polyrepo is generally easier to manage, especially for
    smaller teams. There is little code in each repository compared to a monorepo,
    so there are fewer things you can affect with your changes.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于管理**：多仓库通常更容易管理，特别是对于小型团队来说。与单仓库相比，每个仓库中的代码较少，因此你的更改影响的东西更少。'
- en: '**Straightforward modular deployment**: Deploying your applications modularly
    is more straightforward.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化部署简单**：模块化部署你的应用程序更加简单。'
- en: '**In-line with a micro front-end architecture**: Lastly, if you’re developing
    with a micro front-end architecture, using a polyrepo might feel more in tune
    with the rest of your architecture. However, micro front-ends can be achieved
    with both a monorepo and polyrepo structure.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与微前端架构一致**：最后，如果你正在使用微前端架构进行开发，使用多仓库可能会感觉与你的整体架构更加协调。然而，微前端可以通过单仓库和多仓库结构来实现。'
- en: Before you pick between a monorepo or polyrepo structure, you must also consider
    the drawbacks of polyrepos. These are described in the next section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在你选择单仓库或多仓库结构之前，你还必须考虑多仓库的缺点。这些缺点将在下一节中描述。
- en: Disadvantages of polyrepos
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多仓库的缺点
- en: 'Some common disadvantages of polyrepos are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 多仓库的一些常见缺点如下：
- en: '**Difficulties in code sharing**: First, because code resides in isolation,
    it is harder to share code between applications. This can result in different
    implementations for the same problem or duplicate code in various projects. Teams
    will often create their own solution instead of contributing to a library that
    solves shared problems.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码共享的困难**：首先，因为代码是独立存放的，所以应用程序之间共享代码变得更加困难。这可能导致对同一问题的不同实现或在不同项目中重复代码。团队通常会创建自己的解决方案，而不是为解决共享问题的库做出贡献。'
- en: '**Boundaries between projects and libraries**: When you depend on a library
    that resides in another repository, and you run into a bug, it will be more time-consuming
    to fix the issue. Often, you need to wait for other teams to fix the bug in the
    library and deploy a new version before you can continue.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目和库之间的边界**：当你依赖另一个仓库中存放的库，并且遇到一个错误时，修复问题将更加耗时。通常，你需要等待其他团队修复库中的错误并部署新版本，你才能继续。'
- en: '**Challenges when testing multiple repositories**: Testing applications can
    become more challenging. Predominantly when applications consist of different
    modules that reside in different repositories, testing the entire system can be
    difficult.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试多个仓库时的挑战**：测试应用程序可能会变得更加具有挑战性。主要是在应用程序由位于不同仓库的不同模块组成时，测试整个系统可能会很困难。'
- en: '**Difficulties in creating CI/CD pipelines and deployments**: Creating CI/CD
    pipelines and deployments of the whole system might become more challenging as
    you need multiple repositories to complete the tasks.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建 CI/CD 管道和部署的困难**：随着你需要多个仓库来完成任务，创建整个系统的 CI/CD 管道和部署可能会变得更加具有挑战性。'
- en: '**Dependency conflicts**: Lastly, you can run into dependency conflicts. Different
    applications need to work together in production and can depend on similar dependencies.
    You can encounter compatibility issues when these applications use different versions
    of the set dependency.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖冲突**：最后，你可能会遇到依赖冲突。不同的应用程序需要在生产环境中协同工作，并且可能依赖于相似的依赖项。当这些应用程序使用不同版本的依赖项时，可能会遇到兼容性问题。'
- en: In this section, you learned about the advantages and disadvantages of storing
    your code in a monorepo or polyrepo. Next, you will learn about different architectural
    patterns that are commonly used with Angular applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了将代码存储在单仓库或聚合仓库中的优缺点。接下来，你将了解与Angular应用程序一起使用的不同架构模式。
- en: Architectural patterns for Angular applications
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular应用的架构模式
- en: Architectural patterns focus on how you structure your code and provide rules
    for abstracting business logic away from specific implementations. Architectural
    patterns are an extensive topic and there are entire books dedicated to it; so,
    it will be impossible to cover everything in this section. Still, we will briefly
    cover some of the most common architectural patterns that are used with Angular
    and Nx. In [*Chapter 5*](B21625_05.xhtml#_idTextAnchor083), we will dive into
    design patterns while focusing on code implementations instead of providing a
    high-level view of the system.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 架构模式关注于如何结构化你的代码，并提供将业务逻辑从特定实现中抽象出来的规则。架构模式是一个广泛的话题，甚至有整本书专门讨论它；因此，在这个部分中不可能涵盖所有内容。尽管如此，我们仍将简要介绍一些与Angular和Nx一起使用的最常见架构模式。在[*第5章*](B21625_05.xhtml#_idTextAnchor083)中，我们将深入探讨设计模式，同时关注代码实现而不是提供系统的概述。
- en: Now, let’s dive into some architectural patterns and learn what they try to
    achieve, how they try to achieve it, and what their advantages and disadvantages
    are.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨一些架构模式，了解它们试图实现什么，如何实现，以及它们的优缺点。
- en: Common architectural patterns in Angular applications
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular应用中的常见架构模式
- en: Most architectural patterns try to accomplish the same at their core, only with
    little nuances and different terminologies. Regarding architectural patterns for
    Angular applications, they try to separate domain and business logic from implementations
    and the view. Doing so gives you a loosely coupled system that is easy to test,
    change, and expand without creating dependencies in the wrong places. In this
    section, we will cover the **Model-View-Controller** (**MVC**), hexagonal architecture,
    and layered architecture. These three patterns are some of the most commonly used
    architectural patterns for Angular applications. Other noteworthy patterns are
    the **Model-View View-Model** (**MVVM**), union architecture, and clean architecture.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数架构模式在核心上试图实现相同的目标，只是有一些细微差别和不同的术语。关于Angular应用的架构模式，它们试图将领域和业务逻辑与实现和视图分离。这样做可以使系统松散耦合，易于测试、更改和扩展，而不会在错误的位置创建依赖项。在本节中，我们将介绍**模型-视图-控制器**（**MVC**）、六边形架构和分层架构。这三种模式是Angular应用中最常用的架构模式之一。其他值得注意的模式包括**模型-视图-视图模型**（**MVVM**）、联合架构和整洁架构。
- en: Without further ado, let’s learn about the MVC pattern and how it can be used
    within Angular applications.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们来了解MVC模式以及如何在Angular应用中使用它。
- en: MVC in Angular applications
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Angular应用中的MVC模式
- en: '**MVC** is one of the most commonly used architectural patterns in the world
    of software development. The pattern was first used in the back-end but is now
    also used for front-end applications, or at least something resembling the MVC
    pattern. The MVC pattern is often used for Angular applications because it fits
    well with the tools provided by the framework. As the name implies, MVC consists
    of three parts – the **model**, the **view**, and the **controller**:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVC**是软件开发领域中应用最广泛的架构模式之一。该模式最初用于后端，但现在也用于前端应用程序，或者至少是类似于MVC模式的应用程序。MVC模式常用于Angular应用程序，因为它与框架提供的工具很好地匹配。正如其名称所暗示的，MVC由三个部分组成——**模型**、**视图**和**控制器**：'
- en: The model declares the data models and handles business and data-related logic.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型声明数据模型并处理业务和数据相关的逻辑。
- en: The view displays the current state of the model to the user.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图向用户显示模型的当前状态。
- en: The controller acts as a bridge between the view and the model. The controller
    passes the user input to the model so that the model can perform actions and update
    accordingly, after which the controller returns the updated values to the view.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器充当视图和模型之间的桥梁。控制器将用户输入传递给模型，以便模型可以执行操作并相应地更新，之后控制器将更新的值返回给视图。
- en: If we translate this pattern into an Angular application, the model would be
    a service handling the data and data models. The view would be the HTML template.
    Finally, the controller would be the TypeScript file behind the HTML file, commonly
    named the component class. A better implementation is considering the component
    class as part of the view and having an extra facade service (an additional abstraction
    layer creating a simple interface and communication layer between the view and
    business or state-related logic of your application; we will discuss the facade
    pattern in more detail in [*Chapter 5*](B21625_05.xhtml#_idTextAnchor083)) between
    the model service and the view acting as the controller.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这种模式转换为Angular应用，模型将是一个处理数据和数据模型的服务。视图将是HTML模板。最后，控制器将是HTML文件背后的TypeScript文件，通常称为组件类。更好的实现是将组件类视为视图的一部分，并添加一个额外的外观服务（一个额外的抽象层，在视图和业务或状态相关的逻辑之间创建一个简单的接口和通信层；我们将在[*第5章*](B21625_05.xhtml#_idTextAnchor083)中更详细地讨论外观模式），在模型服务和视图之间充当控制器。
- en: 'If you keep true to the MVC architecture’s original implementation, the model
    directly gives the updated values to the view. To achieve this, in *Figure 1**.2*,
    we would eliminate *steps 4* and *5* and would then go to the view instead of
    the controller. In Angular, this is sort of the case when using the component
    class as a controller, and it results in a tight coupling between the business
    logic and the component classes. Because of that, I prefer to add a separate facade
    service that acts as a controller to fully separate the component classes from
    the business and state layers of my application. By separating the components
    from the state and business logic, you end up with a loose coupling, making it
    easier to change implementations throughout your application:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你坚持MVC架构的原始实现，模型将直接将更新的值提供给视图。为了实现这一点，在*图1.2*中，我们会消除*步骤4*和*步骤5*，然后直接跳转到视图而不是控制器。在Angular中，当使用组件类作为控制器时，这种情况有点类似，这会导致业务逻辑和组件类之间的紧密耦合。正因为如此，我更喜欢添加一个单独的外观服务，充当控制器，以完全将组件类与我的应用程序的业务和状态层分离。通过将组件从状态和业务逻辑中分离出来，你最终得到的是松散耦合，这使得在整个应用程序中更改实现变得更加容易：
- en: '![Figure 1.2: MVC pattern](img/B21625_01_2.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2：MVC模式](img/B21625_01_2.jpg)'
- en: 'Figure 1.2: MVC pattern'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：MVC模式
- en: 'Now that you know what the MVC pattern entails and how you can implement it
    within your Angular applications, let’s learn about the next common architectural
    pattern: the Hexagonal architecture.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了MVC模式的内容以及如何在你的Angular应用中实现它，让我们来学习下一个常见的架构模式：六边形架构。
- en: The hexagonal architecture pattern in Angular applications
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Angular应用中的六边形架构模式
- en: Hexagonal architecture is relatively new compared to MVC and some other architectural
    patterns, such as layered architecture, MVVC, and MVP. The hexagonal architecture
    was introduced in 2005, and people have only started implementing it in Angular
    applications in the last couple of years. It gained popularity because **domain-driven
    development** (**DDD**) became a hot topic, and hexagonal architecture is very
    well suited to combine with DDD. The main principle of hexagonal architecture
    is to separate the core application logic away from the UI and data implementation
    through ports and adapters. Because of that, the architecture is also commonly
    referred to as the *ports and adapter architecture*. But I hear you thinking,
    what are ports and adapters?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与MVC和其他一些架构模式，如分层架构、MVVC和MVP相比，六边形架构相对较新。六边形架构是在2005年提出的，而人们直到最近几年才开始在Angular应用中实施它。它之所以受到欢迎，是因为**领域驱动开发**（**DDD**）成为了一个热门话题，六边形架构非常适合与DDD结合使用。六边形架构的主要原则是通过端口和适配器将核心应用程序逻辑与UI和数据实现分离。正因为如此，这种架构也通常被称为*端口和适配器架构*。但是，我听到你在想，端口和适配器是什么？
- en: 'In simple terms, **ports** are interfaces (or abstract classes) that separate
    your core logic from the UI and code implementations. These interfaces dictate
    how the UI and code implementations can communicate with your application core.
    The **adapters** are the UI and code implementations that connect with your application
    core through the ports. In hexagonal architecture, ports and adaptors come in
    two types, UI and data-related ports and adapters – in other terms, primary and
    secondary adapters and ports. This concept is illustrated in *Figure 1**.3*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**端口**是接口（或抽象类），它们将您的核心逻辑与UI和代码实现分开。这些接口规定了UI和代码实现如何与您的应用程序核心通信。**适配器**是通过端口连接到您的应用程序核心的UI和代码实现。在六边形架构中，端口和适配器有两种类型，UI和数据相关端口和适配器——换句话说，主要和次要适配器和端口。这一概念在
    *图1**.3* 中得到了说明：
- en: '![Figure 1.3: Hexagonal architecture pattern](img/B21625_01_3.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3：六边形架构模式](img/B21625_01_3.jpg)'
- en: 'Figure 1.3: Hexagonal architecture pattern'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：六边形架构模式
- en: When implementing hexagonal architecture, you will have a set of ports and adapters
    for each domain within your application. I like to use a facade service between
    the port interfaces and adapters for more abstraction between the UI, implementations,
    and application core. When using a facade service, the facade can be considered
    as the port itself. Just make sure the facade implements an interface so that
    there is a fixed set of rules for communication with the core and adapters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现六边形架构时，您将为应用程序中的每个领域都有一组端口和适配器。我喜欢在端口接口和适配器之间使用外观服务，以在UI、实现和应用程序核心之间提供更多抽象。当使用外观服务时，外观可以被视为端口本身。只需确保外观实现了一个接口，这样就可以为与核心和适配器的通信定义一组固定的规则。
- en: Because ports define a fixed set of rules for communicating with your application
    core, you can easily change implementations when business requirements change.
    You can swap UI components without touching your business logic or data implementations,
    and you can change how you persist or fetch your data without touching your views
    or application core. The only thing you need to do is ensure your new implementation
    can connect to the same interface your ports are using to connect everything.
    This approach offers excellent flexibility and a loosely coupled system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因为端口定义了与您的应用程序核心通信的固定规则集，所以当业务需求发生变化时，您可以轻松地更改实现。您可以在不触及业务逻辑或数据实现的情况下交换UI组件，并且可以在不触及视图或应用程序核心的情况下更改数据持久化或检索方式。您需要做的唯一事情是确保您的新实现可以连接到端口使用的相同接口，以便连接一切。这种方法提供了出色的灵活性和松散耦合的系统。
- en: 'To clarify things, I want to go over *Figure 1**.3* and translate it into an
    Angular application. We will go from left to right. On the far left, we have the
    primary adapters. Everything the user faces, or triggers, is considered a primary
    adapter: components, directives, resolvers, guards, and event listeners. One step
    to the right, we will find the primary ports. These regular TypeScript interfaces
    (or facade services) dictate how the UI layer communicates with the application
    core. Our application core is in the middle, where we access state management
    and define business and application logic in Angular services. On the right of
    the application core, we have our secondary ports. These ports dictate how the
    application code communicates with HTTP services, state management, in-memory
    persistence, event dispatchers, and other data or API-related logic. Like the
    primary ports, the secondary ports are regular TypeScript interfaces (or facade
    services). On the far right, we have our secondary adapters. The secondary adapters
    implement our HTTP services, local storage persistence, state management, and
    event dispatchers.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清问题，我想回顾一下 *图1**.3* 并将其翻译成Angular应用。我们将从左到右进行。在最左边，我们有主要适配器。用户面对的或触发的所有内容都被视为主要适配器：组件、指令、解析器、守卫和事件监听器。向右一步，我们将找到主要端口。这些常规TypeScript接口（或外观服务）规定了UI层如何与应用程序核心通信。我们的应用程序核心位于中间，在那里我们访问状态管理并在Angular服务中定义业务和应用程序逻辑。在应用程序核心的右侧，我们有我们的次要端口。这些端口规定了应用程序代码如何与HTTP服务、状态管理、内存持久化、事件调度器和其他数据或API相关逻辑通信。与主要端口一样，次要端口也是常规TypeScript接口（或外观服务）。在最右边，我们有我们的次要适配器。次要适配器实现了我们的HTTP服务、本地存储持久化、状态管理和事件调度器。
- en: 'Now that you know what hexagonal architecture is and how you can implement
    it within your Angular applications, let’s take a look at the third and final
    architectural pattern we will discuss: layered architecture.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了六边形架构是什么以及你如何在Angular应用中实现它，让我们来看看我们将讨论的第三种和最后一种架构模式：分层架构。
- en: The layered architecture pattern in Angular applications
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Angular应用中的分层架构模式
- en: 'As the name implies, the layered architecture pattern uses different layers
    to separate concerns. For each application section, you create a layer in the
    architecture that sits on top of another layer. When you implement the layered
    architecture pattern in your Angular applications, you should have at least three
    (main) layers: the core layer, the abstraction layer, and the presentation layer.
    Within these top-level layers, you can have additional sub-layers or sibling elements.
    If your application architecture needs more layers, you can add them as needed.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，分层架构模式使用不同的层来分离关注点。对于应用的每个部分，你应在架构中创建一个层，该层位于另一个层之上。当你将分层架构模式应用于你的Angular应用时，你应该至少有三个（主要）层：核心层、抽象层和表示层。在这些顶级层中，你可以有额外的子层或同级元素。如果你的应用架构需要更多层，你可以根据需要添加。
- en: 'The most important thing with layered architecture is that each layer can only
    communicate with the layer above and below itself; the rest of the layers in the
    chain are off limits. Another essential feat is that events and actions flow upwards,
    and data flows downwards. The user triggers an event or performs an action in
    the presentation layer. This layer notifies the abstraction layer of the action
    and the corresponding changes. The abstraction layer sends these actions and changes
    to the core layer, where the business logic is performed and the data changes
    persist. When the core layer has performed the application logic and persisted
    the changes, the data will flow back from the core layer through the abstraction
    layer in the presentation layer, where the view is updated for the user:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构最重要的地方是每个层只能与自身上下层的层通信；链中的其余层都是禁止的。另一个基本特点是事件和动作向上流动，数据向下流动。用户在表示层触发事件或执行操作。该层通知抽象层操作和相应的变化。抽象层将这些动作和变化发送到核心层，在那里执行业务逻辑并持久化数据变化。当核心层执行了应用逻辑并持久化了变化后，数据将从核心层通过抽象层流向表示层，在那里更新用户视图：
- en: '![Figure 1.4: Layered architecture pattern](img/B21625_01_4.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4：分层架构模式](img/B21625_01_4.jpg)'
- en: 'Figure 1.4: Layered architecture pattern'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：分层架构模式
- en: Throughout this book, we will use a layered architecture resembling what’s shown
    in *Figure 1**.4*, with the presentation layer containing dumb, wrapper, and smart
    components. Dumb components only have component inputs to receive data and outputs
    to alert the parent components something has changed. Wrapper components are also
    dumb, but they are used to group multiple components and provide a reusable layout
    or animation. Even though a wrapper container can wrap around dumb components,
    they are the same for the flow of data and separation of dependencies, which is
    why they are placed next to each other in the architecture design. On top of the
    dumb components, we have smart components. These components are, generally speaking,
    specific business use cases or pages, and they inject facade services and implement
    component logic and state.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用类似于*图1**.4*所示的分层架构，其中表示层包含愚昧的、包装的和智能的组件。愚昧的组件只有组件输入来接收数据，以及输出以通知父组件有变化。包装组件也是愚昧的，但它们用于组合多个组件并提供可重用的布局或动画。尽管包装容器可以围绕愚昧的组件，但在数据流和依赖分离方面它们是相同的，这就是为什么它们在架构设计中并排放置。在愚昧的组件之上，我们有智能组件。这些组件通常是指特定的业务用例或页面，它们注入门面服务并实现组件逻辑和状态。
- en: The next main layer in our architecture is the abstraction layer, where we have
    facade services. These facade services are regular Angular services that implement
    the facade design pattern. These facade services provide additional abstraction
    and are used as a bridge between our smart components and the core layer of the
    application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们架构中的下一主要层是抽象层，其中包含门面服务。这些门面服务是常规的Angular服务，实现了门面设计模式。这些门面服务提供了额外的抽象，并作为我们智能组件和应用核心层之间的桥梁。
- en: Our last major layer is the core layer, where the global state management, business
    and application logic, and HTTP services reside. Our HTTP services layer lies
    on top of the state management and business logic layers. We have separate services
    that do nothing but fetch data and pass it to our other core layers; the lower
    core layers never fetch data directly, so we have an additional abstraction layer
    and have better separation of concerns.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个大层是核心层，其中包含全局状态管理、业务和应用逻辑，以及HTTP服务。我们的HTTP服务层位于状态管理和业务逻辑层之上。我们有一些独立的服务，它们只做一件事，那就是获取数据并将其传递给我们的其他核心层；较低的核心层永远不会直接获取数据，因此我们有一个额外的抽象层，并且有更好的关注点分离。
- en: Now that you know about the layered, hexagonal, and MVC architectural patterns,
    let’s move on and briefly learn about the advantages and disadvantages of each
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了分层、六边形和MVC架构模式，让我们继续，简要了解每种模式的优缺点。
- en: Comparing the architectural patterns
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较架构模式
- en: All three patterns we discussed in the *Common architectural patterns in Angular
    applications* section separate the business logic from the implementations and
    presentation code. They all provide abstraction layers but have different approaches
    to creating these layers. First, the MVC pattern might seem the simplest to implement,
    but you can have too many dependencies and implementations in your component classes
    if you don’t add facade services, especially if you let the model part of MVC
    directly communicate with the view. Not only will this tightly couple your view
    with your business logic, but it can also trigger extensive DOM updates. Changing
    implementations can become hard, and unit testing needs a lot of mocking.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论的*Angular应用中的常见架构模式*部分中，所有三种模式都将业务逻辑与实现和展示代码分离。它们都提供了抽象层，但在创建这些层的方法上有所不同。首先，MVC模式可能看起来最容易实现，但如果你不添加外观服务，你的组件类中可能会有太多的依赖和实现；特别是如果你让MVC的模型部分直接与视图通信。这不仅会紧密耦合你的视图与你的业务逻辑，还可能触发大量的DOM更新。更改实现可能会变得困难，单元测试也需要大量的模拟。
- en: Next, we have hexagonal architecture. I like this architecture, but it introduces
    a lot of boilerplate code and can feel complex to implement, making it not the
    right fit if you have a lot of junior developers on your team. Nonetheless, the
    significant advantage of hexagonal architecture is that you can easily change
    implementations once everything has been set up. Unit testing the code also becomes
    straightforward because everything is separated into ports and adapters.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有六边形架构。我喜欢这种架构，但它引入了大量的样板代码，并且可能感觉实现起来很复杂，如果你团队中有许多初级开发者，这可能不是合适的选择。尽管如此，六边形架构的一个显著优点是，一旦一切设置完成，你可以轻松地更改实现。代码的单元测试也因为一切都被分离到端口和适配器而变得简单直接。
- en: 'Lastly, we have the layered architecture. This one offers the best of both
    the MVC and hexagonal architectures: we have clear divisions and good abstraction
    for our core, implementations, and view. Adding more layers to your architecture
    is simple, and the rules are easy to understand, making it a good solution for
    teams with developers of different experience levels. Because of good separation
    and abstractions, you can simply change implementations, and unit testing remains
    easy.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有分层架构。这个架构结合了MVC和六边形架构的优点：我们为我们的核心、实现和视图提供了清晰的划分和良好的抽象。向你的架构中添加更多层很简单，规则也很容易理解，这使得它成为不同经验水平开发团队的优秀解决方案。由于良好的分离和抽象，你可以简单地更改实现，单元测试仍然很容易。
- en: You now know what the MVC, hexagonal, and layered architectures are, and you
    learned about the advantages and disadvantages of each implementation. In the
    next section, you’ll briefly learn what design patterns are and how they differ
    from architectural patterns.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道了MVC、六边形和分层架构是什么，你也了解了每种实现的优缺点。在下一节中，你将简要了解什么是设计模式以及它们与架构模式的不同。
- en: Design patterns used within Angular applications
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Angular应用中使用的设计模式
- en: While architectural patterns focus on a high-level overview of how we segment
    and abstract our code, design patterns focus on how we implement things within
    our code. When developing Angular applications, we are already working with some
    design patterns out of the box. This is because Angular is a strongly opinionated
    framework with strong **object-orientated programming** (**OOP**) principles at
    its core. Some design patterns we use by default within Angular applications are
    the observable, dependency injection, decorator, component, and singleton patterns.
    These and other design patterns, such as the factory and inheritance patterns,
    are embedded in how the Angular framework works and should be used throughout
    your application when you use the framework correctly. Because these patterns
    are somewhat concealed within the tools and ways of working of the Angular framework,
    you might be using them without actually understanding how they work at their
    core. Besides these design patterns embedded within the Angular framework, you
    can improve your code by introducing even more design patterns. Some work very
    well in combination with Angular, such as the facade pattern.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然架构模式关注于我们对代码进行分割和抽象的高层次概述，但设计模式关注于我们在代码中如何实现事物。在开发 Angular 应用程序时，我们已经在使用一些内置的设计模式。这是因为
    Angular 是一个具有强烈意见的框架，其核心具有强大的**面向对象编程**（**OOP**）原则。Angular 应用程序中默认使用的某些设计模式包括观察者模式、依赖注入、装饰器、组件和单例模式。这些以及其他设计模式，如工厂和继承模式，都嵌入到
    Angular 框架的工作方式中，并且在使用框架时应该在整个应用程序中使用。因为这些模式在 Angular 框架的工具和工作方式中有所隐藏，你可能在使用它们时实际上并不真正理解它们的核心工作原理。除了嵌入在
    Angular 框架中的这些设计模式之外，你还可以通过引入更多的设计模式来改进你的代码。其中一些与 Angular 结合得非常好，例如外观模式。
- en: As with architectural patterns, design patterns ensure that you adhere to specific
    rules when implementing your code, resulting in code that is easy to adjust and
    extend. They prevent you from making the wrong dependencies throughout your code
    and provide a structured and battle-tested way to approach common problems with
    software engineering. For now, I wanted to briefly explain design patterns and
    list some design patterns the Angular framework uses by default. In [*Chapter
    5*](B21625_05.xhtml#_idTextAnchor083), you will learn about design patterns in
    more detail. You will learn about different patterns, when to use them, and how
    to implement them correctly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与架构模式一样，设计模式确保你在实现代码时遵循特定的规则，从而产生易于调整和扩展的代码。它们防止你在代码中建立错误的依赖关系，并提供了一种结构化和经过实战检验的方式来解决软件工程中的常见问题。目前，我想简要地解释设计模式，并列出
    Angular 框架默认使用的一些设计模式。在[*第五章*](B21625_05.xhtml#_idTextAnchor083)中，你将更详细地了解设计模式。你将了解不同的模式、何时使用它们以及如何正确实现它们。
- en: You now know what design patterns are and how they differ from architectural
    patterns. You’ve learned about some patterns that are used within Angular by design
    and that you can add more patterns to improve your code implementations throughout
    your code base. The next topic we will discuss is Nx, which makes structuring,
    creating, maintaining, and testing large Angular monorepos easy.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经知道了设计模式是什么，以及它们与架构模式的不同之处。你已经了解了一些在 Angular 中通过设计使用的设计模式，并且你可以添加更多模式来改进你的代码实现。接下来我们将讨论的是
    Nx，它使得结构化、创建、维护和测试大型 Angular 单一代码库变得容易。
- en: What is Nx and why should you use it?
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Nx 以及为什么你应该使用它？
- en: In this section, you will learn what Nx is and why it’s such a fantastic tool
    for developing Angular applications at scale. **Nx** is rapidly becoming the go-to
    tool for developing large monorepo front-end applications. So, what exactly is
    Nx and why should you use it?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解 Nx 是什么以及为什么它是开发大规模 Angular 应用的绝佳工具。**Nx** 正在迅速成为开发大型单一代码库前端应用的首选工具。那么，Nx
    究竟是什么，为什么你应该使用它？
- en: 'Nx is a tool that helps you to speed up, streamline, and standardize your development,
    testing, build, and deployment process. The Nx tooling offers various features
    and integrations you can utilize during every stage of development. Nx was created
    so that you can adopt it incrementally by picking and choosing what you want to
    use or add to your current environment. At its core, Nx helps you with the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Nx 是一个帮助你加速、简化和标准化你的开发、测试、构建和部署过程的工具。Nx 工具提供了一系列你可以在开发每个阶段利用的功能和集成。Nx 的创建是为了让你可以通过选择和添加你想要使用或添加到当前环境中的内容来逐步采用它。在其核心，Nx
    帮助你完成以下任务：
- en: Speeding up the build and test times of your applications.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加快您应用程序的构建和测试时间。
- en: Managing dependencies and running tasks within monorepo projects.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单一代码库项目中管理依赖关系和运行任务。
- en: Swiftly scaffolding new code snippets, applications, and libraries without needing
    to worry about configuring build tools.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速搭建新的代码片段、应用程序和库，无需担心配置构建工具。
- en: Integrating new tools into the projects of your monorepo workspace.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新工具集成到单一代码库工作空间的项目中。
- en: Ensuring uniformity and consistency within the code of different projects.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保不同项目的代码内部的一致性和统一性。
- en: Updating applications and tools through automated code migration.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过自动代码迁移来更新应用程序和工具。
- en: In the preceding tasks, multiple tools, features, and options, such as a CLI,
    generators, and plugins, help you achieve your goals and streamline processes.
    The tools and features Nx has to offer are divided into different modules in their
    ecosystem.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的任务中，多个工具、功能和选项，如命令行界面（CLI）、生成器和插件，帮助您实现目标并简化流程。Nx 提供的工具和功能在其生态系统中分为不同的模块。
- en: 'To start, you have the Nx **command-line interface** (**CLI**). Similar to
    the Angular CLI, it lets you run commands for tasks such as creating workspaces,
    scaffolding projects, testing projects, or serving and building. Next, the **Nx
    package** contains all the fundamental technologies Nx offers: task running, workspace
    analysis, build caching, scaffolding, and automated code migrations. Then, there
    are plugins, which are NPM packages that extend the fundamentals of Nx and can
    be created by the Nx community for various purposes, such as generating projects,
    integrating tools, and adding or updating libraries. Another element of Nx is
    its **Devkit**, which can be used to build plugins to extend the Nx tooling to
    your specific needs. Nx also has something called **Nx cloud**, which speeds up
    your CI with remote caching and distributed task executions, but this is outside
    the scope of this book. Lastly, we have the **Nx console**, an extension for VS
    Code, IntelliJ, and VIM, making it much easier to manage your Nx workspace and
    run Nx commands.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您有 Nx 的**命令行界面**（**CLI**）。类似于 Angular CLI，它允许您运行创建工作空间、搭建项目、测试项目或提供和构建等任务的命令。接下来，**Nx
    包**包含了 Nx 提供的所有基本技术：任务运行、工作空间分析、构建缓存、搭建和自动代码迁移。然后，还有插件，这些是扩展 Nx 基础的 NPM 包，可以由
    Nx 社区为各种目的创建，例如生成项目、集成工具、添加或更新库。Nx 的另一个元素是其**Devkit**，它可以用来构建插件，以扩展 Nx 工具以满足您的特定需求。Nx
    还有一种称为**Nx 云**的东西，它通过远程缓存和分布式任务执行加快 CI，但这超出了本书的范围。最后，我们有**Nx 控制台**，它是 VS Code、IntelliJ
    和 VIM 的扩展，使得管理您的 Nx 工作空间和运行 Nx 命令变得更加容易。
- en: Now that you know what Nx does at its core, let’s examine it in more detail
    and see how it can help you build scalable monorepos for your Angular applications.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经了解了 Nx 的核心功能，让我们更详细地考察它，看看它如何帮助您为 Angular 应用程序构建可扩展的单一代码库。
- en: How Nx helps you build Angular monorepos that scale
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nx 如何帮助您构建可扩展的 Angular 单一代码库。
- en: 'Now that you understand what Nx is at its core, let’s dive deeper and explore
    how it helps you build, test, and standardize your Angular applications. We will
    begin with one of the main features Nx offers: speeding up tasks such as building,
    serving, and testing.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了 Nx 的核心功能，让我们深入探讨它，看看它是如何帮助您构建、测试和标准化您的 Angular 应用程序的。我们将从 Nx 提供的主要功能之一开始：加快构建、服务和测试等任务的执行速度。
- en: Improving build times with computational caching and incremental builds
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过计算缓存和增量构建来提高构建时间。
- en: Typically, when we run tasks with the Angular CLI, such as `ng build` or `ng
    serve`, our entire application and all the libraries it depends on need to be
    compiled to complete the build or serve your application. This can become time-consuming
    as the application grows. The result is slow CI builds and developers waiting
    for the application to compile each time they want to start or test it. Nx helps
    to resolve these issues with incremental builds and computational caching.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们使用 Angular CLI 运行任务，如 `ng build` 或 `ng serve` 时，我们的整个应用程序以及它所依赖的所有库都需要被编译以完成构建或提供服务。随着应用程序的增长，这可能会变得耗时。结果是
    CI 构建缓慢，开发者在每次想要启动或测试应用程序时都需要等待应用程序编译。Nx 通过增量构建和计算缓存帮助解决这些问题。
- en: With computational caching, Nx will check if anything has changed since the
    last time you ran a command. If nothing has changed or the build computation is
    equal to a previous cached run, Nx won’t rerun the command and instead take the
    results from its caching system. First, it will look at the local caching, and
    if you set up remote caching with Nx cloud, it will also check if it can find
    the same computational hash in the remote cache. If Nx cannot find the same computational
    hash, it will run the command and store the hash of the result in the Nx cache.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算缓存，Nx 将检查自上次您运行命令以来是否有任何更改。如果没有更改或构建计算等于之前的缓存运行，Nx 不会重新运行命令，而是从其缓存系统中获取结果。首先，它将查看本地缓存，如果您设置了
    Nx 云的远程缓存，它也会检查是否可以在远程缓存中找到相同的计算哈希。如果 Nx 找不到相同的计算哈希，它将运行命令并将结果的哈希存储在 Nx 缓存中。
- en: Besides computational caching, Nx helps speed up our build and compile times
    with incremental builds. When using incremental builds, we only build projects
    that have been changed since your last build. In a regular scenario, we build
    the application and all the libraries the application uses. As the application
    grows and depends on many libraries, it can become time-consuming and costly to
    rebuild everything each time you build the application. To use incremental builds,
    your libraries must be buildable so that Nx can cache the libraries and only build
    them if they changed since your last build. When you’re building smaller applications,
    you might not want buildable libraries with computational caching because making
    a library buildable has some overhead as well. When you create a library in your
    Nx workspace, you can choose if you want it to be standard, buildable, or publishable.
    We will dive deeper into this topic in the *Structuring Angular applications and*
    *libraries* section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了计算缓存外，Nx 通过增量构建帮助加快我们的构建和编译时间。在使用增量构建时，我们只构建自上次构建以来已更改的项目。在常规场景中，我们会构建应用程序及其所使用的所有库。随着应用程序的增长和依赖多个库，每次构建应用程序时重建所有内容都可能变得耗时且成本高昂。要使用增量构建，您的库必须是可构建的，这样
    Nx 才能缓存库，并且只有在它们自上次构建以来已更改时才构建它们。当您构建较小的应用程序时，您可能不希望使用具有计算缓存的库，因为使库可构建也有一些开销。当您在
    Nx 工作区中创建库时，您可以选择是否希望它为标准、可构建或可发布的。我们将在 *结构化 Angular 应用程序和库* 部分更深入地探讨这个话题。
- en: Running tasks effectively in a monorepo with Nx
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Nx 在 monorepo 中有效地运行任务
- en: Running tasks, such as `ng build`, `ng test`, and `ng lint`, with the Angular
    CLI in a single Angular project is straightforward. But things become more complicated
    when you have a monorepo with tens, hundreds, or even thousands of applications
    and libraries. In many scenarios, you want to run tasks simultaneously for multiple
    (or all) projects. Sometimes, you want to run specific tasks when something changes
    in a project, or you need to know if changes in a library have affected other
    projects and break them. If you perform these tasks by running commands one by
    one, this becomes unmanageable quickly, and building tools to watch and check
    for the affected projects becomes complicated. Luckily, Nx has everything we need
    to run tasks for multiple or affected projects, watch for changes, and react to
    them with commands.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个 Angular 项目中使用 Angular CLI 运行任务，如 `ng build`、`ng test` 和 `ng lint`，是直接的。但是，当您有一个包含数十、数百甚至数千个应用程序和库的
    monorepo 时，事情会变得更加复杂。在许多场景中，您可能希望同时运行多个（或所有）项目的任务。有时，当项目中的某些内容发生变化时，您想运行特定的任务，或者您需要知道库中的更改是否影响了其他项目并导致它们崩溃。如果您通过逐个运行命令来执行这些任务，这会很快变得难以管理，并且构建用于监视和检查受影响项目的工具也会变得复杂。幸运的是，Nx
    拥有我们运行多个或受影响项目任务、监视更改并对其做出响应所需的一切。
- en: When you use the Nx CLI, it is advised not to use the Angular CLI within the
    monorepo. We want Nx to do all its magic, and this is not possible if we start
    to generate things with the Angular CLI. Luckily, Nx has you covered!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 Nx CLI 时，建议不要在 monorepo 中使用 Angular CLI。我们希望 Nx 做所有它的魔法，如果我们开始使用 Angular
    CLI 生成东西，这是不可能的。幸运的是，Nx 已经为您准备好了！
- en: 'Let’s start with the basics – running commands for a single project using the
    Nx CLI. Running tasks for a single project is similar to running tasks with the
    Angular CLI. For example, if we want to run the tests for an application named
    **testApp**, we can run the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础知识开始——使用 Nx CLI 运行单个项目的命令。为单个项目运行任务与使用 Angular CLI 运行任务类似。例如，如果我们想为名为
    **testApp** 的应用程序运行测试，我们可以运行以下命令：
- en: '[PRE0]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we want to run tasks for multiple projects, we can use the `run-many` keyword
    combined with the `-p` flag to define the projects for which we want to run the
    tasks. If you omit the `-p` flag and only use the `run-many` keyword, the task
    will run for all projects. We can also add the `-t` flag to run multiple tasks
    at once. For example, if we want to build, lint, and test all projects, we can
    run the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想为多个项目运行任务，可以使用 `run-many` 关键字与 `-p` 标志结合来定义我们想要运行任务的那些项目。如果您省略 `-p` 标志并且仅使用
    `run-many` 关键字，则任务将在所有项目中运行。我们还可以添加 `-t` 标志以同时运行多个任务。例如，如果我们想构建、检查和测试所有项目，我们可以运行以下命令：
- en: '[PRE1]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let’s say we only want to build, lint, and test *testApp* and *testApp2*.
    For this, we can run the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们只想构建、检查和测试 *testApp* 和 *testApp2*。为此，我们可以运行以下命令：
- en: '[PRE2]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, running commands with the Nx CLI is simple, even if you need
    to do it for multiple or all projects within your monorepo. Even if you want to
    run several tasks simultaneously for a subset or all projects, you can do it quickly
    and with a single command.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用 Nx CLI 运行命令很简单，即使您需要在单一仓库中的多个或所有项目中执行此操作。即使您想为子集或所有项目同时运行多个任务，也可以快速且只需一个命令即可完成。
- en: 'Another helpful option is to watch for changes in specific projects and run
    scripts whenever changes occur in a watched project. For example, you can watch
    for changes in an application and echo the project name and the changed filename.
    This can be done for single projects, a subset of projects, or all projects, like
    running regular commands. Here’s an example of what this command will look like:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的选项是监视特定项目的更改，并在监视的项目发生更改时运行脚本。例如，您可以监视应用程序的更改并回显项目名称和更改的文件名。这可以针对单个项目、项目子集或所有项目进行，就像运行常规命令一样。以下是一个此命令将如何显示的示例：
- en: '[PRE3]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Lastly, we need something to detect the affected projects and run commands
    for them. When a monorepo grows, it becomes too time-consuming to run tests for
    all projects every time you change a library. Consider the following scenario.
    We have five applications and three libraries being used by those applications.
    Now, if we change the code of a library and all five projects use this library,
    our changes can affect and break the four other projects we aren’t working on
    ourselves. This can be a massive problem if we release an application or library
    to production without noticing we broke another application with our changes.
    When we make changes in a library, we need to know what projects in the monorepo
    are affected by those changes and run the appropriate tests to see if everything
    still works. For this scenario, Nx has *affected commands*. By running these commands,
    you can run tasks such as linting and testing for all projects affected by your
    changes. The following is an example of such a command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要某种机制来检测受影响的项目并为它们运行命令。当单一仓库增长时，每次更改库时运行所有项目的测试变得耗时。考虑以下场景。我们有五个应用程序和三个库被这些应用程序使用。现在，如果我们更改库的代码，并且所有五个项目都使用这个库，我们的更改可能会影响并破坏我们未亲自工作的其他四个项目。如果我们没有注意到我们更改破坏了另一个应用程序就发布了应用程序或库，这可能会成为一个巨大的问题。当我们对库进行更改时，我们需要知道单一仓库中哪些项目会受到这些更改的影响，并运行适当的测试以查看一切是否仍然正常工作。为此场景，Nx
    有 *affected commands*。通过运行这些命令，您可以运行受您更改影响的所有项目的任务，如检查和测试。以下是一个此类命令的示例：
- en: '[PRE4]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With that, you have basic knowledge of running tasks in an Nx monorepo. Next,
    let’s explore how Nx helps us keep the code and setup in our monorepo projects
    standardized and uniform.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，您就掌握了在 Nx 单一仓库中运行任务的基本知识。接下来，让我们探索 Nx 如何帮助我们保持单一仓库项目中代码和设置的标准化和统一。
- en: Ensuring uniformity and consistency within your Nx monorepo
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保Nx单一仓库中的统一性和一致性
- en: Another critical aspect of a scalable Angular monorepo is uniformity and consistency
    in the code of the different applications within the monorepo. When you have hundreds
    of projects in your monorepo, you don’t want different code conventions and implementations
    in each project. This would make it much harder for developers to start working
    on other projects within the monorepo, and it also makes it harder to find similar
    code or refactor code in bulk. When everyone uses the same conventions and code
    patterns, each developer can work on every project within the monorepo and make
    changes when needed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展的 Angular 单仓库的另一个关键方面是单仓库内不同应用程序的代码一致性和一致性。当你有数百个项目在你的单仓库中时，你不想每个项目都有不同的代码约定和实现。这将使开发者更难开始在其他项目中工作，并且也使得查找相似代码或批量重构代码变得更加困难。当每个人都使用相同的约定和代码模式时，每个开发者都可以在单仓库内的每个项目中工作，并在需要时进行更改。
- en: Nx helps us maintain uniformity with global linting rules that apply to all
    projects within the monorepo. You can set up these linting rules however you see
    fit and can even create custom linting rules. Besides global linting rules, you
    can also apply specific lint rules for individual projects.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Nx 通过为单仓库内的所有项目应用全局代码检查规则来帮助我们保持一致性。你可以根据自己的需求设置这些代码检查规则，甚至可以创建自定义的代码检查规则。除了全局代码检查规则之外，你还可以为单个项目应用特定的代码检查规则。
- en: Nx generators are another great way to enforce uniformity within your Nx monorepo.
    Generators are used to generate applications, libraries, components, and other
    code snippets. You can even use Nx generators to modify your code throughout the
    monorepo or set up and change configuration files. This can be very useful when
    you need to apply refactoring to multiple files of your monorepo.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Nx 生成器是强制 Nx 单仓库内一致性的另一种极好方式。生成器用于生成应用程序、库、组件和其他代码片段。你甚至可以使用 Nx 生成器修改单仓库中的代码或设置和更改配置文件。当你需要对你的单仓库中的多个文件应用重构时，这可以非常有用。
- en: Using generators ensures that things are created in the same manner by all developers
    working within the monorepo. Executing generators can be done with the terminal,
    though when using the Nx console, you get a nice user interface for executing
    them. You can also overwrite the built-in generators so that fewer options are
    revealed, and the default values are set. This reduces variation and makes the
    generators easier to use for less experienced developers. We will dive deeper
    into this topic when we create an Nx monorepo in the *Setting up a scalable Angular
    workspace* section. For now, it’s important to know that you must use generators
    whenever possible.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成器确保所有在单仓库内工作的开发者以相同的方式创建事物。可以通过终端执行生成器，尽管当使用 Nx 控制台时，你可以获得一个用于执行它们的良好用户界面。你还可以覆盖内置的生成器，以便显示更少的选项，并设置默认值。这减少了差异，使得生成器对经验较少的开发者更容易使用。当我们在
    *设置可扩展的 Angular 工作区* 部分创建 Nx 单仓库时，我们将更深入地探讨这个话题。现在，重要的是要知道，在可能的情况下，你必须使用生成器。
- en: The last thing I want to mention on uniformity is **Prettier**. Nx has built-in
    support for the code formatter Prettier. As with linting rules, formatting rules
    can be configured for the entire monorepo and individual projects within the monorepo.
    You can also run a command with the Nx CLI to detect unformatted lines of code.
    When you configure VS Code to auto-format on **Save**, Prettier will format your
    code whenever you save a file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想提到关于一致性的最后一个方面是 **Prettier**。Nx 内置了对代码格式化工具 Prettier 的支持。与代码检查规则一样，格式化规则可以配置为整个单仓库以及单仓库内的单个项目。你还可以使用
    Nx CLI 运行命令来检测未格式化的代码行。当你配置 VS Code 在 **保存** 时自动格式化，Prettier 将在保存文件时格式化你的代码。
- en: Now that you’ve learned how to manage monorepos with Nx, we will explore how
    you can update and manage dependencies in an Nx monorepo.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用 Nx 管理单仓库，我们将探讨如何在 Nx 单仓库中更新和管理依赖。
- en: Nx dependency management and code migrations
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Nx 依赖管理和代码迁移
- en: 'Managing dependencies in an Nx monorepo is easy since there is one `package.json`
    file for the entire monorepo (this is only the case for integrated monorepos,
    but we’ll cover this in more detail when we create our monorepo in the *Setting
    up a scalable Angular workspace* section) and most packages can be updated automatically,
    including configuration and code changes needed for that update. Running automated
    updates can be done by using the `nx migrate` command, like so:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Nx monorepo 中管理依赖项很容易，因为整个 monorepo 只有一个 `package.json` 文件（这只适用于集成 monorepo，但当我们创建
    *设置可扩展的 Angular 工作空间* 部分中的 monorepo 时，我们将更详细地介绍这一点）并且大多数包可以自动更新，包括更新所需的配置和代码更改。可以通过使用
    `nx migrate` 命令来运行自动化更新，如下所示：
- en: '[PRE5]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In general, you will update to the latest version of the Nx package and dependencies;
    in that case, you can use the following command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您将更新到 Nx 包的最新版本及其依赖项；在这种情况下，您可以使用以下命令：
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running the preceding command will update your `package.json` file and generate
    a `migrations.json` file containing all the migrations that Nx and its plugins
    need to run to update all packages successfully. To execute these migrations,
    you need to run the `migrate` command with an additional flag, like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的命令将更新您的 `package.json` 文件并生成一个 `migrations.json` 文件，其中包含 Nx 和其插件需要运行以成功更新所有包的所有迁移。要执行这些迁移，您需要运行带有额外标志的
    `migrate` 命令，如下所示：
- en: '[PRE7]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After running this command, your packages, configuration files, and code will
    be updated to use the latest versions of Nx and the plugins configured within
    the workspace. For packages that don’t have a plugin, you need to do the updates
    manually as you do with NPM packages. Packages with a plugin will do everything
    for you with Nx migrations. There are plugins for Angular, Jest, Cypress, and
    most other things you will use within the Nx monorepo.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您的包、配置文件和代码将更新为使用 Nx 和工作空间内配置的插件的最新版本。对于没有插件的包，您需要像处理 NPM 包一样手动进行更新。具有插件的包将使用
    Nx 迁移为您完成所有工作。Nx monorepo 中有 Angular、Jest、Cypress 以及您将使用的大多数其他插件的插件。
- en: 'Another cool feature for managing dependencies is that Nx lets you visualize
    dependencies on a graph. With this, you can see what projects depend on one another
    and zoom in on these nodes to better view the dependencies. This works for projects
    as well as tasks. If you have tasks that run multiple tasks in a chain, you can
    also visualize this task chain on a nice graph. The **Nx graph** is a valuable
    tool as visualization helps you better understand your monorepo’s structure. If
    you can no longer make sense of the dependencies in the graph, chances are that
    they won’t make sense in your code either. You can open the graph by running the
    following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于管理依赖项的酷特性是 Nx 允许您在图上可视化依赖项。通过这种方式，您可以查看哪些项目相互依赖，并放大这些节点以更好地查看依赖项。这也适用于项目和任务。如果您有运行多个任务的链式任务，您还可以在漂亮的图上可视化此任务链。**Nx
    图**是一个非常有价值的工具，因为可视化有助于您更好地理解您的 monorepo 结构。如果您无法理解图中的依赖项，那么它们在您的代码中可能也无法理解。您可以通过运行以下命令打开图：
- en: '[PRE8]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you want a graph of the affected projects, you can run the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看受影响的项目图，可以运行以下命令：
- en: '[PRE9]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Lastly, you can use tags to set up boundaries throughout your monorepo so that
    projects can only import what they’re supposed to import. If you try to import
    a library you aren’t supposed to, the code won’t compile, and an error will inform
    you that you aren’t allowed to use the library within your project. When we create
    our monorepo in the *Setting up a scalable Angular workspace* section, we’ll set
    up these boundaries as well.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用标签在您的 monorepo 中设置边界，以便项目只能导入它们应该导入的内容。如果您尝试导入不应使用的库，代码将无法编译，并将显示错误信息，告知您不允许在项目中使用该库。当我们创建
    *设置可扩展的 Angular 工作空间* 部分中的 monorepo 时，我们也将设置这些边界。
- en: As mentioned previously, Nx is a vast topic that offers us many tools for managing
    monorepos. As we progress through this book, we will learn more about Nx, but
    for now, you have a good idea of what Nx is and how it can help you manage Angular
    monorepos of any size. Now, we will move on to creating an Nx monorepo, including
    some Angular projects and libraries.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Nx 是一个庞大的主题，为我们提供了许多用于管理 monorepo 的工具。随着我们通过这本书的进展，我们将学习更多关于 Nx 的知识，但到目前为止，您已经对
    Nx 是什么以及它如何帮助您管理任何大小的 Angular monorepo 有了一个很好的了解。现在，我们将继续创建一个 Nx monorepo，包括一些
    Angular 项目和库。
- en: Setting up a scalable Angular workspace
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置可扩展的 Angular 工作空间
- en: In this final section, we will create an Nx monorepo, along with some placeholder
    Angular applications and libraries for demonstration purposes. We’ll start by
    adding some extensions in VS Code to make our developer experience more pleasant.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节最后，我们将创建一个 Nx monorepo，以及一些用于演示目的的占位符 Angular 应用程序和库。我们将首先在 VS Code 中添加一些扩展，以使我们的开发者体验更加愉快。
- en: 'Add the following extensions:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下扩展：
- en: 'Angular Essentials (version 16): Angular Essentials is comprised of eight different
    extensions that are useful for Angular development'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular Essentials（版本 16）：Angular Essentials 包含八个不同的扩展，这些扩展对 Angular 开发很有用
- en: Angular support
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 支持
- en: Nx console
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nx 控制台
- en: 'Once you’ve installed these extensions, you will probably need to reload VS
    Code for all of them to be applied, so restart your VS Code application. After
    this, you should see an Nx icon on the left-hand side of VS Code; this is the
    Nx console. When you have successfully installed the various VS Code extensions,
    you must globally install the `Nx` and `Cypress NPM` packages. To do so, you can
    run the following command in the terminal of your choice. I like to use the integrated
    VS Code terminal:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这些扩展后，你可能需要重新加载 VS Code 以应用它们，因此请重启您的 VS Code 应用程序。之后，您应该在 VS Code 左侧看到 Nx
    图标；这是 Nx 控制台。当您成功安装了各种 VS Code 扩展后，您必须全局安装 `Nx` 和 `Cypress NPM` 包。为此，您可以在您选择的终端中运行以下命令。我喜欢使用集成的
    VS Code 终端：
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once these NPM packages have been installed, we can create our Nx workspace.
    Find a folder where you want to create the Nx monorepo and open a terminal at
    this location. To create the Nx workspace, run the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这些 NPM 包后，我们可以创建我们的 Nx 工作区。找到您想创建 Nx monorepo 的文件夹，并在该位置打开终端。要创建 Nx 工作区，请运行以下命令：
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you run this command, you will be prompted with several questions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此命令时，您将收到几个问题：
- en: Where would you like to create your workspace? (`business-tools-monorepo`.)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您想在何处创建工作区？（`business-tools-monorepo`。）
- en: 'Which stack do you want to use? (Angular: Configures an Angular app with modern
    tooling.)'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您想使用哪个堆栈？（Angular：使用现代工具配置 Angular 应用程序。）
- en: 'Standalone project or integrated monorepo? (Integrated monorepo: Nx creates
    a monorepo that contains multiple projects.)'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 独立项目或集成 monorepo？（集成 monorepo：Nx 创建一个包含多个项目的 monorepo。）
- en: Application name (`Invoicing`).
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序名称（`Invoicing`）。
- en: Which bundler would you like to use? (`esbuild`.)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您想使用哪个打包器？（`esbuild`。）
- en: Default stylesheet format (`SASS(.scss)`).
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认样式表格式（`SASS(.scss)`）。
- en: Do you want to enable **server-side rendering** (**SSR**) and **static site
    generation** (**SSG**)? (No.)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您想启用 **服务器端渲染**（**SSR**）和 **静态站点生成**（**SSG**）吗？（否。）
- en: Test runner to use for **end-to-end** (**e2e**) tests (Cypress).
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于端到端测试的测试运行器（Cypress）。
- en: Set up CI with caching, distribution, and test deflaking (Skip).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置具有缓存、分发和测试去抖动的 CI（跳过）。
- en: Would you like remote caching to make your build faster? (Yes.)
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您想使用远程缓存以加快构建速度吗？（是。）
- en: Once you’ve answered these questions, the Nx monorepo will be created in a folder
    called `business-tools-monorepo`. We will dive into what Nx created for us in
    the *What did Nx create in our new workspace?* section, but first, I want to explain
    the different types of workspaces you can create with Nx.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 回答这些问题后，Nx monorepo 将在名为 `business-tools-monorepo` 的文件夹中创建。我们将在 *Nx 在我们的新工作区中创建了什么？*
    这一部分深入了解 Nx 为我们创建的内容，但首先，我想解释您可以使用 Nx 创建的不同类型的工作区。
- en: 'Nx workspaces come as standalone projects, package-based monorepos, and integrated
    monorepos:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Nx 工作区以独立项目、基于包的 monorepos 和集成 monorepos 的形式提供：
- en: Standalone projects are well suited for when you want to start with a single
    project but keep the door open for growing into a large monorepo. Nx is also useful
    for single projects as you can utilize their generators and automated updates
    through Nx migrations and executors.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立项目非常适合您想从一个单一项目开始但保持扩展到大型 monorepo 的可能性时。Nx 对单一项目也很有用，因为您可以使用它们的生成器和通过 Nx
    迁移和执行程序自动更新。
- en: Next, we have package-based monorepos. This solution is beneficial when you
    need to add a lot of exciting projects to an Nx workspace. With package-based
    repos, each project in the Nx workspace has its own dependencies. You will get
    the improved speed and task running from Nx, but Nx will stay out of your way
    for the rest.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们有基于包的 monorepos。当您需要向 Nx 工作区添加大量令人兴奋的项目时，此解决方案很有益。基于包的仓库中，Nx 工作区中的每个项目都有自己的依赖项。您将从
    Nx 获得改进的速度和任务运行，但 Nx 不会妨碍您。
- en: Lastly, there are integrated Nx monorepos. This is what we’ll be using and is
    the setup where you leverage all the tools Nx has to offer.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，还有集成的 Nx 单一代码仓库。这是我们将会使用，并且是利用 Nx 提供的所有工具的设置。
- en: Now, let’s see what Nx created f when it generated the monorepo.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 Nx 在生成单一代码仓库时创建了什么。
- en: What did Nx create in our new workspace?
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nx 在我们的新工作区中创建了什么？
- en: When you open the `business-tools-monorepo` folder in V SCode, you will see
    five folders and a couple of files in the root of the monorepo. We will review
    the essential files and explain the folders, but first, let’s briefly lay out
    what Nx did for us when it generated the monorepo.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 V SCode 中打开 `business-tools-monorepo` 文件夹时，你将在单一代码仓库的根目录下看到五个文件夹和一些文件。我们将回顾必要的文件并解释文件夹，但首先，让我们简要概述
    Nx 在生成单一代码仓库时为我们做了什么。
- en: Nx created our monorepo and configured it for building Angular applications.
    It installed the Nx Angular plugin and all the essential NPM packages needed to
    develop Angular applications. Besides that, Nx configured everything for computational
    caching, ESlint, Cypress e2e testing, and unit testing with Jest, and Prettier
    for code formatting. Nx also made our first Angular application, `apps` folder.
    The `apps` folder will contain all the applications we create in our Nx monorepo.
    If you open the `apps` folder, you will notice that Nx also created an `invoicing-e2e`
    project. This is a Cypress project for e2e testing our Angular invoicing application.
    All of these things will work out of the box. Nx did all the configuration for
    us. In the folder structure, we’ll see a folder named `apps`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Nx 创建了我们的单一代码仓库，并为其构建 Angular 应用程序进行了配置。它安装了 Nx Angular 插件以及开发 Angular 应用程序所需的所有基本
    NPM 包。除此之外，Nx 还为计算缓存、ESLint、Cypress e2e 测试、使用 Jest 的单元测试和 Prettier 代码格式化进行了配置。Nx
    还创建了我们的第一个 Angular 应用程序，`apps` 文件夹。`apps` 文件夹将包含我们在 Nx 单一代码仓库中创建的所有应用程序。如果你打开
    `apps` 文件夹，你会注意到 Nx 还创建了一个 `invoicing-e2e` 项目。这是一个用于端到端测试我们的 Angular 发票应用程序的 Cypress
    项目。所有这些都将直接可用。Nx 为我们进行了所有配置。在文件夹结构中，我们将看到一个名为 `apps` 的文件夹。
- en: 'Now, let’s look at some important files that Nx created in our workspace:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 Nx 在我们的工作区中创建的一些重要文件：
- en: '`nx.json`: This is used to configure the Nx CLI and its default configurations'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nx.json`: 这用于配置 Nx CLI 及其默认配置'
- en: '`.eslintrc.json`: This file can be found at the root of your monorepo and inside
    each project in the repo. The file in the root contains the global ESlint rules
    that are applied to all projects within our monorepo. The files within the specific
    projects contain project-specific ESlint rules.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.eslintrc.json`: 这个文件可以在你的单一代码仓库的根目录下找到，以及在每个特定项目中。根目录下的文件包含应用于我们单一代码仓库中所有项目的全局
    ESLint 规则。特定项目中的文件包含特定项目的 ESLint 规则。'
- en: '`project.json`: This can be found at the root of our Angular application (`apps\invoicing\project.json`).
    In a regular Angular application, this would be our `angular.json` file. It has
    the same content and usage. The `project.json` file will be created for each project
    in our Nx monorepo.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project.json`: 这个文件可以在我们的 Angular 应用程序的根目录下找到（`apps\invoicing\project.json`）。在一个常规的
    Angular 应用程序中，这将是我们自己的 `angular.json` 文件。它们具有相同的内容和用法。`project.json` 文件将在我们的 Nx
    单一代码仓库中的每个项目中创建。'
- en: '`tsconfig.base.json`: This is used for global TypeScript settings and setting
    up aliases for library imports.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tsconfig.base.json`: 这用于全局 TypeScript 设置和为库导入设置别名。'
- en: We will learn more about these files and how to edit them throughout this book
    and when we start to add projects, libraries, and plugins to our Nx monorepo.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中学习更多关于这些文件以及如何编辑它们的知识，当我们开始向我们的 Nx 单一代码仓库添加项目、库和插件时。
- en: Improving our Nx workspace for better Angular development
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升我们的 Nx 工作区以实现更好的 Angular 开发
- en: We already have a nice workspace from Nx that will scale pretty well out of
    the box. You can uniformly create Angular applications, libraries, and other classes
    throughout the workspace. For each application or library you create, Jest unit
    testing is configured, and for each application, you get a Cypress project with
    everything you need to run e2e tests. ESlint and Prettier are configured for the
    entire monorepo to keep your code uniform among the different projects. The monorepo
    has automated updates with Nx migrations; you can visualize your dependencies
    and tasks with the Nx graph and effectively run commands against your monorepo
    with the Nx task runner. The first step I like to take is creating a `libs` folder
    next to the `apps` folder. Inside this `libs` folder, we will store all our libraries.
    To improve this further, we need to add some extra ESlint rules, create custom
    generators tailored to our needs, and set up project boundaries with tags.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个很好的 Nx 工作空间，它将很好地扩展。您可以在整个工作空间中统一创建 Angular 应用程序、库和其他类。对于您创建的每个应用程序或库，Jest
    单元测试已配置，并且对于每个应用程序，您将获得一个 Cypress 项目，其中包含运行端到端测试所需的一切。ESLint 和 Prettier 已配置在整个
    monorepo 中，以保持不同项目之间的代码一致性。monorepo 使用 Nx 迁移进行自动化更新；您可以使用 Nx 图形可视化您的依赖项和任务，并有效地使用
    Nx 任务运行器对您的 monorepo 运行命令。我喜欢采取的第一步是在 `apps` 文件夹旁边创建一个 `libs` 文件夹。在这个 `libs` 文件夹内部，我们将存储所有我们的库。为了进一步提高，我们需要添加一些额外的
    ESlint 规则，创建符合我们需求的自定义生成器，并使用标签设置项目边界。
- en: Adding ESlint rules to improve our Angular code
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 ESlint 规则以改进我们的 Angular 代码
- en: We can use lint rules to keep our code uniform and ensure that developers don’t
    implement code in unintended ways. Linting can catch bugs preemptively and enforce
    best practices. Nx has already added Angular-specific lint rules for our monorepo
    with two `@angular-eslint` packages. To make our monorepo more robust, we’ll want
    to add some extra ESlint rules tailored for Angular and RxJS. The lint rules we
    will add are not required, but I suggest using them or adding rules according
    to your preferences when setting up a monorepo. This is important so that everyone
    working on your code will follow the same implementation and style guide rules
    for writing code. Each company and code base uses its own conventions, so make
    sure you have lint rules in place to enforce them. If you can’t find lint rules
    that enforce your code conventions, Nx also allows you to add custom lint rules.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 lint 规则来保持我们的代码一致性，并确保开发者不会以未预期的方式实现代码。Linting 可以提前捕获错误并强制执行最佳实践。Nx 已经为我们的
    monorepo 添加了 Angular 特定的 lint 规则，使用了两个 `@angular-eslint` 包。为了使我们的 monorepo 更健壮，我们希望添加一些针对
    Angular 和 RxJS 定制的额外 ESlint 规则。我们将添加的 lint 规则不是必需的，但建议在设置 monorepo 时使用它们或添加规则以符合您的偏好。这很重要，因为这样所有参与您代码的人都将遵循相同的实现和代码编写风格指南规则。每个公司和代码库都有自己的约定，所以请确保您有
    lint 规则来强制执行它们。如果您找不到强制执行您代码约定的 lint 规则，Nx 也允许您添加自定义 lint 规则。
- en: 'First, we will add some NPM packages as dev dependencies:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加一些 NPM 包作为开发依赖项：
- en: '[PRE12]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When the command has finished running, the packages will be added to the `package.json`
    file in the root of your Nx monorepo, and the lint rules belonging to these packages
    can be added to the `.eslintrc.json` files. We will only add rules to the `.eslintrc.json`
    file at the root of the monorepo. These lint rules will be applied to all the
    projects within the monorepo. We also need to add `parserOptions` to the `.eslintrc.json`
    file because we’re working with TypeScript and type-based lint rules. You can
    find the updated `.eslintrc.json` file in this book’s GitHub repository (link
    in the *Technical* *requirements* section).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令运行完成后，这些包将被添加到 Nx monorepo 根目录下的 `package.json` 文件中，并且属于这些包的 lint 规则可以添加到
    `.eslintrc.json` 文件中。我们只会在 monorepo 根目录的 `.eslintrc.json` 文件中添加规则。这些 lint 规则将应用于
    monorepo 中的所有项目。我们还需要将 `parserOptions` 添加到 `.eslintrc.json` 文件中，因为我们正在使用 TypeScript
    和基于类型的 lint 规则。您可以在本书的 GitHub 仓库中找到更新后的 `.eslintrc.json` 文件（*技术要求*部分中的链接）。
- en: Once you’ve added the extra lint rules and `parserOptions`, we can move on and
    start creating some custom Nx generators.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您添加了额外的 lint 规则和 `parserOptions`，我们就可以继续创建一些自定义 Nx 生成器。
- en: Creating custom Nx generators for our Angular monorepo
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为我们的 Angular monorepo 创建自定义 Nx 生成器
- en: Generators are excellent tools to do things uniformly because everyone who uses
    the generator will have the same result. First, we’ll focus on overwriting built-in
    Angular generators. Throughout this book, we will create and use generators to
    refactor code in our monorepo and to create custom code snippets.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是执行统一任务的优秀工具，因为使用生成器的每个人都会得到相同的结果。首先，我们将专注于覆盖内置的 Angular 生成器。在整个书中，我们将创建和使用生成器来重构我们的单仓库中的代码以及创建自定义代码片段。
- en: In this section, we will overwrite the generator for creating Angular libraries.
    We will significantly reduce the options you can enter when using the generator,
    add custom options to enforce a directory structure, and add tags for project
    boundaries. Fewer options means less deviation from the conventions your organization
    is using, resulting in more uniformity and fewer questions from less experienced
    developers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将覆盖创建 Angular 库的生成器。我们将显著减少使用生成器时可以输入的选项，添加自定义选项以强制目录结构，并添加项目边界标签。选项越少，就越符合你组织使用的约定，从而实现更多的一致性和减少经验较少的开发者的问题。
- en: 'Let’s start by creating an Nx plugin using an Nx generator:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用 Nx 生成器创建一个 Nx 插件开始：
- en: 'To use the plugin generator, install the NPM package by running the following
    command:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用插件生成器，通过运行以下命令安装 NPM 包：
- en: '[PRE13]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, on the left-hand side of VS Code, click on the Nx icon to open the Nx console.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 VS Code 的左侧，点击 Nx 图标以打开 Nx 控制台。
- en: Go to the **GENERATE & RUN TARGET** tab and click **generate**. This will open
    a dropdown with a search bar at the top of VS Code.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**生成 & 运行目标**选项卡，点击**生成**。这将在 VS Code 顶部打开一个带有搜索栏的下拉菜单。
- en: In this search bar, enter `plugin` and select the **@nx/plugin - plugin Create
    a Nx plugin** option. This will open a new window in VS Code where you can generate
    your plugin.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个搜索栏中，输入`plugin`并选择**@nx/plugin - plugin Create a Nx plugin**选项。这将在 VS Code
    中打开一个新窗口，你可以在这个窗口中生成你的插件。
- en: By default, the generator will ask you to fill out two fields, a *name* and
    an *import path*, and a directory, of which the name is required.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，生成器会要求你填写两个字段，一个*名称*和一个*导入路径*，以及一个目录，其中名称是必需的。
- en: Name your plugin `workspace-generators-plugin`. For the import path, enter `@business-tools/workspace-generators-plugin`,
    and for the directory, enter `libs`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的插件命名为`workspace-generators-plugin`。对于导入路径，输入`@business-tools/workspace-generators-plugin`，对于目录，输入`libs`。
- en: Click **Show** **all options**.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**显示** **所有选项**。
- en: Under **projectNameAndRootFormat**, select **derived**.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**projectNameAndRootFormat**下，选择**派生**。
- en: Then, click on the **generate** button at the top right.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击右上角的**生成**按钮。
- en: This will generate your plugin under the `libs` folder at the root of your monorepo.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的单仓库根目录下的`libs`文件夹中生成你的插件。
- en: 'Next, we will create our custom generator:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的自定义生成器：
- en: First, click on **generate** again in the Nx console.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 Nx 控制台中再次点击**生成**。
- en: In the search bar, type `generator` and select **@nx/plugin -** **generator**.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索栏中，输入`generator`并选择**@nx/plugin -** **generator**。
- en: Now, in the newly opened window, give the generator a name, such as `generate-angular-library`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在新打开的窗口中，给生成器起一个名字，例如`generate-angular-library`。
- en: For `libs\workspace-generators-plugin`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`libs\workspace-generators-plugin`。
- en: Click **Show** **all options**.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**显示** **所有选项**。
- en: Under **projectNameAndRootFormat**, select **derived**.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**projectNameAndRootFormat**下，选择**派生**。
- en: Then, click on the **generate** button at the top right.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，再次点击右上角的**生成**按钮。
- en: 'When this process completes, you will find a `generators` folder inside the
    `src` folder of `workspace-generators-plugin`. Inside this `generators` folder,
    you will find your custom generator, which is named `generate-angular-library`.
    Inside your custom generator are a bunch of files, but before we start exploring
    them, let’s look at what we will overwrite with this custom generator:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当此过程完成后，你将在`workspace-generators-plugin`的`src`文件夹中找到一个`generators`文件夹。在这个`generators`文件夹中，你会找到你的自定义生成器，其名称为`generate-angular-library`。在你的自定义生成器中有一系列文件，但在我们开始探索它们之前，让我们看看我们将用这个自定义生成器覆盖的内容：
- en: Go back to your Nx console and click **generate** again.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回你的 Nx 控制台并再次点击**生成**。
- en: This time, search for `library` and choose **option @nx/angular -** **library**.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，搜索`library`并选择**选项 @nx/angular -** **library**。
- en: When you inspect the new generator window for this library, you will find seven
    options to fill out; if you click on **Show all options**, you will have 30 possibilities
    to fill out. Not all developers will know what to select here, and if we leave
    it up to developers, we will get too much variation when we create libraries within
    our monorepo. For now, let’s close the window for generating an Angular library
    and start to overwrite it with our custom generator.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你检查这个库的新生成器窗口时，你会找到七个选项来填写；如果你点击**显示所有选项**，你将有30个选项可以填写。并不是所有开发者都知道在这里选择什么，如果我们把它留给开发者，那么在我们创建monorepo内的库时，我们会得到太多的变化。现在，让我们关闭生成Angular库的窗口，并开始用我们的自定义生成器来覆盖它。
- en: 'When we overwrite an existing generator, we are interested in three different
    files: `generator.ts`, `schema.json`, and `schema.d.ts`. We will write our logic
    inside the `generator.ts` file; the `schema.json` file will contain the information
    for the Nx console window, and the `schema.d.ts` will contain the interface for
    our options inside the `generator.ts` file. Let’s inspect these three files individually,
    starting with the `generator.ts` file.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们覆盖一个现有的生成器时，我们对三个不同的文件感兴趣：`generator.ts`、`schema.json`和`schema.d.ts`。我们将在`generator.ts`文件中编写我们的逻辑；`schema.json`文件将包含Nx控制台窗口的信息，而`schema.d.ts`将包含`generator.ts`文件中我们选项的接口。让我们分别检查这三个文件，从`generator.ts`文件开始。
- en: 'Nx has already generated a bunch of code for us in this `generator.ts` file,
    but we won’t worry about all that and instead replace it with the following small
    piece of code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Nx已经在这个`generator.ts`文件中为我们生成了一堆代码，但我们将不会担心所有这些，而是用以下一小段代码来替换它：
- en: '[PRE14]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We cleared everything inside the `generateAngularLibraryGenerator` function
    and replaced it with a `libraryGenerator` method from `@nx/angular/generators`.
    This `libraryGenerator` method is the built-in Angular library generator we inspected
    a moment ago. When you want to overwrite built-in generators, you can find them
    in your `node_modules` folder or the GitHub repository of the corresponding package.
    Now, if we build and run our custom generator, we can only enter a name because
    that is the only thing we have in our `schema.json` file, so our custom generator
    generates an Angular library for us with the default settings. So, we went from
    30 options to fill out to only a name. However, we want to add additional options
    and choose specific values for some of the built-in options. We can do this by
    editing the `libraryGenerator` method, like so:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们清除了`generateAngularLibraryGenerator`函数中的所有内容，并用`@nx/angular/generators`中的`libraryGenerator`方法来替换它。这个`libraryGenerator`方法是我们刚才检查过的内置Angular库生成器。当你想要覆盖内置生成器时，你可以在你的`node_modules`文件夹或相应包的GitHub仓库中找到它们。现在，如果我们构建并运行我们的自定义生成器，我们只能输入一个名称，因为这是我们`schema.json`文件中唯一有的东西，所以我们的自定义生成器会使用默认设置为我们生成一个Angular库。因此，我们从填写30个选项减少到了只填写一个名称。然而，我们想要添加额外的选项，并为一些内置选项选择特定的值。我们可以通过编辑`libraryGenerator`方法来实现，如下所示：
- en: '[PRE15]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our generated libraries will now be buildable, use standalone components, have
    on-push change detection, use SCSS style, have tags, have an import path, and
    have a directory structure configured. We use a name, domain, and type property
    in our `options` object. The name is configured by default, so let’s add the options
    we want to expose inside our `schema.json` and `schema.d.ts` files.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成的库现在将是可构建的，使用独立组件，具有on-push变更检测，使用SCSS样式，有标签，有导入路径，并且有配置好的目录结构。我们在`options`对象中使用名称、域和类型属性。名称默认配置，所以让我们在`schema.json`和`schema.d.ts`文件中添加我们想要公开的选项。
- en: 'Inside the `schema.d.ts` file, we’ll find an interface for the `options` object
    we used in the `generator.ts` file. This interface declares a `name` property
    by default. We want to add a domain and type to the interface and only allow preset
    string values for these properties. We can do this by editing the interface like
    this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在`schema.d.ts`文件中，我们将找到用于`generator.ts`文件中使用的`options`对象的接口。这个接口默认声明了一个`name`属性。我们希望向接口添加一个域和类型，并且只允许预设的字符串值用于这些属性。我们可以通过如下编辑接口来实现：
- en: '[PRE16]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Lastly, we want to update our `schema.json` file. This `schema.json` file defines
    the values we can fill out in the Nx console or terminal when using the generator.
    When we generated our custom generator, Nx added a name property for us, so we
    must add the domain and type. We can do this by adding extra objects in the `properties`
    object inside the `schema.json` file. To include the domain, you can add the following
    code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想要更新我们的`schema.json`文件。这个`schema.json`文件定义了我们在使用生成器时可以在Nx控制台或终端中填写的值。当我们生成自定义生成器时，Nx为我们添加了一个名称属性，因此我们必须添加域和类型。我们可以在`schema.json`文件内的`properties`对象中添加额外的对象来实现这一点。要包含域，你可以添加以下代码：
- en: '[PRE17]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For the `type` field, you can add a similar object under the `domain` object.
    The `index` property needs to be one unit higher for the `type` object because
    this index indicates at what position the field will be shown in the Nx console
    when we use the generator.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`type`字段，你可以在`domain`对象下添加一个类似的对象。`index`属性需要比`type`对象高一个单位，因为这个索引表示当我们使用生成器时，该字段将在Nx控制台中显示的位置。
- en: Now, if we build and run the generator, we’ll have three fields to fill out.
    When we fill those fields, a library will be generated for us with all the configurations
    we added.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们构建并运行生成器，我们将有三个字段需要填写。当我们填写这些字段时，一个包含我们添加的所有配置的库将为我们生成。
- en: 'But we can improve the generator even more. We can do this by adding an `''all''`
    option to the type. When selecting `''all''`, we generate a library for each type
    at once, and we can add cleanup logic to remove the initial component that comes
    with the generator – in most cases, we don’t want a component named after the
    library. To achieve these improvements, we’ll need to extract the `libraryGenerator`
    method into a separate function underneath the `generateAngularLibraryGenerator`
    function:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还可以进一步提高生成器的性能。我们可以通过在类型中添加一个`'all'`选项来实现这一点。当选择`'all'`时，我们将一次性为每个类型生成一个库，并且我们可以添加清理逻辑来移除生成器附带的基本组件——在大多数情况下，我们不希望组件的名称与库同名。为了实现这些改进，我们需要将`libraryGenerator`方法提取到`generateAngularLibraryGenerator`函数下方的独立函数中：
- en: '[PRE18]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we need to add an array with our types above the `generateAngularLibraryGenerator`
    function, like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`generateAngularLibraryGenerator`函数上方添加一个包含我们类型的数组，如下所示：
- en: '[PRE19]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, inside the `generateAngularLibraryGenerator` function, we’ll replace `libraryGenerator`
    with a `for` loop. This will add a library for each of the available types when
    `options.type` is equal to `''all''`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`generateAngularLibraryGenerator`函数内部，我们将用`for`循环替换`libraryGenerator`。这将当`options.type`等于`'all'`时，为每个可用类型添加一个库：
- en: '[PRE20]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The only thing that is left to do now is to add some logic to clean up the initial
    component files and update the `index.ts` file to remove the export of this initial
    component. Otherwise, if we create a library named `common-components`, for example,
    it will create a component named `common-components-component`, and that is not
    something we want.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一需要做的事情就是添加一些逻辑来清理初始组件文件，并更新`index.ts`文件以移除该初始组件的导出。否则，如果我们创建一个名为`common-components`的库，例如，它将创建一个名为`common-components-component`的组件，而这并不是我们想要的。
- en: 'To clean up our library, we will use the `tree` parameter that’s exposed to
    us by the `generateAngularLibraryGenerator` function. This `tree` object contains
    our monorepo tree and, in it, all our folders and files. To remove the initial
    component files and update the `index.ts` file when we generate a library, we
    can add the following code at the bottom of our `generateAngularLibraryGenerator`
    function:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清理我们的库，我们将使用由`generateAngularLibraryGenerator`函数暴露给我们的`tree`参数。这个`tree`对象包含我们的monorepo树，其中包含所有我们的文件夹和文件。为了在生成库时移除初始组件文件并更新`index.ts`文件，我们可以在`generateAngularLibraryGenerator`函数的底部添加以下代码：
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once you’ve updated and saved everything, you can test the generator.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你更新并保存了所有内容，你就可以测试生成器。
- en: Open the Nx console in VS Code. At the top, you will find a section named `projects`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开Nx控制台。在顶部，你会找到一个名为`projects`的部分。
- en: 'Underneath this section, you will find your **workspace-generators-plugin**
    project. If you expand this, you will see three options: **build**, **lint**,
    and **test**.'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个部分下方，你会找到你的**workspace-generators-plugin**项目。如果你展开它，你会看到三个选项：**构建**、**lint**和**测试**。
- en: When you hover over the **build** option, you’ll see a **play** button. Go ahead
    and click on this button to build the **workspace-generators-plugin** project.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你悬停在**构建**选项上时，你会看到一个**播放**按钮。请点击这个按钮来构建**workspace-generators-plugin**项目。
- en: When the plugin is built successfully, restart VS Code and click on **generate**
    in your Nx console. You should see **@business-tools/workspace-generators-plugin
    -** **generate-angular-library generator**.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You only need to restart VS Code when you add a new generator or adjust `schema.json`
    because Nx schematics are loaded when you open VS Code.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: When we use the generator, there are three fields where we can enter the name,
    domain, and type. Let’s create a library called `common-components` and then select
    `libs\shared\ui\common-components` path.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: We will also overwrite the component generator. You can go ahead and try to
    do this yourself. If it still feels challenging, you can go to this book’s GitHub
    repository and take the code from there (link in the *Technical requirements*
    section). If you did the overwrite on your own, please check if you implemented
    it the same as we did so that you can continue using the same generators throughout
    this book.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: With that, you know how to overwrite generators and have created your first
    custom generator to build Angular libraries. Next, we will create project boundaries
    for the Nx monorepo.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Setting up project boundaries for the Angular monorepo
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you work in a large monorepo where different teams work on separate projects,
    it is essential to have some boundaries. If you have a library only intended for
    one domain of the monorepo, you don’t want someone to create unintended dependencies
    by importing that library into another domain.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have a library intended for finance-related applications,
    you don’t want it to be imported into a marketing application and create a dependency
    between our finance and marketing domains. What’s even worse is if someone made
    a direct dependency between the two applications. If we do this, we have to build
    and deploy both applications when we only want to update and deploy one of them.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'With Nx, we can set up boundaries with `project.json` file. The boundaries
    are defined inside the `.eslintrc.json` files. We will only create global boundaries
    in the root `.eslintrc.json` file. Inside this `.eslintrc.json` file, you will
    find the following lint rule:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can update the `depConstraints` array to update the boundaries for your
    Nx monorepo. By default, the object inside this array uses `*` as a wildcard,
    allowing any project to import every other project. I advise removing this object
    and setting strict project boundaries. For example, if you only want projects
    with domain finance to import other projects with the same domain, you can add
    this object to the `depConstraints` array:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `sourceTag` component defines the tag we are targeting, while `onlyDependOnLibsWithTags`
    defines the tag it is allowed to import. If you want to see the constraints I
    configured for the monorepo, you can take them from this book’s GitHub repository,
    but you are free to set up the constraints however you like.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve configured the boundaries, you will get a lint error in VS Code
    if you try to import something you’re not allowed to. After the initial setup,
    you might need to restart VS Code for the boundaries to take effect without running
    the linter.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve improved our Nx monorepo and it is ready to host many Angular
    applications and libraries, let’s wrap things up by discussing a good structure
    for our Angular applications and libraries within our monorepo.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Structuring Angular applications and libraries
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last thing we must cover is how to structure our Angular applications and
    libraries within the Nx monorepo. Seeing your applications as containers that
    build up their pages with the components and logic from libraries is a good practice.
    This incentivizes a modular approach and makes it easier for you to have a good
    separation of concerns as a dedicated library project is a much greater boundary
    than separating code with folders in your application. Generally speaking, you
    can use the 80/20 rule, where 80% of your code lives within dedicated library
    projects and 20% within your application projects.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: These libraries don’t have to be built separately from the projects that consume
    them. If that is the case, everything stays the same regarding your deployment
    process, but you won’t utilize Nx incremental builds and computational caching.
    If you want to use incremental builds or publish your libraries to an external
    registry such as NPM, you can mark them as buildable or publishable when you generate
    them. In our custom generator, we made the libraries buildable by default. For
    small applications, you can consider using regular libraries that aren’t buildable
    unless you want to publish them.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Placing code in a library doesn’t necessarily mean the code has to be general
    purpose and must be consumed by multiple parties; putting code in an Nx library
    can be purely for organizational goals. It stimulates you to think in a more API-driven
    way about your code, often resulting in cleaner implementations with fewer dependencies,
    which, in turn, might result in code that can be reused, but it doesn’t have to
    be. When organizing libraries and applications, you should consider the different
    business domains. Generally speaking, the teams of an organization are aligned
    with these business domains; thus, it makes sense to have a similar organization
    for your monorepo projects.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Do you create a new library or reuse an existing one?
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The decision of when to create a new application is pretty straightforward.
    It should probably be an application if it’s a product with a UI that can be used
    or sold independently. For libraries, it can sometimes be harder to define when
    to create a new library and when to add code to an existing library. As with most
    programming decisions, whether to start or reuse a library is about trade-offs.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: The main benefits of creating a new library and splitting up your code are that
    tasks such as building and testing will be completed faster, you have better visualization
    of your architecture with the Nx graph, and you have more control over project
    boundaries by using tags. The advantages of reusing a library are that you can
    better group related code together without any constraints, so it’s easier to
    experiment and less prone to mistakes. Especially when your code base is rapidly
    evolving, keeping things in one library might be easier for the time being. A
    good practice is splitting things into multiple libraries when the development
    pace slows.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Libraries are generally divided into UI, feature, utility, and data-access libraries.
    Your UI libraries should only contain dumb presentational components. Feature
    libraries contain smart components with access to your facade services and are
    created for business cases or pages within the applications. The data-access libraries
    house state management logic and provide everything to communicate with the back-end
    APIs. Lastly, we have the utility libraries, which host helper functions and other
    useful low-level utilities.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'All your libraries should be grouped by their respective application or a business
    domain containing multiple applications. For large companies, the libraries can
    be grouped by sections of a specific business domain, depending on how the scope
    of each domain is defined. When you want to move an application or library into
    a new folder within your Nx monorepo, you need to use the Nx `move` generator
    by running the following command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you want to remove an application or library, you should use the Nx `remove`
    generator, like so:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For both moving and removing projects, you can use the Nx console for a more
    visual approach. It is important to use the Nx console or run the respective Nx
    command in the terminal to perform these actions because they will automatically
    update all configuration files within your Nx monorepo.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1**.5* shows a proposed folder structure, although this is entirely
    up to you and the structure and needs of what you’re building:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: Folder structure](img/B21625_01_5.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Folder structure'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to the next chapter, let’s clean up our monorepo and add some
    placeholder projects. First, remove the invoicing application we made earlier
    and its corresponding e2e project. You can do this by right-clicking on the project
    and selecting `invoicing-e2e` project; then, remove the `invoicing` project. Once
    you’ve removed both projects, we can create some placeholder applications with
    the custom application generator we took from this book’s GitHub repository.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following projects:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '`expenses-registration` (under the domain finance)'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`social-media-dashboard` (under the domain marketing)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `placeholder` library we created can stay because it is already equipped
    with tags and a domain and was created with a custom generator. We will create
    extra libraries as we continue and start to add some code.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 `placeholder` 库可以保留，因为它已经配备了标签和域名，并且是用自定义生成器创建的。随着我们的继续，我们将创建额外的库，并开始添加一些代码。
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you created an Nx monorepo with some placeholder projects and
    are now ready to scale to hundreds of applications. You learned how to structure
    your Angular applications and libraries within the monorepo, and now know how
    to utilize the essential features of Nx.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您创建了一个包含一些占位符项目的 Nx 单一代码仓库，并且现在可以扩展到数百个应用程序。您学习了如何在单一代码仓库中结构化您的 Angular
    应用程序和库，并且现在知道如何利用 Nx 的基本功能。
- en: In the next chapter, we will explore some of the newest and most powerful features
    in the Angular framework.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索 Angular 框架中一些最新和最强大的功能。
