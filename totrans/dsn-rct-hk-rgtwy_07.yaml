- en: '*Chapter 7*: Use Context to Cover an Area'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：使用上下文覆盖区域'
- en: 'In the previous chapter, we learned how `useMemo` is designed and how to use
    `useMemo` to conditionally reuse the last value. In this chapter, we will talk
    about how to propagate changes to cover an area update. We will introduce what
    an area update is and how *React* context is used to share a value within that
    area. Then, we will walk through the data structure and source code behind `useContext`
    to consume the shared value. And finally, we''ll provide two practical examples
    of applying contexts to the theme and the table. The chapter also includes two
    bonus topics in the *Appendix* section: *Propagating a context* and *Context scope
    and value*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了 `useMemo` 的设计和如何使用 `useMemo` 有条件地重用最后一个值。在本章中，我们将讨论如何传播更改以覆盖区域更新。我们将介绍什么是区域更新以及
    *React* 上下文如何用于在该区域内共享值。然后，我们将遍历 `useContext` 后面的数据结构和源代码以消费共享值。最后，我们将提供两个将上下文应用于主题和表格的实际示例。本章还包括
    *附录* 部分的两个额外主题：*传播上下文* 和 *上下文作用域和值*。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is an area update?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么区域更新是什么？
- en: Introducing the React context
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 React 上下文
- en: Understanding the `useContext` design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `useContext` 设计
- en: Test driving `useContext`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 `useContext`
- en: '`useContext` examples'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useContext` 示例'
- en: Questions and answers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问答
- en: Appendix
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附录
- en: What is an area update?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是区域更新？
- en: On a typical website, once the site is loaded, it starts listening to all user
    actions. Each action received gets handled on a first-come, first-served basis.
    Normally, the impact of each action is limited to one small region of the screen,
    using a *UI* term, a single component. However, sometimes, a user action can do
    more than that.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个典型的网站上，一旦网站加载完成，它就开始监听所有用户动作。每个接收到的动作都会按照先来先服务的原则进行处理。通常，每个动作的影响仅限于屏幕上的一个小区域，使用
    *UI* 术语，就是一个单个组件。然而，有时一个用户动作可以做得更多。
- en: Let's use the computer as an analogy. Say you decide to change the color settings
    of your system. Once the color is changed, the computer goes through all the open
    windows and applies that color to them. Therefore, this action can impact multiple
    applications spread across the screen. This becomes an area update.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用计算机作为类比。假设你决定更改系统的颜色设置。一旦颜色更改，计算机就会遍历所有打开的窗口并将该颜色应用到它们上。因此，这个动作可以影响屏幕上分散的多个应用程序。这成为了一个区域更新。
- en: Have you wondered how we can make an area update when the impacted components
    are located very distantly from each other? To be able to answer this question,
    let's first recall a single update introduced in [*Chapter 4*](B17963_04_Epub.xhtml#_idTextAnchor113),
    *Use State to Jumpstart Components*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想过，当受影响的组件彼此之间非常遥远时，我们如何进行区域更新？为了回答这个问题，让我们首先回顾一下在 [*第 4 章*](B17963_04_Epub.xhtml#_idTextAnchor113)
    中引入的单个更新，*使用状态启动组件*。
- en: A fiber tree is scheduled for a single update upon receiving an action. This
    update is localized around a source fiber where the action is received (the red
    dot in *Figure 7.1*). *React* follows the source and collects all the changes
    associated with it and then applies them to the *DOM* (red lines). This is the
    single update pattern in *React*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到一个动作时，纤维树会安排一个单个更新。这个更新围绕接收动作的源纤维进行本地化（*图 7.1* 中的红色点）。*React* 跟随源纤维，收集与之相关的所有更改，然后将它们应用到
    *DOM* 上（红色线条）。这是 *React* 中的单个更新模式。
- en: '![Figure 7.1 – A single update originating from a user action'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – 由用户动作引发的单个更新'
- en: '](img/Figure_7.01_B17963.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.01_B17963.jpg)'
- en: Figure 7.1 – A single update originating from a user action
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 由用户动作引发的单个更新
- en: 'Say the source fiber is a `Title` component:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设源纤维是一个 `Title` 组件：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding `Title` component gets updated when the user clicks on `count`.
    It should also update other children in the `...` section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击 `count` 时，前面的 `Title` 组件会进行更新。它也应该更新 `...` 部分中的其他子组件。
- en: 'Now, consider another component called `ThumbUp`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑另一个名为 `ThumbUp` 的组件：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The intention of the `ThumbUp` component is to respond to `count`. When it
    becomes greater than `5`, we want an `"Awesome"` message to be printed on the
    screen. The `ThumbUp` component is located in *Figure 7.2*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThumbUp` 组件的目的是响应 `count`。当它大于 `5` 时，我们希望在屏幕上打印出 `"Awesome"` 消息。`ThumbUp`
    组件位于 *图 7.2*：'
- en: '![Figure 7.2 – Two updates responding to a single user action'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – 对单个用户动作响应的两个更新'
- en: '](img/Figure_7.02_B17963.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.02_B17963.jpg)'
- en: Figure 7.2 – Two updates responding to a single user action
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 对单个用户动作响应的两个更新
- en: Currently, the `count` variable in the `ThumbUp` component is a made-up one
    because we don't know how it can be passed from the `Title` component. All we
    know is that we want to share this `count` among both components and the challenge
    somehow lies in their relationship.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`ThumbUp`组件中的`count`变量是一个虚构的变量，因为我们不知道它如何从`Title`组件传递过来。我们所知道的是，我们想在两个组件之间共享这个`count`，而挑战似乎在于它们之间的关系。
- en: Apparently, these two components are not a child or parent to one another. There's
    no direct path from one to the other unless we first go upward multiple steps
    to the `Branch` component (dark dot in *Figure 7.2*) and then go down again picking
    another route. Essentially, `Branch` is their common ancestor. So how exactly
    can we send information between two nodes that are not in a direct parent/child
    relationship?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这两个组件之间并不是父子关系。除非我们首先向上移动多个步骤到达`Branch`组件（*图7.2*中的暗点）然后再向下选择另一条路径，否则没有直接从一方到另一方的路径。本质上，`Branch`是它们的共同祖先。那么我们究竟如何在这两个不是直接父子关系的节点之间发送信息呢？
- en: Let's explore this question by taking two approaches, starting with the props
    approach.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过两种方法来探讨这个问题，首先从props方法开始。
- en: Props approach
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Props方法
- en: 'Since the React props only work for the parent/child setup, to apply the props
    to this problem, we need to promote the relevant state to a common ancestor, the
    `Branch` component:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于React的props只适用于父子设置，为了将props应用到这个问题上，我们需要将相关的状态提升到共同祖先，即`Branch`组件：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, the `count` state is relocated from `Title` to `Branch`.
    From there, `count` and `dispatch` are then sent to the (distant) children via
    props. Now, if the state changes, the `Branch` component updates all its children,
    including `Title` and `ThumbUp`. OK, we managed to share the `count` state.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`count`状态从`Title`移动到了`Branch`。从那里，`count`和`dispatch`通过props发送到（遥远的）子组件。现在，如果状态发生变化，`Branch`组件会更新所有子组件，包括`Title`和`ThumbUp`。好吧，我们成功共享了`count`状态。
- en: Although the props approach works in general, it does require us to modify the
    props for both the `Title` and `ThumbUp` components. Since there can be other
    components in the path between `Branch` and each of them, all components along
    the way need to be modified as well. Considering a typical site build, the need
    to share a state happens in the later stage of the project cycle. Taking this
    approach can be very expensive due to the number of components we need to modify.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然props方法在一般情况下是可行的，但它确实要求我们修改`Title`和`ThumbUp`组件的props。由于`Branch`和每个组件之间的路径上可能有其他组件，所以沿途的所有组件都需要进行修改。考虑到典型的网站构建，共享状态的需求通常发生在项目周期的后期阶段。采用这种方法可能会因为需要修改的组件数量而变得非常昂贵。
- en: So, is there a better way of sharing the prop without touching so many components?
    Looking at *Figure 7.2*, an intuitive approach could be to dispatch an update
    to the `Title` component, and an update to the `ThumbUp` component at the same
    time. The combined impact could produce an area update covering both. Let's see
    if we can make this idea work.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，有没有一种更好的方法来共享prop，而不需要修改这么多组件？观察*图7.2*，一个直观的方法可能是同时向`Title`组件和`ThumbUp`组件发送更新。这种组合影响可能会产生覆盖两者的区域更新。让我们看看这个想法是否可行。
- en: Combined dispatch approach
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合分发方法
- en: 'To have a combined dispatch, we need to allow both dispatches to be accessible
    from an event handler. This is a bit tricky since a dispatch function provided
    via `useState` is normally defined inside one component, either `Title` or `ThumbUp`.
    To get around that, let''s say we use a global variable for now:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现组合分发，我们需要允许从事件处理器访问两个分发。这有点棘手，因为通过`useState`提供的分发函数通常定义在一个组件内部，无论是`Title`还是`ThumbUp`。为了解决这个问题，让我们假设我们目前使用一个全局变量：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we amended the `ThumbUp` component and added a `count`
    state and a `dispatch` function. We then used a global variable, `dispatch2`,
    to point to this `dispatch` function so that it can be invoked by other components.
    Now, with this change, we can ask the `Title` component to perform both dispatches:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们修改了`ThumbUp`组件，并添加了一个`count`状态和一个`dispatch`函数。然后我们使用一个全局变量`dispatch2`来指向这个`dispatch`函数，以便其他组件可以调用它。现在，通过这个变化，我们可以要求`Title`组件执行两个分发：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From the preceding setup, after the user clicks on `count`, it performs the
    `dispatch` from `Title` and performs `dispatch2` from `Greeting`. Although the
    two `count` states in each component are not pointing to a shared value, both
    are incremented respectively from these two dispatches. *React* batches these
    two dispatches into one update to the screen, and if the user continues clicking
    the number, you will see an `"Awesome"` message on the screen when the `count`
    state gets bigger than `5`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的设置来看，当用户点击`count`时，它会从`Title`执行`dispatch`操作，并从`Greeting`执行`dispatch2`操作。尽管每个组件中的两个`count`状态并没有指向共享的值，但它们分别从这两个`dispatch`操作中各自增加。*React*将这些两个`dispatch`操作批处理为一次屏幕更新，如果用户继续点击数字，当`count`状态大于`5`时，你会在屏幕上看到一条`"Awesome"`消息。
- en: You might not believe this hack-ish approach would work, but it does. The fact
    that we call a dispatch function for another component is a bit beyond what *React*
    designs `useState` to do, but it's not incorrect. This approach requires fewer
    changes to the code structure. There's no prop involved. All changes are made
    on the local side of `Title` and `ThumbUp`. More importantly, it serves as an
    educational case that an update impacting multiple components can be composed
    of multiple updates.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不相信这种类似黑客的方法会有效，但它确实有效。我们为另一个组件调用`dispatch`函数的事实略超出了*React*设计`useState`的目的，但这并不错误。这种方法需要对代码结构进行较少的修改。没有涉及任何属性。所有更改都是在`Title`和`ThumbUp`的本地侧进行的。更重要的是，它作为一个教育案例，表明影响多个组件的更新可以由多个更新组成。
- en: OK, what we learned from these two approaches is that we want to avoid passing
    props all the way down in this non-parent/child case, and we want to share the
    value as well as trigger a sort of combined update following the value change.
    Moreover, in practice, if the solution can provide the joint dispatch out of the
    box and require minor modifications to the existing code structure, that would
    be even better.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，从这两种方法中我们学到的是，我们想要避免在这个非父/子情况下一路向下传递属性，我们还想共享值以及触发一种随值变化而进行的组合更新。此外，在实践中，如果解决方案可以提供开箱即用的联合`dispatch`，并且只需要对现有代码结构进行少量修改，那就更好了。
- en: By the end of 2017, the *React* team found such needs and introduced a new version
    of context to address its current limitations at that time. What the new context
    does is that it helps to share a value through multiple levels of components without
    requiring a prop in each level. It also provides a mechanism for a distant child
    component to access a value from an ancestor component. Let's take a look at this
    *React* context.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到2017年底，*React*团队发现了这样的需求，并引入了一个新版本的上下文来解决当时存在的限制。新上下文的作用是帮助通过多个组件层级共享一个值，而不需要在每个层级中传递属性。它还提供了一个机制，允许远端子组件访问祖先组件的值。让我们来看看这个*React*上下文。
- en: Introducing the React context
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍React上下文
- en: The context is modeled with a `ReactContext` data type holding a `_currentValue`
    value.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文通过一个包含`_currentValue`值的`ReactContext`数据类型进行建模。
- en: '![Figure 7.3 – React context data structure'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.3 – React上下文数据结构'
- en: '](img/Figure_7.03_B17963.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.03_B17963.jpg](img/Figure_7.03_B17963.jpg)'
- en: Figure 7.3 – React context data structure
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.3 – React上下文数据结构
- en: 'We can create a context with the `createContext` function. For instance, if
    we want to share a piece of user info, we can create a `UserContext` and hold
    a `defaultValue`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`createContext`函数创建一个上下文。例如，如果我们想共享一些用户信息，我们可以创建一个`UserContext`并持有`defaultValue`：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The created context can be shared via a *JavaScript* `export` statement, and
    this way, when any other file or component needs it, it can be imported.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的上下文可以通过*JavaScript*的`export`语句进行共享，这样，当任何其他文件或组件需要它时，它可以被导入。
- en: 'The context allows us to provide the value to all consumers underneath via
    a `Provider` property:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文允许我们通过`Provider`属性将值提供给所有下层的消费者：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A context provider, such as `UserContext.Provider`, accepts a `value` prop to
    share. The provider is a special component. Unlike a function component, it has
    its own update implementation. When it gets updated due to a change in `value`,
    it kicks off a search.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个上下文提供者，如`UserContext.Provider`，接受一个用于共享的`value`属性。提供者是一个特殊组件。与函数组件不同，它有自己的更新实现。当它由于`value`的变化而更新时，它会启动一个搜索。
- en: The search goes through its children, and its children's children recursively,
    until everything under gets visited. For all consumers using the context, they
    are marked to be updated. If you are interested in knowing more about the context
    provider, check out *Appendix A – Propagating a context*, at the end of this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索会遍历其子级及其子级的子级，直到访问到所有内容。对于所有使用上下文的消费者，它们都被标记为需要更新。如果你对上下文提供者感兴趣，请查看本章末尾的*附录A
    – 上下文的传播*。
- en: 'Hence, a provider''s job is to share a value. If multiple values of different
    purposes are required, we can stack them together. Let''s say that, on top of
    `UserContext`, we have one more `ThemeContext` context to share:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，提供者的工作就是共享一个值。如果需要多个不同目的的值，我们可以将它们堆叠在一起。比如说，在`UserContext`之上，我们还有一个`ThemeContext`上下文来共享：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding usage would enable any consumer in the`...` section to read the
    value from `theme` or `user`, or both.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的使用方法将允许`...`部分中的任何消费者读取`theme`或`user`的值，或者两者都读取。
- en: 'One interesting aspect regarding the design of the provider is that a provider
    can be nested under the same provider to override the shared value:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于提供者设计的一个有趣方面是，一个提供者可以嵌套在同一个提供者下面以覆盖共享值：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, `theme1` and `theme2` are provided by two providers from
    the same `ThemeContext` definition. So, which context value does a consumer see,
    you might wonder?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`theme1`和`theme2`是由同一个`ThemeContext`定义的两个提供者提供的。那么，消费者会看到哪个上下文值，你可能想知道？
- en: There are four locations marked `A`, `B`, `C`, and `D` in the preceding code.
    The value a consumer sees depends on where it's consumed. For location `A`, the
    value a consumer sees is `theme1`, for location `B`, it's `theme2`, and for location
    `C`, it's back to `theme1` again.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，标记了四个位置`A`、`B`、`C`和`D`。消费者看到的值取决于它被消费的位置。对于位置`A`，消费者看到的值是`theme1`，对于位置`B`，它是`theme2`，而对于位置`C`，它又回到了`theme1`。
- en: Essentially, the context provider is designed (in a way) like a *JavaScript*
    function. You can get different values in the different function scopes. To figure
    out the correct value at a particular location, you need to find the first ancestor
    parent that provides the `value`. The closest ancestor provider should provide
    the right context value. This should explain why location `C` gets `theme1` instead
    of `theme2`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，上下文提供者（以某种方式）设计得像*JavaScript*函数。你可以在不同的函数作用域中获取不同的值。为了确定特定位置的正确值，你需要找到提供`value`的第一个祖先父级。最近的祖先提供者应该提供正确的上下文值。这应该解释了为什么位置`C`得到`theme1`而不是`theme2`。
- en: 'Then what is the context value outside of any provider scope, for instance,
    at location `D`? Since it does not happen to be an ancestor provider that you
    can find above the `Branch` component. This is where `defaultValue` comes into
    play:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在没有任何提供者作用域之外，例如在位置`D`，上下文值是什么？由于它碰巧不是一个你可以找到在`Branch`组件之上的祖先提供者。这就是`defaultValue`发挥作用的地方：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When no other provider can be found to provide the value, it takes the `defaultValue`
    supplied at the time the context is created. This implies that the default value
    isn''t a must-have, but it can be useful for taking a sneak peek into the format
    of a context type early on:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当找不到其他提供者来提供值时，它将采用在创建上下文时提供的`defaultValue`。这意味着默认值不是必需的，但它可以在早期查看上下文类型格式时很有用：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Internally, *React* uses a stack to push and pop the context to keep track of
    context values for all provider scopes. If you are interested in knowing this
    detail, check out *Appendix B – Context scope and value*, at the end of this chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，*React*使用一个栈来推送和弹出上下文，以跟踪所有提供者作用域的上下文值。如果你对这个细节感兴趣，请查看本章末尾的*附录B – 上下文作用域和值*。
- en: OK, now that we know how to provide a context value, let's see how we can consume
    it in a consumer/child component. *React* provides a `useContext` hook to do just
    that.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们知道了如何提供上下文值，让我们看看我们如何在消费者/子组件中消费它。*React*提供了一个`useContext`钩子来完成这项工作。
- en: Understanding the useContext design
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解useContext设计
- en: '*React* provides a `useContext` hook to consume a context:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*React*提供了一个`useContext`钩子来消费上下文：'
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `useContext` hook function takes one input argument, `context`, and returns
    the shared value. `context` is normally imported from a definition file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`useContext`钩子函数接受一个输入参数`context`，并返回共享的值。`context`通常从一个定义文件中导入。'
- en: useContext data structure
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useContext数据结构
- en: 'We are going to explain how `useContext` is designed with a stripped-down version
    of the source code. Let''s take a look at the data structure that makes it happen:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解释如何使用简化版源代码来设计`useContext`。让我们看看使其发生的数据结构：
- en: '![Figure 7.4 – useContext hook data structure'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 – useContext钩子数据结构'
- en: '](img/Figure_7.04_B17963.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.04_B17963.jpg)'
- en: Figure 7.4 – useContext hook data structure
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – useContext钩子数据结构
- en: To consume (or read) a context value, each fiber gets a new `dependencies` property
    to keep track of all the context it consumes. This is because a component can
    use multiple `useContext` and each usage consumes a different context, such as
    `UserContext` and `ThemeContext`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要消费（或读取）上下文值，每个纤维都会获得一个新的`dependencies`属性来跟踪它所消费的所有上下文。这是因为一个组件可以使用多个`useContext`，并且每次使用都会消费不同的上下文，例如`UserContext`和`ThemeContext`。
- en: The `dependencies` property is designed as a linked list with its `firstContext`
    property to hold the first context with a `ContextItem` type. Each `ContextItem`
    holds a `ReactContext` (the context introduced earlier) and a `next` property
    pointing to the next context. The dependencies list is how the provider finds
    all consumers while propagating the update.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependencies`属性被设计为一个链表，其`firstContext`属性用于保存第一个具有`ContextItem`类型的上下文。每个`ContextItem`都包含一个`ReactContext`（之前介绍过的上下文）和一个指向下一个上下文的`next`属性。依赖列表是提供者如何在传播更新时找到所有消费者的方式。'
- en: 'The `useContext` hook is designed to read a context value for all updates:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`useContext`钩子被设计用来读取所有更新中的上下文值：'
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The main job of `useContext` in the preceding code block is to return `_currentValue`
    from `context`. It also appends `context` to the fiber's `dependencies` list before
    returning the context value.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，`useContext`的主要任务是返回`context`中的`_currentValue`。在返回上下文值之前，它还将`context`追加到纤维的`dependencies`列表中。
- en: '`lastDependency` is an auxiliary variable that keeps track of the last context
    of the update. If this is the first context, it''s then created as `firstContext`,
    otherwise it is appended to the `next` of the list. At the beginning of the update,
    `lastDependency` is set to be `null`. Thus, the list of `dependencies` for each
    fiber is recreated in every update, and this reminds us how hooks are created
    in each update.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`lastDependency`是一个辅助变量，用于跟踪更新的最后一个上下文。如果是第一个上下文，则将其创建为`firstContext`，否则将其追加到列表的`next`中。在更新的开始时，`lastDependency`被设置为`null`。因此，每个纤维的`dependencies`列表在每次更新时都会重新创建，这提醒我们钩子是如何在每次更新中创建的。'
- en: useContext workflow
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useContext工作流程
- en: 'You have gone through a stripped-down version of `useContext` code. Here is
    the summary workflow for both provider and `useContext`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经通过简化版的`useContext`代码进行了学习。以下是提供者和`useContext`的总结工作流程：
- en: '![Figure 7.5 – useContext and ContextProvider workflow'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – useContext和ContextProvider工作流程'
- en: '](img/Figure_7.05_B17963.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.05_B17963.jpg)'
- en: Figure 7.5 – useContext and ContextProvider workflow
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – useContext和ContextProvider工作流程
- en: Let's have a quick run-through. A context is provided through a provider. In
    the event of a value change from the provider, it finds all the consumers and
    propagates the update. Otherwise, it skips the update.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下。上下文通过提供者提供。在提供者的值发生变化的情况下，它会找到所有消费者并传播更新。否则，它会跳过更新。
- en: In an update, when a `useContext` hook is invoked with a given context, it appends
    the context to the fiber's `dependencies` list and returns the context's current
    value.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新过程中，当使用给定上下文的`useContext`钩子被调用时，它会将上下文追加到纤维的`dependencies`列表中，并返回上下文的当前值。
- en: Now that we have gone through the overall design, let's take it all out for
    a test drive.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了整体设计，让我们来对其进行一次全面的测试。
- en: Test driving useContext
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试`useContext`
- en: 'Context is fun to use and has quite a few common applications. Consider a site
    with a user logo displayed at the top-right corner of the screen:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文的使用很有趣，并且有相当多的常见应用。考虑一个在屏幕右上角显示用户标志的网站：
- en: '![Figure 7.6 – An application with App, Header, and Logo'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 – 包含App、Header和Logo的应用程序'
- en: '](img/Figure_7.06_B17963.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.06_B17963.jpg)'
- en: Figure 7.6 – An application with App, Header, and Logo
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 包含App、Header和Logo的应用程序
- en: 'The site is created with an `App` component, containing `Header` and `Main`.
    And in turn, `Header` contains `Logo`, and `Site` contains `Greeting`. `App`,
    `Header`, and `Logo` are defined as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站使用`App`组件创建，包含`Header`和`Main`。然后，`Header`包含`Logo`，而`Site`包含`Greeting`。`App`、`Header`和`Logo`的定义如下：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Assuming the user gets authenticated as an `initialUser` and sent to the `App`,
    it gets passed via a prop to `Header` and `Logo`. In `Logo`, it gets consumed
    by its `imageUrl` property and `username` to display a logo. Notice the interface
    for all components needs to carry `user` as a prop. Since we want to display a
    greeting message under `Main`, the `user` needs to be passed via a prop as well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户经过认证作为`initialUser`发送到`App`，它将通过属性传递给`Header`和`Logo`。在`Logo`中，它通过其`imageUrl`属性和`username`被消费以显示一个标志。注意所有组件的接口都需要携带`user`属性。由于我们想在`Main`下显示问候消息，因此`user`也需要通过属性传递。
- en: 'Let''s see how a context can help to simplify this setup. Let''s say we define
    a `UserContext`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上下文如何帮助简化这个设置。假设我们定义一个`UserContext`：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `App`, we can provide the `initialUser` via `UserContext.Provider`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App`应用中，我们可以通过`UserContext.Provider`提供`initialUser`：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that `Header` and `Main` don't have to carry the `user` prop anymore.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Header`和`Main`不再需要携带`user`属性。
- en: The `App` component creates a `user` state for holding `initialUser`. The `changeUser`
    function can be used to replace the current user if needed. It then assembles
    a `value` object from `user` and `changeUser` to be shared via `UserContext.Provider`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件创建一个`user`状态来保存`initialUser`。`changeUser`函数可以在需要时替换当前用户。然后它从`user`和`changeUser`组装一个`value`对象，通过`UserContext.Provider`共享。'
- en: 'Inside `Logo`, we can consume the value provided, which includes the `user`
    property:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Logo`组件内部，我们可以消费提供的值，包括`user`属性：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, the `user` object is obtained by reading off the `UserContext`
    via an ES6 syntax. For those readers who are interested in knowing about ES6 usages,
    check out the *Embracing JavaScript ES6* section in [*Chapter 10*](B17963_10_Epub.xhtml#_idTextAnchor363),
    *Building a Website with React*. Once the `user` is obtained, we can use the `imageUrl`
    and `username` properties of `user` to quickly wire them to the existing `Logo`
    component.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，通过ES6语法读取`UserContext`来获取`user`对象。对于那些对ES6用法感兴趣的读者，可以查看[*第10章*](B17963_10_Epub.xhtml#_idTextAnchor363)中的*拥抱JavaScript
    ES6*部分，*使用React构建网站*。一旦获取到`user`，我们可以使用`user`的`imageUrl`和`username`属性快速将其连接到现有的`Logo`组件。
- en: 'The same applies to the components under `Main`, such as `Greeting`, which
    shows the `Hello Fang` message depending on the currently logged-in user. We can
    utilize the context to accomplish that with little effort:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于`Main`下的组件，例如`Greeting`，它根据当前登录用户显示`Hello Fang`消息。我们可以利用上下文轻松完成这项工作：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It's important to note that with a context such as `UserContext`, our app becomes
    much more manageable and scalable pertaining to everything about accessing the
    `user` object. Because the information becomes context info, as long as the component
    falls into this context, it can access it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，使用像`UserContext`这样的上下文，我们的应用在访问`user`对象方面变得更加易于管理和可扩展。因为信息变成了上下文信息，只要组件属于这个上下文，它就可以访问它。
- en: Now that we know how to read the user object, let's see if we can change it
    from `initialUser`, such as allowing the user to log in and out of the app.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何读取用户对象，让我们看看是否可以从`initialUser`中更改它，例如允许用户登录和退出应用。
- en: Changing the context value
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改上下文值
- en: 'Say we add a `Logo`. When this button is clicked, the current user is logged
    out, meaning their logo should no longer be available for display:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们添加一个`Logo`。当这个按钮被点击时，当前用户会注销，这意味着他们的标志将不再可用于显示：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, the `changeUser` function is provided via `UserContext`.
    It defines an `authenticated` flag based on whether the `username` is available.
    This flag can be used to decide whether the *UI* should display the **Logout**
    or **Login** button.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`changeUser`函数通过`UserContext`提供。它根据`username`是否存在定义了一个`authenticated`标志。这个标志可以用来决定*UI*是否应该显示**注销**或**登录**按钮。
- en: If the user is authenticated, the `onLogout` event handler is triggered to `changeUser`
    to an empty object, `{}`. `changeUser` is a dispatch function we defined earlier,
    and when it updates the `user`, it also propagates the update to all consumers,
    including the `Logo` component. Thus, when the next update arrives, `user` holds
    an empty object with no `username`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户经过认证作为`initialUser`发送到`App`，它将通过属性传递给`Header`和`Logo`。在`Logo`中，它通过其`imageUrl`属性和`username`被消费以显示一个标志。注意所有组件的接口都需要携带`user`属性。由于我们想在`Main`下显示问候消息，因此`user`也需要通过属性传递。
- en: 'If the user is not authenticated, the `onLogin` event handler is triggered
    where we can redirect the user to a `LoginForm` (the redirection code is omitted
    here):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户未认证，将触发`onLogin`事件处理器，我们可以将用户重定向到`LoginForm`（此处省略重定向代码）：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`LoginForm` also consumes the `UserContext` and reads the `changeUser` property.
    Upon successful submission of the form, we can use `changeUser` again to change
    the empty user into an authenticated user. Similarly, the new update propagates
    the update to all consumers, including `Logo` and `Greeting`. Thus, the user will
    see their logo and username in the top-right corner after logging in, as well
    as a greeting message on the main body. See *Figure 7.6*.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginForm`也消耗`UserContext`并读取`changeUser`属性。在表单成功提交后，我们可以再次使用`changeUser`将空用户更改为认证用户。同样，新的更新将传播到所有消费者，包括`Logo`和`Greeting`。因此，用户在登录后将在右上角看到他们的标志和用户名，以及在主体上的问候消息。参见*图7.6*。'
- en: User login and logout are generally important operations for a site because
    it has a direct impact on site authentication and authorization. Especially when
    refreshing the page entirely isn't an option, the context is a perfect fit in
    terms of reading and writing the user object without worrying about the out-of-sync
    moment among various components.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个网站来说，用户登录和注销通常是重要的操作，因为它对网站的认证和授权有直接影响。特别是当完全刷新页面不是一个选项时，上下文在读取和写入用户对象方面是一个完美的选择，无需担心各个组件之间的不同步时刻。
- en: Now that we have seen how a context update orchestrates the updating of all
    components in the event of a context change, let's take a look at two more examples
    using contexts in real applications.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了在上下文改变的情况下，上下文更新如何协调所有组件的更新，让我们看看两个使用上下文在真实应用中的示例。
- en: useContext examples
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useContext示例
- en: Context is used for sharing site-wise information, but it can be also very effective
    in sharing things in a narrower area. In this section, we'll see examples of both
    cases.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文用于共享网站级别的信息，但它也可以在更窄的范围内非常有效地共享事物。在本节中，我们将看到这两种情况的示例。
- en: Theme context
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主题上下文
- en: 'One nice and common usage involving a context is theming, which allows the
    user to switch between a light and dark theme based on their preference. See *Figure
    7.7*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个涉及上下文的好用且常见的用法是主题化，它允许用户根据他们的偏好在浅色和深色主题之间切换。参见*图7.7*：
- en: '![Figure 7.7 – A theme made with light and dark options'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.7 – 使用浅色和深色选项制作的主题'
- en: '](img/Figure_7.07_B17963.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.07_B17963.jpg](img/Figure_7.07_B17963.jpg)'
- en: Figure 7.7 – A theme made with light and dark options
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 使用浅色和深色选项制作的主题
- en: 'To implement this feature, let''s start with `ThemeContext`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个功能，让我们从`ThemeContext`开始：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can set the default theme with an object supporting a `mode` property, which
    is a string to hold either "light" or "dark".
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用支持`mode`属性的`对象`来设置默认主题，其中`mode`是一个字符串，可以包含“light”或“dark”。
- en: Design theme context
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计主题上下文
- en: 'Any component that requires the theme can read the settings from `ThemeContext`.
    Let''s build a theme-aware `Button` component:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 任何需要主题的组件都可以从`ThemeContext`中读取设置。让我们构建一个具有主题感知能力的`Button`组件：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can theme the button''s style based on the shared `mode` inside the `ButtonStyle`
    component:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据`ButtonStyle`组件内部的共享`mode`来为主题按钮的样式进行主题化：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`ButtonStyle` is a styled component applied on top of the host `button` component
    with modified *CSS*. It receives the `mode` prop and, based on that, we can define
    its `color` with either `"white"` or `"black"`. If you are interested in using
    `StyledComponent`, please check out the *Adopting CSS-in-JS approach* section
    of [*Chapter 10*](B17963_10_Epub.xhtml#_idTextAnchor363), *Building a Website
    with React*.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`ButtonStyle`是一个应用于宿主`button`组件的样式化组件，它具有修改后的*CSS*。它接收`mode`属性，基于此，我们可以使用`"white"`或`"black"`来定义其`color`。如果您对使用`StyledComponent`感兴趣，请查看[*第10章*](B17963_10_Epub.xhtml#_idTextAnchor363)的*采用CSS-in-JS方法*部分，*使用React构建网站*。'
- en: 'Based on this approach, we can build lots of other theme-aware components.
    And imagine a situation where we have a couple of them under `App`; in the event
    of the mode changing, they can all be flipped to their corresponding styles in
    a single update:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种方法，我们可以构建许多其他具有主题感知能力的组件。想象一下，如果我们有`App`下的几个这样的组件；在模式改变的情况下，它们可以在单个更新中切换到相应的样式：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now let''s talk about how to design a context. In the preceding theming case,
    we used `mode` to flip between themes, but we also can bake the exact style into
    it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈如何设计一个上下文。在前面的主题化案例中，我们使用了`mode`在主题之间切换，但我们也可以将确切的样式烘焙到其中：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding context, two individual colors for primary and secondary purposes
    are defined. This way, we can directly read the color in `Button`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的上下文中，定义了两种用于主要和次要目的的单独颜色。这样，我们就可以直接在 `Button` 中读取颜色：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's no right or wrong in terms of how we should design a context. The decision
    as to what property you should use is more or less based on how you want to consume
    these properties and design the components. In our case, the decision is more
    about whether the component should be based on `mode` or `primaryColor`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计上下文方面，没有对错之分。关于您应该使用哪个属性的决策，更多或更少地基于您想要如何消费这些属性并设计组件。在我们的案例中，决策更多关于组件是否应该基于
    `mode` 或 `primaryColor`。
- en: Apply theme manually
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动应用主题
- en: Using a theme for a group of components works out great with a theme context.
    However, sometimes there will be a requirement where we want to apply a theme
    to one particular component without touching the theme of all the other components.
    This normally applies to a nav header component that gets a different contrast
    color to the rest of the site.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主题为多个组件组工作得很好，尤其是在主题上下文中。然而，有时会有这样的需求，我们想要将主题应用于一个特定的组件，而不影响所有其他组件的主题。这通常适用于获得与网站其他部分不同对比色的导航标题组件。
- en: 'This problem can be solved by applying a context in a separate scope:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在单独的作用域中应用上下文，可以解决这个问题：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding `Header` component, another usage of `ThemeContext.Provider`
    is written to provide a different `mode` theme, while `App` has already been provided
    with a `mode` theme. Let's say the `App` theme is `'light'`; it changes to `'dark'`
    when it enters `Header`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `Header` 组件中，还写了一个 `ThemeContext.Provider` 的另一个用途，提供不同的 `mode` 主题，而 `App`
    已经提供了一个 `mode` 主题。假设 `App` 主题是 `'light'`；当它进入 `Header` 时，它变为 `'dark'`。
- en: When the theme-aware `Button` component gets updated, it looks for the closest
    ancestor that defines the provider. Since the ancestor found is `Header` instead
    of `App`, it reads the `'dark'` mode.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当主题感知的 `Button` 组件被更新时，它会寻找定义提供者的最近祖先。由于找到的祖先是 `Header` 而不是 `App`，它读取 `'dark'`
    模式。
- en: 'We are free to override parts of the context value instead of overriding the
    entire value:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以自由地覆盖上下文值的部分，而不是覆盖整个值：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding context, `Header` takes the current theme from the parent scope
    and overrides the `primaryColor` property to `'blue'`. Thus, all child consumers
    under `Header` see a modified theme setting.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的上下文中，`Header` 从父作用域中获取当前主题，并覆盖了 `primaryColor` 属性为 `'blue'`。因此，所有在 `Header`
    下的子消费者都看到了修改后的主题设置。
- en: Playground – Theme Context
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 主题上下文
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/xxLrwJy](https://codepen.io/windmaomao/pen/xxLrwJy).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自由地在这个在线示例中玩耍：[https://codepen.io/windmaomao/pen/xxLrwJy](https://codepen.io/windmaomao/pen/xxLrwJy).
- en: Now we see that a context is a perfect fit for site-wise subjects such as a
    theme. The context does not have to always be as big as a site; if we can identify
    an area, we should be able to apply a context to it. Let's take a look at an example
    where we apply the context to a targeted area such as a table.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到，上下文非常适合网站级别的主题，如主题。上下文不必总是像网站那样大；如果我们能识别一个区域，我们就应该能够将其应用于它。让我们看看一个例子，我们将上下文应用于一个目标区域，如表格。
- en: Table context
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表格上下文
- en: 'Another usage of context is to apply the context to a place that can be small
    but big enough to contain many relevant components inside, such as a table. See
    *Figure 7.8*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文的另一个用途是将上下文应用于一个可以很小但足够大以包含许多相关组件的地方，例如表格。参见 *图 7.8*：
- en: '![Figure 7.8 – A table containing customizable cell displays'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.8 – 包含可定制单元格显示的表格'
- en: '](img/Figure_7.08_B17963.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.08_B17963.jpg](img/Figure_7.08_B17963.jpg)'
- en: Figure 7.8 – A table containing customizable cell displays
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 包含可定制单元格显示的表格
- en: A table can be quite complex in a modern *UI*, where it contains a header, a
    body, a footer, pagination, and a customizable column setting to drive the look
    and feel of cells. Moreover, all these elements can be assembled in a mix-and-match
    way on the fly to suit different business purposes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 *UI* 中，一个表格可能相当复杂，因为它包含标题、主体、页脚、分页以及可定制的列设置，以驱动单元格的外观和感觉。此外，所有这些元素都可以即时混合匹配，以适应不同的业务目的。
- en: Customizing table cells
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义表格单元格
- en: 'A table is made up of rows and columns of cells where each cell can be controlled
    by a cell component such as `DefaultCell`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表格由单元格的行和列组成，其中每个单元格都可以由如 `DefaultCell` 这样的单元格组件控制：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The prop `value` is used to pass in a primitive value from a property of a row,
    such as a string or a number. In a typical case, we simply display it as a string
    format, as in the preceding code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 属性`value`用于从一个行的属性中传递一个原始值，例如一个字符串或一个数字。在典型情况下，我们简单地将其显示为字符串格式，就像前面的代码所示。
- en: 'Given a table row tracking a list of fruits:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个跟踪水果列表的表格行：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding column for `title` is a perfect example, and it should display
    a list of fruit names. However, not all cells are plain strings, since we can
    display a cell as a status indicator, a progress bar, a checkbox, and so on. In
    our case, we have a column for `status` indicating whether the fruit tastes nice
    or just OK, which can be handled by another cell behavior:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`title`列是一个完美的例子，它应该显示水果名称的列表。然而，并非所有单元格都是纯字符串，因为我们可以将单元格显示为状态指示器、进度条、复选框等。在我们的例子中，我们有一个表示水果是否美味或只是OK的`status`列，这可以通过另一个单元格行为来处理：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding custom `StatusCell` component, the value passed in is a boolean,
    and it displays either `'Nice'` or `'Ok'`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的自定义`StatusCell`组件中，传入的值是一个布尔值，它显示为`'Nice'`或`'Ok'`。
- en: 'This means we need a generic `TableCell` where we can pass in some sort of
    column information to customize the display:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要一个通用的`TableCell`，我们可以传入某种类型的列信息来定制显示：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding `TableCell` component, a `col` prop is provided to describe
    how a cell should update. Let''s take a look at the information in two columns
    for both `title` and `status`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`TableCell`组件中，提供了一个`col`属性来描述单元格应该如何更新。让我们看看`title`和`status`两列的信息：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For the second column, the `Cell` property is specified as a custom `StatusCell`,
    whereas the first column omits it, thus taking the `DefaultCell`. With this `col`
    capability, we can design a custom look and feel for all sorts of cells.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二列，`Cell`属性被指定为自定义的`StatusCell`，而第一列省略了它，因此使用了`DefaultCell`。通过这个`col`功能，我们可以为各种单元格设计自定义的外观和感觉。
- en: Design table context
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计表格上下文
- en: The example so far displays the cell based on the cell content, `row[col.name]`.
    As long as the column name matches the data stored in the row data, we should
    find the correct cell value. But sometimes, they might not match or, even worse,
    sometimes we need to display a cell based on multiple columns. For instance, to
    display a person's full name, we need the person's first name and last name, which
    are spread out across two columns. Only `row` can provide enough. But we only
    have a cell `value`. Where can we get a `row`?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的例子是基于单元格内容显示单元格，即`row[col.name]`。只要列名与行数据中存储的数据匹配，我们就应该找到正确的单元格值。但有时，它们可能不匹配，或者更糟糕的是，有时我们需要根据多个列来显示单元格。例如，为了显示一个人的全名，我们需要这个人的名字和姓氏，它们分布在两个列中。只有`row`可以提供足够的信息。但我们只有一个单元格`value`。我们能在哪里得到`row`？
- en: 'We can pass the `row` into each `TableCell` as a prop. But say we want to avoid
    the props approach to keep the cell interface flexible. In this case, we can create
    a `TableContext`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`row`作为属性传递给每个`TableCell`。但如果我们想避免使用属性方法以保持单元格接口的灵活性，我们可以这样做。在这种情况下，我们可以创建一个`TableContext`：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the preceding `TableContext`, we add a `row` property as well as `rows`
    and `cols` so that all consumers can share them. We can then provide it to each
    row of a table in the `TableRow` component:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`TableContext`中，我们添加了`row`属性以及`rows`和`cols`，以便所有消费者都可以共享它们。然后我们可以将其提供给`TableRow`组件中的每一行：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `TableRow` component is responsible for updating a row of the table. We
    use `TableContext` for two purposes here, one to get all the `cols` stored, and
    one to override the `row` property with one provided before providing the context
    back to each row. Now, when we get to each cell component, we should be able to
    get the current `row`. To demo it, we can set up another custom column for `''combo''`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`TableRow`组件负责更新表格中的一行。我们在这里使用`TableContext`有两个目的，一个是为了获取所有存储的`cols`，另一个是为了在将上下文返回给每一行之前，用之前提供的属性覆盖`row`属性。现在，当我们到达每个单元格组件时，我们应该能够获取当前的`row`。为了演示，我们可以为`''combo''`设置另一个自定义列：'
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The idea of the `''combo''` column is to join both `''title''` and `''status''`
    in a single cell via a custom `ComboCell` component:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`''combo''`列的想法是在单个单元格中通过自定义的`ComboCell`组件将`''title''`和`''status''`结合起来：'
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, we grab the current `row` info from `TableContext` and
    access both the `title` and `status` properties. With this approach, we can literally
    assemble any information from the current row. Also, notice that there's no props
    passed into this component. This means, as long as you import `TableContext`,
    you can design a custom cell anywhere you want. This decoupling, having no explicit
    dependency, should make us very comfortable designing a custom cell style on the
    fly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从`TableContext`中获取当前的`row`信息，并访问`title`和`status`属性。通过这种方法，我们可以从当前行组装任何信息。此外，请注意，没有将属性传递到这个组件中。这意味着，只要导入`TableContext`，你就可以在任何你想的地方设计一个自定义单元格。这种解耦，没有显式的依赖，应该使我们能够非常舒适地动态设计自定义单元格样式。
- en: We can argue, were we to provide the `row` directly to the `ComboCell`, we would
    achieve the same functionalities without the table context setup. That can be
    true. The choice of whether you pass the `row` as a prop or from a context impacts
    how you design the cells.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以争论，如果我们直接将`row`提供给`ComboCell`，我们就可以在不设置表格上下文的情况下实现相同的功能。这可能是对的。你选择是否将`row`作为属性或从上下文中传递会影响你如何设计单元格。
- en: In our case, passing `row` from a context does make the design a bit more flexible.
    Let's continue our example and see the usage of this `TableContext` in other places.
    Let's say this time that a cell needs to know more information, such as the `cols`
    settings, or even a piece of action associated with the table, such as deleting
    a row.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，从上下文中传递`row`确实使设计变得更加灵活。让我们继续我们的例子，看看在其他地方如何使用这个`TableContext`。假设这次一个单元格需要知道更多信息，比如`cols`设置，甚至与表格相关的一些操作，比如删除一行。
- en: 'Let''s take a look at one example where we delete a row of tables by clicking
    from a cell. Now, in order to manage the content of the table, we can provide
    a state `[rows, setRows]` to the `Table` component:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，通过点击单元格来删除表格的一行。现在，为了管理表格的内容，我们可以向`Table`组件提供一个状态`[rows, setRows]`：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the preceding code, the `Table` component is responsible for displaying
    all the rows of a table. The passed-in `rows` and `cols`, as well as a `setRows`
    dispatch function, are all sent to the `TableContext` provider to be consumed.
    With this, we can define a custom `DeleteCell` component:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Table`组件负责显示表格的所有行。传递的`rows`和`cols`以及`setRows`分发函数都被发送到`TableContext`提供者以供消费。有了这个，我们可以定义一个自定义的`DeleteCell`组件：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code, `DeleteCell` contains a `newRows`, by filtering out the
    current `row` and then uses the `setRows` dispatch function to replace the table
    content. Once `rows` is updated, it should trigger a provider update and thereby
    propagate a change to all table components.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`DeleteCell`包含一个`newRows`，通过过滤掉当前的`row`然后使用`setRows`分发函数来替换表格内容。一旦`rows`被更新，它应该触发提供者的更新，从而将更改传播到所有表格组件。
- en: Without a context to provide `setRows`, it would have to be passed through lots
    of layers to reach `DeleteCell`. Even in this brief example, the number of layers
    is not straightforward. Moreover, in this case, we don't exactly know the name
    of the component beforehand. It could be `DeleteCell` or `DefaultCell`, or any
    cell component that hasn't been designed yet. Therefore, the context usage here
    is really helpful in delivering things to an area underneath without knowing the
    exact location.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 没有上下文提供`setRows`，它必须通过许多层传递才能到达`DeleteCell`。即使在简短的例子中，层数也不是显而易见的。此外，在这种情况下，我们事先并不知道组件的名称。它可能是`DeleteCell`或`DefaultCell`，或者任何尚未设计的单元格组件。因此，这里的上下文使用对于将事物传递到未知的确切位置非常有帮助。
- en: Playground – Table Context
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 表格上下文
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/VwzWeMa](https://codepen.io/windmaomao/pen/VwzWeMa).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎免费尝试这个在线示例：[https://codepen.io/windmaomao/pen/VwzWeMa](https://codepen.io/windmaomao/pen/VwzWeMa)。
- en: 'Let''s conclude this table example by means of `Table` component usage under
    the `App` component:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在`App`组件下使用`Table`组件来总结这个表格例子：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We learned a really cool concept in this chapter, that is, a context. First,
    we got to know what is a context under *React*. We then dug deeper into the context
    design as well as how to consume it with a `useContext` hook. We then went through
    a context test drive by managing a user object for a site and further learned
    two more applications of applying contexts to the `Theme` and the `Table`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一个非常酷的概念，那就是上下文。首先，我们了解了在*React*中上下文是什么。然后，我们深入研究了上下文的设计以及如何使用`useContext`钩子来消费它。然后，我们通过管理一个网站的用户对象进行上下文测试驱动，进一步学习了将上下文应用于`Theme`和`Table`的两种更多应用。
- en: In the next chapter, we will get into our next hook in the *React* family and
    see how a ref can be used to hide private matters away from the engine.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进入React家族的下一个钩子，并看看如何使用ref将私人事务隐藏在引擎之外。
- en: Questions and answers
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题与答案
- en: 'The following are some questions and answers to refresh your knowledge:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些问题与答案，以帮助您巩固知识：
- en: What is a *React* context?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是*React*上下文？
- en: A *React* context is an identity that can be used to share a value with consumers.
    It's designed so that a value can be provided to a localized scope, hence all
    components within that scope can read from this shared value.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*React*上下文是一个可以用来与消费者共享值的身份。它被设计成可以提供一个值给局部作用域，因此该作用域内的所有组件都可以从这个共享值中读取。'
- en: What is the `useContext` hook?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useContext`钩子是什么？'
- en: The `useContext` hook is used in a consumer component so that it can read a
    context given by providers. A component can consume as many contexts as it can.
    When the provider gets updated, all the consumer components for that particular
    context get updated at the same time.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useContext`钩子在消费者组件中使用，以便它可以读取由提供者给出的上下文。一个组件可以消费尽可能多的上下文。当提供者更新时，该特定上下文的所有消费者组件将同时更新。'
- en: What's the common usage of `useContext`?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useContext`的常见用法是什么？'
- en: The `useContext` hook is a hook in the *React* hook family when it comes to
    an update involving an area of components. We often see this context usage in
    `User`, `Theme`, and `Table`, which requires the consumption of a value under
    an ancestor component without passing it explicitly through layers of components.
    The `useContext` hook also makes it possible to deliver a value to an area without
    knowing exactly where the destination is.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当涉及到组件区域更新时，`useContext`钩子是*React*钩子家族中的一个钩子。我们经常在`User`、`Theme`和`Table`中看到这种上下文用法，这需要在不通过组件层传递的情况下，在祖先组件下消费一个值。`useContext`钩子还使得向一个区域传递值成为可能，而不必确切知道目的地在哪里。
- en: Appendix
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: Appendix A – Propagating a context
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录A – 传播上下文
- en: 'React comes with different kinds of fibers. While a function component is one
    of them, the context provider is another one. It gets its own update logic with
    each update:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: React包含不同类型的纤维。虽然函数组件是其中之一，但上下文提供者又是另一种。它为每次更新都有自己的更新逻辑：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code, the `updateContextProvider` function takes in `fiber`,
    and checks whether it has been mounted or not via `oldProps !== null`. If it's
    a first-time mount, then it does things similar to a function component, reconciling
    the children into fibers and then returning the first child to work on next.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`updateContextProvider`函数接收`fiber`，并通过`oldProps !== null`检查它是否已经挂载。如果是首次挂载，那么它就会做一些类似于函数组件的事情，将子组件协调到纤维中，然后返回第一个子组件以供后续处理。
- en: 'If it''s not the first time, such as during an update, it then compares the
    `value` prop between `oldValue` and `newValue`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是首次挂载，例如在更新过程中，它就会比较`value`属性之间的`oldValue`和`newValue`：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If it turns out that there''s no change in the value provided from the strict
    equal comparison, `===`, and if there''s no change in the children, it then bails
    out the fiber and skips the reconciliation. Otherwise, if there''s a change in
    the value provided, it propagates the context change to all its consumer fibers
    via the `propagateContextChange` function:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从严格的相等比较`===`提供的值没有变化，并且子组件也没有变化，那么它就会退出纤维并跳过协调。否则，如果提供的值有变化，它将通过`propagateContextChange`函数将上下文变化传播到所有消费者纤维：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The propagation goes for a deep search under the `fiber` fiber and checks to
    see whether it contains the same `context` as per the `firstContext`. If it finds
    a match, it invokes a `scheduleWorkOnParentPath` function to schedule an update
    along the path from the root to the parent. This function is quite similar to
    `scheduleUpdateOnFiber`, which we see in the `useState` hook. But here, instead
    of doing it once, this function is applied to all consumers found.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fiber`纤维下进行深度搜索的传播检查是否包含与`firstContext`相同的`context`。如果找到匹配项，它将调用`scheduleWorkOnParentPath`函数来安排从根到父级的路径更新。这个函数与我们在`useState`钩子中看到的`scheduleUpdateOnFiber`非常相似。但在这里，这个函数不是只执行一次，而是应用于找到的所有消费者。
- en: In short, you can see that a provider is a special component that schedules
    an update for all consumers reading from the same context.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你可以看到提供者是一个特殊的组件，它为从同一上下文中读取的所有消费者安排更新。
- en: Appendix B – Context scope and value
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录B – 上下文作用域和值
- en: A context value changes under different scopes of a context. But what does this
    statement mean?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文值在不同的上下文作用域下发生变化。但这个陈述意味着什么呢？
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding convoluted example, can you guess what the output is if we
    invoke `provider1(1)`? Please take a minute to think. The answer is `3`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的复杂示例中，如果我们调用`provider1(1)`，你能猜到输出是什么吗？请花一分钟思考。答案是`3`。
- en: Because each function has a scope, within the scope of the function, all local
    variables from the input argument take precedence. Though the outer `value` is
    `1`, the inner `value` becomes `3` due to the change of scope.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个函数都有一个作用域，在函数的作用域内，所有从输入参数传入的局部变量都有优先权。尽管外部的`value`是`1`，但由于作用域的改变，内部的`value`变成了`3`。
- en: The context provider is designed in a similar fashion; it uses a stack to push
    the old value in before entering one scope, and then pop the old value out after
    leaving the same scope. This way, an outer scope is always kept in memory when
    we work in an inner scope.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文提供者以类似的方式设计；在进入一个作用域之前，它使用堆栈将旧值推入，然后在离开相同的作用域后弹出旧值。这样，当我们在一个内部作用域中工作时，总是将外部作用域保持在内存中。
- en: 'Let''s take a look at this process closely. Say `cursor` holds the value in
    one outer scope, and it wants to enter the inner scope with a new `value`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这个过程。假设`cursor`在一个外部作用域中持有值，并且它想要带着新的`value`进入内部作用域：
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding code, `cursor` is a global variable, which holds the current
    value under the `current` property. The `push` operation puts the old value in
    the stack and then replaces the current value of `cursor` with the new `value`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`cursor`是一个全局变量，它持有`current`属性下的当前值。`push`操作将旧值放入堆栈，然后替换`cursor`的当前值为新值。
- en: 'Therefore, once we enter the inner scope, the `current` of `cursor` is updated
    to the latest, so how do we get back the old value once we finish this inner scope?
    Yes, we perform a `pop` operation:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦我们进入内部作用域，`cursor`的`current`就会更新为最新值，那么我们如何在完成这个内部作用域后恢复旧值呢？是的，我们执行一个`pop`操作：
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding code, we pop the previous stacked value back to the `cursor`.
    So now, when we get out of the inner scope, the value gets back to the old value.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将之前的堆叠值弹回到`cursor`。因此，当我们从内部作用域退出时，值会恢复到旧值。
- en: 'This mechanism is exactly what''s applied to our context provider:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制正是应用于我们的上下文提供者：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When it gets to the update of a provider, it pushes the old value and replaces
    it with a new value with a `pushProvider` function:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当它到达提供者的更新时，它使用`pushProvider`函数将旧值推入并替换为新值：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The last line of `pushProvider` sets the `_currentValue` of the context with
    the `nextValue` from the `value` prop. This is how the consumer in the inner scope
    gets the inner value. But before that, it pushes an old value of `_currentValue`
    in the stack and stores it in a global variable, `valueCursor`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushProvider`的最后一行使用`value`属性的`nextValue`将上下文的`_currentValue`设置为上下文。这就是内部作用域中的消费者如何获得内部值。但在那之前，它将`_currentValue`的旧值推入堆栈，并将其存储在全局变量`valueCursor`中。'
- en: 'Before we move out of the provider''s scope, `popProvider` is invoked:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开提供者的作用域之前，调用`popProvider`：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The last line of `popProvider` sets the `currentValue` of the context back to
    the saved value from `valueCursor`. But before that, it pops the old value from
    the stack.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`popProvider`的最后一行将上下文的`currentValue`设置回从`valueCursor`保存的值。但在那之前，它从堆栈中弹出旧值。'
- en: So, at all times, there's a `valueCursor` to hold the outer scope value, while
    `context._currentValue` holds the current/inner scope value. This means that the
    context value stored in `_currentValue` is not a fixed value throughout the update.
    Hopefully, you can now see that a context has a "global" sense and varies based
    on the scope.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在所有时候，都有一个`valueCursor`来持有外部作用域的值，而`context._currentValue`则持有当前/内部作用域的值。这意味着存储在`_currentValue`中的上下文值在整个更新过程中并不是一个固定值。希望你现在可以明白，上下文具有“全局”的概念，并且根据作用域而变化。
