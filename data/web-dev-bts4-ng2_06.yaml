- en: Chapter 6. Dependency Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。依赖注入
- en: This chapter is about dependency injection that teaches you how to decouple
    the requirements of an application and how to create a consistent source of data
    as a service. You will learn about Injector and Provider classes. We will also
    discuss Injectable decorator that is required for the creation of an object.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了依赖注入，教您如何解耦应用程序的需求以及如何创建一个一致的数据源作为服务。您将了解注入器和提供者类。我们还将讨论Injectable装饰器，这是创建对象所必需的。
- en: 'At the end of the chapter, you will have a solid understanding of:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将对以下内容有扎实的理解：
- en: What is dependency injection?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是依赖注入？
- en: Separation of concerns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点的分离
- en: Creating a service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个服务
- en: The injector and provider classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入器和提供者类
- en: Injectable and inject decorators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Injectable和inject装饰器
- en: Creating data services for our application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序创建数据服务
- en: What is dependency injection?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是依赖注入？
- en: Here, I will talk about the concept of **dependency injection** with some concrete
    examples that will hopefully demonstrate the problems it tries to solve and the
    benefits it gives to the developer. Angular is mostly based on dependency injection,
    which you may or may not be familiar with. If you already know the concept of
    dependency injection, you can safely skip this chapter and just read the next
    one.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将讨论**依赖注入**的概念，并提供一些具体的例子，希望能够演示它试图解决的问题以及它为开发人员带来的好处。Angular主要基于依赖注入，您可能已经熟悉或不熟悉。如果您已经了解依赖注入的概念，可以安全地跳过本章，直接阅读下一章。
- en: Dependency injection is probably one of the most famous design patterns I know,
    and you have probably already used it. I think it is one of the most difficult
    ones to explain well, partly due to the nonsense examples used in most introductions
    to dependency injection. I have tried to come up with examples that fit the Angular
    world better.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入可能是我所知道的最著名的设计模式之一，您可能已经使用过它。我认为这是最难解释清楚的设计模式之一，部分原因是由于大多数依赖注入介绍中使用的无意义的例子。我尝试提出更适合Angular世界的例子。
- en: A real-life example
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个现实生活的例子
- en: Imagine, you start your own business, and tend to travel a lot by air, so you
    need to arrange flights. You are always booking the flight yourself using the
    phone number of the airline agency.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您开了自己的业务，经常需要乘飞机出差，所以需要安排航班。您总是使用航空公司的电话号码自己预订航班。
- en: 'Thus your typical travel planning routine might look like the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您的典型旅行计划例程可能如下所示：
- en: Decide the destination, and desired arrival date and time
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定目的地和期望的到达日期和时间
- en: Call up the airline agency and convey the necessary information to obtain a
    flight booking
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给航空公司打电话，传达必要的信息以预订航班
- en: Pick up the tickets and be on your way
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取票并上路
- en: 'Now, if you suddenly change the preferred agency, and its contact mechanisms,
    you would be subject to the following relearning scenarios:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您突然更改了首选机构及其联系机制，您将受到以下重新学习情景的影响：
- en: The new agency, and its new contact mechanisms (say the new agency offers Internet
    based services and the way to make the bookings is over the Internet instead of
    over the phone)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的机构及其新的联系机制（假设新机构提供基于互联网的服务，预订方式是通过互联网而不是通过电话）
- en: The typical conversational sequence through which the necessary bookings get
    done (data instead of voice)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必要的预订通过的典型对话顺序（数据而不是语音）
- en: You need to adjust yourself to the new scenario. It could lead to a substantial
    amount of time spent on the readjustment process.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要调整自己以适应新情景。这可能会导致大量时间花在重新调整过程上。
- en: Assume your business is growing and you get a secretary in the company, so whenever
    you needed to travel, you send an email to him or her to just state the destination,
    desired arrival date and time. The flight reservations are made for you and the
    tickets get delivered to you.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的业务正在发展，你在公司里雇了一个秘书，所以每当你需要出差时，你只需给他或她发送一封电子邮件，说明目的地、期望的到达日期和时间。机票会为你预订好，并送到你手上。
- en: Now if the preferred agency gets changed, the secretary would become aware of
    the change, and would perhaps readjust his or her workflow to be able to communicate
    with the agency. However, you would have no relearning required. You still continue
    to follow the same protocol as before, since the secretary makes all the necessary
    adaptation in a manner that means you do not need to do anything differently.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果首选机构发生了变化，秘书会意识到这种变化，并可能重新调整他或她的工作流程，以便与机构进行沟通。然而，你不需要重新学习。你仍然按照以前的协议继续，因为秘书以一种方式进行了所有必要的适应，这意味着你不需要做任何不同的事情。
- en: 'In both the scenarios, you are the client and are dependent upon the services
    provided by the agency. However, the second scenario has a few differences:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你都是客户，并且依赖机构提供的服务。然而，第二种情况有一些不同之处：
- en: You don't need to know the contact point of the agency—the secretary does it
    for you
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要知道机构的联系点——秘书会为你做这件事
- en: You don't need to know the exact conversational sequence by which the agency
    conducts its activities via voice, email, website, and so on, as you are aware
    of a particular standardized conversational series with the secretary
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要知道机构通过语音、电子邮件、网站等方式进行活动的确切对话顺序，因为你知道与秘书的特定标准对话序列
- en: The services you are dependent upon are provided to you in a manner that you
    do not need to readjust should the service provider change
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你所依赖的服务以一种方式提供给你，如果服务提供者发生变化，你不需要重新调整
- en: That is dependency injection in *real life* .
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是*现实生活*中的依赖注入。
- en: Dependency injection
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'Both, the Angular and custom components we used in our project are a part of
    a set of collaborating components. They depend upon each other to complete their
    intended purpose, and they need to know:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目中使用的Angular和自定义组件都是一组协作组件的一部分。它们彼此依赖以完成其预期目的，并且它们需要知道：
- en: Which components to communicate with?
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要与哪些组件进行通信？
- en: Where to locate them?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在哪里找到它们？
- en: How to communicate with them?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与它们沟通？
- en: 'When the way to access is changed, such changes can potentially require the
    source of a lot of components to be modified. Here are the plausible solutions
    we can use to prevent dramatic changes of components:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问方式发生变化时，这些变化可能需要修改许多组件的源。以下是我们可以使用的可能解决方案，以防止组件的剧烈变化：
- en: We can embed the logic of location and instantiation as part of our usual logic
    of components
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将位置和实例化的逻辑嵌入到我们通常的组件逻辑中
- en: We can create the *external* piece of code to assume the responsibility of location
    and instantiation and supply the references when necessary
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建*外部*代码片段来承担位置和实例化的责任，并在必要时提供引用
- en: We can look at the last solution as the  *secretary* from our *real life* example.
    We don't need to change the code of components when the way to locate any external
    dependency changes. This solution is the implementation of dependency injection,
    where an *external* piece of code is part of Angular Framework.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将最后一个解决方案看作是我们*现实生活*示例中的*秘书*。当定位任何外部依赖项的方式发生变化时，我们不需要更改组件的代码。这个解决方案是依赖注入的实现，其中一个*外部*代码片段是Angular框架的一部分。
- en: The use of dependency injection requires the declaration of the components and
    lets the framework work out of the complexities of instantiation, initialization,
    sequencing, and supplying the references as needed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖注入需要声明组件，并让框架处理实例化、初始化、排序和根据需要提供引用的复杂性。
- en: 'Passing of a dependency into a dependent object that would use it is a dependency
    injection. A component can accept a dependency in at least three common ways:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将依赖项传递给使用它的依赖对象是依赖注入。组件可以以至少三种常见方式接受依赖项：
- en: '**Constructor injection** : In this, the dependencies are provided through
    a class constructor.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数注入**：在这种情况下，依赖项通过类构造函数提供。'
- en: '**Setter injection** : In this, the injector utilizes the component exposed
    setter methods to inject the dependency.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Setter注入**：在这种情况下，注入器利用组件公开的setter方法来注入依赖项。'
- en: '**Interface injection** : In this, the dependency provides a method that will
    inject the dependency into any component passed to it.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口注入**：在这种情况下，依赖项提供了一个方法，该方法将依赖项注入到传递给它的任何组件中。'
- en: Constructor injection
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: 'This method requires the component to provide a parameter in a constructor
    for the dependency. We injected the `Router` instance in the code of the `ProductGridService`
    component:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法要求组件在构造函数中提供依赖项的参数。我们在`ProductGridService`组件的代码中注入了`Router`实例：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Constructor injection is the most preferable method and can be used to ensure
    the component is always in a valid state, but its lacks the flexibility of being
    able to change its dependencies later.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数注入是最可取的方法，可以用来确保组件始终处于有效状态，但它缺乏能够稍后更改其依赖项的灵活性。
- en: Other injection methods
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他注入方法
- en: Setter and interface methods are not implemented in the Angular framework.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Setter和接口方法在Angular框架中没有实现。
- en: Components versus services
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件与服务
- en: 'Angular 2 distinguishes the code of a web application on:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2在Web应用程序的代码上有所区别：
- en: The components that represent the visual part
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表视觉部分的组件
- en: The reusable data services
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用的数据服务
- en: The data service is a simple class that provides methods for returning or updating
    some data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 数据服务是一个简单的类，提供了返回或更新一些数据的方法。
- en: ReflectiveInjector
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReflectiveInjector
- en: A `ReflectiveInjector` is an injection container that we use as a replacement
    for a `new` operator we are using to resolve the constructor dependencies automatically.
    When code in an application asks about dependencies in the constructor, the `ReflectiveInjector`
    resolves them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReflectiveInjector`是一个注入容器，我们将其用作替代`new`运算符，用于自动解析构造函数的依赖项。当应用程序中的代码询问构造函数中的依赖项时，`ReflectiveInjector`会解析它们。'
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With a `resolveAndCreate` method, the `ReflectiveInjector` creates an instance
    of `Injector` . We are passing the array of service providers into the injector
    to configure it, or it won't know how to create them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`resolveAndCreate`方法，`ReflectiveInjector`创建了一个`Injector`的实例。我们将服务提供者数组传递给注入器以配置它，否则它将不知道如何创建它们。
- en: With an `Injector` , creating a `ProductGridService` is very easy, because it
    takes full responsibility of providing and injecting the `ActivatedRoute` into
    the `ProductGridService` .
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Injector`，创建`ProductGridService`非常容易，因为它完全负责提供和注入`ActivatedRoute`到`ProductGridService`中。
- en: Let's talk about why we imported and applied the `Injectable` decorator to the
    class?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论为什么我们导入并应用了`Injectable`装饰器到类中？
- en: Injectable decorator
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可注入装饰器
- en: We create multiple types in the application for particular needs. Some of them
    may have dependencies to others. We must mark any type available for an injector
    with an `Injectable` decorator. Injector uses class constructor metadata to get
    the parameter types and determine dependent types for instantiation and injection.
    Any dependent type must be marked with `Injectable` decorator or injector will
    report an error when trying to instantiate it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序中为特定需求创建多种类型。其中一些可能依赖于其他类型。我们必须使用`Injectable`装饰器标记任何可用于注入器的类型。注入器使用类构造函数的元数据来获取参数类型，并确定实例化和注入的依赖类型。任何依赖类型都必须用`Injectable`装饰器标记，否则在尝试实例化时，注入器将报告错误。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Add `@Injectable()` to every service class to prevent dependency injection errors.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个服务类添加`@Injectable()`以防止依赖注入错误。
- en: We must import and apply the `Injectable` decorator to all class of our services
    explicitly to make them available to an injector for instantiation. Without this
    decorator, the Angular doesn't know about the existence of those types.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须显式地为我们的所有服务类导入和应用`Injectable`装饰器，以使它们可用于注入器进行实例化。没有这个装饰器，Angular就不知道这些类型的存在。
- en: Inject decorator
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入装饰器
- en: 'As I mentioned, the Injector uses a class constructor metadata to determine
    dependent types:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所提到的，注入器使用类构造函数的元数据来确定依赖类型：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Injector uses the TypeScript generated metadata to inject the instance of `ActivatedRoute`
    type into the constructor. For injecting the TypeScript primitives such as `string`
    , `boolean` , or array we should define and use the Opaque Token:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注入器使用TypeScript生成的元数据将`ActivatedRoute`类型的实例注入到构造函数中。对于注入TypeScript原语，如`string`、`boolean`或数组，我们应该定义并使用Opaque
    Token：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, with the `APP_TITLE` token defined we can use it in the registration of
    dependency provider:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了定义的`APP_TITLE`标记，我们可以在依赖提供者的注册中使用它：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We use the `@Inject` decorator when we inject the application title into any
    constructor of our application:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将应用程序标题注入到我们应用程序的任何构造函数中时，我们使用`@Inject`装饰器：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will talk about tokens shortly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快会谈到标记。
- en: Optional decorator
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选装饰器
- en: 'In cases when class has optional dependencies, we can use the `@Optional` decorator
    to mark the constructor parameters:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在类具有可选依赖项的情况下，我们可以使用`@Optional`装饰器来标记构造函数参数：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I added the conditional statement into the code above because I expected that
    `config` property will equal `null` .
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我在上面的代码中添加了条件语句，因为我预期`config`属性将等于`null`。
- en: Configuring the injector
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置注入器
- en: 'In the preceding example, I used the `resolveAndCreate` method of the `ReflectiveInjector`
    to create `Injector` , but in real life, it''s not necessary:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我使用了`ReflectiveInjector`的`resolveAndCreate`方法来创建`Injector`，但在现实生活中，这是不必要的。
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Angular framework creates an application-wide injector for us during the
    Bootstrap of the application:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的启动过程中，Angular框架为我们创建了一个应用程序范围的注入器：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We must configure the injector via registering the providers that create the
    services our application requires. We can do that in two ways:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须通过注册创建应用程序所需服务的提供者来配置注入器。我们可以通过两种方式来做到这一点：
- en: Register a provider within an `NgModule`
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`NgModule`中注册提供者
- en: Register a provider in an `AppComponent`
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`AppComponent`中注册提供者
- en: Which one is best? The services injected into the `AppModule` are widely available
    in the entire application and can be injected into lazy-loading modules and their
    components. The services injected into the `AppComponent` are available only to
    this component and its children and are not available to lazy-loading modules.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 哪一个更好？注入到`AppModule`中的服务在整个应用程序中都是广泛可用的，并且可以注入到惰性加载模块及其组件中。注入到`AppComponent`中的服务仅对该组件及其子组件可用，并且不可用于惰性加载模块。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Register application-wide providers in the root `AppModule` , not in the `AppComponent`
    .
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在根“AppModule”中注册应用程序范围的提供者，而不是在“AppComponent”中。
- en: 'We can configure injector with alternative providers under the right circumstances:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在适当的情况下配置注入器以使用替代提供者：
- en: Provided an object behaves or looks like the original one
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的对象行为或外观与原始对象相似
- en: Provides a substitute class
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供替代类
- en: Provides a factory function
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个工厂函数
- en: 'For example for `AppModule` class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如对于“AppModule”类：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We used a short-hand expression when registering the provider in the injector.
    Angular transforms it into the following verbose format:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册注入器中提供者时，我们使用了一种简写表达式。Angular将其转换为以下冗长格式：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `provide` property in the first place is the *token* that serves as the
    key for:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先的“provide”属性是作为键的*标记*：
- en: Locating a dependency value
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位依赖值
- en: Registering the provider
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册提供者
- en: The second property, `useClass` , is a definition object similar to many other
    *use* things such `useValue` , `useExisting` , and others. and tells the framework
    how to create the dependency. With the help of the *use* definitions, we can quickly
    switch implementations, define constants and factory functions. Let's look at
    all of them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个属性“useClass”是一个类似于许多其他*use*东西的定义对象，如“useValue”、“useExisting”等，并告诉框架如何创建依赖关系。借助*use*定义，我们可以快速切换实现，定义常量和工厂函数。让我们来看看它们。
- en: Class providers
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类提供者
- en: 'Most of the time we will utilize the `useClass` definition to ask the different
    class to provide the service. We can create our own `BetterRouter` class as an
    extension of the original one and register it such that:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们将利用“useClass”定义来要求不同的类提供服务。我们可以创建我们自己的“BetterRouter”类作为原始类的扩展，并注册它，如下所示：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The injector knows how to build `BetterRouter` and will sort it out.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注入器知道如何构建“BetterRouter”并将其解决。
- en: Aliased class providers
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 别名类提供者
- en: 'In scenarios when we need to use many providers of the same singleton, we can
    use the `useExisting` definition:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要使用同一个单例的许多提供者的情况下，我们可以使用“useExisting”定义：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Look at the following example where `useExisting` helps organize mock requests:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子，“useExisting”如何帮助组织模拟请求：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code below demonstrates how to use the `MockBackend` instead of the real
    one, making AJAX requests:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码演示了如何使用“MockBackend”而不是真实的后端，进行AJAX请求：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Another useful place for `useExisting` is in providing multiple values of custom
    pipes, custom directives, or custom validators:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: “useExisting”另一个有用的地方是提供自定义管道、自定义指令或自定义验证器的多个值：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With the help of the `multi` option, it is possible to add the `CustomValidatorDirective`
    to the default collections to have it available globally in the application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 借助“multi”选项，可以将“CustomValidatorDirective”添加到默认集合中，使其在应用程序中全局可用。
- en: Value providers
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值提供者
- en: 'Sometimes we need to use a configuration object, string or function in our
    application is not always an instance of a class. Here the interface defines the
    structure of configuration:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要在应用程序中使用配置对象、字符串或函数，并不总是类的实例。在这里，接口定义了配置的结构：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can register the ready-made objects with the `useValue` definition. There
    is no `Config` class, so we cannot use it for the token. Instead, we can use a
    string literal to register and resolve dependencies:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用“useValue”定义注册现成的对象。没有“Config”类，所以我们不能用它来作为标记。相反，我们可以使用字符串字面量来注册和解析依赖项：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And now we can inject it into any constructor with the help of `@Inject` decorator:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过“@Inject”装饰器将其注入到任何构造函数中：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Unfortunately, using string tokens opens up a potential for naming collisions.
    Angular comes to the rescue and provides an elegant solution with `Opaque Token`
    for non-class dependencies:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用字符串标记会导致命名冲突的潜在问题。Angular提供了一个优雅的解决方案，使用`Opaque Token`来处理非类依赖项：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are registering the `CUSTOM_CONFIG` in the injector with the value provider:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用值提供者在注入器中注册`CUSTOM_CONFIG`：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inject it into any constructor:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将其注入到任何构造函数中：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Multiple values
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个值
- en: 'With the help of the `multi` option it is possible to add other values to the
    same binding later:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 借助`multi`选项，可以随后向相同的绑定添加其他值：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Somewhere in the code we can get multiple values of the `languages` :'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的某个地方，我们可以获得`languages`的多个值：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Factory providers
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工厂提供者
- en: In cases when we need to create the dependent value dynamically based on information
    changed at any moment after the Bootstrap has happened, we can apply the `useFactory`
     definition.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要根据在引导程序发生后的任何时刻更改的信息动态创建依赖值的情况下，我们可以应用`useFactory`定义。
- en: Let's imagine we use `SecurityService` to authorize the user.`CategoryService`
    must know facts about the user. The authorization can change during the user session
    because he or she can log in and log out at any moment many times. The direct
    injection `SecurityService` into `CategoryService` creates a precedent to inject
    it into all services of the application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们使用`SecurityService`来授权用户。`CategoryService`必须了解有关用户的信息。授权可以在用户会话期间动态更改，因为他或她可以随时多次登录和注销。直接将`SecurityService`注入`CategoryService`会导致将其注入到应用程序的所有服务中。
- en: 'The solution is quite neat, use the primitive Boolean `authorization` property
    instead of `SecurityService` to control `CategoryService` :'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案非常巧妙，使用原始的布尔`authorization`属性来控制`CategoryService`，而不是使用`SecurityService`：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The authorized property will update dynamically, so we cannot use a value provider,
    but we have to take over the creation of a new instance of the `CategoryService`
    with a factory function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 授权属性将动态更新，因此我们不能使用值提供者，而必须通过工厂函数接管创建新的`CategoryService`实例：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the factory provider we inject the `SecurityService` along with the factory
    function:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在工厂提供者中，我们将`SecurityService`与工厂函数一起注入：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The hierarchy of injectors
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入器的层次结构
- en: Angular 1 has only one injector across the application, and it manages the creation
    and resolving of all dependencies quite nicely. Every registered dependency becomes
    a singleton, so only one instance of it is available across the application. That
    solution has a side effect where you need to have more than one instance of the
    same dependency injecting into different parts of the application. Because the
    Angular 2 application is a tree of components, the framework has a **hierarchical
    dependency injection** system—the tree of injectors exists in parallel to the
    component tree of the application. Every component has an injector of its own
    or shared with other components at the same level in the tree. When the component
    at the bottom of the tree requests a dependency, Angular tries to find it with
    a provider registered in that component's injector. If the provider doesn't exist
    on this level, the injector passes the request to its parent injector and so on
    until finding the injector that can handle the request. Angular throws an exception
    if it runs out of ancestors. This solution helps us to create different instances
    of the same dependency on various levels and components. The particular service
    instance is still a singleton, but only in the scope of the host component instance
    and its children.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 1在整个应用程序中只有一个注入器，并且它很好地管理了所有依赖项的创建和解析。每个注册的依赖项都变成了单例，因此在整个应用程序中只有一个实例可用。这种解决方案有一个副作用，即您需要在应用程序的不同部分注入相同依赖项的多个实例。因为Angular
    2应用程序是一个组件树，该框架具有**分层依赖注入**系统——注入器树与应用程序的组件树并行存在。每个组件都有自己的注入器，或者与树中同一级别的其他组件共享。当树底部的组件请求依赖项时，Angular会尝试在该组件的注入器中查找已注册的提供者。如果该级别上不存在提供者，注入器会将请求传递给其父注入器，依此类推，直到找到能够处理请求的注入器。如果祖先用尽，Angular会抛出异常。这种解决方案帮助我们在不同级别和组件上创建相同依赖项的不同实例。特定服务实例仍然是单例，但仅在主机组件实例及其子级的范围内。
- en: 'Let''s start:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: Open Terminal, create folder `ecommerce` and move in
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开终端，创建名为`ecommerce`的文件夹并进入其中
- en: Copy the contents of the project from the folder `chapter_6/1.ecommerce-seed`
    into the new project
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目的内容从文件夹`chapter_6/1.ecommerce-seed`复制到新项目中
- en: 'Run the following script to install `npm` modules:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行以下脚本以安装`npm`模块：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Start the TypeScript watcher and lite server with next command:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令启动TypeScript监视器和轻量级服务器：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This script opens the web browser and navigates to the welcome page of the project.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将打开Web浏览器并导航到项目的欢迎页面。
- en: Category service
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类别服务
- en: I mentioned in [Chapter 5](text00047.html#page "Chapter 5. Routing") , *Routing*
    , about the necessity to decouple the data from the presentation logic when implementing
    SPA. I partially realized it in the category and product views. The `CategoryListComponent`
    and `WelcomeComponent` use category returns from the `getCategories` function.
    Right now it is not suffering, but when we start getting and updating data from
    the server, we will need more functions. Better hide the implementation detail
    inside the single reusable data service class to use it in multiple components.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第5章](text00047.html#page "第5章。路由")中提到了*路由*，在实现SPA时，需要将数据与呈现逻辑解耦的必要性。我在类别和产品视图中部分实现了这一点。`CategoryListComponent`和`WelcomeComponent`使用了从`getCategories`函数返回的类别。现在它还没有受到影响，但当我们开始从服务器获取和更新数据时，我们将需要更多的函数。最好将实现细节隐藏在单个可重用数据服务类中，以便在多个组件中使用它。
- en: Let's refactor the category data acquisition business to a single service that
    provides categories, and share that service with all components that need them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将类别数据获取业务重构为一个提供类别的单一服务，并与所有需要它们的组件共享该服务。
- en: 'Rename the `category.ts`  to `category.service.ts` to follow a name convention
    in which we spell the name of a service in lowercase followed by `.service` .
    If the service name is multi-word, we will spell the base filename in lower `dash-case`
    . Add an import statement to the top of the file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `category.ts` 重命名为 `category.service.ts`，以遵循服务名称以小写字母拼写，后跟 `.service` 的命名约定。如果服务名称由多个单词组成，我们将以小写的
    `dash-case` 拼写基本文件名。在文件顶部添加一个导入语句：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now create the `CategoryService` class and move the `categories` variable,
    `getCategories` and `getCategory` functions inside:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建 `CategoryService` 类，并将 `categories` 变量、`getCategories` 和 `getCategory`
    函数移到其中。
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Don't forget to add `this` to all references to `categories` property.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将对 `categories` 属性的所有引用添加 `this`。
- en: Injector provider for category service
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别服务的注射器提供者
- en: 'We must register a service provider with the injector to tell Angular how to
    create the service. The best place to do that is in the `providers` property of
    a `NgModule` . We need only one instance of categories per application, so when
    we import the `CategoryModule` into the `AppModule` , Angular will register and
    create the singleton from the `CategoryService` class available across the whole
    application. Open the `category.module.ts` file, import the `CategoryService`
    and change `@NgModule` decorator with the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在注射器中注册服务提供者，告诉 Angular 如何创建服务。这样做的最佳位置是在 `NgModule` 的 `providers` 属性中。我们只需要一个类别的实例，所以当我们将
    `CategoryModule` 导入 `AppModule` 时，Angular 将注册并创建来自 `CategoryService` 类的单例，可在整个应用程序中使用。打开
    `category.module.ts` 文件，导入 `CategoryService` 并使用以下代码更改 `@NgModule` 装饰器：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Move to your web browser and open the browser console. We get a full bunch
    of issues, mostly about the wrong name of file `category.ts` was renamed to `category.service.ts`
    . We can easily fix that issue. Another problem is the use of the functions `getCategory`
    and `getCategories` . To fix that issue we need to import the `CategoryService`
    :'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 转到您的网络浏览器并打开浏览器控制台。我们会收到一大堆问题，主要是关于文件名错误，`category.ts` 被重命名为 `category.service.ts`。我们可以轻松解决这个问题。另一个问题是使用函数
    `getCategory` 和 `getCategories`。为了解决这个问题，我们需要导入 `CategoryService`：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And inject it into constructors in all the necessary places such that:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其注入到所有必要位置的构造函数中：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Move initialization of all variables inside the constructor for now, similar
    to `categories` in the preceding example.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时将所有变量的初始化移动到构造函数中，类似于前面示例中的 `categories`。
- en: Product service
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品服务
- en: 'Rename the `product.ts`  to `product.service.ts` . Create the class `ProductService`
    and move the `products` variable, `getProducts` and `getProduct` functions into
    it:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `product.ts` 重命名为 `product.service.ts`。创建 `ProductService` 类，并将 `products`
    变量、`getProducts` 和 `getProduct` 函数移到其中：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Fix the `import` in all classes to have references on old methods.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 修复所有类中的 `import`，以引用旧方法。
- en: Injector provider for product service
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品服务的注射器提供者
- en: 'We follow the same procedure for `ProductService` to register a service provider.
    Because we need only one instance of service per application, we can register
    it in the `ProductModule` . Open the `product.module.ts` file, import the `ProductService`
    and change the `@NgModule` decorator with the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `ProductService` 采取相同的步骤来注册服务提供者。因为我们只需要一个应用程序中的服务实例，所以我们可以在 `ProductModule`
    中注册它。打开 `product.module.ts` 文件，导入 `ProductService` 并使用以下代码更改 `@NgModule` 装饰器：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now restart the application to see all of your products and categories again:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新启动应用程序，以再次查看所有产品和类别：
- en: '![Injector provider for product service](Image00105.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![产品服务的注射器提供者](Image00105.jpg)'
- en: Tip
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code for this at `chapter_6/2.ecommerce-di` .
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `chapter_6/2.ecommerce-di` 找到此源代码。
- en: The shopping cart
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车
- en: A shopping cart is a piece of software that acts as an online store's catalog
    and allows users to select items for eventual purchase. It's known as a shopping
    basket. A shopping cart (or basket) allows a user to collect items while browsing
    an online catalog of products. The user should click on the **Buy Now** button
    to add the selected item to the cart. The total amount and number of items in
    the cart presents in the navigation bar component. The user is able to move to
    a checkout or view the cart to manage the number of purchased items.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车是一种软件，充当在线商店的目录，并允许用户选择最终购买的商品。它被称为购物篮。购物车（或篮子）允许用户在浏览产品在线目录时收集商品。用户应单击“立即购买”按钮将所选商品添加到购物车中。购物车中的总金额和商品数量显示在导航栏组件中。用户可以转到结账或查看购物车以管理购买商品的数量。
- en: 'The cart must store the items the user puts in the cart. The items should be:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车必须存储用户放入购物车中的商品。商品应该是：
- en: Fetchable to be able to display the cart content
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可获取以显示购物车内容
- en: Updatable to be able to change the quantity of an item in the cart
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可更新以更改购物车中商品的数量
- en: Removable
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可移除
- en: 'With this in mind, let''s first create the basic cart functionality: adding,
    updating, and deleting items and defining a barebones item class and walk through
    the code usage.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们首先创建基本的购物车功能：添加、更新和删除商品，并定义一个简单的项目类，并浏览代码的使用。
- en: Let's create the `cart` folder and `cart.service.ts` file inside. We will keep
    the model definition implemented as the `Cart` and the `CartItem` inside that
    file as well as the `CartService` .
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建“cart”文件夹和“cart.service.ts”文件。我们将在该文件中实现模型定义，如“Cart”和“CartItem”，以及“CartService”。
- en: The Cart model and CartItem
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 购物车模型和CartItem
- en: 'At the beginning, the `Cart` class needs an internal array for storing all
    the `items` in the cart:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，“Cart”类需要一个内部数组来存储购物车中的所有“items”：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, it must `count` the number and keep the `amount` of all items. The `CartItem`
    is an interface defining the structure of data the cart can use:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它必须“计算”所有项目的数量并保持“金额”。 “CartItem”是一个定义购物车可以使用的数据结构的接口：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The CartService
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 购物车服务
- en: 'The `CartService` keeps the `cart` instance to make it available across the
    whole application:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: “CartService”保持“cart”实例，以使其在整个应用程序中可用：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `addProduct` method should add items to the cart:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: “addProduct”方法应将商品添加到购物车中：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The method takes one argument of type `Product` and tries to find the item containing
    the same one. The method needs to increment the number of products and increase
    the amount of the found cart item. Otherwise, it creates the new `CartItem` instance
    and assigns the product to it. After all, it is growing the total number of items
    and amount in the shopping cart.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个“Product”类型的参数，并尝试找到包含相同产品的项目。该方法需要增加产品数量并增加找到的购物车项目的金额。否则，它将创建新的“CartItem”实例并将产品分配给它。最后，它增加了购物车中的总商品数量和金额。
- en: 'Next, the `removeProduct` method of the class can be used to remove the product
    quickly from the cart:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，该类的“removeProduct”方法可用于快速从购物车中删除产品：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The method takes one argument of product type and tries to find the item containing
    the same one. The method needs to decrement the number of goods associated with
    this item cart. It removes the cart item which includes no one product. In the
    end, it reduces the total number of items and amount in the shopping cart.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个产品类型的参数，并尝试找到包含相同产品的项目。该方法需要减少与此购物车项目相关联的商品数量。它删除包含零个产品的购物车项目。最后，它减少了购物车中的总商品数量和金额。
- en: 'Method `removeItem` removes the particular item and reduces the total number
    of items and amount in the shopping cart:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: “removeItem”方法删除特定项目，并减少了购物车中的总商品数量和金额：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following private method `findItem` helps to find `CartItem` by `Product`
    id:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下私有方法`findItem`帮助通过`Product` id找到`CartItem`：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The last private method, `remove` , decreases the number of items in the cart:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个私有方法`remove`，减少了购物车中商品的数量：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The Cart menu component
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 购物车菜单组件
- en: The key aspect that I find must present on the shopping cart design is that,
    at first glance, the user should be able to find out how many items there are
    in the shopping cart. You need to keep your user informed about how many items
    are in the shopping cart so that users are aware of what they have added to the
    cart without having to use the dropdown.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为购物车设计中必须存在的关键方面是，用户一眼就能看到购物车中有多少商品。您需要让用户了解购物车中有多少商品，这样用户就可以在不使用下拉菜单的情况下知道他们添加了什么商品到购物车中。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure shoppers can easily see the items in their cart and that they appear
    above the fold rather than on another page.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 确保购物者可以轻松看到购物车中的商品，并且它们出现在页面上方，而不是在另一页上。
- en: That is quite a significant UX design pattern. If you keep the shopping cart
    content somewhere in the sidebar or near the top right of your pages, you are
    removing extra steps in the checkout process and making it easier for shoppers
    to move throughout the site and keep track of items and order totals the whole
    time.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的UX设计模式。如果你将购物车内容保留在侧边栏或页面右上方附近，你就可以简化结账流程，让购物者更容易在网站上移动并随时跟踪商品和订单总额。
- en: '![The Cart menu component](Image00106.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![购物车菜单组件](Image00106.jpg)'
- en: 'With this in mind, let''s create the `cart-menu.component.ts` and  `cart-menu.component.html`
    . Copy and paste the following code into the `cart-menu.component.ts` file:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们创建`cart-menu.component.ts`和`cart-menu.component.html`。将以下代码复制并粘贴到`cart-menu.component.ts`文件中：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The purpose of the local `cart` variable is to represent on view the content
    and update it with changes that happen after the user adds or removes the product
    to the cart.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 本地`cart`变量的目的是在视图上表示内容，并在用户添加或移除产品到购物车后更新它。
- en: 'We display the total number of items and amount in the label of the drop-down
    menu:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在下拉菜单的标签中显示商品总数和金额：
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Pay attention to the currency pipe with the following parameters:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意带有以下参数的货币管道：
- en: The first parameter is the ISO 4217 currency code, such as `USD` for the US
    dollar and `EUR` for the euro.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是ISO 4217货币代码，例如`USD`代表美元，`EUR`代表欧元。
- en: '* At the second place is a Boolean indicating whether to use the currency symbol
    (example `$` ) or the currency code (example `USD` ) in the output'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '* 第二个位置是一个布尔值，指示是否在输出中使用货币符号（例如`$`）或货币代码（例如`USD`）'
- en: At the last place we add the digit info in the next format: `minIntegerDigits.minFractionDigits-maxFractionDigits`
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最后一个位置，我们以以下格式添加数字信息：`minIntegerDigits.minFractionDigits-maxFractionDigits`
- en: I recommend using this pipe here and in all other places where you need to display
    the amount of currency.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在这里和所有其他需要显示货币金额的地方使用这个管道。
- en: 'We display the contents of the cart inside a Bootstrap 4 table:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Bootstrap 4表格中显示购物车的内容：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At the bottom of the menu, we display the total amount and two buttons to navigate
    to `Cart` and `Checkout` :'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜单底部，我们显示总金额和两个按钮，用于跳转到`购物车`和`结账`：
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Cart module
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 购物车模块
- en: 'Let''s add the `CartManuComponent` and `Cart Service` into the `CartModule`
    to make them easily accessible in the entire application:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`CartManuComponent`和`Cart Service`添加到`CartModule`中，以便在整个应用程序中轻松访问它们：
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We need to add the `CartModule` into the `AppModule` :'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将`CartModule`添加到`AppModule`中：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Update the Navbar
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新导航栏
- en: 'Open the `navbar.component.html` and find the cart placeholder:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`navbar.component.html`并找到购物车占位符：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Change it to look more elegant:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为更加优雅的样式：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Update the Cart via Service
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过服务更新购物车
- en: 'And the last thing we must to do is inject the `CartService` into the `ProductGrid`
    component and start to listen to `addToCart` events. In the method with the same
    name we call the `addProduct` of `CartService` to add the selected goodie into
    the shopping cart:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的最后一件事是将`CartService`注入到`ProductGrid`组件中，并开始监听`addToCart`事件。在同名方法中，我们调用`CartService`的`addProduct`将所选商品添加到购物车中：
- en: '[PRE52]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, try to click on **Buy Now** on different products and see changes happen
    in the navigation bar. Click the dropdown to display the shopping cart content:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试点击不同产品上的**立即购买**，并查看导航栏中发生的变化。单击下拉菜单以显示购物车内容：
- en: '![Update the Cart via Service](Image00107.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![通过服务更新购物车](Image00107.jpg)'
- en: Tip
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code at `chapter_6/3.ecommerce-cart` .
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter_6/3.ecommerce-cart`找到源代码。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You will now be familiar with the dependency injection that Angular relies heavily
    on. As we've seen, we split our Angular code into visual components and services.
    Each of them depend upon one another, and dependency injection provides referential
    transparency. Dependency injection allows us to tell Angular what services our
    visual components depend on, and the framework will resolve these for us.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将熟悉Angular依赖注入的使用。正如我们所见，我们将Angular代码分成了可视组件和服务。它们彼此依赖，并且依赖注入提供了引用透明性。依赖注入允许我们告诉Angular我们的可视组件依赖于哪些服务，框架将为我们解决这些问题。
- en: We created the classes for products and categories to hide the functionality
    into reusable services. Plus, we created the shopping cart component and service
    and wired the last to products, so the user can add the products to the cart.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了产品和类别的类，以将功能隐藏到可重用的服务中。此外，我们创建了购物车组件和服务，并将最后一个与产品连接起来，以便用户可以将产品添加到购物车中。
- en: In [Chapter 7](text00066.html#page "Chapter 7. Working with Forms") , *Working
    with Forms* , we will talk about how to use Angular 2 directives related to form
    creation and how to link a code based form component to the HTML form. Plus we
    will continue to build the project we started to develop in previous chapters.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](text00066.html#page "第7章. 处理表单")中，*处理表单*，我们将讨论如何使用与表单创建相关的Angular 2指令，以及如何将基于代码的表单组件链接到HTML表单。此外，我们将继续构建我们在前几章中开始开发的项目。
- en: 读累了记得休息一会哦~
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Booklist sharing
- en: 书友学习交流
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
