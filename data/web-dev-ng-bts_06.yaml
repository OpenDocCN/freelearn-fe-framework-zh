- en: Building Angular Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Angular组件
- en: Since the whole of Angular is composed of several interrelated parts, it's virtually
    impossible to select one part of Angular as being more important than another.
    The removal of any one of these parts renders the whole compromised—maybe even
    useless. Having said that, if I had to pick one part that was really important,
    I'd pick components. There are several really cool things about components, such
    as how when we build components, we are basically also extending HTML, since we're
    creating custom HTML tags. Components are TypeScript classes, and as we'll see
    a bit later on in this chapter, the way we link our code to our custom HTML tag
    is via the `@Component` annotation. I'll also explain what annotations are later
    in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整个Angular由几个相互关联的部分组成，几乎不可能选择Angular的某一部分比其他部分更重要。删除其中任何一个部分都会使整个系统受损，甚至可能变得无用。话虽如此，如果我必须选择一个真正重要的部分，我会选择组件。组件有几个非常酷的特点，比如当我们构建组件时，我们基本上也在扩展HTML，因为我们正在创建自定义HTML标签。组件是TypeScript类，正如我们稍后在本章中将看到的那样，我们将代码链接到自定义HTML标签的方式是通过`@Component`注释。我也会在本章后面解释注释是什么。
- en: 'A quick word on the terminology used from this point forward: I''ve used the
    word *parts* instead of the word *components* in order to avoid confusion, since
    the word *component*is an overloaded word—it has different meanings in different
    contexts. Additionally, I use the word *page* from a classical web application
    perspective, as opposed to the literal sense, when talking about a view (that
    is, a screen).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后使用的术语简要说明：我使用“部分”一词而不是“组件”一词，以避免混淆，因为“组件”一词是一个多义词-在不同的上下文中有不同的含义。此外，当谈论视图（即屏幕）时，我从经典的Web应用程序角度使用“页面”一词，而不是字面意义上的意思。
- en: Angular applications contain a single root component. However, when discussing
    an application's screens or views, it is necessary to mention other components
    that act as root components for that view. For example, the sign-up screen has
    a root component.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Angular应用程序包含一个根组件。但是，在讨论应用程序的屏幕或视图时，有必要提及其他充当该视图的根组件的组件。例如，注册屏幕有一个根组件。
- en: 'Here''s a bullet point list of topics that we''re going to cover together:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将一起涵盖的主题的项目列表：
- en: An Angular application as a tree of components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Angular应用程序作为组件树
- en: The `@Component` annotation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Component`注释'
- en: Properties of the `@Component` annotation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Component`注释的属性'
- en: Content projection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容投影
- en: Life cycle hooks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期钩子
- en: Component interface
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件接口
- en: Components that are needed to implement the three wireframes that are associated
    with this chapter
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要实现与本章相关的三个线框的组件
- en: Angular application architecture – a tree of components
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular应用程序架构-组件树
- en: An Angular application is basically a tree of components. As we've learned in
    previous chapters, Angular is an SPA framework and thus has a single page to leverage
    for displaying its tree of components. We've seen that Angular has a single top-level
    component, called the root component, and depending on what we'd like our application
    to do in response to our user's actions, we have that root component load up other
    components. These other components (let's refer to them as *secondary root components*
    for now) in turn recursively render additional components. The way in which we've
    wired up our router in [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing*, is that we've mapped URLs to our *secondary root components—*one per
    *page*, which springs into view when our users click on the navigational (that
    is, menu) links.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 应用程序基本上是一个组件树。正如我们在之前的章节中学到的，Angular 是一个单页面应用程序框架，因此有一个单页面来展示其组件树。我们已经看到
    Angular 有一个顶层组件，称为根组件，根据我们希望应用程序对用户操作做出的响应，我们让根组件加载其他组件。这些其他组件（暂时称它们为*次级根组件*）反过来递归地渲染其他组件。我们在[第4章](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml)中设置路由的方式是将
    URL 映射到我们的*次级根组件*，每个*页面*一个组件，当用户点击导航（即菜单）链接时，它们就会显示出来。
- en: What makes all this possible is that components are composable. This is to say
    that our components are made up of other components, and are thus nested. We can
    nest our components in an arbitrarily deep component hierarchy, hence the statement
    at the very beginning of this section, *An Angular application is basically a
    tree of components*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是可能的原因是组件是可组合的。这意味着我们的组件由其他组件组成，因此是嵌套的。我们可以在任意深的组件层次结构中嵌套我们的组件，因此在本节的开头就有了这样的陈述，*Angular
    应用程序基本上是一个组件树*。
- en: The Angular framework takes care of recursively loading and rendering our components
    for us.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 框架会递归地加载和渲染我们的组件。
- en: Architecting an Angular application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计 Angular 应用程序
- en: Just as is the case with most engineering projects, software projects also need
    to have a process for designing and architecting applications. The typical way
    to start is to break down whatever you're building into separate chunks of work.
    In Angular's vernacular, this means that we need to break down our application
    into separate components, each of which is responsible for certain things, such
    as displaying the result of a calculation, or accepting user input.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数工程项目一样，软件项目也需要有一个设计和架构应用程序的过程。开始的典型方式是将你正在构建的东西分解成独立的工作块。在 Angular 的术语中，这意味着我们需要将我们的应用程序分解成独立的组件，每个组件负责某些事情，比如显示计算结果或接受用户输入。
- en: Once we have a list of components that we need to use (whether they are third-party
    components or custom components), we need to treat them as black boxes—or mathematical
    functions. Let me explain what I mean by this.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了需要使用的组件列表（无论是第三方组件还是自定义组件），我们需要把它们当作黑匣子——或数学函数。让我解释一下我的意思。
- en: When I say we need to treat our components as black boxes, I'm suggesting that
    we should not let our mind be consumed with their implementation at this stage
    (that is, when we are simply listing them). We'll concern ourselves with building
    our components a little later in the chapter, but for now, treating them as black
    boxes is all we need to do.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说我们需要把组件当作黑匣子对待时，我是在建议我们不应该在这个阶段（即我们只是列举它们时）让我们的思绪被它们的实现所占据。我们将在本章稍后关注构建我们的组件，但现在，把它们当作黑匣子就足够了。
- en: When I say we need to treat our components as mathematical functions, I'm merely
    suggesting that we think about what the output is going to be, and what inputs
    are needed for the function (that is, our component). The inputs and outputs of
    our components make up their public interfaces. We'll be taking a closer look
    at component interfaces a bit later in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说我们需要把组件当作数学函数来对待时，我只是建议我们考虑输出会是什么，以及函数（也就是我们的组件）需要什么输入。组件的输入和输出构成了它们的公共接口。我们稍后会更仔细地研究组件接口。
- en: Breaking up your components into sub-components
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将你的组件分解为子组件
- en: 'The number of components in an application, or even per page, for that matter,
    varies greatly. It can range from just a few to several hundred—or maybe even
    more. However, there is a good rule of thumb for how far you should go in breaking
    up a component (such as a sub-component that is the top-level component for that
    specific page) into sub-components. If you keep component reusability in mind,
    all you need to ask yourself as you break down the component into sub-components
    is this: "Are there two or more parts to this component that I can reuse elsewhere?"
    If the answer is yes, you can probably benefit from breaking it down further.
    If the answer is no, then you''re done—no more breaking down of the component
    is necessary.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序中的组件数量，甚至每个页面中的组件数量，都各不相同。它可以从几个到几百甚至更多。然而，对于将组件（比如作为特定页面的顶级组件的子组件）分解为子组件，有一个很好的经验法则。如果你记住了组件的可重用性，当你将组件分解为子组件时，你只需要问自己这个问题：“这个组件有两个或更多部分可以在其他地方重用吗？”如果答案是肯定的，你可能会受益于进一步分解。如果答案是否定的，那么你就完成了，不需要再进一步分解组件。
- en: Let's consider a quick example, just to make this a bit less abstract. Assume
    that you have a listing of items on a page—one row per item—and the item is a
    component. Let's also assume that each item has a thumbnail image for whatever
    that item is. If the thumbnail can be used elsewhere, maybe on the checkout page,
    or on the item detail page, then that thumbnail should be its own component and
    a sub-component of the item component.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的例子，只是为了让这个问题不那么抽象。假设你在页面上有一个商品清单，每个商品占据一行，商品就是一个组件。我们还假设每个商品都有一个缩略图，用于显示该商品。如果缩略图可以在其他地方使用，比如在结账页面或商品详细页面，那么这个缩略图应该是它自己的组件，是商品组件的子组件。
- en: 'Zooming out a bit from the item listing example, and starting from the page
    view, you may take this approach to help you get started when planning your components:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从商品清单示例中放大一点，从页面视图开始，你可以采取这种方法来帮助你在规划组件时开始：
- en: Your page header is a component
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的页面页眉也是一个组件
- en: You may have a quick-links section on the right-hand side of your page, which
    would be another component
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能在页面右侧有一个快速链接部分，这也将是另一个组件
- en: You have your main content section, taking up the majority of your screen real
    estate, which would also be a component
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有你的主要内容部分，占据了大部分屏幕空间，这也将是一个组件
- en: Your page footer is also a component
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的页面页脚也是一个组件
- en: From the preceding components, all of them are likely to be reusable, except
    for the main content section. You may desire your page header, and page footer,
    to be on every page within your application—and you may want to re-display the
    quick-links section on various pages. For these reasons, those components are
    probably fine as they are. No further breakdown is required. The reason you will
    want to break down your main content component is that it's not reusable because
    you're not likely to have two copies of the same page!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的组件中，所有这些组件都可能是可重用的，除了主要内容部分。您可能希望您的页面标题和页面页脚出现在应用程序中的每个页面上，并且您可能希望在各个页面上重新显示快速链接部分。出于这些原因，这些组件可能已经很好了。不需要进一步的拆分。您需要拆分主要内容组件的原因是它不可重用，因为您不太可能拥有相同页面的两个副本！
- en: Component responsibilities
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件责任
- en: Angular applications that are architected will have components that are not
    only reusable but have well-defined boundaries. This is to say that they have
    a separation of concerns. Each component does one thing and does it well. The
    components should be abstracted away from one another, and they should not know
    about each other's details (that is, implementation). The one thing that they
    should know about each other is how to communicate with each other. This is accomplished
    via their public interfaces, and we'll look at this shortly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 被架构化的Angular应用程序将具有不仅可重用而且有明确定义边界的组件。也就是说，它们具有关注点分离。每个组件只做一件事，并且做得很好。这些组件应该相互抽象，它们不应该了解彼此的细节（即实现）。它们应该了解彼此的唯一事情是如何与彼此通信。这是通过它们的公共接口实现的，我们很快会看到这一点。
- en: For now, all you need to know is that when you plan your application's components,
    you should list their responsibilities. That is, write down what they will be
    doing. Astute readers will probably see the connection between the use case diagrams
    and the lists of component responsibilities, since components are how users will
    be interacting with the application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您需要知道的是，当您计划应用程序的组件时，您应该列出它们的责任。也就是说，写下它们将要做什么。敏锐的读者可能会看到用例图和组件责任列表之间的联系，因为组件是用户将如何与应用程序交互的方式。
- en: Annotations
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解
- en: Annotations are a new feature of TypeScript. They are symbols, prefixed with
    the `@` sign, that we add to our code (that is, used to decorate our classes).
    Annotations can appear at the top of our class declaration, or at the top of our
    functions, or even on top of our class properties. What annotations do, generally
    speaking, is inject boilerplate code where they are attached (that is, our class,
    function, or properties). While we don't need annotations, since we can choose
    to write the boilerplate code ourselves, we're better off leveraging them because
    the boilerplate code shouldn't have to be written over and over again. Additionally,
    by using annotations instead of handwriting the boilerplate code, not only is
    the drudgery removed, but we don't have error-prone code to contend with. We'll see
    more annotations in various chapters of the book, but let's focus on the `@Component` and
    `@NgModule` decorators for this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是TypeScript的一个新特性。它们是以`@`符号为前缀的符号，我们将其添加到我们的代码中（即用于装饰我们的类）。注解可以出现在我们的类声明顶部，或者在我们的函数顶部，甚至在我们的类属性顶部。一般来说，注解的作用是在它们附加的地方（即我们的类、函数或属性）注入样板代码。虽然我们不需要注解，因为我们可以选择自己编写样板代码，但我们最好利用它们，因为样板代码不应该一遍又一遍地编写。此外，通过使用注解而不是手写样板代码，不仅可以消除单调乏味，而且我们不必处理容易出错的代码。我们将在本书的各个章节中看到更多的注解，但让我们专注于本章的`@Component`和`@NgModule`装饰器。
- en: '@Component'
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Component'
- en: While annotations can appear at the top of our class declaration, or at the
    top of our functions, or even on top of our class properties, the `@Component`
    annotation will always appear at the top of our component's class declaration.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然注解可以出现在我们的类声明顶部，或者在我们的函数顶部，甚至在我们的类属性顶部，但`@Component`注解将始终出现在我们组件类声明的顶部。
- en: 'In order for the `@Component` annotation to become available to us, we have
    to import it like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`@Component`注解对我们可用，我们必须像这样导入它：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's look at that line of code for just a moment. It is JavaScript—specifically,
    ES6\. If you recall from [Chapter 2](82376b53-6401-4844-9440-7ba76a2fb6a2.xhtml),
    *ECMAScript and TypeScript Crash Course*, the part of the curly braces of the
    statement is a new construct in ES6 called *destructuring*. Also, there is no
    explicit path to the `@angular/core` module. We leave it to the CLI and TypeScript
    compiler to figure out where the module is, and exactly how it should be loaded
    and made available to the code in our class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看一下那行代码。这是JavaScript，具体来说是ES6。如果你还记得[第2章](82376b53-6401-4844-9440-7ba76a2fb6a2.xhtml)中的*ECMAScript和TypeScript速成课程*，这个语句的大括号部分是ES6中称为*解构*的新构造。此外，没有明确的路径指向`@angular/core`模块。我们让CLI和TypeScript编译器来找出模块在哪里，以及如何加载和使其在我们的类中可用。
- en: Properties of the @Component decorator
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Component装饰器的属性'
- en: The `@Component` decorator provides us with a number of properties for the purposes
    of configuring our components. Let's take a look at them.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Component`装饰器为配置我们的组件提供了许多属性。让我们来看看它们。'
- en: selector
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择器
- en: 'The `selector` is a property of the `@Component` annotation, and its value
    (of type string) is what gives the name to our custom HTML tag. I like cars, so
    here''s an example `car` component in code, showing its annotation, selector,
    and class name:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`selector`是`@Component`注解的一个属性，它的值（类型为字符串）是为我们的自定义HTML标签命名的。我喜欢汽车，所以这里有一个`car`组件的示例代码，显示了它的注解、选择器和类名：'
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When Angular sees our custom HTML tags, `<car></car>`, it creates an instance
    of our `CarComponent` and will replace our custom tags with some HTML that the
    browser actually understands. OK, but where in our component class do we add stuff
    to give our component something more than a ghostly aura? The next section is
    the answer (that is, the `template` property).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当Angular看到我们的自定义HTML标签`<car></car>`时，它会创建我们的`CarComponent`的一个实例，并将我们的自定义标签替换为浏览器实际理解的一些HTML。好的，但是在我们的组件类中，我们在哪里添加东西，使我们的组件不再只是一个幽灵般的光环？下一节就是答案（即`template`属性）。
- en: template and templateUrl
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板和模板URL
- en: 'Our poor little `car` component has no visible body just yet. This is because
    Angular needs to know what browser-friendly HTML to add when it renders our `car`
    component, and we just haven''t provided that for Angular yet. The way to provide
    that is to use the `template` property (of type string) to hold the HTML that
    Angular will render for us after it creates the instance of the `CarComponent`
    class (any time it sees our custom tags, `<car></car>`). Let''s rectify this by
    beefing up our preceding `@Component` annotation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可怜的小`car`组件目前还没有可见的主体。这是因为Angular需要知道在渲染我们的`car`组件时要添加什么浏览器友好的HTML，而我们还没有为Angular提供这个。提供的方法是使用`template`属性（类型为字符串）来保存Angular在创建`CarComponent`类的实例后将为我们渲染的HTML（每当它看到我们的自定义标签`<car></car>`时）。让我们通过加强我们之前的`@Component`注解来纠正这一点：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What would happen if our component required a lot of HTML? Well, this is why
    we have another property that we can use, `templateUrl`*.* The`templateUrl` property
    provides us with a way to externalize our component''s HTML from our component
    class and have it in a separate file. Your `template` property would look something
    like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的组件需要大量HTML会发生什么？好吧，这就是为什么我们有另一个可以使用的属性，`templateUrl`*。*`templateUrl`属性为我们提供了一种将组件的HTML从组件类外部化并放在单独文件中的方法。您的`template`属性看起来可能是这样的：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: styles and stylesUrls
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: styles和stylesUrls
- en: 'The `styles` property is used for what you expect it to be used for—to add
    styling to our component template. Just like the `template` property, the value
    is of type string. Also, because it''s easiest to read CSS when spaced over multiple
    lines, we''ll be using the back-tick character (new in ES6, and thus also available
    in TypeScript), which enables us to create what is known as *template literals*.
    Let''s add the `styles` parameter to our `CarComponent` class to see how this
    may look:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`styles`属性用于您期望的用途-向我们的组件模板添加样式。就像`template`属性一样，值的类型是字符串。此外，因为在多行上间隔CSS最容易阅读，我们将使用反引号字符（在ES6中是新的，因此也在TypeScript中可用），它使我们能够创建所谓的*模板文字*。让我们向`CarComponent`类添加`styles`参数，看看这可能是什么样子：'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That's all there is to the `styles` property. I bet you can guess what the `styleUrls`
    property does. Yup—it works just like the `templateUrl` property. It provides
    us with a way to externalize our component's CSS from our component class and
    having it in externalized style sheets. Note that I mentioned *files*, as in the
    plural of *file*. The `styleUrls` property takes a value of an array of strings
    (as opposed to being of type String as what the value of the `templateUrl` property
    is)—thus, we can pass multiple style sheets to it if we wanted to*.*
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`styles`属性的全部内容。我敢打赌你可以猜到`styleUrls`属性的作用。是的-它的工作原理就像`templateUrl`属性一样。它为我们提供了一种将组件的CSS从组件类外部化并将其放在外部样式表中的方法。请注意，我提到了*文件*，即*文件*的复数形式。`styleUrls`属性接受字符串数组的值（与`templateUrl`属性的值的类型为字符串相反）-因此，如果我们想要，我们可以将多个样式表传递给它*。*
- en: So, by using a combination of the template, `templateUrl`, styles, and `styleUrls`
    properties, we can encapsulate the HTML (that is, our component template), and
    the CSS we'd like to apply to our template, within our component class—thanks
    to the properties that the `@Component` annotation makes available to us. And
    thanks to the `selector` property, we can use custom HTML tags in our components'
    parent templates. Are you starting to get a good feel for how all these things
    fit together? If not, no worries—you soon will, when we start to implement our
    example application's views.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过使用模板，`templateUrl`，styles和`styleUrls`属性的组合，我们可以将HTML（即我们的组件模板）和我们想要应用于模板的CSS封装在我们的组件类中-感谢`@Component`注释为我们提供的属性。由于`selector`属性，我们可以在组件的父模板中使用自定义HTML标记。您开始对所有这些东西如何组合在一起有了良好的感觉吗？如果没有，别担心-当我们开始实现示例应用程序的视图时，您很快就会明白。
- en: View encapsulation
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图封装
- en: View encapsulation is something that is extremely convenient and very cool—as
    most things in Angular are—and is used to configure the scope of our CSS.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 视图封装是非常方便和非常酷的东西-就像Angular中的大多数东西一样-用于配置我们的CSS的范围。
- en: Typically, when we create (or change) a CSS class, the style is applied throughout
    our application and is not confined to a specific page, component, and so on.
    Angular gives us a level of control over this by allowing us to encapsulate (that
    is, restrict, or contain) our styles to the components that contain the given
    style sheets/CSS. This is done through another property of the `@Component` annotation, named `encapsulation`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们创建（或更改）CSS类时，样式会应用于整个应用程序，而不限于特定页面、组件等。Angular通过允许我们将样式封装（即限制或包含）到包含给定样式表/CSS的组件中，为我们提供了对此的一定程度的控制。这是通过`@Component`注释的另一个属性`encapsulation`来实现的。
- en: 'We can set the encapsulation of our component''s styles to one of the following
    three possible values:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将组件样式的封装设置为以下三个可能值之一：
- en: '`ViewEncapsulation.Emulated`: This is the default value and the effect is that
    our styles will remain contained to just our component. They will not affect anything
    else on our page(s). However, our component will still inherit, or have access
    to, styles that are globally accessible to our application.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewEncapsulation.Emulated`: 这是默认值，效果是我们的样式将仅限于我们的组件。它们不会影响我们页面上的其他任何东西。但是，我们的组件仍将继承或访问全局可访问的样式。'
- en: '`ViewEncapsulation.Native`: This is basically the same thing as `ViewEncapsulation.Emulated`,
    except that we are asking Angular to block, or shield, our component from any
    globally defined styles. The effect is that our component will be immune from
    any styles that are not assigned to our `@Component` annotation''s `styles` or
    `styleUrls` properties.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewEncapsulation.Native`: 这基本上与`ViewEncapsulation.Emulated`相同，只是我们要求Angular阻止或保护我们的组件免受任何全局定义的样式影响。效果是我们的组件将免受未分配给我们`@Component`注释的`styles`或`styleUrls`属性的任何样式的影响。'
- en: '`ViewEncapsulation.None`: This is the setting that we would use if we didn''t
    want to control the level of CSS isolation at all. In other words, if we wanted
    to let our component''s CSS affect other page assets, and also wanted our component
    to inherit globally defined CSS rulesets, this is the setting that we would use.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewEncapsulation.None`: 这是我们会使用的设置，如果我们不想控制CSS隔离的级别。换句话说，如果我们希望让我们组件的CSS影响其他页面资产，并且还希望我们的组件继承全局定义的CSS规则集，这就是我们会使用的设置。'
- en: Is this cool or what? What a feature! If you think about it, this is one of
    the things that make code reuse, even between applications, not just within the
    same application, possible. If we want to guarantee that our component will look
    the same across Angular applications, regardless of any given application's styles,
    we can set our component's `encapsulation` property to `ViewEncapsulation.Native`
    and we're good to go.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷，不是吗？多么棒的功能！如果你仔细想想，这是使代码重用成为可能的事情之一，甚至在不同的应用程序之间，而不仅仅是在同一个应用程序中。如果我们想要保证我们的组件在Angular应用程序中看起来相同，无论任何给定应用程序的样式如何，我们可以将我们组件的`encapsulation`属性设置为`ViewEncapsulation.Native`，然后就可以了。
- en: Module versus NgModule
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块与NgModule
- en: Terminology is everything because it is easy to confuse things due to their
    semantics. This is especially true when the language/terms in the topics in question
    contain overloaded words—as with Angular as the topic. For instance, we've seen
    that we have to be pretty specific about what we mean by the words *component* and
    *page*. The same thing applies to the word *module,* and so I'd like to clear
    something up at this point before we continue on.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 术语非常重要，因为由于语义的原因很容易混淆事物。当涉及的主题中的语言/术语包含重载词时，这一点尤为真实，就像Angular作为主题一样。例如，我们已经看到，我们必须非常明确地说明我们所说的*组件*和*页面*的含义。同样的事情也适用于*模块*这个词，所以在继续之前，我想在这一点上澄清一些事情。
- en: As we've seen in [Chapter 2](82376b53-6401-4844-9440-7ba76a2fb6a2.xhtml), *ECMAScript
    and TypeScript Crash Course*, the notion of modules is new in ES6\. In JavaScript,
    when we talk about a module, we are usually referring to a code file that we can
    then import into the context of our executing script, making its encapsulated
    functions available to our script. An Angular module, or `NgModule`, is a module
    consisting of more than one file—hence, it's often referred to as a package. Because
    we treat this `NgModule`, or package, in much the same way as a JavaScript module—by
    importing it—we often think of them as being equivalent, but they are not.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](82376b53-6401-4844-9440-7ba76a2fb6a2.xhtml)中所看到的，*ECMAScript和TypeScript速成课*，模块的概念在ES6中是新的。在JavaScript中，当我们谈论模块时，通常是指一个代码文件，然后我们可以将其导入到我们执行脚本的上下文中，使其封装的函数对我们的脚本可用。Angular模块，或`NgModule`，是由多个文件组成的模块，因此通常被称为包。因为我们像导入JavaScript模块一样对待这个`NgModule`或包，我们经常认为它们是等价的，但它们并不是。
- en: This chapter's focus is on components, but we will also take a look at constructing
    our own `NgModules` in [Chapter 11](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml),
    *Dependency Injection and Services*, when we encapsulate our calls to our backend
    APIs in one cohesive package.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点是组件，但当我们将对后端API的调用封装在一个统一的包中时，我们还将在[第11章](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml)中看一下如何构建我们自己的`NgModules`，*依赖注入和服务*。
- en: Before we leave our discussion on `NgModule`, deferring further discussion to
    a later chapter, I'd like to at least touch upon a couple of its parameters, since
    `@NgModule` is another annotation that I had mentioned existed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开关于`NgModule`的讨论之前，将进一步讨论推迟到以后的章节，我想至少触及一下它的一些参数，因为`@NgModule`是我提到过的另一个存在的注解。
- en: Properties of the @NgModule decorator
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@NgModule装饰器的属性'
- en: 'If you take a look at the `app.module.ts` file in the example application that
    we started building in [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing*, you can see that there are four parameters in the `@NgModule` annotation
    on our `AppModule` class. Let''s take a quick look at these four and what we use
    them for:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看我们在[第4章](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml)中开始构建的示例应用程序中的`app.module.ts`文件，您会看到在我们的`AppModule`类上的`@NgModule`注解中有四个参数。让我们快速看一下这四个参数以及我们用它们做什么：
- en: '**Declarations**: This is where we list the components and directives that
    we will need to package in this `NgModule`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明**：这是我们列出需要打包在这个`NgModule`中的组件和指令的地方。'
- en: '**Imports**: These make the exported declarations of other modules available
    to our `NgModule`.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入**：这使得其他模块的导出声明对我们的`NgModule`可用。'
- en: '**Providers**: This is where we list services and values so that they become
    known to **dependency injection** (**DI**). They are added to the root scope and
    are injected to other services or directives that have them as a dependency. We''re
    going to cover DI in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml),
    *Integrating Backend Data Services*.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供者**：这是我们列出服务和值的地方，以便它们为**依赖注入**（**DI**）所知。它们被添加到根作用域，并被注入到其他具有它们作为依赖项的服务或指令中。我们将在[第12章](9610f27b-03db-4258-8a68-24eb3901117b.xhtml)中介绍DI，*集成后端数据服务*。'
- en: '**Bootstrap**: This is where we list the component that we want Angular to
    Bootstrap upon application startup.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引导**：这是我们列出我们希望Angular在应用程序启动时引导的组件。'
- en: There can only be one `NgModule` in our application where we make use of the
    Bootstrap parameter—since the bootstrapping process starts with only one module.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中只能有一个`NgModule`，我们在其中使用Bootstrap参数，因为引导过程始于只有一个模块。
- en: Content projection
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容投影
- en: The notion of content projection provides component developers with a mechanism
    that can increase their reusability. In particular, I'm referring to the way in
    which their data is displayed (that is, rendered).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 内容投影的概念为组件开发人员提供了一种可以增加其可重用性的机制。特别是，我指的是它们的数据显示方式（即呈现方式）。
- en: What this means is that instead of trying to create a component that has properties
    for each possible way, its template can be altered (which is nearly impossible)
    so that the developers that consume the component can vary the values of these
    properties to customize how it's rendered. Content projection provides a way to
    accomplish this with much less ceremony.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，我们不再试图创建一个组件，为每种可能的方式都有属性，而是可以更改其模板（这几乎是不可能的），以便使用组件的开发人员可以变化这些属性的值，以自定义渲染方式。内容投影提供了一种以更少的仪式实现这一点的方法。
- en: The mechanism we use is a pair of `ng-content` tags, like this: `<ng-content></ng-content>`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的机制是一对 `ng-content` 标签，就像这样：`<ng-content></ng-content>`。
- en: 'We''ll see this in practice in the Photo Listing page, but let me show you
    a contrived example for now. Let''s modify the template in our `CarComponent`
    to the following code snippet (adding the pair of `ng-content` tags):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在照片列表页面中实践这一点，但现在让我给你展示一个人为的例子。让我们修改我们的 `CarComponent` 模板为以下代码片段（添加一对 `ng-content`
    标签）：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What this does is to enable the CarComponent's parent component to project content
    into the CarComponent's template, thereby altering the template as desired. Let's
    assume that instead of just showing the maker of the car in regular text, within
    a set of `<p>` tags, we'd like to show the make of the car in a set of `<strong>`
    tags.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的目的是使 CarComponent 的父组件能够将内容投影到 CarComponent 的模板中，从而根据需要更改模板。假设我们不仅仅想在常规文本中显示汽车制造商，而是想在一组
    `<p>` 标签中显示汽车制造商。
- en: 'Here is what the parent component would look like:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件将如下所示：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It would look like the preceding instead of the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是如下所示：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again, this was a contrived example. Also, the whole point of Angular is to
    have dynamic data but we haven't done that here. For instance, we'd have the car
    question and answer data bound to elements within the component template, instead
    of having it hardcoded (to *What production car has the fastest acceleration time
    from 0 to 60?*, and *Tesla*, in this case.) However, our simplified hardcoded
    code illustrates the notion of content projection in the most straightforward
    way possible—by not dynamizing the data, as we'll be doing a bit later in the
    book.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这是一个人为的例子。另外，Angular 的整个重点是拥有动态数据，但我们在这里没有做到。例如，我们会将汽车问题和答案数据绑定到组件模板中的元素，而不是将其硬编码（在这种情况下是
    *哪辆量产汽车的0到60加速时间最快？* 和 *特斯拉*）。然而，我们简化的硬编码代码以最直接的方式说明了内容投影的概念——即不使数据动态化，而我们将在本书的后面部分做一些动态化。
- en: Projecting multiple sections
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投影多个部分
- en: It is possible to include more than a single pair of `ng-content` tags. However,
    since Angular will not be able to tell which projected content has replaced which
    set of `ng-content` tags, we need to label the `ng-content` tags in some fashion
    to disambiguate them from one another.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以包含多对 `ng-content` 标签。然而，由于 Angular 无法确定哪个投影内容已替换了哪组 `ng-content` 标签，我们需要以某种方式标记
    `ng-content` 标签，以使它们彼此区分开来。
- en: 'A simple way to label, or mark, the `ng-content` tags so that the intended
    projected content replaces the desired set of `ng-content` tags is to identify
    the elements by class names. We label the tags by using an attribute of `ng-content`, named
    `select`. Let''s extend our contrived `CarComponent` example to see how this may
    look with two pairs of `ng-content` tags:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的方法是通过类名标记或标记`ng-content`标签，以便预期投影的内容替换所需的一组`ng-content`标签。我们使用`ng-content`的名为`select`的属性来标记标签。让我们扩展我们的虚构`CarComponent`示例，看看这在具有两对`ng-content`标签时会是什么样子：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is what the parent component would look like:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是父组件的样子：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By using `ng-content` tags, and its `select` attribute, if you have multiple
    content projection targets, you can create components that are customizable by
    developers that consume them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`ng-content`标签及其`select`属性，如果您有多个内容投影目标，您可以创建可由消费者定制的组件。
- en: Life cycle hooks
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期钩子
- en: As with almost everything that is alive, from the stars in our solar system
    to the flowers you may have bought to decorate your dining room table, Angular
    components also have a life cycle—the different stages, or phases, they go through
    from the moment they spring into existence to the moment they cease to exist.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与几乎所有活着的事物一样，从我们太阳系中的恒星到您可能买来装饰餐桌的花朵，Angular组件也有一个生命周期，它们从诞生到消亡经历的不同阶段或阶段。
- en: We can hook into these different stages to run any code that we may want to
    have Angular run for us as our component moves through them. This is made possible
    because Angular provides us with special methods, one for each phase of the component
    life cycle, which Angular calls for us. All we have to do is provide the code
    that we want Angular to run—and the way we do that is to add functions, bearing
    the same name as the life cycle hooks, to our component class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这些不同的阶段钩入任何我们希望Angular为我们运行的代码，因为Angular为我们提供了特殊的方法，每个组件生命周期阶段都有一个方法，Angular会为我们调用。我们所要做的就是提供我们希望Angular运行的代码，我们是通过在组件类中添加与生命周期钩子同名的函数来实现的。
- en: 'There''s a set of life cycle hooks for the component, and there''s also a set
    of life cycle hooks for its children (that is, child components). The following
    table enumerates the most common ones:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 组件有一组生命周期钩子，其子组件（即子组件）也有一组生命周期钩子。以下表列出了最常见的生命周期钩子：
- en: '| **Life cycle hook** | **Type** | **Invoked when...** |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **生命周期钩子** | **类型** | **在...时调用** |'
- en: '|  `constructor` |  Component | Angular creates a component as a result of
    `new` being called on a class. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `constructor` | 组件 | Angular在类上调用`new`时创建组件。 |'
- en: '|  `ngOnInit` |  Component | A component has been fully initialized. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `ngOnInit` | 组件 | 组件已完全初始化。 |'
- en: '|  `ngOnChanges` |  Component | A change has happened to an input property
    (called once per chance). |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `ngOnChanges` | 组件 | 输入属性发生变化（每次变化调用一次）。 |'
- en: '|  `ngOnDestroy` |  Component | Angular is about to destroy the component.
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `ngOnDestroy` | 组件 | Angular即将销毁组件。 |'
- en: '|  `ngAfterContentInit` |  Child | After content projection occurs for the
    component. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `ngAfterContentInit` | 子 | 组件的内容投影发生后。 |'
- en: '|  `ngAfterContentChecked` |  Child | Angular runs its change detection algorithm
    on the content. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `ngAfterContentChecked` | 子 | Angular在内容上运行其变更检测算法。 |'
- en: '|  `ngAfterViewInit` |  Child | A component''s view has been fully initialized.
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `ngAfterViewInit` | 子 | 组件的视图已完全初始化。 |'
- en: '|  `ngAfterViewChecked` |  Child | Angular runs its change detection algorithm
    on the view. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `ngAfterViewChecked` | 子 | Angular在视图上运行其变更检测算法。 |'
- en: Most common life cycle hooks
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最常见的生命周期钩子
- en: 'From the preceding eight life cycle hooks, you''re most likely to use only
    three of them (in most cases). All three fall into the component type of life
    cycle hook:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的八个生命周期钩子中，你最有可能只使用其中的三个（在大多数情况下）。所有这三个都属于组件类型的生命周期钩子：
- en: '`ngOnInit`: Our initialization logic for our component will go here. You may
    think that the constructor is the place to add the initialization logic, but `ngOnInit`
    is preferable because any binding of data via our interface (that is, input properties)
    will have been done. This isn''t the case with the constructor phase.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngOnInit`：我们的组件初始化逻辑将放在这里。你可能会认为构造函数是添加初始化逻辑的地方，但`ngOnInit`更可取，因为通过我们的接口（即输入属性）进行的任何数据绑定都已经完成。构造函数阶段并非如此。'
- en: '`ngOnChanges`: When we want to know what input properties have changed, and
    to what they were changed to, this is the place to look.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngOnChanges`：当我们想知道哪些输入属性已经改变，以及它们被改变成了什么，这就是需要查看的地方。'
- en: '`ngOnDestroy`: This is where we insert our cleanup logic for our component
    (if we have any things we''d like to clean up—otherwise, we don''t use it).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngOnDestroy`：这是我们为组件插入清理逻辑的地方（如果我们有任何需要清理的东西 - 否则，我们就不使用它）。'
- en: 'Here is an example of how we hook into the `ngOnInit` life cycle hook (we''ll
    just write out some output to our console):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们如何钩入`ngOnInit`生命周期钩子的例子（我们只是向控制台输出一些内容）：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Component interface – inputs and outputs, and the flow of data
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件接口 - 输入和输出，以及数据流
- en: If you were to create a diagram of your components on a particular screen (that
    is, view/page), drawing arrows between them to indicate the flow of data, the
    arrows would point from one component's outputs to another component's inputs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要在特定屏幕上创建一个组件的图表（即视图/页面），在它们之间画箭头来表示数据流，箭头将从一个组件的输出指向另一个组件的输入。
- en: In code, as we'll see later in our implementations, the ways in which we bind
    outputs and inputs are in our component templates (that is, in the HTML). But
    to have binding in HTML, we need to create our components in code and we need
    to give them interfaces.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，正如我们将在实现中看到的那样，我们绑定输出和输入的方式是在我们的组件模板中（即在HTML中）。但是要在HTML中进行绑定，我们需要在代码中创建我们的组件，并且我们需要给它们接口。
- en: Let's take a quick look at a concrete example—it'll show how a parent component
    could pass data to its child component. To demonstrate this, let's first create
    our two components.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一个具体的例子，它将展示父组件如何将数据传递给它的子组件。为了演示这一点，让我们首先创建我们的两个组件。
- en: 'Here is our `DadComponent`, which will be the parent component:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`DadComponent`，它将是父组件：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is our `SonComponent`, which will be the child component:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`SonComponent`，它将是子组件：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There''s a lot going on in this little bit of code. I won''t describe what''s
    going on in the previous code blocks. Rather, I''d like for you to study it for
    a few minutes and see if you can figure out what''s going on. You should have
    enough information from previous chapters, along with with some basic knowledge
    of JavaScript/TypeScript, and an understanding of getters and setters (as many
    languages have). I know you can do it—give it a try. I''ll give you two hints:
    1) `@Input()` is a decorator, and in this case, it creates the public interface
    of `SonComponent`; 2) `DadComponent` will end up creating three instances of `SonComponent`.
    Two of the sons will know their own name, and unfortunately, one of the sons won''t
    know his name. What does he say? What are the names of the sons that do know their
    name? Can you see why three sons are created? Can you guess what would be written
    to the console, and how many times it would be written?'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中发生了很多事情。我不会描述前面代码块中发生了什么。相反，我希望你花几分钟时间研究一下，看看你能否弄清楚发生了什么。你应该从以前的章节中获得足够的信息，再加上一些关于JavaScript/TypeScript的基本知识，以及对getter和setter的理解（因为许多语言都有）。我知道你能做到——试一试。我会给你两个提示：1）`@Input()`是一个装饰器，在这种情况下，它创建了`SonComponent`的公共接口；2）`DadComponent`最终会创建三个`SonComponent`的实例。其中两个儿子会知道自己的名字，不幸的是，其中一个儿子不会知道自己的名字。他会说什么？知道自己名字的儿子叫什么？你能看出为什么会创建三个儿子吗？你能猜到会写入控制台什么，以及会写入多少次吗？
- en: We're going to see a lot of this pattern throughout our implementations, so
    don't worry if it looks strange, or seems a bit complicated, and you can't answer
    all of the questions I've asked. This stuff should become second nature to you
    after a while. And yes, I will be explaining our implementation code from now
    on—not in excruciating detail, but in enough detail for you to understand the
    material at hand. For now, I just wanted you to get a feel for what this passing
    of data via component interfaces looks like.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的实现中看到很多这种模式，所以如果看起来奇怪，或者似乎有点复杂，并且你不能回答我提出的所有问题，不要担心。过一段时间，这些东西应该变得很自然。是的，我将从现在开始解释我们的实现代码——不是详细到极致，但足够让你理解手头的材料。目前，我只是想让你感受一下通过组件接口传递数据是什么样子。
- en: Our implementation of the components for our three pages
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们三个页面的组件实现
- en: 'We now have enough knowledge to implement (that is, create in code) the components
    that we will need for the following three pages of our example application:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有足够的知识来实现（即，在代码中创建）我们示例应用程序以下三个页面所需的组件：
- en: Preview Listing
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预览列表
- en: Photo Listing
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 照片列表
- en: Preview Photo
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预览照片
- en: 'To generate those components, we will make use of the Angular CLI schematics.
    Run the following commands and we should expect the components and required files
    to be auto-generated:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成这些组件，我们将利用Angular CLI原理图。运行以下命令，我们应该期望自动生成组件和所需的文件：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once the commands run successfully, we should see the output, as shown in the
    following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令成功运行，我们应该看到如下屏幕截图所示的输出：
- en: '![](assets/21ffb974-aa8f-4b2c-aa74-aa5c58aa2b9e.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/21ffb974-aa8f-4b2c-aa74-aa5c58aa2b9e.png)
- en: In the preceding screenshot, we can notice that the corresponding files have
    been generated for the component and the `app.module.ts` file has been updated
    with the latest components generated.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的屏幕截图中，我们可以注意到已为组件生成了相应的文件，并且`app.module.ts`文件已经更新为最新生成的组件。
- en: 'The final project structure of our application with components generated so
    far is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应用程序的最终项目结构如下所示：
- en: '![](assets/ee18d776-dfb0-4d9a-8c20-fe27b2ef2770.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/ee18d776-dfb0-4d9a-8c20-fe27b2ef2770.png)
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've covered a lot of ground in this chapter. You may have not completely understood
    some of the code in the last section, and this is OK because you will get good
    at this stuff as we implement our pages for our example application together.
    Since this chapter was on components, I just wanted to show you the general structure
    for how to set up parent and child components, and how to pass data from the parent
    to the child via the child's public interface. However, you should now have a
    pretty good understanding of how an Angular application is just a tree of components.  What
    the rule of thumb is for breaking up your components into sub-components and what
    are annotations and decorators.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容。您可能并没有完全理解上一节中的一些代码，这没关系，因为当我们一起为示例应用程序实现页面时，您会变得擅长这些内容。由于本章是关于组件的，我只是想向您展示如何设置父组件和子组件的一般结构，以及如何通过子组件的公共接口从父组件传递数据。但是，现在您应该对
    Angular 应用程序只是一组组件的树有了相当好的理解。分解组件为子组件的经验法则是什么，注解和装饰器是什么。
- en: We also studied what the `@Component` annotation/decorator is, what it's properties
    are, and how to configure them. We then moved on to the `@NgModule` decorator
    is, and what some of its properties are, and what purpose they serve. We then
    studied what content projection is, and how to use it to allow other developers
    that consume your components to customize of their rendering.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了`@Component`注解/装饰器是什么，它的属性是什么，以及如何配置它们。然后，我们转向了`@NgModule`装饰器是什么，它的一些属性是什么，以及它们的作用是什么。然后，我们研究了内容投影是什么，以及如何使用它允许其他开发人员自定义他们的渲染。
- en: Lastly we studied what life cycle hooks are, how to use them, and reasons why
    you'd want to use them. We then moved on to component interfaces are and how to
    create them. Finally, we studies the implementation of the components we need
    for our three pages (Preview Listing, Photo Listing, and Preview Photo)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了什么是生命周期钩子，如何使用它们以及为什么要使用它们。然后，我们转向了组件接口是什么以及如何创建它们。最后，我们研究了我们三个页面（预览列表、照片列表和预览照片）所需的组件的实现。
- en: In the next chapter, [Chapter 7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml), *Templates,
    Directives, and Pipes*, we're going to zoom into the template portion of components,
    since that's where all the data binding and rendering take place—bringing our
    Angular application from a bunch of 0s and 1s to life on our screens.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[第 7 章](cd8509d5-4bce-4056-8156-557186df18cd.xhtml)，*模板、指令和管道*，我们将深入研究组件的模板部分，因为那里是所有数据绑定和渲染发生的地方——将我们的
    Angular 应用程序从一堆 0 和 1 带到我们的屏幕上。
- en: Angular provides many tools, in the form of directives and pipes, for us to
    leverage, so we can tell it how to paint on our canvas. So, turn the page over
    and let's learn about how we can get Angular to start putting our component paint
    on our application canvas to bring our application to life—which is where we'll
    place our components onto our three pages (Preview Listing, Photo Listing, and
    Preview Photo).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了许多工具，以指令和管道的形式，供我们利用，这样我们就可以告诉它如何在画布上绘制。所以，翻过页面，让我们了解如何让 Angular
    开始在应用程序画布上放置我们的组件绘制，从而使我们的应用程序生动起来——这就是我们将把我们的组件放置到我们的三个页面（预览列表、照片列表和预览照片）上的地方。
