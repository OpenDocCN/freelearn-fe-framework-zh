<html><head></head><body>
		<div id="_idContainer077">
			<h1 id="_idParaDest-98" class="chapter-number"><a id="_idTextAnchor100"/>4</h1>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor101"/>Using React Hooks</h1>
			<p>In this chapter, we will learn about React’s common Hooks and how to use them with TypeScript. We will implement the knowledge of all these Hooks in a React component that allows a user to adjust a score for a person. We will start by exploring the effect Hook and begin to understand use cases where it is useful. We will then delve into two state Hooks, <strong class="source-inline">useState</strong> and <strong class="source-inline">useReducer</strong>, understanding when it is best to use each one. After that, we will cover the ref Hook and how it differs from the state Hook, and then the memo and callback Hooks, looking at how they can <span class="No-Break">help performance.</span></p>
			<p>So, we’ll cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Using the <span class="No-Break">effect Hook</span></li>
				<li>Using <span class="No-Break">state Hooks</span></li>
				<li>Using the <span class="No-Break">ref Hook</span></li>
				<li>Using the <span class="No-Break">memo Hook</span></li>
				<li>Using the <span class="No-Break">callback Hook</span></li>
			</ul>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor102"/>Technical requirements</h1>
			<p>We will use the following technologies in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><strong class="bold">Browser</strong>: A modern browser such as <span class="No-Break">Google Chrome</span></li>
				<li><strong class="bold">Node.js</strong> and <strong class="bold">npm</strong>: You can install them <span class="No-Break">from </span><a href="https://nodejs.org/en/download/"><span class="No-Break">https://nodejs.org/en/download/</span></a></li>
				<li><strong class="bold">Visual Studio Code</strong>: You can install it <span class="No-Break">from </span><a href="https://code.visualstudio.com/"><span class="No-Break">https://code.visualstudio.com/</span></a></li>
			</ul>
			<p>All the code snippets in this chapter can be found online <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4"><span class="No-Break">https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor103"/>Using the effect Hook</h1>
			<p>In this section, we will learn about the effect Hook and where it is useful. We will then create a new React project and a <a id="_idIndexMarker295"/>component that makes use of the <span class="No-Break">effect Hook.</span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor104"/>Understanding the effect Hook parameters</h2>
			<p>The effect Hook is used for<a id="_idIndexMarker296"/> component side effects. A component side effect is something executed outside the scope of the component such as a web service request. The effect Hook is defined using the <strong class="source-inline">useEffect</strong> function from React. <strong class="source-inline">useEffect</strong> contains <span class="No-Break">two parameters:</span></p>
			<ul>
				<li>A function that executes the effect; at a minimum, this function runs each time the component <span class="No-Break">is rendered</span></li>
				<li>An optional array of dependencies that cause the effect function to rerun <span class="No-Break">when changed</span></li>
			</ul>
			<p>Here’s an example of the <strong class="source-inline">useEffect</strong> Hook in <span class="No-Break">a component:</span></p>
			<pre class="source-code">
function SomeComponent() {
<strong class="bold">  function someEffect() {</strong>
<strong class="bold">    console.log("Some effect");</strong>
<strong class="bold">  }</strong>
<strong class="bold">  useEffect(someEffect);</strong>
  return ...
}</pre>
			<p>The preceding effect Hook is passed an effect function called <strong class="source-inline">someEffect</strong>. No effect dependencies have been passed, so the effect function is executed each time the <span class="No-Break">component renders.</span></p>
			<p>Often, an anonymous arrow function is used for the effect function. Here’s the same example but with an anonymous effect <span class="No-Break">function instead:</span></p>
			<pre class="source-code">
function SomeComponent() {
  <strong class="bold">useEffect(() =&gt; {</strong>
<strong class="bold">    console.log("Some effect");</strong>
<strong class="bold">  });</strong>
  return ...
}</pre>
			<p>As you can see, this version<a id="_idIndexMarker297"/> of the code is a little shorter and arguably easier <span class="No-Break">to read.</span></p>
			<p>Here’s another example of <span class="No-Break">an effect:</span></p>
			<pre class="source-code">
function SomeOtherComponent({ search }) {
<strong class="bold">  useEffect(() =&gt; {</strong>
<strong class="bold">    console.log("An effect dependent on a search prop",       search);</strong>
<strong class="bold">  }, [search]);</strong>
  Return ...;
}</pre>
			<p>This time the effect has a dependency on a <strong class="source-inline">search</strong> prop. So, the <strong class="source-inline">search</strong> prop is defined in an array in the effect Hook’s second parameter. The effect function will run every time the value of <span class="No-Break"><strong class="source-inline">search</strong></span><span class="No-Break"> changes.</span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor105"/>The rules of Hooks</h2>
			<p>There are some rules <a id="_idIndexMarker298"/>that all Hooks, including <strong class="source-inline">useEffect</strong>, <span class="No-Break">must obey:</span></p>
			<ul>
				<li>A Hook can only be called at the top level of a function component. So, a Hook can’t be called in a loop or in a nested function such as an <span class="No-Break">event handler.</span></li>
				<li>A Hook can’t be <span class="No-Break">called conditionally.</span></li>
				<li>A Hook can only be used in function components and not <span class="No-Break">class components.</span></li>
			</ul>
			<p>The following example is a violation of <span class="No-Break">the rules:</span></p>
			<pre class="source-code">
export function AnotherComponent() {
  function handleClick() {
    useEffect(() =&gt; {
      console.log("Some effect");
    });
  }
  return &lt;button onClick={handleClick}&gt;Cause effect&lt;/button&gt;;
}</pre>
			<p>This is a violation because <strong class="source-inline">useEffect</strong> is called in a handler function rather than at the top level. A <a id="_idIndexMarker299"/>corrected version is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
export function AnotherComponent() {
  const [clicked, setClicked] = useState(false);
  useEffect(() =&gt; {
    if (clicked) {
      console.log("Some effect");
    }
  }, [clicked]);
  function handleClick() {
    setClicked(true);
  }
  return &lt;button onClick={handleClick}&gt;Cause effect&lt;/button&gt;;
}</pre>
			<p><strong class="source-inline">useEffect</strong> has been lifted to the top level and now depends on the <strong class="source-inline">clicked</strong> state that is set in the <span class="No-Break">handler function.</span></p>
			<p>The following is another example that violates the rules <span class="No-Break">of Hooks:</span></p>
			<pre class="source-code">
function YetAnotherComponent({ someProp }) {
  if (!someProp) {
    return null;
  }
  useEffect(() =&gt; {
    console.log("Some effect");
  });
  return ...
}</pre>
			<p>The violation is<a id="_idIndexMarker300"/> because <strong class="source-inline">useEffect</strong> is called conditionally. If <strong class="source-inline">someProp</strong> is falsy, <strong class="source-inline">null</strong> is returned from the component and <strong class="source-inline">useEffect</strong> is never called. So, the condition is that <strong class="source-inline">useEffect</strong> is only called when <strong class="source-inline">someProp</strong> <span class="No-Break">is truthy.</span></p>
			<p>A corrected version is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
function YetAnotherComponent({someProp}) {
  useEffect(() =&gt; {
    if (someProp) {
      console.log("Some effect");
    }
  });
  if (!someProp) {
    return null
  }
  return ...
}</pre>
			<p><strong class="source-inline">useEffect</strong> has been lifted above the condition. The condition has also been put inside the effect function <a id="_idIndexMarker301"/>so that its logic is only executed when <strong class="source-inline">someProp</strong> <span class="No-Break">is truthy.</span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor106"/>Effect cleanup</h2>
			<p>An effect can return a function that performs cleanup logic when the component is unmounted. Cleanup logic<a id="_idIndexMarker302"/> ensures nothing is left that could cause a memory leak. Let’s consider the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
function ExampleComponent({onClickAnywhere}) {
  useEffect(() =&gt; {
    function handleClick() {
      onClickAnywhere();
    }
    document.addEventListener("click", handleClick);
  });
  return ...
}</pre>
			<p>The preceding effect function attaches an event handler to the <strong class="source-inline">document</strong> element. The event handler is never detatched though, so multiple event handlers will become attached to the <strong class="source-inline">document</strong> element as the effect is rerun. This problem is resolved by returning a <strong class="source-inline">cleanup</strong> function that detaches the event handler <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
function ExampleComponent({ onClickAnywhere }) {
  useEffect(() =&gt; {
    function handleClick() {
      onClickAnywhere();
    }
    document.addEventListener("click", listener);
<strong class="bold">    return function cleanup() {</strong>
<strong class="bold">      document.removeEventListener("click", listener);</strong>
<strong class="bold">    };</strong>
  });
  return ...;
}</pre>
			<p>Often, an anonymous arrow function is used for the <span class="No-Break">cleanup function:</span></p>
			<pre class="source-code">
function ExampleComponent({ onClickAnywhere }) {
  useEffect(() =&gt; {
    function handleClick() {
      onClickAnywhere();
    }
    document.addEventListener("click", listener);
<strong class="bold">    return () =&gt; {</strong>
<strong class="bold">      document.removeEventListener("click", listener);</strong>
<strong class="bold">    };</strong>
  });
  return ...;</pre>
			<p>An anonymous arrow<a id="_idIndexMarker303"/> function is a little shorter than the named function in the <span class="No-Break">previous example.</span></p>
			<p>Next, we will explore a common use case for the <span class="No-Break">effect Hook.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor107"/>Creating the project</h2>
			<p>Let’s start by <a id="_idIndexMarker304"/>creating a new project in Visual Studio Code using Create React App. We learned how to do this in <a href="B19051_03.xhtml#_idTextAnchor072"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><em class="italic">, Setting Up React and TypeScript</em> – the steps are <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Open Visual Studio Code in a blank folder of your choice and run the <span class="No-Break">following command:</span><pre class="source-code">
npx create-react-app app --template typescript</pre></li>
			</ol>
			<p>Create React App will take a minute or so to create the project. The app is called <strong class="source-inline">app</strong> in the proceeding command, but feel free to <span class="No-Break">change this.</span></p>
			<ol>
				<li value="2">Reopen Visual Studio Code in the <strong class="source-inline">app</strong> folder that has just been created (or whatever you called <span class="No-Break">the app).</span></li>
				<li>Install Prettier and its libraries to allow it to work with ESLint. Run the following command in the terminal to <span class="No-Break">do this:</span><pre class="source-code">
npm i -D prettier eslint-config-prettier eslint-plugin-prettier</pre></li>
				<li>Enable Visual Studio Code to<a id="_idIndexMarker305"/> automatically format code as files are saved. To do this, create a <strong class="source-inline">.vscode</strong> folder in the project root and create a <strong class="source-inline">settings.json</strong> file containing <span class="No-Break">the following:</span><pre class="source-code">
{</pre><pre class="source-code">
  "editor.formatOnSave": true,</pre><pre class="source-code">
  "editor.defaultFormatter": "esbenp.prettier-vscode"</pre><pre class="source-code">
}</pre></li>
				<li>Update the ESLint configuration to allow Prettier to manage the styling rules. To do this, add the following highlighted line to the <strong class="source-inline">eslintConfig</strong> section <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break">:</span><pre class="source-code">
{</pre><pre class="source-code">
  ...,</pre><pre class="source-code">
  "eslintConfig": {</pre><pre class="source-code">
    "extends": [</pre><pre class="source-code">
      "react-app",</pre><pre class="source-code">
      "react-app/jest"<strong class="bold">,</strong></pre><pre class="source-code">
      <strong class="bold">"plugin:prettier/recommended"</strong></pre><pre class="source-code">
    ]</pre><pre class="source-code">
  },</pre><pre class="source-code">
  ...</pre><pre class="source-code">
}</pre></li>
				<li>Add the following Prettier <a id="_idIndexMarker306"/>configuration in a file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">.prettierrc.json</strong></span><span class="No-Break">:</span><pre class="source-code">
{</pre><pre class="source-code">
  "printWidth": 100,</pre><pre class="source-code">
  "singleQuote": true,</pre><pre class="source-code">
  "semi": true,</pre><pre class="source-code">
  "tabWidth": 2,</pre><pre class="source-code">
  "trailingComma": "all",</pre><pre class="source-code">
  "endOfLine": "auto"</pre><pre class="source-code">
}</pre></li>
				<li>Remove the following files from the <strong class="source-inline">src</strong> folder, because these aren’t needed in <span class="No-Break">this project:</span><ul><li><span class="No-Break"><strong class="source-inline">App.test.tsx</strong></span></li><li><span class="No-Break"><strong class="source-inline">Logo.svg</strong></span></li></ul></li>
				<li>Open <strong class="source-inline">index.tsx</strong> and save the file without making any changes. This will remove any <span class="No-Break">formatting issues.</span></li>
				<li>Open <strong class="source-inline">App.tsx</strong> and replace the content with <span class="No-Break">the following:</span><pre class="source-code">
import React from 'react';</pre><pre class="source-code">
import './App.css';</pre><pre class="source-code">
function App() {</pre><pre class="source-code">
  return &lt;div className="App"&gt;&lt;/div&gt;;</pre><pre class="source-code">
}</pre><pre class="source-code">
export default App;</pre></li>
				<li>Start the app running in development mode by running <strong class="source-inline">npm start</strong> in the terminal. The app contains <a id="_idIndexMarker307"/>a blank page at the moment. Keep the app running as we explore the different Hooks in a <span class="No-Break">React component.</span></li>
			</ol>
			<p>That’s the project created. Next, we will use the <span class="No-Break">effect Hook.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor108"/>Fetching data using the effect Hook</h2>
			<p>A common use of the <a id="_idIndexMarker308"/>effect Hook is fetching data. Carry out the following steps to implement an effect that fetches a <span class="No-Break">person’s name:</span></p>
			<ol>
				<li value="1">Create a function that will simulate a data request. To do this, create a file called <strong class="source-inline">getPerson.ts</strong> in the <strong class="source-inline">src</strong> folder and then add the following content to <span class="No-Break">this file:</span><pre class="source-code">
type Person = {</pre><pre class="source-code">
  name: string,</pre><pre class="source-code">
};</pre><pre class="source-code">
export function getPerson(): Promise&lt;Person&gt; {</pre><pre class="source-code">
  return new Promise((resolve) =&gt;</pre><pre class="source-code">
    setTimeout(() =&gt; resolve({ name: "Bob" }), 1000)</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The function asynchronously returns an object, <strong class="source-inline">{ name: "Bob" }</strong>, after a second <span class="No-Break">has elapsed.</span></p>
			<p>Notice the type annotation for the return type, <strong class="source-inline">Promise&lt;Person&gt;</strong>. The <strong class="source-inline">Promise</strong> type represents a JavaScript <strong class="source-inline">Promise</strong>, which is something that will eventually be completed. The <strong class="source-inline">Promise</strong> type has a generic argument for the item type that is resolved in the promise, which is <strong class="source-inline">Person</strong> in this example. For more information on JavaScript promises, see the following <span class="No-Break">link: </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="2">Next, we will create a React component that will eventually display a person and a score. Create<a id="_idIndexMarker309"/> a file called <strong class="source-inline">PersonScore.tsx</strong> in the <strong class="source-inline">src</strong> folder and then add the following contents to <span class="No-Break">the file:</span><pre class="source-code">
import { useEffect } from 'react';</pre><pre class="source-code">
import { getPerson } from './getPerson';</pre><pre class="source-code">
export function PersonScore() {</pre><pre class="source-code">
  return null;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The <strong class="source-inline">useEffect</strong> Hook has been imported from React and the <strong class="source-inline">getPerson</strong> function we have just created has also been imported. At the moment, the component simply <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="3">Add the following effect above the <span class="No-Break">return statement:</span><pre class="source-code">
export function PersonScore() {</pre><pre class="source-code">
  <strong class="bold">useEffect(() =&gt; {</strong></pre><pre class="source-code">
<strong class="bold">    getPerson().then((person) =&gt; console.log(person));</strong></pre><pre class="source-code">
<strong class="bold">  }, []);</strong></pre><pre class="source-code">
  return null;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The effect calls the <strong class="source-inline">getPerson</strong> function and outputs the returned person to the console. The effect is only executed after the component is initially rendered because an empty array has been specified as the effect dependencies in its <span class="No-Break">second </span><span class="No-Break"><a id="_idIndexMarker310"/></span><span class="No-Break">argument.</span></p>
			<ol>
				<li value="4">Open <strong class="source-inline">App.tsx</strong> and render the <strong class="source-inline">PersonScore</strong> component inside the <span class="No-Break"><strong class="source-inline">div</strong></span><span class="No-Break"> element:</span><pre class="source-code">
import React from 'react';</pre><pre class="source-code">
import './App.css';</pre><pre class="source-code">
<strong class="bold">import { PersonScore } from './PersonScore';</strong></pre><pre class="source-code">
function App() {</pre><pre class="source-code">
  return (</pre><pre class="source-code">
    &lt;div className="App"&gt;</pre><pre class="source-code">
      <strong class="bold">&lt;PersonScore /&gt;</strong></pre><pre class="source-code">
    &lt;/div&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre><pre class="source-code">
export default App;</pre></li>
				<li>Go to the running app in the browser and go to the <strong class="bold">Console</strong> panel in the browser’s DevTools. Notice that the <strong class="source-inline">person</strong> object appears in the console, which verifies that the effect that fetches the <strong class="source-inline">person</strong> data <span class="No-Break">ran properly:</span></li>
			</ol>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B19051_04_01.jpg" alt="Figure 4.1 – The effect output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The effect output</p>
			<p>You may also notice that the effect function has been executed twice rather than once. This behavior is intentional and only happens in development mode with React Strict Mode. This will eventually allow a future React feature to preserve the state when sections of the UI are removed. See this blog post from the React team for<a id="_idIndexMarker311"/> more information on this <span class="No-Break">behavior: </span><span class="No-Break">https://reactjs.org/blog/2022/03/29/react-v18.html#new-strict-mode-behaviors</span><span class="No-Break">.</span></p>
			<ol>
				<li value="6">Next, we will refactor how the effect function is called to expose an interesting problem. Open <strong class="source-inline">PersonScore.tsx</strong> and change the <strong class="source-inline">useEffect</strong> call to use the <span class="No-Break"><strong class="source-inline">async</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">await</strong></span><span class="No-Break"> syntax:</span><pre class="source-code">
useEffect(<strong class="bold">async</strong> () =&gt; {</pre><pre class="source-code">
  <strong class="bold">const person = await getPerson();</strong></pre><pre class="source-code">
<strong class="bold">  console.log(person);</strong></pre><pre class="source-code">
}, []);</pre></li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> syntax is an alternative way to write asynchronous code. Many developers prefer it because it reads like synchronous code. For more information on <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong>, see the following <span class="No-Break">link: </span><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#async_and_await"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#async_and_await</span></a><span class="No-Break">.</span></p>
			<p>The preceding code is arguably more readable, but React raises an error. Look in the browser’s console and you’ll see the <span class="No-Break">following error:</span></p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B19051_04_02.jpg" alt="Figure 4.2 – Effect async error"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Effect async error</p>
			<p>The error is very informative – the <strong class="source-inline">useEffect</strong> Hook doesn’t allow a function marked with <strong class="source-inline">async</strong> to be passed <span class="No-Break">into it.</span></p>
			<ol>
				<li value="7">Next, update the code and use the approach suggested in the <span class="No-Break">error message:</span><pre class="source-code">
useEffect(() =&gt; {</pre><pre class="source-code">
  async function getThePerson() {</pre><pre class="source-code">
    const person = await getPerson();</pre><pre class="source-code">
    console.log(person);</pre><pre class="source-code">
  }</pre><pre class="source-code">
  getThePerson();</pre><pre class="source-code">
}, []);</pre></li>
			</ol>
			<p>A nested asynchronous function has been defined and immediately called in the effect function; this <span class="No-Break">works nicely.</span></p>
			<ol>
				<li value="8">This implementation<a id="_idIndexMarker312"/> of the effect is arguably less readable than the initial version. So, switch back to that version before continuing to the next section. The code is available to copy from the following <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section1-Using-the-effect-hook/src/PersonScore.tsx"><span class="No-Break">https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section1-Using-the-effect-hook/src/PersonScore.tsx</span></a><span class="No-Break">.</span></li>
			</ol>
			<p>That completes our exploration of the effect Hook – here’s <span class="No-Break">a recap:</span></p>
			<ul>
				<li>The effect Hook is used to execute component side effects when a component is rendered or when certain props or <span class="No-Break">states change.</span></li>
				<li>A common use case for the effect Hook is fetching data. Another use case is where DOM events need to be <span class="No-Break">manually registered.</span></li>
				<li>Any required effect cleanup can be done in a function returned by the <span class="No-Break">effect function.</span></li>
			</ul>
			<p>Next, we will learn about the two state Hooks in React. Keep the app running as we move to the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor109"/>Using state Hooks</h1>
			<p>We have already learned about the <strong class="source-inline">useState</strong> Hook in previous chapters, but here we will look at it again and <a id="_idIndexMarker313"/>compare it against another state Hook we haven’t covered yet, <strong class="source-inline">useReducer</strong>. We will expand the <strong class="source-inline">PersonScore</strong> component we created in the last section to explore these <span class="No-Break">state Hooks.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor110"/>Using useState</h2>
			<p>As a reminder, the <strong class="source-inline">useState</strong> Hook allows <a id="_idIndexMarker314"/>state to be defined in a variable. The syntax for <strong class="source-inline">useState</strong> is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const [state, setState] = useState(initialState);</pre>
			<p>We will enhance the <strong class="source-inline">PersonScore</strong> component we created in the last section to store the person’s name in <strong class="source-inline">state</strong>. We will also have <strong class="source-inline">state</strong> for a score that is incremented, decremented, and<a id="_idIndexMarker315"/> reset using some buttons in the component. We will also add the <strong class="source-inline">loading</strong> state to the component, which will show a loading indicator <span class="No-Break">when </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p>Carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Open <strong class="source-inline">PersonScore.tsx</strong> and add <strong class="source-inline">useState</strong> to the React <span class="No-Break">import statement:</span><pre class="source-code">
import { useEffect<strong class="bold">, useState</strong> } from 'react';</pre></li>
				<li>Add the following state definitions for <strong class="source-inline">name</strong>, <strong class="source-inline">score</strong>, and <strong class="source-inline">loading</strong> at the top of the component function, above the <span class="No-Break"><strong class="source-inline">useEffect</strong></span><span class="No-Break"> call:</span><pre class="source-code">
export function PersonScore() {</pre><pre class="source-code">
  <strong class="bold">const [name, setName] = useState&lt;string | undefined&gt;();</strong></pre><pre class="source-code">
<strong class="bold">  const [score, setScore] = useState(0);</strong></pre><pre class="source-code">
<strong class="bold">  const [loading, setLoading] = useState(true);</strong></pre><pre class="source-code">
  useEffect( ... );</pre><pre class="source-code">
  return null;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The <strong class="source-inline">score</strong> state is initialized to <strong class="source-inline">0</strong> and <strong class="source-inline">loading</strong> is initialized <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="3">Change the effect function to set the <strong class="source-inline">loading</strong> and <strong class="source-inline">name</strong> state values after the person data has been <a id="_idIndexMarker316"/>fetched. This should replace the existing <span class="No-Break"><strong class="source-inline">console.log</strong></span><span class="No-Break"> statement:</span><pre class="source-code">
useEffect(() =&gt; {</pre><pre class="source-code">
  getPerson().then((person) =&gt; <strong class="bold">{</strong></pre><pre class="source-code">
<strong class="bold">    setLoading(false);</strong></pre><pre class="source-code">
<strong class="bold">    setName(person.name);</strong></pre><pre class="source-code">
<strong class="bold">  }</strong>);</pre><pre class="source-code">
}, []);</pre></li>
			</ol>
			<p>After the person has been fetched, <strong class="source-inline">loading</strong> is set to <strong class="source-inline">false</strong>, and <strong class="source-inline">name</strong> is set to the <span class="No-Break">person’s name.</span></p>
			<ol>
				<li value="4">Next, add the<a id="_idIndexMarker317"/> following <strong class="source-inline">if</strong> statement in between the <strong class="source-inline">useEffect</strong> call and the <span class="No-Break">return statement:</span><pre class="source-code">
useEffect( ... );</pre><pre class="source-code">
<strong class="bold">if (loading) {</strong></pre><pre class="source-code">
<strong class="bold">  return &lt;div&gt;Loading ...&lt;/div&gt;;</strong></pre><pre class="source-code">
<strong class="bold">}</strong></pre><pre class="source-code">
return ...</pre></li>
			</ol>
			<p>This displays a loading indicator when the <strong class="source-inline">loading</strong> state <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="5">Change the component’s return statement from outputting nothing to outputting <span class="No-Break">the following:</span><pre class="source-code">
if (loading) {</pre><pre class="source-code">
  return &lt;div&gt;Loading ...&lt;/div&gt;;</pre><pre class="source-code">
}</pre><pre class="source-code">
return <strong class="bold">(</strong></pre><pre class="source-code">
<strong class="bold">  &lt;div&gt;</strong></pre><pre class="source-code">
<strong class="bold">    &lt;h3&gt;</strong></pre><pre class="source-code">
<strong class="bold">      {name}, {score}</strong></pre><pre class="source-code">
<strong class="bold">    &lt;/h3&gt;</strong></pre><pre class="source-code">
<strong class="bold">    &lt;button&gt;Add&lt;/button&gt;</strong></pre><pre class="source-code">
<strong class="bold">    &lt;button&gt;Subtract&lt;/button&gt;</strong></pre><pre class="source-code">
<strong class="bold">    &lt;button&gt;Reset&lt;/button&gt;</strong></pre><pre class="source-code">
<strong class="bold">  &lt;/div&gt;</strong></pre><pre class="source-code">
<strong class="bold">)</strong>;</pre></li>
			</ol>
			<p>The person’s name <a id="_idIndexMarker318"/>and score are displayed in a header with <strong class="bold">Add</strong>, <strong class="bold">Subtract</strong>, and <strong class="bold">Reset</strong> buttons <a id="_idIndexMarker319"/>underneath (don’t worry that the output is unstyled – we will learn how to style components in the <span class="No-Break">next chapter):</span></p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B19051_04_03.jpg" alt="Figure 4.3 – The PersonScore component after data has been fetched"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – The PersonScore component after data has been fetched</p>
			<ol>
				<li value="6">Update the <strong class="bold">Add</strong> button so that it increments the score <span class="No-Break">when clicked:</span><pre class="source-code">
&lt;button <strong class="bold">onClick={() =&gt; setScore(score + 1)}</strong>&gt;Add&lt;/button&gt;</pre></li>
			</ol>
			<p>The button click event calls the score state setter to increment <span class="No-Break">the state.</span></p>
			<p>There is an alternative method of updating the state values based on their previous value. The alternative method uses a parameter in the state setter that gives the previous<a id="_idIndexMarker320"/> state value, so our example could look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
setScore(<strong class="bold">previousScore =&gt; previousScore + 1</strong>)</pre>
			<p>This is arguably a little harder to read, so we’ll stick to our <span class="No-Break">initial method.</span></p>
			<ol>
				<li value="7">Add score state <a id="_idIndexMarker321"/>setters to the other buttons <span class="No-Break">as follows:</span><pre class="source-code">
&lt;button <strong class="bold">onClick={() =&gt; setScore(score - 1)}</strong>&gt;Subtract&lt;/button&gt;</pre><pre class="source-code">
&lt;button <strong class="bold">onClick={() =&gt; setScore(0)}</strong>&gt;Reset&lt;/button&gt;</pre></li>
				<li>In the running app, click the different buttons. They should change the score as you <span class="No-Break">would expect.</span></li>
			</ol>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B19051_04_04.jpg" alt="Figure 4.4 – The PersonScore component after the button is clicked"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – The PersonScore component after the button is clicked</p>
			<ol>
				<li value="9">Before we finish this exercise, let’s take some time to understand when the state values are actually set. Update the effect function to output the state values after they <span class="No-Break">are set:</span><pre class="source-code">
useEffect(() =&gt; {</pre><pre class="source-code">
  getPerson().then((person) =&gt; {</pre><pre class="source-code">
    setLoading(false);</pre><pre class="source-code">
    setName(person.name);</pre><pre class="source-code">
    <strong class="bold">console.log("State values", loading, name);</strong></pre><pre class="source-code">
  });</pre><pre class="source-code">
}, []);</pre></li>
			</ol>
			<p>Perhaps we would expect <strong class="source-inline">false</strong> and <strong class="source-inline">"Bob"</strong> as the output to the console? However, <strong class="source-inline">true</strong> and <strong class="source-inline">undefined</strong> are the output to the console. This is because updating state values is <a id="_idIndexMarker322"/>not immediate – instead, they are batched and updated before the next render. So, it isn’t until the next render that <strong class="source-inline">loading</strong> will be <strong class="source-inline">false</strong>, and <strong class="source-inline">name</strong> will <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">"Bob"</strong></span><span class="No-Break">.</span></p>
			<p>We no longer <a id="_idIndexMarker323"/>need the <strong class="source-inline">console.log</strong> statement we added in this step, so remove it <span class="No-Break">before continuing.</span></p>
			<p>Next, we will learn about an alternative React Hook for <span class="No-Break">using state.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor111"/>Understanding useReducer</h2>
			<p><strong class="source-inline">useReducer</strong> is an <a id="_idIndexMarker324"/>alternative method of managing state. It uses a <strong class="bold">reducer</strong> function for <a id="_idIndexMarker325"/>state changes, which takes in the current state value and returns the new <span class="No-Break">state value.</span></p>
			<p>Here is an example of a <span class="No-Break"><strong class="source-inline">useReducer</strong></span><span class="No-Break"> call:</span></p>
			<pre class="source-code">
const [state, dispatch] = useReducer(reducer, initialState);</pre>
			<p>So, <strong class="source-inline">useReducer</strong> takes in a reducer function and the initial state value as parameters. It then returns a tuple containing the current state value and a function to <strong class="bold">dispatch</strong> <span class="No-Break">state changes.</span></p>
			<p>The dispatch function takes in an <a id="_idIndexMarker326"/>argument that describes the change. This object is called an <strong class="bold">action</strong>. An example <strong class="source-inline">dispatch</strong> call is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
dispatch({ type: 'add', amount: 2 });</pre>
			<p>There is no defined structure for an action, but it is common practice for it to contain a property, such as <strong class="source-inline">type</strong>, to specify the type of change. Other properties in the action can vary depending on the type of change. Here’s another example of a <span class="No-Break"><strong class="source-inline">dispatch</strong></span><span class="No-Break"> call:</span></p>
			<pre class="source-code">
dispatch({ type: 'loaded' });</pre>
			<p>This time, the action only needs the type to change the <span class="No-Break">necessary state.</span></p>
			<p>Turning our attention to the reducer function, it has parameters for the current state value and the action. Here’s an example code snippet of <span class="No-Break">a reducer:</span></p>
			<pre class="source-code">
function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'add':
      return { ...state, total: state.total + action.amount };
    case ...
      ...
    default:
      return state;
  }
}</pre>
			<p>The reducer function <a id="_idIndexMarker327"/>usually contains a <strong class="source-inline">switch</strong> statement based on the action type. Each switch branch makes the required changes to the state and returns the updated state. A new state<a id="_idIndexMarker328"/> object is created during the state change – the current state is never mutated. A mutating state would result in the component <span class="No-Break">not re-rendering.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the preceding code snippet, inside the <strong class="source-inline">"add"</strong> branch the <strong class="bold">spread syntax</strong> is used on the <strong class="source-inline">state</strong> variable (<strong class="source-inline">...state</strong>). The <a id="_idIndexMarker329"/>spread syntax copies all the properties from the object after the three dots. In the preceding code snippet, all the properties are copied from the <strong class="source-inline">state</strong> variable into the new state object returned. The <strong class="source-inline">total</strong> property value will then be overwritten by <strong class="source-inline">state.total + action.amount</strong> because this is defined after the spread operation in the new object creation. For more information on the spread syntax, see the following <span class="No-Break">link: </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax</span></a><span class="No-Break">.</span></p>
			<p>The types for <strong class="source-inline">useReducer</strong> can be explicitly defined in its generic parameter <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const [state, dispatch] = useReducer<strong class="bold">&lt;Reducer&lt;State, Action&gt;&gt;</strong>(
  reducer,
  initialState
);</pre>
			<p><strong class="source-inline">Reducer</strong> is a standard <a id="_idIndexMarker330"/>React type that has generic parameters for the type of state and the type <span class="No-Break">of action.</span></p>
			<p>So, <strong class="source-inline">useReducer</strong> is more complex than <strong class="source-inline">useState</strong> because state changes go through a reducer function that we<a id="_idIndexMarker331"/> must implement. This benefits complex state objects with related properties or when a state change depends on the previous <span class="No-Break">state value.</span></p>
			<p>Next, we will implement state <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">useReducer</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor112"/>Using useReducer</h2>
			<p>We will refactor the <strong class="source-inline">PersonScore</strong> component <a id="_idIndexMarker332"/>we have been working on to use <strong class="source-inline">useReducer</strong> instead of <strong class="source-inline">useState</strong>. To do this, carry out the following steps. The code snippets used are available to copy <span class="No-Break">from </span><a href="https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section2-Using-state-hooks/2-Using-useReducer/src/PersonScore.tsx"><span class="No-Break">https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section2-Using-state-hooks/2-Using-useReducer/src/PersonScore.tsx</span></a><span class="No-Break">:</span></p>
			<ol>
				<li value="1">Open <strong class="source-inline">PersonScore.tsx</strong> and import <strong class="source-inline">useReducer</strong> instead of <strong class="source-inline">useState</strong> <span class="No-Break">from React:</span><pre class="source-code">
import { useEffect, <strong class="bold">useReducer</strong> } from 'react';</pre></li>
				<li>We will have the state in a single object, so define a type for the state beneath the <span class="No-Break">import statements:</span><pre class="source-code">
type State = {</pre><pre class="source-code">
  name: string | undefined;</pre><pre class="source-code">
  score: number;</pre><pre class="source-code">
  loading: boolean;</pre><pre class="source-code">
};</pre></li>
				<li>Next, let’s also define<a id="_idIndexMarker333"/> types for all the <span class="No-Break">action objects:</span><pre class="source-code">
type Action =</pre><pre class="source-code">
  | {</pre><pre class="source-code">
      type: 'initialize';</pre><pre class="source-code">
      name: string;</pre><pre class="source-code">
    }</pre><pre class="source-code">
  | {</pre><pre class="source-code">
      type: 'increment';</pre><pre class="source-code">
    }</pre><pre class="source-code">
  | {</pre><pre class="source-code">
      type: 'decrement';</pre><pre class="source-code">
    }</pre><pre class="source-code">
  | {</pre><pre class="source-code">
      type: 'reset';</pre><pre class="source-code">
    };</pre></li>
			</ol>
			<p>These action objects represent all the ways in which state can change. The action object types are combined using a union type, allowing an action to be any <span class="No-Break">of these.</span></p>
			<ol>
				<li value="4">Now, define the following reducer function underneath the <span class="No-Break">type definitions:</span><pre class="source-code">
function reducer(state: State, action: Action): State {</pre><pre class="source-code">
  switch (action.type) {</pre><pre class="source-code">
    case 'initialize':</pre><pre class="source-code">
      return { name: action.name, score: 0, loading: false };</pre><pre class="source-code">
    case 'increment':</pre><pre class="source-code">
      return { ...state, score: state.score + 1 };</pre><pre class="source-code">
    case 'decrement':</pre><pre class="source-code">
      return { ...state, score: state.score - 1 };</pre><pre class="source-code">
    case 'reset':</pre><pre class="source-code">
      return { ...state, score: 0 };</pre><pre class="source-code">
    default:</pre><pre class="source-code">
      return state;</pre><pre class="source-code">
  }</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The reducer function contains a <strong class="source-inline">switch</strong> statement that makes appropriate state changes for<a id="_idIndexMarker334"/> each type <span class="No-Break">of action.</span></p>
			<p>Notice the nice IntelliSense when referencing the <strong class="source-inline">state</strong> and <span class="No-Break"><strong class="source-inline">action</strong></span><span class="No-Break"> parameters:</span></p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B19051_04_05.jpg" alt="Figure 4.5 – IntelliSense inside the reducer function"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – IntelliSense inside the reducer function</p>
			<ol>
				<li value="5">Inside the <strong class="source-inline">PersonScore</strong> component, replace the <strong class="source-inline">useState</strong> calls with the following <span class="No-Break"><strong class="source-inline">useReducer</strong></span><span class="No-Break"> call:</span><pre class="source-code">
const [{ name, score, loading }, dispatch] = useReducer(</pre><pre class="source-code">
  reducer,</pre><pre class="source-code">
  {</pre><pre class="source-code">
    name: undefined,</pre><pre class="source-code">
    score: 0,</pre><pre class="source-code">
    loading: true,</pre><pre class="source-code">
  }</pre><pre class="source-code">
);</pre></li>
			</ol>
			<p>The state has been initialized with an <strong class="source-inline">undefined</strong> name, a score of <strong class="source-inline">0</strong>, and <strong class="source-inline">loading</strong> set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p>The current state value has been destructured into <strong class="source-inline">name</strong>, <strong class="source-inline">score</strong>, and <strong class="source-inline">loading</strong> variables. If you hover over these destructured state variables, you will see that their types have been <span class="No-Break">inferred correctly.</span></p>
			<ol>
				<li value="6">We now need to<a id="_idIndexMarker335"/> amend the places in the component that update the state. Start with the effect function and dispatch an initialize action after the person has <span class="No-Break">been returned:</span><pre class="source-code">
useEffect(() =&gt; {</pre><pre class="source-code">
  getPerson().then((<strong class="bold">{ name }</strong>) =&gt;</pre><pre class="source-code">
    <strong class="bold">dispatch({ type: 'initialize', name })</strong></pre><pre class="source-code">
  );</pre><pre class="source-code">
}, []);</pre></li>
				<li>Lastly, dispatch the relevant actions in the button <span class="No-Break">click handlers:</span><pre class="source-code">
&lt;button onClick={() =&gt; <strong class="bold">dispatch({ type: 'increment' })</strong>}&gt;</pre><pre class="source-code">
  Add</pre><pre class="source-code">
&lt;/button&gt;</pre><pre class="source-code">
&lt;button onClick={() =&gt; <strong class="bold">dispatch({ type: 'decrement' })</strong>}&gt;</pre><pre class="source-code">
  Subtract</pre><pre class="source-code">
&lt;/button&gt;</pre><pre class="source-code">
&lt;button onClick={() =&gt; <strong class="bold">dispatch({ type: 'reset' })</strong>}&gt;</pre><pre class="source-code">
  Reset</pre><pre class="source-code">
&lt;/button&gt;</pre></li>
				<li>If you try clicking the buttons in the running app, they will <span class="No-Break">correctly update.</span></li>
			</ol>
			<p>That completes our exploration of the <strong class="source-inline">useReducer</strong> Hook. It is more useful for complex state management situations than <strong class="source-inline">useState</strong>, for example, when the state is a complex object with related <a id="_idIndexMarker336"/>properties and state changes depend on previous state values. The <strong class="source-inline">useState</strong> Hook is more appropriate when the state is based on primitive values independent of any <span class="No-Break">other state.</span></p>
			<p>We will continue to expand the <strong class="source-inline">PersonScore</strong> component in the following sections. Next, we will learn how to move the focus to the <strong class="bold">Add</strong> button using the <span class="No-Break">ref Hook.</span></p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor113"/>Using the ref Hook</h1>
			<p>In this section, we will learn <a id="_idIndexMarker337"/>about the ref Hook and where it is useful. We will then walk through a common use case of the ref Hook by enhancing the <strong class="source-inline">PersonScore</strong> component we have been <span class="No-Break">working on.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor114"/>Understanding the ref Hook</h2>
			<p>The ref Hook is called <strong class="source-inline">useRef</strong> and it returns a variable whose value is persisted for the lifetime of a component. This means that the variable doesn’t lose its value when a <span class="No-Break">component re-renders.</span></p>
			<p>The value returned from the ref Hook is often referred to as a <strong class="bold">ref</strong>. The ref can be changed without causing <span class="No-Break">a re-render.</span></p>
			<p>Here’s the syntax <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">useRef</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const ref = useRef(initialValue);</pre>
			<p>An initial value can optionally be passed into <strong class="source-inline">useRef</strong>. The type of the ref can be explicitly defined in a generic argument <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">useRef</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const ref = useRef<strong class="bold">&lt;Ref&gt;</strong>(initialValue);</pre>
			<p>The generic argument is useful when no initial value is passed or is <strong class="source-inline">null</strong>. This is because TypeScript won’t be able to infer the <span class="No-Break">type correctly.</span></p>
			<p>The value of the ref is<a id="_idIndexMarker338"/> accessed via its <span class="No-Break"><strong class="source-inline">current</strong></span><span class="No-Break"> property:</span></p>
			<pre class="source-code">
console.log("Current ref value", ref<strong class="bold">.current</strong>);</pre>
			<p>The value of the ref can be updated via its current property <span class="No-Break">as well:</span></p>
			<pre class="source-code">
ref.current = newValue;</pre>
			<p>A common use of the <strong class="source-inline">useRef</strong> Hook is to access HTML elements imperatively. HTML elements have a <strong class="source-inline">ref</strong> attribute in JSX that can be assigned to a ref. The following is an example <span class="No-Break">of this:</span></p>
			<pre class="source-code">
function MyComponent() {
  <strong class="bold">const inputRef = useRef&lt;HTMLInputElement&gt;(null)</strong>;
  function doSomething() {
    console.log(
      "All the properties and methods of the input",
      <strong class="bold">inputRef.current</strong>
    );
  }
  return &lt;input <strong class="bold">ref={inputRef}</strong> type="text" /&gt;;
}</pre>
			<p>The ref used here is called <strong class="source-inline">inputRef</strong> and is initially <strong class="source-inline">null</strong>. So, it is explicitly given a type of <strong class="source-inline">HTMLInputElement</strong>, which is a standard type for input elements. The ref is then assigned to the <strong class="source-inline">ref</strong> attribute on an input element in JSX. All the input’s properties and methods are then accessible via the ref’s <span class="No-Break"><strong class="source-inline">current</strong></span><span class="No-Break"> property.</span></p>
			<p>Next, we will use the <strong class="source-inline">useRef</strong> Hook in the <span class="No-Break"><strong class="source-inline">PersonScore</strong></span><span class="No-Break"> component.</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor115"/>Using the ref Hook</h2>
			<p>We will enhance the <strong class="source-inline">PersonScore</strong> component we have been working on to use <strong class="source-inline">useRef</strong> to move the focus to<a id="_idIndexMarker339"/> the <strong class="bold">Add</strong> button. To do this, carry out the following steps. All the code snippets used are available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section3-Using-the-ref-hook/src/PersonScore.tsx"><span class="No-Break">https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section3-Using-the-ref-hook/src/PersonScore.tsx</span></a><span class="No-Break">:</span></p>
			<ol>
				<li value="1">Open <strong class="source-inline">PersonScore.tsx</strong> and import <strong class="source-inline">useRef</strong> <span class="No-Break">from React:</span><pre class="source-code">
import { useEffect, useReducer<strong class="bold">, useRef</strong> } from 'react';</pre></li>
				<li>Create a ref for the <strong class="bold">Add</strong> button just below the <span class="No-Break"><strong class="source-inline">useReducer</strong></span><span class="No-Break"> statement:</span><pre class="source-code">
const [ ... ] = useReducer( ... );</pre><pre class="source-code">
<strong class="bold">const addButtonRef = useRef&lt;HTMLButtonElement&gt;(null);</strong></pre><pre class="source-code">
useEffect( ... )</pre></li>
			</ol>
			<p>The ref is named <strong class="source-inline">addButtonRef</strong> and is initially <strong class="source-inline">null</strong>. It is given the standard <span class="No-Break"><strong class="source-inline">HTMLButtonElement</strong></span><span class="No-Break"> type.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">All the standard HTML elements have corresponding TypeScript types for React. Right-click on the <strong class="source-inline">HTMLButtonElement</strong> type and choose <strong class="bold">Go to Definition</strong> to discover all these types. The React TypeScript types will open containing all the HTML <span class="No-Break">element types.</span></p>
			<ol>
				<li value="3">Assign the ref to the <strong class="source-inline">ref</strong> attribute on the <strong class="bold">Add</strong> button <span class="No-Break">JSX element:</span><pre class="source-code">
&lt;button</pre><pre class="source-code">
  <strong class="bold">ref={addButtonRef}</strong></pre><pre class="source-code">
  onClick={() =&gt; dispatch({ type: 'increment' })}</pre><pre class="source-code">
&gt;</pre><pre class="source-code">
  Add</pre><pre class="source-code">
&lt;/button&gt;</pre></li>
				<li>Now that we <a id="_idIndexMarker340"/>have a reference to the <strong class="bold">Add</strong> button, we can invoke it’s <strong class="source-inline">focus</strong> method to move the focus to it when the person’s information has been fetched. Let’s add another effect to do this below the existing effect that fetches <span class="No-Break">the person:</span><pre class="source-code">
useEffect(() =&gt; {</pre><pre class="source-code">
  getPerson().then(({ name }) =&gt;</pre><pre class="source-code">
    dispatch({ type: 'initialize', name })</pre><pre class="source-code">
  );</pre><pre class="source-code">
}, []);</pre><pre class="source-code">
<strong class="bold">useEffect(() =&gt; {</strong></pre><pre class="source-code">
<strong class="bold">  if (!loading) {</strong></pre><pre class="source-code">
<strong class="bold">    addButtonRef.current?.focus();</strong></pre><pre class="source-code">
<strong class="bold">  }</strong></pre><pre class="source-code">
<strong class="bold">}, [loading]);</strong></pre><pre class="source-code">
if (loading) {</pre><pre class="source-code">
  return &lt;div&gt;Loading ...&lt;/div&gt;;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The effect is executed when the <strong class="source-inline">loading</strong> state is <strong class="source-inline">true</strong>, which will be after the person has <span class="No-Break">been fetched.</span></p>
			<p>Notice the <strong class="source-inline">?</strong> symbol after the <strong class="source-inline">current</strong> property on the ref. This is the <strong class="bold">optional chaining</strong> operator, and it allows<a id="_idIndexMarker341"/> the <strong class="source-inline">focus</strong> method to be invoked without having to check that <strong class="source-inline">current</strong> is not <strong class="source-inline">null</strong>. Visit the following link for more information <a id="_idIndexMarker342"/>about optional <span class="No-Break">chaining: </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining</span></a><span class="No-Break">.</span></p>
			<p>We could have moved the focus to the <strong class="bold">Add</strong> button in the existing effect <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
useEffect(() =&gt; {
  getPerson().then(({ name }) =&gt; {
    dispatch({ type: 'initialize', name });
    <strong class="bold">addButtonRef.current?.focus();</strong>
  });
}, []);</pre>
			<p>However, this is mixing the concerns of fetching data, setting state, and setting focus to a button. Mixing concerns like this can make components hard to understand <span class="No-Break">and change.</span></p>
			<ol>
				<li value="5">If you refresh the browser containing the running app, you will see a focus indicator on the <span class="No-Break"><strong class="bold">Add</strong></span><span class="No-Break"> button:</span></li>
			</ol>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B19051_04_06.jpg" alt="Figure 4.6 – The focused Add button"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – The focused Add button</p>
			<p>If you press the <em class="italic">Enter</em> key, you will see that the <strong class="bold">Add</strong> button is clicked and the score incremented. This proves that the <strong class="bold">Add</strong> button <span class="No-Break">is focused.</span></p>
			<p>That completes the enhancement and our exploration of the <span class="No-Break">ref Hook.</span></p>
			<p>To recap, the <strong class="source-inline">useRef</strong> Hook creates a mutatable value and doesn’t cause a re-render when changed. It is commonly used to access HTML elements in <span class="No-Break">React imperatively.</span></p>
			<p>Next, we will learn about<a id="_idIndexMarker343"/> the <span class="No-Break">memo Hook.</span></p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor116"/>Using the memo Hook</h1>
			<p>In this section, we will learn about the memo Hook and where it is useful. We will then walk through an example in the <strong class="source-inline">PersonScore</strong> component we have been <span class="No-Break">working on.</span></p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor117"/>Understanding the memo Hook</h2>
			<p>The memo Hook creates a <a id="_idIndexMarker344"/>memoized value and is beneficial for values that have computationally expensive calculations. The Hook is called <strong class="source-inline">useMemo</strong> and the syntax is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const memoizedValue = useMemo(() =&gt; expensiveCalculation(), []);</pre>
			<p>A function that returns the value to memoize is passed into <strong class="source-inline">useMemo</strong> as the first argument. The function in this first argument should perform the <span class="No-Break">expensive calculation.</span></p>
			<p>The second argument passed to <strong class="source-inline">useMemo</strong> is an array of dependencies. So, if the <strong class="source-inline">expensiveCalculation</strong> function has dependencies <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>, the call will be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const memoizedValue = useMemo(
  () =&gt; expensiveCalculation(<strong class="bold">a, b</strong>),
  [<strong class="bold">a, b</strong>]
);</pre>
			<p>When any dependencies change, the function in the first argument is executed again to return a new value to memoize. In the previous example, a new version of <strong class="source-inline">memoizedValue</strong> is created every time <strong class="source-inline">a</strong> or <span class="No-Break"><strong class="source-inline">b</strong></span><span class="No-Break"> changes.</span></p>
			<p>The type of the memoized value is inferred but can be explicitly defined in a generic parameter on <strong class="source-inline">useMemo</strong>. The following is an example of explicitly defining that the memoized value should have a <span class="No-Break"><strong class="source-inline">number</strong></span><span class="No-Break"> type:</span></p>
			<pre class="source-code">
 const memoizedValue = useMemo<strong class="bold">&lt;number&gt;</strong>(
  () =&gt; expensiveCalculation(),
  []
);</pre>
			<p>Next, we will <a id="_idIndexMarker345"/>experiment <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">useMemo</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor118"/>Using the memo Hook</h2>
			<p>We will use the <strong class="source-inline">PersonScore</strong> component<a id="_idIndexMarker346"/> we have been working on to play with the <strong class="source-inline">useMemo</strong> Hook. To do so, carry out the following steps. The code snippets used are available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4/Section4-Using-the-memo-hook"><span class="No-Break">https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4/Section4-Using-the-memo-hook</span></a><span class="No-Break">:</span></p>
			<ol>
				<li value="1">Open <strong class="source-inline">PersonScore.tsx</strong> and import <strong class="source-inline">useMemo</strong> <span class="No-Break">from React:</span><pre class="source-code">
import {</pre><pre class="source-code">
  useEffect,</pre><pre class="source-code">
  useReducer,</pre><pre class="source-code">
  useRef<strong class="bold">,</strong></pre><pre class="source-code">
<strong class="bold">  useMemo</strong></pre><pre class="source-code">
} from 'react';</pre></li>
				<li>Add the following expensive function below the <span class="No-Break">import statements:</span><pre class="source-code">
function sillyExpensiveFunction() {</pre><pre class="source-code">
  console.log("Executing silly function");</pre><pre class="source-code">
  let sum = 0;</pre><pre class="source-code">
  for (let i = 0; i &lt; 10000; i++) {</pre><pre class="source-code">
    sum += i;</pre><pre class="source-code">
  }</pre><pre class="source-code">
  return sum;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The function adds all the numbers between <strong class="source-inline">0</strong> and <strong class="source-inline">10000</strong> and will take a while <span class="No-Break">to execute.</span></p>
			<ol>
				<li value="3">Add a call to the <a id="_idIndexMarker347"/>function in the <strong class="source-inline">PersonScore</strong> component beneath <span class="No-Break">the effects:</span><pre class="source-code">
useEffect( ... );</pre><pre class="source-code">
<strong class="bold">const expensiveCalculation = sillyExpensiveFunction();</strong></pre><pre class="source-code">
if (loading) {</pre><pre class="source-code">
  return &lt;div&gt;Loading ...&lt;/div&gt;;</pre><pre class="source-code">
}</pre></li>
				<li>Add the result of the function call to the JSX underneath <strong class="source-inline">name</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">score</strong></span><span class="No-Break">:</span><pre class="source-code">
&lt;h3&gt;</pre><pre class="source-code">
  {name}, {score}</pre><pre class="source-code">
&lt;/h3&gt;</pre><pre class="source-code">
<strong class="bold">&lt;p&gt;{expensiveCalculation}&lt;/p&gt;</strong></pre><pre class="source-code">
&lt;button ... &gt;</pre><pre class="source-code">
  Add</pre><pre class="source-code">
&lt;/button&gt;</pre></li>
				<li>Refresh the browser containing the app and click the buttons. If you look in the console, you will see that the expensive function is executed every time the component is re-rendered after a <span class="No-Break">button click.</span></li>
			</ol>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B19051_04_07.jpg" alt="Figure 4.7 – The expensive function executed multiple times"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – The expensive function executed multiple times</p>
			<p>Remember that a double render occurs in development mode and React’s Strict Mode. So, once a button is clicked, you will see <strong class="bold">Executing silly function</strong> in the <span class="No-Break">console twice.</span></p>
			<p>An expensive<a id="_idIndexMarker348"/> function executing each time a component is re-rendered can lead to <span class="No-Break">performance problems.</span></p>
			<ol>
				<li value="6">Rework the call to <strong class="source-inline">sillyExpensiveFunction</strong> <span class="No-Break">as follows:</span><pre class="source-code">
const expensiveCalculation = <strong class="bold">useMemo(</strong></pre><pre class="source-code">
<strong class="bold">  () =&gt;</strong> sillyExpensiveFunction()<strong class="bold">,</strong></pre><pre class="source-code">
<strong class="bold">  []</strong></pre><pre class="source-code">
<strong class="bold">)</strong>;</pre></li>
			</ol>
			<p>The <strong class="source-inline">useMemo</strong> Hook is used to memoize the value from the <span class="No-Break">function call.</span></p>
			<ol>
				<li value="7">Refresh the browser containing the running app and click the buttons. If you look in the console, you will see that the expensive function isn’t executed when the buttons are clicked because the memoized value is <span class="No-Break">used instead.</span></li>
			</ol>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B19051_04_08.jpg" alt="Figure 4.8 – The expensive function call memoized"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – The expensive function call memoized</p>
			<p>That completes our exploration of the <strong class="source-inline">useMemo</strong> Hook. The takeaway from this section is that the <strong class="source-inline">useMemo</strong> Hook helps improve the performance of function calls by memoizing their results and <a id="_idIndexMarker349"/>using the memoized value when the function <span class="No-Break">is re-executed.</span></p>
			<p>Next, we will look at another Hook that can <span class="No-Break">help performance.</span></p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor119"/>Using the callback Hook</h1>
			<p>In this section, we will learn about the<a id="_idIndexMarker350"/> callback Hook and where it is useful. We will then use the Hook in the <strong class="source-inline">PersonScore</strong> component we have been <span class="No-Break">working on.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor120"/>Understanding the callback Hook</h2>
			<p>The callback Hook memoizes a function so that it isn’t recreated on each render. The Hook is called <strong class="source-inline">useCallback</strong> and the syntax is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const memoizedCallback = useCallback(() =&gt; someFunction(), []);</pre>
			<p>A function that executes the function to memoize is passed into <strong class="source-inline">useCallback</strong> as the first argument. The second argument passed to <strong class="source-inline">useCallback</strong> is an array of dependencies. So, if the <strong class="source-inline">someFunction</strong> function has dependencies <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>, the call will be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const memoizedCallback = useCallback(
  () =&gt; someFunction(<strong class="bold">a, b</strong>),
  [<strong class="bold">a, b</strong>]
);</pre>
			<p>When any dependencies change, the function in the first argument is executed again to return a new function to memoize. In the previous example, a new version of <strong class="source-inline">memoizedCallback</strong> is created every time <strong class="source-inline">a</strong> or <span class="No-Break"><strong class="source-inline">b</strong></span><span class="No-Break"> changes.</span></p>
			<p>The type of the memoized function is inferred but can be explicitly defined in a generic parameter on <strong class="source-inline">useCallback</strong>. Here<a id="_idIndexMarker351"/> is an example of explicitly defining that the memoized function has no parameters and <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">void</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
 const memoizedValue = useCallback<strong class="bold">&lt;() =&gt; void&gt;</strong>(
  () =&gt; someFunction (),
  []
);</pre>
			<p>A common use case for <strong class="source-inline">useCallback</strong> is to prevent unnecessary re-renders of child components. Before trying <strong class="source-inline">useCallback</strong>, we will take the time to understand when a component <span class="No-Break">is re-rendered.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor121"/>Understanding when a component is re-rendered</h2>
			<p>We already understand that a <a id="_idIndexMarker352"/>component re-renders when its state changes. Consider the <span class="No-Break">following component:</span></p>
			<pre class="source-code">
export function SomeComponent() {
  const [someState, setSomeState] = useState('something');
  return (
    &lt;div&gt;
      &lt;ChildComponent /&gt;
      &lt;AnotherChildComponent something={someState} /&gt;
      &lt;button
        onClick={() =&gt; setSomeState('Something else')}
      &gt;&lt;/button&gt;
    &lt;/div&gt;
  );
}</pre>
			<p>When <strong class="source-inline">someState</strong> changes, <strong class="source-inline">SomeComponent</strong> will re-render – for example, when the button is clicked. In addition, <strong class="source-inline">ChildComponent</strong> and <strong class="source-inline">AnotherChildComponent</strong> will re-render when <strong class="source-inline">someState</strong> changes. This is because a component is re-rendered when its parent <span class="No-Break">is re-rendered.</span></p>
			<p>It may seem like this re-rendering behavior will cause performance problems – particularly when a component is rendered near the top of a large component tree. However, it rarely does cause performance issues. This is because the DOM will only be updated after a re-render<a id="_idIndexMarker353"/> if the virtual DOM changes, and updating the DOM is the slow part of the process. In the preceding example, the DOM for <strong class="source-inline">ChildComponent</strong> won’t be updated when <strong class="source-inline">SomeComponent</strong> is re-rendered if the definition of <strong class="source-inline">ChildComponent</strong> is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
export function ChildComponent() {
  return &lt;span&gt;A child component&lt;/span&gt;;
}</pre>
			<p>The DOM for <strong class="source-inline">ChildComponent</strong> won’t be updated during a re-render because the virtual DOM will <span class="No-Break">be unchanged.</span></p>
			<p>While this re-rendering behavior generally doesn’t cause performance problems, it can cause performance issues if a computationally expensive component is frequently re-rendered or a component with a slow side effect is frequently re-rendered. For example, we would want to avoid unnecessary re-renders in components with a side effect that <span class="No-Break">fetches data.</span></p>
			<p>There is a function called <strong class="source-inline">memo</strong> in React that can be used to prevent unnecessary re-renders. The memo function can be applied as follows to <strong class="source-inline">ChildComponent</strong> to prevent <span class="No-Break">unnecessary re-renders:</span></p>
			<pre class="source-code">
export const ChildComponent = memo(() =&gt; {
  return &lt;span&gt;A child component&lt;/span&gt;;
});</pre>
			<p>The <strong class="source-inline">memo</strong> function wraps the component and memoizes the result for a given set of props. The memoized function is then used during a re-render if the props are the same. Note that the preceding code snippet uses arrow function syntax so that the component can be a <span class="No-Break">named export.</span></p>
			<p>In summary, React’s <strong class="source-inline">memo</strong> function<a id="_idIndexMarker354"/> can prevent the unnecessary re-rendering of <span class="No-Break">slow components.</span></p>
			<p>Next, we will use the <strong class="source-inline">memo</strong> function and the <strong class="source-inline">useCallback</strong> Hook to prevent <span class="No-Break">unnecessary re-renders.</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor122"/>Using the callback Hook</h2>
			<p>We will now refactor the <strong class="source-inline">PersonScore</strong> component by extracting the <strong class="bold">Reset</strong> button into a separate component called <strong class="source-inline">Reset</strong>. This will lead to unnecessary re-rendering of the <strong class="source-inline">Reset</strong> component, which <a id="_idIndexMarker355"/>we will resolve using React’s <strong class="source-inline">memo</strong> function and the <span class="No-Break"><strong class="source-inline">useCallback</strong></span><span class="No-Break"> Hook.</span></p>
			<p>To do so, carry out the following steps. The code snippets used are available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4/Section5-Using-the-callback-hook"><span class="No-Break">https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4/Section5-Using-the-callback-hook</span></a><span class="No-Break">:</span></p>
			<ol>
				<li value="1">Start by creating a new file in the <strong class="source-inline">src</strong> folder for the reset button called <strong class="source-inline">Reset.tsx</strong> with the <span class="No-Break">following content:</span><pre class="source-code">
type Props = {</pre><pre class="source-code">
  onClick: () =&gt; void,</pre><pre class="source-code">
};</pre><pre class="source-code">
export function Reset({ onClick }: Props) {</pre><pre class="source-code">
  console.log("render Reset");</pre><pre class="source-code">
  return &lt;button onClick={onClick}&gt;Reset&lt;/button&gt;;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The component takes in a click handler and displays the reset button. The component also outputs <strong class="bold">render Reset</strong> to the console so that we can clearly see when the component <span class="No-Break">is re-rendered.</span></p>
			<ol>
				<li value="2">Open <strong class="source-inline">PersonScore.tsx</strong> and import the <span class="No-Break"><strong class="source-inline">Reset</strong></span><span class="No-Break"> component:</span><pre class="source-code">
import { Reset } from './Reset';</pre></li>
				<li>Replace the existing reset<a id="_idIndexMarker356"/> button with the new <strong class="source-inline">Reset</strong> component <span class="No-Break">as follows:</span><pre class="source-code">
&lt;div&gt;</pre><pre class="source-code">
  ...</pre><pre class="source-code">
  &lt;button onClick={() =&gt; dispatch({ type: 'decrement' })}&gt;</pre><pre class="source-code">
    Subtract</pre><pre class="source-code">
  &lt;/button&gt;</pre><pre class="source-code">
  <strong class="bold">&lt;Reset onClick={() =&gt; dispatch({ type: 'reset' })} /&gt;</strong></pre><pre class="source-code">
&lt;/div&gt;;</pre></li>
				<li>Go to the app running in the browser and open React’s DevTools. Make sure the <strong class="bold">Highlight updates when components render.</strong> option is ticked in the <strong class="bold">Components</strong> <span class="No-Break">panel’s settings:</span></li>
			</ol>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B19051_04_09.jpg" alt="Figure 4.9 – The re-render highlight option"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – The re-render highlight option</p>
			<ol>
				<li value="5">In the browser, the <strong class="bold">Reset</strong> button will work as it did before. Click this button as well as the <strong class="bold">Add</strong> and <strong class="bold">Subtract</strong> buttons. If you look at the console you’ll notice that <strong class="source-inline">Reset</strong> is unnecessarily re-rendered. You will also see the re-render highlight around the <span class="No-Break"><strong class="bold">Reset</strong></span><span class="No-Break"> button.</span></li>
			</ol>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B19051_04_10.jpg" alt="Figure 4.10 – The unnecessary re-renders of the Reset component"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – The unnecessary re-renders of the Reset component</p>
			<ol>
				<li value="6">Use the browser’s DevTools to <a id="_idIndexMarker357"/>inspect the DOM. To do this, right-click on the <strong class="bold">Reset</strong> button and choose <strong class="bold">Inspect</strong>. Click the buttons and observe the DOM elements. The DevTools in Chrome highlight elements when they are updated. You will see that only the <strong class="source-inline">h3</strong> element content was updated – none of the other elements are highlighted due to an <span class="No-Break">update occurring.</span></li>
			</ol>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B19051_04_11.jpg" alt="Figure 4.11 – The h3 element was updated after a re-render"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – The h3 element was updated after a re-render</p>
			<p>Even though <strong class="source-inline">Reset</strong> is unnecessarily re-rendered, it doesn’t result in a DOM update. In addition, <strong class="source-inline">Reset</strong> isn’t <a id="_idIndexMarker358"/>computationally expensive and doesn’t contain any side effects. So, the unnecessary render isn’t really a performance problem. However, we will use this example to learn how to use React’s <strong class="source-inline">memo</strong> function, and the <strong class="source-inline">useCallback</strong> Hook can prevent the <span class="No-Break">unnecessary render.</span></p>
			<ol>
				<li value="7">We will now add React’s <strong class="source-inline">memo</strong> function to try to prevent unnecessary re-renders. Open <strong class="source-inline">React.tsx</strong> and add a React import statement to import <strong class="source-inline">memo</strong> at the top of <span class="No-Break">the file:</span><pre class="source-code">
import { memo } from 'react';</pre></li>
				<li>Now, wrap <strong class="source-inline">memo</strong> around the <strong class="source-inline">Reset</strong> component <span class="No-Break">as follows:</span><pre class="source-code">
export <strong class="bold">const Reset = memo(</strong>({ onClick }: Props) <strong class="bold">=&gt;</strong> {</pre><pre class="source-code">
  console.log("render Reset");</pre><pre class="source-code">
  return &lt;button onClick={onClick}&gt;Reset&lt;/button&gt;;</pre><pre class="source-code">
}<strong class="bold">)</strong>;</pre></li>
				<li>In addition, add the following line beneath the <strong class="source-inline">Reset</strong> component definition so that it has a meaningful name in <span class="No-Break">React’s DevTools:</span><pre class="source-code">
Reset.displayName = 'Reset';</pre></li>
				<li>In the browser, click the <strong class="bold">Add</strong>, <strong class="bold">Subtract</strong>, and <strong class="bold">Reset</strong> buttons. Then, look at the console and notice that <strong class="source-inline">Reset</strong> is <em class="italic">still</em> <span class="No-Break">unnecessarily re-rendered.</span></li>
				<li>We will use React’s DevTools to start to understand why Reset is still unnecessarily re-rendered when its result is memoized. Open the <strong class="bold">Profiler</strong> panel and click the cog icon to open<a id="_idIndexMarker359"/> the settings. Go to the <strong class="bold">Profiler</strong> settings section and make sure <strong class="bold">Record why each component rendered while profiling.</strong> <span class="No-Break">is ticked:</span></li>
			</ol>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B19051_04_12.jpg" alt="Figure 4.12 – Ensuring the Record why each component rendered while profiling. option is ticked"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – Ensuring the Record why each component rendered while profiling. option is ticked</p>
			<ol>
				<li value="12">Click the blue circle icon to start profiling and then click the <strong class="bold">Add</strong> button in our app. Click the red circle icon to <span class="No-Break">stop profiling.</span></li>
				<li>In the flamegraph that appears, click the <strong class="bold">Reset</strong> bar. This gives useful information about the <strong class="source-inline">Reset</strong> <span class="No-Break">component re-render:</span></li>
			</ol>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B19051_04_13.jpg" alt="Figure 4.13 – Information about the Reset re-render"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13 – Information about the Reset re-render</p>
			<p>So, the unnecessary <strong class="source-inline">Reset</strong> render is happening because the <strong class="source-inline">onClick</strong> prop changes. The <strong class="source-inline">onClick</strong> handler contains the same code, but a new instance of the function is created on every render. This means <strong class="source-inline">onClick</strong> will have a different reference on each render. The changing <strong class="source-inline">onClick</strong> prop reference means that the memorized<a id="_idIndexMarker360"/> result from <strong class="source-inline">Reset</strong> isn’t used and a re-render <span class="No-Break">occurs instead.</span></p>
			<ol>
				<li value="14">We can use the <strong class="source-inline">useCallback</strong> Hook to memoize the <strong class="source-inline">onClick</strong> handler and prevent the re-render. Open <strong class="source-inline">PersonScore.tsx</strong> and start by refactoring the handler into a <span class="No-Break">named function:</span><pre class="source-code">
<strong class="bold">function handleReset() {</strong></pre><pre class="source-code">
<strong class="bold">  dispatch({ type: 'reset' });</strong></pre><pre class="source-code">
<strong class="bold">}</strong></pre><pre class="source-code">
if (loading) {</pre><pre class="source-code">
  return &lt;div&gt;Loading ...&lt;/div&gt;;</pre><pre class="source-code">
}</pre><pre class="source-code">
return (</pre><pre class="source-code">
  &lt;div&gt;</pre><pre class="source-code">
    ...</pre><pre class="source-code">
    &lt;Reset onClick={<strong class="bold">handleReset</strong>} /&gt;</pre><pre class="source-code">
  &lt;/div&gt;</pre><pre class="source-code">
);</pre></li>
				<li>Now, add <strong class="source-inline">useCallback</strong> to the React <span class="No-Break">import statement:</span><pre class="source-code">
import {</pre><pre class="source-code">
  useEffect,</pre><pre class="source-code">
  useReducer,</pre><pre class="source-code">
  useRef,</pre><pre class="source-code">
  useMemo<strong class="bold">,</strong></pre><pre class="source-code">
<strong class="bold">  useCallback</strong></pre><pre class="source-code">
} from 'react';</pre></li>
				<li>Lastly, wrap <strong class="source-inline">useCallback</strong> around <a id="_idIndexMarker361"/>the click handler we <span class="No-Break">just created:</span><pre class="source-code">
<strong class="bold">const handleReset = useCallback(</strong></pre><pre class="source-code">
  <strong class="bold">() =&gt;</strong> dispatch({ type: 'reset' })<strong class="bold">,</strong></pre><pre class="source-code">
<strong class="bold">  []</strong></pre><pre class="source-code">
<strong class="bold">);</strong></pre></li>
				<li>Now, if you click the <strong class="bold">Add</strong>, <strong class="bold">Subtract</strong>, and <strong class="bold">Reset</strong> buttons, you will notice that <strong class="source-inline">Reset</strong> is no longer <span class="No-Break">unnecessarily re-rendered.</span></li>
			</ol>
			<p>That completes our exploration of the <span class="No-Break"><strong class="source-inline">useCallback</strong></span><span class="No-Break"> Hook.</span></p>
			<p>Here’s a quick recap of everything we learned in <span class="No-Break">this section:</span></p>
			<ul>
				<li>A component is re-rendered when its parent <span class="No-Break">is re-rendered.</span></li>
				<li>React’s <strong class="source-inline">memo</strong> function can be used to prevent unnecessary re-renders to <span class="No-Break">child components.</span></li>
				<li><strong class="source-inline">useCallback</strong> can be used to memoize functions. This can be used to create a stable reference for function props passed to child components to prevent <span class="No-Break">unnecessary re-renders.</span></li>
				<li>React’s <strong class="source-inline">memo</strong> function and <strong class="source-inline">useCallback</strong> should be used wisely – make sure they help performance <a id="_idIndexMarker362"/>before using them because they increase the complexity of <span class="No-Break">the code.</span></li>
			</ul>
			<p>Next, we will summarize <span class="No-Break">the chapter.</span></p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor123"/>Summary</h1>
			<p>In this chapter, we learned that all React Hooks must be called at the top level of a function component and can’t be <span class="No-Break">called conditionally.</span></p>
			<p>The <strong class="source-inline">useEffect</strong> Hook can be used to execute component side effects when it is rendered. We learned how to use <strong class="source-inline">useEffect</strong> to fetch data, which is a common <span class="No-Break">use case.</span></p>
			<p><strong class="source-inline">useReducer</strong> is an alternative to <strong class="source-inline">useState</strong> for using state, and we experienced using both approaches in our <strong class="source-inline">PersonScore</strong> example component. <strong class="source-inline">useState</strong> is excellent for primitive state values. <strong class="source-inline">useReducer</strong> is great for complex object state values, particularly when state changes depend on previous <span class="No-Break">state values.</span></p>
			<p>The <strong class="source-inline">useRef</strong> Hook creates a mutatable value and doesn’t cause a re-render when changed. We used <strong class="source-inline">useRef</strong> to set focus to an HTML element after it was rendered, which is a common <span class="No-Break">use case.</span></p>
			<p>The <strong class="source-inline">useMemo</strong> and <strong class="source-inline">useCallback</strong> Hooks can be used to memoize values and functions, respectively, and can be used for performance optimization. The examples we used for these Hooks were a little contrived and using <strong class="source-inline">useCallback</strong> didn’t improve performance, so remember to check that the use of these Hooks does <span class="No-Break">improve performance.</span></p>
			<p>So far in this book, the components we have created are unstyled. In the next chapter, we will learn several approaches for styling <span class="No-Break">React components.</span></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor124"/>Questions</h1>
			<p>Answer the following questions to check what you have learned about <span class="No-Break">React Hooks:</span></p>
			<ol>
				<li value="1">The following component renders some text for 5 seconds. This is problematic though – what is <span class="No-Break">the problem?</span><pre class="source-code">
export function TextVanish({ text }: Props) {</pre><pre class="source-code">
  if (!text) {</pre><pre class="source-code">
    return null;</pre><pre class="source-code">
  }</pre><pre class="source-code">
  const [textToRender, setTextToRender] = useState(text);</pre><pre class="source-code">
  useEffect(() =&gt; {</pre><pre class="source-code">
    setTimeout(() =&gt; setTextToRender(""), 5000);</pre><pre class="source-code">
  }, []);</pre><pre class="source-code">
  return &lt;span&gt;{textToRender}&lt;/span&gt;;</pre><pre class="source-code">
}</pre></li>
				<li>The following code is a snippet from a React component that fetches some data and stores it in state. There are several problems with this code though – can you spot any of <span class="No-Break">the problems?</span><pre class="source-code">
const [data, setData] = useState([]);</pre><pre class="source-code">
useEffect(async () =&gt; {</pre><pre class="source-code">
  const data = await getData();</pre><pre class="source-code">
  setData(data);</pre><pre class="source-code">
});</pre></li>
				<li>How many times will the following component re-render in production mode when the button is clicked? Also, what will the button content be after <span class="No-Break">one click?</span><pre class="source-code">
export function Counter() {</pre><pre class="source-code">
  const [count, setCount] = useState(0);</pre><pre class="source-code">
  return (</pre><pre class="source-code">
    &lt;button</pre><pre class="source-code">
      onClick={() =&gt; {</pre><pre class="source-code">
        setCount(count + 1);</pre><pre class="source-code">
        setCount(count + 1);</pre><pre class="source-code">
        setCount(count + 1);</pre><pre class="source-code">
      }}</pre><pre class="source-code">
    &gt;</pre><pre class="source-code">
      {count}</pre><pre class="source-code">
    &lt;/button&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre></li>
				<li>How many times will the following component re-render in production mode when the button is clicked? Also, what will the button content be after <span class="No-Break">one click?</span><pre class="source-code">
export function CounterRef() {</pre><pre class="source-code">
  const count = useRef(0);</pre><pre class="source-code">
  return (</pre><pre class="source-code">
    &lt;button</pre><pre class="source-code">
      onClick={() =&gt; {</pre><pre class="source-code">
        count.current = count.current + 1;</pre><pre class="source-code">
      }}</pre><pre class="source-code">
    &gt;</pre><pre class="source-code">
      {count.current}</pre><pre class="source-code">
    &lt;/button&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre></li>
				<li>Consider the following <span class="No-Break"><strong class="source-inline">reducer</strong></span><span class="No-Break"> function:</span><pre class="source-code">
type State = { steps: number };</pre><pre class="source-code">
type Action =</pre><pre class="source-code">
  | { type: 'forward'; steps: number }</pre><pre class="source-code">
  | { type: 'backwards'; steps: number };</pre><pre class="source-code">
function reducer(state: State, action: Action): State {</pre><pre class="source-code">
  switch (action.type) {</pre><pre class="source-code">
    case 'forward':</pre><pre class="source-code">
      return { ...state, steps: state.steps + action.steps };</pre><pre class="source-code">
    case 'backwards':</pre><pre class="source-code">
      return { ...state, steps: state.steps - action.        steps };</pre><pre class="source-code">
    default:</pre><pre class="source-code">
      return state;</pre><pre class="source-code">
  }</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>What will the type of the <strong class="source-inline">action</strong> parameter be narrowed down to in the <strong class="source-inline">"backwards"</strong> <span class="No-Break">switch branch?</span></p>
			<ol>
				<li value="6">Consider the following <span class="No-Break"><strong class="source-inline">Counter</strong></span><span class="No-Break"> component:</span><pre class="source-code">
export function Counter() {</pre><pre class="source-code">
  const [count, setCount] = useState(0);</pre><pre class="source-code">
  const memoCount = useMemo(() =&gt; count, []);</pre><pre class="source-code">
  return (</pre><pre class="source-code">
    &lt;div&gt;</pre><pre class="source-code">
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;</pre><pre class="source-code">
        {memoCount}</pre><pre class="source-code">
      &lt;/button&gt;</pre><pre class="source-code">
    &lt;/div&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>What will the button content be after it is <span class="No-Break">clicked once?</span></p>
			<ol>
				<li value="7">Consider the following <span class="No-Break"><strong class="source-inline">Counter</strong></span><span class="No-Break"> component:</span><pre class="source-code">
export function Counter() {</pre><pre class="source-code">
  const [count, setCount] = useState(0);</pre><pre class="source-code">
  const handleClick = useCallback(() =&gt; {</pre><pre class="source-code">
    setCount(count + 1);</pre><pre class="source-code">
  }, []);</pre><pre class="source-code">
  return (</pre><pre class="source-code">
    &lt;div&gt;</pre><pre class="source-code">
      &lt;button onClick={handleClick}&gt;{count}&lt;/button&gt;</pre><pre class="source-code">
    &lt;/div&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>What will the button content be after it is <span class="No-Break">clicked twice?</span></p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor125"/>Answers</h1>
			<ol>
				<li value="1">The problem with the component is that both <strong class="source-inline">useState</strong> and <strong class="source-inline">useEffect</strong> are called conditionally (when the <strong class="source-inline">text</strong> prop is defined), and React doesn’t allow its Hooks to be called conditionally. Placing the Hooks before the <strong class="source-inline">if</strong> statement resolves <span class="No-Break">the problem:</span><pre class="source-code">
export function TextVanish({ text }: Props) {</pre><pre class="source-code">
  <strong class="bold">const [textToRender, setTextToRender] = useState(text);</strong></pre><pre class="source-code">
<strong class="bold">  useEffect(() =&gt; {</strong></pre><pre class="source-code">
<strong class="bold">    setTimeout(() =&gt; setTextToRender(""), 5000);</strong></pre><pre class="source-code">
<strong class="bold">  }, []);</strong></pre><pre class="source-code">
  if (!text) {</pre><pre class="source-code">
    return null;</pre><pre class="source-code">
  }</pre><pre class="source-code">
  return &lt;span&gt;{textToRender}&lt;/span&gt;;</pre><pre class="source-code">
}</pre></li>
				<li>The main problem with the code is that the effect function can’t be marked as asynchronous with the <strong class="source-inline">async</strong> keyword. A solution is to revert to the older <span class="No-Break">promise syntax:</span><pre class="source-code">
const [data, setData] = useState([]);</pre><pre class="source-code">
useEffect(() =&gt; {</pre><pre class="source-code">
  getData()<strong class="bold">.then((theData) =&gt; setData(theData))</strong>;</pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>The other major problem is that no dependencies are defined in the call to <strong class="source-inline">useEffect</strong>. This means the effect function will be executed on every render. The effect function sets some state, which causes a re-render. So, the component will keep re-rendering, and the effect function will keep executing indefinitely. An empty array passed into the second argument of <strong class="source-inline">useEffect</strong> will resolve <span class="No-Break">the problem:</span></p>
			<pre class="source-code">
useEffect(() =&gt; {
  getData().then((theData) =&gt; setData(theData));
}<strong class="bold">, []</strong>);</pre>
			<p>Another problem is that the <strong class="source-inline">data</strong> state will have the <strong class="source-inline">any[]</strong> type, which isn’t ideal. In this case, it is probably better to explicitly define the type of the state <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const [data, setData] = useState<strong class="bold">&lt;Data[]&gt;</strong>([]);</pre>
			<p>The last problem is that the data state could be set after the component has been unmounted, which can lead to memory leaks. A solution is to set a flag when the component is unmounted and not set the state when the flag <span class="No-Break">is set:</span></p>
			<pre class="source-code">
useEffect(() =&gt; {
  <strong class="bold">let cancel = false;</strong>
  getData().then((theData) =&gt; {
    <strong class="bold">if (!cancel)</strong> {
      setData(theData);
    <strong class="bold">}</strong>
  });
  <strong class="bold">return () =&gt; {</strong>
<strong class="bold">    cancel = true;</strong>
<strong class="bold">  };</strong>
}, []);</pre>
			<ol>
				<li value="3">The button will only render once in production mode because state changes <span class="No-Break">are batched.</span></li>
			</ol>
			<p>The state isn’t changed until the next render, so clicking the button once will result in <strong class="source-inline">count</strong> being set to <strong class="source-inline">1</strong>, which means the button content will <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="4">The button will not re-render when the button is clicked because changes to a ref don’t cause <span class="No-Break">a re-render.</span></li>
			</ol>
			<p>The <strong class="source-inline">counter</strong> ref will be incremented when the button is clicked. However, because a re-render doesn’t occur, the button content will still <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="5">TypeScript will narrow the type of the <strong class="source-inline">action</strong> parameter to <strong class="source-inline">{ type: 'backwards</strong> <strong class="source-inline">'; steps: number }</strong> in the <strong class="source-inline">'backwards'</strong> <span class="No-Break">switch branch.</span></li>
				<li>The button’s content will always be <strong class="source-inline">0</strong> because the initial count of <strong class="source-inline">0</strong> is memoized and <span class="No-Break">never updated.</span></li>
				<li>The button content will be <strong class="source-inline">1</strong> after one click and will stay as <strong class="source-inline">1</strong> after subsequent clicks. So, after two clicks, it will <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>The key here is that the <strong class="source-inline">handleClick</strong> function is only created when the component is initially rendered because <strong class="source-inline">useCallback</strong> memoizes it. So, the <strong class="source-inline">count</strong> state will always be <strong class="source-inline">0</strong> within the memoized function. This means the <strong class="source-inline">count</strong> state will always be updated to <strong class="source-inline">1</strong>, which will appear in the <span class="No-Break">button content.</span></p>
		</div>
		<div>
			<div id="_idContainer078" class="IMG---Figure">
			</div>
		</div>
	

		<div id="_idContainer079" class="Content">
			<h1 id="_idParaDest-124"><a id="_idTextAnchor126"/>Part 2: App Fundamentals</h1>
			<p>This part covers the fundamental topics for building apps that are outside the core of React. These topics are styling, clientside routing, and forms. Each topic involves different approaches that you can take, along with the benefits of each one. We will also cover several popular third-party libraries that are commonly used for these parts of an application.  </p>
			<p>This part includes the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B19051_05.xhtml#_idTextAnchor127"><em class="italic">Chapter 5</em></a>, <em class="italic">Approaches to Styling React Frontends</em></li>
				<li><a href="B19051_06.xhtml#_idTextAnchor151"><em class="italic">Chapter 6</em></a>, <em class="italic">Routing with React Router</em></li>
				<li><a href="B19051_07.xhtml#_idTextAnchor188"><em class="italic">Chapter 7</em></a>, <em class="italic">Working with Forms</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer080">
			</div>
		</div>
	</body></html>