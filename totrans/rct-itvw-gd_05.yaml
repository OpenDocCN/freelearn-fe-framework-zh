- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Advanced Concepts of ReactJS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactJS 的高级概念
- en: Every web developer should have in-depth knowledge of React fundamentals, core
    concepts, Hooks, and router navigations to build a successful career in the React
    technology stack. But if you want to elevate your React skills to the next level,
    you should be able to build production-level apps by applying advanced React concepts
    such as portals, error boundaries, concurrent rendering features, profilers, and
    more. While some of these concepts were introduced a long time ago and improved
    with new features in each major release, other advanced concepts have only been
    introduced in recent releases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网页开发者都应该对 React 的基础知识、核心概念、Hooks 和路由导航有深入的了解，以便在 React 技术栈中建立成功的职业生涯。但如果你想要将你的
    React 技能提升到下一个层次，你应该能够通过应用高级 React 概念，如 Portals、错误边界、并发渲染特性、分析器等，来构建生产级别的应用。虽然其中一些概念很久以前就被引入，并且随着每个主要版本的更新而得到改进，但其他高级概念只在新版本中引入。
- en: In this chapter, you will understand the advanced concepts of ReactJS so that
    you can use them in various real-time use cases. Advanced concepts such as error
    boundaries, portals, concurrent rendering, and suspense, as well as code quality
    and performance optimization-related features such as strict mode, static type
    checking, and profilers, will be discussed to cover the interview questions for
    mid-level to senior developer candidates. At the end, we will quickly explore
    some questions related to React Native that are meant for mobile environments
    such as iOS and Android.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解 ReactJS 的高级概念，以便您可以在各种实时用例中使用它们。将讨论错误边界、Portals、并发渲染、Suspense 等高级概念，以及与代码质量和性能优化相关的特性，如严格模式、静态类型检查和分析器，以涵盖中级到高级开发者的面试问题。最后，我们将快速探讨一些与
    React Native 相关的问题，这些问题旨在针对 iOS 和 Android 等移动环境。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Exploring portals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Portals
- en: Understanding error boundaries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解错误边界
- en: Managing asynchronous actions with the Suspense API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Suspense API 管理异步操作
- en: Optimizing rendering performance using concurrent rendering
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发渲染优化渲染性能
- en: Debugging React applications with the Profiler API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Profiler API 调试 React 应用程序
- en: Strict mode
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格模式
- en: Static type checking
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类型检查
- en: React in mobile environments and its features
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动环境中的 React 及其特性
- en: The main objective of this chapter is to give you a clear understanding of React’s
    advanced concepts and tackle interview questions that are asked to test the advanced
    skill levels of any job aspirant.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是让您对 React 的高级概念有一个清晰的理解，并解决那些用来测试求职者高级技能水平的面试问题。
- en: Exploring portals
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Portals
- en: Nowadays, it is quite common to use model windows or popups on web pages to
    quickly grab the user’s attention. They help notify the user of some important
    information or ask the user to enter their input. But the implementation of these
    widgets is challenging in large apps since it involves writing complex CSS code
    and handling the DOM hierarchy. Fortunately, React provides the portals feature
    to solve these kinds of use cases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在网页上使用模型窗口或弹出窗口来快速吸引用户的注意力是非常常见的。它们有助于通知用户一些重要信息或请求用户输入。但在大型应用中实现这些小部件是具有挑战性的，因为它涉及到编写复杂的
    CSS 代码和处理 DOM 层级。幸运的是，React 提供了 Portals 功能来解决这类用例。
- en: Portals were introduced in 2017 and were first seen in React version 16\. They
    are used to render React components outside of the DOM hierarchy. The usage of
    portals is not typical, but they are helpful in specific use cases, as you will
    see in the following subsections.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Portals 在 2017 年被引入，首次出现在 React 版本 16 中。它们用于在 DOM 层级之外渲染 React 组件。Portals 的使用并不典型，但在某些特定用例中非常有帮助，您将在以下小节中看到。
- en: What are portals? How do you create them?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Portals？您如何创建它们？
- en: React portals allow you to render children into a DOM node that exists outside
    of the parent DOM hierarchy. Even though you render a child component outside
    the parent, the parent-child relationship still exists between the components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: React Portals 允许您将子组件渲染到存在于父 DOM 层级之外的 DOM 节点。尽管您在父组件之外渲染子组件，但组件之间仍然存在父子关系。
- en: 'A React portal can be created by calling the `createPortal` function, which
    is imported from the `react-dom` package. This function accepts two mandatory
    arguments and one optional argument:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用从 `react-dom` 包导入的 `createPortal` 函数来创建一个 React Portal。此函数接受两个必需参数和一个可选参数：
- en: '`Children`: Any JSX code that can be rendered with React.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Children`: 可以用React渲染的任何JSX代码。'
- en: '`DOMNode`: The DOM node where you need to render the portal’s content.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOMNode`: 需要在其中渲染门户内容的DOM节点。'
- en: '`Key`: A unique identifier to distinguish the portal inside the component tree.
    This is optional.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Key`: 用于在组件树中区分门户的唯一标识符。这是可选的。'
- en: 'The following example of a modal window shows how a portal is created at a
    particular DOM node outside the root tree hierarchy:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模态窗口的示例显示了如何在根树层次结构之外的特定DOM节点处创建门户：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, the portal returns a React node that can be rendered
    anywhere in the component tree. In this example, the returned node is going to
    be a modal widget. This modal has been appended to the document body and is available
    at the same level as the `root` node in the HTML.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，门户返回一个React节点，该节点可以在组件树中的任何位置渲染。在这个例子中，返回的节点将是一个模态小部件。这个模态已经被附加到文档主体上，并且与HTML中的`root`节点处于同一级别。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is common practice to name the top-level node `root` because everything inside
    it will be managed by React. Applications built with React alone usually have
    a single root node. But if you are integrating React into an existing application,
    you might have many isolated root DOM nodes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 常规做法是将顶级节点命名为`root`，因为其中的一切都将由React管理。仅使用React构建的应用程序通常只有一个根节点。但是，如果您正在将React集成到现有应用程序中，您可能有许多独立的根DOM节点。
- en: 'Any React component can use the preceding portal as a child component:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 任何React组件都可以将前面的门户用作子组件：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is no restriction on the number of portals that can be used in a particular
    component or an application. Using portals, you can also render React components
    into non-React server markup such as static or server-rendered pages and non-React
    DOM nodes that are managed outside of React.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 没有对特定组件或应用程序中可使用的门户数量的限制。使用门户，您还可以将React组件渲染到非React服务器标记（如静态或服务器端渲染的页面）和非React
    DOM节点中，这些节点由React之外管理。
- en: What are the common use cases of portals?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 门户的常见用例有哪些？
- en: 'In applications where you can see the child components visually breaking off
    of the parent container, portals can be useful. The most common use cases are
    listed here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在可以直观地看到子组件从父容器中分离的应用程序中，门户非常有用。最常见的用例如下列出：
- en: '**Modal windows or dialogue components**: Portals can be used to create large
    dialogues or modal windows that float over the rest of the web page without you
    having to worry about the parent component.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Modal windows or dialogue components**: 门户可用于创建大型对话框或模态窗口，这些窗口可以浮在网页的其余部分之上，而无需担心父组件。'
- en: '`overflow:hidden` or `z-index` styling, then tooltips created inside the portal
    won’t be cut off from their parent container.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用`overflow:hidden`或`z-index`样式，那么在门户内部创建的工具提示不会从其父容器中切断。
- en: '**Loaders**: When a background task such as fetching data from a database is
    in progress, it is sensible to show a loading screen on the modern web. This helps
    block the user from interacting with the application until the background task
    has been completed.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Loaders**: 当后台任务（如从数据库获取数据）正在进行时，在现代网络中显示加载屏幕是合理的。这有助于阻止用户在后台任务完成之前与应用程序交互。'
- en: '**Popovers**: Popovers are useful for quickly providing context information
    to the user. For example, profile cards can be used to display user profile information
    without the need to click and visit the profile itself. You can just read the
    details by hovering over the icon or button elements.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Popovers**: Popovers对于快速提供上下文信息非常有用。例如，可以使用个人资料卡片来显示用户个人资料信息，而无需点击并访问个人资料本身。您只需将鼠标悬停在图标或按钮元素上即可阅读详细信息。'
- en: '**Cookie alerts**: It is possible to create cookie alerts (or banners) so that
    visitors can choose what cookies are allowed to track while they’re visiting the
    website.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cookie alerts**: 可以创建cookie警报（或横幅），以便访客在访问网站时选择允许跟踪哪些cookie。'
- en: '**Drop-down menus**: If the drop-down menus are displayed inside a parent component
    that has hidden overflow styling, it can be created as a portal.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Drop-down menus**: 如果下拉菜单显示在具有隐藏溢出样式的父组件内部，则可以将其创建为门户。'
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By moving the child components outside the main component tree, the rendering
    performance will be optimized as the components aren’t re-rendering for each state
    update. Moreover, it provides the flexibility of abstraction.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将子组件移出主组件树，渲染性能将得到优化，因为组件不会在每次状态更新时重新渲染。此外，它提供了抽象的灵活性。
- en: How does event bubbling work inside portals?
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 门户内部的事件冒泡是如何工作的？
- en: Even though a portal exists somewhere in the DOM tree, the portal retains its
    position in the React component tree by supporting all component features, such
    as accessing props, state, context, and event propagation. This means event bubbling
    also works with portals.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 portal 存在于 DOM 树的某个位置，它通过支持所有组件功能（如访问 props、state、context 和事件传播）来保留其在 React
    组件树中的位置。这意味着事件冒泡也适用于 portals。
- en: 'The behavior of event bubbling in portals is similar to how a React child component
    fires events inside the component tree. The events that are fired from a portal
    will propagate upwards to ancestors in the containing React tree, even though
    those elements are not ancestors in the DOM tree. For example, in the following
    HTML code, the parent component under the main root (`#main-root`) can catch an
    uncaught bubbling event from a sibling node (`#dialog-root`) that’s been implemented
    using portals:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: portals 中事件冒泡的行为类似于 React 子组件在组件树内部触发事件。从 portals 触发的事件将向上传播到包含的 React 树中的祖先元素，即使这些元素在
    DOM 树中不是祖先。例如，在以下 HTML 代码中，位于主根（`#main-root`）下的父组件可以捕获一个未捕获的冒泡事件，该事件来自使用 portals
    实现的兄弟节点（`#dialog-root`）：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Event bubbling in portals follows the React tree but not the DOM tree.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: portals 中的事件冒泡遵循 React 树而不是 DOM 树。
- en: What accessibility precautions are taken care of in portals?
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 portals 中采取了哪些可访问性预防措施？
- en: You need to ensure that React applications built with portals are accessible,
    even for people with disabilities. For example, keyboard focus should work naturally
    when you move the focus between the modal window and the parent web page. The
    modal dialogues that are created as part of portals should follow the WAI-ARIA
    modal authoring practices ([https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/](https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/)).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保使用 portals 构建的 React 应用程序对残疾人士也是可访问的。例如，当你在不同模态窗口和父网页之间移动焦点时，键盘焦点应该自然工作。作为
    portals 部分创建的模态对话框应遵循 WAI-ARIA 模态编写实践（[https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/](https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/))。
- en: 'Some of the guidelines for achieving keyboard accessibility are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实现键盘可访问性的部分指南如下：
- en: When the dialog or modal is open, the focus moves to an element inside the dialog.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对话框或模态框打开时，焦点会移动到对话框内的一个元素。
- en: Tabbing the focusable elements should only cycle through the dialog elements.
    The focus should not skip the dialog that has been opened.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用制表符键在可聚焦元素之间循环时，应仅遍历对话框元素。焦点不应跳过已打开的对话框。
- en: After pressing the *Esc* key, the dialog should close.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下 *Esc* 键后，对话框应关闭。
- en: If you are going to use a third-party library to create the modals, you need
    to make sure that the package follows the required accessibility guidelines.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用第三方库来创建模态框，你需要确保该库遵循所需的可访问性指南。
- en: You will always encounter unexpected errors while building applications. These
    errors can occur in several ways, such as via network requests, invoking third-party
    APIs, accessing nested object properties that don’t exist, and so on. Error boundaries
    are mainly used in React applications to handle these kinds of errors.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时，你总会遇到意外的错误。这些错误可能以多种方式发生，例如通过网络请求、调用第三方 API、访问不存在的嵌套对象属性等。错误边界主要在 React
    应用程序中用于处理这些类型的错误。
- en: Understanding error boundaries
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解错误边界
- en: In React applications, you can handle errors in two possible ways. The first
    approach is using a `try..catch` block to handle the errors in an imperative code
    block, similar to regular event handlers. The second approach is to use **error
    boundaries**. These are used to deal with declarative component code that will
    render on the screen.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 应用程序中，你可以以两种可能的方式处理错误。第一种方法是在命令式代码块中使用 `try..catch` 块来处理错误，类似于常规事件处理器。第二种方法是使用
    **错误边界**。这些用于处理将在屏幕上渲染的声明式组件代码。
- en: The React team introduced error boundaries as part of React version 16\. No
    official component has been created for error boundaries in the React library,
    so you need to create the error boundary component on your own.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: React 团队在 React 版本 16 中引入了错误边界作为其一部分。React 库中没有创建用于错误边界的官方组件，因此你需要自己创建错误边界组件。
- en: What are error boundaries?
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是错误边界？
- en: Error boundaries are just React components with a certain list of tasks. They
    are used to catch JavaScript errors that can occur in their child component tree,
    log those specific errors, and redirect the screen to the fallback UI to recover
    from the error state. This component helps prevent the entire component tree from
    crashing just because of an error that happened somewhere in the tree.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 错误边界只是具有特定任务列表的React组件。它们用于捕获其子组件树中可能发生的JavaScript错误，记录这些特定错误，并将屏幕重定向到回退UI以从错误状态中恢复。该组件有助于防止整个组件树因为树中某个地方发生的错误而崩溃。
- en: 'Error boundaries catch errors during rendering, in life cycle methods, and
    in the constructors of the entire component tree below them. An error boundary
    can be created with a class component by defining either or both of the following
    life cycle methods:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。可以通过定义以下生命周期方法之一或两者来使用类组件创建错误边界：
- en: '`static getDerivedStateFromError`: This method is used to render a fallback
    UI after an error has been thrown'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static getDerivedStateFromError`：此方法用于在抛出错误后渲染回退UI'
- en: '`componentDidCatch`: This method is used to log error information'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidCatch`：此方法用于记录错误信息'
- en: 'An error boundary can be created using these two methods to protect the application
    from crashing. This is how it is done:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用这两种方法之一创建错误边界来保护应用程序免受崩溃的影响。以下是实现方式：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `getDerivedStateFromError` method will be invoked if an error occurs in
    the rendering phase of any life cycle method. In this method, you can update the
    error state flag variable’s value to reflect the fallback UI in the next render.
    Based on the error state variable, the `render` method will update the UI on the
    screen. At the same time, the same error can be reported to the logging service
    for debugging purposes using the `componentDidCatch` method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何生命周期方法在渲染阶段发生错误，将调用`getDerivedStateFromError`方法。在这个方法中，你可以更新错误状态标志变量的值，以反映下一次渲染中的回退UI。根据错误状态变量，`render`方法将在屏幕上更新UI。同时，可以使用`componentDidCatch`方法将相同的错误报告给日志服务，用于调试目的。
- en: 'Once the error boundary has been created, it can be used as a regular React
    component. The error boundary component needs to be wrapped around the top-level
    React component where you suspect any kind of possible bugs. The usage of the
    component looks as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了错误边界，它就可以作为一个常规的React组件使用。错误边界组件需要围绕你怀疑可能存在任何类型错误的最顶层React组件进行包装。组件的使用方式如下：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding error boundary catches any error thrown within the `MyComponent`
    component tree and prevents the application from crashing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的错误边界捕获`MyComponent`组件树中抛出的任何错误，并防止应用程序崩溃。
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can also wrap error boundaries for individual components with a different
    set of error messages to prevent them from breaking other parts of the page. The
    decision of error boundary design depends on the business requirements and UX
    design.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以用不同的一组错误消息包裹单个组件的错误边界，以防止它们破坏页面的其他部分。错误边界的设计决策取决于业务需求和UX设计。
- en: If the enclosed error boundary failed to catch the error, the error will propagate
    to the next closest error boundary around it. This behavior is similar to a `catch()`
    block, which propagates an error to the next nearest catch block.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包含的错误边界未能捕获错误，错误将传播到其周围的下一个最近的错误边界。这种行为类似于`catch()`块，它将错误传播到下一个最近的捕获块。
- en: Popular testing frameworks such as Jest can be used to write unit tests for
    error boundaries similar to any other React component. The unit test should simulate
    the error in the React component (to which the error boundary is wrapped) and
    verify that the error boundary can catch errors and renders the fallback UI properly
    or not. It is also possible to verify the error boundary using React DevTools
    by forcing the selected component into an error (red button) state.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 像Jest这样的流行测试框架可以用来为错误边界编写类似于任何其他React组件的单元测试。单元测试应该模拟React组件（错误边界所包裹的组件）中的错误，并验证错误边界是否能够捕获错误并正确渲染回退UI。也可以通过强制选定的组件进入错误（红色按钮）状态来使用React
    DevTools验证错误边界。
- en: Is it possible to create an error boundary as a function component?
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 是否可以创建一个作为函数组件的错误边界？
- en: At the time of writing, it is not possible to create an error boundary as a
    function component using the latest React version – that is, you can only create
    an error boundary using a class component. Moreover, you can avoid writing an
    error boundary class altogether by reusing the `react-error-boundary` ([https://github.com/bvaughn/react-error-boundary](https://github.com/bvaughn/react-error-boundary))
    package from the community.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，无法使用最新的React版本创建错误边界作为函数组件 - 也就是说，您只能使用类组件创建错误边界。此外，您可以通过重用社区中的`react-error-boundary`
    ([https://github.com/bvaughn/react-error-boundary](https://github.com/bvaughn/react-error-boundary))包来避免编写错误边界类。
- en: When do error boundaries not work?
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时错误边界不起作用？
- en: 'Error boundaries do not catch errors in the following scenarios:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下场景中，错误边界不会捕获错误：
- en: '`onClick`, `onChange`, and others) aren’t used during the rendering phase,
    error boundaries won’t be required to recover the UI from errors'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onClick`、`onChange`和其他在渲染阶段不使用，因此不需要错误边界来从错误中恢复UI'
- en: '`setTimeout`, `requestAnimationFrame`, and others'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setTimeout`、`requestAnimationFrame`和其他'
- en: '**Server-side rendering**: React doesn’t support error boundaries on a server'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端渲染**：React不支持在服务器上使用错误边界'
- en: '**When there’s an error inside the error boundary**: React cannot catch errors
    thrown in the error boundary itself'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当错误边界内部有错误时**：React无法捕获在错误边界本身抛出的错误'
- en: You may need to opt for a regular JavaScript `try..catch` statement or `promise#catch()`
    block to handle errors for the aforementioned cases except for the last one, where
    you need to make sure no errors occur in the error boundary.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述情况（除了最后一个情况外），您可能需要选择常规的JavaScript `try..catch`语句或`promise#catch()`块来处理错误，确保在错误边界中没有发生错误。
- en: Just like error boundaries are used to display a fallback UI for any error caught
    in the application, the Suspense API is used to display a fallback UI until its
    children have finished loading.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就像错误边界用于在应用程序中捕获任何错误并显示回退UI一样，Suspense API用于在子组件完成加载之前显示回退UI。
- en: Managing asynchronous actions with the Suspense API
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Suspense API管理异步操作
- en: The Suspense feature was introduced in React version 16, alongside error boundaries.
    Initially, it was only meant to be used with the `lazy` API for code splitting
    and could not be used for server-side rendering. React18 improved the Suspense
    API so that it can support many use cases, including server-side rendering and
    asynchronous operations such as data fetching.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Suspense功能是在React版本16中引入的，与错误边界同时出现。最初，它仅用于与`lazy` API一起进行代码拆分，并且不能用于服务器端渲染。React18改进了Suspense
    API，使其能够支持许多用例，包括服务器端渲染和异步操作，如数据获取。
- en: What is the Suspense API? How do you use it?
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Suspense API？如何使用它？
- en: The Suspense API is used to display a fallback UI such as a loading indicator
    until its children are ready to render. The suspense component accepts a `fallback`
    prop to render an alternative UI if its children have not finished rendering.
    You can wrap your application with a suspense component either at the top level
    or individual sections of the application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Suspense API用于显示回退UI，如加载指示器，直到其子组件准备好渲染。suspense组件接受一个`fallback`属性来渲染一个替代UI，如果其子组件尚未完成渲染。您可以在应用的最顶层或应用的各个部分使用suspense组件。
- en: Let’s learn how to use the Suspense feature by looking at the following example.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例学习如何使用Suspense功能。
- en: 'Consider a simple use case of loading blog posts from a specific author. Here,
    the blog posts component (that is, `<Posts/>)` suspends while fetching the list
    of posts. Before the content is ready to be displayed, React switches to the closest
    suspense boundary to display the fallback loading indicator (that is, `<Loading
    />`) in place of displaying the list of posts:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的用例，即从特定作者那里加载博客文章。在这里，博客文章组件（即`<Posts/>`）在获取文章列表时挂起。在内容准备好显示之前，React切换到最近的suspense边界来显示回退加载指示器（即`<Loading/>`），而不是显示文章列表：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once the blog post data has been fetched, React switches back to displaying
    the actual blog post data.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦博客文章数据已被获取，React会切换回显示实际的博客文章数据。
- en: 'You can also defer updating the list and display state content until the new
    results are ready. This alternative UI pattern is possible by passing a query
    to the `useDeferredValue` Hook:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将更新列表和显示状态的内容延迟到新结果准备就绪。通过传递查询到`useDeferredValue` Hook，可以实现这种替代UI模式：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In traditional applications, you need to use the `isLoading` data flag variable
    to indicate whether data fetching has finished or not and display the respective
    content on the screen. However, if you use the Suspense feature, React automatically
    determines whether to display the fallback UI or component data, without depending
    on any additional flag.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统应用程序中，你需要使用 `isLoading` 数据标志变量来指示数据获取是否完成，并在屏幕上显示相应的内容。然而，如果你使用 Suspense
    功能，React 会自动确定是否显示回退 UI 或组件数据，而不依赖于任何额外的标志。
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Only suspense-enabled frameworks have integrations with the Suspense feature
    to communicate loading states to React.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 只有启用了 suspense 的框架才与 Suspense 功能集成，以将加载状态传达给 React。
- en: Can I use the suspense component for any kind of data fetching?
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我可以使用 suspense 组件进行任何类型的数据获取吗？
- en: 'The suspense component cannot detect data fetching inside an effect or event
    handler. It can only be used for the following suspense-enabled data sources:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: suspense 组件无法检测 effect 或事件处理器内部的数据获取。它只能用于以下启用了 suspense 的数据源：
- en: Data fetching with suspense-enabled opinionated frameworks such as Relay, Next.js,
    Remix, and Hydrogen
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用启用了 suspense 的有意见框架（如 Relay、Next.js、Remix 和 Hydrogen）进行数据获取
- en: Lazy-loading component code with the `lazy` API
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `lazy` API 懒加载组件代码
- en: Using the Suspense feature without a framework is not supported at the time
    of writing. However, there is a plan from the React team to provide an official
    API to integrate data sources with the suspense component in future versions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本文时，不支持在没有框架的情况下使用 Suspense 功能。然而，React 团队有一个计划，在未来的版本中提供官方 API 以将数据源与 suspense
    组件集成。
- en: How do you prevent unnecessary fallbacks during an update?
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你是如何在更新过程中防止不必要的回退的？
- en: If the visible UI is replaced with a fallback, there will be a flashing user
    experience. This is not a good UX experience. This situation happens when a state
    update causes a component to suspend, but the nearest suspense boundary is already
    showing some fallback content to the user. You can avoid these unnecessary fallbacks
    by marking the state updates as non-urgent using the `startTransition` API.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可见的 UI 被回退替换，将会有闪烁的用户体验。这不是一个好的用户体验。这种情况发生在状态更新导致组件挂起，但最近的 suspense 边界已经向用户显示了一些回退内容时。你可以通过使用
    `startTransition` API 将状态更新标记为非紧急来避免这些不必要的回退。
- en: 'Consider an example of navigating pages in an application and applying a transition
    for the page update to prevent unnecessary fallbacks:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个在应用程序中导航页面并应用页面更新过渡以防止不必要的回退的例子：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: During the transition, React will wait for the content to be loaded without
    retriggering the suspense fallback UI to hide the already revealed content.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在过渡期间，React 将等待内容加载，而不会重新触发 suspense 回退 UI 来隐藏已经显示的内容。
- en: Note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: React only prevents unnecessary fallbacks for non-urgent updates. It will not
    delay the render for any urgent updates.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: React 只会防止非紧急更新的不必要的回退。它不会延迟任何紧急更新的渲染。
- en: In the past, React was only able to handle one task at a time and the render
    process was synchronous. Once the task had been started, it could not be interrupted.
    This is called blocking rendering. Later, this issue was fixed by introducing
    concurrent mode, which can interrupt the task if there is another urgent task.
    Concurrent mode was introduced as an experimental feature and replaced by the
    concurrent rendering feature in React version 18.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，React 只能一次处理一个任务，渲染过程是同步的。一旦任务开始，就无法中断。这被称为阻塞渲染。后来，通过引入并发模式解决了这个问题，如果存在另一个紧急任务，并发模式可以中断任务。并发模式最初作为一个实验性功能引入，并在
    React 版本 18 中被并发渲染功能取代。
- en: Optimizing rendering performance using concurrent rendering
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并发渲染优化渲染性能
- en: React 18 introduced the concurrent renderer, which makes the rendering process
    asynchronous and ensures it can be interrupted, paused, resumed, and even abandoned.
    As a result, React can respond to user interactions quickly, even if it is in
    the middle of a heavy rendering task.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: React 18 引入了并发渲染器，这使得渲染过程异步，并确保它可以被中断、暂停、恢复，甚至放弃。因此，React 可以快速响应用户交互，即使它正在进行繁重的渲染任务。
- en: New features such as suspense, streaming server rendering, and transitions are
    powered by concurrent rendering.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能，如 suspense、流式服务器渲染和过渡，都是由并发渲染驱动的。
- en: How do you enable concurrent rendering in React?
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何在 React 中启用并发渲染？
- en: First, you need to update both the `react` and `react-dom` packages to version
    18\. After that, you need to replace the deprecated `ReactDOM.render` method with
    the `ReactDOM.createRoot` method. Concurrent rendering will be enabled automatically
    in whichever parts of your application you use concurrent features such as suspense,
    streaming server rendering, and transitions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将`react`和`react-dom`包更新到版本18。之后，你需要将已弃用的`ReactDOM.render`方法替换为`ReactDOM.createRoot`方法。并发渲染将在你使用并发功能（如suspense、流式服务器渲染和过渡）的应用程序部分自动启用。
- en: As the application becomes complex, you need to spend a significant amount of
    time analyzing the application’s performance. It is especially crucial to measure
    the application performance’s characteristics before delivering it to customers.
    Even though you can use the browser’s User Timing API (Web API) to measure the
    rendering cost of your components, there are better alternatives that have been
    created by the React team. The Profiler API, for example, helps identify performance
    bottlenecks in React applications.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序变得复杂，你需要花费大量时间分析应用程序的性能。在向客户交付之前，测量应用程序性能的特征尤为重要。尽管你可以使用浏览器的User Timing
    API（Web API）来测量组件的渲染成本，但React团队已经创建了更好的替代方案。例如，Profiler API可以帮助识别React应用程序中的性能瓶颈。
- en: Debugging React applications with the Profiler API
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Profiler API调试React应用程序
- en: 'If you are benchmarking a React application’s performance, then tracking how
    many times your components are re-rendered and the cost of each re-rendering will
    help you identify the defecting areas or parts in the application. React provides
    two different ways to measure the application’s rendering performance: the **React
    Profiler API** and the **React DevTools** profiler tab. The React Profiler API
    is recommended considering that it supports the Suspense feature.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在基准测试React应用程序的性能，那么跟踪你的组件重渲染的次数以及每次重渲染的成本将帮助你识别应用程序中的缺陷区域或部分。React提供了两种不同的方式来衡量应用程序的渲染性能：**React
    Profiler API**和**React DevTools**的Profiler标签。考虑到它支持Suspense功能，推荐使用React Profiler
    API。
- en: How do you measure rendering performance?
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何衡量渲染性能？
- en: 'React provides the Profiler API to measure the rendering performance of a component
    tree programmatically. The component has two props: the `id` prop, which is used
    to identify the part of the UI being measured, and the `onRender` callback, which
    is called every time the tree updates.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: React提供了Profiler API以编程方式测量组件树的渲染性能。该组件有两个属性：`id`属性，用于识别正在测量的UI部分，以及`onRender`回调，每次树更新时都会调用。
- en: The callback receives arguments such as `id`, `phase`, `actualDuration`, `baseDuration`,
    `startTime`, and `commitTime`, which are used to log the rendering time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数接收诸如`id`、`phase`、`actualDuration`、`baseDuration`、`startTime`和`commitTime`等参数，这些参数用于记录渲染时间。
- en: 'Imagine you are suspicious of the rendering performance of an author biography
    component that exists inside an online bookstore application, and you would like
    to profile the component. In this case, the `AuthorBio` component needs to be
    wrapped with the `Profiler` component, along with the `onRender` callback. This
    will look as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你对一个存在于在线书店应用程序中的作者简介组件的渲染性能表示怀疑，并希望对其进行分析。在这种情况下，`AuthorBio`组件需要被`Profiler`组件包裹，并附带`onRender`回调。这看起来如下所示：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can also use multiple `Profiler` components to measure the different parts
    of your application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用多个`Profiler`组件来衡量应用程序的不同部分。
- en: JavaScript provided strict mode as a new feature in ECMAScript5 to enforce the
    restricted version of JavaScript. This feature brings stricter rules when you
    write code and throws errors if you violate them. Strict mode can be enabled by
    adding a `use strict` line at the top of your file. Similarly, React provides
    the `StrictMode` component as a development-only tool, which is used to enforce
    stricter warnings and checks while writing React code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在ECMAScript5中提供了严格模式作为一项新特性，以强制执行JavaScript的受限版本。此特性在编写代码时带来了更严格的规则，并在违反这些规则时抛出错误。可以通过在文件顶部添加`use
    strict`行来启用严格模式。同样，React提供了`StrictMode`组件作为开发工具，用于在编写React代码时强制执行更严格的警告和检查。
- en: Strict mode
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 严格模式
- en: The React team introduced strict mode as a debugging tool to identify potential
    bugs or issues in a web application. This tool is available as the `StrictMode`
    component in the React API. It doesn’t render any UI that is similar to the `Fragment`
    component. This feature is only applicable to development mode – it won’t impact
    behavior in production. This section focuses on the important strict mode concepts
    and questions that might be asked in the interview.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: React 团队引入了严格模式作为调试工具，用于识别网络应用程序中可能存在的错误或问题。此工具作为 React API 中的 `StrictMode`
    组件提供。它不会渲染任何类似于 `Fragment` 组件的 UI。此功能仅适用于开发模式 – 它不会影响生产环境中的行为。本节重点介绍重要的严格模式概念和可能在面试中提出的问题。
- en: How do you enable strict mode?
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何启用严格模式？
- en: 'You can enable strict mode for an entire app by wrapping it around the root
    component, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将整个应用包裹在根组件周围来为整个应用启用严格模式，如下所示：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also only use strict mode in certain parts of the application (that
    is, not the entire application) where you think there is a high possibility of
    bugs. Consider strict mode for the main body of the page of an application. It
    should look something like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以仅在应用程序的某些部分（即不是整个应用程序）中使用严格模式，如果你认为这些部分有很高的错误可能性。考虑将严格模式用于应用程序页面主体。它应该看起来像这样：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Most of the time, React developers face issues with improper logic in the rendering
    section, as well as issues with missing cleanup code inside effects Hooks. These
    types of bugs can easily be identified with strict mode.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，React 开发者会遇到渲染部分逻辑不当的问题，以及 effects Hook 内缺少清理代码的问题。这些类型的错误可以通过严格模式轻松识别。
- en: Can you describe the list of development-only checks enabled by strict mode?
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你能描述一下严格模式启用的仅限开发模式的检查列表吗？
- en: 'Strict mode enables the following list of development-only checks to find commonly
    occurring bugs during early development:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式启用了以下仅限开发模式的检查列表，以在早期开发过程中查找常见错误：
- en: Components will re-render one more time to find the bugs that were caused by
    impure rendering
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件将重新渲染一次以查找由不纯渲染引起的错误
- en: Components will rerun effects one more time to find the bugs that were caused
    by missing cleanup for the effect
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件将重新运行一次效果以查找由效果缺少清理引起的错误
- en: Components will be verified for the usage of deprecated APIs and will notify
    the users with warnings
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件将被验证是否使用了已弃用的 API，并将通过警告通知用户
- en: These checks are applicable for development purposes only. They won’t have any
    impact on the production builds.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些检查仅适用于开发目的。它们不会对生产构建产生影响。
- en: What functions are called twice in the double rendering process of strict mode?
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格模式的两次渲染过程中调用哪些函数？
- en: 'Strict mode calls the following list of functions twice in development mode:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式在开发模式下会调用以下列表中的函数两次：
- en: The function’s component body, excluding code inside event handlers
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的组件体，不包括事件处理程序内部的代码
- en: The functions that are passed to Hook, such as `useState`, `useReducer`, and
    `useMemo`
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给 Hook 的函数，如 `useState`、`useReducer` 和 `useMemo`
- en: State updater functions
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态更新函数
- en: Class component methods such as `constructor`, `render`, `shouldComponentUpdate`,
    and `getDerivedStateFromProps`
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类组件方法，如 `constructor`、`render`、`shouldComponentUpdate` 和 `getDerivedStateFromProps`
- en: If your function is impure, running it twice in development mode will impact
    the expected output. This result helps you identify any bugs in your code as early
    as possible.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的函数不纯，在开发模式下运行两次将影响预期的输出。这个结果可以帮助你尽早识别代码中的任何错误。
- en: Apart from strict mode, you can also use static type checking in React applications
    to avoid bugs and errors that appear at runtime. As your application grows, you
    can catch many bugs using type checking.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了严格模式之外，你还可以在 React 应用程序中使用静态类型检查来避免运行时出现的错误和错误。随着你的应用程序增长，你可以使用类型检查捕获许多错误。
- en: Static type checking
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态类型检查
- en: React is based on JavaScript and JavaScript is a loosely typed language. So,
    we don’t get the default static type-checking feature in React.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: React 基于 JavaScript，JavaScript 是一种弱类型语言。因此，在 React 中我们没有默认的静态类型检查功能。
- en: In its older versions (<15.5), React had `PropTypes` validators so that it could
    perform simple type checking in applications. Post that, this library was moved
    out from React’s core module and created as a separate library, `prop-types` ([https://www.npmjs.com/package/prop-types](https://www.npmjs.com/package/prop-types)).
    Nowadays, `PropTypes` are not commonly used in modern React applications. Even
    though static type checking is not mandatory in React, you might encounter some
    questions related to static type checking in the interview.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在其旧版本（<15.5）中，React有`PropTypes`验证器，以便在应用程序中执行简单的类型检查。在那之后，这个库从React的核心模块中移出，并作为一个独立的库创建，即`prop-types`([prop-types包](https://www.npmjs.com/package/prop-types))。如今，`PropTypes`在现代React应用程序中不常用。尽管在React中静态类型检查不是强制性的，但在面试中您可能会遇到一些与静态类型检查相关的问题。
- en: What are the benefits of static type checking?
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态类型检查有哪些好处？
- en: 'There are many benefits of static type checking in JavaScript applications.
    Some of these are listed here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript应用程序中进行静态类型检查有许多好处。其中一些列在这里：
- en: Can identify type errors before runtime (that is, errors at compile time)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在运行时之前（即在编译时）识别类型错误
- en: Can detect bugs and errors in the early stages
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在早期阶段检测bug和错误
- en: Optimized and easy to read
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化且易于阅读
- en: Better IDE support
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的IDE支持
- en: Can generate documentation
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以生成文档
- en: It is cheaper to fix bugs if you identify them as early as possible.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尽早发现错误，修复它们会更便宜。
- en: How do you implement static type checking in React applications?
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您如何在React应用程序中实现静态类型检查？
- en: 'In React, there are multiple ways to implement static type checking, but the
    following two ways are the best:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，有多种方式可以实现静态类型检查，但以下两种方式是最好的：
- en: TypeScript
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript
- en: Flow
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flow
- en: These two static type checkers help identify certain types of errors, even before
    you run your code. Since TypeScript is robust and has the most community support,
    let’s see how it can be implemented in React.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个静态类型检查器可以帮助您在运行代码之前识别某些类型的错误。由于TypeScript稳健且社区支持度最高，让我们看看它如何在React中实现。
- en: 'TypeScript was created by Microsoft and is considered a typed superset of JavaScript.
    It comes with its own compiler and can catch errors and bugs at build time. It
    supports JSX and can use React hooks without any problems. Nowadays, TypeScript
    can be supported by major frameworks just by appending various options, as listed
    here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是由微软创建的，被认为是JavaScript的超集。它自带编译器，可以在构建时捕获错误和bug。它支持JSX，并且可以无问题地使用React
    hooks。如今，TypeScript可以通过添加各种选项来支持主要框架，如下所示：
- en: 'Next.js:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Next.js:'
- en: '[PRE11]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Remix:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Remix:'
- en: '[PRE12]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Gatsby:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Gatsby:'
- en: '[PRE13]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Expo:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Expo:'
- en: '[PRE14]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you are not using any of these frameworks, you need to follow the following
    manual steps to set up TypeScript in React applications:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有使用这些框架，您需要遵循以下手动步骤在React应用程序中设置TypeScript：
- en: '`npm` or the `yarn` package manager:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`npm`或`yarn`包管理器：'
- en: '[PRE15]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`tsconfig.json` by generating the file using the following command:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令生成`tsconfig.json`文件：
- en: '[PRE16]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The frequently used options are the source directory for TypeScript files and
    generated JavaScript files for the output folder. The configuration looks like
    this:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 常用的选项包括TypeScript文件的源目录和输出文件夹的生成JavaScript文件。配置看起来像这样：
- en: '[PRE17]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can add more configuration options, as described here: [https://www.typescriptlang.org/docs/handbook/tsconfig-json.html](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html).
    TypeScript’s React starter provides this configuration file with a good set of
    rules.'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以添加更多配置选项，如这里所述：[TypeScript配置选项](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)。TypeScript的React启动器提供了一个包含良好规则的配置文件。
- en: '`.ts` extension or the `.tsx` extension for files that contain JSX code.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.ts`扩展名或`.tsx`扩展名用于包含JSX代码的文件。'
- en: '`DefinitelyTyped` ([https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped))
    repository or creating a local declaration file.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DefinitelyTyped` ([DefinitelyTyped仓库](https://github.com/DefinitelyTyped/DefinitelyTyped))或创建一个本地的声明文件。'
- en: Now, you can build your TypeScript project with the `tsc` command, which is
    available through the TypeScript package.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用TypeScript包中的`tsc`命令构建TypeScript项目。
- en: Initially, React was mainly used for web development. Nowadays, it can be used
    for mobile, desktop, and VR apps too. React Native is a separate library that
    was created to support mobile devices. It is based on the same concepts as React
    but uses native components instead of web components to render on the screen.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: React in mobile environments and its features
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Facebook initially chose to make its services available on mobile devices,
    it decided to run mobile pages based on HTML5 instead of building native apps,
    which was preferred by many tech giants at that time. However, it ended up with
    UX and performance overhead issues.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: In 2013, the Facebook team found a method of generating UI elements for iOS
    apps by using JavaScript. This idea was successful for mobile applications and
    later, React Native was supported for Android devices too.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: This section will focus on React Native, so that we can go beyond ReactJS concepts
    and cover important topics related to architecture, navigation, and its differences
    from ReactJS, which might be expected in React interviews.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: What is React Native?
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React Native is a popular JavaScript-based mobile app framework for building
    natively rendered mobile applications for iOS, Android, and Windows. The main
    advantage of this library is that you can use one code base that runs on multiple
    platforms.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The Facebook team open sourced React Native in 2015\. After only a few years,
    this library became one of the top solutions for mobile development and is now
    used in popular mobile apps such as Facebook, Instagram, Skype, Uber, and others.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: What are the differences between React and React Native?
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React Native is based on the React library and they share many concepts. But
    there are a few major differences, as shown here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '| **React** | **React Native** |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| It is used to develop web applications | It is used to develop mobile applications
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| It uses the `react-router` library to navigate pages | It uses an in-built
    navigator library to navigate pages |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| A virtual DOM is used to render the web pages | A native API is used to render
    the pages |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| React uses HTML, CSS, and JavaScript to create a user interface | React Native
    uses native components and APIs to build apps |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| It uses JavaScript and CSS libraries for animation | It comes with built-in
    animation libraries |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1: React versus React Native'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: So, React Native is an additional library built on top of React library to create
    native apps and this native library has its own architecture.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Can you describe the React Native architecture based on the threading model?
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fabric is the new rendering architecture that was created by the Facebook team
    and even their app is backed by this renderer. The core principles of this architecture
    are unifying the renderer logic in C++ and optimizing the interoperability between
    host platforms. It is based on the threading model, similar to the old architecture,
    but it functions differently to optimize the user experience better than native
    apps.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 是由 Facebook 团队创建的新渲染架构，甚至他们的应用程序也是由这个渲染器支持的。该架构的核心原则是在 C++ 中统一渲染器逻辑，并优化主机平台之间的互操作性。它基于线程模型，类似于旧架构，但功能不同，以优化用户体验，使其优于原生应用程序。
- en: In the old architecture, React Native bridge was used to communicate between
    JavaScript and native modules. But it has its limitations – for example, communication
    can only happen through asynchronous operations and it is required to serialize
    or deserialize the data as JSON. This bridge component was replaced with **JavaScript
    Interface** (**JSI**) in the new architecture.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧架构中，React Native 桥被用于在 JavaScript 和原生模块之间进行通信。但它有其局限性——例如，通信只能通过异步操作进行，并且需要将数据序列化为
    JSON 或反序列化为 JSON。在新架构中，此桥组件被**JavaScript 接口**（**JSI**）所取代。
- en: 'Let’s take a look at how the various components communicate in the new rendering
    architecture:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在新渲染架构中各种组件是如何进行通信的：
- en: '![Figure 5.1: Fabric rendering architecture](img/Figure_05.01_B18603.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：Fabric 渲染架构](img/Figure_05.01_B18603.jpg)'
- en: 'Figure 5.1: Fabric rendering architecture'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：Fabric 渲染架构
- en: 'Three parallel threads run in every React app, irrespective of whether the
    old or new renderer is used:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个 React 应用程序中，无论使用的是旧渲染器还是新渲染器，都会运行三个并行线程：
- en: '**UI thread or main thread**: This thread is responsible for handling iOS and
    Android host views. It handles some native interactions, such as tapping on a
    button, user gesture events, scrolling, and others.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI 线程或主线程**：此线程负责处理 iOS 和 Android 主视图。它处理一些原生交互，例如点击按钮、用户手势事件、滚动等。'
- en: '**JS thread**: This thread is responsible for handling all the logic of your
    React Native application. It takes care of all the DOM hierarchy operations written
    in the code and executes them. After that, the code is sent to the native module
    thread for optimizations.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JS 线程**：此线程负责处理你的 React Native 应用程序的所有逻辑。它负责处理代码中编写的所有 DOM 层级操作并执行它们。之后，代码被发送到原生模块线程进行优化。'
- en: '**Shadow or background thread**: This thread is responsible for layout calculations
    such as positions and the height and width of elements and then transforming them
    into native elements.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阴影或背景线程**：此线程负责布局计算，例如元素的位置、高度和宽度，然后将它们转换为原生元素。'
- en: In the old architecture, the bridge component was used to communicate between
    the JS thread and the UI thread asynchronously by serializing and deserializing
    the data. As a result, memory management and application performance became overloaded.
    In the new architecture, the bridge component has been replaced with JSI for efficient
    communication between native and JavaScript code. JSI is a lightweight layer where
    methods written in C++ can be used by the JavaScript engine, such as **JavaScript
    Core** (**JSC**) or Hermes, to directly invoke or call methods in the native code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧架构中，桥组件用于通过序列化和反序列化数据以异步方式在 JS 线程和 UI 线程之间进行通信。因此，内存管理和应用程序性能变得过载。在新架构中，桥组件已被
    JSI 取代，以实现原生代码和 JavaScript 代码之间的有效通信。JSI 是一个轻量级层，其中用 C++ 编写的函数可以被 JavaScript 引擎（如
    **JavaScript Core**（**JSC**）或 Hermes）直接调用或调用原生代码中的方法。
- en: 'The workflow of the new architecture is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 新架构的工作流程如下：
- en: When the user clicks an app icon of a mobile application, the Fabric rendering
    system directly loads the native side instead of opening native modules.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击移动应用程序的应用图标时，Fabric 渲染系统直接加载原生端而不是打开原生模块。
- en: The rendering system notifies the JS thread once it is ready. After that, the
    JS thread loads the final bundle, named `main.bundle.js`, which consists of JavaScript
    code, React logic, and its components.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染系统在准备好后通知 JS 线程。之后，JS 线程加载名为 `main.bundle.js` 的最终包，其中包含 JavaScript 代码、React
    逻辑及其组件。
- en: The JS code is invoked through the ref native function, which has been exposed
    as an object using the JSI API to Fabric.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JS 代码通过 ref 原生函数被调用，该函数已通过 JSI API 暴露给 Fabric。
- en: The yoga engine inside the shadow thread performs layout calculations, converting
    from the Flexbox-based style into the host layout, and so on.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阴影线程内的瑜伽引擎执行布局计算，将基于 Flexbox 的样式转换为宿主布局等。
- en: Finally, the components are rendered on the screen.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，组件将在屏幕上渲染。
- en: 'Additionally, two new components have been added to the new architecture: `Turbo
    module` and `CodeGen`.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，新架构中增加了两个新组件：`Turbo module` 和 `CodeGen`。
- en: '`Turbo module` is an improved version of the native module (it exists in the
    old architecture) that communicates between JavaScript and platform-native code
    by lazily loading the modules to improve the startup performance. The `CodeGen`
    static type checker helps communicate dynamic JavaScript code and JSI code written
    as statically typed C++.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Turbo module` 是原生模块（存在于旧架构中）的改进版本，通过懒加载模块与 JavaScript 和平台原生代码进行通信，以改善启动性能。`CodeGen`
    静态类型检查器有助于沟通动态 JavaScript 代码和作为静态类型 C++ 编写的 JSI 代码。'
- en: How do you perform navigations in React Native?
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在 React Native 中执行导航？
- en: React Native uses the `react-navigation` library to navigate between pages in
    native applications. The transition between multiple screens is managed by various
    kinds of navigators, such as stack navigators, drawer navigators, and tab navigators.
    While navigating between multiple screens, you can also pass data between them.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 使用 `react-navigation` 库在原生应用之间进行页面导航。多个屏幕之间的转换由各种类型的导航器管理，例如堆栈导航器、抽屉导航器和标签导航器。在多个屏幕之间导航时，您还可以在它们之间传递数据。
- en: 'React Navigation is made up of core utilities that are used by navigators to
    create the navigation structure in your app. The package can be installed using
    the following command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: React Navigation 由核心实用工具组成，这些工具被导航器用于在您的应用中创建导航结构。该包可以使用以下命令安装：
- en: '[PRE18]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Each navigator in React Navigation lives in its own library. For example, if
    you want to use the `native-stack` navigator, it should be installed separately
    using the following command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: React Navigation 中的每个导航器都存在于自己的库中。例如，如果您想使用 `native-stack` 导航器，应单独使用以下命令进行安装：
- en: '[PRE19]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The stack navigator provides a way for your app to transition between screens
    and manage navigation history. This behavior is similar to how a web browser handles
    navigation history. It also provides gestures and animations that you might expect
    in Android and iOS devices while navigating the pages within the stack.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈导航器为您的应用提供了在屏幕之间切换和管理导航历史的方法。这种行为类似于网络浏览器处理导航历史的方式。它还提供了在堆栈内导航页面时可能期望在 Android
    和 iOS 设备上出现的手势和动画。
- en: 'Here is an example of an organization’s website navigation menu items that
    have been created based on the stack navigator:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个基于堆栈导航器创建的组织网站导航菜单项的示例：
- en: '[PRE20]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, we created a stacked navigation menu to redirect users
    to important screens of the website, such as the home and services pages.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个堆栈导航菜单，用于将用户重定向到网站的重要屏幕，例如主页和服务页面。
- en: Additionally, you can nest navigators using the Navigation API.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用 Navigation API 嵌套导航器。
- en: What are the benefits of the new architecture?
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新架构有哪些好处？
- en: 'The new architecture of React Native brings several benefits in terms of user
    experience, code quality, performance, and extensibility. We have compiled a few
    of them here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 的新架构在用户体验、代码质量、性能和可扩展性方面带来了许多好处。我们在这里列出了一些：
- en: '**Better interoperability**: In the old architecture, there was a layout jump
    issue when you try to embed a React view into the host view. This was because
    the React Native layout was asynchronous. The new renderer provides improved interoperability
    by rendering React pages synchronously.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的互操作性**：在旧架构中，当您尝试将 React 视图嵌入宿主视图时，会出现布局跳跃问题。这是因为 React Native 的布局是异步的。新的渲染器通过同步渲染
    React 页面提供了改进的互操作性。'
- en: '**Better data fetching behavior**: The data fetching user experience has been
    improved with the integration of React’s Suspense feature.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的数据获取行为**：通过集成 React 的 Suspense 功能，数据获取用户体验得到了改善。'
- en: '**Type safety**: Code generation ensures type safety between the JS and platform
    layers. It uses JavaScript component declarations to generate C++ structs to hold
    the props. The code generated from the JS specification must be typed through
    Flow or TypeScript.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型安全**：代码生成确保了 JS 和平台层之间的类型安全。它使用 JavaScript 组件声明来生成 C++ 结构体以保存属性。从 JS 规范生成的代码必须通过
    Flow 或 TypeScript 进行类型化。'
- en: '**Synchronous execution**: This improves the user experience. Now, it is possible
    to execute the functions synchronously rather than asynchronously.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步执行**：这提高了用户体验。现在，可以同步执行函数，而不是异步执行。'
- en: '**Concurrency**: JavaScript can invoke functions that are executed on different
    threads.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发**：JavaScript可以调用在不同线程上执行的功能。'
- en: '**Shared C++ code**: The new renderer is implemented in C++. As a result, it
    is possible to write platform-agnostic code and share it between platforms.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享的C++代码**：新的渲染器是用C++实现的。因此，可以编写平台无关的代码，并在不同平台之间共享。'
- en: '**Improved performance**: In the new rendering architecture, all the limitations
    of a particular platform can be identified, and solutions have been provided for
    working with both iOS and Android. Initially, the view flattening solution was
    only available on Android, but it is now available by default for both platforms.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能提升**：在新渲染架构中，可以识别特定平台的全部限制，并为iOS和Android的使用提供了解决方案。最初，视图展平解决方案仅在Android上可用，但现在默认适用于两个平台。'
- en: '**Faster startup**: Since the host components are lazily initialized by default,
    there will be a faster startup time.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的启动**：由于主组件默认是懒加载的，因此启动时间将更快。'
- en: '**Consistency**: The component’s behavior is consistent across platforms because
    the new render system is cross-platform.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：由于新的渲染系统是跨平台的，因此组件的行为在各个平台之间是一致的。'
- en: '**Less overhead**: You don’t need to perform serialization or deserialization
    between JavaScript and the UI layer anymore.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更少的开销**：不再需要在JavaScript和UI层之间进行序列化和反序列化。'
- en: You cannot achieve these benefits with the old architecture.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用旧架构无法实现这些好处。
- en: What is view flattening?
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图展平是什么？
- en: The declarative and composition characteristics of the React API allow you to
    create deep React Element Trees, where most of the nodes only affect the layout
    of a screen instead of rendering on the screen. These nodes are called **layout-only**
    nodes. Large amounts of layout-only nodes lead to poor performance during rendering.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: React API的声明性和组合特性允许你创建深层次的React元素树，其中大多数节点仅影响屏幕的布局，而不是在屏幕上渲染。这些节点被称为**仅布局**节点。大量的仅布局节点会导致渲染时的性能下降。
- en: The renderer implements the view flattening algorithm to improve performance.
    View flattening is an optimization algorithm that’s used by the React Native renderer
    to avoid deep layout trees. This mechanism merges or flattens these types of layout-only
    nodes and reduces the depth of the host view hierarchy displayed on the screen.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器实现了视图展平算法以提升性能。视图展平是一种优化算法，由React Native渲染器使用，以避免深层次布局树。这种机制合并或展平这些仅用于布局的节点类型，并减少屏幕上显示的主视图层次结构的深度。
- en: 'This process can be explained with `MyLogoComponent`, which contains view container
    components with margin and padding styling:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可以用`MyLogoComponent`来解释，它包含具有边距和填充样式的视图容器组件：
- en: '[PRE21]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, two host views (that is, `<View style={..}>`) have been
    added between the container and the actual content of the component to apply structural
    styling for the inner content.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在容器和组件的实际内容之间添加了两个主视图（即`<View style={..}>`），以对内部内容应用结构样式。
- en: The view flattening algorithm is integrated as a part of the **diffing** stage
    of the renderer and merges the styling of the second and third views into the
    first view. This way, it avoids the need to create and render two extra host views.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 视图展平算法作为渲染器**差异**阶段的组成部分集成，并将第二和第三个视图的样式合并到第一个视图中。这样，它避免了创建和渲染两个额外的主视图的需求。
- en: 'The following diagram shows how the native screen appeared without deep layout
    trees using this mechanism:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了使用此机制没有深层次布局树的原生屏幕的外观：
- en: '![Figure 5.2: Native screen with merged views](img/Figure_05.02_B18603.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：合并视图的原生屏幕](img/Figure_05.02_B18603.jpg)'
- en: 'Figure 5.2: Native screen with merged views'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：合并视图的原生屏幕
- en: There won’t be any visible changes after this view flattening algorithm has
    been applied.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 应用此视图展平算法后，将不会出现任何可见的变化。
- en: In this section, we covered some of the important fundamental concepts of React
    Native that you might encounter in React job interviews. You might be asked about
    these to test your knowledge of the React technology stack. This section also
    brings you to the end of this chapter, where we covered a wide range of advanced
    topics in the React ecosystem.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了一些React Native的重要基本概念，这些概念你可能在React面试中遇到。你可能会被问到这些问题来测试你对React技术栈的了解。本节也标志着本章的结束，其中我们涵盖了React生态系统中的广泛高级主题。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered a list of advanced concepts that you might encounter in
    a ReactJS interview. We began by covering new features such as portals, which
    handle modal windows, error boundaries, which prevent the app from crashing due
    to errors, and the Suspense feature, which displays an alternative UI for heavily
    time-consuming background tasks. After that, we covered topics related to concurrent
    rendering, which supports features that improve the rendering performance, followed
    by the Profiler API, which can be used to detect the rendering cost of specific
    parts of an application.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一系列你可能在ReactJS面试中遇到的高级概念。我们首先介绍了新特性，如处理模态窗口的portals、防止应用因错误而崩溃的错误边界，以及Suspense特性，它为耗时较长的后台任务显示替代UI。之后，我们讨论了与并发渲染相关的话题，它支持提高渲染性能的特性，接着是Profiler
    API，它可以用来检测应用程序特定部分的渲染成本。
- en: Then, we discussed development-only features such as strict mode and static
    types, which help us avoid any possible bugs and errors encountered in the code.
    Finally, we introduced React in mobile environments and React Native and its differences
    with ReactJS, as well as its internals and rendering architecture.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了仅用于开发的特性，如严格模式和静态类型，这些特性有助于我们避免在代码中遇到任何可能的错误和bug。最后，我们介绍了在移动环境中以及React
    Native，以及它与ReactJS的区别，包括其内部结构和渲染架构。
- en: Throughout this chapter, we have helped you learn advanced concepts, their significance,
    and their best practices in React development. As a result, this book will improve
    your React skill set so that you become an expert and stand out in the competitive
    job market.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们帮助你学习了高级概念、它们的重要性以及React开发中的最佳实践。因此，这本书将提高你的React技能，让你成为专家，并在竞争激烈的就业市场中脱颖而出。
- en: In the next chapter, we will understand popular state management solutions in
    React. We will start by looking at Flux patterns and the Redux architecture so
    that you understand the foundation of Redux. After that, we will cover important
    topics such as core principles, various components, handling asynchronous requests,
    middleware, and debugging Redux applications.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解React中流行的状态管理解决方案。我们将从了解Flux模式和Redux架构开始，以便你理解Redux的基础。之后，我们将讨论核心原则、各种组件、处理异步请求、中间件以及调试Redux应用程序等重要话题。
- en: 'Part 3: Going Beyond React and Advanced Topics'
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：超越React和高级主题
- en: In this part, you will learn about the popular React.js state library Redux
    and why having a global state store in our projects can be extremely beneficial,
    compared to using a local state. We will also take a look at the numerous ways
    to use CSS within a React.js application and how each method has its pros and
    cons.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，你将了解流行的React.js状态库Redux，以及与使用本地状态相比，在我们的项目中拥有全局状态存储可以带来极大的好处。我们还将探讨在React.js应用程序中使用CSS的多种方式以及每种方法的优缺点。
- en: Then, we will be testing and debugging as we learn of the different ways we
    can use testing to make our code more reliable. Finally, we will learn about the
    React.js libraries Next.js, Gatsby, and Remix, seeing how they can help us to
    build React.js applications.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将随着对测试的不同方式的学习来进行测试和调试，以使我们的代码更加可靠。最后，我们将了解React.js库Next.js、Gatsby和Remix，看看它们如何帮助我们构建React.js应用程序。
- en: 'This part has the following chapters:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 6*](B18603_06.xhtml#_idTextAnchor209), *Redux: The Best State Management
    Solution*'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18603_06.xhtml#_idTextAnchor209)，*Redux：最佳状态管理解决方案*'
- en: '[*Chapter 7*](B18603_07.xhtml#_idTextAnchor239), *Different Approaches to Apply
    CSS in React.js*'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18603_07.xhtml#_idTextAnchor239)，*在React.js中应用CSS的不同方法*'
- en: '[*Chapter 8*](B18603_08.xhtml#_idTextAnchor257), *Testing and Debugging the
    React Application*'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18603_08.xhtml#_idTextAnchor257)，*测试和调试React应用程序*'
- en: '[*Chapter 9*](B18603_09.xhtml#_idTextAnchor276), *Rapid Development with the
    Next.js, Gatsby, and Remix Frameworks*'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18603_09.xhtml#_idTextAnchor276)，*使用Next.js、Gatsby和Remix框架进行快速开发*'
