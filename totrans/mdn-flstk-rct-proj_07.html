<html><head></head><body>
<div id="_idContainer063" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-89"><a id="_idTextAnchor090" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-90" class="calibre5"><a id="_idTextAnchor091" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Deploying the Application with Docker and CI/CD</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Now that we have successfully developed our first full-stack application with a backend service and a frontend, we are going to package our app into Docker images and learn how to deploy them</span><a id="_idIndexMarker296" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.4.1"> using </span><strong class="bold"><span class="kobospan" id="kobo.5.1">continuous integration</span></strong><span class="kobospan" id="kobo.6.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.7.1">CI</span></strong><span class="kobospan" id="kobo.8.1">) and </span><strong class="bold"><span class="kobospan" id="kobo.9.1">continuous delivery</span></strong><span class="kobospan" id="kobo.10.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.11.1">CD</span></strong><span class="kobospan" id="kobo.12.1">) principles. </span><span class="kobospan" id="kobo.12.2">We </span><a id="_idIndexMarker297" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.13.1">have already learned how to start Docker containers in </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.14.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.15.1">, </span><em class="italic"><span class="kobospan" id="kobo.16.1">Getting to Know Node.js and MongoDB</span></em><span class="kobospan" id="kobo.17.1">. </span><span class="kobospan" id="kobo.17.2">In this chapter, we will learn how to create our own Docker images to instantiate containers from. </span><span class="kobospan" id="kobo.17.3">Then, we are going to manually deploy our application to a cloud provider. </span><span class="kobospan" id="kobo.17.4">Finally, we are going to configure CI/CD to automate the deployment of our application. </span><span class="kobospan" id="kobo.17.5">At the end of this chapter, we will have successfully deployed our first </span><a id="_idIndexMarker298" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.18.1">full-stack </span><strong class="bold"><span class="kobospan" id="kobo.19.1">MongoDB Express React Node.js</span></strong><span class="kobospan" id="kobo.20.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.21.1">MERN</span></strong><span class="kobospan" id="kobo.22.1">) application, and set it up for future </span><span><span class="kobospan" id="kobo.23.1">automated deployments!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">In this chapter, we are going to cover the following </span><span><span class="kobospan" id="kobo.25.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.26.1">Creating </span><span><span class="kobospan" id="kobo.27.1">Docker images</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.28.1">Deploying our full-stack application to </span><span><span class="kobospan" id="kobo.29.1">the cloud</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.30.1">Configuring CI to </span><span><span class="kobospan" id="kobo.31.1">automate testing</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.32.1">Configuring CD to automate </span><span><span class="kobospan" id="kobo.33.1">the deployment</span></span></li>
</ul>
<h1 id="_idParaDest-91" class="calibre5"><a id="_idTextAnchor092" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.34.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.35.1">Before we start, please install all requirements from </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.36.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.37.1">, </span><em class="italic"><span class="kobospan" id="kobo.38.1">Preparing For Full-Stack Development</span></em><span class="kobospan" id="kobo.39.1">, and </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.40.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.41.1">, </span><em class="italic"><span class="kobospan" id="kobo.42.1">Getting to Know Node.js </span></em><span><em class="italic"><span class="kobospan" id="kobo.43.1">and MongoDB</span></em></span><span><span class="kobospan" id="kobo.44.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.45.1">The versions listed in those chapters are the ones used in the book. </span><span class="kobospan" id="kobo.45.2">While installing a newer version should not be an issue, please note that certain steps might work differently on a newer version. </span><span class="kobospan" id="kobo.45.3">If you are having an issue with the code and steps provided in this book, please try using the versions mentioned in </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.46.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.47.1"> and </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.48.1">Chapter 2</span></em></span></a><span><span class="kobospan" id="kobo.49.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.50.1">You can find the code for this chapter on </span><span><span class="kobospan" id="kobo.51.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch5" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.52.1">https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch5</span></span></a><span><span class="kobospan" id="kobo.53.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.54.1">The CiA video for this chapter can be found </span><span><span class="kobospan" id="kobo.55.1">at: </span></span><a href="https://youtu.be/aQplfCQGWew" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.56.1">https://youtu.be/aQplfCQGWew</span></span></a></p>
<h1 id="_idParaDest-92" class="calibre5"><a id="_idTextAnchor093" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.57.1">Creating Docker images</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.58.1">In </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.59.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.60.1">, </span><em class="italic"><span class="kobospan" id="kobo.61.1">Getting to Know Node.js and MongoDB</span></em><span class="kobospan" id="kobo.62.1">, we learned that in the Docker platform, we use Docker </span><a id="_idIndexMarker299" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.63.1">images to create containers, which can then run services. </span><span class="kobospan" id="kobo.63.2">We have already learned how to use the existing </span><strong class="source-inline"><span class="kobospan" id="kobo.64.1">mongo</span></strong><span class="kobospan" id="kobo.65.1"> image to create a container for our database service. </span><span class="kobospan" id="kobo.65.2">In this section, we are going to learn how to create our own image to instantiate a container from. </span><span class="kobospan" id="kobo.65.3">To do so, we first need to create</span><a id="_idIndexMarker300" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.66.1"> a </span><strong class="bold"><span class="kobospan" id="kobo.67.1">Dockerfile</span></strong><span class="kobospan" id="kobo.68.1">, which contains all the instructions needed to build the Docker image. </span><span class="kobospan" id="kobo.68.2">First, we will create a Docker image for our backend service and run a container from it. </span><span class="kobospan" id="kobo.68.3">Then, we will do the same for our frontend. </span><span class="kobospan" id="kobo.68.4">Finally, we will create a </span><strong class="bold"><span class="kobospan" id="kobo.69.1">Docker Compose file</span></strong><span class="kobospan" id="kobo.70.1"> to</span><a id="_idIndexMarker301" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.71.1"> start our database and backend services together with </span><span><span class="kobospan" id="kobo.72.1">our frontend.</span></span></p>
<h2 id="_idParaDest-93" class="calibre7"><a id="_idTextAnchor094" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.73.1">Creating the backend Dockerfile</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.74.1">A Dockerfile tells Docker </span><a id="_idIndexMarker302" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.75.1">step by step how to build the image. </span><span class="kobospan" id="kobo.75.2">Each line in the file is an instruction telling Docker what to do. </span><span class="kobospan" id="kobo.75.3">The format of a Dockerfile is </span><span><span class="kobospan" id="kobo.76.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.77.1">
# comment
INSTRUCTION arguments</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.78.1">Every Dockerfile must begin with a </span><strong class="source-inline"><span class="kobospan" id="kobo.79.1">FROM</span></strong><span class="kobospan" id="kobo.80.1"> instruction, which specifies which image the newly created image should be based on. </span><span class="kobospan" id="kobo.80.2">You can extend your image from existing images, such as </span><strong class="source-inline"><span class="kobospan" id="kobo.81.1">ubuntu</span></strong> <span><span class="kobospan" id="kobo.82.1">or </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.83.1">node</span></strong></span><span><span class="kobospan" id="kobo.84.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.85.1">Let’s get started by creating the Dockerfile for our </span><span><span class="kobospan" id="kobo.86.1">backend service:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.87.1">Copy the </span><strong class="source-inline1"><span class="kobospan" id="kobo.88.1">ch4</span></strong><span class="kobospan" id="kobo.89.1"> folder to a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.90.1">ch5</span></strong><span class="kobospan" id="kobo.91.1"> folder, </span><span><span class="kobospan" id="kobo.92.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.93.1">$ cp -R ch4 ch5</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.94.1">Create </span><a id="_idIndexMarker303" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.95.1">a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.96.1">backend/Dockerfile</span></strong><span class="kobospan" id="kobo.97.1"> file inside the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.98.1">ch5</span></strong></span><span><span class="kobospan" id="kobo.99.1"> folder.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.100.1">In this file, we first define a base image for our image, which will be version 20 of the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.101.1">node</span></strong></span><span><span class="kobospan" id="kobo.102.1"> image:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.103.1">
FROM node:20</span></pre><p class="calibre3"><span class="kobospan" id="kobo.104.1">This image is provided by Docker Hub, similar to the </span><strong class="source-inline"><span class="kobospan" id="kobo.105.1">ubuntu</span></strong><span class="kobospan" id="kobo.106.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.107.1">mongo</span></strong><span class="kobospan" id="kobo.108.1"> images we created containers </span><span><span class="kobospan" id="kobo.109.1">from before.</span></span></p></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.110.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.111.1">Be careful to only use official images and images created by trusted authors. </span><span class="kobospan" id="kobo.111.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.112.1">node</span></strong><span class="kobospan" id="kobo.113.1"> image, for example, is officially maintained by the </span><span><span class="kobospan" id="kobo.114.1">Node.js team.</span></span></p>
<ol class="calibre15">
<li value="4" class="calibre11"><span class="kobospan" id="kobo.115.1">Then, we set the working directory, which is where all files of our service will be placed inside </span><span><span class="kobospan" id="kobo.116.1">the image:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.117.1">
WORKDIR /app</span></pre><p class="calibre3"><span class="kobospan" id="kobo.118.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.119.1">WORKDIR</span></strong><span class="kobospan" id="kobo.120.1"> instruction is similar to using </span><strong class="source-inline"><span class="kobospan" id="kobo.121.1">cd</span></strong><span class="kobospan" id="kobo.122.1"> in the terminal. </span><span class="kobospan" id="kobo.122.2">It changes the working directory so that we do not have to prefix all the following commands with the full path. </span><span class="kobospan" id="kobo.122.3">Docker creates the folder for us if it does not </span><span><span class="kobospan" id="kobo.123.1">exist yet.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.124.1">Next, we copy the </span><strong class="source-inline1"><span class="kobospan" id="kobo.125.1">package.json</span></strong><span class="kobospan" id="kobo.126.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.127.1">package-lock.json</span></strong><span class="kobospan" id="kobo.128.1"> files from our project to the </span><span><span class="kobospan" id="kobo.129.1">working directory:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.130.1">
COPY package.json package-lock.json ./</span></pre><p class="calibre3"><span class="kobospan" id="kobo.131.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.132.1">COPY</span></strong><span class="kobospan" id="kobo.133.1"> instruction copies files from your local file system into the Docker image (relative to the local working directory). </span><span class="kobospan" id="kobo.133.2">Multiple files can be specified, and the last argument to the instruction is the destination (in this case, the current working directory of </span><span><span class="kobospan" id="kobo.134.1">the image).</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.135.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.136.1">package-lock.json</span></strong><span class="kobospan" id="kobo.137.1"> file is needed to ensure that the Docker image contains the same versions of the </span><strong class="source-inline"><span class="kobospan" id="kobo.138.1">npm</span></strong><span class="kobospan" id="kobo.139.1"> packages as our </span><span><span class="kobospan" id="kobo.140.1">local build.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.141.1">Now, we </span><a id="_idIndexMarker304" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.142.1">run </span><strong class="source-inline1"><span class="kobospan" id="kobo.143.1">npm install</span></strong><span class="kobospan" id="kobo.144.1"> to install all dependencies in </span><span><span class="kobospan" id="kobo.145.1">the image:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.146.1">
RUN npm install</span></pre><p class="calibre3"><span class="kobospan" id="kobo.147.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.148.1">RUN</span></strong><span class="kobospan" id="kobo.149.1"> instruction executes a command in the working directory of </span><span><span class="kobospan" id="kobo.150.1">the image.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.151.1">Then, we copy the rest of our application from the local file system to the </span><span><span class="kobospan" id="kobo.152.1">Docker image:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.153.1">
COPY . </span><span class="kobospan1" id="kobo.153.2">.</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.154.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.155.1">Are you wondering why we initially just copied </span><strong class="source-inline1"><span class="kobospan" id="kobo.156.1">package.json</span></strong><span class="kobospan" id="kobo.157.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.158.1">package-lock.json</span></strong><span class="kobospan" id="kobo.159.1">? </span><span class="kobospan" id="kobo.159.2">Docker images are built layer by layer. </span><span class="kobospan" id="kobo.159.3">Each instruction forms a layer of the image. </span><span class="kobospan" id="kobo.159.4">If something changes, only the layers following the change are rebuilt. </span><span class="kobospan" id="kobo.159.5">So, in our case, if any of the code changes, only this last </span><strong class="source-inline1"><span class="kobospan" id="kobo.160.1">COPY</span></strong><span class="kobospan" id="kobo.161.1"> instruction is re-executed when rebuilding the Docker image. </span><span class="kobospan" id="kobo.161.2">Only if dependencies change are the other </span><strong class="source-inline1"><span class="kobospan" id="kobo.162.1">COPY</span></strong><span class="kobospan" id="kobo.163.1"> instruction and </span><strong class="source-inline1"><span class="kobospan" id="kobo.164.1">npm install</span></strong><span class="kobospan" id="kobo.165.1"> re-executed. </span><span class="kobospan" id="kobo.165.2">Using this order of instruction reduces the time required to rebuild the </span><span><span class="kobospan" id="kobo.166.1">image immensely.</span></span></p>
<ol class="calibre15">
<li value="8" class="calibre11"><span class="kobospan" id="kobo.167.1">Finally, we run </span><span><span class="kobospan" id="kobo.168.1">our application:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.169.1">
CMD ["npm", "start"]</span></pre><p class="calibre3"><span class="kobospan" id="kobo.170.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.171.1">CMD</span></strong><span class="kobospan" id="kobo.172.1"> instruction is not executed while building the image. </span><span class="kobospan" id="kobo.172.2">Instead, it stores information in the metadata of the image, telling Docker which command to run when a container is instantiated from the image. </span><span class="kobospan" id="kobo.172.3">In our case, the container is going to run </span><strong class="source-inline"><span class="kobospan" id="kobo.173.1">npm start</span></strong><span class="kobospan" id="kobo.174.1"> when using </span><span><span class="kobospan" id="kobo.175.1">our image.</span></span></p></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.176.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.177.1">You may have noticed that we passed a JSON array to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.178.1">CMD</span></strong><span class="kobospan" id="kobo.179.1"> instruction instead of simply writing </span><strong class="source-inline1"><span class="kobospan" id="kobo.180.1">CMD npm start</span></strong><span class="kobospan" id="kobo.181.1">. </span><span class="kobospan" id="kobo.181.2">The JSON array version is</span><a id="_idIndexMarker305" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.182.1"> called </span><strong class="bold"><span class="kobospan" id="kobo.183.1">exec form</span></strong><span class="kobospan" id="kobo.184.1"> and, if the first argument is an executable, will run the command directly without invoking a shell. </span><span class="kobospan" id="kobo.184.2">The form without the JSON array is </span><a id="_idIndexMarker306" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.185.1">called </span><strong class="bold"><span class="kobospan" id="kobo.186.1">shell form</span></strong><span class="kobospan" id="kobo.187.1"> and will execute the command with a shell, prefixing it with </span><strong class="source-inline1"><span class="kobospan" id="kobo.188.1">/bin/sh -c</span></strong><span class="kobospan" id="kobo.189.1">. </span><span class="kobospan" id="kobo.189.2">Running a command without a shell has the advantage of allowing the application to properly receive signals, such as a </span><strong class="source-inline1"><span class="kobospan" id="kobo.190.1">SIGTERM</span></strong><span class="kobospan" id="kobo.191.1"> or </span><strong class="source-inline1"><span class="kobospan" id="kobo.192.1">SIGKILL</span></strong><span class="kobospan" id="kobo.193.1"> signal when the application is terminated. </span><span class="kobospan" id="kobo.193.2">Alternatively, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.194.1">ENTRYPOINT</span></strong><span class="kobospan" id="kobo.195.1"> instruction can be used to specify which executable should be used to run a certain command (it defaults to </span><strong class="source-inline1"><span class="kobospan" id="kobo.196.1">/bin/sh -c</span></strong><span class="kobospan" id="kobo.197.1">). </span><span class="kobospan" id="kobo.197.2">In some cases, you may even want to run the script directly using </span><strong class="source-inline1"><span class="kobospan" id="kobo.198.1">CMD ["node", "src/index.js"]</span></strong><span class="kobospan" id="kobo.199.1">, so that the script can properly receive </span><em class="italic"><span class="kobospan" id="kobo.200.1">all</span></em><span class="kobospan" id="kobo.201.1"> signals. </span><span class="kobospan" id="kobo.201.2">However, this would require us to implement the </span><strong class="source-inline1"><span class="kobospan" id="kobo.202.1">SIGINT</span></strong><span class="kobospan" id="kobo.203.1"> signal in our backend server to allow closing the container via </span><em class="italic"><span class="kobospan" id="kobo.204.1">Ctrl</span></em><span class="kobospan" id="kobo.205.1"> + </span><em class="italic"><span class="kobospan" id="kobo.206.1">C</span></em><span class="kobospan" id="kobo.207.1">, so, to keep things simple, we just use </span><strong class="source-inline1"><span class="kobospan" id="kobo.208.1">npm </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.209.1">start</span></strong></span><span><span class="kobospan" id="kobo.210.1"> instead.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.211.1">After creating our </span><a id="_idIndexMarker307" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.212.1">Dockerfile, we should also create a </span><strong class="source-inline"><span class="kobospan" id="kobo.213.1">.dockerignore</span></strong><span class="kobospan" id="kobo.214.1"> file to make sure unnecessary files are not copied into </span><span><span class="kobospan" id="kobo.215.1">our image.</span></span></p>
<h2 id="_idParaDest-94" class="calibre7"><a id="_idTextAnchor095" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.216.1">Creating a .dockerignore file</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.217.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.218.1">COPY</span></strong><span class="kobospan" id="kobo.219.1"> command, where </span><a id="_idIndexMarker308" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.220.1">we copy all files, would also copy the </span><strong class="source-inline"><span class="kobospan" id="kobo.221.1">node_modules</span></strong><span class="kobospan" id="kobo.222.1"> folder and other files, such as the </span><strong class="source-inline"><span class="kobospan" id="kobo.223.1">.env</span></strong><span class="kobospan" id="kobo.224.1"> file, which we do not want to go into our image. </span><span class="kobospan" id="kobo.224.2">To prevent certain files from being copied into our Docker image, we need to create a </span><strong class="source-inline"><span class="kobospan" id="kobo.225.1">.dockerignore</span></strong><span class="kobospan" id="kobo.226.1"> file. </span><span class="kobospan" id="kobo.226.2">Let’s do </span><span><span class="kobospan" id="kobo.227.1">that now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.228.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.229.1">backend/.dockerignore</span></strong></span><span><span class="kobospan" id="kobo.230.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.231.1">Open it and enter the following contents to ignore the </span><strong class="source-inline1"><span class="kobospan" id="kobo.232.1">node_modules</span></strong><span class="kobospan" id="kobo.233.1"> folder and all </span><strong class="source-inline1"><span class="kobospan" id="kobo.234.1">.</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.235.1">env</span></strong></span><span><span class="kobospan" id="kobo.236.1"> files:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.237.1">
node_modules
.env*</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.238.1">Now that we have defined a </span><strong class="source-inline"><span class="kobospan" id="kobo.239.1">.dockerignore</span></strong><span class="kobospan" id="kobo.240.1"> file, the </span><strong class="source-inline"><span class="kobospan" id="kobo.241.1">COPY</span></strong><span class="kobospan" id="kobo.242.1"> instructions will ignore these folders and files. </span><span class="kobospan" id="kobo.242.2">Let’s build the Docker </span><span><span class="kobospan" id="kobo.243.1">image now.</span></span></p>
<h2 id="_idParaDest-95" class="calibre7"><a id="_idTextAnchor096" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.244.1">Building the Docker image</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.245.1">After successfully </span><a id="_idIndexMarker309" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.246.1">creating the backend Dockerfile and a </span><strong class="source-inline"><span class="kobospan" id="kobo.247.1">.dockerignore</span></strong><span class="kobospan" id="kobo.248.1"> file to prevent certain files and folders from being added to our Docker image, we can now get started building our </span><span><span class="kobospan" id="kobo.249.1">Docker image:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.250.1">Open </span><span><span class="kobospan" id="kobo.251.1">a Terminal.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.252.1">Run the following command to build the </span><span><span class="kobospan" id="kobo.253.1">Docker image:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.254.1">$ docker image build -t blog-backend backend/</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.255.1">We specified </span><strong class="source-inline"><span class="kobospan" id="kobo.256.1">blog-backend</span></strong><span class="kobospan" id="kobo.257.1"> as the name of our image and </span><strong class="source-inline"><span class="kobospan" id="kobo.258.1">backend/</span></strong><span class="kobospan" id="kobo.259.1"> as the </span><span><span class="kobospan" id="kobo.260.1">working directory.</span></span></p></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.261.1">After running the command, Docker will start by reading the Dockerfile and </span><strong class="source-inline"><span class="kobospan" id="kobo.262.1">.dockerignore</span></strong><span class="kobospan" id="kobo.263.1"> file. </span><span class="kobospan" id="kobo.263.2">Then, it will download the </span><strong class="source-inline"><span class="kobospan" id="kobo.264.1">node</span></strong><span class="kobospan" id="kobo.265.1"> image and run our instructions one by one. </span><span class="kobospan" id="kobo.265.2">Finally, it will export all layers and metadata into our </span><span><span class="kobospan" id="kobo.266.1">Docker image.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.267.1">The following </span><a id="_idIndexMarker310" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.268.1">screenshot shows the output of creating a </span><span><span class="kobospan" id="kobo.269.1">Docker image:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer053">
<span class="kobospan" id="kobo.270.1"><img alt="Figure 5.1 – The output when creating a Docker image" src="image/B19385_05_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.271.1">Figure 5.1 – The output when creating a Docker image</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.272.1">Now that we have successfully created our own image, let’s create and run a container based </span><span><span class="kobospan" id="kobo.273.1">on it!</span></span></p>
<h2 id="_idParaDest-96" class="calibre7"><a id="_idTextAnchor097" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.274.1">Creating and running a container from our image</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.275.1">We have</span><a id="_idIndexMarker311" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.276.1"> already created Docker containers based on the </span><strong class="source-inline"><span class="kobospan" id="kobo.277.1">ubuntu</span></strong><span class="kobospan" id="kobo.278.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.279.1">mongo</span></strong><span class="kobospan" id="kobo.280.1"> images in </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.281.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.282.1">, </span><em class="italic"><span class="kobospan" id="kobo.283.1">Getting to Know Node.js and MongoDB</span></em><span class="kobospan" id="kobo.284.1">. </span><span class="kobospan" id="kobo.284.2">Now, we are going to create and run a container from our own image. </span><span class="kobospan" id="kobo.284.3">Let’s get started doing </span><span><span class="kobospan" id="kobo.285.1">that now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.286.1">Run the following command to list all </span><span><span class="kobospan" id="kobo.287.1">available images:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.288.1">$ docker images</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.289.1">This command should return the </span><strong class="source-inline"><span class="kobospan" id="kobo.290.1">blog-backend</span></strong><span class="kobospan" id="kobo.291.1"> image that we just created, and the </span><strong class="source-inline"><span class="kobospan" id="kobo.292.1">mongo</span></strong><span class="kobospan" id="kobo.293.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.294.1">ubuntu</span></strong><span class="kobospan" id="kobo.295.1"> images that we </span><span><span class="kobospan" id="kobo.296.1">previously used.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.297.1">Make sure the </span><strong class="source-inline1"><span class="kobospan" id="kobo.298.1">dbserver</span></strong><span class="kobospan" id="kobo.299.1"> container with our database is </span><span><span class="kobospan" id="kobo.300.1">already running.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.301.1">Then, start a new container, </span><span><span class="kobospan" id="kobo.302.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.303.1">$ docker run -it -e PORT=3001 -e DATABASE_URL=mongodb://host.docker.internal:27017/blog -p 3001:3001 blog-backend</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.304.1">Let’s break down the</span><a id="_idIndexMarker312" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.305.1"> arguments to the </span><strong class="source-inline"><span class="kobospan" id="kobo.306.1">docker </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.307.1">run</span></strong></span><span><span class="kobospan" id="kobo.308.1"> command:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.309.1">-it</span></strong><span class="kobospan" id="kobo.310.1"> runs the container in interactive mode (</span><strong class="source-inline1"><span class="kobospan" id="kobo.311.1">-t</span></strong><span class="kobospan" id="kobo.312.1"> to allocate a pseudo Terminal and </span><strong class="source-inline1"><span class="kobospan" id="kobo.313.1">-i</span></strong><span class="kobospan" id="kobo.314.1"> to keep the input </span><span><span class="kobospan" id="kobo.315.1">stream open).</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.316.1">-e PORT=3001</span></strong><span class="kobospan" id="kobo.317.1"> sets the </span><strong class="source-inline1"><span class="kobospan" id="kobo.318.1">PORT</span></strong><span class="kobospan" id="kobo.319.1"> environment variable inside the container </span><span><span class="kobospan" id="kobo.320.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.321.1">3001</span></strong></span><span><span class="kobospan" id="kobo.322.1">.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.323.1">-e DATABASE_URL=mongodb://host.docker.internal:27017/blog</span></strong><span class="kobospan" id="kobo.324.1"> sets the </span><strong class="source-inline1"><span class="kobospan" id="kobo.325.1">DATABASE_URL</span></strong><span class="kobospan" id="kobo.326.1"> environment variable. </span><span class="kobospan" id="kobo.326.2">Here, we replaced </span><strong class="source-inline1"><span class="kobospan" id="kobo.327.1">localhost</span></strong><span class="kobospan" id="kobo.328.1"> with </span><strong class="source-inline1"><span class="kobospan" id="kobo.329.1">host.docker.internal</span></strong><span class="kobospan" id="kobo.330.1">, as the MongoDB service runs in a different container on the Docker host (</span><span><span class="kobospan" id="kobo.331.1">our machine).</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.332.1">-p 3001:3001</span></strong><span class="kobospan" id="kobo.333.1"> forwards port </span><strong class="source-inline1"><span class="kobospan" id="kobo.334.1">3001</span></strong><span class="kobospan" id="kobo.335.1"> from inside the container to port </span><strong class="source-inline1"><span class="kobospan" id="kobo.336.1">3001</span></strong><span class="kobospan" id="kobo.337.1"> on the host (</span><span><span class="kobospan" id="kobo.338.1">our machine).</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.339.1">blog-backend</span></strong><span class="kobospan" id="kobo.340.1"> is the name of </span><span><span class="kobospan" id="kobo.341.1">our image.</span></span></li></ul></li> <li class="calibre11"><span class="kobospan" id="kobo.342.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.343.1">blog-backend</span></strong><span class="kobospan" id="kobo.344.1"> container is now running, which looks very similar to running the backend directly on our host in the Terminal. </span><span class="kobospan" id="kobo.344.2">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.345.1">http://localhost:3001/api/v1/posts</span></strong><span class="kobospan" id="kobo.346.1"> to verify that it is running properly like before and returning </span><span><span class="kobospan" id="kobo.347.1">all posts.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.348.1">Keep the </span><a id="_idIndexMarker313" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.349.1">container running </span><span><span class="kobospan" id="kobo.350.1">for now.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.351.1">We have successfully packaged our backend as a Docker image and started a container from it! </span><span class="kobospan" id="kobo.351.2">Now, let’s do the same for </span><span><span class="kobospan" id="kobo.352.1">our frontend.</span></span></p>
<h2 id="_idParaDest-97" class="calibre7"><a id="_idTextAnchor098" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.353.1">Creating the frontend Dockerfile</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.354.1">After creating a Docker image </span><a id="_idIndexMarker314" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.355.1">for the backend service, we are now going to repeat the same process to create an image for the frontend. </span><span class="kobospan" id="kobo.355.2">We will do so by first creating a Dockerfile, then the </span><strong class="source-inline"><span class="kobospan" id="kobo.356.1">.dockerignore</span></strong><span class="kobospan" id="kobo.357.1"> file, building the image, and then running a container. </span><span class="kobospan" id="kobo.357.2">Now, we will start with creating the </span><span><span class="kobospan" id="kobo.358.1">frontend Dockerfile.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.359.1">In the Dockerfile for our frontend, we are going to use </span><span><span class="kobospan" id="kobo.360.1">two images:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.361.1">A </span><strong class="source-inline1"><span class="kobospan" id="kobo.362.1">build</span></strong><span class="kobospan" id="kobo.363.1"> image to build our project</span><a id="_idIndexMarker315" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.364.1"> using </span><strong class="bold"><span class="kobospan" id="kobo.365.1">Vite</span></strong><span class="kobospan" id="kobo.366.1"> (which will be discarded, with only the build </span><span><span class="kobospan" id="kobo.367.1">output kept)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.368.1">A </span><strong class="source-inline1"><span class="kobospan" id="kobo.369.1">final</span></strong><span class="kobospan" id="kobo.370.1"> image, which will serve our static site </span><span><span class="kobospan" id="kobo.371.1">using nginx</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.372.1">Let’s make the </span><span><span class="kobospan" id="kobo.373.1">Dockerfile now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.374.1">Create a new Dockerfile in the root of </span><span><span class="kobospan" id="kobo.375.1">our project.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.376.1">In this newly created file, first, use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.377.1">node</span></strong><span class="kobospan" id="kobo.378.1"> image again, but this time we tag it </span><strong class="source-inline1"><span class="kobospan" id="kobo.379.1">AS build</span></strong><span class="kobospan" id="kobo.380.1">. </span><span class="kobospan" id="kobo.380.2">Doing so enables multi-stage builds in Docker, which means that we can use another base image later for our </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.381.1">final</span></strong></span><span><span class="kobospan" id="kobo.382.1"> image:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.383.1">
FROM node:20 AS build</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.384.1">During build time, we also set the </span><strong class="source-inline1"><span class="kobospan" id="kobo.385.1">VITE_BACKEND_URL</span></strong><span class="kobospan" id="kobo.386.1"> environment variable. </span><span class="kobospan" id="kobo.386.2">In Docker, we can use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.387.1">ARG</span></strong><span class="kobospan" id="kobo.388.1"> instruction to define environment variables that are only relevant when the image is </span><span><span class="kobospan" id="kobo.389.1">being built:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.390.1">
ARG VITE_BACKEND_URL=http://localhost:3001/api/v1</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.391.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.392.1">While the </span><strong class="source-inline1"><span class="kobospan" id="kobo.393.1">ARG</span></strong><span class="kobospan" id="kobo.394.1"> instruction defines an environment variable that can be changed at build time using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.395.1">--build-arg</span></strong><span class="kobospan" id="kobo.396.1"> flag, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.397.1">ENV</span></strong><span class="kobospan" id="kobo.398.1"> instruction sets the environment variable to a fixed value, which will persist when a container is run from the resulting image. </span><span class="kobospan" id="kobo.398.2">So, if we want to customize environment variables during build time, we should use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.399.1">ARG</span></strong><span class="kobospan" id="kobo.400.1"> instruction. </span><span class="kobospan" id="kobo.400.2">However, if we want to customize environment variables during runtime, </span><strong class="source-inline1"><span class="kobospan" id="kobo.401.1">ENV</span></strong><span class="kobospan" id="kobo.402.1"> is </span><span><span class="kobospan" id="kobo.403.1">better suited.</span></span></p>
<ol class="calibre15">
<li value="4" class="calibre11"><span class="kobospan" id="kobo.404.1">We set the</span><a id="_idIndexMarker316" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.405.1"> working directory to </span><strong class="source-inline1"><span class="kobospan" id="kobo.406.1">/build</span></strong><span class="kobospan" id="kobo.407.1"> for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.408.1">build</span></strong><span class="kobospan" id="kobo.409.1"> stage, and then repeat the same instructions that we defined for the backend to install all necessary dependencies and copy over the </span><span><span class="kobospan" id="kobo.410.1">necessary files:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.411.1">
WORKDIR /build
COPY package.json .
</span><span class="kobospan1" id="kobo.411.2">COPY package-lock.json .
</span><span class="kobospan1" id="kobo.411.3">RUN npm install
COPY . </span><span class="kobospan1" id="kobo.411.4">.</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.412.1">Additionally, we execute </span><strong class="source-inline1"><span class="kobospan" id="kobo.413.1">npm run build</span></strong><span class="kobospan" id="kobo.414.1"> to create a static build of our </span><span><span class="kobospan" id="kobo.415.1">Vite app:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.416.1">
RUN npm run build</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.417.1">Now, our </span><strong class="source-inline1"><span class="kobospan" id="kobo.418.1">build</span></strong><span class="kobospan" id="kobo.419.1"> stage is completed. </span><span class="kobospan" id="kobo.419.2">We use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.420.1">FROM</span></strong><span class="kobospan" id="kobo.421.1"> instruction again to create the </span><strong class="source-inline1"><span class="kobospan" id="kobo.422.1">final</span></strong><span class="kobospan" id="kobo.423.1"> stage. </span><span class="kobospan" id="kobo.423.2">This time, we base it off the </span><strong class="source-inline1"><span class="kobospan" id="kobo.424.1">nginx</span></strong><span class="kobospan" id="kobo.425.1"> image, which runs an nginx </span><span><span class="kobospan" id="kobo.426.1">web server:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.427.1">
FROM nginx AS final</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.428.1">We set the working directory for this stage to </span><strong class="source-inline1"><span class="kobospan" id="kobo.429.1">/var/www/html</span></strong><span class="kobospan" id="kobo.430.1">, which is the folder that nginx serves static </span><span><span class="kobospan" id="kobo.431.1">files from:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.432.1">
WORKDIR /usr/share/nginx/html</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.433.1">Lastly, we copy everything from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.434.1">/build/dist</span></strong><span class="kobospan" id="kobo.435.1"> folder (which is where Vite puts the built static files) from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.436.1">build</span></strong><span class="kobospan" id="kobo.437.1"> stage into the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.438.1">final</span></strong></span><span><span class="kobospan" id="kobo.439.1"> stage:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.440.1">
COPY --from=build /build/dist .</span></pre><p class="calibre3"><span class="kobospan" id="kobo.441.1">A </span><strong class="source-inline"><span class="kobospan" id="kobo.442.1">CMD</span></strong><span class="kobospan" id="kobo.443.1"> instruction is not needed in this case, as the </span><strong class="source-inline"><span class="kobospan" id="kobo.444.1">nginx</span></strong><span class="kobospan" id="kobo.445.1"> image already contains one</span><a id="_idIndexMarker317" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.446.1"> to run the web </span><span><span class="kobospan" id="kobo.447.1">server properly.</span></span></p></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.448.1">We successfully created a multi-stage Dockerfile for our frontend! </span><span class="kobospan" id="kobo.448.2">Now, let’s move on to creating the </span><strong class="source-inline"><span class="kobospan" id="kobo.449.1">.</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.450.1">dockerignore</span></strong></span><span><span class="kobospan" id="kobo.451.1"> file.</span></span></p>
<h2 id="_idParaDest-98" class="calibre7"><a id="_idTextAnchor099" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.452.1">Creating the .dockerignore file for the frontend</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.453.1">We also </span><a id="_idIndexMarker318" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.454.1">need to create a </span><strong class="source-inline"><span class="kobospan" id="kobo.455.1">.dockerignore</span></strong><span class="kobospan" id="kobo.456.1"> file for the frontend. </span><span class="kobospan" id="kobo.456.2">Here, we also exclude, in addition to the </span><strong class="source-inline"><span class="kobospan" id="kobo.457.1">node_modules/</span></strong><span class="kobospan" id="kobo.458.1"> folder and </span><strong class="source-inline"><span class="kobospan" id="kobo.459.1">.env</span></strong><span class="kobospan" id="kobo.460.1"> files, the </span><strong class="source-inline"><span class="kobospan" id="kobo.461.1">backend/</span></strong><span class="kobospan" id="kobo.462.1"> folder containing our backend service and the </span><strong class="source-inline"><span class="kobospan" id="kobo.463.1">.vscode</span></strong><span class="kobospan" id="kobo.464.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.465.1">.git</span></strong><span class="kobospan" id="kobo.466.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.467.1">.husky</span></strong><span class="kobospan" id="kobo.468.1"> folders. </span><span class="kobospan" id="kobo.468.2">Let’s create the </span><strong class="source-inline"><span class="kobospan" id="kobo.469.1">.dockerignore</span></strong> <span><span class="kobospan" id="kobo.470.1">file now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.471.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.472.1">.dockerignore</span></strong><span class="kobospan" id="kobo.473.1"> file in the root of </span><span><span class="kobospan" id="kobo.474.1">our project.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.475.1">Inside this newly created file, enter the </span><span><span class="kobospan" id="kobo.476.1">following contents:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.477.1">
node_modules
.env*
backend
.vscode
.git
.husky
.commitlintrc.json</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.478.1">Now that we have ignored the files not necessary for the Docker image, let’s </span><span><span class="kobospan" id="kobo.479.1">build it!</span></span></p>
<h2 id="_idParaDest-99" class="calibre7"><a id="_idTextAnchor100" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.480.1">Building the frontend Docker image</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.481.1">Just like before, we</span><a id="_idIndexMarker319" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.482.1"> execute the </span><strong class="source-inline"><span class="kobospan" id="kobo.483.1">docker build</span></strong><span class="kobospan" id="kobo.484.1"> command to build the image, giving it the name </span><strong class="source-inline"><span class="kobospan" id="kobo.485.1">blog-frontend</span></strong><span class="kobospan" id="kobo.486.1"> and specifying the root directory as </span><span><span class="kobospan" id="kobo.487.1">the path:</span></span></p>
<pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.488.1">$ docker build -t blog-frontend .</span></strong></pre> <p class="calibre3"><span class="kobospan" id="kobo.489.1">Docker will now use the </span><strong class="source-inline"><span class="kobospan" id="kobo.490.1">node</span></strong><span class="kobospan" id="kobo.491.1"> image to build our frontend in the </span><strong class="source-inline"><span class="kobospan" id="kobo.492.1">build</span></strong><span class="kobospan" id="kobo.493.1"> stage. </span><span class="kobospan" id="kobo.493.2">Then, it will switch to the </span><strong class="source-inline"><span class="kobospan" id="kobo.494.1">final</span></strong><span class="kobospan" id="kobo.495.1"> stage, use the </span><strong class="source-inline"><span class="kobospan" id="kobo.496.1">nginx</span></strong><span class="kobospan" id="kobo.497.1"> image, and copy over the built static files from the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.498.1">build</span></strong></span><span><span class="kobospan" id="kobo.499.1"> stage.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.500.1">Now, let’s create and run the </span><span><span class="kobospan" id="kobo.501.1">frontend container.</span></span></p>
<h2 id="_idParaDest-100" class="calibre7"><a id="_idTextAnchor101" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.502.1">Creating and running the frontend container</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.503.1">Similarly to what we did for the</span><a id="_idIndexMarker320" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.504.1"> backend container, we can also create and run a container from the </span><strong class="source-inline"><span class="kobospan" id="kobo.505.1">blog-frontend</span></strong><span class="kobospan" id="kobo.506.1"> image by executing the </span><span><span class="kobospan" id="kobo.507.1">following command:</span></span></p>
<pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.508.1">$ docker run -it -p 3000:80 blog-frontend</span></strong></pre> <p class="calibre3"><span class="kobospan" id="kobo.509.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.510.1">nginx</span></strong><span class="kobospan" id="kobo.511.1"> image runs the web server on port </span><strong class="source-inline"><span class="kobospan" id="kobo.512.1">80</span></strong><span class="kobospan" id="kobo.513.1">, so, if we want to use the port </span><strong class="source-inline"><span class="kobospan" id="kobo.514.1">3000</span></strong><span class="kobospan" id="kobo.515.1"> on our host, we need to forward from port </span><strong class="source-inline"><span class="kobospan" id="kobo.516.1">80</span></strong><span class="kobospan" id="kobo.517.1"> to </span><strong class="source-inline"><span class="kobospan" id="kobo.518.1">3000</span></strong><span class="kobospan" id="kobo.519.1"> by passing </span><strong class="source-inline"><span class="kobospan" id="kobo.520.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.521.1">p 3000:80</span></strong></span><span><span class="kobospan" id="kobo.522.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.523.1">After running this </span><a id="_idIndexMarker321" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.524.1">command and navigating to </span><strong class="source-inline"><span class="kobospan" id="kobo.525.1">http://localhost:3000</span></strong><span class="kobospan" id="kobo.526.1"> in your browser, you should see the frontend being served properly and showing blog posts from </span><span><span class="kobospan" id="kobo.527.1">the backend.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.528.1">Now that we have created images and containers for the backend and frontend, we are going to learn about a way to manage multiple images </span><span><span class="kobospan" id="kobo.529.1">more easily.</span></span></p>
<h2 id="_idParaDest-101" class="calibre7"><a id="_idTextAnchor102" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.530.1">Managing multiple images using Docker Compose</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.531.1">Docker Compose</span><a id="_idIndexMarker322" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.532.1"> is a tool that allows us to define and run multi-container applications with Docker. </span><span class="kobospan" id="kobo.532.2">Instead of manually building and running the backend, frontend, and database containers, we can use Compose to build and run them all together. </span><span class="kobospan" id="kobo.532.3">To get started using Compose, we need to create a </span><strong class="source-inline"><span class="kobospan" id="kobo.533.1">compose.yaml</span></strong><span class="kobospan" id="kobo.534.1"> file in the root of our project, </span><span><span class="kobospan" id="kobo.535.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.536.1">Create a </span><a id="_idIndexMarker323" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.537.1">new </span><strong class="source-inline1"><span class="kobospan" id="kobo.538.1">compose.yaml</span></strong><span class="kobospan" id="kobo.539.1"> file in the root of </span><span><span class="kobospan" id="kobo.540.1">our project.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.541.1">Open the newly created file and start by defining the version of the Docker Compose </span><span><span class="kobospan" id="kobo.542.1">file specification:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.543.1">
version: '3.9'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.544.1">Now, define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.545.1">services</span></strong><span class="kobospan" id="kobo.546.1"> object, in which we are going to define all the services that we want </span><span><span class="kobospan" id="kobo.547.1">to use:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.548.1">
services:</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.549.1">First, we have </span><strong class="source-inline1"><span class="kobospan" id="kobo.550.1">blog-database</span></strong><span class="kobospan" id="kobo.551.1">, which uses the </span><strong class="source-inline1"><span class="kobospan" id="kobo.552.1">mongo</span></strong><span class="kobospan" id="kobo.553.1"> image and forwards </span><span><span class="kobospan" id="kobo.554.1">port </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.555.1">27017</span></strong></span><span><span class="kobospan" id="kobo.556.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.557.1">
  blog-database:
    image: mongo
    ports:
      - '27017:27017'</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.558.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.559.1">In YAML files, the indentation of lines is very important to distinguish where properties are nested, so please be careful to put in the correct amount of spaces before </span><span><span class="kobospan" id="kobo.560.1">each line.</span></span></p>
<ol class="calibre15">
<li value="5" class="calibre11"><span class="kobospan" id="kobo.561.1">Next, we have </span><strong class="source-inline1"><span class="kobospan" id="kobo.562.1">blog-backend</span></strong><span class="kobospan" id="kobo.563.1">, which uses the Dockerfile defined in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.564.1">backend/</span></strong><span class="kobospan" id="kobo.565.1"> folder, defines the environment variables for </span><strong class="source-inline1"><span class="kobospan" id="kobo.566.1">PORT</span></strong><span class="kobospan" id="kobo.567.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.568.1">DATABASE_URL</span></strong><span class="kobospan" id="kobo.569.1">, forwards the port to the host, and depends </span><span><span class="kobospan" id="kobo.570.1">on </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.571.1">blog-database</span></strong></span><span><span class="kobospan" id="kobo.572.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.573.1">
  blog-backend:
    build: backend/
    environment:
      - PORT=3001
      - DATABASE_URL=mongodb://host.docker.internal:27017/blog
    ports:
      - '3001:3001'
    depends_on:
      - blog-database</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.574.1">Lastly, we </span><a id="_idIndexMarker324" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.575.1">have </span><strong class="source-inline1"><span class="kobospan" id="kobo.576.1">blog-frontend</span></strong><span class="kobospan" id="kobo.577.1">, which uses the Dockerfile defined in the root, defines the </span><strong class="source-inline1"><span class="kobospan" id="kobo.578.1">VITE_BACKEND_URL</span></strong><span class="kobospan" id="kobo.579.1"> build argument, forwards the port to the host, and depends </span><span><span class="kobospan" id="kobo.580.1">on </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.581.1">blog-backend</span></strong></span><span><span class="kobospan" id="kobo.582.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.583.1">
  blog-frontend:
    build:
      context: .
</span><span class="kobospan1" id="kobo.583.2">      args:
        VITE_BACKEND_URL: http://localhost:3001/api/v1
    ports:
      - '3000:80'
    depends_on:
      - blog-backend</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.584.1">After defining the services, save </span><span><span class="kobospan" id="kobo.585.1">the file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.586.1">Then, stop the backend and frontend containers running in the terminal by using the </span><em class="italic"><span class="kobospan" id="kobo.587.1">Ctrl</span></em><span class="kobospan" id="kobo.588.1"> + </span><em class="italic"><span class="kobospan" id="kobo.589.1">C</span></em> <span><span class="kobospan" id="kobo.590.1">key combination.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.591.1">Also, stop the already running </span><strong class="source-inline1"><span class="kobospan" id="kobo.592.1">dbserver</span></strong><span class="kobospan" id="kobo.593.1"> container, </span><span><span class="kobospan" id="kobo.594.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.595.1">$ docker stop dbserver</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.596.1">Finally, run the following command in the Terminal to start all services using </span><span><span class="kobospan" id="kobo.597.1">Docker Compose:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.598.1">$ docker compose up</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.599.1">Docker Compose</span><a id="_idIndexMarker325" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.600.1"> will now create containers for the database, backend, and frontend and start all of them. </span><span class="kobospan" id="kobo.600.2">You will start seeing logs being printed from the different services. </span><span class="kobospan" id="kobo.600.3">If you go to </span><strong class="source-inline"><span class="kobospan" id="kobo.601.1">http://localhost:3000</span></strong><span class="kobospan" id="kobo.602.1">, you can see that the frontend is running. </span><span class="kobospan" id="kobo.602.2">Create a new post to verify that the connection to the backend and database works </span><span><span class="kobospan" id="kobo.603.1">as well.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.604.1">The following screenshot shows the output of </span><strong class="source-inline"><span class="kobospan" id="kobo.605.1">docker compose up</span></strong><span class="kobospan" id="kobo.606.1"> creating and starting </span><span><span class="kobospan" id="kobo.607.1">all containers:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer054">
<span class="kobospan" id="kobo.608.1"><img alt="Figure 5.2 – Creating and running multiple containers with Docker Compose" src="image/B19385_05_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.609.1">Figure 5.2 – Creating and running multiple containers with Docker Compose</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.610.1">The output in the screenshot is then followed by log messages from the various services, including the MongoDB database service and our backend and </span><span><span class="kobospan" id="kobo.611.1">frontend services.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.612.1">Just like always, you can press </span><em class="italic"><span class="kobospan" id="kobo.613.1">Ctrl</span></em><span class="kobospan" id="kobo.614.1"> + </span><em class="italic"><span class="kobospan" id="kobo.615.1">C</span></em><span class="kobospan" id="kobo.616.1"> to stop all Docker </span><span><span class="kobospan" id="kobo.617.1">Compose containers.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.618.1">Now that we have set up Docker Compose, it’s very easy to start all services at once and manage them all in one place. </span><span class="kobospan" id="kobo.618.2">If you look at your Docker containers, you may notice that there are lots of stale containers still left over from previously building the </span><strong class="source-inline"><span class="kobospan" id="kobo.619.1">blog-backend</span></strong><span class="kobospan" id="kobo.620.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.621.1">blog-frontend</span></strong><span class="kobospan" id="kobo.622.1"> containers. </span><span class="kobospan" id="kobo.622.2">Let’s now learn how to clean </span><span><span class="kobospan" id="kobo.623.1">up those.</span></span></p>
<h2 id="_idParaDest-102" class="calibre7"><a id="_idTextAnchor103" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.624.1">Cleaning up unused containers</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.625.1">After experimenting </span><a id="_idIndexMarker326" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.626.1">with Docker for a while, there will be lots of images and containers that are not in use anymore. </span><span class="kobospan" id="kobo.626.2">Docker generally does not remove objects unless you explicitly ask it to, causing it to use a lot of disk space. </span><span class="kobospan" id="kobo.626.3">If you want to remove objects, you can either remove them one by one or use one of the </span><strong class="source-inline"><span class="kobospan" id="kobo.627.1">prune</span></strong><span class="kobospan" id="kobo.628.1"> commands provided </span><span><span class="kobospan" id="kobo.629.1">by Docker:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.630.1">docker container prune</span></strong><span class="kobospan" id="kobo.631.1">: This removes all </span><span><span class="kobospan" id="kobo.632.1">stopped containers</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.633.1">docker image prune</span></strong><span class="kobospan" id="kobo.634.1">: This removes all dangling images (images not tagged and not referenced by </span><span><span class="kobospan" id="kobo.635.1">any container)</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.636.1">docker image prune -a</span></strong><span class="kobospan" id="kobo.637.1">: This removes all images not used by </span><span><span class="kobospan" id="kobo.638.1">any containers</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.639.1">docker volume prune</span></strong><span class="kobospan" id="kobo.640.1">: This removes all volumes not used by </span><span><span class="kobospan" id="kobo.641.1">any containers</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.642.1">docker network prune</span></strong><span class="kobospan" id="kobo.643.1">: This cleans up networks not used by </span><span><span class="kobospan" id="kobo.644.1">any containers</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.645.1">docker system prune</span></strong><span class="kobospan" id="kobo.646.1">: This prunes everything </span><span><span class="kobospan" id="kobo.647.1">except volumes</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.648.1">docker system prune --volumes</span></strong><span class="kobospan" id="kobo.649.1">: This </span><span><span class="kobospan" id="kobo.650.1">prunes everything</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.651.1">So, if you want to, for example, remove all </span><a id="_idIndexMarker327" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.652.1">unused containers, you should first make sure that all of the containers that you still want to use are running. </span><span class="kobospan" id="kobo.652.2">Then, execute </span><strong class="source-inline"><span class="kobospan" id="kobo.653.1">docker container prune</span></strong><span class="kobospan" id="kobo.654.1"> in </span><span><span class="kobospan" id="kobo.655.1">the terminal.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.656.1">Now that we have learned how to use Docker locally to package our services as images and run them in containers, let’s move on to deploying our full-stack application to </span><span><span class="kobospan" id="kobo.657.1">the cloud.</span></span></p>
<h1 id="_idParaDest-103" class="calibre5"><a id="_idTextAnchor104" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.658.1">Deploying our full-stack application to the cloud</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.659.1">After </span><a id="_idIndexMarker328" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.660.1">creating Docker images and containers locally, it’s </span><a id="_idIndexMarker329" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.661.1">time to learn how to deploy them to the cloud so that everyone can access our services. </span><span class="kobospan" id="kobo.661.2">In this book, we are going to use </span><strong class="bold"><span class="kobospan" id="kobo.662.1">Google Cloud</span></strong><span class="kobospan" id="kobo.663.1"> as an example, but the general process also applies to other providers such as </span><strong class="bold"><span class="kobospan" id="kobo.664.1">Amazon Web Services</span></strong><span class="kobospan" id="kobo.665.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.666.1">AWS</span></strong><span class="kobospan" id="kobo.667.1">) and </span><a id="_idIndexMarker330" class="calibre6 pcalibre1 pcalibre"/><strong class="bold"><span class="kobospan" id="kobo.668.1">Microsoft Azure</span></strong><span class="kobospan" id="kobo.669.1">. </span><span class="kobospan" id="kobo.669.2">For the MongoDB database, we are going to</span><a id="_idIndexMarker331" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.670.1"> use </span><strong class="bold"><span class="kobospan" id="kobo.671.1">MongoDB Atlas</span></strong><span class="kobospan" id="kobo.672.1"> but feel free to use any provider that can host a MongoDB database </span><span><span class="kobospan" id="kobo.673.1">for you.</span></span></p>
<h2 id="_idParaDest-104" class="calibre7"><a id="_idTextAnchor105" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.674.1">Creating a MongoDB Atlas database</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.675.1">To host our database, we</span><a id="_idIndexMarker332" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.676.1"> are going to use the official cloud solution provided by the MongoDB team called MongoDB Atlas. </span><span class="kobospan" id="kobo.676.2">Let’s get started with registering and setting up a </span><span><span class="kobospan" id="kobo.677.1">database now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.678.1">Go to </span><a href="https://www.mongodb.com/atlas" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.679.1">https://www.mongodb.com/atlas</span></a><span class="kobospan" id="kobo.680.1"> and press </span><strong class="bold"><span class="kobospan" id="kobo.681.1">Try Free</span></strong><span class="kobospan" id="kobo.682.1"> to create a new account, or sign in with your </span><span><span class="kobospan" id="kobo.683.1">existing account.</span></span></li>
</ol>
<p class="callout-heading"><span class="kobospan" id="kobo.684.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.685.1">The following instructions may vary slightly due to updates in the MongoDB Atlas UI. </span><span class="kobospan" id="kobo.685.2">If the options are not available exactly as listed, try to follow the instructions on the website instead to create a database and a user to access it. </span><span class="kobospan" id="kobo.685.3">This applies to all cloud services that we are going to set up throughout </span><span><span class="kobospan" id="kobo.686.1">this chapter.</span></span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.687.1">Select </span><strong class="bold"><span class="kobospan" id="kobo.688.1">Database</span></strong><span class="kobospan" id="kobo.689.1"> from the </span><a id="_idIndexMarker333" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.690.1">sidebar, then press </span><strong class="bold"><span class="kobospan" id="kobo.691.1">Create</span></strong><span class="kobospan" id="kobo.692.1"> to create a new database deployment. </span><span class="kobospan" id="kobo.692.2">If you made a new account, you should be asked to create a new database </span><span><span class="kobospan" id="kobo.693.1">deployment automatically.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.694.1">Select </span><strong class="bold"><span class="kobospan" id="kobo.695.1">Shared / M0 Sandbox</span></strong><span class="kobospan" id="kobo.696.1"> (free instance) on Google Cloud and your </span><span><span class="kobospan" id="kobo.697.1">preferred region.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.698.1">Give your cluster a name of </span><span><span class="kobospan" id="kobo.699.1">your choice.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.700.1">Press </span><strong class="bold"><span class="kobospan" id="kobo.701.1">Create</span></strong><span class="kobospan" id="kobo.702.1"> to create your M0 sandbox cluster. </span><span class="kobospan" id="kobo.702.2">It will take some time for the database to be accessible (typically around a minute). </span><span class="kobospan" id="kobo.702.3">However, you can continue setting up the user while waiting for the cluster to be </span><span><span class="kobospan" id="kobo.703.1">set up.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.704.1">Go to the </span><strong class="bold"><span class="kobospan" id="kobo.705.1">Database</span></strong><span class="kobospan" id="kobo.706.1"> section in the sidebar and click on the </span><strong class="bold"><span class="kobospan" id="kobo.707.1">Connect</span></strong><span class="kobospan" id="kobo.708.1"> button next to your newly </span><span><span class="kobospan" id="kobo.709.1">created cluster.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.710.1">In the popup, select </span><strong class="bold"><span class="kobospan" id="kobo.711.1">Allow Access from Anywhere</span></strong><span class="kobospan" id="kobo.712.1"> and then press </span><strong class="bold"><span class="kobospan" id="kobo.713.1">Add </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.714.1">IP Address</span></strong></span><span><span class="kobospan" id="kobo.715.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.716.1">Set a username and password for your database user and press </span><strong class="bold"><span class="kobospan" id="kobo.717.1">Create </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.718.1">database user</span></strong></span><span><span class="kobospan" id="kobo.719.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.720.1">Press </span><strong class="bold"><span class="kobospan" id="kobo.721.1">Choose a connection method</span></strong><span class="kobospan" id="kobo.722.1"> and </span><span><span class="kobospan" id="kobo.723.1">select </span></span><span><strong class="bold"><span class="kobospan" id="kobo.724.1">Drivers</span></strong></span><span><span class="kobospan" id="kobo.725.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.726.1">A connection </span><a id="_idIndexMarker334" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.727.1">string will be shown; copy it and save it for later, inserting your previously set password instead of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.728.1">&lt;password&gt;</span></strong><span class="kobospan" id="kobo.729.1"> string. </span><span class="kobospan" id="kobo.729.2">The connection string should have the </span><span><span class="kobospan" id="kobo.730.1">following format:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.731.1">
mongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;cluster-name&gt;.&lt;cluster-id&gt;.mongodb.net/?retryWrites=true&amp;w=majority</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.732.1">Verify that the</span><a id="_idIndexMarker335" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.733.1"> connection string works by opening a terminal and connecting to it using </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.734.1">mongo</span></strong></span><span><span class="kobospan" id="kobo.735.1"> shell:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.736.1">$ mongosh "&lt;connection-string&gt;"</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.737.1">The following screenshot shows how the </span><strong class="bold"><span class="kobospan" id="kobo.738.1">Database Deployments</span></strong><span class="kobospan" id="kobo.739.1"> tab looks in </span><span><span class="kobospan" id="kobo.740.1">MongoDB Atlas:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer055">
<span class="kobospan" id="kobo.741.1"><img alt="Figure 5.3 – A fresh M0 Sandbox database cluster deployed on MongoDB Atlas" src="image/B19385_05_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.742.1">Figure 5.3 – A fresh M0 Sandbox database cluster deployed on MongoDB Atlas</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.743.1">Now that we have successfully created our MongoDB database in the cloud, we can move on to setting up Google Cloud to deploy our backend </span><span><span class="kobospan" id="kobo.744.1">and frontend.</span></span></p>
<h2 id="_idParaDest-105" class="calibre7"><a id="_idTextAnchor106" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.745.1">Creating an account on Google Cloud</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.746.1">Let’s get started with </span><a id="_idIndexMarker336" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.747.1">Google Cloud by creating an account now. </span><span class="kobospan" id="kobo.747.2">When creating an account, you need to enter billing information, but you will get $300 in free credits to trial using Google Cloud </span><span><span class="kobospan" id="kobo.748.1">for free:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.749.1">Go to </span><a href="https://cloud.google.com" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.750.1">https://cloud.google.com</span></a><span class="kobospan" id="kobo.751.1"> in </span><span><span class="kobospan" id="kobo.752.1">your browser.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.753.1">Press </span><strong class="bold"><span class="kobospan" id="kobo.754.1">Get started for free</span></strong><span class="kobospan" id="kobo.755.1"> if you do not have an account yet or press </span><strong class="bold"><span class="kobospan" id="kobo.756.1">Sign in</span></strong><span class="kobospan" id="kobo.757.1"> if you already have </span><span><span class="kobospan" id="kobo.758.1">an account.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.759.1">Log in with your Google account and follow the instructions until you have access to the Google </span><span><span class="kobospan" id="kobo.760.1">Cloud console.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.761.1">You should now see a screen similar to the </span><span><span class="kobospan" id="kobo.762.1">following figure:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer056">
<span class="kobospan" id="kobo.763.1"><img alt="Figure 5.4 – The Google Cloud console after registering" src="image/B19385_05_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.764.1">Figure 5.4 – The Google Cloud console after registering</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.765.1">Now that you have an account set up and ready, let’s start deploying </span><span><span class="kobospan" id="kobo.766.1">our services.</span></span></p>
<h2 id="_idParaDest-106" class="calibre7"><a id="_idTextAnchor107" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.767.1">Deploying our Docker images to a Docker registry</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.768.1">Before we</span><a id="_idIndexMarker337" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.769.1"> can deploy a service on a cloud provider, we first need to deploy our Docker image to a </span><strong class="bold"><span class="kobospan" id="kobo.770.1">Docker registry</span></strong><span class="kobospan" id="kobo.771.1"> so that the cloud provider can access it from there and create a container from it. </span><span class="kobospan" id="kobo.771.2">Follow these steps to deploy our Docker images to Docker Hub, the official </span><span><span class="kobospan" id="kobo.772.1">Docker registry:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.773.1">Go to </span><a href="https://hub.docker.com" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.774.1">https://hub.docker.com</span></a><span class="kobospan" id="kobo.775.1"> and log in or register an </span><span><span class="kobospan" id="kobo.776.1">account there.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.777.1">Press the </span><strong class="bold"><span class="kobospan" id="kobo.778.1">Create repository</span></strong><span class="kobospan" id="kobo.779.1"> button to create a new repository. </span><span class="kobospan" id="kobo.779.2">The repository will contain </span><span><span class="kobospan" id="kobo.780.1">our image.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.781.1">Enter </span><strong class="source-inline1"><span class="kobospan" id="kobo.782.1">blog-frontend</span></strong><span class="kobospan" id="kobo.783.1"> as the repository name and leave the description empty and visibility </span><strong class="source-inline1"><span class="kobospan" id="kobo.784.1">public</span></strong><span class="kobospan" id="kobo.785.1">. </span><span class="kobospan" id="kobo.785.2">Then press the </span><span><strong class="bold"><span class="kobospan" id="kobo.786.1">Create</span></strong></span><span><span class="kobospan" id="kobo.787.1"> button.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.788.1">Repeat </span><em class="italic"><span class="kobospan" id="kobo.789.1">Steps 2</span></em><span class="kobospan" id="kobo.790.1"> and </span><em class="italic"><span class="kobospan" id="kobo.791.1">3</span></em><span class="kobospan" id="kobo.792.1">, but this time, enter </span><strong class="source-inline1"><span class="kobospan" id="kobo.793.1">blog-backend</span></strong><span class="kobospan" id="kobo.794.1"> as the </span><span><span class="kobospan" id="kobo.795.1">repository name.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.796.1">Open a new terminal and enter the following command to log in to your Docker </span><span><span class="kobospan" id="kobo.797.1">Hub account:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.798.1">$ docker login</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.799.1">Enter your username and password from Docker Hub and press the </span><em class="italic"><span class="kobospan" id="kobo.800.1">Return</span></em><span class="kobospan" id="kobo.801.1"> key </span><span><span class="kobospan" id="kobo.802.1">or </span></span><span><em class="italic"><span class="kobospan" id="kobo.803.1">Enter</span></em></span><span><span class="kobospan" id="kobo.804.1">.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.805.1">Rebuild your image for Linux (to be able to deploy it to Google Cloud later), tag your image with your repository name (replace </span><strong class="source-inline1"><span class="kobospan" id="kobo.806.1">[USERNAME]</span></strong><span class="kobospan" id="kobo.807.1"> with your Docker Hub username), and push it to </span><span><span class="kobospan" id="kobo.808.1">the repository:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.809.1">$ docker build --platform linux/amd64 -t blog-frontend .</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.810.1">$ docker tag blog-frontend [USERNAME]/blog-frontend</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.811.1">$ docker push [USERNAME]/blog-frontend</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.812.1">Navigate to </span><strong class="source-inline1"><span class="kobospan" id="kobo.813.1">backend/</span></strong><span class="kobospan" id="kobo.814.1"> in the terminal and repeat </span><em class="italic"><span class="kobospan" id="kobo.815.1">Step 6</span></em><span class="kobospan" id="kobo.816.1"> for the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.817.1">blog-backend</span></strong></span><span><span class="kobospan" id="kobo.818.1"> image:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.819.1">$ cd backend/</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.820.1">$ docker build --platform linux/amd64 -t blog-backend .</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.821.1">$ docker tag blog-backend [USERNAME]/blog-backend</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.822.1">$ docker push [USERNAME]/blog-backend</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.823.1">Now that both</span><a id="_idIndexMarker338" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.824.1"> repositories are set up and the images are pushed to them, they should show up in Docker Hub with the following information: </span><strong class="bold"><span class="kobospan" id="kobo.825.1">Contains: Image | Last pushed: a few </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.826.1">seconds ago</span></strong></span><span><span class="kobospan" id="kobo.827.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer057">
<span class="kobospan" id="kobo.828.1"><img alt="Figure 5.5 – Docker Hub giving an overview of our repositories" src="image/B19385_05_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.829.1">Figure 5.5 – Docker Hub giving an overview of our repositories</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.830.1">Now that our Docker images are published on a public Docker registry (Docker Hub), we can continue setting up Google Cloud to deploy </span><span><span class="kobospan" id="kobo.831.1">our services.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.832.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.833.1">The repositories created on Docker Hub in this book are </span><em class="italic"><span class="kobospan" id="kobo.834.1">public</span></em><span class="kobospan" id="kobo.835.1">. </span><span class="kobospan" id="kobo.835.2">You can also choose to create up to one private repository on Docker Hub for free. </span><span class="kobospan" id="kobo.835.3">Otherwise, you either need to have a Docker Hub subscription, use a different registry, or host your own registry. </span><span class="kobospan" id="kobo.835.4">For example, </span><strong class="bold"><span class="kobospan" id="kobo.836.1">Google Artifact Registry</span></strong><span class="kobospan" id="kobo.837.1"> could</span><a id="_idIndexMarker339" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.838.1"> be used to deploy private Docker images </span><a id="_idIndexMarker340" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.839.1">on </span><span><strong class="bold"><span class="kobospan" id="kobo.840.1">Cloud Run</span></strong></span><span><span class="kobospan" id="kobo.841.1">.</span></span></p>
<h2 id="_idParaDest-107" class="calibre7"><a id="_idTextAnchor108" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.842.1">Deploying the backend Docker image to Cloud Run</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.843.1">After successfully </span><a id="_idIndexMarker341" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.844.1">publishing our Docker images on the </span><a id="_idIndexMarker342" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.845.1">Docker Hub registry, it’s time to deploy them using Google Cloud Run. </span><span class="kobospan" id="kobo.845.2">Cloud Run is a managed compute platform. </span><span class="kobospan" id="kobo.845.3">It allows us to run containers directly on the Google Cloud infrastructure, making app deployment simple and fast. </span><span class="kobospan" id="kobo.845.4">The alternatives to Cloud Run would be Kubernetes-based infrastructure, such as AWS ECS Fargate </span><span><span class="kobospan" id="kobo.846.1">or DigitalOcean.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.847.1">Follow these</span><a id="_idIndexMarker343" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.848.1"> steps to deploy the backend to </span><a id="_idIndexMarker344" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.849.1">Google </span><span><span class="kobospan" id="kobo.850.1">Cloud Run:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.851.1">Go </span><span><span class="kobospan" id="kobo.852.1">to </span></span><a href="https://console.cloud.google.com/" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.853.1">https://console.cloud.google.com/</span></span></a><span><span class="kobospan" id="kobo.854.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.855.1">In the search bar at the top, enter </span><strong class="source-inline1"><span class="kobospan" id="kobo.856.1">Cloud Run</span></strong><span class="kobospan" id="kobo.857.1"> and select the </span><strong class="bold"><span class="kobospan" id="kobo.858.1">Cloud Run – Serverless for containerized </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.859.1">applications</span></strong></span><span><span class="kobospan" id="kobo.860.1"> product.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.861.1">Press the </span><strong class="bold"><span class="kobospan" id="kobo.862.1">Create Service</span></strong><span class="kobospan" id="kobo.863.1"> button to create a </span><span><span class="kobospan" id="kobo.864.1">new service.</span></span></li>
</ol>
<p class="callout-heading"><span class="kobospan" id="kobo.865.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.866.1">You may need to first create a project before you can create a service. </span><span class="kobospan" id="kobo.866.2">In that case, just follow the instructions on the website to create a new project with a name of your choice. </span><span class="kobospan" id="kobo.866.3">Afterward, press the </span><strong class="bold"><span class="kobospan" id="kobo.867.1">Create Service</span></strong><span class="kobospan" id="kobo.868.1"> button to create a </span><span><span class="kobospan" id="kobo.869.1">new service.</span></span></p>
<ol class="calibre15">
<li value="4" class="calibre11"><span class="kobospan" id="kobo.870.1">Enter </span><strong class="source-inline1"><span class="kobospan" id="kobo.871.1">[USERNAME]</span></strong><strong class="source-inline1"><span class="kobospan" id="kobo.872.1">/blog-backend</span></strong><span class="kobospan" id="kobo.873.1"> in the </span><strong class="bold"><span class="kobospan" id="kobo.874.1">Container image </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.875.1">URL</span></strong></span><span><span class="kobospan" id="kobo.876.1"> box.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.877.1">Enter </span><strong class="source-inline1"><span class="kobospan" id="kobo.878.1">blog-backend</span></strong><span class="kobospan" id="kobo.879.1"> in the </span><strong class="bold"><span class="kobospan" id="kobo.880.1">Service name</span></strong><span class="kobospan" id="kobo.881.1"> box, select a region of your choice, leave </span><strong class="bold"><span class="kobospan" id="kobo.882.1">CPU is only allocated during request processing</span></strong><span class="kobospan" id="kobo.883.1"> selected, and select </span><strong class="bold"><span class="kobospan" id="kobo.884.1">All – Allow direct access to your service from the Internet</span></strong><span class="kobospan" id="kobo.885.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.886.1">Authentication – Allow </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.887.1">unauthenticated invocations</span></strong></span><span><span class="kobospan" id="kobo.888.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.889.1">Expand the </span><strong class="bold"><span class="kobospan" id="kobo.890.1">Container, Networking, Security</span></strong><span class="kobospan" id="kobo.891.1"> section, scroll down to </span><strong class="bold"><span class="kobospan" id="kobo.892.1">Environment variables</span></strong><span class="kobospan" id="kobo.893.1">, and click on </span><span><strong class="bold"><span class="kobospan" id="kobo.894.1">Add Variable</span></strong></span><span><span class="kobospan" id="kobo.895.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.896.1">Name the new environment variable </span><strong class="source-inline1"><span class="kobospan" id="kobo.897.1">DATABASE_URL</span></strong><span class="kobospan" id="kobo.898.1"> and, as the value, enter the connection string from MongoDB Atlas, which you </span><span><span class="kobospan" id="kobo.899.1">saved earlier.</span></span></li>
</ol>
<p class="callout-heading"><span class="kobospan" id="kobo.900.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.901.1">For simplicity, we are using a regular environment variable here. </span><span class="kobospan" id="kobo.901.2">To make variables that contain credentials more secure, it </span><a id="_idIndexMarker345" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.902.1">should instead be added as a secret, which requires enabling the </span><strong class="bold"><span class="kobospan" id="kobo.903.1">Secrets API</span></strong><span class="kobospan" id="kobo.904.1">, adding the secret to the secret manager, and then referencing the secret and choosing it to be exposed as an </span><span><span class="kobospan" id="kobo.905.1">environment variable.</span></span></p>
<ol class="calibre15">
<li value="8" class="calibre11"><span class="kobospan" id="kobo.906.1">Leave the rest of the options as the default options and </span><span><span class="kobospan" id="kobo.907.1">press </span></span><span><strong class="bold"><span class="kobospan" id="kobo.908.1">Create</span></strong></span><span><span class="kobospan" id="kobo.909.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.910.1">You will get redirected to the newly created service, where the container is currently being deployed. </span><span class="kobospan" id="kobo.910.2">Wait until it finishes deploying, which can take up to a couple </span><span><span class="kobospan" id="kobo.911.1">of minutes.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.912.1">When</span><a id="_idIndexMarker346" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.913.1"> the service finishes </span><a id="_idIndexMarker347" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.914.1">deploying, you should see a checkmark and a URL. </span><span class="kobospan" id="kobo.914.2">Click the URL to open the backend and you will see our </span><strong class="bold"><span class="kobospan" id="kobo.915.1">Hello World from Express!</span></strong><span class="kobospan" id="kobo.916.1"> message, which means that our backend was successfully deployed in </span><span><span class="kobospan" id="kobo.917.1">the cloud!</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.918.1">A deployed service looks as follows in Google </span><span><span class="kobospan" id="kobo.919.1">Cloud Run:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer058">
<span class="kobospan" id="kobo.920.1"><img alt="Figure 5.6 – A successfully deployed service on Google Cloud Run" src="image/B19385_05_6.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.921.1">Figure 5.6 – A successfully deployed service on Google Cloud Run</span></p>
<h2 id="_idParaDest-108" class="calibre7"><a id="_idTextAnchor109" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.922.1">Deploying the frontend Docker image to Cloud Run</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.923.1">For the</span><a id="_idIndexMarker348" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.924.1"> frontend, we first need to rebuild the</span><a id="_idIndexMarker349" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.925.1"> container to change the </span><strong class="source-inline"><span class="kobospan" id="kobo.926.1">VITE_BACKEND_URL</span></strong><span class="kobospan" id="kobo.927.1"> environment variable, which is statically built into our project. </span><span class="kobospan" id="kobo.927.2">Let’s do </span><span><span class="kobospan" id="kobo.928.1">that first:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.929.1">Open a terminal and run the following command to rebuild the frontend with the environment </span><span><span class="kobospan" id="kobo.930.1">variable set:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.931.1">$ docker build --platform linux/amd64 --build-arg "VITE_BACKEND_URL=[URL]/api/v1" -t blog-frontend .</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.932.1">Make sure to replace </span><strong class="source-inline"><span class="kobospan" id="kobo.933.1">[URL]</span></strong><span class="kobospan" id="kobo.934.1"> with the URL to the backend service deployed on Google </span><span><span class="kobospan" id="kobo.935.1">Cloud Run.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.936.1">Tag it with </span><a id="_idIndexMarker350" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.937.1">your Docker Hub username</span><a id="_idIndexMarker351" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.938.1"> and deploy the new version of the image to </span><span><span class="kobospan" id="kobo.939.1">Docker Hub:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.940.1">$ docker tag blog-frontend [USERNAME]/blog-frontend</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.941.1">$ docker push [USERNAME]/blog-frontend</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.942.1">Now, we can repeat similar steps as we did to deploy the backend to deploy our frontend </span><span><span class="kobospan" id="kobo.943.1">as well:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.944.1">Create a new Cloud Run service, enter </span><strong class="source-inline1"><span class="kobospan" id="kobo.945.1">[USERNAME]</span></strong><strong class="source-inline1"><span class="kobospan" id="kobo.946.1">/blog-frontend</span></strong><span class="kobospan" id="kobo.947.1"> in the </span><strong class="bold"><span class="kobospan" id="kobo.948.1">Container image URL</span></strong><span class="kobospan" id="kobo.949.1"> box and </span><strong class="source-inline1"><span class="kobospan" id="kobo.950.1">blog-frontend</span></strong><span class="kobospan" id="kobo.951.1"> in the </span><strong class="bold"><span class="kobospan" id="kobo.952.1">Service </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.953.1">name</span></strong></span><span><span class="kobospan" id="kobo.954.1"> box.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.955.1">Pick a region of your choice and enable </span><strong class="bold"><span class="kobospan" id="kobo.956.1">Allow </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.957.1">unauthenticated invocations</span></strong></span><span><span class="kobospan" id="kobo.958.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.959.1">Expand </span><strong class="bold"><span class="kobospan" id="kobo.960.1">Container, Networking, Security</span></strong><span class="kobospan" id="kobo.961.1"> and change the container port from </span><strong class="source-inline1"><span class="kobospan" id="kobo.962.1">8080</span></strong> <span><span class="kobospan" id="kobo.963.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.964.1">80</span></strong></span><span><span class="kobospan" id="kobo.965.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.966.1">Press </span><strong class="bold"><span class="kobospan" id="kobo.967.1">Create</span></strong><span class="kobospan" id="kobo.968.1"> to create the service and wait for it to </span><span><span class="kobospan" id="kobo.969.1">be deployed.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.970.1">Open the URL in your browser and you should see the deployed frontend. </span><span class="kobospan" id="kobo.970.2">Adding and listing blog posts also works now by sending a request to the deployed backend, which then stores the posts in our MongoDB </span><span><span class="kobospan" id="kobo.971.1">Atlas cluster.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.972.1">We have successfully manually deployed our first full-stack React and Node.js application with a MongoDB database in the cloud! </span><span class="kobospan" id="kobo.972.2">In the next sections, we are going to focus on automating testing and deployment </span><span><span class="kobospan" id="kobo.973.1">using CI/CD.</span></span></p>
<h1 id="_idParaDest-109" class="calibre5"><a id="_idTextAnchor110" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.974.1">Configuring CI to automate testing</span></h1>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.975.1">Continuous Integration</span></strong><span class="kobospan" id="kobo.976.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.977.1">CI</span></strong><span class="kobospan" id="kobo.978.1">) covers the automation of </span><a id="_idIndexMarker352" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.979.1">integrating code changes to find bugs quicker and keep the code base easily maintainable. </span><span class="kobospan" id="kobo.979.2">Usually, this is facilitated by having scripts run automatically when a developer makes a pull/merge request before the code is merged into the main branch. </span><span class="kobospan" id="kobo.979.3">This practice allows us to detect problems with our code early by, for example, running the linter and tests before the code can be merged. </span><span class="kobospan" id="kobo.979.4">As a result, CI gives us more confidence in our code and allows us to make and deploy changes faster and </span><span><span class="kobospan" id="kobo.980.1">more frequently.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.981.1">The following figure shows a </span><a id="_idIndexMarker353" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.982.1">simple overview of a possible </span><span><span class="kobospan" id="kobo.983.1">CI/CD pipeline:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer059">
<span class="kobospan" id="kobo.984.1"><img alt="Figure 5.7 – Simple overview of a CI/CD pipeline" src="image/B19385_05_7.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.985.1">Figure 5.7 – Simple overview of a CI/CD pipeline</span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.986.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.987.1">In this book, we are going to </span><a id="_idIndexMarker354" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.988.1">use </span><strong class="bold"><span class="kobospan" id="kobo.989.1">GitHub Actions</span></strong><span class="kobospan" id="kobo.990.1"> for CI/CD. </span><span class="kobospan" id="kobo.990.2">While the syntax and configuration files might look and work differently on other systems, such as GitLab CI/CD or CircleCI, the general principles </span><span><span class="kobospan" id="kobo.991.1">are similar.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.992.1">In GitHub Actions, </span><strong class="bold"><span class="kobospan" id="kobo.993.1">workflows</span></strong><span class="kobospan" id="kobo.994.1"> can</span><a id="_idIndexMarker355" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.995.1"> be triggered </span><a id="_idIndexMarker356" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.996.1">when </span><strong class="bold"><span class="kobospan" id="kobo.997.1">events</span></strong><span class="kobospan" id="kobo.998.1"> occur in the repository, such as pushing to a branch, opening a new pull request, or creating a new issue. </span><span class="kobospan" id="kobo.998.2">Workflows can contain one or </span><a id="_idIndexMarker357" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.999.1">multiple </span><strong class="bold"><span class="kobospan" id="kobo.1000.1">jobs</span></strong><span class="kobospan" id="kobo.1001.1">, which can either run in parallel or sequentially. </span><span class="kobospan" id="kobo.1001.2">Each job runs inside its own </span><strong class="bold"><span class="kobospan" id="kobo.1002.1">runner</span></strong><span class="kobospan" id="kobo.1003.1">, which takes </span><a id="_idIndexMarker358" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1004.1">instructions from the CI definition and executes them within a specified </span><a id="_idIndexMarker359" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1005.1">container. </span><span class="kobospan" id="kobo.1005.2">Inside jobs, </span><strong class="bold"><span class="kobospan" id="kobo.1006.1">actions</span></strong><span class="kobospan" id="kobo.1007.1"> can</span><a id="_idIndexMarker360" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1008.1"> be performed, which are either existing actions provided on GitHub, or we can write our </span><span><span class="kobospan" id="kobo.1009.1">own actions.</span></span></p>
<h2 id="_idParaDest-110" class="calibre7"><a id="_idTextAnchor111" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1010.1">Adding CI for the frontend</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1011.1">Let’s get started</span><a id="_idIndexMarker361" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1012.1"> creating a workflow that will build the frontend when a pull request is created, or a push is made to the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1013.1">main</span></strong></span><span><span class="kobospan" id="kobo.1014.1"> branch:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1015.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.1016.1">.github/</span></strong><span class="kobospan" id="kobo.1017.1"> folder in the root of our project. </span><span class="kobospan" id="kobo.1017.2">Inside it, create a </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1018.1">workflows/</span></strong></span><span><span class="kobospan" id="kobo.1019.1"> folder.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1020.1">Inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1021.1">.github/workflows/</span></strong><span class="kobospan" id="kobo.1022.1"> folder, create a new file </span><span><span class="kobospan" id="kobo.1023.1">called </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1024.1">frontend-ci.yaml</span></strong></span><span><span class="kobospan" id="kobo.1025.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1026.1">Open the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1027.1">.github/workflows/frontend-ci.yaml</span></strong><span class="kobospan" id="kobo.1028.1"> file and start by giving the workflow </span><span><span class="kobospan" id="kobo.1029.1">a name:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1030.1">
name: Blog Frontend CI</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1031.1">Then, listen to events by using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1032.1">on</span></strong><span class="kobospan" id="kobo.1033.1"> keyword. </span><span class="kobospan" id="kobo.1033.2">We are going to execute the jobs when a new pull request or push is made to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1034.1">main</span></strong></span><span><span class="kobospan" id="kobo.1035.1"> branch:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1036.1">
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1037.1">Now, we define a job that will run the linter and build </span><span><span class="kobospan" id="kobo.1038.1">the frontend:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1039.1">
jobs:
  lint-and-build:</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1040.1">We run the job on an </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1041.1">ubuntu-latest</span></strong></span><span><span class="kobospan" id="kobo.1042.1"> container:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1043.1">
    runs-on: ubuntu-latest</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1044.1">We can make use of the matrix strategy to run our tests multiple times with different variables. </span><span class="kobospan" id="kobo.1044.2">In our case, we want to run it on multiple </span><span><span class="kobospan" id="kobo.1045.1">Node.js versions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1046.1">
    strategy:
      matrix:
        node-version: [16.x, 18.x, 20.x]</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1047.1">Now, we define the steps inside our job. </span><span class="kobospan" id="kobo.1047.2">Make sure the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1048.1">steps</span></strong><span class="kobospan" id="kobo.1049.1"> are defined on the same indentation level </span><span><span class="kobospan" id="kobo.1050.1">as </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1051.1">strategy</span></strong></span><span><span class="kobospan" id="kobo.1052.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1053.1">
    steps:</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1054.1">First, we use </span><a id="_idIndexMarker362" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1055.1">the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1056.1">actions/checkout</span></strong><span class="kobospan" id="kobo.1057.1"> action, which checks out </span><span><span class="kobospan" id="kobo.1058.1">our repository:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1059.1">
      - uses: actions/checkout@v3</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1060.1">Then, we use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1061.1">actions/setup-node</span></strong><span class="kobospan" id="kobo.1062.1"> action, which sets up Node.js inside our container. </span><span class="kobospan" id="kobo.1062.2">Here, we make use of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1063.1">node-version</span></strong><span class="kobospan" id="kobo.1064.1"> variable we </span><span><span class="kobospan" id="kobo.1065.1">defined earlier:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1066.1">
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1067.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1068.1">cache</span></strong><span class="kobospan" id="kobo.1069.1"> option specifies a package manager to be used for </span><span><span class="kobospan" id="kobo.1070.1">caching dependencies.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.1071.1">Finally, we</span><a id="_idIndexMarker363" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1072.1"> install dependencies, run the linter, and build </span><span><span class="kobospan" id="kobo.1073.1">our frontend:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1074.1">
      - name: Install dependencies
        run: npm install
      - name: Run linter on frontend
        run: npm run lint
      - name: Build frontend
        run: npm run build</span></pre></li> </ol>
<h2 id="_idParaDest-111" class="calibre7"><a id="_idTextAnchor112" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1075.1">Adding CI for the backend</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1076.1">Now that we</span><a id="_idIndexMarker364" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1077.1"> have added CI for the frontend, let’s also add CI for the backend by building and testing it when a pull request is created or a push is made to the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1078.1">main</span></strong></span><span><span class="kobospan" id="kobo.1079.1"> branch:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1080.1">Inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1081.1">.github/workflows/</span></strong><span class="kobospan" id="kobo.1082.1"> folder, create a new file </span><span><span class="kobospan" id="kobo.1083.1">called </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1084.1">backend-ci.yaml</span></strong></span><span><span class="kobospan" id="kobo.1085.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1086.1">Open the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1087.1">.github/workflows/backend-ci.yaml</span></strong><span class="kobospan" id="kobo.1088.1"> file, start by giving it a name, and listen to the same events as we did for the </span><span><span class="kobospan" id="kobo.1089.1">frontend CI:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1090.1">
name: Blog Backend CI
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1091.1">Now, we define a job that will build and test the backend. </span><span class="kobospan" id="kobo.1091.2">We set the default working directory to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1092.1">backend/</span></strong><span class="kobospan" id="kobo.1093.1"> folder to run all actions inside </span><span><span class="kobospan" id="kobo.1094.1">that folder:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1095.1">
jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [16.x, 18.x, 20.x]
    defaults:
      run:
        working-directory: ./backend</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1096.1">Then, we </span><a id="_idIndexMarker365" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1097.1">use the same actions as for the frontend to check out the repository and set </span><span><span class="kobospan" id="kobo.1098.1">up Node.js:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1099.1">
    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      - name: Install dependencies
        run: npm install</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1100.1">Finally, we run the linter on our backend and run </span><span><span class="kobospan" id="kobo.1101.1">the tests:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1102.1">
      - name: Run linter on backend
        run: npm run lint
      - name: Run backend tests
        run: npm test</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1103.1">Save the workflow files and commit and push them to a GitHub repository by creating a new repository on GitHub and following their instructions to push an existing repository </span><span><span class="kobospan" id="kobo.1104.1">to GitHub.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1105.1">Go to the </span><a id="_idIndexMarker366" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1106.1">repository on GitHub and select the </span><strong class="bold"><span class="kobospan" id="kobo.1107.1">Actions</span></strong><span class="kobospan" id="kobo.1108.1"> tab. </span><span class="kobospan" id="kobo.1108.2">You should see your workflows </span><span><span class="kobospan" id="kobo.1109.1">running here.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.1110.1">The following screenshot shows our CI workflows successfully running </span><span><span class="kobospan" id="kobo.1111.1">on GitHub:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer060">
<span class="kobospan" id="kobo.1112.1"><img alt="Figure 5.8 – Backend and frontend CI workflows successfully running in GitHub Actions" src="image/B19385_05_8.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1113.1">Figure 5.8 – Backend and frontend CI workflows successfully running in GitHub Actions</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1114.1">If we make a new pull request to the </span><strong class="source-inline"><span class="kobospan" id="kobo.1115.1">main</span></strong><span class="kobospan" id="kobo.1116.1"> branch, we can also see that our CI workflows are running properly on the new code. </span><span class="kobospan" id="kobo.1116.2">For example, if we added a way to tag posts from the frontend and accidentally made tags required in the backend without considering our previous rule of only the title being required, we will see that the corresponding </span><span><span class="kobospan" id="kobo.1117.1">tests failed:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer061">
<span class="kobospan" id="kobo.1118.1"><img alt="Figure 5.9 – Backend CI workflow failing in a pull request" src="image/B19385_05_9.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1119.1">Figure 5.9 – Backend CI workflow failing in a pull request</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1120.1">We can also see that GitHub Actions automatically cancels the jobs running for other Node.js versions after one of them already failed, to avoid </span><span><span class="kobospan" id="kobo.1121.1">wasting time.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1122.1">Now that we have successfully set up our CI workflows, let’s continue by setting up CD to automate the deployment of our </span><span><span class="kobospan" id="kobo.1123.1">full-stack application.</span></span></p>
<h1 id="_idParaDest-112" class="calibre5"><a id="_idTextAnchor113" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1124.1">Configuring CD to automate the deployment</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1125.1">After the pull/merge </span><a id="_idIndexMarker367" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1126.1">request is merged, </span><strong class="bold"><span class="kobospan" id="kobo.1127.1">continuous delivery</span></strong><span class="kobospan" id="kobo.1128.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1129.1">CD</span></strong><span class="kobospan" id="kobo.1130.1">) comes into play. </span><span class="kobospan" id="kobo.1130.2">CD automates the release process by automatically deploying the services and applications for us. </span><span class="kobospan" id="kobo.1130.3">Usually, this involves a multi-stage process, where code is first automatically deployed to a staging environment and can then be manually deployed to other environments, up until production. </span><span class="kobospan" id="kobo.1130.4">If deployment to production is also an automated process, it is called </span><strong class="bold"><span class="kobospan" id="kobo.1131.1">continuous deployment</span></strong><span class="kobospan" id="kobo.1132.1"> instead of </span><span><span class="kobospan" id="kobo.1133.1">continuous delivery.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1134.1">First, we need to get the credentials to authenticate with Docker Hub and Google Cloud. </span><span class="kobospan" id="kobo.1134.2">Then, we can set up the workflow for deploying </span><span><span class="kobospan" id="kobo.1135.1">our blog.</span></span></p>
<h2 id="_idParaDest-113" class="calibre7"><a id="_idTextAnchor114" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1136.1">Getting Docker Hub credentials</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1137.1">Let’s start by getting the </span><a id="_idIndexMarker368" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1138.1">credentials to access </span><span><span class="kobospan" id="kobo.1139.1">Docker Hub:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1140.1">Go </span><span><span class="kobospan" id="kobo.1141.1">to </span></span><a href="https://hub.docker.com/" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.1142.1">https://hub.docker.com/</span></span></a><span><span class="kobospan" id="kobo.1143.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1144.1">Click on your profile and go to your </span><span><span class="kobospan" id="kobo.1145.1">account settings.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1146.1">Click on the </span><strong class="bold"><span class="kobospan" id="kobo.1147.1">Security</span></strong><span class="kobospan" id="kobo.1148.1"> tab and press the </span><strong class="bold"><span class="kobospan" id="kobo.1149.1">New Access </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.1150.1">Token</span></strong></span><span><span class="kobospan" id="kobo.1151.1"> button.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1152.1">As a description, write </span><strong class="source-inline1"><span class="kobospan" id="kobo.1153.1">GitHub Actions</span></strong><span class="kobospan" id="kobo.1154.1"> and press the </span><strong class="bold"><span class="kobospan" id="kobo.1155.1">Generate</span></strong><span class="kobospan" id="kobo.1156.1"> button. </span><span class="kobospan" id="kobo.1156.2">Give </span><strong class="bold"><span class="kobospan" id="kobo.1157.1">Read, Write, </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.1158.1">Delete</span></strong></span><span><span class="kobospan" id="kobo.1159.1"> permissions.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1160.1">Copy the access token and store it in a </span><span><span class="kobospan" id="kobo.1161.1">safe place.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1162.1">Go to your GitHub repository and then go to </span><strong class="bold"><span class="kobospan" id="kobo.1163.1">Settings</span></strong><span class="kobospan" id="kobo.1164.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.1165.1">Secrets and variables</span></strong><span class="kobospan" id="kobo.1166.1"> | </span><span><strong class="bold"><span class="kobospan" id="kobo.1167.1">Actions</span></strong></span><span><span class="kobospan" id="kobo.1168.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1169.1">Press the </span><strong class="bold"><span class="kobospan" id="kobo.1170.1">New repository secret</span></strong><span class="kobospan" id="kobo.1171.1"> button to add a new secret. </span><span class="kobospan" id="kobo.1171.2">As a name, write </span><strong class="source-inline1"><span class="kobospan" id="kobo.1172.1">DOCKERHUB_USERNAME</span></strong><span class="kobospan" id="kobo.1173.1">, and as a secret value, use your username on </span><span><span class="kobospan" id="kobo.1174.1">Docker Hub.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1175.1">Add another secret with the name </span><strong class="source-inline1"><span class="kobospan" id="kobo.1176.1">DOCKERHUB_TOKEN</span></strong><span class="kobospan" id="kobo.1177.1"> and paste your previously created access token as the </span><span><span class="kobospan" id="kobo.1178.1">secret value.</span></span></li>
</ol>
<h2 id="_idParaDest-114" class="calibre7"><a id="_idTextAnchor115" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1179.1">Getting Google Cloud credentials</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1180.1">Now, we are going to </span><a id="_idIndexMarker369" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1181.1">create a service account to access Google </span><span><span class="kobospan" id="kobo.1182.1">Cloud Run:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1183.1">Go </span><span><span class="kobospan" id="kobo.1184.1">to </span></span><a href="https://console.cloud.google.com/" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.1185.1">https://console.cloud.google.com/</span></span></a><span><span class="kobospan" id="kobo.1186.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1187.1">In the search box on the top, enter </span><strong class="bold"><span class="kobospan" id="kobo.1188.1">Service accounts</span></strong><span class="kobospan" id="kobo.1189.1"> and go to the </span><strong class="bold"><span class="kobospan" id="kobo.1190.1">IAM and admin – Service </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.1191.1">accounts</span></strong></span><span><span class="kobospan" id="kobo.1192.1"> page.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1193.1">Press the </span><strong class="bold"><span class="kobospan" id="kobo.1194.1">Create Service </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.1195.1">Account</span></strong></span><span><span class="kobospan" id="kobo.1196.1"> button.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1197.1">In the </span><strong class="bold"><span class="kobospan" id="kobo.1198.1">Service account name</span></strong><span class="kobospan" id="kobo.1199.1"> box, enter </span><strong class="source-inline1"><span class="kobospan" id="kobo.1200.1">GitHub Actions</span></strong><span class="kobospan" id="kobo.1201.1">. </span><span class="kobospan" id="kobo.1201.2">The ID should automatically be generated as </span><strong class="source-inline1"><span class="kobospan" id="kobo.1202.1">github-actions</span></strong><span class="kobospan" id="kobo.1203.1">. </span><span class="kobospan" id="kobo.1203.2">Press </span><strong class="bold"><span class="kobospan" id="kobo.1204.1">Create </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.1205.1">and Continue</span></strong></span><span><span class="kobospan" id="kobo.1206.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1207.1">Grant the service access to the </span><strong class="bold"><span class="kobospan" id="kobo.1208.1">Cloud Run Admin</span></strong><span class="kobospan" id="kobo.1209.1"> role and </span><span><span class="kobospan" id="kobo.1210.1">press </span></span><span><strong class="bold"><span class="kobospan" id="kobo.1211.1">Continue</span></strong></span><span><span class="kobospan" id="kobo.1212.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1213.1">Press </span><strong class="bold"><span class="kobospan" id="kobo.1214.1">Done</span></strong><span class="kobospan" id="kobo.1215.1"> to finish creating the </span><span><span class="kobospan" id="kobo.1216.1">service account.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1217.1">On the overview list, copy the email of your newly created service account and save it for </span><span><span class="kobospan" id="kobo.1218.1">later use.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1219.1">Go to the default compute service account by clicking on its email address. </span><span class="kobospan" id="kobo.1219.2">Go to the </span><strong class="bold"><span class="kobospan" id="kobo.1220.1">Permissions</span></strong><span class="kobospan" id="kobo.1221.1"> tab and press </span><span><strong class="bold"><span class="kobospan" id="kobo.1222.1">Grant Access</span></strong></span><span><span class="kobospan" id="kobo.1223.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1224.1">Paste the email of your newly created service account into the </span><strong class="bold"><span class="kobospan" id="kobo.1225.1">New principals</span></strong><span class="kobospan" id="kobo.1226.1"> field and assign the </span><strong class="bold"><span class="kobospan" id="kobo.1227.1">Cloud Run Service Agent</span></strong><span class="kobospan" id="kobo.1228.1"> role. </span><span class="kobospan" id="kobo.1228.2">Press </span><strong class="bold"><span class="kobospan" id="kobo.1229.1">Save</span></strong> <span><span class="kobospan" id="kobo.1230.1">to confirm.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1231.1">On the overview list, press the three dots icon to open actions on your </span><strong class="source-inline1"><span class="kobospan" id="kobo.1232.1">github-actions</span></strong><span class="kobospan" id="kobo.1233.1"> service account and select </span><span><strong class="bold"><span class="kobospan" id="kobo.1234.1">Manage keys</span></strong></span><span><span class="kobospan" id="kobo.1235.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1236.1">On the new page, press </span><strong class="bold"><span class="kobospan" id="kobo.1237.1">Add Key</span></strong><span class="kobospan" id="kobo.1238.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.1239.1">Create New Key</span></strong><span class="kobospan" id="kobo.1240.1">, and press </span><strong class="bold"><span class="kobospan" id="kobo.1241.1">Create</span></strong><span class="kobospan" id="kobo.1242.1"> in the popup. </span><span class="kobospan" id="kobo.1242.2">A JSON file should </span><span><span class="kobospan" id="kobo.1243.1">be downloaded.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1244.1">Go to your GitHub repository, and go to </span><strong class="bold"><span class="kobospan" id="kobo.1245.1">Settings</span></strong><span class="kobospan" id="kobo.1246.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.1247.1">Secrets and variables</span></strong><span class="kobospan" id="kobo.1248.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.1249.1">Actions</span></strong><span class="kobospan" id="kobo.1250.1">. </span><span class="kobospan" id="kobo.1250.2">Press the </span><strong class="bold"><span class="kobospan" id="kobo.1251.1">New repository secret</span></strong><span class="kobospan" id="kobo.1252.1"> button to add a </span><span><span class="kobospan" id="kobo.1253.1">new secret.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1254.1">Add a new secret on your GitHub repository called </span><strong class="source-inline1"><span class="kobospan" id="kobo.1255.1">GOOGLECLOUD_SERVICE_ACCOUNT</span></strong><span class="kobospan" id="kobo.1256.1"> and paste the previously copied email of your newly created service account as a </span><span><span class="kobospan" id="kobo.1257.1">secret value.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1258.1">Add a new </span><a id="_idIndexMarker370" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1259.1">secret on your GitHub repository called </span><strong class="source-inline1"><span class="kobospan" id="kobo.1260.1">GOOGLECLOUD_CREDENTIALS</span></strong><span class="kobospan" id="kobo.1261.1"> and as the secret, paste in the contents of the downloaded </span><span><span class="kobospan" id="kobo.1262.1">JSON file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1263.1">Add a new secret on your GitHub repository called </span><strong class="source-inline1"><span class="kobospan" id="kobo.1264.1">GOOGLECLOUD_REGION</span></strong><span class="kobospan" id="kobo.1265.1"> and set the secret value to the region you selected when creating the Cloud </span><span><span class="kobospan" id="kobo.1266.1">Run services.</span></span></li>
</ol>
<p class="callout-heading"><span class="kobospan" id="kobo.1267.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1268.1">For better security, Google recommends</span><a id="_idIndexMarker371" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1269.1"> using </span><strong class="bold"><span class="kobospan" id="kobo.1270.1">workload identity federation</span></strong><span class="kobospan" id="kobo.1271.1"> instead of exporting service account key JSON credentials. </span><span class="kobospan" id="kobo.1271.2">However, setting up workload identity federation is a bit more complicated. </span><span class="kobospan" id="kobo.1271.3">More information on how to set it up can be found </span><span><span class="kobospan" id="kobo.1272.1">here: </span></span><a href="https://github.com/google-github-actions/auth#setup" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.1273.1">https://github.com/google-github-actions/auth#setup</span></span></a><span><span class="kobospan" id="kobo.1274.1">.</span></span></p>
<h2 id="_idParaDest-115" class="calibre7"><a id="_idTextAnchor116" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1275.1">Defining the deployment workflow</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1276.1">Now that the credentials are </span><a id="_idIndexMarker372" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1277.1">available as secret values to our CI/CD workflows, we can get started defining the </span><span><span class="kobospan" id="kobo.1278.1">deployment workflow:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1279.1">Inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1280.1">.github/workflows/</span></strong><span class="kobospan" id="kobo.1281.1"> folder, create a new file </span><span><span class="kobospan" id="kobo.1282.1">called </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1283.1">cd.yaml</span></strong></span><span><span class="kobospan" id="kobo.1284.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1285.1">Open the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1286.1">.github/workflows/cd.yaml</span></strong><span class="kobospan" id="kobo.1287.1"> file and start by giving it </span><span><span class="kobospan" id="kobo.1288.1">a name:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1289.1">
name: Deploy Blog Application</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1290.1">For CD, we only execute the workflow when pushing to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1291.1">main</span></strong></span><span><span class="kobospan" id="kobo.1292.1"> branch:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1293.1">
on:
  push:
    branches:
      - main</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1294.1">We start defining a </span><strong class="source-inline1"><span class="kobospan" id="kobo.1295.1">deploy</span></strong><span class="kobospan" id="kobo.1296.1"> job, in which we set </span><strong class="source-inline1"><span class="kobospan" id="kobo.1297.1">environment</span></strong><span class="kobospan" id="kobo.1298.1"> to </span><strong class="source-inline1"><span class="kobospan" id="kobo.1299.1">production</span></strong><span class="kobospan" id="kobo.1300.1"> and point the URL to the deployed </span><span><span class="kobospan" id="kobo.1301.1">frontend URL:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1302.1">
jobs:
  deploy:
    runs-on: ubuntu-latest
    environment:
      name: production
      url: ${{ steps.deploy-frontend.outputs.url }}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1303.1">We will define a step with the </span><strong class="source-inline"><span class="kobospan" id="kobo.1304.1">deploy-frontend</span></strong><span class="kobospan" id="kobo.1305.1"> ID later, which stores a variable </span><span><span class="kobospan" id="kobo.1306.1">in </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1307.1">steps.deploy-frontend.outputs.url</span></strong></span><span><span class="kobospan" id="kobo.1308.1">.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.1309.1">For the steps, as we did before, we first need to check out </span><span><span class="kobospan" id="kobo.1310.1">our repository:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1311.1">
    steps:
      - uses: actions/checkout@v3</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1312.1">Then, we log in to</span><a id="_idIndexMarker373" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1313.1"> Docker Hub using the credentials we set earlier in </span><span><span class="kobospan" id="kobo.1314.1">our secrets:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1315.1">
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1316.1">Next, we log in to Google Cloud using the credentials we </span><span><span class="kobospan" id="kobo.1317.1">set earlier:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1318.1">
      - uses: google-github-actions/auth@v1
        with:
          service_account: ${{ secrets.GOOGLECLOUD_SERVICE_ACCOUNT }}
          credentials_json: ${{ secrets.GOOGLECLOUD_CREDENTIALS }}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1319.1">Now, we build and push the backend Docker image using </span><strong class="source-inline1"><span class="kobospan" id="kobo.1320.1">docker/build-push-action</span></strong><span class="kobospan" id="kobo.1321.1">, which builds and pushes an image to a </span><span><span class="kobospan" id="kobo.1322.1">Docker registry:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1323.1">
      - name: Build and push backend image
        uses: docker/build-push-action@v4
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/blog-backend:latest</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1324.1">After pushing</span><a id="_idIndexMarker374" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1325.1"> the Docker image for the backend, we can now deploy it on Cloud Run, using the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1326.1">google-github-actions/deploy-cloudrun</span></strong></span><span><span class="kobospan" id="kobo.1327.1"> action:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1328.1">
      - id: deploy-backend
        name: Deploy backend
        uses: google-github-actions/deploy-cloudrun@v1
        with:
          service: blog-backend
          image: ${{ secrets.DOCKERHUB_USERNAME }}/blog-backend:latest
          region: ${{ secrets.GOOGLECLOUD_REGION }}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1329.1">We gave this step the </span><strong class="source-inline"><span class="kobospan" id="kobo.1330.1">deploy-backend</span></strong><span class="kobospan" id="kobo.1331.1"> ID, as we need to use it to reference the backend URL to build the frontend image in the </span><span><span class="kobospan" id="kobo.1332.1">next step.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.1333.1">After building and deploying the backend, we build the frontend in a similar way, making sure to pass </span><strong class="source-inline1"><span class="kobospan" id="kobo.1334.1">VITE_BACKEND_URL</span></strong> <span><span class="kobospan" id="kobo.1335.1">as </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1336.1">build-args</span></strong></span><span><span class="kobospan" id="kobo.1337.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1338.1">
      - name: Build and push frontend image
        uses: docker/build-push-action@v4
        with:
          context: .
</span><span class="kobospan1" id="kobo.1338.2">          file: ./Dockerfile
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/blog-frontend:latest
          build-args: VITE_BACKEND_URL=${{ steps.deploy-backend.outputs.url }}/api/v1</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1339.1">Finally, we can deploy the frontend, giving this step the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1340.1">deploy-frontend</span></strong><span class="kobospan" id="kobo.1341.1"> ID, such that our environment URL can be </span><span><span class="kobospan" id="kobo.1342.1">set properly:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1343.1">
      - id: deploy-frontend
        name: Deploy frontend
        uses: google-github-actions/deploy-cloudrun@v1
        with:
          service: blog-frontend
          image: ${{ secrets.DOCKERHUB_USERNAME }}/blog-frontend:latest
          region: ${{ secrets.GOOGLECLOUD_REGION }}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1344.1">Save the</span><a id="_idIndexMarker375" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1345.1"> file and commit and push your changes to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1346.1">main</span></strong><span class="kobospan" id="kobo.1347.1"> branch. </span><span class="kobospan" id="kobo.1347.2">You will see </span><strong class="bold"><span class="kobospan" id="kobo.1348.1">Deploy Blog Application</span></strong><span class="kobospan" id="kobo.1349.1"> being triggered on </span><span><span class="kobospan" id="kobo.1350.1">GitHub Actions.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.1351.1">The following screenshot shows the result of our blog application being successfully deployed via </span><span><span class="kobospan" id="kobo.1352.1">GitHub Actions:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer062">
<span class="kobospan" id="kobo.1353.1"><img alt="Figure 5.10 – A successful deployment of our full-stack application using GitHub Actions" src="image/B19385_05_10.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1354.1">Figure 5.10 – A successful deployment of our full-stack application using GitHub Actions</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1355.1">You can click on the URL to open the deployed frontend and will see that it works the same way as the manually </span><span><span class="kobospan" id="kobo.1356.1">deployed version.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1357.1">Congratulations! </span><span class="kobospan" id="kobo.1357.2">You have successfully automated the integration and deployment of your first </span><span><span class="kobospan" id="kobo.1358.1">full-stack application!</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.1359.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1360.1">In this book, we only created a single-stage deployment, deploying automatically directly to production. </span><span class="kobospan" id="kobo.1360.2">In a real-world application, you may want to define multiple stages. </span><span class="kobospan" id="kobo.1360.3">For example, CD could automatically deploy to a staging environment. </span><span class="kobospan" id="kobo.1360.4">Deploying to production could then be configured to require </span><span><span class="kobospan" id="kobo.1361.1">manual confirmation.</span></span></p>
<h1 id="_idParaDest-116" class="calibre5"><a id="_idTextAnchor117" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1362.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1363.1">In this chapter, we started by learning how to create Docker images and how to instantiate local containers from them. </span><span class="kobospan" id="kobo.1363.2">Then, we automated this process by using Docker Compose. </span><span class="kobospan" id="kobo.1363.3">Next, we published our images on the Docker Hub registry to be able to deploy them on Google Cloud Run. </span><span class="kobospan" id="kobo.1363.4">We then manually deployed our full-stack application on Cloud Run. </span><span class="kobospan" id="kobo.1363.5">Finally, we learned how to set up CI/CD workflows with GitHub Actions to automate the running of the linter, tests, and deploying the </span><span><span class="kobospan" id="kobo.1364.1">blog application.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1365.1">Up until now, everything in our application has been publicly accessible. </span><span class="kobospan" id="kobo.1365.2">With no user management, anyone can just create posts as any author. </span><span class="kobospan" id="kobo.1365.3">In the next chapter, </span><a href="B19385_06.xhtml#_idTextAnchor119" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.1366.1">Chapter 6</span></em></span></a><span class="kobospan" id="kobo.1367.1">, </span><em class="italic"><span class="kobospan" id="kobo.1368.1">Adding Authentication with JWT</span></em><span class="kobospan" id="kobo.1369.1">, we are going to learn how to implement user accounts and authentication in our full-stack blog application. </span><span class="kobospan" id="kobo.1369.2">We are going to learn what </span><strong class="bold"><span class="kobospan" id="kobo.1370.1">JSON Web Tokens</span></strong><span class="kobospan" id="kobo.1371.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1372.1">JWTs</span></strong><span class="kobospan" id="kobo.1373.1">) are and implement multiple routes for logging in and </span><span><span class="kobospan" id="kobo.1374.1">signing up.</span></span></p>
</div>
</body></html>