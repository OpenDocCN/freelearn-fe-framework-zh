<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer047">
			<h1 id="_idParaDest-82" class="chapter-number"><a id="_idTextAnchor080"/>4</h1>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor081"/>Building a Weather Dashboard – Data Fetching and State Management</h1>
			<p>As we venture into <a href="B19760_04.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic">Chapter 4</em></span></a> of our Nuxt 3 exploration, we’re setting our sights on constructing a <a id="_idIndexMarker173"/>practical weather dashboard. Our journey starts with <strong class="bold">Nuxt UI</strong>, Nuxt’s official UI library, which simplifies the creation of stunning and responsive web applications. Nuxt UI offers a comprehensive collection of fully styled and customizable UI components, specifically designed for Nuxt. We’ll explore how to import Nuxt UI into our project and use <span class="No-Break">its components.</span></p>
			<p>Next, we’ll discuss data fetching in general. This will lay the groundwork for understanding how to retrieve and handle data dynamically in a Nuxt application. Specifically, we’ll <a id="_idIndexMarker174"/>use the <strong class="bold">OpenWeatherMap</strong> API in our project, providing a real-world context for our data <span class="No-Break">fetching practices.</span></p>
			<p>Following this, we’ll master <strong class="source-inline">$fetch</strong> for efficient data fetching. By fetching real weather data from the OpenWeatherMap API, you’ll learn how to display this information effectively <span class="No-Break">and responsively.</span></p>
			<p>Finally, we will guide you <a id="_idIndexMarker175"/>through state management using <strong class="bold">Pinia</strong>. This approach centralizes and manages the state of your application’s data, facilitating easy access and manipulation of weather data across different components without the complexities of <span class="No-Break">prop drilling.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Setting up the weather <span class="No-Break">dashboard application.</span></li>
				<li>Integrating Nuxt UI in the <span class="No-Break">weather dashboard</span></li>
				<li>Exploring data fetching with <strong class="source-inline">$fetch</strong> in <span class="No-Break">Nuxt 3</span></li>
				<li>Integrating with the Pinia store to monitor city and <span class="No-Break">weather data</span></li>
			</ul>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor082"/>Technical requirements</h1>
			<p>The code files for this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter04"><span class="No-Break">https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter04</span></a><span class="No-Break">.</span></p>
			<p>The CiA video for this chapter can be found <span class="No-Break">on </span><a href="https://packt.link/1uNS1"><span class="No-Break">https://packt.link/1uNS1</span></a></p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor083"/>Essential background – understanding Nuxt 3 Data Fetching and State Management</h1>
			<p>Before diving into the practical application, let’s build a solid foundation in two key areas – data fetching with Nuxt UI and state management <span class="No-Break">using Pinia:</span></p>
			<ul>
				<li><strong class="bold">Data fetching</strong>: It’s crucial to understand the concept of data fetching in web applications. Data <a id="_idIndexMarker176"/>fetching refers to the process of retrieving data from an external source, such as an API, and displaying it in your application. Nuxt 3 offers enhanced data fetching capabilities, making it easier and more efficient. You’ll learn about built-in methods and tools in Nuxt 3, such as <strong class="source-inline">$fetch</strong>, which simplifies the process of fetching and <span class="No-Break">displaying data.</span></li>
				<li><strong class="bold">State management with Pinia</strong>: Pinia is a state management library designed for Vue <a id="_idIndexMarker177"/>applications, offering a more intuitive and straightforward approach than its predecessor, Vuex. With Pinia, you can centralize and manage the application’s state, facilitating data sharing across components without prop drilling. Pinia also offers API-style composition. More details can be found on <a id="_idIndexMarker178"/>Pinia’s official websi<a href="https://pinia.vuejs.org/">te <span class="No-Break">at </span><span class="No-Break">https://pinia.vuej</span></a><span class="No-Break">s.org/</span><span class="No-Break">.</span></li>
			</ul>
			<p>Now that we’ve covered those two areas, let’s start by setting up our weather <span class="No-Break">dashboard application.</span></p>
			<p>First, let’s kick off by creating our new project <span class="No-Break">named weather-sky:</span></p>
			<pre class="console">
pnpm dlx nuxi@latest init weather-sky</pre>			<p>After initializing, navigate to the <span class="No-Break">project directory:</span></p>
			<pre class="console">
cd weather-sky
code .</pre>			<p>Next, we will incorporate <strong class="source-inline">@nuxtjs/google-fonts</strong> for our font needs. However, diverging from our usual path of adding Tailwind CSS, we’ll introduce Nuxt UI to <span class="No-Break">our toolkit.</span></p>
			<p>Let’s install <span class="No-Break">these packages:</span></p>
			<pre class="console">
pnpm i @nuxtjs/google-fonts
pnpm i @nuxt/ui</pre>			<p>Once installed, open <strong class="source-inline">nuxt.config.ts</strong> and add both <strong class="source-inline">@nuxtjs/google-fonts</strong> and <strong class="source-inline">@nuxt/ui</strong> to the <strong class="source-inline">modules</strong> array, integrating them into our <span class="No-Break">project setup.</span></p>
			<p>Before implementing Nuxt UI theming, we’ll create a <strong class="source-inline">tailwind.config.ts</strong> file and include our <a id="_idIndexMarker179"/>standard configurations. However, this time, we won’t define the colors in the Tailwind configuration. Instead, we’ll leverage Nuxt UI theming capabilities <a id="_idIndexMarker180"/>to set this color. We’ll learn how to do that in the <span class="No-Break">next section.</span></p>
			<p>Here’s how the <strong class="source-inline">tailwind.config.ts</strong> might look without adding the <span class="No-Break">colors option:</span></p>
			<pre class="source-code">
import type { Config } from 'tailwindcss'
export default &lt;Partial&lt;Config&gt;&gt;{
  theme: {
    extend: {
      fontFamily: {
        sans: ['Roboto', 'sans-serif']
      },
      container: {
        center: true,
        padding: {
          DEFAULT: '1.5rem',
          lg: '4rem',
          xl: '4rem',
          '2xl': '4rem'
        },
        screens: {
          sm: '576px',
          md: '768px',
          lg: '992px',
          xl: '1200px',
          '2xl': '1400px'
        }
      }
    }
  }
}</pre>			<p>Finally, let’s integrate <a id="_idIndexMarker181"/>the Roboto font into our project. We do this by updating <a id="_idIndexMarker182"/>the <strong class="source-inline">nuxt.config.ts</strong> file, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
export default defineNuxtConfig({
  modules: ['@nuxt/ui', '@nuxtjs/google-fonts'],
  googleFonts: {
    families: {
      Roboto: [100, 300, 400, 700, 900]
    }
  },
})</pre>			<p>Now, let’s <a id="_idIndexMarker183"/>add a title in <strong class="source-inline">app.vue</strong> and see how <span class="No-Break">it looks:</span></p>
			<pre class="source-code">
&lt;template&gt;
  &lt;div class="bg-slate-100 dark:bg-slate-800 min-h-screen
             py-4"&gt;
    &lt;div class="text-3xl text-center"&gt;Weather Sky&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;</pre>			<p>The output <a id="_idIndexMarker184"/>should be similar <span class="No-Break">to this:</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B19760_04_01.jpg" alt="Figure 4.1: Weather Sky initial page" width="1211" height="476"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1: Weather Sky initial page</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Nuxt UI uses <a id="_idIndexMarker185"/>the system’s default color scheme. As a result, you might notice that the color of your app appears dark instead of light if you do not specify a custom color. This behavior ensures that your app automatically aligns with the user’s <span class="No-Break">preferred theme.</span></p>
			<p>To verify the <a id="_idIndexMarker186"/>font, a handy Chrome extension called <strong class="bold">WhatFont</strong> can be used. WhatFont is an <a id="_idIndexMarker187"/>efficient tool for quickly identifying the fonts used on web pages. It’s a great aid for designers and developers to confirm font choices <span class="No-Break">and styles.</span></p>
			<p>When using <a id="_idIndexMarker188"/>WhatFont on our website, if you click on the extension icon and select the title, it will display the font details. In our case, it should confirm the use of <strong class="bold">Roboto</strong> with a weight <span class="No-Break">of </span><span class="No-Break"><strong class="bold">400</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B19760_04_02.jpg" alt="Figure 4.2: The WhatFont extension" width="749" height="398"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2: The WhatFont extension</p>
			<p>Now that we’ve set up our project, our next step is to integrate with Nuxt UI and make use of its features <span class="No-Break">and components.</span></p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor084"/>Integrating Nuxt UI in the weather dashboard</h1>
			<p>Nuxt UI is an official UI library from Nuxt, designed to enhance the user interface experience <a id="_idIndexMarker189"/>in Nuxt applications. It offers a range of features, including fully styled and customizable components, support for dark mode, keyboard shortcuts, and support for both left-to-right and right-to-left languages. Built with Headless UI and Tailwind CSS, Nuxt UI provides a robust framework for creating intuitive and visually appealing user interfaces in Nuxt apps. You can read more <a id="_idIndexMarker190"/>about it on the official <span class="No-Break">website: </span><a href="https://ui.nuxt.com/"><span class="No-Break">https://ui.nuxt.com/</span></a><span class="No-Break">.</span></p>
			<p>Now, let’s go back to our project and start learning about Nuxt UI theming. We’ll utilize <strong class="source-inline">app.config.ts</strong> to define the primary color, integrating our design preferences within the Nuxt ecosystem. Here’s how we set <span class="No-Break">it up:</span></p>
			<pre class="source-code">
export default defineAppConfig({
  ui: {
    primary: 'sky'
  }
})</pre>			<p>The <strong class="source-inline">app.config.ts</strong> file is a <a id="_idIndexMarker191"/>central UI configuration file, offering dynamic theming capabilities. This flexibility enables us to tailor our application’s theme and component styles on the fly. By setting theme colors and integrating with Tailwind CSS, we gain access to a broader color palette, enhancing our design options. Moreover, the <strong class="source-inline">ui</strong> property provides specific component customizations, allowing for a personalized and coherent user interface. As we progress, we will explore, in detail, how to use this file to customize our <span class="No-Break">components’ design.</span></p>
			<p>Let’s put our Nuxt UI integration to the test and start using some of its components in our <strong class="source-inline">app.vue</strong> file. The following code snippet shows how to create a basic layout with a <span class="No-Break">weather card:</span></p>
			<pre class="source-code">
&lt;template&gt;
  &lt;div class="bg-slate-100 min-h-screen"&gt;
    &lt;u-container&gt;
      &lt;u-card&gt; weather sky &lt;/u-card&gt;
    &lt;/u-container&gt;
  &lt;/div&gt;
&lt;/template&gt;</pre>			<p>In this template, we use the <strong class="source-inline">&lt;u-container&gt;</strong> component from Nuxt UI, which provides a containerized space for our content. The <strong class="source-inline">&lt;u-card&gt;</strong> component within it is where we display our <span class="No-Break">weather data.</span></p>
			<p>Here’s the <a id="_idIndexMarker192"/>output of our updated Nuxt UI integration in the <span class="No-Break"><strong class="source-inline">app.vue</strong></span><span class="No-Break"> file:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B19760_04_03.jpg" alt="Figure 4.3: Nuxt UI integration" width="1211" height="292"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3: Nuxt UI integration</p>
			<p>Now, let’s consider enhancing our layout further. Suppose we want to add vertical spacing to the container. Typically, we could do this by adding the <strong class="source-inline">py-6</strong> class directly in our template. But what if we aim for a more streamlined approach, where this spacing becomes a default style for all containers in our application? This is where the power of component customization in Nuxt UI <span class="No-Break">truly shines.</span></p>
			<p>Nuxt UI allows us to override and customize component styles globally via the <strong class="source-inline">app.config.ts</strong> file. By doing this, we ensure consistent styling across our application without repeatedly adding the same class in different components. Here’s how we can achieve this for our <span class="No-Break"><strong class="source-inline">container</strong></span><span class="No-Break"> component:</span></p>
			<pre class="source-code">
export default defineAppConfig({
  ui: {
    primary: 'sky',
    container: {
      padding: 'py-6'
    }
  }
})</pre>			<p>In this <a id="_idIndexMarker193"/>configuration, we’ve added a padding <strong class="source-inline">property</strong> to the <strong class="source-inline">container</strong> configuration within the <strong class="source-inline">ui</strong> property, based on the configuration options available for the <strong class="source-inline">u-container</strong> component, which we can find detailed <span class="No-Break">here: </span><span class="No-Break">https://ui.nuxt.com/layout/container#config</span><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">After modifying the configuration, it may be necessary to restart your development server to apply and view the changes in <span class="No-Break">your application.</span></p>
			<p>Now, every time we use the <strong class="source-inline">&lt;u-container&gt;</strong> component in our application, it will automatically include this vertical padding, creating a consistent look and feel throughout <span class="No-Break">the app.</span></p>
			<p>Let’s now customize the <strong class="source-inline">u-card</strong> component and remove the shadow. This is done via the <span class="No-Break"><strong class="source-inline">app.config.ts</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
export default defineAppConfig({
  ui: {
    // ...other configurations...
    card: {
      base: 'overflow-visible mb-6',
      shadow: 'shadow-none'
    }
  }
})</pre>			<p>In this configuration, we’re setting the <strong class="source-inline">base</strong> property to <strong class="source-inline">'overflow-visible mb-6'</strong>. This adjusts the default layout of the card, allowing for visible overflow and adding a margin at the bottom. Additionally, we’re applying <strong class="source-inline">'shadow-none'</strong> to the <strong class="source-inline">shadow</strong> property, effectively removing the default shadow from <span class="No-Break">all cards.</span></p>
			<p>Next, we’ll <a id="_idIndexMarker194"/>explore data fetching with <strong class="source-inline">$fetch</strong> in Nuxt 3, diving into how to efficiently fetch and manage data in <span class="No-Break">our applications.</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor085"/>Exploring data fetching with $fetch in Nuxt 3</h1>
			<p>In Nuxt 3, data fetching is a pivotal aspect that is managed using composables that work in both <a id="_idIndexMarker195"/>browser and server environments. Nuxt <a id="_idIndexMarker196"/>offers three primary <a id="_idIndexMarker197"/>tools for <span class="No-Break">this purpose:</span></p>
			<ul>
				<li><strong class="source-inline">useFetch</strong>: This is the most straightforward method for data fetching within a component’s <a id="_idIndexMarker198"/>setup function, typically used for retrieving essential data for the component’s initial state. But in our project, we’ll work with more complex methods: <strong class="source-inline">useAsyncData</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">$fetch</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">useAsyncData</strong>: This <a id="_idIndexMarker199"/>is like <strong class="source-inline">useFetch</strong> but includes additional logic for more complex data <span class="No-Break">fetching scenarios.</span></li>
				<li><strong class="source-inline">$fetch</strong>: This <a id="_idIndexMarker200"/>is a part of the <strong class="source-inline">ofetch</strong> library and is a versatile fetch API that works across Node.js, browsers, and workers. It features smart JSON parsing, automatic stringification for JSON bodies, user-friendly error handling, auto retry capabilities, and configurable timeouts. This makes <strong class="source-inline">$fetch</strong> a robust tool for efficient, reliable network requests in various environments. You can read more about it <span class="No-Break">at </span><span class="No-Break">https://github.com/unjs/ofetch</span><span class="No-Break">.</span></li>
			</ul>
			<p>Now, let’s progress with the next steps in our Nuxt <span class="No-Break">3 project.</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor086"/>Creating an account on OpenWeatherMap</h2>
			<p><strong class="bold">OpenWeatherMap</strong> offers a <a id="_idIndexMarker201"/>comprehensive suite of weather APIs, providing real-time data for our <span class="No-Break">weather dashboard.</span></p>
			<p>Before we <a id="_idIndexMarker202"/>can fetch weather data, it’s essential to have access to OpenWeatherMap’s APIs. Begin by creating an account on OpenWeatherMap. Go to their sign-up page: <a href="https://openweathermap.org/register">https://openweathermap.org/register</a>, provide <a id="_idIndexMarker203"/>the required details, and create your account. Once your account is set up, go to the dropdown menu under your username and navigate to the <strong class="bold">My API keys</strong> page, then generate a new key. Remember to copy this key, as it will be crucial for accessing <span class="No-Break">the APIs.</span></p>
			<p>We’ll focus on two APIs <span class="No-Break">from OpenWeatherMap:</span></p>
			<ul>
				<li><strong class="bold">Geocoding API</strong>: This <a id="_idIndexMarker204"/>API enables location searches, allowing users to find specific cities or regions. You can find the full documentation <span class="No-Break">here: </span><a href="https://openweathermap.org/api/geocoding-api"><span class="No-Break">https://openweathermap.org/api/geocoding-api</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">One Call API</strong>: This <a id="_idIndexMarker205"/>provides detailed weather information for the searched location, offering current weather information, data forecasts, and more. For more info, <span class="No-Break">visit </span><a href="https://openweathermap.org/api/one-call-3"><span class="No-Break">https://openweathermap.org/api/one-call-3</span></a><span class="No-Break">.</span></li>
			</ul>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor087"/>Testing the API</h2>
			<p>To utilize <a id="_idIndexMarker206"/>the Geocoding API from OpenWeatherMap, we’ll implement <a id="_idIndexMarker207"/>a test scenario using <strong class="source-inline">$fetch</strong> in our <span class="No-Break">Nuxt application.</span></p>
			<p>In <strong class="source-inline">app.vue</strong>, create a script, then define a function that will use <strong class="source-inline">$fetch</strong> to call the <span class="No-Break">Geocoding API:</span></p>
			<pre class="source-code">
&lt;script setup lang="ts"&gt;
async function citiesLookup(query : string) {
  const apiKey = 'YOUR_API_KEY'; // Replace with your
                                    actual API key
  const response = await $fetch(
    `http://api.openweathermap.org/geo/1.0/direct?q=
    ${query}&amp;limit=5&amp;appid=${apiKey}`
  );
  return response;
}
&lt;/script&gt;</pre>			<p>Here is <a id="_idIndexMarker208"/>the breakdown of <span class="No-Break">the function:</span></p>
			<ul>
				<li>This function <a id="_idIndexMarker209"/>performs a lookup for cities using the OpenWeatherMap <span class="No-Break">Geocoding API</span></li>
				<li>The <strong class="source-inline">query</strong> parameter is used to search for the name of the city or a part <span class="No-Break">of it</span></li>
				<li>The <strong class="source-inline">limit=5</strong> parameter in the URL limits the number of results <span class="No-Break">to five</span></li>
			</ul>
			<p>Don’t forget to replace <strong class="source-inline">apiKey</strong> with your <span class="No-Break">actual key.</span></p>
			<p>Then, invoke this function with a sample location query to test <span class="No-Break">the API:</span></p>
			<pre class="source-code">
const data = await citiesLookup('London');
console.log(data); // Outputs the response from the
                      Geocoding API</pre>			<p>You should see a similar output to this: </p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B19760_04_04.jpg" alt="Figure 4.4: Geocoding API response" width="1062" height="599"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4: Geocoding API response</p>
			<p>With the <a id="_idIndexMarker210"/>successful testing of the API, let’s define types for the responses <a id="_idIndexMarker211"/><span class="No-Break">from OpenWeatherMap.</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor088"/>Defining global types</h2>
			<p>Having previously discussed TypeScript types, we will now focus on defining them for the responses <a id="_idIndexMarker212"/>from OpenWeatherMap APIs. Anticipating the structure of the data we’ll receive from the API is crucial for <span class="No-Break">type-safe development.</span></p>
			<p>Inspecting the <a id="_idIndexMarker213"/>console output reveals that the <strong class="source-inline">city</strong> object contains specific fields. To handle this data effectively, we create an <strong class="source-inline">index.ts</strong> file in a <strong class="source-inline">types</strong> folder with the <span class="No-Break">following type:</span></p>
			<pre class="source-code">
export {}
declare global {
  type CityData = {
    name: string
    lat: number
    lon: number
    country: string
    state: string
  }
}</pre>			<p>As we learned <a id="_idIndexMarker214"/>in the previous chapter, by exporting <a id="_idIndexMarker215"/>an empty object and declaring a global object that contains the <strong class="source-inline">CityData</strong> type, we’ve made these types globally available in <span class="No-Break">our application.</span></p>
			<p>Now, let’s enhance our application’s configuration strategy and find a way to save our <span class="No-Break">API key.</span></p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor089"/>Utilizing useRuntimeConfig to expose configuration within the application</h2>
			<p><strong class="source-inline">useRuntimeConfig</strong> is a composable in Nuxt 3 designed for accessing runtime configurations. This feature enables the global and centralized management of configuration <a id="_idIndexMarker216"/>values, such as API keys, across <span class="No-Break">your application.</span></p>
			<p>Runtime configurations are stored in <strong class="source-inline">nuxt.config.ts</strong> using the <strong class="source-inline">runtimeConfig</strong> attribute. You can define a secret key, which will be accessible only on the server, or public keys. In our case, we’ll define the API key as a public key to be accessible on the client <span class="No-Break">side, too.</span></p>
			<p>Update <strong class="source-inline">nuxt.config.ts</strong> by adding <span class="No-Break">the following:</span></p>
			<pre class="source-code">
export default defineNuxtConfig({
  // …other configs
  runtimeConfig: {
    public: {
      weatherApiKey: "ENTER_YOUR_KEY_HERE"
    }
  },
})</pre>			<p>Then, we’ll <a id="_idIndexMarker217"/>update the <strong class="source-inline">citiesLookup</strong> method to retrieve the API key <span class="No-Break">via </span><span class="No-Break"><strong class="source-inline">useRuntimeConfig</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
async function citiesLookup(query) {
  const config = useRuntimeConfig()
  const apiKey = config.public.weatherApiKey
  const response = await $fetch(
    `http://api.openweathermap.org/geo/1.0/direct?q=
    ${query}&amp;limit=5&amp;appid=${apiKey}`
  );
  return response;
}</pre>			<p>After updating, we’ll retest to ensure that the function remains effective with the new configuration setup. It should yield the same result. If you encounter a <strong class="source-inline">401</strong> error, it indicates an incorrect or invalid API key. In this case, debug the runtime configuration to verify that the key is <span class="No-Break">displayed correctly.</span></p>
			<p>Next, we’ll enhance our dashboard with a dynamic city search feature using Nuxt UI’s <span class="No-Break"><strong class="source-inline">SelectMenu</strong></span><span class="No-Break"> component.</span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor090"/>Creating the CitiesLookup component</h2>
			<p>We’ll build the <strong class="source-inline">CitiesLookup</strong> component, a key feature of our weather dashboard. Utilizing Nuxt UI’s <strong class="source-inline">SelectMenu</strong> component will enable users to dynamically search for cities. The <a id="_idIndexMarker218"/>integration of asynchronous search capabilities will create a seamless and intuitive user experience. First, let’s <a id="_idIndexMarker219"/>create the <strong class="source-inline">CitiesLookup</strong> component inside the <strong class="source-inline">components</strong> folder. Then, add the <span class="No-Break">following template:</span></p>
			<pre class="source-code">
&lt;template&gt;
  &lt;USelectMenu
    v-model="activeCity"
    :searchable="citiesLookup"
    placeholder="Search for a city..."
  /&gt;
&lt;/template&gt;</pre>			<p>This part sets up the UI for city searching. <strong class="source-inline">USelectMenu</strong> is bound to <strong class="source-inline">activeCity </strong>for capturing the user’s selection. The <strong class="source-inline">:searchable</strong> attribute is linked to the <strong class="source-inline">citiesLookup</strong> function, which we will see in the <span class="No-Break"><strong class="source-inline">script</strong></span><span class="No-Break"> section:</span></p>
			<pre class="source-code">
&lt;script setup lang="ts"&gt;
const config = useRuntimeConfig()
const apiKey = config.public.weatherApiKey
const activeCity = ref()
const citiesLookup = async (query: string) =&gt; {
  if (!query) return
  const response: Array&lt;CityData&gt; = await $fetch(
    `http://api.openweathermap.org/geo/1.0/direct?q=
    ${query}&amp;limit=5&amp;appid=${apiKey}`
  )
  return response.map(city =&gt; ({
    ...city,
    label: `${city.name}, ${city.country}`
  }))
}
&lt;/script&gt;</pre>			<p>Here’s <a id="_idIndexMarker220"/><span class="No-Break">the breakdown:</span></p>
			<ul>
				<li>We started <a id="_idIndexMarker221"/>by employing <strong class="source-inline">useRuntimeConfig</strong> to access the <span class="No-Break">API key.</span></li>
				<li>We also defined <strong class="source-inline">activeCity</strong> to store and react to the user’s selection from the <span class="No-Break">drop-down menu.</span></li>
				<li>The <strong class="source-inline">citiesLookup</strong> function, which we initially tested in the previous section, is now adapted to fetch city data and format it for the <strong class="source-inline">USelectMenu</strong> component. First, we skip the fetch if the query is empty. The response from the Geocoding API is mapped to include a label for each city, combining the city name and country. This labeling is crucial for the <strong class="source-inline">USelectMenu</strong> component to display the <span class="No-Break">options correctly.</span></li>
				<li>The <strong class="source-inline">:searchable</strong> prop on <strong class="source-inline">USelectMenu</strong> takes our <strong class="source-inline">citiesLookup</strong> function. This setup creates a dynamic, asynchronous search feature where the drop-down menu options update in real time based on the <span class="No-Break">user’s input.</span></li>
				<li>The <strong class="source-inline">CityData</strong> type is recognized directly without importing it, thanks to our global <span class="No-Break">declaration approach.</span></li>
			</ul>
			<p>Now that <a id="_idIndexMarker222"/>we have our <strong class="source-inline">CitiesLookup</strong> component <a id="_idIndexMarker223"/>ready, let’s integrate it into the main application view. Here’s how we can incorporate it <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">app.vue</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;template&gt;
  &lt;div class="bg-slate-100 min-h-screen"&gt;
    &lt;u-container&gt;
      &lt;u-card&gt;
        &lt;h1 class="text-3xl font-bold text-center
                  text-gray-700 mb-6"&gt;
          Weather Sky
        &lt;/h1&gt;
        &lt;p class="text-center text-gray-500 mb-4"&gt;
          Search for current weather data by city
        &lt;/p&gt;
        &lt;cities-lookup /&gt;
      &lt;/u-card&gt;
    &lt;/u-container&gt;
  &lt;/div&gt;
&lt;/template&gt;</pre>			<p>With the <strong class="source-inline">CitiesLookup</strong> component in place, users can now search for a city such as <strong class="source-inline">London</strong>. The following screenshot illustrates performing such <span class="No-Break">a search:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B19760_04_05.jpg" alt="Figure 4.5: CityLookup component" width="1321" height="630"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5: CityLookup component</p>
			<p>Next, we will focus on displaying the weather data for the selected city. This will involve fetching <a id="_idIndexMarker224"/>the weather data from the OpenWeatherMap API and presenting it in a user-friendly format on <span class="No-Break">our dashboard.</span></p>
			<p>To keep <a id="_idIndexMarker225"/>our application reactive, we need a mechanism to detect when a user selects a different city. This can be achieved by adding an event listener. <strong class="source-inline">@update:modelValue</strong> emits a <strong class="source-inline">change</strong> event whenever the <strong class="source-inline">activeCity</strong> value is updated. In <strong class="source-inline">CitiesLookup</strong>, update <span class="No-Break">the template:</span></p>
			<pre class="source-code">
&lt;USelectMenu
  v-model="activeCity"
  :searchable="citiesLookup"
  placeholder="Search for a city..."
  @update:modelValue="emit('change', $event)"
/&gt;</pre>			<p>This emit will dispatch the newly selected city, contained within the <strong class="source-inline">$event</strong> parameter, to the parent component. In the <strong class="source-inline">&lt;script&gt;</strong> section, we declare the event emitter <span class="No-Break">like so:</span></p>
			<pre class="source-code">
const emit = defineEmits(['change'])</pre>			<p>In <strong class="source-inline">app.vue</strong>, we’re <a id="_idIndexMarker226"/>set to catch the city <a id="_idIndexMarker227"/>selection updates. We listen for the <strong class="source-inline">change </strong>event emitted by our <span class="No-Break"><strong class="source-inline">CitiesLookup</strong></span><span class="No-Break"> component:</span></p>
			<pre class="source-code">
&lt;template&gt;
  &lt;div class="bg-slate-100 dark:bg-slate-800 min-h-screen"&gt;
    &lt;div class="container py-6"&gt;
      &lt;u-card&gt;
        &lt;h1 class="text-3xl font-bold text-center
          mb-6"&gt;Weather Sky&lt;/h1&gt;
        &lt;p class="text-center text-gray-500 mb-4"&gt;
          Search for current weather data by city
        &lt;/p&gt;
        &lt;cities-lookup @change="onCityChanged" /&gt;
      &lt;/u-card&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;</pre>			<p>Within the <strong class="source-inline">&lt;script&gt;</strong> section, we define the <strong class="source-inline">onCityChanged</strong> function, which will handle <span class="No-Break">the event:</span></p>
			<pre class="source-code">
&lt;script setup lang="ts"&gt;
const onCityChanged = async (newCity : CityData) =&gt; {
  console.log(newCity); // This will log the selected city
                           data to the console.
}
&lt;/script&gt;</pre>			<p>Selecting <strong class="bold">London</strong> from the search results now logs the city details to the console, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B19760_04_06.jpg" alt="Figure 4.6: Listening to CitiesLookup change" width="1561" height="655"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6: Listening to CitiesLookup change</p>
			<p>With this <a id="_idIndexMarker228"/>in place, we’re prepared <a id="_idIndexMarker229"/>to fetch and display the weather data using OpenWeatherMap’s One Call API for the <span class="No-Break">chosen city.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor091"/>Fetching the weather data</h2>
			<p>With the city selected, the next step is to retrieve the weather details. Using the latitude and longitude <a id="_idIndexMarker230"/>from the selected city’s data, we will call <a id="_idIndexMarker231"/>the One Call API from OpenWeatherMap. For more information, visit the One Call API documentation <span class="No-Break">link: </span><a href="https://openweathermap.org/api/one-call-3"><span class="No-Break">https://openweathermap.org/api/one-call-3</span></a><span class="No-Break">.</span></p>
			<p>Here is <strong class="source-inline">app.vue</strong> after implementing the <span class="No-Break"><strong class="source-inline">onCityChanged</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
&lt;script setup lang="ts"&gt;
const weatherData = ref()
const loading = ref(false)
const onCityChanged = async (activeCity: CityData) =&gt; {
  const config = useRuntimeConfig()
  const apiKey = config.public.weatherApiKey
  loading.value = true
  try {
    weatherData.value = await $fetch(
      `https://api.openweathermap.org/data/2.5/onecall?lat=
      ${activeCity?.lat}&amp;lon=${activeCity?.lon}&amp;appid=
      ${apiKey}&amp;units=metric`
    )
    console.log(weatherData.value);
  } catch (error) {
    console.error('Error fetching weather data:', error)
  }
  loading.value = false
}
&lt;/script&gt;</pre>			<p>Let’s <a id="_idIndexMarker232"/>break <a id="_idIndexMarker233"/>the <span class="No-Break">code down:</span></p>
			<ul>
				<li><strong class="source-inline">weatherData</strong> is a reactive <strong class="source-inline">ref</strong> that will hold the fetched <span class="No-Break">weather information</span></li>
				<li><strong class="source-inline">loading</strong> is a flag indicating whether the data fetching is <span class="No-Break">in progress</span></li>
				<li><strong class="source-inline">onCityChanged</strong> is an async function triggered when a new city <span class="No-Break">is selected</span></li>
				<li>The API request is made with the selected city’s latitude <span class="No-Break">and longitude</span></li>
				<li>On success, <strong class="source-inline">weatherData</strong> is populated with the weather response; if there’s an error, it’s logged to <span class="No-Break">the console</span></li>
				<li>We print the result to the console to <span class="No-Break">inspect it</span></li>
			</ul>
			<p>Now, in the <a id="_idIndexMarker234"/>application, by searching for <strong class="source-inline">London</strong> and selecting <a id="_idIndexMarker235"/>the first result, we observe the following output in <span class="No-Break">the console:</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B19760_04_07.jpg" alt="Figure 4.7: One Call API response" width="1210" height="840"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7: One Call API response</p>
			<p>The response will contain three types of <span class="No-Break">weather data:</span></p>
			<ul>
				<li><strong class="bold">Current weather</strong>: Immediate <a id="_idIndexMarker236"/><span class="No-Break">weather conditions</span></li>
				<li><strong class="bold">Hourly forecast</strong>: Weather <a id="_idIndexMarker237"/>predictions broken down <span class="No-Break">by hour</span></li>
				<li><strong class="bold">Daily forecast</strong>: Comprehensive <a id="_idIndexMarker238"/>weather outlook for the next <span class="No-Break">7 days</span></li>
			</ul>
			<p>You can find the full details about the response in the API documentation. After examining <a id="_idIndexMarker239"/>the One Call API response from OpenWeatherMap, I have crafted specific types to repre<a id="_idTextAnchor092"/>sent the structure of the weather <a id="_idIndexMarker240"/>data – <strong class="source-inline">WeatherDataResponse</strong>, <strong class="source-inline">HourlyWeather</strong>, <strong class="source-inline">DailyWeather</strong>, and<span lang="en-US" xml:lang="en-US"> </span><strong class="source-inline">Weather</strong> – and added them to the <strong class="source-inline">types/index.ts</strong> file. They can be found in the <span class="No-Break">project repository.</span></p>
			<p>Each type reflects the various aspects of weather data, such as current conditions, hourly forecasts, and <span class="No-Break">daily predictions.</span></p>
			<p>This data, while accessible in the parent and child components, hints at increasing complexity as our application grows. To streamline state management and data flow, we turn to Pinia. This state management library offers a centralized store for our application’s reactive state, allowing for more organized and maintainable data handling. In the following section, we’ll delve into how Pinia can enhance our application’s architecture, then we’ll create components to display the <span class="No-Break">weather data.</span></p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/>Integrating with the Pinia store to monitor city and weather data</h1>
			<p>As we’ve <a id="_idIndexMarker241"/>seen, managing data across components can get complex. To simplify this, we introduce Pinia: Vue’s state management solution that allows for a centralized and reactive state. For a deep dive into Pinia and its features, visit the official Pinia <span class="No-Break">documentation: </span><a href="https://pinia.vuejs.org/"><span class="No-Break">https://pinia.vuejs.org/</span></a><span class="No-Break">.</span></p>
			<p>Now, let’s apply our knowledge and create our first store with Pinia to manage city and weather data efficiently. This practice will improve data handling in our application, making it more efficient <span class="No-Break">and maintainable.</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Installing Pinia and creating the first store</h2>
			<p>First, install <a id="_idIndexMarker242"/>Pinia by running the <span class="No-Break">following command:</span></p>
			<pre class="console">
pnpm i @pinia/nuxt</pre>			<p>Then, update <strong class="source-inline">nuxt.config.ts</strong> and Include Pinia in the <strong class="source-inline">modules</strong> array to ensure that it’s <a id="_idIndexMarker243"/>loaded into your <span class="No-Break">Nuxt application:</span></p>
			<pre class="source-code">
// https://nuxt.com/docs/api/configuration/nuxt-config
export default defineNuxtConfig({
  // ...other config
  modules: ['@nuxt/ui', '@nuxtjs/google-fonts',
  '@pinia/nuxt'],
})</pre>			<p>Now, create a new directory in the root folder of the project, call it <strong class="source-inline">stores</strong>, and add a <strong class="source-inline">weather.ts</strong> file in which we’ll define the store. Within the file, add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import { defineStore } from 'pinia'
export const useWeatherStore = defineStore('weather', () =&gt; {
  return {  }
})</pre>			<p>Pinia offers <a id="_idIndexMarker244"/>two ways to define <span class="No-Break">a store:</span></p>
			<ul>
				<li><strong class="bold">Options stores</strong>: An object-based declaration, providing a familiar API for those used to Vue’s <span class="No-Break">Options API</span></li>
				<li><strong class="bold">Setup stores</strong>: Utilizes Vue’s Composition API, allowing for a more composable and <a id="_idIndexMarker245"/><span class="No-Break">reactive approach</span></li>
			</ul>
			<p>For our weather application, we’ve chosen the setup store method, leveraging the Composition API’s full potential for a more flexible state <span class="No-Break">management experience.</span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Integrating Reactive States and Functions in Pinia Store</h2>
			<p>In our <strong class="source-inline">weather.ts</strong> store, we first establish reactive references – <strong class="source-inline">activeCity</strong> and <strong class="source-inline">weatherData</strong> – akin to how we would in the Composition API. These references will hold <a id="_idIndexMarker246"/>the currently selected city and weather <span class="No-Break">information, respectively:</span></p>
			<pre class="source-code">
import { defineStore } from 'pinia'
export const useWeatherStore = defineStore('weather', () =&gt; {
  const activeCity = ref&lt;CityData&gt;()
  const weatherData = ref&lt;WeatherDataResponse&gt;()
  return {  }
})</pre>			<p>Next, we migrate the <strong class="source-inline">citiesLookup</strong> function from the <strong class="source-inline">CitiesLookup</strong> component to our store, ensuring that it retrieves the API key from the runtime configuration. This function fetches and formats city data <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">SelectMenu</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const config = useRuntimeConfig()
const apiKey = config.public.weatherApiKey
const citiesLookup = async (query: string):
Promise&lt;CityData[]&gt; =&gt; {
    if (!query) return []
    const response: Array&lt;CityData&gt; = await
    $fetch(`http://api.openweathermap.org/geo/1.0/direct?q=
    ${query}&amp;limit=5&amp;appid=${apiKey}`)
    return response.map(city =&gt; ({
        ...city,
        label: `${city.name}, ${city.country}`
    }))
}</pre>			<p>Similarly, we introduce <strong class="source-inline">getWeatherData</strong>, a function to fetch weather details based on the <a id="_idIndexMarker247"/>selected city (as we did in the <span class="No-Break"><strong class="source-inline">app.vue</strong></span><span class="No-Break"> file):</span></p>
			<pre class="source-code">
const getWeatherData = async () =&gt; {
    try {
        weatherData.value = await $fetch(
            `https://api.openweathermap.org/data/2.5/
            onecall?lat=${activeCity.value?.lat}&amp;lon=
            ${activeCity.value?.lon}&amp;appid=${apiKey}&amp;units=
            metric`
        )
    } catch (error) {
        console.error('Error fetching weather data:',
                       error)
    }
}</pre>			<p>In the final step, we make sure to return all these references and functions from the store, making them accessible throughout <span class="No-Break">the application:</span></p>
			<pre class="source-code">
return { activeCity, weatherData, citiesLookup,
getWeatherData }</pre>			<p>Here’s <a id="_idIndexMarker248"/>the complete setup of our <span class="No-Break"><strong class="source-inline">weather.ts</strong></span><span class="No-Break"> store:</span></p>
			<pre class="source-code">
import { defineStore } from 'pinia'
export const useWeatherStore = defineStore('weather', () =&gt; {
  const activeCity = ref&lt;CityData&gt;()
  const weatherData = ref&lt;WeatherDataResponse&gt;()
  const config = useRuntimeConfig()
  const apiKey = config.public.weatherApiKey
  const citiesLookup = async (query: string):
  Promise&lt;CityData[]&gt; =&gt; {
    const response: Array&lt;CityData&gt; = await $fetch(
      `http://api.openweathermap.org/geo/1.0/direct?q=
      ${query}&amp;limit=5&amp;appid=${apiKey}`
    )
    return response.map(city =&gt; ({
      ...city,
      label: `${city.name}, ${city.country}`
    }))
  }
  const getWeatherData = async () =&gt; {
    try {
      weatherData.value = await $fetch(
        `https://api.openweathermap.org/data/2.5/
        onecall?lat=${activeCity.value?.lat}&amp;lon=
        ${activeCity.value?.lon}&amp;appid=${apiKey}&amp;units=
        metric`
      )
    } catch (error) {
      console.error('Error fetching weather data:', error)
    }
  }
  return { activeCity, weatherData, citiesLookup,
           getWeatherData }
})</pre>			<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/>Refactoring components for Pinia store integration</h2>
			<p>In our <strong class="source-inline">CitiesLookup</strong> component, thanks to <strong class="source-inline">@nuxt/pinia</strong>, all stores located in the <strong class="source-inline">/stores</strong> directory <a id="_idIndexMarker249"/>are automatically imported throughout the app. This eliminates the need for manual imports. By calling <strong class="source-inline">useWeatherStore</strong>, we gain access to the store defined in the Pinia <span class="No-Break">store directly:</span></p>
			<pre class="source-code">
&lt;script setup lang="ts"&gt;
const weatherStore = useWeatherStore()
// weatherStore now contains the all refs and functions
&lt;/script&gt;</pre>			<p>We then replace the local <strong class="source-inline">citiesLookup</strong> function with the one from <span class="No-Break">the store:</span></p>
			<pre class="source-code">
&lt;template&gt;
  &lt;USelectMenu
    v-model="activeCity"
    :searchable="weatherStore.citiesLookup"
    placeholder="Search for a city..."
    @update:modelValue="emit('change', $event)"
  /&gt;
&lt;/template&gt;</pre>			<p>When <a id="_idIndexMarker250"/>integrating our components with the Pinia store, a key consideration is maintaining reactivity when using store properties. Directly destructuring properties from the store, as in the following code, can lead to a loss <span class="No-Break">of reactivity:</span></p>
			<pre class="source-code">
const { activeCity } = weatherStore</pre>			<p>This is where <strong class="source-inline">storeToRefs</strong> from Pinia becomes crucial. <strong class="source-inline">storeToRefs</strong> is a method that ensures reactivity is preserved when we extract properties from a store. By using the following code, we can destructure properties such as <strong class="source-inline">activeCity</strong> while maintaining their reactive nature, as demonstrated in the updated <span class="No-Break"><strong class="source-inline">CitiesLookup</strong></span><span class="No-Break"> component:</span></p>
			<pre class="source-code">
storeToRefs(weatherStore)</pre>			<p class="callout-heading">Note</p>
			<p class="callout">When you use <strong class="source-inline">@pinia/nuxt</strong> version <strong class="source-inline">0.5.1</strong> or later, <strong class="source-inline">storeToRefs</strong> is automatically imported. There’s no need to import it manually into <span class="No-Break">your components.</span></p>
			<p>Here is the final version <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">CitiesLookup.vue</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;template&gt;
  &lt;USelectMenu
    v-model="activeCity"
    :searchable="weatherStore.citiesLookup"
    placeholder="Search for a city..."
    @update:modelValue="emit('change', $event)"
  /&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
const weatherStore = useWeatherStore()
const { activeCity } = storeToRefs(weatherStore)
const emit = defineEmits(['change'])
&lt;/script&gt;</pre>			<p>Refactoring <strong class="source-inline">app.vue</strong> to utilize <a id="_idIndexMarker251"/>our Pinia store involves updating the <strong class="source-inline">onCityChanged</strong> function. Here’s how the script <span class="No-Break">now looks:</span></p>
			<pre class="source-code">
&lt;script setup lang="ts"&gt;
const weatherStore = useWeatherStore()
const { activeCity, weatherData } =
storeToRefs(weatherStore)
const loading = ref(false)
const onCityChanged = async () =&gt; {
  loading.value = true
  await weatherStore.getWeatherData()
  loading.value = false
}
&lt;/script&gt;</pre>			<p>In this refactored version, <strong class="source-inline">activeCity</strong> no longer needs to be passed as a parameter. Instead, we obtain <a id="_idIndexMarker252"/>a reactive reference to <strong class="source-inline">activeCity</strong> from the weather store using <strong class="source-inline">storeToRefs</strong>. Additionally, the weather data fetching is now handled directly by the <strong class="source-inline">getWeatherData</strong> method in the weather store, streamlining the component and centralizing the logic in the store. This approach simplifies <strong class="source-inline">app.vue</strong>, keeping it clean and focused on the <span class="No-Break">UI logic.</span></p>
			<p>Now that we’ve refactored our components to use the Pinia store, it’s time to test the application and ensure that everything functions seamlessly. Once we confirm the smooth operation of these updates, we’ll move on to our <span class="No-Break">next challenge.</span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>Implementing weather data widget components</h2>
			<p>Having ensured that our application functions smoothly with the integrated Pinia store, we now <a id="_idIndexMarker253"/>turn our attention to developing the weather data display. As part of this process, we will be using <strong class="source-inline">dayjs</strong>, as we did in the previous chapter, to handle date and time formatting within <span class="No-Break">our components.</span></p>
			<p>We begin by <span class="No-Break">installing </span><span class="No-Break"><strong class="source-inline">dayjs</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$ pnpm i dayjs</pre>			<p>Then, let’s create <strong class="source-inline">EmptyPlaceholder.vue</strong>, a component that provides a friendly message when no weather data is available. This placeholder will be displayed if there’s no active city selected or while the weather data <span class="No-Break">is loading.</span></p>
			<p>Here’s the <span class="No-Break">component’s template:</span></p>
			<pre class="source-code">
&lt;!—components/emptyPlaceholder.vue --&gt;
&lt;template&gt;
  &lt;div class="w-full mx-auto mt-10"&gt;
    &lt;div class="text-center p-12 border border-gray-300
    rounded-lg shadow-sm"&gt;
      &lt;p class="font-semibold text-xl"&gt;
        Weather data is not available yet. Please select a
        city to display the weather information.
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;</pre>			<p>This <a id="_idIndexMarker254"/>component is then integrated into <strong class="source-inline">app.vue</strong>, specifically under the <strong class="source-inline">u-card</strong> section, ensuring that it’s only visible when there’s no weather data or <span class="No-Break">during loading:</span></p>
			<pre class="source-code">
&lt;template&gt;
  &lt;!-- city selection card  --&gt;
  &lt;empty-placeholder v-if="!weatherData &amp;&amp; !loading" /&gt;
&lt;/template&gt;</pre>			<p>To enhance the user experience during data loading, we’ll implement a <strong class="source-inline">loading</strong> skeleton card. This feature provides a visual cue that content is being loaded. Here’s the updated <span class="No-Break"><strong class="source-inline">app.vue</strong></span><span class="No-Break"> template:</span></p>
			<pre class="source-code">
&lt;template&gt;
  &lt;!-- city selection card  --&gt;
  &lt;empty-placeholder v-if="!weatherData &amp;&amp; !loading" /&gt;
  &lt;div v-else-if="loading" class="animate-pulse w-full
  space-y-4"&gt;
    &lt;div class="h-96 bg-slate-300 dark:bg-slate-900
      rounded" /&gt;
    &lt;div class="h-96 bg-slate-300 dark:bg-slate-900
      rounded" /&gt;
  &lt;/div&gt;
&lt;/template&gt;</pre>			<p>The added code creates a pulsing effect on two <strong class="source-inline">div</strong> elements, simulating the space where the weather data cards will appear once the data is loaded. <strong class="source-inline">v-if="loading"</strong> ensures <a id="_idIndexMarker255"/>that this skeleton is only visible during the <span class="No-Break">loading phase.</span></p>
			<p>Moving forward, we’ll develop a comprehensive display of weather data in <strong class="source-inline">app.vue</strong>. This includes <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Current weather</strong>: The current weather conditions, including temperature, weather description, and <span class="No-Break">relevant icons.</span></li>
				<li><strong class="bold">Hourly forecast</strong>: A scrollable view of the hourly weather forecast. Each card in this section will detail the weather conditions for a <span class="No-Break">specific hour.</span></li>
				<li><strong class="bold">7-day forecast</strong>: A grid layout presenting the 7-day <span class="No-Break">weather forecast.</span></li>
			</ul>
			<p>Let’s begin with the <span class="No-Break"><strong class="source-inline">CurrentWeatherData.vue</strong></span><span class="No-Break"> component:</span></p>
			<pre class="source-code">
&lt;template&gt;
  &lt;div class="text-center"&gt;
    &lt;h2 class="text-4xl font-bold"&gt;
      {{ weatherData?.current.temp.toFixed(0) }}°
    &lt;/h2&gt;
    &lt;p class="text-xl"&gt;
      {{ weatherData?.current.weather[0].description }}
    &lt;/p&gt;
    &lt;img
      :src="`http://openweathermap.org/img/wn/
           ${weatherData?.current.weather[0].icon}@2x.png`"
      alt="Weather Icon"
      class="mx-auto"
    /&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
const weatherStore = useWeatherStore()
const { weatherData } = storeToRefs(weatherStore)
&lt;/script&gt;</pre>			<p>Here <a id="_idIndexMarker256"/>is <span class="No-Break">a breakdown:</span></p>
			<ul>
				<li>The <strong class="source-inline">template</strong> section displays the current temperature in a large, bold font. It also shows a description of the current weather, as well as an image of the weather icon, sourced from OpenWeatherMap, corresponding to the current <span class="No-Break">weather condition.</span></li>
				<li>The <strong class="source-inline">script</strong> section accesses the reactive version of <strong class="source-inline">weatherData</strong> from the weather store <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">storeToRefs</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Now, let’s proceed <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">HourlyWeatherCard.vue</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;template&gt;
  &lt;div
    class="flex flex-col items-center min-w-[125px]
    max-w-[125px] p-4 border-dashed border-2 bg-slate-50
    dark:bg-slate-800 text-slate-700 dark:text-slate-300
    rounded-lg"
  &gt;
    &lt;p class="font-light text-lg"&gt;
      {{ dayjs(hour.dt * 1000).format('HH:mm') }}
    &lt;/p&gt;
    &lt;p class="text-2xl font-black"&gt;
      {{ hour.temp.toFixed(0) }}°C&lt;/p&gt;
    &lt;img
      :src="`http://openweathermap.org/img/wn/
           ${hour.weather[0].icon}@2x.png`"
      alt="Weather Icon"
      class="w-12 h-12"
    /&gt;
    &lt;p class="text-sm mt-1"&gt;
      {{ hour.weather[0].description }}
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import dayjs from 'dayjs'
defineProps&lt;{ hour: HourlyWeather }&gt;()
&lt;/script&gt;</pre>			<p>This component is structured <span class="No-Break">as follows:</span></p>
			<ul>
				<li>It displays hourly forecasts in a <span class="No-Break"><strong class="source-inline">flex</strong></span><span class="No-Break"> container</span></li>
				<li>It uses <strong class="source-inline">dayjs</strong> to convert and format the Unix timestamp, <strong class="source-inline">(hour.dt)</strong>, into a readable time <span class="No-Break">format, </span><span class="No-Break"><strong class="source-inline">(HH:mm)</strong></span></li>
				<li>It includes weather information such as an image and description for the <span class="No-Break">specific hour</span></li>
				<li>It utilizes <strong class="source-inline">defineProps</strong> to ensure that the component receives the correct <strong class="source-inline">HourlyWeather</strong> <span class="No-Break">data type</span></li>
			</ul>
			<p>This <a id="_idIndexMarker257"/>means that we need to loop over the hour data array in <strong class="source-inline">app.vue</strong> and call this component for each <span class="No-Break">data item.</span></p>
			<p>Next, let’s look <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">ForecastCard.vue</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;template&gt;
  &lt;div
    class="flex flex-col items-center p-4 border-dashed
    border-2 bg-slate-50 dark:bg-slate-800 text-slate-700
    dark:text-slate-300 rounded-lg"
  &gt;
    &lt;p class="text-lg font-semibold"&gt;
      {{ dayjs(day.dt * 1000).format('dddd') }}
    &lt;/p&gt;
    &lt;img
      :src="`http://openweathermap.org/img/wn/
           ${day.weather[0].icon}@2x.png`"
      alt="Weather Icon"
      class="w-12 h-12"
    /&gt;
    &lt;p class="mt-1"&gt;
      {{ day.temp.day.toFixed(0) }}°C /
      {{ day.temp.night.toFixed(0) }}°C
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import dayjs from 'dayjs'
defineProps&lt;{
  day: DailyWeather
}&gt;()
&lt;/script&gt;</pre>			<p>Like <strong class="source-inline">HourlyWeatherCard</strong>, this component will be used in <strong class="source-inline">app.vue</strong>, looping over each <a id="_idIndexMarker258"/>item in the daily weather data array to dynamically present each <span class="No-Break">day’s forecast.</span></p>
			<p>With all components created, let’s add them <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">app.vue</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;template&gt;
    &lt;!-- ... card for city lookup --&gt;
    &lt;empty-placeholder v-if="!weatherData &amp;&amp; !loading" /&gt;
    &lt;div v-if="loading" class="animate-pulse w-full
    space-y-4"&gt;
      &lt;div class="h-96 bg-slate-300 dark:bg-slate-900
      rounded" /&gt;
      &lt;div class="h-96 bg-slate-300 dark:bg-slate-900
      rounded" /&gt;
    &lt;/div&gt;
    &lt;u-card v-else-if="weatherData"&gt;
      &lt;h1 class="text-3xl font-bold text-center mb-6"&gt;
        {{ activeCity?.name }}, {{ activeCity?.country }}
      &lt;/h1&gt;
        &lt;div class="space-y-6 mb-8"&gt;
          &lt;!-- Current Weather --&gt;
          &lt;current-weather-data /&gt;
            &lt;!-- Hourly Weather Slider --&gt;
            &lt;div class="flex overflow-x-auto py-4
            space-x-4"&gt;
              &lt;hourly-weather-card
                v-for="(hour, index) in weatherData.hourly"
                :key="index"
                :hour="hour" /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;!-- 7 Day Forecast --&gt;
        &lt;div class="p-4 rounded-lg"&gt;
          &lt;h3 class="font-semibold text-center mb-4"&gt;
            7 Day Forecast
          &lt;/h3&gt;
          &lt;div class="grid grid-cols-1 md:grid-cols-2
          lg:grid-cols-3 gap-4"&gt;
            &lt;forecast-card
              v-for="(day, index) in weatherData.daily"
              :key="index"
              :day="day"
            /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
    &lt;/u-card&gt;
&lt;/template&gt;</pre>			<p>Here <a id="_idIndexMarker259"/>is <span class="No-Break">the breakdown:</span></p>
			<ul>
				<li><strong class="source-inline">u-card</strong> displays the selected city’s name <span class="No-Break">and country</span></li>
				<li>The <strong class="source-inline">current-weather-data</strong> component shows the current <span class="No-Break">weather conditions</span></li>
				<li>A horizontal slider, containing <strong class="source-inline">hourly-weather-card</strong> components, presents the <span class="No-Break">hourly forecast</span></li>
				<li>The 7-day forecast is laid out in a grid, with each <strong class="source-inline">forecast-card</strong> component representing a <span class="No-Break">day’s weather</span></li>
			</ul>
			<p>Now, it’s <a id="_idIndexMarker260"/>time to test the application to ensure that all components are functioning as expected. Check the <span class="No-Break">following scenarios:</span></p>
			<ul>
				<li><strong class="bold">No active city</strong>: Verify the display when no city is selected: </li>
			</ul>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B19760_04_08.jpg" alt="Figure 4.8: No active city" width="911" height="390"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8: No active city</p>
			<ul>
				<li><strong class="bold">Loading state</strong>: Observe the loading skeleton when data is being fetched: </li>
			</ul>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B19760_04_09.jpg" alt="Figure 4.9: Loading state" width="829" height="448"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9: Loading state</p>
			<ul>
				<li><strong class="bold">Data display</strong>: Ensure <a id="_idIndexMarker261"/>that all weather data is correctly displayed when a city is selected: </li>
			</ul>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B19760_04_10.jpg" alt="Figure 4.10: Data display" width="925" height="656"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10: Data display</p>
			<p>With all the pieces now in place, our weather dashboard in <strong class="source-inline">app.vue</strong> stands as a testament to our combined efforts and technical prowess. Congratulations on reaching this <span class="No-Break">significant milestone!</span></p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor098"/>Summary</h1>
			<p>In this chapter, we explored the construction of a weather dashboard using Nuxt 3, starting with the sleek and user-friendly Nuxt UI. Our journey included practical data fetching with the OpenWeatherMap API and efficient use of <strong class="source-inline">$fetch</strong> for dynamic data presentation. The chapter culminated with the integration of Pinia for centralized state management, making the handling of weather data across components simpler and more efficient. This chapter was designed to enhance your skills in building advanced, real-world applications with <span class="No-Break">Nuxt 3.</span></p>
			<p>As we proceed to <a href="B19760_05.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, we shift gears to a new challenge: constructing a community forum website with Nuxt 3. This chapter will guide you through the intricacies of user registration, login, and post creation. We’ll dive into implementing robust authentication to secure the website, ensuring that features such as post creation are exclusive to registered users. You’ll learn practical skills such as form validation, exploring authentication strategies, and managing access tokens with cookies. Additionally, we’ll delve into configuring middleware for protected routes, cementing your understanding of web application security and user management in <span class="No-Break">Nuxt 3.</span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>Practice questions</h1>
			<ul>
				<li>How do you integrate Nuxt UI into a Nuxt <span class="No-Break">3 project?</span></li>
				<li>How do you customize the primary color in <span class="No-Break">Nuxt UI?</span></li>
				<li>What <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">$fetch</strong></span><span class="No-Break">?</span></li>
				<li>How do you define a global type without needing to import it <span class="No-Break">each time?</span></li>
				<li>What is the purpose of the <strong class="source-inline">useRuntimeConfig</strong> composable in <span class="No-Break">Nuxt 3?</span></li>
				<li>What are the benefits of using Pinia for state management <span class="No-Break">in Nuxt?</span></li>
				<li>Explain the use of <strong class="source-inline">storeToRefs</strong> in a Nuxt <span class="No-Break">3 application.</span></li>
				<li>How do you ensure reactivity when using a global state from a <span class="No-Break">Pinia store?</span></li>
			</ul>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor100"/>Further reading</h1>
			<ul>
				<li>Nuxt <span class="No-Break">UI: </span><a href="https://ui.nuxt.com/"><span class="No-Break">https://ui.nuxt.com/</span></a></li>
				<li>Nuxt data <span class="No-Break">fetching: </span><a href="https://nuxt.com/docs/getting-started/data-fetching"><span class="No-Break">https://nuxt.com/docs/getting-started/data-fetching</span></a></li>
				<li><span class="No-Break">Pinia: </span><a href="https://pinia.vuejs.org"><span class="No-Break">https://pinia.vuejs.org</span></a></li>
				<li>OpenWeatherMap <span class="No-Break">API: </span><a href="https://openweathermap.org/api"><span class="No-Break">https://openweathermap.org/api</span></a></li>
				<li>JavaScript asynchronous programming and <span class="No-Break">promises: </span><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous</span></a></li>
				<li>Day.js <span class="No-Break">documentation: </span><a href="https://day.js.org/"><span class="No-Break">https://day.js.org/</span></a></li>
			</ul>
		</div>
	</div>
</div>
</body></html>