- en: RxJS Advanced
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just finished our last chapter that taught us more about what operators exist
    and how to utilize them effectively. Armed with this knowledge, we will now go
    into this subject in more depth. We will go from learning about what parts exist,
    to actually understanding the nature of RxJS. Knowing the nature of RxJS involves
    understanding more about what makes it tick. To uncover this, we need to cover
    topics such as what the differences are between hot, warm, and cold Observables;
    knowing about Subjects and what they are good for; and the sometimes ignored topic
    of Schedulers.
  prefs: []
  type: TYPE_NORMAL
- en: There are also other aspects of working with Observables that we want to cover,
    namely, how to deal with errors and how to test your Observables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Hot, cold, and warm Observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subjects: how they differ from Observables, and when to use them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipeable operators, a recent addition to the RxJS library, and how they affect
    how you compose Observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marble testing, the testing machinery in place that helps you with testing your
    Observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hot, cold, and warm Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are hot, cold, and warm Observables. What do we actually mean by that?
    For starters, let''s say that most things you will deal with are cold Observables.
    Not helping? If we say that cold Observables are lazy, does that help? No? OK,
    let''s talk about Promises for a second. Promises are hot. They are hot because
    when we execute their code, it happens straight away. Let''s see an example of
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you come from a non-RxJS background, you will most likely, at this point,
    think: OK, yes, that''s what I expected. This is the point we are trying to make,
    though: Calling `getData()` makes your code run straight away. This differs from
    RxJS in the sense that similar RxJS code will actually not run until there is
    a listener/subscriber that cares about the result. RxJS answers the old philosophical
    question: Does a tree make a sound when it falls in the forest if no one is there
    to listen? In the case of Promises, it does. In the case of an Observable, it
    doesn''t. Let''s clarify what we just said with a similar code example using RxJS
    and Observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In RxJS, code like this is considered cold, or lazy. We need a subscriber for
    something to actually happen. We can add a subscriber like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a major difference in how Observables behave versus Promises, and it''s
    important to know. This is a cold Observable; so, what is a hot Observable? It
    would be easy to think, at this point, that a hot Observable is something that
    executes straight away; there is more to it than that, however. One of the official
    explanations of what a hot Observable is, is that anything that subscribes to
    it will share the Producer with other Subscribers. The Producer is what spouts
    out values internally inside the Observable. This means that the data is shared.
    Let''s look at a cold Observable subscription scenario and contrast that with
    a hot Observable subscription scenario. We will start with the cold scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have three different subscribers that receive their
    own copy of emitted values. The values start from the beginning, every time we
    add a new subscriber. That might be expected when looking at the two first subscribers.
    As for the third one, it is added as a subscriber after two seconds. Yes, even
    that subscriber receives its own set of values. The explanation is that each subscriber
    receives its own Producer upon subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'With hot Observables, there is just one producer, which means the scenario
    above will play out differently. Let''s write down the code for a hot Observable
    scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The reason the third subscriber is outputting only the value `2` is that the
    other values have been emitted already. The third subscriber wasn't around to
    see that happen. On the third value emit, it is around, and that is the reason
    it receives the value `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Making a stream hot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This `hotStream$`, how can it be created? You did say that most of the streams
    being created are cold? We have an operator for doing just that, or two operators,
    in reality. We can make a stream go from cold to hot by using the operators `publish()`
    and `connect()`. Let''s start with a cold Observable and add the mentioned operators,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see from the preceding code that we create our Observable and instruct
    it to emit values, one value per second. Furthermore, it should stop after five
    emitted values. We then call the operator `publish()`. This puts us in ready mode.
    We then set up a few subscriptions to happen after two seconds and three seconds,
    respectively. This is followed by us calling `connect()` on the stream. This will
    make the stream go from hot to cold. Thereby, our stream starts emitting values,
    and any subscriber, whenever it starts subscribing, will share a producer with
    any future subscriber. Lastly, we add a subscriber to happen straight after the
    call to `connect()`. Let''s show what the output becomes with the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee47651c-91e2-4dba-be28-5072cf65726e.png)'
  prefs: []
  type: TYPE_IMG
- en: Our first subscriber is emitting values after one second. Our second subscriber
    kicks in after yet another second. This time its value is `1`; it has missed out
    on the first value. After yet another second, the third subscriber has been attached.
    The first value that subscriber emits is `2`; it missed out on the two first values.
    We clearly see how the operators `publish()` and `connect()` help to create our
    hot Observable, but also how it matters when you start subscribing to a hot Observable.
  prefs: []
  type: TYPE_NORMAL
- en: Why on earth would I want a hot Observable? What's the area for application?
    Well, imagine you have a live stream, a football game that you stream to many
    subscribers/viewers. They wouldn't want to see what happens from the first minute
    of the game when they arrive late, but, rather, where the match is right now,
    at the time of subscription (when they park themselves in front of the television).
    So, there definitely exist cases where hot Observables are the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: Warm streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been describing and discussing cold Observables and hot Observables,
    but there is a third kind: the warm Observable. A warm Observable can be thought
    of as being created as a cold Observable, but turning into a hot Observable under
    certain conditions. Let''s look at such a case by introducing the `refCount()`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, so we started to use the operator `publish()`, and it looks like we are
    about to use our `connect()` operator and that we have a hot Observable, right?
    Well, yes, but instead of calling `connect()`, we call `refCount()`. This operator
    will warm our Observable up so that when the first subscriber arrives, it will
    act like a cold Observable. OK? That just sounds like a cold Observable, right?
    Let''s have a look at the output first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db091650-11ef-4095-b8e9-65cd305e6bef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To answer the preceding question, yes, it''s correct that it just behaves like
    a cold Observable; we aren''t missing out on any emitted values. The interesting
    thing happens when we get a second subscriber. Let''s add that second subscriber
    and see what the effects are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our second subscriber is added; now, let''s have a look at what the result
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/152ed024-9bf4-44ae-89a5-96fb02bf1d4f.png)'
  prefs: []
  type: TYPE_IMG
- en: What we can see from the results above is that the first subscriber is alone
    in receiving the number `0`. When the second subscriber arrives, its first value
    is `1`, which proves the stream has gone from acting like a cold Observable to
    a hot Observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way we can do warm Observables, and that is through using
    the `share()` operator. The `share()` operator can be seen as more of a smart
    operator that allows our Observable to go from cold to hot, depending on the situation.
    That can be a really great idea sometimes. So, there are the following situations
    for Observables:'
  prefs: []
  type: TYPE_NORMAL
- en: Created as a hot Observable; the stream hasn't completed, and none of the subscribers
    are more than one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Falls back into being a cold Observable; any previous subscription has had time
    to end before a new subscription arrives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created as a cold Observable; the Observable itself has had time to complete
    before the subscription happens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try to show in code how the first bullet can happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code describes a situation where we defined a stream with a subscription
    that happens straight away. The second subscription happens after one second.
    Now, according to the definition of the `share()` operator, this means that the
    stream will be created as a cold Observable, but will, at the time of the second
    subscriber, be turned into a hot Observable, as there is a pre-existing subscriber
    and the stream has yet to complete. Let''s inspect our output to verify that this
    is the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bef68a1-abca-490f-9274-b52f2a7be5d1.png)'
  prefs: []
  type: TYPE_IMG
- en: The first subscriber seems to be clearly alone in the values it gets. When the
    second subscriber arrives, it seems to share the producer, as it doesn't start
    from zero, but, rather, it starts listening where the first subscriber is.
  prefs: []
  type: TYPE_NORMAL
- en: Subjects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are used to using Observables in a certain way. We construct them from something
    and we start listening to values that they emit. There is usually very little
    we can do to affect what is being emitted after the point of creation. Sure, we
    can change it and filter it, but it is next to impossible to add more to our `Observable`
    unless we merge it with another stream. Let''s have a look at when we are really
    in control of what is being emitted when it comes to Observables, using the `create()`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We see the Observable acting as a wrapper around the thing that really emits
    our values, the Observer. In our Observer instance, the Observer is calling `next()`,
    with a parameter to emit values – values that we listen to in our `subscribe()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section is about the Subject. The Subject differs from the Observable
    in that it can affect the content of the stream after its creation. Let''s have
    a look at just that with the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we notice is how we just call the constructor instead of using
    a factory method like `create()` or `from()` or similar, as we do on an Observable.
    The second thing we notice is how we subscribe to it on the second line, and only
    on the last line do we emit values by calling `next()`. Why is the code written
    in this order? Well, if we didn''t write it this way and have the `next()` call
    happen as the second thing, our subscription wouldn''t be there, and the value
    would have been emitted straight away. We know two things for sure, though: we
    are calling `next()`, and we are calling `subscribe()`, which makes `Subject`
    a double nature. We did mention another thing the `Subject` was capable of: changing
    the stream after creation. Our call to `next()` is literally doing that. Let''s
    add a few more calls so we ensure we really get the idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we stated before, all the calls we make to the `next()` method enable us
    to affect the stream; we see in our `subscribe()` method that every call to `next()`
    leads to the `subscribe()` being hit, or, technically, the first function we pass
    into it.
  prefs: []
  type: TYPE_NORMAL
- en: Using Subject for cascading lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, what''s the point? Why should we use Subjects over Observables? That''s
    actually a quite deep question. There are many ways of solving most streaming-related
    problems; problems where it is tempting to use a Subject can often be solved through
    some other way. Let''s have a look at what you could be using it for, though.
    Let''s talk about cascading drop-down lists. What we mean by that is that we want
    to know what restaurants exist in a city. Imagine, therefore, that we have a drop-down
    list that allows us to select what country we are interested in. Once we select
    a country, we should select the city we are interested in from a drop-down list
    of cities. Thereafter, we get to select from a list of restaurants, and, finally,
    pick the restaurant that interests us. In the markup, it most likely looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At the start of the application, we haven''t selected anything, and the only
    drop-down list that is selected is the first one, and it is filled with countries.
    Imagine that we therefore set up the following code in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have established that we want to listen to the selected events
    of each drop-down list, and we want, in the cases of countries or cities droplist,
    filter the upcoming droplist. Say we select a specific country then we want to
    repopulate/filter the cities droplist so that it only shows cities for the selected
    country. For the restaurant drop-down list, we want to perform a booking based
    on our restaurant selection. Sounds pretty simple, right? We need some subscribers.
    The cities drop-down list needs to listen to changes in the countries drop-down
    list. So we add that to our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So, here, we have a behavior of performing an AJAX request when we select a
    country; we get a filtered list of cities, and we introduce the new subject instance
    `cities$`. We call the `next()` method on it with our filtered cities as a parameter.
    Finally, we listen to changes to the `cities$` stream by calling the `subscribe()`
    method on the stream. As you can see, when data arrives, we rebuild our cities
    drop-down list there.
  prefs: []
  type: TYPE_NORMAL
- en: 'We realize that our next step is to react to changes from us doing a selection
    in the cities drop-down list. So, let''s set that up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we added some code to react to a selection being made
    in our cities drop-down list. We also added some code to listen to changes in
    the `restaurants$` stream, which finally led to our restaurants drop-down list
    being repopulated. The last step is to listen to changes on us selecting a restaurant
    in the restaurants drop-down list. What should happen here is up to you, dear
    reader. A suggestion is that we query some API for the selected restaurant''s
    opening hours, or its menu. Use your creativity. We will leave you with some final
    subscription code, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This became a quite long code example, and it should be said that this is not
    the best way of solving a problem like this, but it does demonstrate how a Subject
    works: it can add value to the stream when it wants, and it can be subscribed
    to.'
  prefs: []
  type: TYPE_NORMAL
- en: BehaviorSubject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been looking at the default type of Subject, and we have uncovered
    a little of its secrets. However, there are many more types of Subjects. One such
    interesting type of Subject is the `BehaviorSubject`. So, why do we need a `BehaviorSubject`,
    and for what? Well, when dealing with a default Subject, we are able to add values
    to the stream, as well as subscribe to the stream. The `BehaviorSubject` gives
    us some added capabilities, in the form of:'
  prefs: []
  type: TYPE_NORMAL
- en: A starter value, which is great if we are able to show something to the UI while
    waiting for an AJAX call to finish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can query on the latest value; in some situations, it is interesting to know
    what the last emitted value was
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To address the first bullet, let''s write some code and showcase this capability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: ReplaySubject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With a normal Subject, it matters when we start subscribing. If we start emitting
    values before our subscription is set up, those values are simply lost. If we
    have a `BehaviorSubject`, we have a somewhat better scenario. Even if we are late
    in subscribing, so a value has already been emitted, the very last emitted value
    is still possible to gain access to. Then the following question arises: What
    if two or more values are emitted before a subscription happens and we care about
    those values – what then?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s illustrate this scenario and see what happens with a Subject and `BehaviorSubject`,
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'What we can see from the preceding code is that Subject is not a good candidate
    if we care about values prior to us subscribing. The `BehaviorSubject` constructors
    are slightly better for that scenario, but if we really care about prior values,
    and a lot of them, then we should have a look at the `ReplaySubject`. The `ReplaySubject`
    has the ability to specify two things: a buffer size and a window size. A buffer
    size is simply the amount of values it should remember from the past, and the
    window size specifies for how long it should remember them for. Let us demonstrate
    this in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see how we emit `2` and `3`, that is, the two
    latest emitted values. This is due to the fact that we specify the buffer size
    in the `ReplaySubject` constructor to be 2\. The only value we loose out on is
    1\. Had we, on the other hand, specified a 3 in our constructor, all three values
    would have reached the subscriber. So much for the buffer size and how that works;
    what about the window size property? Let''s illustrate how that works with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we specify the window size as 2,000 milliseconds; that is how long the
    values should be held in the buffer. We can see below that we delay the creation
    of our subscription to occur after 2,010 milliseconds. The end result of this
    is that no values will be emitted, as the buffer will have been emptied before
    the subscription has time to occur. A higher value of the window size would have
    fixed this issue.
  prefs: []
  type: TYPE_NORMAL
- en: AsyncSubject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AsyncSubject` has a capacity of one, which means we can emit a ton of
    values, but only the latest one is something that is stored. It isn''t really
    lost, either, but you won''t see it unless you complete the stream. Let''s look
    at a piece of code that illustrates just this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we had fours values being emitted, but nothing seems to reach the
    subscriber. At this point, we don''t know whether this is because it just acts
    like a subject and throws away all emitted values that happen before a subscription
    or not. Let''s therefore call the `complete()` method and see how that plays out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will emit a `4` due to the fact that `AsyncSubject` only remembers the
    last value and we are calling the `complete()` method, thereby signaling the completion
    of the stream.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error handling is a very big topic. It is an area that is easy to underestimate.
    Normally, when coding, we could be led to believe we just need to do certain things,
    such as ensure we don't have syntax errors or runtime errors. With streams, we
    mostly think of runtime errors. The question is, how should we act when an error
    occurs? Should we pretend like it rains and just throw the error away? Should
    we hope for a different outcome if we try the same code some time in the future,
    or should we maybe just give up when a certain type of error exists? Let's try
    to collect our thoughts and look at the different error approaches that exist
    within RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: Catch and continue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sooner or later, we will have a stream that will throw an error. Let''s see
    what that can look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we set up a scenario where we first emit a value, followed
    by emitting an error. The first value is captured in our first callback in our
    subscribe method. The second emitted thing, the error, is captured by our error
    callback. The third emitted value does not get emitted to our subscriber because
    our stream has been interrupted by the error. There is something we can do here,
    and that is to use the `catch()` operator. Let''s apply that to our stream and
    see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we capture our error with the `catch()` operator. In the `catch()` operator,
    we take our error and emit it as a normal Observable using the `of()` operator.
    What happens to the `2` we emit, though? Still no luck with that one. The `catch()`
    operator is able to take our error and turn it into a normal emitted value; instead
    of an error, we don't get all the values from the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at a scenario when we are dealing with multiple streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the scenario above, we merge three streams. The first stream emits the number
    `1` and nothing else gets emitted. This is due to our second stream tearing everything
    down, as it emits an error. Let''s try to apply our newfound `catch()` operator
    and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We run the above code and we notice that the `1` is emitted, the error is emitted
    as a normal value, and, finally, even the `2` is emitted. Our conclusion here
    is that it is a good idea to apply a `catch()` operator to a stream before it
    is being merged with our streams.
  prefs: []
  type: TYPE_NORMAL
- en: As before, we can also conclude that the `catch()` operator is able to stop
    the stream from just erroring out, but that other values that would have been
    emitted after the error are effectively lost.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring the error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw in the former section, the `catch()` operator does a good job of
    ensuring that a stream that errors out doesn''t cause any problems when being
    merged with another stream. The `catch()` operator enables us to take the error,
    investigate it, and create a new Observable that will emit a value as though nothing
    happened. Sometimes, however, you don''t want to even deal with streams that error
    out. For such a scenario, there is a different operator, called `onErrorResumeNext()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The implication of using the `onErrorResumeNext()` operator is that the second
    stream, the one that emits an error, gets completely ignored, and the values `1`
    and `2` get emitted. This is a very nice operator to use if your scenario is only
    about caring for the streams that do not error out.
  prefs: []
  type: TYPE_NORMAL
- en: Retry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different reasons why you would want to retry a stream. It''s easier
    to imagine why you would want to if your stream is dealing with AJAX calls. Network
    connections may be unreliable at times with the local network you are on, or the
    service you are trying to hit may be temporarily down for some reason. Regardless
    of the reason, you have a situation where hitting that endpoint will some of the
    time reply with an answer, and some of the time return a 401 error. What we are
    describing here is the business case for adding retry logic to your streams. Let''s
    have a look at a stream designed to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code above is the value `1` being emitted four times, followed
    by our error. What happens is that our streams'' values are retried three times
    before the error callback is hit in the subscribe. Using the `retry()` operator
    delays when the error is actually treated as an error. The preceding example doesn''t
    make sense to retry, though, as the error will always occur. Therefore, let''s
    take a better example – an AJAX call where the network connection may come and
    go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are attempting an AJAX request towards a file that doesn''t seem to
    exist. Having a look at the console, we are faced with the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1abf96ff-ea61-4bd1-a20b-f276d562a645.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What we see in the above logging are four failed AJAX requests that lead to
    an error. We have essentially just switched our simple stream to a more credible
    AJAX request stream, with the same behavior. Should the file suddenly start to
    exist, we may have a scenario with two failed attempts and one successful attempt.
    Our approach has a flaw, though: we retry our AJAX attempts far too often. If
    we are actually dealing with an intermittent network connection, we need to have
    some kind of delay between attempts. It is reasonable to set a delay between attempts
    of at least 30 seconds or more. We can accomplish that by using a slightly different
    retry operator that takes milliseconds rather than a number of attempts as an
    argument. It looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What we do here is use the operator `retryWhen()`. The `retryWhen()` operator's
    mission in life is to return a stream. At this point, you can manipulate the stream
    it returns by appending a `.delay()` operator that takes a number of milliseconds.
    The result from doing so is that it will retry the AJAX call for all eternity,
    which may not be what you want.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Retry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we most likely want is to combine the delay between retry attempts with
    being able to specify how many times we want to retry the stream. Let''s have
    a look at how we can accomplish that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting part here is that we use the operator `.take()`. We specify
    the number of emitted values we want from this inner Observable. We have now accomplished
    a nice approach in which we are able to control the number of retries and the
    delay between retries. There is an aspect to this that we haven''t tried, namely,
    how we want all the retries to end when it finally gives up. In the preceding
    code, the stream just completes after the stream is retried after *x* number of
    times with no successful result. However, we may want the stream to error out
    instead. We can accomplish this by just adding an operator to the code, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are adding a `concat()` operator that adds a stream that just fails.
    So we are guaranteed, after three failed attempts, to have an error happen. This
    is usually a better approach than having the stream silently complete after *x*
    number of failed attempts.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't a perfect approach, though; imagine that you want to investigate
    what type of error you get back. In the case of AJAX requests being made, it matters
    whether we get a 400-something error or a 500-something error back as HTTP status
    code. They mean different things. With 500 errors, something is very wrong on
    the backend, and we probably want to give up straight away. With a 404 error,
    however, this implies the resource isn't there, but in the case with an intermittent
    network connection, this means the resource can't be reached due to our connection
    being offline. For that reason, a 404 error might be worth retrying. To solve
    that in code, we need to inspect the value being emitted to determine what to
    do. We can inspect values using the `do()` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we investigate the type of HTTP status of the response
    and determine how to handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Marble testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing asynchronous code can be challenging. For one, we have the time factor.
    The way we specify what operators to use for our crafted algorithm leads to the
    algorithm taking anywhere from 2 seconds to 30 minutes to execute. Therefore,
    it will at first feel like there is no point in testing it, because it can't be
    done within a reasonable time. We have a way to test RxJS, though; it is called
    Marble testing and it allows us to control how fast time passes so we have a test
    that can execute it in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of a Marble is known to us. We can represent one or many streams and
    the effect an operator has one two or more streams. We do this by drawing the
    streams as a line and values as circles on the lines. The operator is shown as
    verb below the input streams. Following operator is a third stream, the result
    of taking the input streams and applying the operator, a so - called marble diagram.
    The line represents a continuous timeline. We take this concept and bring it to
    testing. What this means is that we can express our incoming values as a graphical
    representation and apply our algorithm to it and assert on the result.
  prefs: []
  type: TYPE_NORMAL
- en: Set up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set up our environment correctly so we can write marble tests. We need
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The NPM library jasmine-marbles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A scaffolded Angular application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that we scaffold our Angular project, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After the project has been scaffolded, it''s time to add our NPM library, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now we have finished the setup, so the time has come to write tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first marble test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new file `marble-testing.spec.ts`. It should look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot of interesting things are happening here. We import the function `cold()`
    from the NPM library marble-testing. Thereafter we set up a test suite by calling
    `describe()`, followed by a test specification, by calling `it()`. Then we call
    our `cold()` function and provide it a string. Let''s have a close look at that
    function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The above code set up a stream that expects to values to be emitted followed
    by the stream ending. How do we know that? It's time to explain what `x-x|` means.
    `x` is just any value, the hyphen `-` means time has passed. The pipe `|` means
    our stream has ended. The second argument in the cold function is a mapping object
    that tells us what the x means. In this case, it has come to mean the value 1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, let''s have a look at the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code applies the operator `.map()` and increased the value with
    one for each value emitted in the stream. Thereafter, we call the `.toBeObservable()`
    helper method and verify it against an expected condition,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The previous condition states that we expect the stream to should emit two values,
    but that the values should now have the number 2\. This makes sense, as our `map()`
    function performs just that.
  prefs: []
  type: TYPE_NORMAL
- en: Fleshing out with more tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write one more test. This time we will be testing the `filter()` operator.
    This one is interesting, as it filters away values that does not fulfill a certain
    condition. Our test file should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This test is set up in pretty much the same way as our first test. This time
    we use the `filter()` operator but what stands out is our expected stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`--y`, means that our first values is removed. Based on how the filter condition
    is defined, we are not surprised. The reason for the double hyphen, `-`, though,
    is that time still passes, but instead of an emitted value a hyphen takes its
    place.'
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Marble testing, have a look at the following link from the
    official documentation, [https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md](https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md)
  prefs: []
  type: TYPE_NORMAL
- en: Pipeable operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We haven''t mentioned it much so far, but the RxJS library weighs in quite
    heavily when used in an app. In today''s world of mobile first, every kilobyte
    counts when it comes to libraries that you include in your app. They count because
    the user may be on a 3G connection, and if it takes too long to load, your user
    may leave, or just may end up not liking your app, as it feels slow to load, and
    this may cause you to have bad reviews or lose users. So far, we have used two
    different ways of importing RxJS:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing the whole library; this one is quite costly in terms of size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing only the operators we need; this ensures that the bundle decreases
    significantly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The different options have looked like this, for importing the whole library
    and all its operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Or like this, to only import what we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'That looks good, right? Well, yes, but it is a flawed approach. Let''s explain
    what happens when you type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'By typing the preceding, we add to the prototype of the `Observable`. Looking
    in the source code for RxJS, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding code, we import the `Observable` as well
    as the operator in question and we add the operator to the prototype by assigning
    it to a `map` property on the prototype. What''s flawed with that, you might wonder?
    The problem is tree shaking, a process we use to get rid of unused code. Tree
    shaking has a hard time determining what you use and don''t use, respectively.
    You may actually import a `map()` operator and it gets added to the Observable.
    As the code changes over time, you may end up not using it anymore. You may argue
    that you should remove the import at that point, but you might have a lot of code,
    and it is easy to overlook. It would be better if only used operators were included
    in the final bundle. It is, as we mentioned before, hard for the tree-shaking
    process to know what is used and what is not, with the current approach. For that
    reason, a big rewrite has happened in RxJS, adding something called pipeable operators,
    which help us with the above problem. There is also another downside to patching
    the prototype, and that is the fact that it creates a dependency. If the library
    changes and the operator is no longer added when we patch it (calling the import),
    then we have a problem. We won''t detect the problem until runtime. We would rather
    be told that the operator has gone through us importing and explicitly using it,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Creating reusable operators with let()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `let()` operator lets you have the whole operator and operate on it, rather
    than just manipulating the values as you would do with the `map()` operator, for
    example. Using the `let()` operator could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we were able to define a group of operators such as
    `addAndFilter` and `sub3` and use them on the stream with the `let()` operator.
    This enables us to create composable and reusable operators. It is with this very
    knowledge that we now move on to the concept of pipeable operators.
  prefs: []
  type: TYPE_NORMAL
- en: Shifting to pipeable operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned already, pipeable operators are here, and you can find them
    by importing the respective operators from the `rxjs/operators` directory, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To use it, we are now relying on the `pipe()` operator that we use as the parent
    operator, if you will. Using the preceding operators will therefore look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has taken us deep into RxJS by covering topics such as hot, cold,
    and warm Observables, and what that generally means in terms of when to subscribe
    to a stream and how they share their Producer under certain conditions. Next up,
    we covered Subjects, and the fact that Observable isn't the only thing you can
    subscribe to. Subjects also allow as to append values to the stream whenever we
    want, and we also learned that there exist different types of Subjects, depending
    on the situation at hand.
  prefs: []
  type: TYPE_NORMAL
- en: We ventured deeper into an important topic, testing, and tried to explain the
    difficulty in testing asynchronous code. We talked about the current state of
    the testing situation and what libraries to use here and now for your testing
    scenarios. Lastly, we covered pipeable operators, and our new preferred way of
    importing and composing operators to ensure we end up with the smallest possible
    bundle size.
  prefs: []
  type: TYPE_NORMAL
- en: With all this RxJS knowledge, it is now time to take on the Redux pattern and
    its core concepts in the coming chapter, so we are ready to tackle NgRx in the
    final chapter of this book. It's time to get excited, if you weren't before.
  prefs: []
  type: TYPE_NORMAL
