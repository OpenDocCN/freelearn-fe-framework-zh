<html><head></head><body>
<div id="_idContainer034">
<p><a id="_idTextAnchor140"/></p>
<h1 class="chapter-number" id="_idParaDest-75"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-76"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.2.1">Components and Pages</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The main building blocks of an Angular application are the </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">components</span></strong><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">It is by using them that we assemble our user</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.6.1"> interfaces and define the flow of the experience. </span><span class="koboSpan" id="kobo.6.2">In Angular architecture, components organize an application into reusable parts, making it easy to maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">and scale.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">In this chapter, we will explore the communication between components and thus assemble our pages using component composition, avoiding the anti-pattern of creating </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">monolithic interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">In this chapter, we’re going to cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">following topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Creating components</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Communication between components – inputs </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">and outputs</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Best practice – using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.16.1">TrackBy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.17.1"> property</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Separating responsibilities – smart and </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">presentation components</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Communication from the child component – </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">@Output</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.23.1">By the end of this chapter, you will be able to create reusable and easy-to-maintain components and pages, streamlining the development of your project and increasing your productivity and that of </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">your team.</span></span><a id="_idTextAnchor143"/></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.26.1">To follow the instructions in this chapter, you’ll need </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.28.1">Visual Studio </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">Code (</span></span><a href="https://code.visualstudio.com/Download"><span class="No-Break"><span class="koboSpan" id="kobo.30.1">https://code.visualstudio.com/Download</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.31.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Node.js 18 or </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">higher (</span></span><a href="https://nodejs.org/en/download/"><span class="No-Break"><span class="koboSpan" id="kobo.34.1">https://nodejs.org/en/download/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.35.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.36.1">The code files for this chapter are available </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">at </span></span><a href="https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch4"><span class="No-Break"><span class="koboSpan" id="kobo.38.1">https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch4</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.39.1">.</span></span><a id="_idTextAnchor145"/></p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.40.1">Creating components</span></h1>
<p><span class="koboSpan" id="kobo.41.1">Every interface created</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.42.1"> with Angular is a component in the architecture of the framework; therefore, theoretically, we could have our entire application in a </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">single component.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">As we studied in </span><a href="B19562_02.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.45.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.46.1">, </span><em class="italic"><span class="koboSpan" id="kobo.47.1">Organizing Your Application</span></em><span class="koboSpan" id="kobo.48.1">, it is best to separate your application into modules, and with components, we use the same reasoning by separating our interfaces into and composing them with different components, maximizing reuse </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">and maintainability.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">In this chapter, we will illustrate this with a gym diary application, as shown in the following figure – to focus on Angular, we will not use Angular Material, only HTML, CSS (in this case, Tailwind CSS), </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">and TypeScript.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.52.1"><img alt="Figure 4.1 – Gym diary application UI" src="image/B19562_04_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.53.1">Figure 4.1 – Gym diary application UI</span></p>
<p><span class="koboSpan" id="kobo.54.1">In this initial example, we created a component with just the HTML template and the CSS and TypeScript files are as they were created by Angular CLI. </span><span class="koboSpan" id="kobo.54.2">Here’s the top of the </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">page first:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.56.1">
&lt;div class="min-h-screen bg-gray-200"&gt;
  &lt;header class="bg-blue-500 py-4 text-white"&gt;
    &lt;div class="mx-auto max-w-6xl px-4"&gt;
      &lt;h1 class="text-2xl font-bold"&gt;Workout diary&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/header&gt;</span></pre> <p><span class="koboSpan" id="kobo.57.1">Using good HTML semantic</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.58.1"> practices, let’s create a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.60.1"> section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.61.1">
 &lt;main class="mx-auto mt-8 max-w-6xl px-4"&gt;
   &lt;section class="mb-8"&gt;
     &lt;h2 class="mb-4 text-xl font-bold"&gt;List of entries&lt;/h2&gt;
     &lt;ul class="rounded border shadow"&gt;
       &lt;li class="mb-4 border-b bg-white p-4"&gt;
         &lt;span class="font-bold"&gt;Date:&lt;/span&gt; 2023-03-20&lt;br /&gt;
         &lt;span class="font-bold"&gt;Exercise:&lt;/span&gt; Bench press&lt;br /&gt;
         &lt;span class="font-bold"&gt;Sets:&lt;/span&gt; 3&lt;br /&gt;
         &lt;span class="font-bold"&gt;Reps:&lt;/span&gt; 10
       &lt;/li&gt;
         &lt;!-- more entries here --&gt;
     &lt;/ul&gt;
   &lt;/section&gt;
   &lt;button
     class="rounded bg-blue-500 py-2 px-4 font-bold text-white hover:bg-blue-700"
   &gt;
     Add new entry
   &lt;/button&gt;
 &lt;/main&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.62.1">We can see that in the preceding example, the interface is designed and stylized, but it is not functional because the diary entries are fixed in HTML, and in our application, the user should be able to add as many entries as </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">they want.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">We can identify here that this</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.65.1"> part of the diary entry could be a component for the page to use, so let’s create a component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">entry</span></strong><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">As we learned in </span><a href="B19562_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.68.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.69.1">, </span><em class="italic"><span class="koboSpan" id="kobo.70.1">Starting Projects the Right Way</span></em><span class="koboSpan" id="kobo.71.1">, we are going to use the Angular CLI to create this new component in the module </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">we need:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.73.1">
ng g c diary/entry-item</span></pre> <p><span class="koboSpan" id="kobo.74.1">With this command, the Angular CLI will create a folder with the following four files in addition to updating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">diary</span></strong><span class="koboSpan" id="kobo.76.1"> module with the </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">new component.</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">entry-item.component.css</span></strong><span class="koboSpan" id="kobo.79.1">: This file will contain the component’s style sheet. </span><span class="koboSpan" id="kobo.79.2">Angular manages to solve a big pain point of a web application, which is the CSS scope of each component. </span><span class="koboSpan" id="kobo.79.3">With this feature, we can specify the component’s styling without having to worry about whether it will affect an application’s CSS even using the same property or </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">selector name.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">entry-item.component.html</span></strong><span class="koboSpan" id="kobo.82.1">: This file contains the component’s HTML template and, although the extension seems to indicate that we can only use HTML tags, in the template file, we can use Angular directives, as we will study in </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">this chapter.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">entry-item.component.spec.ts</span></strong><span class="koboSpan" id="kobo.85.1">: This file contains the unit test for the component, which we will detail in </span><a href="B19562_10.xhtml#_idTextAnchor264"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.86.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.87.1">, </span><em class="italic"><span class="koboSpan" id="kobo.88.1">Design for Tests: </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.89.1">Best Practices</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">entry-item.component.ts</span></strong><span class="koboSpan" id="kobo.92.1">: This is the TypeScript file that represents the component itself. </span><span class="koboSpan" id="kobo.92.2">All other files are optional, making it possible for you to create a component with just this file, although this is not a practice widely applied in Angular projects and is only recommended for very </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">small components.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.94.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">entry-item.component.ts</span></strong><span class="koboSpan" id="kobo.96.1"> file, the Angular CLI created the </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">following structure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.98.1">
import { Component } from '@angular/core';
@Component({
 selector: 'app-entry-item',
 templateUrl: './entry-item.component.html',
 styleUrls: ['./entry-item.component.css']
})
export class EntryItemComponent {
}</span></pre> <p><span class="koboSpan" id="kobo.99.1">With this example, we reinforce</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.100.1"> the definition that a component is a TypeScript class, and by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">@Component</span></strong><span class="koboSpan" id="kobo.102.1"> decorator, we indicate to Angular where the parts to assemble </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">it are.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">The main properties are </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">selector</span></strong><span class="koboSpan" id="kobo.107.1">: This is an optional property</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.108.1"> that defines what the component’s selector will be if it is used in the template of another component. </span><span class="koboSpan" id="kobo.108.2">Components that represent a page do not need to have a selector defined as they are instantiated from a route. </span><span class="koboSpan" id="kobo.108.3">The Angular CLI suggests the selector based on your application’s prefix defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">prefix</span></strong><span class="koboSpan" id="kobo.110.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">angular.json</span></strong><span class="koboSpan" id="kobo.112.1"> file, along with the name you defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">ng </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">g</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.115.1"> command.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">templateUrl</span></strong><span class="koboSpan" id="kobo.117.1">: This defines the path of the HTML file that contains the component’s template. </span><span class="koboSpan" id="kobo.117.2">Alternatively, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">template</span></strong><span class="koboSpan" id="kobo.119.1"> property to define a string with all the </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">component’s HTML.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">styleUrls</span></strong><span class="koboSpan" id="kobo.122.1">: This defines the path of the CSS files that contain the component’s styling. </span><span class="koboSpan" id="kobo.122.2">A detail of this property is that it is an array, so it is possible to have more than one CSS file linked to the component. </span><span class="koboSpan" id="kobo.122.3">Alternatively, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">style</span></strong><span class="koboSpan" id="kobo.124.1"> property to define a string containing the </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">component’s CSS.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.126.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">entry-item.component.html</span></strong><span class="koboSpan" id="kobo.128.1"> file, we will place</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.129.1"> the snippet that represents an item in a list of exercises in our </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">gym diary:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.131.1">
&lt;div class="mb-4 border-b bg-white p-4"&gt;
  &lt;span class="font-bold"&gt;Date:&lt;/span&gt; 2023-03-20&lt;br /&gt;
  &lt;span class="font-bold"&gt;Exercise:&lt;/span&gt; Bench press&lt;br /&gt;
  &lt;span class="font-bold"&gt;Sets:&lt;/span&gt; 3&lt;br /&gt;
  &lt;span class="font-bold"&gt;Reps:&lt;/span&gt; 10
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.132.1">Here, we have the representation of an item, with the difference being that we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">&lt;div&gt;</span></strong><span class="koboSpan" id="kobo.134.1"> element instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">&lt;li&gt;</span></strong><span class="koboSpan" id="kobo.136.1"> because we want our component to be as reusable as possible here – it may not necessarily be used within a list and within an </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">ul&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.139.1"> element.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">Let’s put our component to use. </span><span class="koboSpan" id="kobo.140.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">diary.component</span></strong><span class="koboSpan" id="kobo.142.1"> component, let’s refactor the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">diary.component.html</span></strong><span class="koboSpan" id="kobo.144.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.146.1">
&lt;div class="min-h-screen bg-gray-200"&gt;
  &lt;header class="bg-blue-500 py-4 text-white"&gt;
    &lt;div class="mx-auto max-w-6xl px-4"&gt;
      &lt;h1 class="text-2xl font-bold"&gt;Workout diary&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/header&gt;
  &lt;main class="mx-auto mt-8 max-w-6xl px-4"&gt;
    &lt;section class="mb-8"&gt;
      &lt;h2 class="mb-4 text-xl font-bold"&gt;List of entries&lt;/h2&gt;
      &lt;ul class="rounded border shadow"&gt;
        &lt;li&gt;
          </span><strong class="bold"><span class="koboSpan" id="kobo.147.1">&lt;app-entry-item /&gt;</span></strong><span class="koboSpan" id="kobo.148.1">
        &lt;/li&gt;
        &lt;li&gt;
          </span><strong class="bold"><span class="koboSpan" id="kobo.149.1">&lt;app-entry-item /&gt;</span></strong><span class="koboSpan" id="kobo.150.1">
        &lt;/li&gt;
        &lt;!-- more entries here --&gt;
      &lt;/ul&gt;
   &lt;/section&gt;
   &lt;button
     class="rounded bg-blue-500 py-2 px-4 font-bold text-white hover:bg-blue-700"
   &gt;
     Add new entry
   &lt;/button&gt;
 &lt;/main&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.151.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">app-entry-item</span></strong><span class="koboSpan" id="kobo.153.1"> selector, we are consuming</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.154.1"> our new component on the page. </span><span class="koboSpan" id="kobo.154.2">From version 15 of Angular, we can use self-closing tags for components, so we have used </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">&lt;app-entry-item /&gt;</span></strong><span class="koboSpan" id="kobo.156.1"> here, but if you prefer the previous way, </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">&lt;app-entry-item&gt;</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.158.1">&lt;/app-entry- item&gt;</span></strong><span class="koboSpan" id="kobo.159.1"> also </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">still </span><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.161.1">works.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">Running our project, we can see that it continues to work. </span><span class="koboSpan" id="kobo.162.2">However, the data is the same in both items. </span><span class="koboSpan" id="kobo.162.3">We now need a way to pass information between components, and we’ll see how to do that in the </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">next se</span><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.164.1">ction.</span></span></p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.165.1">Communication between components – inputs and outputs</span></h1>
<p><span class="koboSpan" id="kobo.166.1">In our gym diary application, we now need</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.167.1"> the workout list page component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.169.1">, to communicate with the list item </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">component, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">EntryItemComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">The simplest way to accomplish this communication is with Angular’s Property Binding concept. </span><span class="koboSpan" id="kobo.173.2">Despite the complicated</span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.174.1"> name, in practice, we annotate a component object’s property with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">@Input</span></strong><span class="koboSpan" id="kobo.176.1"> annotation, so Angular creates a custom HTML attribute on </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">the component.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">Let’s see this concept in practice; first, let’s create an interface that will represent an item in </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">our diary:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.180.1">
ng g interface diary/interfaces/exercise-set</span></pre> <p><span class="koboSpan" id="kobo.181.1">With the preceding command, we create the file and, as an organized practice, we create a folder to store the module’s interfaces. </span><span class="koboSpan" id="kobo.181.2">In the generated file, we will define the object we want to </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">communicate with:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.183.1">
export interface ExerciseSet {
  id?: string;
  date: Date;
  exercise: string;
  sets: number;
  reps: number;
}
export type ExerciseSetList = Array&lt;Exerc</span><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.184.1">iseSet&gt;;</span></pre> <p><span class="koboSpan" id="kobo.185.1">We create an interface defining the object and a type to define a list of exercises, improving the future readability of </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">our impleme</span><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.187.1">ntation.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">Now, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">entry-item.component.ts</span></strong><span class="koboSpan" id="kobo.190.1"> file, let’s add the </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">new property:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.192.1">
import { Component, Input } from '@angular/core';
import { ExerciseSet } from '../interfaces/exercise-set';
@Component({
 selector: 'app-entry-item',
 templateUrl: './entry-item.component.html',
 styleUrls: ['./entry-item.component.css']
})
export class EntryItemComponent {
  @Input('exercise-set') exerciseSet!:ExerciseSet;
}</span></pre> <p><span class="koboSpan" id="kobo.193.1">Here we create a property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">exerciseSet</span></strong><span class="koboSpan" id="kobo.195.1"> of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">ExerciseSet</span></strong><span class="koboSpan" id="kobo.197.1"> that we just defined. </span><span class="koboSpan" id="kobo.197.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">!</span></strong><span class="koboSpan" id="kobo.199.1"> symbol in the type definition because we are going to define its value </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">at runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">@Input</span></strong><span class="koboSpan" id="kobo.203.1"> annotation</span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.204.1"> receives the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">exercise-set</span></strong><span class="koboSpan" id="kobo.206.1"> string as a parameter. </span><span class="koboSpan" id="kobo.206.2">With this, we define the name </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.207.1">of the custom HTML attribute to be used in the template. </span><span class="koboSpan" id="kobo.207.2">This parameter is optional; if it's not used, the name of the attribute will be the name of the property. </span><span class="koboSpan" id="kobo.207.3">Here, it would </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">exerciseSet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">Let’s now change our template to use </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">this property:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.213.1">
&lt;div class="mb-4 border-b bg-white p-4"&gt;
  &lt;span class="font-bold"&gt;Date:&lt;/span&gt; {{ exerciseSet.date | date }}&lt;br /&gt;
  &lt;span class="font-bold"&gt;Exercise:&lt;/span&gt; {{ exerciseSet.exercise }}&lt;br /&gt;
  &lt;span class="font-bold"&gt;Sets:&lt;/span&gt; {{ exerciseSet.sets }}&lt;br /&gt;
  &lt;span class="font-bold"&gt;Reps:&lt;/span&gt; {{ exerciseSet.reps }}
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.214.1">To use the component’s properties inside the template, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">{{ }}</span></strong><span class="koboSpan" id="kobo.216.1"> syntax. </span><span class="koboSpan" id="kobo.216.2">Here, we can see an advantage of using VS Code with the Angular Language Service extension enabled because we have type-checking in the HTML template, avoiding typos, </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">for example.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">Something to highlight in this example is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">Date</span></strong><span class="koboSpan" id="kobo.220.1"> attribute. </span><span class="koboSpan" id="kobo.220.2">Here, we are using an Angular feature called </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">pipe</span></strong><span class="koboSpan" id="kobo.222.1">, which allows the formatting of a template element. </span><span class="koboSpan" id="kobo.222.2">In this case, we are formatting </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">a date.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">Let’s now configure</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.225.1"> a list of exercises in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">diary.component.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.227.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.228.1">
import { Component } from '@angular/core';
import { ExerciseSetList } from '../interfaces/exercise-set';
@Component({
 templateUrl: './diary.component.html',
 styleUrls: ['./diary.component.css'],
})
export class DiaryComponent {
  exerciseList: ExerciseSetList = [
    { id: '1', date: new Date(), exercise: 'Deadlift', reps: 15, sets: 3 },
    { id: '2', date: new Date(), exercise: 'Squat', reps: 15, sets: 3 },
    { id: '3', date: new Date(), exercise: 'Barbell row', reps: 15, sets:</span><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.229.1"> 3 },
 ];
}</span></pre> <p><span class="koboSpan" id="kobo.230.1">For this example, we create a property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">exerciseListExample</span></strong><span class="koboSpan" id="kobo.232.1"> and fill it with objects from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">ExerciseSet</span></strong><span class="koboSpan" id="kobo.234.1"> interface. </span><span class="koboSpan" id="kobo.234.2">Now, let’s change the list template in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">diary.component.html</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.236.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.237.1">
. </span><span class="koboSpan" id="kobo.237.2">. </span><span class="koboSpan" id="kobo.237.3">.
</span><span class="koboSpan" id="kobo.237.4">  &lt;section class="mb-8"&gt;
    &lt;h2 class="mb-4 text-xl font-bold"&gt;List of entries&lt;/h2&gt;
      &lt;ul class="rounded border shadow"&gt;
        &lt;li *ngFor="let item of exerciseList"&gt;
          &lt;app-entry-item [exercise-set]="item" /&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
  &lt;/section&gt;
. </span><span class="koboSpan" id="kobo.237.5">. </span><span class="koboSpan" id="kobo.237.6">.</span></pre> <p><span class="koboSpan" id="kobo.238.1">In the template, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">ngFor</span></strong><span class="koboSpan" id="kobo.240.1"> directive, which has the function of iterating over a list and rendering</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.241.1"> the element we want to define in the template. </span><span class="koboSpan" id="kobo.241.2">For each list item, we are going to create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">app-entry-item</span></strong><span class="koboSpan" id="kobo.243.1"> component and now we want to assign an item </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">To do that, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">[exercise-set]</span></strong><span class="koboSpan" id="kobo.247.1"> attribute to pass the item provided by </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">ngFor</span></strong><span class="koboSpan" id="kobo.249.1">. </span><span class="koboSpan" id="kobo.249.2">When we run our project, we have the list, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.251.1"><img alt="Figure 4.2 – Gym diary application UI after refactoring" src="image/B19562_04_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.252.1">Figure 4.2 – Gym diary application UI after refactoring</span></p>
<p><span class="koboSpan" id="kobo.253.1">With this, we understand</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.254.1"> how to pass information from one component to another, but we can improve this project by introducing a good performance practice, the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">Track</span><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.256.1">By</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.257.1"> property.</span></span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.258.1">Best practice – using the TrackBy property</span></h1>
<p><span class="koboSpan" id="kobo.259.1">After the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">*ngIf</span></strong><span class="koboSpan" id="kobo.261.1"> directive, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">ngFor</span></strong><span class="koboSpan" id="kobo.263.1"> directive will probably</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.264.1"> be the directive that you will use the most in your Angular projects. </span><span class="koboSpan" id="kobo.264.2">Although simple, this directive can hide a performance and perception problem in the frontend that will occur for </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">your user.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">To demonstrate this, let’s add a new list button, simulating a list update coming from </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">the backend.</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">diary.component.ts</span></strong><span class="koboSpan" id="kobo.270.1"> file, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">following method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.272.1">
 newList() {
   this.exerciseList = [
     { id: '1', date: new Date(), exercise: 'Deadlift', reps: 15, sets: 3 },
     { id: '2', date: new Date(), exercise: 'Squat', reps: 15, sets: 3 },
     { id: '3', date: new Date(), exercise: 'Barbell row', reps: 15, sets: 3 },
     { id: '4', date: new Date(), exercise: 'Leg Press', reps: 15, sets: 3 },
   ];
 }</span></pre> <p><span class="koboSpan" id="kobo.273.1">This method replaces the array</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.274.1"> with this new array, which contains the same elements but with one </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">more item.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">Let’s add the button to the </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">list template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.278.1">
&lt;br&gt;
&lt;br&gt;
  &lt;button
    class="rounded bg-blue-500 py-2 px-4 font-bold text-white hover:bg-blue-700"
    (click)="newList()"
   &gt;
     Server Sync
  &lt;/button&gt;</span></pre> <p><span class="koboSpan" id="kobo.279.1">When we click on the </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">Server Sync</span></strong><span class="koboSpan" id="kobo.281.1"> button, the entire item list is rendered, even though the new list is identical to the original except for the addition of a </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">new item.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.283.1"><img alt="Figure 4.3 – Chrome DevTools" src="image/B19562_04_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.284.1">Figure 4.3 – Chrome DevTools</span></p>
<p><span class="koboSpan" id="kobo.285.1">For a few items, this may not necessarily</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.286.1"> be a problem, but for a larger list, this unnecessary rendering may offend the performance perception our user will have of </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.288.1">To improve this kind of case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">ngFor</span></strong><span class="koboSpan" id="kobo.290.1"> directive has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">TrackBy</span></strong><span class="koboSpan" id="kobo.292.1"> option. </span><span class="koboSpan" id="kobo.292.2">Let’s refactor our code to demonstrate this option; first, let’s create a method for the exercise </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">list component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.294.1">
 itemTrackBy(index: number, item: ExerciseSet) {
   return item.id;
 }</span></pre> <p><span class="koboSpan" id="kobo.295.1">This method tells Angular how to identify the single element in a collection that it will iterate through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">*ngFor</span></strong><span class="koboSpan" id="kobo.297.1"> directive. </span><span class="koboSpan" id="kobo.297.2">Think of it as the </span><em class="italic"><span class="koboSpan" id="kobo.298.1">primary key</span></em><span class="koboSpan" id="kobo.299.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">the collection.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">In the component’s template, let’s change the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">ngFor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.303.1"> configuration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
&lt;section class="mb-8"&gt;
  &lt;h2 class="mb-4 text-xl font-bold"&gt;List of entries&lt;/h2&gt;
  &lt;ul class="rounded border shadow"&gt;
    </span><strong class="bold"><span class="koboSpan" id="kobo.305.1">&lt;li *ngFor="let item of exerciseList; index as i; trackBy: itemTrackBy"&gt;</span></strong><span class="koboSpan" id="kobo.306.1">
      &lt;app-entry-item [exercise-set]="item" /&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/section&gt;</span></pre> <p><span class="koboSpan" id="kobo.307.1">Here, we are telling </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">ngFor</span></strong><span class="koboSpan" id="kobo.309.1"> to render</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.310.1"> based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">id</span></strong><span class="koboSpan" id="kobo.312.1"> property of the object. </span><span class="koboSpan" id="kobo.312.2">Running it again in the browser with Chrome DevTools, we see that now only the item with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">id</span></strong><span class="koboSpan" id="kobo.314.1"> attribute is rendered on </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">the page.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">TrackBy</span></strong><span class="koboSpan" id="kobo.318.1"> attribute, in addition to avoiding unnecessary rendering, has the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">following advantages:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.320.1">Enables animations</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.321.1"> when removing and adding items from </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">the collection</span></span></li>
<li><span class="koboSpan" id="kobo.323.1">Retains any DOM-specific UI state, such as focus and text selection, when the </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">collection changes</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.325.1">Now that we’ve learned about the use of this </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">ngFor</span></strong><span class="koboSpan" id="kobo.327.1"> property, let’s study how we can architect the composition of our compo</span><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.328.1">nents </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">and pages.</span></span></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.330.1">Separating responsibilities – Smart and Presentation components</span></h1>
<p><span class="koboSpan" id="kobo.331.1">The information flow of a </span><strong class="bold"><span class="koboSpan" id="kobo.332.1">single-page application</span></strong><span class="koboSpan" id="kobo.333.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.334.1">SPA</span></strong><span class="koboSpan" id="kobo.335.1">) can be quite complex and, if you don’t think about this flow</span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.336.1"> from the beginning of your design, it can affect the productivity and quality of your project </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">The simpler the better; therefore, a very common</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.339.1"> design pattern not only in Angular applications but also in SPAs in general</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.340.1"> is the composition of interfaces using Smart and Presentation components. </span><span class="koboSpan" id="kobo.340.2">In literature and</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.341.1"> in the</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.342.1"> community, you will also find this pattern under the name of </span><strong class="bold"><span class="koboSpan" id="kobo.343.1">Smart</span></strong><span class="koboSpan" id="kobo.344.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.345.1">Dumb</span></strong><span class="koboSpan" id="kobo.346.1"> components or </span><strong class="bold"><span class="koboSpan" id="kobo.347.1">Container</span></strong><span class="koboSpan" id="kobo.348.1"> and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.349.1">Presentation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.350.1"> components.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">A Smart component has the UI business</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.352.1"> rule; it is where we will have injected the services that will communicate with the backend and where the interface with the Presentation components will </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">be composed.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">A Presentation component is a component that has</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.355.1"> the sole purpose of showing the data passed by the Smart component, normally via input. </span><span class="koboSpan" id="kobo.355.2">A Presentation component in turn can contain one or more components of the </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">Presentation type.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">To illustrate this pattern, we will use the </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.359.1"><img alt="Figure 4.4 – Smart and Presentation components" src="image/B19562_04_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.360.1">Figure 4.4 – Smart and Presentation components</span></p>
<p><span class="koboSpan" id="kobo.361.1">Notice that we have a source of truth, which is the Smart component, and the communication occurs in only one direction, this is what we call a Unidirectional Data Flow. </span><span class="koboSpan" id="kobo.361.2">The purpose of this pattern is to isolate all states within a component and thereby simplify </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">state management.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">Let’s refactor our project to fit this design pattern. </span><span class="koboSpan" id="kobo.363.2">Let’s create a new presentation component</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.364.1"> using the </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">Angular CLI:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.366.1">
ng g c diary/list-entries</span></pre> <p><span class="koboSpan" id="kobo.367.1">In this new component, we are going to move the part that renders the list of diary entries into your template. </span><span class="koboSpan" id="kobo.367.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">list-entries.component.html</span></strong><span class="koboSpan" id="kobo.369.1"> file, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.371.1">
&lt;section class="mb-8"&gt;
  &lt;h2 class="mb-4 text-xl font-bold"&gt;List of entries&lt;/h2&gt;
  &lt;ul class="rounded border shadow"&gt;
    &lt;li *ngFor="let item of exerciseList; index as i; trackBy: itemTrackBy"&gt;
      &lt;app-entry-item [exercise-set]="item" /&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/section&gt;</span></pre> <p><span class="koboSpan" id="kobo.372.1">The list that will be displayed will come ready from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.374.1"> component, so in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">list-entries.component.ts</span></strong><span class="koboSpan" id="kobo.376.1"> file, we will add the </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.378.1">
import { Component, Input } from '@angular/core';
import { ExerciseSet, ExerciseSetList } from '../interfaces/exercise-set';
@Component({
 selector: 'app-list-entries',
 templateUrl: './list-entries.component.html',
 styleUrls: ['./list-entries.component.css'],
})
export class ListEntriesComponent {
  @Input() exerciseList!: ExerciseSetList;
  itemTrackBy(index: number, item: ExerciseSet) {
    return item.id;
 }
}</span></pre> <p><span class="koboSpan" id="kobo.379.1">Here, we move the </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">itemTrackBy</span></strong><span class="koboSpan" id="kobo.381.1"> function into the component, as it will be its function to display</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.382.1"> the list, and we include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">exerciseList</span></strong><span class="koboSpan" id="kobo.384.1"> attribute with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">@Input</span></strong><span class="koboSpan" id="kobo.386.1"> decorator. </span><span class="koboSpan" id="kobo.386.2">In this example, we didn’t specify any parameters, so the name of the template’s attribute will be the same as the attribute of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">exerciseList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.388.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.389.1">Let’s change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">Diary</span></strong><span class="koboSpan" id="kobo.391.1"> template in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">diary.component.html</span></strong><span class="koboSpan" id="kobo.393.1"> file to use the new presentation component we </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">have created:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.395.1">
&lt;main class="mx-auto mt-8 max-w-6xl px-4"&gt;
  </span><strong class="bold"><span class="koboSpan" id="kobo.396.1">&lt;app-list-entries [exerciseList]="exerciseList" /&gt;</span></strong><span class="koboSpan" id="kobo.397.1">
  &lt;button
    class="rounded bg-blue-500 py-2 px-4 font-bold text-white hover:bg-blue-700"
  &gt;
    Add new entry
  &lt;/button&gt;
  &lt;br /&gt;
  &lt;br /&gt;
  &lt;button
    class="rounded bg-blue-500 py-2 px-4 font-bold text-white hover:bg-blue-700"
    (click)="newList()"
  &gt;
     erver Sync
  &lt;/button&gt;
 &lt;/main&gt;</span></pre> <p><span class="koboSpan" id="kobo.398.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.400.1"> Smart component just</span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.401.1"> passes the list to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">ListEntriesComponent</span></strong><span class="koboSpan" id="kobo.403.1"> Presentation component, which iterates</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.404.1"> over the list by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">EntryItemComponent</span></strong><span class="koboSpan" id="kobo.406.1"> Presentation component. </span><span class="koboSpan" id="kobo.406.2">With this structure, only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.408.1"> component needs to worry about the list of exercises, respecting SOLID’s Single </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">Responsibility concept.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">We’ve studied how to structure our pages and components, but how do child components communicate with their parents? </span><span class="koboSpan" id="kobo.410.2">Let’s learn about the output attributes o</span><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.411.1">f Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">components next.</span></span></p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.413.1">Communication from the child component – using  @Output</span></h1>
<p><span class="koboSpan" id="kobo.414.1">We studied how parent</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.415.1"> components, which can be either smart</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.416.1"> or presentational, can communicate with their child components by using attributes marked with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">Input</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.419.1"> decorator.</span></span></p>
<p><span class="koboSpan" id="kobo.420.1">However, when we need the opposite, the child component passes some information to the parent. </span><span class="koboSpan" id="kobo.420.2">As we saw in the previous section, business rule processing should ideally happen in the Smart component. </span><span class="koboSpan" id="kobo.420.3">For this type of communication, we mark attributes with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">Output</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.423.1"> decorator.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">Let’s create a button for adding an item to our diary. </span><span class="koboSpan" id="kobo.424.2">We’ll see the use of forms in </span><a href="B19562_06.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.425.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.426.1">, </span><em class="italic"><span class="koboSpan" id="kobo.427.1">Handling User Input: Forms</span></em><span class="koboSpan" id="kobo.428.1">, but here we want to focus on the interaction </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">between components.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">Using the Angular CLI, we will create the new component using </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">this command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.432.1">
ng g c diary/new-item-button</span></pre> <p><span class="koboSpan" id="kobo.433.1">In the new component’s template, let’s move the diary button template into </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">the component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.435.1">
&lt;button
  class="rounded bg-blue-500 py-2 px-4 font-bold text-white hover:bg-blue-700"
&gt;
  Add new entry
&lt;/button&gt;</span></pre> <p><span class="koboSpan" id="kobo.436.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">new-item-button.component.ts</span></strong><span class="koboSpan" id="kobo.438.1"> file, we will add</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.439.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">new</span></span><span class="No-Break"><a id="_idIndexMarker215"/></span><span class="No-Break"><span class="koboSpan" id="kobo.441.1"> attribute:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.442.1">
import { Component, EventEmitter, Output } from '@angular/core';
import { ExerciseSet } from '../interfaces/exercise-set';
@Component({
 selector: 'app-new-item-button',
 templateUrl: './new-item-button.component.html',
 styleUrls: ['./new-item-button.component.css'],
})
export class NewItemButtonComponent {
  @Output() newExerciseEvent = new EventEmitter&lt;ExerciseSet&gt;();
  addNewExercise() {
    const id = Date.now().toString();
    const date = new Date();
    const reps = 10;
    const sets = 4;
    const exercise = 'Leg Press';
    const newExerciseSet: ExerciseSet = { id, date, reps, sets, exercise };
    this.newExerciseEvent.emit(newExerciseSet);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.443.1">Here, we first create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">newExerciseEvent</span></strong><span class="koboSpan" id="kobo.445.1"> attribute and add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">@Output</span></strong><span class="koboSpan" id="kobo.447.1"> decorator to define that it will be an attribute present in the </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">component’s template.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">Here, there is a difference</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.450.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">@Input</span></strong><span class="koboSpan" id="kobo.452.1"> attribute; in this case, we are already assigning an object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">EventEmitter</span></strong><span class="koboSpan" id="kobo.454.1"> class to the variable. </span><span class="koboSpan" id="kobo.454.2">This Angular class</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.455.1"> aims to emit events when a certain action </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">takes place.</span></span></p>
<p><span class="koboSpan" id="kobo.457.1">This is necessary because, unlike </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">@Input</span></strong><span class="koboSpan" id="kobo.459.1">, the value of which is assigned when the component is structured and rendered, </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">@Output</span></strong><span class="koboSpan" id="kobo.461.1"> communication can occur at any time, depending on the </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">user’s action.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">EventEmitter</span></strong><span class="koboSpan" id="kobo.465.1"> class uses TypeScript’s type-checking capability, making it possible for us to determine what type of object we are going to emit to the </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">parent component.</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">addNewExercise</span></strong><span class="koboSpan" id="kobo.469.1"> method, we create an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">ExerciseSet</span></strong><span class="koboSpan" id="kobo.471.1">, and using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">emit</span></strong><span class="koboSpan" id="kobo.473.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">EventEmitter</span></strong><span class="koboSpan" id="kobo.475.1"> class, we pass this object to the </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">parent component.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">Back to the template – let’s add the method call to the button’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">click</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.479.1"> action:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.480.1">
&lt;button
  class="rounded bg-blue-500 py-2 px-4 font-bold text-white hover:bg-blue-700"
  (click)="addNewExercise()"
&gt;
  Add new entry
&lt;/button&gt;</span></pre> <p><span class="koboSpan" id="kobo.481.1">Now let’s refactor </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.483.1"> to consume the </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">new button:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.485.1">
. </span><span class="koboSpan" id="kobo.485.2">. </span><span class="koboSpan" id="kobo.485.3">.
</span><span class="koboSpan" id="kobo.485.4">&lt;main class="mx-auto mt-8 max-w-6xl px-4"&gt;
  &lt;app-list-entries [exerciseList]="exerciseList" /&gt;
  &lt;app-new-item-button (newExerciseEvent)="addExercise($event)" /&gt;
  &lt;br /&gt;
  &lt;br /&gt;
  &lt;button
    class="rounded bg-blue-500 py-2 px-4 font-bold text-white hover:bg-blue-700"
    (click)="newList()"
  &gt;
    Server Sync
  &lt;/button&gt;
 &lt;/main&gt;
. </span><span class="koboSpan" id="kobo.485.5">. </span><span class="koboSpan" id="kobo.485.6">.</span></pre> <p><span class="koboSpan" id="kobo.486.1">In the template, we are</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.487.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">app-new-item-button</span></strong><span class="koboSpan" id="kobo.489.1"> component</span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.490.1"> to pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">addExercise</span></strong><span class="koboSpan" id="kobo.492.1"> function to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">newExerciseEvent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.494.1"> attribute.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">Here, we can highlight that the binding of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">@Output</span></strong><span class="koboSpan" id="kobo.497.1"> attribute must be done with parentheses – </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">( )</span></strong><span class="koboSpan" id="kobo.499.1"> – and this </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">$event</span></strong><span class="koboSpan" id="kobo.501.1"> parameter represents the object that the child component will emit. </span><span class="koboSpan" id="kobo.501.2">If you highlight this parameter in VS Code, we can verify that it is of </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">ExerciseSet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">Finally, let’s create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">addExercise</span></strong><span class="koboSpan" id="kobo.507.1"> method in </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">the component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.509.1">
. </span><span class="koboSpan" id="kobo.509.2">. </span><span class="koboSpan" id="kobo.509.3">.
</span><span class="koboSpan" id="kobo.509.4">addExercise(newSet: ExerciseSet) {
   this.exerciseList.push(newSet);
 }
. </span><span class="koboSpan" id="kobo.509.5">. </span><span class="koboSpan" id="kobo.509.6">.</span></pre> <p><span class="koboSpan" id="kobo.510.1">Our method receives the emitted value and adds it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">exercises</span></strong><span class="koboSpan" id="kobo.512.1"> array. </span><span class="koboSpan" id="kobo.512.2">Running our project, we can see that the items are </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">successfully added.</span></span></p>
<p><span class="koboSpan" id="kobo.514.1">In this example, we can see in practice the whole flow of the design pattern of the Smart and presentation components. </span><span class="koboSpan" id="kobo.514.2">When clicking on the </span><strong class="bold"><span class="koboSpan" id="kobo.515.1">Add Exercises</span></strong><span class="koboSpan" id="kobo.516.1"> button, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">Diary</span></strong><span class="koboSpan" id="kobo.518.1"> Smart component receives the new exercise from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">NewItemButtonComponent</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.520.1">presentation component.</span></span></p>
<p><span class="koboSpan" id="kobo.521.1">By updating the list, the list</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.522.1"> is automatically passed</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.523.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">ListEntriesComponent</span></strong><span class="koboSpan" id="kobo.525.1"> component, which renders the list on the screen. </span><span class="koboSpan" id="kobo.525.2">Now we are going to implement actions for the items of the list of exercises – we will see how to emit events of these items</span><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.526.1"> and how to identify </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">these elements.</span></span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.528.1">Propagating events from nested components</span></h1>
<p><span class="koboSpan" id="kobo.529.1">We will add the options to delete</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.530.1"> an item from the list and increase the number of repetitions</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.531.1"> to our diary. </span><span class="koboSpan" id="kobo.531.2">First, let’s add the buttons to the list item template. </span><span class="koboSpan" id="kobo.531.3">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">entry-item.component.html</span></strong><span class="koboSpan" id="kobo.533.1"> file, we will edit </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">the template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.535.1">
&lt;div class="mb-4 flex items-center justify-between border-b bg-white p-4"&gt;
  &lt;div&gt;
    &lt;span class="font-bold"&gt;Date:&lt;/span&gt; {{ exerciseSet.date | date }}&lt;br /&gt;
    &lt;span class="font-bold"&gt;Exercise:&lt;/span&gt; {{ exerciseSet.exercise }}&lt;br /&gt;
    &lt;span class="font-bold"&gt;Sets:&lt;/span&gt; {{ exerciseSet.sets }}&lt;br /&gt;
    &lt;span class="font-bold"&gt;Reps:&lt;/span&gt; {{ exerciseSet.reps }}
  &lt;/div&gt;
  &lt;div class="flex items-center"&gt;
    &lt;button
      class="mr-2 rounded bg-red-500 py-2 px-4 font-bold text-white hover:bg-red-700"
    &gt;
      Delete
    &lt;/button&gt;
    &lt;button
      class="rounded bg-blue-500 py-2 px-4 font-bold text-white hover:bg-blue-700"
    &gt;
      New Rep
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.536.1">The challenge here is to ensure</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.537.1"> that the action that will happen</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.538.1"> on each item in the list if correctly identified to be applied correctly – that is, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">Diary</span></strong><span class="koboSpan" id="kobo.540.1"> Smart component that handles the list will find the corresponding item and </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">change it.</span></span></p>
<p><span class="koboSpan" id="kobo.542.1">For this, we will apply the Angular output feature to the </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">item component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.544.1">
 @Output() newRepEvent = new EventEmitter&lt;ExerciseSet&gt;();
 @Output() deleteEvent = new EventEmitter&lt;string&gt;();
 delete() {
   this.deleteEvent.emit(this.exerciseSet.id);
 }
 newRep() {
   const reps = ++this.exerciseSet.reps;
   const newItem: ExerciseSet = {
     ...this.exerciseSet,
     reps,
   };
   this.newRepEvent.emit(newItem);
 }</span></pre> <p><span class="koboSpan" id="kobo.545.1">We create two outputs, each one for a different event that we want to emit, and we type them because we need </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">different actions.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">We then create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">delete</span></strong><span class="koboSpan" id="kobo.549.1"> method, which will emit</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.550.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">id</span></strong><span class="koboSpan" id="kobo.552.1"> value of the item we want to delete, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">newRep</span></strong><span class="koboSpan" id="kobo.554.1"> method, with which we will add repetitions</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.555.1"> to the item of the exercise that will be performed and emit </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">that item.</span></span></p>
<p><span class="koboSpan" id="kobo.557.1">We will return to the template to associate the methods with the </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">buttons created:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.559.1">
   &lt;button
     class="mr-2 rounded bg-red-500 py-2 px-4 font-bold text-white hover:bg-red-700"
     </span><strong class="bold"><span class="koboSpan" id="kobo.560.1">(click)="delete()"</span></strong><span class="koboSpan" id="kobo.561.1">
   &gt;
     Delete
   &lt;/button&gt;
   &lt;button
     class="rounded bg-blue-500 py-2 px-4 font-bold text-white hover:bg-blue-700"
     </span><strong class="bold"><span class="koboSpan" id="kobo.562.1">(click)="newRep()"</span></strong><span class="koboSpan" id="kobo.563.1">
   &gt;
     New Rep
   &lt;/button&gt;</span></pre> <p><span class="koboSpan" id="kobo.564.1">Now let’s change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">list-entries.component</span></strong><span class="koboSpan" id="kobo.566.1"> presentation </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.567.1">component for creating the output, which here, for simplicity, will have</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.568.1"> the same name as the </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">item’s output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.570.1">
export class ListEntriesComponent {
 @Input() exerciseList!: ExerciseSetList;
</span><strong class="bold"><span class="koboSpan" id="kobo.571.1"> @Output() newRepEvent = new EventEmitter&lt;ExerciseSet&gt;();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.572.1"> @Output() deleteEvent = new EventEmitter&lt;string&gt;();</span></strong><span class="koboSpan" id="kobo.573.1">
. </span><span class="koboSpan" id="kobo.573.2">. </span><span class="koboSpan" id="kobo.573.3">.
</span><span class="koboSpan" id="kobo.573.4">}</span></pre> <p><span class="koboSpan" id="kobo.574.1">To propagate the item’s events, we will change the </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">list template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.576.1">
  &lt;li *ngFor="let item of exerciseList; index as i; trackBy: itemTrackBy"&gt;
    &lt;app-entry-item
      [exercise-set]="item"
      </span><strong class="bold"><span class="koboSpan" id="kobo.577.1">(deleteEvent)="deleteEvent.emit($event)"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.578.1">      (newRepEvent)="newRepEvent.emit($event)"</span></strong><span class="koboSpan" id="kobo.579.1">
    /&gt;
  &lt;/li&gt;</span></pre> <p><span class="koboSpan" id="kobo.580.1">We can see that we only emit the item’s event using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">emit</span></strong><span class="koboSpan" id="kobo.582.1"> method of </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">the outputs.</span></span></p>
<p><span class="koboSpan" id="kobo.584.1">Finally, we will refactor the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.586.1"> Smart component to react to the item’s event. </span><span class="koboSpan" id="kobo.586.2">First, let’s see </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">the template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.588.1">
&lt;main class="mx-auto mt-8 max-w-6xl px-4"&gt;
  &lt;app-list-entries
    [exerciseList]="exerciseList"
    (deleteEvent)="deleteItem($event)"
    (newRepEvent)="newRep($event)"
  /&gt;
 . </span><span class="koboSpan" id="kobo.588.2">. </span><span class="koboSpan" id="kobo.588.3">.
 </span><span class="koboSpan" id="kobo.588.4">&lt;/main&gt;</span></pre> <p><span class="koboSpan" id="kobo.589.1">As in the previous example, we used parentheses</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.590.1"> to associate it with a method, which will handle the event</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.591.1"> and receive the element emitted by the parameter of that method using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">$</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">event</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.594.1"> variable.</span></span></p>
<p><span class="koboSpan" id="kobo.595.1">We will now refactor the component by creating two new methods – one to delete a journal entry and one to create a new repetition for </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">an exercise:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.597.1">
. </span><span class="koboSpan" id="kobo.597.2">. </span><span class="koboSpan" id="kobo.597.3">.
</span><span class="koboSpan" id="kobo.597.4">deleteItem(id: string) {
  this.exerciseList = this.exerciseList.filter((item) =&gt; item.id !== id);
}
 newRep(exerciseSet: ExerciseSet) {
   const id = exerciseSet.id;
   const i = this.exerciseList.findIndex((item) =&gt; item.id === id);
   if (i &gt;= 0) {
     this.exerciseList[i] = { ...exerciseSet };
   }
 }
. </span><span class="koboSpan" id="kobo.597.5">. </span><span class="koboSpan" id="kobo.597.6">.</span></pre> <p><span class="koboSpan" id="kobo.598.1">We are using the TypeScript array methods to simulate deleting and changing the array of items. </span><span class="koboSpan" id="kobo.598.2">We can see that the method</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.599.1"> already receives the deletion item or id automatically due to Angular’s event</span><a id="_idIndexMarker233"/> <span class="No-Break"><span class="koboSpan" id="kobo.600.1">emission mechanism.</span></span></p>
<p><span class="koboSpan" id="kobo.601.1">We are taking advantage of the smart and presentation component pattern here to leverage its</span><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.602.1"> usage with a slightly more </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">complex requirement.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.604.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.605.1">In this chapter, we studied the elements responsible for rendering the interface of our project, the components. </span><span class="koboSpan" id="kobo.605.2">We saw how to create and organize the components in a granular way, resulting in our project being </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">more maintainable.</span></span></p>
<p><span class="koboSpan" id="kobo.607.1">We also studied how to communicate between components using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">@Input</span></strong><span class="koboSpan" id="kobo.609.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">@Output</span></strong><span class="koboSpan" id="kobo.611.1"> attributes, using the capabilities of Angular that facilitate </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">this communication.</span></span></p>
<p><span class="koboSpan" id="kobo.613.1">We saw the good practice of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">TrackBy</span></strong><span class="koboSpan" id="kobo.615.1"> to iterate lists in templates using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">ngFor</span></strong><span class="koboSpan" id="kobo.617.1"> directive, improving performance specifically for lists with </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">many items.</span></span></p>
<p><span class="koboSpan" id="kobo.619.1">Finally, we study the design pattern of the Smart and Presentation components, a way of organizing components and their interactions in order to simplify this orchestration with a unidirectional </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">information flow.</span></span></p>
<p><span class="koboSpan" id="kobo.621.1">In the next chapter, we will study the Angular elements responsible for the business rules and interaction with the backend – </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">the services.</span></span></p>
</div>
</body></html>