- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Adding Authentication with JWT
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JWT添加认证
- en: After developing and deploying our first full-stack application, we now have
    a way for anyone to create posts on our blog. However, since the author is an
    input field, anyone could enter any author, impersonating others! That’s not good.
    In this chapter, we are going to add authentication with **JSON Web Token** (**JWT**)
    and functionalities to sign up and log into our application by adding additional
    routes using React Router.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发和部署我们的第一个全栈应用程序后，我们现在有一种方式让任何人都可以在我们的博客上创建帖子。然而，由于作者是一个输入字段，任何人都可以输入任何作者，冒充他人！这不好。在本章中，我们将添加使用**JSON
    Web Token**（JWT）的认证以及通过添加额外的路由使用React Router来注册和登录我们的应用程序的功能。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What is JWT?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JWT是什么？
- en: Implementing login, signup, and authenticated routes in the backend using JWT
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后端使用JWT实现登录、注册和认证路由
- en: Integrating login and signup in the frontend using React Router and JWT
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Router和JWT在前端集成登录和注册
- en: Advanced token handling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级令牌处理
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before we start, please install all the requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing for Full-Stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请安装[*第1章*](B19385_01.xhtml#_idTextAnchor016)“为全栈开发做准备”和[*第2章*](B19385_02.xhtml#_idTextAnchor028)“了解Node.js和MongoDB”中提到的所有要求。
- en: The versions listed in those chapters are the ones used in this book. While
    installing a newer version should not be an issue, please note that certain steps
    might work differently. If you are having an issue with the code and steps provided
    in this book, please try using the versions mentioned in [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016)
    and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那些章节中列出的版本是本书中使用的版本。虽然安装较新版本不应有问题，但请注意，某些步骤可能会有所不同。如果您在这本书提供的代码和步骤中遇到问题，请尝试使用[*第1章*](B19385_01.xhtml#_idTextAnchor016)和[*第2章*](B19385_02.xhtml#_idTextAnchor028)中提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch6](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch6).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码：[https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch6](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch6)。
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/LloHmkgRLWk](https://youtu.be/LloHmkgRLWk).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可以在[https://youtu.be/LloHmkgRLWk](https://youtu.be/LloHmkgRLWk)找到。
- en: What is JWT?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JWT是什么？
- en: JWT, pronounced “jot”, is an open industry standard (RFC 7519) for safely passing
    claims between multiple parties. Claims can be information about a certain party
    or object, such as the email address, user ID, and roles of a user. In our case,
    we will pass JWTs between our backend and frontend.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JWT，发音为“jot”，是一个开放行业标准（RFC 7519），用于在多个当事人之间安全地传递声明。声明可以是关于某个当事人或对象的信息，例如用户的电子邮件地址、用户ID和角色。在我们的案例中，我们将在后端和前端之间传递JWT。
- en: JWT is used by many products and services and is supported by third-party authentication
    providers, such as Auth0, Okta, and Firebase Auth. It is easy to parse JWTs as
    we only need to base64 decode them and parse the JSON string. After verifying
    the signature, we can be sure that the JWT is authentic and trust the claims within
    it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JWT被许多产品和服务使用，并得到第三方认证提供商的支持，如Auth0、Okta和Firebase Auth。解析JWT很容易，我们只需要对它们进行base64解码并解析JSON字符串。在验证签名后，我们可以确信JWT是真实的，并信任其中的声明。
- en: 'JWTs consist of the following components:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JWT由以下组件组成：
- en: '**Header**: Containing the algorithm and token type'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部**：包含算法和令牌类型'
- en: '**Payload**: Containing the data/claims of the token'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效载荷**：包含令牌的数据/声明'
- en: '**Signature**: For verifying that the token was created by a legit source'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名**：用于验证令牌是否由合法来源创建'
- en: 'These three components form a JWT as they’re joined into a single string, separated
    by a period (`.`), as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个组件通过点（`.`）连接成一个字符串，形成一个JWT，如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s look at each component separately.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分别查看每个组件。
- en: JWT header
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT头
- en: 'The JWT header typically consists of a token type (in our case, JWT), specified
    by the `typ` property, and the algorithm used to create the signature (in our
    case, we will use HMAC SHA256, a SHA256 hash-based message authentication code),
    specified by the `alg` property. The header is defined as a JSON object, like
    so:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JWT头部通常由一个令牌类型（在我们的情况下，JWT），由`typ`属性指定，以及用于创建签名的算法（在我们的情况下，我们将使用基于SHA256哈希的消息认证码HMAC
    SHA256），由`alg`属性指定。头部被定义为JSON对象，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This JSON object is then base64 encoded and forms the first part of the JWT.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此JSON对象随后被base64编码，形成JWT的第一部分。
- en: JWT payload
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT有效载荷
- en: 'The main part of the JWT is the payload, which contains all claims. Claims
    are information about an entity (such as the user) and additional data. The JWT
    standard distinguishes between three types of claims:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: JWT的主要部分是有效载荷，它包含所有声明。声明是关于实体的信息（例如用户）和附加数据。JWT标准区分三种类型的声明：
- en: '**Registered claims**: These are predefined claims and it’s recommended that
    they’re set. They include information about the following:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已注册声明**：这些是预定义的声明，建议设置它们。它们包括以下信息：'
- en: The issuer (**iss**), which is the entity that created the token.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发行者（**iss**），即创建令牌的实体。
- en: The expiration time (**exp**), which tells us when the token expires.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过期时间（**exp**），它告诉我们令牌何时过期。
- en: The subject (**sub**), which tells us about the entity identified by the token
    (such as the user who generated the token during a login).
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题（**sub**），它告诉我们由令牌标识的实体信息（例如，在登录过程中生成令牌的用户）。
- en: The audience (**aud**), which tells us about the intended recipients of the
    token.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受众（**aud**），它告诉我们令牌的预期接收者。
- en: The issued at time (**iat**), which tells us when the token was created.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布时间（**iat**），它告诉我们令牌何时创建。
- en: The not before time (**nbf**), which specifies a time before which the token
    is not valid yet.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不早于时间（**nbf**），它指定一个时间点，在此时间点之前令牌尚未有效。
- en: The JWT ID (**jti**), which provides a unique identifier for the JWT. It’s used
    to prevent JWTs from being replayed.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JWT ID（**jti**），它为JWT提供唯一标识符。它用于防止JWT被重放。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The JSON object properties defined in the JWT standard are all three-letter
    names to keep the JWT as compact as possible.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: JWT标准中定义的JSON对象属性都是三字母名称，以使JWT尽可能紧凑。
- en: '**Public claims**: These are additional claims that are commonly used and shared
    across many services. A list of those can be found on the **Internet Assigned
    Numbers Authority** (**IANA**) website: [https://www.iana.org/assignments/jwt/jwt.xhtml](https://www.iana.org/assignments/jwt/jwt.xhtml).
    If we want to store additional information, we should always consult this list
    first to see if we can use a standardized claim name.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共声明**：这些是常用且在许多服务中共享的额外声明。这些声明的列表可以在**互联网数字分配机构**（**IANA**）网站上找到：[https://www.iana.org/assignments/jwt/jwt.xhtml](https://www.iana.org/assignments/jwt/jwt.xhtml)。如果我们想存储额外的信息，我们应该首先咨询这个列表，看看是否可以使用标准化的声明名称。'
- en: '**Private claims**: These are custom-defined claims, which are neither registered
    nor public. If we need a special claim that isn’t defined yet, we can make a private
    claim that only our services will understand.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有声明**：这些是自定义定义的声明，既不是已注册的也不是公共的。如果我们需要一个尚未定义的特殊声明，我们可以创建一个只有我们的服务才能理解的私有声明。'
- en: All claims are optional, but it makes sense to at least include one claim to
    identify the subject, such as the `sub` registered claim.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有声明都是可选的，但至少包括一个声明来识别主题是有意义的，例如`sub`已注册声明。
- en: 'Putting together what we’ve learned, we can create the following example payload:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们所学的知识整合起来，我们可以创建以下示例有效载荷：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our example, the `sub` claim is a registered claim, the `name` claim is a
    public claim, and the `admin` claim is a private claim.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`sub`声明是一个已注册的声明，`name`声明是一个公共声明，而`admin`声明是一个私有声明。
- en: The payload is also base64 encoded and forms the second part of the JWT. As
    such, this information is publicly readable by anyone who has access to the token.
    Do not put secret information into the payload or header of a JWT! However, the
    information cannot be *changed* without invalidating the existing signature, making
    all claims tamper-proof. Only a backend service with access to the private key
    can generate a new signature to create a valid JWT.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有效载荷也被base64编码，形成JWT的第二部分。因此，这些信息对任何有权访问令牌的人都是公开可读的。不要将机密信息放入JWT的有效载荷或头部！然而，信息不能被*更改*而不使现有签名无效，使所有声明防篡改。只有具有访问私钥的后端服务才能生成新的签名以创建有效的JWT。
- en: JWT signature
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT签名
- en: 'The final part of a JWT is its signature. The signature is what proves that
    all the information that we’ve defined up until now has not been tampered with.
    The signature is created by taking the base64-encoded header and payload, joining
    those strings with a period symbol, and using the specified algorithm to sign
    it with a secret key:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JWT的最后部分是其签名。签名证明了我们之前定义的所有信息都没有被篡改。签名是通过将base64编码的头部和负载合并，用句号连接这些字符串，并使用指定的算法用密钥签名来创建的：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we’ve learned about the different components of a JWT, let’s put this
    all together to create a valid JWT.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了JWT的不同组件，让我们将这些内容全部放在一起来创建一个有效的JWT。
- en: Creating a JWT
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建JWT
- en: 'Follow these steps to create a JWT:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个JWT：
- en: Go to the [https://jwt.io/](https://jwt.io/) website and scroll down to the
    **Debugger** section.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://jwt.io/](https://jwt.io/)网站，并滚动到**调试器**部分。
- en: Enter our previously defined header and payload.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入我们之前定义的头部和负载。
- en: Enter **full-stack** as the secret.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**全栈**作为密钥。
- en: The encoded JWT should update on the fly as you’re changing the values.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码的JWT应该在你更改值时实时更新。
- en: 'As you can see, we have successfully created our first JWT:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经成功创建了第一个JWT：
- en: '![Figure 6.1 – Our first JWT, created with the jwt.io debugger](img/B19385_06_1.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 使用jwt.io调试器创建的第一个JWT](img/B19385_06_1.jpg)'
- en: Figure 6.1 – Our first JWT, created with the jwt.io debugger
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 使用jwt.io调试器创建的第一个JWT
- en: The generated JWT consists of three components, each of them base64-encoded
    and separated by periods. In the debugger, they are highlighted in three different
    colors. Try changing the base64 string in the “Encoded” section by removing some
    characters; you will see that the JWT is now invalid due to an ”Invalid Signature”
    issue. Now that we’ve created our first JWT, let’s learn how to use it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的JWT由三个组件组成，每个组件都是base64编码的，并用句号分隔。在调试器中，它们用三种不同的颜色突出显示。尝试通过从“编码”部分的base64字符串中删除一些字符来更改它；你会看到JWT现在因“无效签名”问题而无效。现在我们已经创建了第一个JWT，让我们学习如何使用它。
- en: Using JWT
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JWT
- en: 'In the login process, we are going to generate a JWT for the logged-in user
    in the backend. This JWT will be returned to the user’s browser. When the user
    wants to access a protected route, we can send the JWT to the backend server by
    using the `Authorization` header with the `Bearer` schema, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录过程中，我们将在后端为登录用户生成一个JWT。这个JWT将被返回给用户的浏览器。当用户想要访问受保护的路由时，我们可以通过使用带有“Bearer”模式的`Authorization`头部将JWT发送到后端服务器，如下所示：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The backend can then check for this header, verify the signature of the token,
    and grant the user access to certain routes. By sending the token in a header
    instead of a cookie, we don’t have to deal with CORS issues that we would have
    when dealing with cookies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 后端可以检查这个头部，验证令牌的签名，并授予用户访问某些路由的权限。通过在头部而不是cookie中发送令牌，我们不必处理处理cookie时可能遇到的CORS问题。
- en: Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful not to send too much data in the header since some servers do not
    accept more than 8 KB in headers. This means that, for example, complex role information
    should not be stored in the JWT claims as it might take up too much space. Instead,
    this kind of information could be stored in the database associated with a user
    ID from the JWT.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要在头部发送太多数据，因为一些服务器不接受超过8 KB的头部。这意味着，例如，复杂的角色信息不应存储在JWT声明中，因为它可能会占用太多空间。相反，这类信息可以存储在与JWT中的用户ID关联的数据库中。
- en: An interesting advantage of using a JWT is that the authentication server and
    the actual backend for our app do not have to be the same. We could have a separate
    authentication service, get a JWT, and in the backend verify the signature of
    the JWTs to guarantee that they were generated by the authentication service.
    This allows us to use external services for authentication, such as Auth0, Okta,
    or Firebase Auth.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JWT的一个有趣的优势是，认证服务器和我们的应用的实际后端不必是同一个。我们可以有一个独立的认证服务，获取一个JWT，然后在后端验证JWT的签名，以确保它们是由认证服务生成的。这允许我们使用外部服务进行认证，例如Auth0、Okta或Firebase
    Auth。
- en: 'The following diagram shows the authorization flow for a JWT:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了JWT的授权流程：
- en: '![Figure 6.2 – Authorization flow for a JWT](img/B19385_06_2.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – JWT的授权流程](img/B19385_06_2.jpg)'
- en: Figure 6.2 – Authorization flow for a JWT
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – JWT的授权流程
- en: As we can see, the application requests authorization to the authorization server,
    which can also be either a third-party provider, a separate service, or part of
    the backend service. Then, when authorization is granted (if the login details
    are correct), the authorization server returns a JWT. This JWT can then be used
    to access protected routes on APIs. Before granting access, the JWT signature
    is validated to ensure that it has not been tampered with.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，应用程序请求授权服务器进行授权，这也可以是第三方提供者、独立服务或后端服务的一部分。然后，当授权被授予（如果登录详情正确），授权服务器返回一个JWT。然后可以使用这个JWT来访问API上的受保护路线。在授予访问权限之前，JWT签名被验证以确保它没有被篡改。
- en: Storing JWT
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储 JWT
- en: We should take great care about where we store the JWT. Local storage is *not*
    a good way to store authentication information such as a JWT. Cross-site scripting
    can be used to steal all data in local storage. For short-lived tokens, we can
    store them in a JavaScript runtime variable (such as a React context). For longer-term
    storage, we could use an `httpOnly` cookie, which has additional security guarantees.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该非常小心地考虑我们存储JWT的位置。本地存储并不是存储如JWT之类的认证信息的好方法。跨站脚本可以用来窃取本地存储中的所有数据。对于短期令牌，我们可以将它们存储在JavaScript运行时变量（如React上下文）中。对于长期存储，我们可以使用具有额外安全保证的`httpOnly`cookie。
- en: Now that we’ve learned how JWT works, let’s put theory into practice and implement
    login, signup, and authenticated routes in the backend using JWT.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了JWT的工作原理，让我们将理论付诸实践，在后端使用JWT实现登录、注册和认证路线。
- en: Implementing login, signup, and authenticated routes in the backend using JWTs
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JWT在后端实现登录、注册和认证路线
- en: Now that we’ve learned about JWTs, we’ll implement them in our backend. First,
    we need to create a user model in our database, after which we can create routes
    to sign up and log into our app. Finally, we will implement authenticated routes
    that are only accessible with a JWT.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了JWT，我们将在后端实现它们。首先，我们需要在数据库中创建一个用户模型，然后我们可以创建注册和登录应用的路线。最后，我们将实现需要JWT才能访问的认证路线。
- en: Creating the user model
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户模型
- en: 'We’ll start the backend implementation by creating a user model, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始后端实现，创建一个用户模型，如下所示：
- en: 'Copy the **ch5** folder to a new **ch6** folder, as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**ch5**文件夹复制到一个新的**ch6**文件夹，如下所示：
- en: '[PRE5]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Open the **ch6** folder in VS Code.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开**ch6**文件夹。
- en: 'Create a new **backend/src/db/models/user.js** file and define a new **userSchema**
    inside it:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**backend/src/db/models/user.js**文件，并在其中定义一个新的**userSchema**：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A user should have a required unique **username** and a required **password**:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户应该有一个必需的唯一**用户名**和一个必需的**密码**：
- en: '[PRE7]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create and export the model:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并导出模型：
- en: '[PRE8]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At this point, let’s also adjust the post model so that we can store a reference
    to a user ID instead of the username as the author. Edit **backend/src/db/models/post.js**,
    as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，让我们也调整一下帖子模型，以便我们可以存储一个用户ID的引用而不是作者的用户名。编辑**backend/src/db/models/post.js**，如下所示：
- en: '[PRE9]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we’ve successfully created the user model, let’s move on to creating
    the signup service so that we have a way to create new users.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功创建了用户模型，让我们继续创建注册服务，以便我们有一种创建新用户的方法。
- en: Creating the signup service
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建注册服务
- en: When a user signs up, we need to hash the password provided by the user before
    storing it in the database. We should never store passwords in plaintext as that
    would mean that if our database gets leaked, an attacker will have access to the
    passwords of all users. Hashing is a one-way function that turns a string into
    a different string in a deterministic way. This means that, for example, if we
    do `hash("password1")`, we get a specific string every time we do it. However,
    if we do `hash("password2")`, we get a completely different string. By choosing
    a good hash function, we can ensure that reversing a hash is so computationally
    expensive that it is impossible to do in a reasonable time. When the user signs
    up, we can store the hash of their password. When a user then enters their password
    to log in, we can hash their entered password again and compare it to the hash
    in the database.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户注册时，我们需要在将其存储在数据库之前对用户提供的密码进行散列。我们绝不应该以明文形式存储密码，因为这意味着如果我们的数据库泄露，攻击者将能够访问所有用户的密码。散列是一个单向函数，以确定的方式将字符串转换为不同的字符串。这意味着，例如，如果我们执行`hash("password1")`，每次执行都会得到一个特定的字符串。然而，如果我们执行`hash("password2")`，我们会得到一个完全不同的字符串。通过选择一个好的散列函数，我们可以确保逆向散列的计算成本如此之高，以至于在合理的时间内无法完成。当用户注册时，我们可以存储他们密码的散列。当用户输入密码登录时，我们可以再次散列他们输入的密码，并将其与数据库中的散列进行比较。
- en: 'Let’s start implementing the signup service with hashed passwords:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现带有散列密码的注册服务：
- en: 'Install the **bcrypt** npm package. We are going to use this to hash the password
    before storing it:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装**bcrypt**npm包。我们将使用它来在存储之前散列密码：
- en: '[PRE10]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a new **backend/src/services/users.js** file and import **bcrypt** and
    the **User** model:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**backend/src/services/users.js**文件并导入**bcrypt**和**User**模型：
- en: '[PRE11]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define a **createUser** function that takes **username** and **password** values:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个**createUser**函数，它接受**username**和**password**值：
- en: '[PRE12]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Inside this function, we use the **bcrypt.hash** function to create a hash
    from the plaintext password using 10 salt rounds (repeating the hashing 10 times
    to make it even harder to reverse it):'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们使用**bcrypt.hash**函数通过10轮盐值（重复10次散列以使其更难逆向）从明文密码创建散列：
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can create a new user and store it in our database:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个新的用户并将其存储在我们的数据库中：
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For brevity, we won’t cover creating tests for the user services. Refer to [*Chapter
    3*](B19385_03_split_000.xhtml#_idTextAnchor050), *Implementing a Backend Service
    Using Express, Mongoose ODM, and Jest*, for information on how to create tests
    for your service functions. You can write similar tests to what we did for the
    posts service functions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，我们不会涵盖为用户服务创建测试。有关如何为您的服务函数创建测试的信息，请参阅[*第3章*](B19385_03_split_000.xhtml#_idTextAnchor050)，*使用Express、Mongoose
    ODM和Jest实现后端服务*。您可以编写与我们为帖子服务函数所做的类似的测试。
- en: After creating the signup service, we can create the signup route.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建注册服务之后，我们可以创建注册路由。
- en: Creating the signup route
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建注册路由
- en: 'Now, let’s expose the signup service function by adding an API route for it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加一个API路由来暴露注册服务功能：
- en: 'Create a new **backend/src/routes/users.js** file and import the **createUser**
    service:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**backend/src/routes/users.js**文件并导入**createUser**服务：
- en: '[PRE15]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define a new **userRoutes** function and expose a **POST /api/v1/user/signup**
    route. This route creates a new user from the request body and return the username:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的**userRoutes**函数并暴露一个**POST /api/v1/user/signup**路由。此路由从请求体中创建一个新的用户并返回用户名：
- en: '[PRE16]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, we define a singular `user` route instead of calling it `users`
    as we are only dealing with one user at a time. To keep things simple, the error
    handling is very rudimentary. It would be a good idea to distinguish between the
    different errors that can happen and show a different error message, depending
    on the error.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们定义了一个单独的`user`路由而不是`users`，因为我们一次只处理一个用户。为了保持简单，错误处理非常基础。区分可能发生的不同错误并显示不同的错误消息将是一个好主意。
- en: 'Edit **backend/src/app.js** and import the **userRoutes** function:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**backend/src/app.js**并导入**userRoutes**函数：
- en: '[PRE17]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the same file, call the **userRoutes** function after the **postRoutes**
    function to mount them:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，在**postRoutes**函数之后调用**userRoutes**函数以挂载它们：
- en: '[PRE18]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Make sure the **dbserver** container is running in Docker.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Docker中的**dbserver**容器正在运行。
- en: 'Start the backend by running the following command in a Terminal inside the
    **backend/** folder:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**backend/**文件夹内的终端中运行以下命令以启动后端：
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, make a request to the new **POST /api/v1/user/signup** route. You will
    see that creating a user works if **username** and **password** values are provided
    properly. Enter the following code in your browser console while the backend is
    running, on a blank tab or at **http://localhost:3001/**:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向新的**POST /api/v1/user/signup**路由发送请求。您将看到，如果提供了正确的**username**和**password**值，创建用户是有效的。在后台运行时，在空白标签页或**http://localhost:3001/**中输入以下代码：
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If we try creating another user with the same username (by executing the same
    fetch again), it will fail because the **username** field is defined to be unique
    in Mongoose.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试使用相同的用户名（通过再次执行相同的fetch）创建另一个用户，它将失败，因为**username**字段在Mongoose中被定义为唯一的。
- en: Now that we have successfully created our first user, let’s continue by creating
    the login service to allow our user to log in.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功创建了第一个用户，让我们继续创建登录服务，以便我们的用户能够登录。
- en: Creating the login service
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建登录服务
- en: 'So far, we have only created a user in our database. As we aren’t authorizing
    the user yet, we haven’t dealt with JWTs yet. Let’s start doing that now:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在数据库中创建了一个用户。因为我们还没有对用户进行授权，所以我们还没有处理JWTs。现在让我们开始处理：
- en: 'Open a new Terminal and install the **jsonwebtoken** library, which contains
    functions to deal with the creation and verification of JWTs:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并安装**jsonwebtoken**库，它包含处理JWT创建和验证的函数：
- en: '[PRE21]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Edit the **backend/src/services/users.js** file and import **jwt** from the
    **jsonwebtoken** library:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**backend/src/services/users.js**文件并从**jsonwebtoken**库中导入**jwt**：
- en: '[PRE22]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define a new **loginUser** function, which takes a username and password:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的**loginUser**函数，它接受用户名和密码：
- en: '[PRE23]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, fetch a user with the given **username** from our database:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从我们的数据库中获取具有给定**username**的用户：
- en: '[PRE24]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, use **bcrypt.compare** to compare the entered password to the hashed
    password from the database:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用**bcrypt.compare**比较输入的密码与数据库中的散列密码：
- en: '[PRE25]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If the user correctly enters a username and password, we use **jwt.sign()**
    to create a new JWT and sign it with a secret. For the secret, we use an environment
    variable:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户正确输入用户名和密码，我们使用**jwt.sign()**创建一个新的JWT并用一个密钥签名。对于密钥，我们使用一个环境变量：
- en: '[PRE26]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the last argument, we also specify that our token should be valid for 24
    hours.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在最后一个参数中，我们还指定我们的令牌应该有效期为24小时。
- en: Note
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are using the user ID, not the username, to identify the user. This is done
    to future-proof the system as the user ID is a value that will never change. In
    the future, we might want to add a way to change the username. It would be hard
    to deal with such a change if we always use the username to identify the user.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用用户ID而不是用户名来识别用户。这样做是为了使系统具有未来性，因为用户ID是一个永远不会改变的值。将来，我们可能想添加一个更改用户名的方法。如果我们总是使用用户名来识别用户，处理这样的更改将很困难。
- en: 'Lastly, we return the token:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们返回令牌：
- en: '[PRE27]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we define the **JWT_SECRET** environment variable by editing the **.****env**
    file:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过编辑**.****env**文件来定义**JWT_SECRET**环境变量：
- en: '[PRE28]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Make sure you generate a safe JWT secret for the production environment, which
    you never expose or use in development environments or for debugging! If you want
    to deploy your app to Google Cloud Run again, you would also need to add this
    secret as an environment variable there.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保您为生产环境生成一个安全的JWT密钥，您永远不会在开发环境中或用于调试时暴露或使用它！如果您想再次将您的应用程序部署到Google Cloud Run，您还需要将此密钥作为环境变量添加到那里。
- en: 'We’ll also add one to **.env.template** as an example:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还会在**.env.template**中添加一个示例：
- en: '[PRE29]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After successfully creating a login service to create and sign JWTs, we can
    create the login route.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建用于创建和签名JWTs的登录服务之后，我们可以创建登录路由。
- en: Creating the login route
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建登录路由
- en: 'We still need to expose the login service as an API route for users to be able
    to log in. Let’s do that now:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要将登录服务作为API路由公开，以便用户能够登录。现在让我们来做这件事：
- en: 'Edit the **backend/src/routes/users.js** file and import the **loginUser**
    function:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**backend/src/routes/users.js**文件并导入**loginUser**函数：
- en: '[PRE30]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add a new **POST /api/v1/user/login** route inside the **userRoutes** function,
    where we call the **loginUser** function and return the token:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**userRoutes**函数内部添加一个新的**POST /api/v1/user/login**路由，其中我们调用**loginUser**函数并返回令牌：
- en: '[PRE31]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the backend is not running anymore, start it again. Then, make a request
    to **/api/v1/user/login** to test it out by entering the following code in your
    browser console:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果后端不再运行，请重新启动它。然后，通过在您的浏览器控制台中输入以下代码来请求**/api/v1/user/login**以测试它：
- en: '[PRE32]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We have successfully created a valid JWT! To verify that the JWT is valid,
    we can paste it into the debugger at [https://jwt.io/](https://jwt.io/). Make
    sure that you also change the secret in the **Verify Signature** section on the
    page, as shown in the following screenshot:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经成功创建了一个有效的JWT！为了验证JWT是否有效，我们可以将其粘贴到[https://jwt.io/](https://jwt.io/)的调试器中。确保您还更改了页面上的**Verify
    Signature**部分中的密钥，如下面的截图所示：
- en: '![Figure 6.3 – Verifying the JWT created from the login service](img/B19385_06_3.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 验证从登录服务创建的JWT](img/B19385_06_3.jpg)'
- en: Figure 6.3 – Verifying the JWT created from the login service
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 验证从登录服务创建的JWT
- en: Note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When copying the token from the JSON response in your browser, make sure that
    you are copying the full string value, and not the truncated one (with **…** in
    the middle of the string). Otherwise, the JWT might not decode properly in the
    debugger.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当从浏览器中的JSON响应中复制令牌时，确保您复制的是完整的字符串值，而不是截断的值（字符串中间有**…**）。否则，JWT可能在调试器中无法正确解码。
- en: After successfully logging our user in and creating a token for them, we can
    now protect certain routes and make sure that only logged-in users can access
    them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功登录用户并为他们创建令牌之后，我们现在可以保护某些路由并确保只有登录用户可以访问它们。
- en: Defining authenticated routes
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义认证路由
- en: 'Now that we have successfully created a valid JWT, we can start protecting
    routes. To do so, we are going to use the `express-jwt` library, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功创建了一个有效的JWT，我们可以开始保护路由。为此，我们将使用`express-jwt`库，如下所示：
- en: 'Install the **express-jwt** npm package:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装**express-jwt**npm包：
- en: '[PRE33]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a new **backend/src/middleware** folder. Inside it, create a new **backend/src/middleware/jwt.js**
    file and import **expressjwt** there:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**backend/src/middleware**文件夹中创建一个新的文件夹。在其内部，创建一个新的**backend/src/middleware/jwt.js**文件，并在其中导入**expressjwt**：
- en: '[PRE34]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create and export a **requireAuth** middleware by using the **expressjwt**
    function and your secret and algorithm settings:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**expressjwt**函数和您的密钥和算法设置创建并导出**requireAuth**中间件：
- en: '[PRE35]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We need to use a function for the secret because `dotenv` isn’t initialized
    at import time yet, so the environment variable will only be available later.
    Specifying the algorithms is required to prevent potential downgrade attacks.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要使用一个函数来处理密钥，因为`dotenv`在导入时还没有初始化，所以环境变量将只能在之后才可用。指定算法是必需的，以防止潜在的降级攻击。
- en: 'Edit **backend/src/routes/posts.js** and import the **requireAuth** middleware:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**backend/src/routes/posts.js**并导入**requireAuth**中间件：
- en: '[PRE36]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the middleware to the create route. Middleware in Express can be added
    to specific routes by passing it as a second argument to the function, as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将中间件添加到创建路由中。在Express中，可以通过将中间件作为函数的第二个参数传递来将其添加到特定路由，如下所示：
- en: '[PRE37]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Repeat the same for the edit route:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于编辑路由重复相同的操作：
- en: '[PRE38]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, do this for the delete route:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，对删除路由也这样做：
- en: '[PRE39]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Try accessing the routes without being logged in. You will see that they fail
    with a **401 Unauthorized** status. Execute the following code into your browser
    console:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在不登录的情况下访问路由。您将看到它们以**401 Unauthorized**状态失败。将以下代码执行到您的浏览器控制台：
- en: '[PRE40]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can see the results of executing the code in the following screenshot:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在以下屏幕截图中看到执行代码的结果：
- en: "![Figure 6.4 – Attempting to access a protected route \uFEFFwithout a JWT and\
    \ then with a JWT](img/B19385_06_4.jpg)"
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 尝试在没有JWT的情况下访问受保护的路由，然后使用JWT](img/B19385_06_4.jpg)'
- en: Figure 6.4 – Attempting to access a protected route without a JWT and then with
    a JWT
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 尝试在没有JWT的情况下访问受保护的路由，然后使用JWT
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of using the **express-jwt** library, we could also manually extract
    the token from the **Authorization** header and use the **jwt.verify** function
    from the **jsonwebtoken** library to verify it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用**express-jwt**库之外，我们还可以手动从**Authorization**头中提取令牌，并使用**jsonwebtoken**库中的**jwt.verify**函数来验证它。
- en: The routes are protected now, but we aren’t considering which user accessed
    them. Let’s do that now by accessing the currently logged-in user from the token.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 路由现在已被保护，但我们还没有考虑哪个用户访问了它们。现在让我们通过从令牌中访问当前登录用户来实现这一点。
- en: Accessing the currently logged-in user
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问当前登录用户
- en: 'After adding authenticated routes, we successfully protected some routes so
    that they can only be accessed by logged-in users. However, it’s still possible
    to edit posts of other users or create posts under a different username. Let’s
    change that:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了认证路由之后，我们成功保护了一些路由，使得只有登录用户才能访问。然而，仍然可以编辑其他用户的帖子或以不同的用户名创建帖子。让我们来改变这一点：
- en: 'Edit the **backend/src/services/posts.js** file and add a **userId** argument
    to the **createPost** function, *removing* **author** from the object:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**backend/src/services/posts.js**文件，并在**createPost**函数中添加**userId**参数，从对象中*删除***author**：
- en: '[PRE41]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Instead of setting the author through the request body, we will set the author
    to the ID of the logged-in user:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将不再通过请求体设置作者，而是将作者设置为登录用户的ID：
- en: '[PRE42]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We adjust the **updatePost** and **deletePost** functions similarly (adding
    the **userId** argument, removing the **author** argument, and removing the author
    variable from the **$set** object), ensuring that the currently logged-in user
    is the author of the post:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们以类似的方式调整**updatePost**和**deletePost**函数（添加**userId**参数，删除**author**参数，并从**$set**对象中删除作者变量），确保当前登录用户是帖子的作者：
- en: '[PRE43]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In our case, we simply fetch a post with the given ID and an author as the current
    user. We could still extend this code to first fetch the post with the given ID,
    check if it exists (if not, return a **404 Not Found** error), and if it does
    exist, verify that the author is the currently logged-in user (if not, return
    a **403** **Forbidden** error).
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们简单地通过给定的ID和当前用户作为作者来获取帖子。我们仍然可以扩展此代码，首先获取具有给定ID的帖子，检查它是否存在（如果不存在，则返回**404
    Not Found**错误），如果存在，则验证作者是否是当前登录用户（如果不是，则返回**403 Forbidden**错误）。
- en: Note
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is a breaking API change and requires changing the tests. For brevity,
    we will not go through adjusting the tests step by step here, so this is left
    as an exercise for you.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个破坏性的API更改，需要更改测试。为了简洁，我们不会一步一步地调整测试，所以这留作您的练习。
- en: 'Edit the **backend/src/routes/posts.js** file and use the **req.auth.sub**
    variable to pass the user ID to the **createPost** function:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**backend/src/routes/posts.js**文件，并使用**req.auth.sub**变量将用户ID传递给**createPost**函数：
- en: '[PRE44]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Do the same for the **updatePost** function:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对**updatePost**函数也进行同样的操作：
- en: '[PRE45]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Also, do this for the **deletePost** function:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，还需要对**deletePost**函数进行同样的操作：
- en: '[PRE46]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Try creating a new post; you will see that it is created by the user identified
    in the JWT. You can do this by executing the following code in the browser console
    (don’t forget to replace **<TOKEN>** with your previously generated JWT):'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试创建一个新的帖子；您将看到它是通过JWT中标识的用户创建的。您可以通过在浏览器控制台中执行以下代码来完成此操作（不要忘记将**<TOKEN>**替换为您之前生成的JWT）：
- en: '[PRE47]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Editing and deleting your posts is also possible, but not for posts from other
    users anymore!
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编辑和删除您的帖子也是可能的，但不再适用于其他用户的帖子！
- en: Info
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The **express-jwt** middleware stores all decoded claims from the JWT in a **req.auth**
    object. So, we can access any claims made when creating our JWT here. Of course,
    the middleware validates the JWT signature against the defined secret first, to
    ensure that it received an authentic JWT.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**express-jwt**中间件将JWT中解码的所有声明存储在**req.auth**对象中。因此，我们可以在这里访问创建JWT时做出的任何声明。当然，中间件首先验证JWT签名与定义的密钥是否匹配，以确保它收到了一个真实的JWT。'
- en: Now that we’ve set up the login, signup, and authenticated routes, let’s continue
    by integrating login and signup in the frontend.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了登录、注册和认证路由，让我们继续在前端集成登录和注册。
- en: Integrating login and signup in the frontend using React Router and JWT
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Router和JWT在前端集成登录和注册
- en: Now that we have successfully implemented authorization in the backend, let’s
    start extending the frontend with signup and login pages and connecting them to
    the backend. First, we are going to learn how to implement multiple pages in a
    React app using React Router. Then, we are going to implement the signup UI and
    connect it to the backend. Afterward, we are going to implement a login UI, store
    the token in the frontend, and set up automatic redirects when we are successfully
    logged in. Finally, we are going to update the code for creating posts to pass
    the token in the Authorization header and properly access our authenticated route.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在后端成功实现了授权，让我们开始扩展前端，添加注册和登录页面，并将它们连接到后端。首先，我们将学习如何在React应用程序中使用React
    Router实现多个页面。然后，我们将实现注册UI并将其连接到后端。之后，我们将实现登录UI，在前端存储令牌，并在成功登录时设置自动重定向。最后，我们将更新创建帖子的代码，在授权头中传递令牌，并正确访问我们的认证路由。
- en: Let’s get started with the frontend integration by setting up React Router.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置React Router开始，进行前端集成。
- en: Using React Router to implement multiple routes
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用React Router实现多个路由
- en: 'React Router is a library that allows us to manage routing in our app by defining
    multiple pages on different routes, just like what we have done in Express for
    API routes, but for the frontend! Let’s set up React Router:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 是一个库，它允许我们通过在多个不同路由上定义多个页面来管理我们的应用路由，就像我们在 Express 中为 API 路由所做的那样，但这是针对前端！让我们设置
    React Router：
- en: 'Install the **react-router-dom** library in the frontend project (the root
    of the **ch6** folder, not inside the **backend** folder):'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前端项目中安装 **react-router-dom** 库（在 **ch6** 文件夹的根目录，而不是在 **backend** 文件夹内）：
- en: '[PRE48]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Edit **src/App.jsx** and import the **createBrowserRouter** function and **RouterProvider**
    component:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/App.jsx** 并导入 **createBrowserRouter** 函数和 **RouterProvider** 组件：
- en: '[PRE49]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a new **router** and define the routes. First, we’ll define an index
    route for rendering our **Blog** component:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **router** 并定义路由。首先，我们将定义一个索引路由来渲染我们的 **Blog** 组件：
- en: '[PRE50]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, in the **App** component, replace the **<Blog>** component with **<RouterProvider>**,
    as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 **App** 组件中，将 **<Blog>** 组件替换为 **<RouterProvider>**，如下所示：
- en: '[PRE51]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Start the frontend by running the following command in the root of the **ch6**
    folder:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **ch6** 文件夹的根目录下运行以下命令以启动前端：
- en: '[PRE52]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The blog should render the same way as before, but now, we can start defining
    new routes! You can verify that React Router is working by going to a page that
    we did not define – for example, **http://localhost:5173/test**. React Router
    will display the default 404 page, as shown in the following screenshot:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 博客应该以与之前相同的方式渲染，但现在，我们可以开始定义新的路由！您可以通过访问我们未定义的页面来验证 React Router 是否工作 – 例如，**http://localhost:5173/test**。React
    Router 将显示默认的 404 页面，如下面的截图所示：
- en: '![Figure 6.5 – The default 404 page provided by React Router](img/B19385_06_5.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – React Router 提供的默认 404 页面](img/B19385_06_5.jpg)'
- en: Figure 6.5 – The default 404 page provided by React Router
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – React Router 提供的默认 404 页面
- en: Now that we have successfully set up React Router, we can move on to creating
    the signup page.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功设置了 React Router，我们可以继续创建注册页面。
- en: Creating the signup page
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建注册页面
- en: 'We will start by updating our folder structure so that it supports multiple
    pages. Then, we will implement a `Signup` component and define a `/signup` route
    to link to it. Follow these steps:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先更新我们的文件夹结构，以便它支持多个页面。然后，我们将实现一个 `Signup` 组件并定义一个指向它的 `/signup` 路由。按照以下步骤操作：
- en: Create a new **src/pages/** folder.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/pages/** 文件夹。
- en: 'Move the **src/Blog.jsx** file into the **src/pages/** folder. When VS Code
    asks you to update all imports, select **Yes**. Alternatively, update the import
    in **src/App.jsx**, as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **src/Blog.jsx** 文件移动到 **src/pages/** 文件夹中。当 VS Code 询问您更新所有导入时，选择 **是**。或者，按照以下方式在
    **src/App.jsx** 中更新导入：
- en: '[PRE53]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a new **src/api/users.js** file and define an API function for the **signup**
    route, as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/api/users.js** 文件并定义一个针对 **注册** 路由的 API 函数，如下所示：
- en: '[PRE54]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We are checking for `res.ok` here, which will be `false` when the response status
    code is an error code, such as `400`.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里检查 `res.ok`，当响应状态码是错误码时，例如 `400`，它将是 `false`。
- en: 'Create a new **src/pages/Signup.jsx** file, import the **useState**, **useMutation**,
    and **useNavigate** hooks from **react-router-dom**, as well as the **signup**
    function, and define a **Signup** component there:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/pages/Signup.jsx** 文件，从 **react-router-dom** 中导入 **useState**、**useMutation**
    和 **useNavigate** 钩子，以及 **signup** 函数，并在其中定义一个 **Signup** 组件：
- en: '[PRE55]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In this component, we first create state hooks for the **username** and **password**
    fields:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个组件中，我们首先为 **用户名** 和 **密码** 字段创建状态钩子：
- en: '[PRE56]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, we use the **useNavigate** hook to get a function to navigate to a different
    route:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用 **useNavigate** 钩子获取一个函数来导航到不同的路由：
- en: '[PRE57]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We also define a **useMutation** hook to send the **signup** request. On success,
    we navigate to the **/login** route, which we will define soon:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还定义了一个 **useMutation** 钩子来发送 **注册** 请求。在成功后，我们将导航到 **/login** 路由，我们将在稍后定义它：
- en: '[PRE58]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In case of an error, we could also use the `signupMutation.isError` state and
    the response from the backend to show a more nicely formatted error message.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果发生错误，我们也可以使用 `signupMutation.isError` 状态和后端响应来显示一个格式更漂亮的错误消息。
- en: 'Then, we define a function to handle the submission of the form, as we did
    for the **CreatePost** component:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个处理表单提交的函数，就像我们为 **CreatePost** 组件所做的那样：
- en: '[PRE59]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, we create a simple form to enter a username, password, and a button to
    submit the request, similar to the **CreatePost** component:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个简单的表单来输入用户名、密码和一个提交请求的按钮，类似于 **CreatePost** 组件：
- en: '[PRE60]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Edit **src/App.jsx** and import the **Signup** page component:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/App.jsx** 并导入 **Signup** 页面组件：
- en: '[PRE61]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Add a new **/signup** route that points to the **Signup** page component:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的**/signup**路由，指向**Signup**页面组件：
- en: '[PRE62]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: After defining the signup page, we still need a way to link to it. Let’s add
    the link now.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义注册页面之后，我们仍然需要一种链接到它的方法。现在让我们添加这个链接。
- en: Linking to other routes using the Link component
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Link组件链接到其他路由
- en: Now that we have multiple pages in our blog app, we need to link between them.
    To do this, we can use the `Link` component provided by React Router. We could
    also use a normal link by using `<a href="">`, but that would cause a full page
    refresh. The `Link` component uses client-side routing and thus avoids doing a
    full refresh of the page. Instead, it immediately renders the new component on
    the client side.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们博客应用中有多个页面，我们需要在它们之间建立链接。为此，我们可以使用React Router提供的`Link`组件。我们也可以使用普通的`<a
    href="">`链接，但那样会导致整个页面刷新。`Link`组件使用客户端路由，因此避免了页面的完全刷新。相反，它立即在客户端渲染新的组件。
- en: 'Follow these steps to create a link from the index page to the signup page:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤从首页创建到注册页面的链接：
- en: 'Create a new **src/components/Header.jsx** file and import the **Link** component
    from **react-router-dom**:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**src/components/Header.jsx**文件，并从**react-router-dom**导入**Link**组件：
- en: '[PRE63]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Define a component and return the **Link** component to define a link to the
    signup route, as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个组件并返回**Link**组件以定义到注册路由的链接，如下所示：
- en: '[PRE64]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Edit **src/pages/Blog.jsx** and import the **Header** component:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/pages/Blog.jsx**并导入**Header**组件：
- en: '[PRE65]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, render the **Header** component in the **Blog** component:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在**Blog**组件中渲染**Header**组件：
- en: '[PRE66]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Edit **src/pages/Signup.jsx** and import the **Link** component:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/pages/Signup.jsx**并导入**Link**组件：
- en: '[PRE67]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Add the **Link** component to link back to the index page:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加**Link**组件以链接回首页：
- en: '[PRE68]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now that we’ve successfully linked our signup page, let’s continue by creating
    the login page.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功链接了注册页面，接下来让我们继续创建登录页面。
- en: Creating the login page and storing the JWT
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建登录页面并存储JWT
- en: 'Now that we have successfully defined the signup page, we can create the login
    page. However, first, we need to come up with a way to store the JWT. We shouldn’t
    store it in local storage as a potential attacker can steal the token from there
    (through, for example, script injection). In a **single-page application** (**SPA**),
    where we have no page reloads, a safe and simple way to store the token is to
    store it in the runtime using a React context. Let’s do that now:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功定义了注册页面，我们可以创建登录页面。然而，首先我们需要想出一个存储JWT的方法。我们不应该将其存储在本地存储中，因为潜在的攻击者可以从那里窃取令牌（例如，通过脚本注入）。在一个**单页应用**（**SPA**）中，由于没有页面刷新，将令牌存储在运行时使用React上下文是一种安全且简单的方法。现在让我们这样做：
- en: 'Create a new **src/contexts/** folder. Inside it, create a **src/contexts/AuthContext.jsx**
    file and import the **createContext**, **useState**, and **useContext** functions
    from **react**:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**src/contexts/**文件夹。在其内部，创建一个**src/contexts/AuthContext.jsx**文件，并从**react**导入**createContext**、**useState**和**useContext**函数：
- en: '[PRE69]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, define the following context:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义以下上下文：
- en: '[PRE70]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, define an **AuthContextProvider** component that provides the context
    with a state hook:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个**AuthContextProvider**组件，该组件使用状态钩子提供上下文：
- en: '[PRE71]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Also, define a hook to use the context with a **useState**-like API:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，定义一个钩子来使用上下文，类似于**useState**的API：
- en: '[PRE72]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Edit **src/App.jsx** and import **AuthContextProvider**:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/App.jsx**并导入**AuthContextProvider**：
- en: '[PRE73]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Wrap **RouterProvider** with **AuthContextProvider** to make it available to
    all pages:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**RouterProvider**包裹在**AuthContextProvider**中，使其对所有页面可用：
- en: '[PRE74]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Edit **src/api/users.js** and define a new login function:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/api/users.js**并定义一个新的登录函数：
- en: '[PRE75]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Copy over the **src/pages/Signup.jsx** file to a new **src/pages/Login.jsx**
    file and adjust the import and component name. Also, add a new import for the
    **useAuth** hook:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**src/pages/Signup.jsx**文件复制到新的**src/pages/Login.jsx**文件中，调整导入和组件名称。此外，添加对**useAuth**钩子的新导入：
- en: '[PRE76]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, edit **src/pages/Login.jsx**, add the **useAuth** hook, adjust the **signupMutation**
    to call login, set the token, and navigate to the index page upon successfully
    logging in:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编辑**src/pages/Login.jsx**，添加**useAuth**钩子，调整**signupMutation**以调用登录、设置令牌并在成功登录后导航到首页：
- en: '[PRE77]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Adjust the submit button, as follows:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整提交按钮，如下所示：
- en: '[PRE78]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Edit **src/App.jsx** and import the **Login** page:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/App.jsx**并导入**Login**页面：
- en: '[PRE79]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Lastly, define the **/login** route, as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义**/login**路由，如下所示：
- en: '[PRE80]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: With that, our signup and login pages are working properly, but we still need
    to link to the login page and show the currently logged-in user on the index page.
    Let’s do that now.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的注册和登录页面就正常工作了，但我们仍然需要在首页上链接到登录页面并显示当前登录的用户。我们现在就来做这件事。
- en: Using the stored JWT and implementing a simple logout
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用存储的JWT和实现简单的注销
- en: In this section, we are going to check if the user is logged in already by checking
    if there is a valid JWT stored in the context. Then, we are going to use the auth
    context hook to log our user out again by simply removing the token from it. This
    is not a full logout as the JWT is still technically valid. For a full logout,
    we would have to invalidate the token in the backend (for example, by blacklisting
    that token in the authentication service database). This process is called **token
    revocation**.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过检查上下文中是否存储了有效的JWT来验证用户是否已经登录。然后，我们将使用auth上下文钩子通过简单地从其中移除令牌来再次注销我们的用户。这不是一个完整的注销，因为JWT在技术上仍然是有效的。为了进行完整的注销，我们必须在后端使令牌无效（例如，通过在认证服务数据库中将该令牌列入黑名单）。这个过程被称为**令牌撤销**。
- en: 'Let’s start using the stored JWT and implement a simple logout:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用存储的JWT并实现简单的注销：
- en: 'Install the **jwt-decode** library in the root of our project (the frontend):'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们项目的根目录（前端）安装**jwt-decode**库：
- en: '[PRE81]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Edit **src/components/Header.jsx** and import the **jwtDecode** function and
    the **useAuth** hook:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/components/Header.jsx**并导入**jwtDecode**函数和**useAuth**钩子：
- en: '[PRE82]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Get the token from the **useAuth** hook in the **Header** component:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Header**组件的**useAuth**钩子中获取令牌：
- en: '[PRE83]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Add a check for if the token is properly set. If it is, parse the token and
    render the user ID from it:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对令牌是否正确设置的检查。如果是，解析令牌并渲染从其中获取的用户ID：
- en: '[PRE84]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: In this case, we are only decoding the token in one place. If this functionality
    is used in multiple places, it would make sense to abstract the decoding into
    a separate hook.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只在一个地方解码令牌。如果这个功能在多个地方使用，将解码抽象成一个单独的钩子是有意义的。
- en: 'Additionally, we’ll show a button to log out here, which just resets the token:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还将在这里显示一个注销按钮，它只是重置令牌：
- en: '[PRE85]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'While we’re at it, let’s also add a link to the login page to the header, if
    the user isn’t logged in yet:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此过程中，我们还将添加一个链接到登录页面到页眉，如果用户尚未登录：
- en: '[PRE86]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Congratulations! We have successfully implemented a simple JWT user authentication
    flow. However, you may have noticed that all the users in our blog appear as their
    user ID, not with their username. Let’s change that.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经成功实现了简单的JWT用户认证流程。然而，你可能已经注意到，我们博客中的所有用户都显示为他们的用户ID，而不是他们的用户名。让我们来改变这一点。
- en: Fetching the usernames
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取用户名
- en: To show the usernames instead of the user IDs, we are going to create a `User`
    component that will fetch user information from an endpoint in our backend, which
    we are going to create now. For now, we will only show the username, but in the
    future, this feature could be used to fetch other information, such as the avatar
    or full name of the user.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示用户名而不是用户ID，我们将创建一个`User`组件，该组件将从我们后端的一个端点获取用户信息，我们现在将创建它。目前，我们只显示用户名，但将来这个功能可以用来获取其他信息，例如用户的头像或全名。
- en: Implementing the backend endpoint
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现后端端点
- en: 'Let’s get started by implementing the backend endpoint for fetching user information:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现用于获取用户信息的后端端点：
- en: 'Edit **backend/src/services/users.js** and add a new function to get user information
    by **id**. As a fallback, we return the user ID if we can’t find a matching user:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**backend/src/services/users.js**并添加一个新函数，通过**id**获取用户信息。如果找不到匹配的用户，我们将返回用户ID作为后备：
- en: '[PRE87]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: We specifically make sure we only return the username here, to avoid leaking
    the password or other sensitive user information!
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们特别确保我们只在这里返回用户名，以避免泄露密码或其他敏感用户信息！
- en: 'Edit **backend/src/routes/users.js** and import the newly defined function
    there:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**backend/src/routes/users.js**并在此处导入新定义的函数：
- en: '[PRE88]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Then, define a new route inside the **userRoutes** function, which will get
    a user with a specific ID. For this route, we use the plural **users** as we are
    dealing with multiple users here:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在**userRoutes**函数内部定义一个新的路由，该路由将获取具有特定ID的用户。对于此路由，我们使用复数**users**，因为我们在这里处理多个用户：
- en: '[PRE89]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Since we are already working on the backend, let’s also change the existing
    **author** filter so that it works with usernames. Edit **backend/src/services/posts.js**
    and import the **User** model:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经在后端工作，让我们也更改现有的**author**过滤器，使其与用户名一起工作。编辑**backend/src/services/posts.js**并导入**User**模型：
- en: '[PRE90]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Refactor the **listPostsByAuthor** function by finding a user with the given
    username, then listing all posts by the user ID (if one was found):'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查找具有给定用户名的用户，然后按用户ID列出所有帖子（如果找到了）来重构**listPostsByAuthor**函数：
- en: '[PRE91]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Now that we have an endpoint that returns user information for a given user
    ID, let’s use it in the frontend!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个返回给定用户ID的用户信息的端点，让我们在前端使用它！
- en: Implementing a User component to fetch and render the username
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现一个用于获取和渲染用户名的User组件
- en: In the frontend, we are going to create a component that will fetch and render
    the username. React Query helps us a lot here because we don’t need to worry about
    fetching the same user IDs multiple times – it will cache the result for us and
    instantly return it, instead of making another request.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端，我们将创建一个组件来获取和渲染用户名。React Query在这里帮了我们很大忙，因为我们不需要担心多次获取相同的用户ID – 它会为我们缓存结果并立即返回，而不是再次发起请求。
- en: 'Follow these steps to implement a `User` component:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现`User`组件：
- en: 'First, we need to define the API function. Edit **src/api/users.js** and add
    a function to get the user info by **id**:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要定义API函数。编辑**src/api/users.js**并添加一个通过**id**获取用户信息的函数：
- en: '[PRE92]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Create a new **src/components/User.jsx** file and import **useQuery**, **PropTypes**,
    and the API function:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**src/components/User.jsx**文件并导入**useQuery**、**PropTypes**和API函数：
- en: '[PRE93]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now, define the component and get the user info via the query hook:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义组件并通过查询钩子获取用户信息：
- en: '[PRE94]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We render the username if available and fall back to the ID otherwise:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有用户名，我们渲染它，否则回退到ID：
- en: '[PRE95]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Lastly, we define the prop types for the component:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为组件定义prop类型：
- en: '[PRE96]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, we can make use of the newly created component and import it in **src/components/Header.jsx**:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用新创建的组件并将其导入到**src/components/Header.jsx**中：
- en: '[PRE97]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Then, we can edit the existing code to render the **User** component instead
    of directly rendering the user ID:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以编辑现有代码以渲染**User**组件而不是直接渲染用户ID：
- en: '[PRE98]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Next, we repeat the same process for **src/components/Post.jsx** and import
    the **User** component:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们对**src/components/Post.jsx**执行相同的操作并导入**User**组件：
- en: '[PRE99]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Then, we adjust the code to render the **User** component:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调整代码以渲染**User**组件：
- en: '[PRE100]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, our usernames will all render properly again, as shown in the following
    screenshot:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的用户名将再次正确渲染，如下面的截图所示：
- en: '![Figure 6.6 – Properly fetching and showing the username](img/B19385_06_6.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 正确获取并显示用户名](img/B19385_06_6.jpg)'
- en: Figure 6.6 – Properly fetching and showing the username
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 正确获取并显示用户名
- en: 'Now that usernames show up properly, we need to do one more thing: send the
    JWT header when creating posts.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户名已经正确显示，我们需要做一件事：在创建帖子时发送JWT头。
- en: Sending the JWT header when creating posts
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在创建帖子时发送JWT头
- en: When creating a post, we don’t need to send the author anymore. Instead, we
    need to send the JWT with the `Authentication` header.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建帖子时，我们不再需要发送作者信息。相反，我们需要发送带有`Authentication`头的JWT。
- en: 'Let’s refactor the code so that we can do this:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构代码以便我们可以这样做：
- en: 'Edit **src/api/posts.jsx** and adjust the **createPost** function so that it
    accepts a JWT as the first argument, which is then passed on inside an **Authentication**
    header:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/api/posts.jsx**并调整**createPost**函数，使其接受JWT作为第一个参数，然后将其作为**Authentication**头传递：
- en: '[PRE101]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Edit **src/components/CreatePost.jsx** and import the **useAuth** hook:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/components/CreatePost.jsx**并导入**useAuth**钩子：
- en: '[PRE102]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Get the JWT from the **useAuth** hook inside the component:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从组件内部的**useAuth**钩子中获取JWT：
- en: '[PRE103]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '*Remove* the **author** state:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除* **author**状态：'
- en: '[PRE104]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Also, *remove* the **author** state from the **createPost** function and instead
    pass in the **token** state as the first argument:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要从**createPost**函数中*删除* **author**状态，并改为将**token**状态作为第一个参数传递：
- en: '[PRE105]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Before rendering the component, check if the user is logged in by checking
    if a token exists. If the user is not logged in, we tell them to log in first:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染组件之前，通过检查是否存在令牌来检查用户是否已登录。如果用户未登录，我们告诉他们先登录：
- en: '[PRE106]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '*Remove* the following code to remove the **author** field:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除*以下代码以删除**author**字段：'
- en: '[PRE107]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Now, creating a post works successfully again! It stores the user ID of the
    currently logged-in user in the database as the author and resolves it to the
    username when showing the post.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建帖子又成功工作了！它将当前登录用户的用户ID存储在数据库中作为作者，并在显示帖子时将其解析为用户名。
- en: Next, we’ll learn about advanced token handling.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习高级令牌处理。
- en: Advanced token handling
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级令牌处理
- en: 'You may have noticed that our simple authentication solution is still missing
    some features that a fully-fledged solution should have, such as the following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们的简单认证解决方案仍然缺少一些完整解决方案应该具备的功能，例如以下内容：
- en: Using asymmetric keys for the tokens so that we can verify the authenticity
    (using the public key) without exposing our secret (the private key) to all services.
    Up until now, we have been using a symmetric key, which means that we need the
    same secret to generate and verify a JWT.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非对称密钥对令牌进行加密，这样我们就可以在不暴露我们的秘密（私钥）给所有服务的情况下验证其真实性（使用公钥）。到目前为止，我们一直在使用对称密钥，这意味着我们需要相同的秘密来生成和验证JWT。
- en: Storing tokens in safe **httpOnly** cookies so that they can be accessed again,
    even when the page is refreshed or closed.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将令牌存储在安全的**httpOnly** cookie中，以便在页面刷新或关闭后再次访问。
- en: Invalidating tokens after logging out on the backend.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后端注销后使令牌无效。
- en: Implementing these things requires a lot of effort manually, so it is best practice
    to use an authentication solution such as Auth0 or Firebase Auth. These solutions
    work similarly to our simple JWT implementation, but they provide an external
    authentication service to create and handle the tokens for us. This chapter intended
    to introduce how those providers work behind the scenes so that you can easily
    understand and integrate any of the providers as you see fit in your projects.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些功能需要大量手动工作，因此最佳实践是使用认证解决方案，如Auth0或Firebase Auth。这些解决方案的工作方式与我们的简单JWT实现类似，但它们为我们提供了一个外部的认证服务来创建和处理令牌。本章旨在介绍这些提供商幕后是如何工作的，以便您可以轻松理解并集成您项目中的任何提供商。
- en: So far, all users have been considered equal, with everyone being allowed to
    create posts, but only update and delete their own posts. For a public blog, it
    would be good to have a way for administrators to delete other people’s posts
    to moderate the content on the platform. A good way to add roles is to store and
    fetch them from the database. While adding roles in the JWT is technically possible,
    it has some downsides, such as the need to invalidate existing tokens and create
    a new token when the roles change.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有用户都被视为平等，每个人都可以创建帖子，但只能更新和删除自己的帖子。对于一个公开的博客，为管理员提供一个删除他人帖子以管理平台内容的方法会很好。添加角色的一个好方法是存储和从数据库中检索它们。虽然在JWT中添加角色在技术上可行，但它有一些缺点，例如在角色更改时需要使现有令牌无效并创建新的令牌。
- en: Summary
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how JWTs work in depth. First, we learned about
    the theory of authentication and JWTs, and how to manually create them. Then,
    we implemented login, signup, and authenticated routes in the backend. Next, we
    integrated these routes in the frontend by creating new pages and routing between
    them using React Router. Finally, we wrapped up this chapter by learning about
    advanced token handling and giving pointers on more things to learn about authentication
    and role management.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入学习了JWT的工作原理。首先，我们学习了认证理论和JWT，以及如何手动创建它们。然后，我们在后端实现了登录、注册和认证路由。接下来，我们通过创建新页面并在它们之间使用React
    Router进行路由来将这些路由集成到前端。最后，我们通过学习高级令牌处理以及关于认证和角色管理的更多学习要点来结束本章。
- en: In the next chapter, [*Chapter 7*](B19385_07.xhtml#_idTextAnchor147), *Improving
    the Load Time Using Server-Side Rendering*, we are going to learn how to implement
    server-side rendering to improve the initial load time of our blog. We are already
    doing a lot of requests on the first load (fetching all blog posts, then the usernames
    of each author). We can bundle them together by doing this on the backend.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[*第7章*](B19385_07.xhtml#_idTextAnchor147)，*使用服务器端渲染提高加载时间*，我们将学习如何实现服务器端渲染以改善我们博客的初始加载时间。在第一次加载时，我们已经做了很多请求（获取所有博客帖子，然后是每位作者的昵称）。我们可以通过在后台这样做来将它们捆绑在一起。
