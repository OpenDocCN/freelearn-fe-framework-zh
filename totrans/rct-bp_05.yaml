- en: Chapter 5. Creating a Map App with HTML5 APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：使用HTML5 API创建地图应用
- en: In this chapter, we'll cover a variety of HTML5 APIs with ReactJS, and we'll
    generate a map-based application that can run on your desktop browser as well
    as your mobile device.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用ReactJS介绍各种HTML5 API，并生成一个可以在您的桌面浏览器以及移动设备上运行的基于地图的应用程序。
- en: 'In brief, these are the topics that we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这些是我们将要讨论的主题：
- en: An overview of useful HTML5 APIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用HTML5 API概述
- en: The High Resolution Time API
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高精度时间API
- en: The Vibration API
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 震动API
- en: The Battery Status API
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电池状态API
- en: The Page Visibility API
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面可见性API
- en: The Geolocation API
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理位置API
- en: Reverse geolocation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向地理定位
- en: Static and interactive maps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态和交互式地图
- en: The state of HTML5 APIs
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5 API的状态
- en: The HTML5 specification has added a number of useful APIs that you may not have
    tried yet. The reason is likely to be a combination of lack of browser support
    and knowing that they exist. A lot of APIs have been introduced since the dawn
    of HTML5\. Some have reached stability; some are still up and coming; and sadly,
    some have fallen to the wayside and are about to be deprecated—like the highly
    promising getUserMedia API—or are not able to get enough traction to gain support
    on all browsers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5规范增加了一些有用的API，您可能还没有尝试过。原因很可能是缺乏浏览器支持和知道它们的存在。自从HTML5诞生以来，已经引入了许多API。一些已经达到稳定状态；一些仍在发展中；遗憾的是，一些已经落伍，即将被弃用——比如非常有前途的getUserMedia
    API——或者无法获得足够的支持以在所有浏览器上运行。
- en: Let's take a look at the most interesting APIs available right now and how you
    can use them to create powerful web applications. We'll use several of these in
    the map application we will create later in the chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看目前最有趣的API以及如何使用它们来创建强大的Web应用程序。我们将在本章后面创建的地图应用程序中使用其中的一些。
- en: The High Resolution Time API
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高精度时间API
- en: If your website loads too slowly, users will become frustrated and leave. Measuring
    the execution time and page load is therefore one of the most important aspects
    of user experience, but unfortunately, it's also one of the most difficult to
    troubleshoot.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的网站加载速度过慢，用户会感到沮丧并离开。因此，测量执行时间和页面加载时间是用户体验最重要的方面之一，但遗憾的是，这也是最难调试的问题之一。
- en: For historical reasons, the most commonly used method of measuring page load
    is using the Date API to compare timestamps. This was the best tool available
    for a long time, but there are a number of problems with this approach.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，测量页面加载最常用的方法是使用Date API来比较时间戳。这在很长一段时间内是最好的工具，但这种方法存在许多问题。
- en: JavaScript time is infamous for being inaccurate (for instance, some versions
    of Internet Explorer simply round down time representation if the results are
    less than a certain threshold, making it virtually impossible to retrieve correct
    measurements). The Date API can only be used once the code is running in the browser,
    which means that you cannot measure processes involving the server or network.
    It also introduces overhead and clutter in your code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript时间因其不准确而臭名昭著（例如，某些版本的Internet Explorer如果结果小于某个阈值，就会简单地向下取整时间表示，这使得获取正确测量值几乎成为不可能）。Date
    API只能在代码在浏览器中运行时使用，这意味着您无法测量涉及服务器或网络的进程。它还引入了开销和代码的杂乱。
- en: In short, you deserve a better tool, something that's native to the browser,
    provides fine precision, and doesn't clutter up your code base. Fortunately, all
    of this is already available to you in the form of the **High Resolution Time
    API**. It provides the current time in sub-millisecond resolution. Unlike the
    Date API, it is not subject to system clock skew or adjustments, and since it's
    native, no additional overhead is created.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，您值得一个更好的工具，一个原生的浏览器工具，提供高精度，并且不会使您的代码库变得杂乱。幸运的是，所有这些都已经以**高精度时间API**的形式提供给您。它提供了以亚毫秒为分辨率的当前时间。与Date
    API不同，它不受系统时钟偏移或调整的影响，并且由于它是原生的，不会创建额外的开销。
- en: The API exposes only one method, called `now()`. It returns a very accurate
    timestamp with a precision to a thousandth of a millisecond, allowing you to have
    accurate performance tests of your code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该API仅公开一个名为`now()`的方法。它返回一个精确到千分之一的毫秒级的时间戳，允许您对代码进行精确的性能测试。
- en: 'It''s very easy to replace instances of your code where you use the Date API
    with the High Resolution Time API. For instance, the following code uses the Date
    API (and may log a positive or negative number, or zero):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 用高分辨率时间API替换你代码中使用日期API的实例非常简单。例如，以下代码使用了日期API（可能会记录一个正数、负数或零）：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A similar operation with `performance.now()` looks like the next segment and
    will not only be more accurate, but always positive as well:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`performance.now()`的类似操作看起来像下一个部分，不仅会更准确，而且始终是正数：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As noted, the High Resolution Time API originally exposed only one method,
    but through the **User Timing API**, you can access a few more methods that let
    you measure performance without littering your code base with excess variables:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，高分辨率时间API最初只公开了一个方法，但通过**用户时间API**，你可以访问更多方法，让你可以测量性能而不会在代码库中留下过多的变量：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can fetch existing marks by type or name by calling either `performance.getEntriesByType(''measure'')`
    or `performance.getEntriesByType(''mark'')`. You can also get a list of all the
    entries by calling `performance.getEntries()`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用`performance.getEntriesByType('measure')`或`performance.getEntriesByType('mark')`来按类型或名称获取现有的标记。你也可以通过调用`performance.getEntries()`来获取所有条目的列表：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can easily get rid of any marks you've set up by calling `performance.clearMarks()`.
    Calling it with no value will clear all marks, but you can also remove single
    marks by calling `clearMarks()` with the mark you want to remove. The same goes
    for measures, using `performance.clearMeasure()`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用`performance.clearMarks()`轻松地移除你设置的任何标记。不带值调用它将清除所有标记，但你也可以通过调用`clearMarks()`并指定要删除的标记来移除单个标记。对于度量也是如此，使用`performance.clearMeasure()`。
- en: Using `performance.mark()` and `performance.measure()` is great for measuring
    the execution time of your code, but using them to measure page load is still
    rather clunky. To help troubleshoot page loads, a third API has been developed,
    which extends the High Resolution Time API even further. This is called the **Navigation
    Timing API** and provides measurements related to DNS lookup, TCP connection,
    redirects, DOM building, and so on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`performance.mark()`和`performance.measure()`来测量代码的执行时间非常棒，但用它们来测量页面加载仍然相当笨拙。为了帮助调试页面加载，已经开发了一个第三个API，它进一步扩展了高分辨率时间API。这被称为**导航时间API**，它提供了与DNS查找、TCP连接、重定向、DOM构建等相关度量的信息。
- en: It works by recording the time when milestones in the page load process occur.
    There are many measured events given in milliseconds that can be accessed through
    the `PerformanceTiming` interface. You can easily use these records to calculate
    the many factors that surround page load time. For instance, you can measure the
    time taken for the page to be visible to the user by subtracting `timing.navigationStart`
    from `timing.loadEventEnd`, or measure how long the DNS lookup takes by subtracting
    `timing.domainLookupStart` from `timing.domainLookupEnd`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过记录页面加载过程中里程碑的时间来实现。有许多以毫秒为单位的事件被给出，可以通过`PerformanceTiming`接口访问。你可以轻松地使用这些记录来计算围绕页面加载时间的许多因素。例如，你可以通过从`timing.navigationStart`减去`timing.loadEventEnd`来测量页面对用户可见的时间，或者通过从`timing.domainLookupStart`减去`timing.domainLookupEnd`来测量DNS查找所需的时间。
- en: The `performance.navigation` object also stores two attributes that can be used
    to find out whether a page load is triggered by a redirect, back/forward button,
    or normal URL load.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`performance.navigation`对象还存储了两个属性，可以用来确定页面加载是由重定向、后退/前进按钮还是正常URL加载触发的。'
- en: All of these methods combined enable you to find the bottlenecks in your application.
    We'll be using the API for debugging information and highlighting which parts
    of the app take the most time to load.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法结合起来，使你能够找到应用程序中的瓶颈。我们将使用API来获取调试信息和突出显示应用程序中加载时间最长的部分。
- en: Browser support for these APIs vary. Both the **High Resolution Time API** and
    **Navigation Timing API** are supported by modern browsers, but the **Resource
    Timing API** is not supported by Safari or Safari Mobile, so you need to practice
    defensive coding in order to avoid `TypeErrors` preventing your page from working.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些API的浏览器支持情况各不相同。**高分辨率时间API**和**导航时间API**都受到现代浏览器的支持，但**资源时间API**不受Safari或Safari
    Mobile的支持，因此你需要练习防御性编程，以避免`TypeErrors`阻止你的页面工作。
- en: The Vibration API
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 震动API
- en: The Vibration API offers the ability to interact with the mobile device's built-in
    vibration hardware component. If the API is not supported, nothing will happen;
    therefore, it's safe to use on devices that do not support it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 振动 API 提供了与移动设备内置振动硬件组件交互的能力。如果 API 不受支持，则不会发生任何操作；因此，在设备不支持它的情况下使用是安全的：
- en: 'The API is activated by applying the `navigator.vibrate` method. It accepts
    either a single number to vibrate once or an array of values to alternately vibrate,
    pause, and then vibrate again. Passing a value of `0`, an empty array, or an array
    containing all zeros will cancel any currently ongoing vibration pattern:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: API 通过调用 `navigator.vibrate` 方法来激活。它可以接受一个单独的数字来振动一次，或者一个值数组来交替振动、暂停，然后再振动。传递
    `0`、一个空数组或包含所有零的数组将取消任何当前正在进行的振动模式：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The API is targeted against mobile devices and has been around since 2012\.
    Android devices running Chrome or Firefox support the API, but there is no support
    for the API on Safari or on mobile, and it seems there never will be.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该 API 针对移动设备，自 2012 年以来一直存在。运行 Chrome 或 Firefox 的 Android 设备支持该 API，但在 Safari
    或移动设备上没有支持，而且似乎永远不会支持：
- en: This is unfortunate because vibration has a number of valid use cases, for instance,
    to provide tactile feedback when the user interacts with buttons or form controls
    or to alert the user of a notification.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这很遗憾，因为振动有许多有效的用例，例如，在用户与按钮或表单控件交互时提供触觉反馈，或者提醒用户有通知：
- en: 'You can, of course, also use it for fun, for instance, by playing a popular
    melody:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以用它来娱乐，例如，通过播放流行的旋律：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A fun list of Vibration API tunes can be found at [https://gearside.com/custom-vibration-patterns-mobile-devices/](https://gearside.com/custom-vibration-patterns-mobile-devices/).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一份有趣的振动 API 调音列表可以在 [https://gearside.com/custom-vibration-patterns-mobile-devices/](https://gearside.com/custom-vibration-patterns-mobile-devices/)
    找到：
- en: We'll be using the Vibration API in our map app to respond to button clicks.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的地图应用中使用振动 API 来响应用户的按钮点击：
- en: The Battery Status API
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电池状态 API
- en: The Battery Status API lets you inspect the state of a device's battery and
    fire events about changes in battery level or status. This can be quite useful
    because we can use this information to disable battery-draining operations, and
    hold off on AJAX requests and other network-related traffic when the battery is
    running low.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 电池状态 API 允许您检查设备电池的状态，并触发有关电池电量和状态变化的的事件。这非常有用，因为我们可以使用这些信息来禁用耗电操作，并在电池电量低时推迟
    AJAX 请求和其他网络相关流量：
- en: The API exposes four methods and four events. The methods are `charging`, `chargingTime`,
    `dischargingTime`, and `level` and the events are `chargingchange`, `levelchange`,
    `chargingtimechange`, and `dischargingtimechange`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该 API 提供了四种方法和四种事件。方法包括 `charging`、`chargingTime`、`dischargingTime` 和 `level`，事件包括
    `chargingchange`、`levelchange`、`chargingtimechange` 和 `dischargingtimechange`：
- en: 'You can add event listeners to your `mount` method in order to respond to changes
    in battery status:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向您的 `mount` 方法添加事件监听器，以响应电池状态的变化：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There''s no need to add the event listeners if the browser doesn''t support
    the Battery API, so it''s a good idea to check that the `navigator` object contains
    `battery` before adding any event listeners:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浏览器不支持电池 API，则不需要添加事件监听器，所以在添加任何事件监听器之前检查 `navigator` 对象是否包含 `battery` 是一个好主意：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These functions will fire anytime a change happens with your battery status.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数将在您的电池状态发生变化时随时触发：
- en: The Battery API is supported by Firefox, Chrome, and the Android browser. Neither
    Safari nor IE support it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 电池 API 由 Firefox、Chrome 和 Android 浏览器支持。Safari 和 IE 都不支持它。
- en: We'll use this in our map app to warn users about switching to static maps if
    the battery is running low.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的地图应用中使用这个功能来警告用户，如果电池电量低，将切换到静态地图：
- en: The Page Visibility API
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 页面可见性 API
- en: The Page Visibility API lets us detect whether our page is visible or in focus,
    hidden, or not in focus (that is, either minimized or tabbed).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 页面可见性 API 允许我们检测我们的页面是否可见或聚焦，隐藏，或者不在聚焦（即，最小化或标签页）：
- en: The API doesn't have any methods, but it exposes the `visibilitychange` event,
    which we can use to detect changes in the state of the page's visibility and two
    read-only properties, `hidden` and `visibilityState`. When a user minimizes the
    web page or moves to another tab, the API sends a `visibilitychange` event regarding
    the visibility of the page.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 该API没有任何方法，但它暴露了`visibilitychange`事件，我们可以使用它来检测页面可见状态的变化以及两个只读属性，`hidden`和`visibilityState`。当用户最小化网页或切换到另一个标签页时，API会发送一个关于页面可见性的`visibilitychange`事件。
- en: 'It can easily be added to your React component in the mount method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以轻松地添加到你的React组件的挂载方法中：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And then, you can monitor any changes in the page visibility in the `onVisibilityChange`
    function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在`onVisibilityChange`函数中监控页面可见性的任何变化：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can use this to halt the execution of any network activity that isn't necessary
    when the user isn't actively using your page. You may also want to pause the execution
    if you're showing content, like an image carousel that shouldn't advance to the
    next slide unless the user is viewing the page, or if you're serving video or
    game content. When the user revisits your page, you can continue the execution
    seamlessly.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个功能在用户没有积极使用你的页面时停止执行任何不必要的网络活动。如果你正在显示内容，如不应在没有用户查看页面时切换到下一张幻灯片的图片轮播，或者如果你正在提供视频或游戏内容，你可能也想暂停执行。当用户重新访问你的页面时，你可以无缝地继续执行。
- en: We won't be using this API in our map app, but we'll be sure to use it in [Chapter
    9](ch09.html "Chapter 9. Creating a Shared App"), *Creating a Shared App*, when
    we make a game that should pause when the player minimizes or tabs the window.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在地图应用中不会使用这个API，但当我们制作一个应该在玩家最小化或切换窗口时暂停的游戏时，我们一定会使用它，在[第9章](ch09.html "第9章。创建共享应用")*创建共享应用*中。
- en: Browser support is excellent. The API is supported by all major browsers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器支持非常出色。该API被所有主流浏览器支持。
- en: The Geolocation API
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地理位置API
- en: The Geolocation API defines a high-level interface to locate information, such
    as latitude and longitude, which is linked to the device hosting it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 地理位置API定义了一个高级接口来定位信息，如纬度和经度，这些信息与托管它的设备相关联。
- en: Knowing where your user is located is a powerful tool and can be used to serve
    localized content, personalize ads or search results, and draw a map of your surroundings.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 了解用户的位置是一个强大的工具，可以用来提供本地化内容、个性化广告或搜索结果，以及绘制你周围环境的地图。
- en: The API doesn't concern itself with the location source, so it is entirely up
    to the device as to where it gets its information. Common sources are GPS, location
    inferred from network signals, Wi-Fi, Bluetooth, MAC address, RFID, GSM cell ID,
    and so on; it includes manual user input as well. Because it can derive its information
    from so many sources, the API is usable from a number of devices, including cell
    phones and desktop computers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该API不关心位置来源，因此设备完全决定其信息来源。常见来源包括GPS、从网络信号推断出的位置、Wi-Fi、蓝牙、MAC地址、RFID、GSM小区ID等等；它还包括手动用户输入。因为它可以从这么多来源中获取信息，所以该API可以在包括手机和桌面电脑在内的多种设备上使用。
- en: 'The API exposes three methods that belong to the `navigator.geolocation` object:
    `getCurrentPosition`, `watchPosition`, and `clearWatch`. Both `getCurrentPosition`
    and `watchPosition` perform the same task. The difference is that the first method
    performs a one-time request, while the latter continually monitors the device
    for changes.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该API暴露了属于`navigator.geolocation`对象的三种方法：`getCurrentPosition`、`watchPosition`和`clearWatch`。`getCurrentPosition`和`watchPosition`执行相同的任务。区别在于第一个方法执行一次性请求，而后者持续监控设备的变化。
- en: 'The coordinates contain these properties: `latitude`, `longitude`, `altitude`,
    `accuracy`, `altitudeAccuracy`, `heading`, and `speed`. Desktop browsers usually
    won''t report any values other than `latitude` and `longitude`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标包含以下属性：`latitude`、`longitude`、`altitude`、`accuracy`、`altitudeAccuracy`、`heading`和`speed`。桌面浏览器通常不会报告除`latitude`和`longitude`之外的其他值。
- en: 'Retrieving a position returns an object with a timestamp and a set of coordinates.
    The timestamp lets you know when the location was detected, which can be useful
    if you need to know how fresh the data is:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 获取位置返回一个包含时间戳和一组坐标的对象。时间戳让你知道位置是在何时被检测到的，这在需要知道数据的新鲜程度时可能很有用：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `clearWatch` function can be called to stop monitoring if you''ve started
    `watchPosition`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经启动了`watchPosition`，可以调用`clearWatch`函数来停止监控：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This API will be central to our map application. In fact, we won't show the
    user any content unless we are able to get a current location. Browser support
    is fortunately excellent, since it's supported by all major applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 API 将成为我们地图应用的核心。实际上，除非我们能够获取当前位置，否则我们不会向用户显示任何内容。幸运的是，浏览器支持非常好，因为它被所有主要应用程序支持。
- en: Creating our map app
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的地图应用
- en: 'Let''s start with the basic setup from the first chapter. As usual, we''ll
    be extending the scaffold with a few extra packages:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一章的基本设置开始。像往常一样，我们将通过添加一些额外的包来扩展脚手架：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Most of these packages should be familiar to you. The ones we haven't used in
    the earlier chapters are `url`, `two utility functions from the` `lodash` library,
    and the leaflet `map` library. We'll use the `url` function for URL resolution
    and parsing. The `lodash` functions will come in handy when we need to compose
    a URL to the map service of our choice. Leaflet is an open source JavaScript library
    for interactive maps. We'll get back to it when we add an interactive map to our
    app.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包中的大多数你应该都很熟悉。我们之前章节中没有使用的是 `url`、`来自 `lodash` 库的两个实用函数`和 leaflet `地图`库。我们将使用
    `url` 函数进行 URL 解析和解析。当我们需要组合一个指向我们选择的地图服务的 URL 时，`lodash` 函数将很有用。Leaflet 是一个用于交互式地图的开源
    JavaScript 库。当我们向应用中添加交互式地图时，我们将回到它。
- en: 'The `devDependencies` section in `package.json` should now look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 中的 `devDependencies` 部分现在应该看起来像这样：'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s open `public/index.html` and add some code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开 `public/index.html` 并添加一些代码：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We'll need the Bootstrap CSS and the Leaflet CSS to display our maps properly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 Bootstrap CSS 和 Leaflet CSS 来正确显示我们的地图。
- en: 'We''ll also need to apply some styles, so open `public/app.css` and replace
    the content with the following style:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要应用一些样式，所以打开 `public/app.css` 并将其内容替换为以下样式：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first styles we add are a set of bouncing balls. These will be displayed
    while we're fetching content on the first load of the app, so it's important that
    they look good and that they convey to the user that something is happening. This
    set of code is provided by [http://tobiasahlin.com/spinkit/](http://tobiasahlin.com/spinkit/).
    On this site, you'll find a few more examples of simple loading spinners animated
    with hardware-accelerated CSS animations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的第一组样式是一组弹跳球。这些将在我们首次加载应用内容时显示，因此它们看起来很重要，并且它们向用户传达了正在发生某事。这组代码由 [http://tobiasahlin.com/spinkit/](http://tobiasahlin.com/spinkit/)
    提供。在这个网站上，你还可以找到一些使用硬件加速 CSS 动画简单加载旋转器的更多示例。
- en: 'We''ll create two different types of maps, one static and one interactive.
    We''re also going to set up zoom and exit buttons and make sure they look okay
    on smaller devices:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两种不同类型的地图，一种静态的，一种交互式的。我们还将设置缩放和退出按钮，并确保它们在小设备上看起来不错：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These buttons let us zoom in and out when using static maps. They''re placed
    near the upper right-hand side of the screen, and they mimic the functionality
    of an interactive map:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些按钮让我们在使用静态地图时可以放大和缩小。它们位于屏幕的右上角，并模仿交互式地图的功能：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The media query makes some small alterations to the style to make sure the maps
    are visible and have a proper margin on small devices.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体查询对样式进行了一些小的调整，以确保在小设备上地图可见并且有适当的边距。
- en: When you start your server now with `node server.js`, you should see a blank
    screen in your browser. We're ready to get on with our app.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `node server.js` 启动你的服务器时，你应该在浏览器中看到一个空白屏幕。我们准备好继续我们的应用开发。
- en: Setting up geolocation
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置地理位置
- en: We'll start by creating a service that fetches our reverse geolocation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个服务来获取我们的反向地理位置。
- en: 'Create a folder called `service` in the source folder and call it `geo.js`.
    Add the following content to it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在源文件夹中创建一个名为 `service` 的文件夹，并将其命名为 `geo.js`。向其中添加以下内容：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We'll need the utilities we installed as part of the Bootstrap process. The
    `url utils` parameter will create a URL string for us based on a set of keys and
    properties. `Lodash pick` creates an object composed of the picked object properties,
    while `identity` returns the first argument provided to it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要作为 Bootstrap 过程的一部分安装的实用工具。`url utils` 参数将根据一组键和属性为我们创建一个 URL 字符串。`Lodash
    pick` 创建一个由所选对象属性组成的对象，而 `identity` 返回提供给它的第一个参数。
- en: 'We''ll also need to create a `config.json` file holding the parameters that
    we will use to construct the URL string, let''s take a look at the following code
    snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个 `config.json` 文件，其中包含我们将用于构造 URL 字符串的参数，让我们看一下以下代码片段：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We construct our request with a timeout. Superagent has a few other options
    you can set, such as accept headers, query parameters, and more, let''s take a
    look at the following code snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用超时构造我们的请求。Superagent还有一些其他选项可以设置，例如接受头、查询参数等，让我们看一下以下代码片段：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There is a long-standing bug in Superagent where some errors (4xx and 5xx)
    aren''t set with the `err` object as documented, so we need to check both `err`
    and `res.error` in order to catch all the errors, let''s take a look at the following
    code snippet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Superagent中有一个长期存在的bug，其中一些错误（4xx和5xx）没有按照文档设置在`err`对象中，因此我们需要检查`err`和`res.error`以捕获所有错误，让我们看一下以下代码片段：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will return our request through a `Promise` instance. `Promise` is an object
    that is used for deferred and asynchronous computations. It represents an operation
    that hasn't completed yet, but is expected to in the future.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个`Promise`实例返回我们的请求。`Promise`是一个用于延迟和异步计算的对象。它表示一个尚未完成但预计将来会完成的操作。
- en: 'Next, create a file called `config.json` and place it in your source folder,
    and add the following content:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`config.json`的文件，并将其放置在您的源文件夹中，并添加以下内容：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: OpenStreetMap is an openly licensed map of the world created by volunteers using
    local knowledge, GPS tracks, and donated sources. It is reported to have over
    2 million users who have collected data using manual survey, GPS devices, aerial
    photography, and other free sources.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: OpenStreetMap是一个由志愿者使用当地知识、GPS轨迹和捐赠的资源创建的开放许可的世界地图。据报道，有超过200万用户使用手动调查、GPS设备、航空摄影和其他免费资源收集了数据。
- en: We'll be using the service to fetch reverse geolocation as well as use it in
    combination with Leaflet to create an interactive map in the later part of this
    chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后面部分使用该服务来获取反向地理编码，并将其与Leaflet结合使用，以创建一个交互式地图。
- en: 'Let''s make sure we can retrieve our current location and the reverse geolocation.
    Open `app.jsx` and replace the content with the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保我们可以检索我们的当前位置和反向地理编码。打开`app.jsx`文件，并用以下代码替换内容：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''re going to use all of these state variables in our app eventually, but
    the ones we''ll update and use now are `locationFetched`, `lon`, and `lat`. The
    state of the first variable will decide whether we''ll show a loading animation
    or a result from the geo lookups, let''s take a look at the following code snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终将在我们的应用中使用所有这些状态变量，但我们现在将更新并使用的是`locationFetched`、`lon`和`lat`。第一个变量的状态将决定我们是否会显示加载动画或地理查找的结果，让我们看一下以下代码片段：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We set up a marker before we call the function that fetches the current position
    and the reverse geolocation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用获取当前位置和反向地理编码的函数之前，我们设置了一个标记：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We use the one-time request from `navigator.geolocation` to fetch the user''s
    current position. We then store this in our component state. We also send a call
    to `fetchReverseGeo` with the coordinates:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`navigator.geolocation`的一次性请求来获取用户的当前位置。然后我们将这个位置存储在我们的组件状态中。我们还调用`fetchReverseGeo`函数，并传递坐标：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will be used to display an alert a little bit later:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在稍后用于显示一个警告：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We''re done with fetching data, so let''s measure how long it took. We can
    fetch the time by using the `fetch_geo_time` keyword anytime we want, as it appears
    in the preceding code. Now, consider this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了数据获取，所以让我们测量它花费了多长时间。我们可以通过使用`fetch_geo_time`关键字在任何时候获取时间，正如它在前面的代码中所示。现在，考虑以下情况：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After we receive the position, we store it in our component state, and for
    the browser and devices that have vibration support, we send off a short vibration
    to let the user know the app is ready to be used. Refer to the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们收到位置后，我们将其存储在我们的组件状态中，对于具有振动支持的网络浏览器和设备，我们发送一个短暂的振动，让用户知道应用已准备好使用。请参阅以下内容：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When we catch an error, we store the error message as part of our component
    state. We will either receive the error as an object with a message property or
    as a string, so we make sure that we check this before storing it. Moving on to
    the next part:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们捕获到一个错误时，我们将错误消息作为我们组件状态的一部分存储。我们可能会以包含消息属性的对象或字符串的形式接收错误，所以我们确保在存储之前检查这一点。接下来是下一部分：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the event that any of the third-party services we rely on are down or unavailable,
    we short circuit the app and display an error message, as shown in the preceding
    code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们依赖的任何第三方服务出现故障或不可用，我们将短路应用并显示错误消息，正如前面代码所示：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We present the SpinKit bouncing balls in this block. It is always shown before
    all necessary data is fully loaded, let''s take a look at the following code snippet:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个块中展示了SpinKit弹跳球。它总是在所有必要的数据完全加载之前显示，让我们看一下以下代码片段：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We let the user know that we got a set of coordinates and a real world address:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让用户知道我们得到了一组坐标和现实世界的地址：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This `if`-`else` block will either show a map of the world, static or interactive,
    depending on the user's choice; alternatively, it will display a set of buttons
    and the option to select a new location.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`if`-`else`块将根据用户的选择显示世界地图，静态或交互式；或者，它将显示一组按钮和选择新位置的选择项。
- en: 'We could also have used routing to toggle between these choices. But this would
    mean setting up a map route, a home route, and so on. This is often a good idea,
    but it''s not always necessary, and this app shows how you can structure a simple
    app without the use of routing, let''s take a look at the following code snippet:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用路由在这些选择之间切换。但这意味着需要设置地图路由、主页路由等等。这通常是一个好主意，但并不总是必要的，这个应用展示了如何在不使用路由的情况下构建一个简单的应用，让我们看一下以下代码片段：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We display the debug information from the High Resolution Time API here. We
    delegate each section into a function. This is called separation of concerns.
    The purpose is to encapsulate sections of code to increase modularity and simplify
    development. When reading the code, it''s much easier to understand that when
    the program asks for {this.debugDNSLookup()}, it returns some information about
    the DNS lookup time. If we inlined the function, it would be harder to understand
    the purpose of the code block:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里显示来自高分辨率时间API的调试信息。我们将每个部分委托给一个函数。这被称为关注点分离。目的是封装代码部分以增加模块化和简化开发。在阅读代码时，当程序请求`{this.debugDNSLookup()}`时，它返回有关DNS查找时间的一些信息。如果我们内联函数，那么理解代码块的目的就会更困难：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In each of the debug functions, we check whether the performance object has
    support for the method we want to use. Most modern browsers support the High Resolution
    Time API, but support for the User Timing API is more spotty.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个调试函数中，我们检查性能对象是否支持我们想要使用的方法。大多数现代浏览器支持高分辨率时间API，但用户时间API的支持则更加零散。
- en: 'The math operation converts the time in milliseconds into seconds:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 数学运算将毫秒时间转换为秒：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If an error occurs, for instance, if the SuperAgent request call fails, we
    display an error message instead of providing any content, let''s take a look
    at the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，例如，如果SuperAgent请求调用失败，我们将显示错误消息而不是提供任何内容，让我们看一下以下代码：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We''ll show a set of bouncing balls until we have a position and a location,
    let''s take a look at the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将显示一组弹跳球，直到我们有一个位置和位置，让我们看一下以下代码：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If everything is good, we render the content:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将渲染内容：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When you've added this code, you should see the app start with a set of bouncing
    balls. Then, after it has fetched your location, you should see your coordinates
    in longitude and latitude values as well as your real location address. Below
    this, you should see a few lines of debug information.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当您添加了这段代码后，您应该看到应用以一组弹跳球开始。然后，在它获取了您的位置之后，您应该看到经纬度值以及您的真实位置地址。在此之下，您应该看到一些调试信息。
- en: 'One note about the largesse of this component: When writing components or indeed
    any code, the need to refactor increases roughly in tandem with the time you spend
    writing it. This component is a prime example because it now contains a lot of
    different logic. It does geolocation, debugging, as well as rendering. It would
    be wise to split it up into several different components for separation of concerns,
    as talked about in the comment to the renderContent() method. Let''s take a look
    at the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个组件的慷慨之处有一点要注意：在编写组件或任何代码时，随着你花费的时间增加，重构的需求也会大致增加。这个组件是一个很好的例子，因为它现在包含了很多不同的逻辑。它执行地理位置、调试以及渲染。明智的做法是将它拆分成几个不同的组件，以实现关注点的分离，正如在`renderContent()`方法的注释中所讨论的那样。让我们看一下以下截图：
- en: '![Setting up geolocation](img/B04943_05_01.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![设置地理位置](img/B04943_05_01.jpg)'
- en: The location should be quite accurate, and thanks to the comprehensive list
    of real-world addresses in OpenStreetMap, the translation to your current location
    should also be fairly close to where you are as well.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 位置应该相当准确，多亏了OpenStreetMap中详尽的现实世界地址列表，将您的当前位置转换为的位置也应该相当接近您所在的位置。
- en: The debug information lets you know how much time it takes from when the app
    is loaded until the view is ready. When running on localhost, **DNS** and **connection
    lookup** are always loaded in 0 milliseconds, instantaneously. When you are running
    your app on an external server, these numbers will go up and reflect how much
    time it would take to lookup your server and connect to it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 调试信息会告诉您从应用程序加载到视图准备就绪所需的时间。当在本地主机上运行时，**DNS** 和 **连接查找**总是以0毫秒的速度加载，瞬间完成。当您在外部服务器上运行应用程序时，这些数字将会增加，并反映查找您的服务器并连接到它所需的时间。
- en: In the preceding screenshot, you'll notice it doesn't take much time before
    the page is loaded and ready to be served. The really slow part of it is the amount
    of time you spend waiting for the app to fetch location data from reverse geolocation.
    As per the screenshot, it took approximately 1.5 seconds. This number will usually
    fluctuate between 1-10 seconds, and you won't be able to reduce it unless you
    find a way to cache the request.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，您会注意到页面加载并准备就绪所需的时间并不长。真正慢的部分是您等待应用程序从反向地理定位获取位置数据所需的时间。根据屏幕截图，大约需要1.5秒。这个数字通常会在1-10秒之间波动，除非您找到一种方法来缓存请求，否则您无法减少它。
- en: Now that we know we are able to fetch the user position and address, let's create
    some maps.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们能够获取用户的位置和地址，让我们创建一些地图。
- en: Showing static maps
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示静态地图
- en: 'A static map is simply an image snapshot of your chosen position. Using static
    maps has many benefits over interactive maps, for instance:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 静态地图只是您选择位置的图像快照。使用静态地图比交互式地图有许多优点，例如：
- en: No overhead. It's a plain image, so it's both fast and lightweight.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无额外开销。它是一个纯图像，因此它既快又轻量。
- en: You can pre-render and cache the map. This means less hits to the map provider
    and that you might get away with a smaller data plan.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以预先渲染和缓存地图。这意味着对地图提供商的访问次数更少，您可能可以使用更小的数据计划。
- en: Static also means that you have complete control of the map. Using a third-party
    service often means surrendering some control to the service.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态还意味着您对地图有完全的控制权。使用第三方服务通常意味着将一些控制权交给服务。
- en: There are a number of map providers that we can use to show maps of the world
    in addition to OpenStreetMap. Among those are Yahoo! Maps, Bing Maps, Google Maps,
    MapQuest, and more.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 OpenStreetMap 之外，我们还可以使用许多地图提供商来显示世界地图。其中还包括 Yahoo! 地图、Bing 地图、Google 地图、MapQuest
    等。
- en: We'll be setting up our app to connect to a few of these services, so you can
    compare and decide which one you prefer.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置我们的应用程序以连接到这些服务中的一小部分，这样您就可以比较并决定您更喜欢哪一个。
- en: 'Let''s open `config.json` again and add a few more endpoints. Add this just
    before the closing bracket of the file (make sure to add a comma after `openstreetmap`):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次打开 `config.json` 并添加更多端点。在文件的结束括号之前添加以下内容（确保在 `openstreetmap` 后面添加逗号）：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: For `Bing` and `mapQuest`, you need to set the `providerKey` key before you
    can use them. For Bing Maps, go to the **Bing Maps Dev Center** at [https://www.bingmapsportal.com/](https://www.bingmapsportal.com/),
    sign in, select **Keys** under **My Account**, and add an application to receive
    a key.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Bing` 和 `mapQuest`，在使用它们之前，您需要设置 `providerKey` 键。对于 Bing 地图，请访问 [https://www.bingmapsportal.com/](https://www.bingmapsportal.com/)
    上的 **Bing Maps Dev Center**，登录，在 **我的账户** 下选择 **密钥**，并添加一个应用程序以接收一个密钥。
- en: For mapQuest, go to [https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free](https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free)
    and create a free account. Create an application and retrieve your key.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 mapQuest，请访问 [https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free](https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free)
    并创建一个免费账户。创建一个应用程序并获取您的密钥。
- en: For Google, go to [https://developers.google.com/maps/documentation/static-maps/get-api-key](https://developers.google.com/maps/documentation/static-maps/get-api-key)
    and register a free API key.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Google，请访问 [https://developers.google.com/maps/documentation/static-maps/get-api-key](https://developers.google.com/maps/documentation/static-maps/get-api-key)
    并注册一个免费的API密钥。
- en: 'In order to use the endpoints, we''ll need to set up a service and a factory.
    Create `source/service/map-factory.js` and add this code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用端点，我们需要设置一个服务和工厂。创建 `source/service/map-factory.js` 并添加以下代码：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, create `source/service/map-service.js` and add this code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建 `source/service/map-service.js` 并添加以下代码：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We'll send `param` in the name of the provider, and we'll fetch the configuration
    data based on this.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在提供者的名称中发送 `param`，我们将根据这个获取配置数据。
- en: The map providers have different requirements for how you should join the size
    parameter, so we take the width and the height and join them based on the value
    in the configuration.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'All providers agree that latitude and longitude should be joined by a comma,
    so we set up a location variable in this format. Refer to the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This snippet will add any markers you''ve configured in `config.json`. We''ll
    only use this variable if there are any configured markers:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We''ll add the key and set the map type from the configuration. Bing calls
    the markers pushpin, so this variable is only used in Bing Maps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We'll set up two different URLs based on whether we're serving a Bing Map or
    a map from any other provider. Notice that we're using ES6 template strings to
    compose our URL. These are composed with backticks and use string substitution
    with the `${ }` syntax.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a different method than the one we used in `source/service/geo.js`, and
    in truth, we could have gone with the same approach here. Finally, we pass along
    the `id` variable from `params` and the finished map URL to our return function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we need to create a view for the static maps. What we''ll do is create
    three buttons that will enable us to open a map for our current location with
    all three map providers. Your app should look something like the one in the following
    screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing static maps](img/B04943_05_02.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: 'Create a folder called `views` under the `source` folder, add a file called
    `static-map.jsx`, and add this code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As seen in the preceding code, we''ll allow zooming as long as it''s between
    1 and 18\. We''ll use the current height and width of the device to set up our
    map canvas:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'These buttons will allow us to increase or decrease zoom, or exit back to the
    main menu:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Refer to the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You may wonder if there's any particular reason why we put this file in a `view`
    folder while the other files went into the `component` folder. There's not a programmatic
    reason for it. All files could be put into the component folder, and React wouldn't
    bat an eye. The purpose is to provide the programmer with a clue on how the data
    is meant to be structured, hopefully making it easier to understand when going
    back and editing the project.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to create a component called `static-map` that will take our map
    properties and serve along a valid image.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called `components`, add a new file called `static-map.jsx`,
    and add the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `location` object contains our map URL and all of the associated data that
    the `map-factory` parameter has produced:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is all the plumbing we need to present our static maps. Let's open up `app.jsx`
    and add the code that will tie these files together.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'In between the two rows in the `render` method, add a new row with this code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In our previous apps, we used routes to navigate back and forth, but this time,
    we're going to skip routes altogether and use these variables to show different
    states of our app.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re also going to need to add the two referenced functions, so add the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'At the top of the file, add these two imports:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And then finally, add the two functions referenced in the preceding code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `goBack` method simply nulls the provider. This will toggle whether we see
    the buttons or a map in the main view render.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open your app now, you''ll see three different buttons enabling you
    to open a map of your current location with either Google Maps, Bing Maps, or
    MapQuest. The picture will show the current location in Bing Maps, as in the following
    screenshot:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing static maps](img/B04943_05_03.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: Without some clever hardcoding, you can't open any location other than your
    own. Let's create an input box that lets you select a different location based
    on longitude and latitude and a select box that will conveniently set the location
    to any of a predefined number of world cities.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these functions to `app.jsx`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As seen in the preceding code, valid longitude values are between negative
    *180* and positive *180* degrees. We''ll fetch the current values passed to us
    from the `event` handler:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Valid latitude values are between negative *90* and positive *90* degrees:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Whenever the user clicks on the **Fetch** button, we execute a new reverse
    geolocation search:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here''s the new geolocation search:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Above the header with static maps in `render()`, add this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This alert will only be shown if the user tries to fetch a set of invalid coordinates.
    It will automatically disappear after 2,500 milliseconds, let''s take a look at
    the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing static maps](img/B04943_05_04.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: Creating an interactive map
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interactive maps offer a level of interactivity that is often expected by users
    presented with a map on a website.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of benefits in displaying an interactive map instead of
    a plain image:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: You can set markers outside the current viewport. It's perfect when you want
    to display a small map, but provide information about locations that can be discovered
    by moving or zooming the map.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive maps provide a playground for your users, making it more likely
    that they'll spend time at your site.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive content generally makes the app feel better compared to static content.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our interactive map, we'll be using a combination of `Leaflet` and `OpenStreetMap`.
    They're both open source and free resources, making them an excellent choice for
    our budding map app.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in `source/views` and call it `interactive-map.jsx`. Add
    the following code to it:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The Leaflet package fetches image tiles from `openstreetmap.org` with `x`,
    `y`, and `zoom` parameters. Refer to the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is the function we use when creating a map. We set the view with our chosen
    latitude, longitude, and zoom, and add a marker to the middle of the view.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'More markers can be added by passing a `location` object to the internal `setMarker`
    function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'On mounting it, we create a map with the internal function `createMap`, unless
    we pass along an external function via `props`, such as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We use inline styles to set the height of the map to 200 pixels less than the
    height of the viewport:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We''ll notify the user if we notice that the battery is running low on the
    device. To continually monitor the battery status, we''d need to set up an event
    listener described earlier in this chapter:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, open `app.jsx` and add the following code snippet at the end of `renderButtons()`,
    just above the closing `<div />`, such as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, replace the code in `renderMapView()` with this code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Finally, add the interactive-map view to the `import` section:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an interactive map](img/B04943_05_05.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: You should now be able to load the app and click on the **Interactive Map**
    button and be presented with an interactive map of your location. You can pinch,
    move, and zoom the map, and it will work on a smartphone or a tablet as well as
    on your desktop browser.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: You can extend this map with new markers and even different tiles. We've used
    OpenStreetMap throughout this app, but it's very easy to switch out. Take a look
    at [https://leaflet-extras.github.io/leaflet-providers/preview/](https://leaflet-extras.github.io/leaflet-providers/preview/)
    for an overview of what kind of tiles you can use.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: There's also a wide array of plugins to choose from, and you'll find those at
    [http://leafletjs.com/plugins.html](http://leafletjs.com/plugins.html).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the state of several useful HTML5 APIs. We then
    put them to good use when creating a map application that serves both static and
    interactive maps.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The static maps are set up to use a variety of different proprietary services,
    while the interactive map is set up to use the free and open maps service, OpenStreepMap,
    using a popular library called Leaflet.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: You can extend the interactive map by adding markers for a set of queries. For
    instance, you could use a service such as Google Maps to fetch a list of restaurants
    (Sushi restaurants, for example), and add a fish marker to each location using
    the Leaflet library. The possibilities are endless.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The finished project can be viewed online at [https://reactjsblueprints-chapter5.herokuapp.com](https://reactjsblueprints-chapter5.herokuapp.com).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create an application that requires the user to
    create an account and log in to take advantage of all the features of the app.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
