- en: BuckleScript, Belt, and Interoperability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BuckleScript、Belt和互操作性
- en: 'In this chapter, we''ll take a closer look at the BuckleScript-specific features
    that are available to us. We''ll also learn about recursion and recursive data
    structures. By the end of this chapter, we''ll have come full circle in the introduction
    to Reason and its ecosystem. In doing so, we''ll have done the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地了解BuckleScript特有的功能，这些功能对我们可用。我们还将学习递归和递归数据结构。在本章结束时，我们将完成Reason及其生态系统的介绍。在这个过程中，我们将完成以下工作：
- en: Learned more about Reason's module system
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更深入地了解了Reason的模块系统
- en: Explored more of Reason's primitive data structures (arrays and lists)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索了Reason的更多原始数据结构（数组和列表）
- en: Seen how the various pipe operators can make code more readable
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看到了各种管道操作符如何使代码更易于阅读
- en: Become familiar with the Reason and Belt standard libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉Reason和Belt标准库
- en: Created bindings to a JavaScript module for use within Reason
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为在Reason中使用创建了绑定到JavaScript模块
- en: Added route transitions to our application by binding to React Transition Group
    components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过绑定到React Transition Group组件为我们的应用程序添加了路由转换
- en: To follow along, use any environment you wish. Much of what we'll be doing is
    not ReasonReact-specific. Toward the end of the chapter, we'll resume building
    our ReasonReact app.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟上进度，请使用您想要的任何环境。我们将要做的大部分内容都不是ReasonReact特有的。在本章的结尾，我们将继续构建我们的ReasonReact应用程序。
- en: Module scope
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块作用域
- en: 'As you now know, all `.re` files are modules and all modules are globally available—including
    nested ones. By default, all types and bindings can be accessed from anywhere
    by providing the namespace. However, doing this over and over quickly becomes
    tedious. Luckily, we have a few ways to make this more pleasant:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在所知，所有`.re`文件都是模块，所有模块都是全局可用的——包括嵌套的模块。默认情况下，所有类型和绑定都可以通过提供命名空间在任何地方访问。然而，这样做会很快变得繁琐。幸运的是，我们有几种方法可以使这更加愉快：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we''ll use the `Foo` module''s `fromFoo` type along with it''s bindings
    within another module in different ways:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将以不同的方式使用`Foo`模块的`fromFoo`类型及其在另一个模块内的绑定：
- en: '**Option 1**: Without any sugar:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项1**：没有任何糖：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Option 2**: Alias the module to a shorter name. For example, we can declare
    a new module `F` and bind it to the existing module `Foo`:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项2**：将模块别名到更短的名字。例如，我们可以声明一个新的模块`F`并将其绑定到现有的模块`Foo`：'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Option 3**: Locally open the module using the `Module.()` syntax. This syntax
    only works with a single expression:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项3**：使用`Module.()`语法在本地打开模块。这种语法只适用于单个表达式：'
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Option 4**: In the OOP sense, have `Bar` extend `Foo` using `include`:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项4**：在面向对象的意义上，使用`include`让`Bar`扩展`Foo`：'
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Option 5**: Globally `open` the module. Use `open` sparingly in large scopes,
    since it becomes hard to know which types and bindings belong to which modules:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项5**：全局`打开`模块。在大范围内，`open`应谨慎使用，因为它会变得难以知道哪些类型和绑定属于哪个模块：'
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Prefer using `open` in local scopes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在局部作用域中使用`open`：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding syntax will reformat (via `refmt`) to Option 3''s syntax, but
    remember that Option 3''s syntax only works with single expressions. For example,
    the following isn''t able to be converted into Option 3''s syntax:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语法将通过`refmt`重新格式化为选项3的语法，但请记住，选项3的语法只适用于单个表达式。例如，以下内容无法转换为选项3的语法：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Reason standard library is found within a variety of modules that are already
    available to us. For example, Reason's standard library includes an `Array` module,
    and we can access its functions using the dot notation (that is, `Array.length`).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Reason标准库位于我们已可用的各种模块中。例如，Reason的标准库包括一个`Array`模块，我们可以使用点符号（即`Array.length`）来访问其函数。
- en: In [Chapter 5](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml), *Effective ML*,
    we'll learn how to hide a module's types and bindings so that they aren't globally
    available if we don't want them to be.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml)《有效的ML》中，我们将学习如何隐藏模块的类型和绑定，以便在不需要它们全局可用时不可用。
- en: Data structures
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: We've already seen several of Reason's primitive data structures including strings,
    integers, floats, tuples, records, and variants. Let's explore a few more.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Reason的几个原始数据结构，包括字符串、整数、浮点数、元组、记录和变体。让我们再探索一些。
- en: Array
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Reason arrays compile to regular JavaScript arrays. Reason arrays are as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Reason数组编译为常规JavaScript数组。Reason数组如下所示：
- en: Homogeneous (all elements must be of the same type)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同质（所有元素必须是同一类型）
- en: Mutable
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变
- en: Fast at random access and updates
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速的随机访问和更新
- en: 'They look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它们看起来像这样：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Accessing and updating elements of an array are the same as in JavaScript:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 访问和更新数组元素的方式与 JavaScript 中的相同：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In JavaScript, we map over the array, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们按照以下方式遍历数组：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To do the same in Reason, we have a few different options.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Reason 中做同样的事情，我们有几种不同的选择。
- en: Using the Reason standard library
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Reason 标准库
- en: 'The Reason standard library''s `Array` module contains several functions, but
    not all the ones you''d expect coming from JavaScript. It does have a `map` function,
    however:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 标准库的 `Array` 模块包含几个函数，但并非所有你从 JavaScript 中期望的函数都有。然而，它确实有一个 `map` 函数：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The type of `Array.map` is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.map` 的类型如下：'
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The type signature says `map` accepts a function of type `''a => ''b`, an array
    of type `''a`, and returns an array of type `''b`. Note that, `''a` and `''b`
    are **type variables**. Type variables are like normal variables, except for types.
    In the preceding example, `map` has a type:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 类型签名表明 `map` 接受一个类型为 `'a => 'b` 的函数，一个类型为 `'a` 的数组，并返回一个类型为 `'b` 的数组。注意，`'a`
    和 `'b` 是 **类型变量**。类型变量就像普通变量一样，只是它们是类型。在上面的例子中，`map` 的类型是：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is because the `'a` and `'b` type variables were both consistently replaced
    with the concrete `string` type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为类型变量 `'a` 和 `'b` 都被一致地替换成了具体的 `string` 类型。
- en: 'Note that, when using `Array.map`, the compiled output does not compile to
    JavaScript''s `Array.prototype.map`—it has its own implementation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当使用 `Array.map` 时，编译后的输出不会编译成 JavaScript 的 `Array.prototype.map`——它有自己的实现：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The Reason standard library documentation can be found here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 标准库的文档可以在这里找到：
- en: '[https://reasonml.github.io/api](https://reasonml.github.io/api)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[ReasonML API](https://reasonml.github.io/api)'
- en: Using the Belt standard library
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Belt 标准库
- en: 'The Reason standard library is actually the OCaml standard library. It was
    not created with JavaScript in mind. The Belt standard library was created by
    the same person who created BuckleScript—Hongbo Zhang—and ships with BuckleScript.
    Belt was made with JavaScript in mind and is especially known for its performance.
    The Belt standard library is accessed via the `Belt` module:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 标准库实际上是 OCaml 标准库。它不是针对 JavaScript 创建的。Belt 标准库是由创建 BuckleScript 的同一人
    Hongbo Zhang 创建的，并随 BuckleScript 一起提供。Belt 是针对 JavaScript 创建的，并且以其性能而闻名。Belt 标准库通过
    `Belt` 模块访问：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The Belt standard library documentation can be found here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Belt 标准库的文档可以在这里找到：
- en: '[https://bucklescript.github.io/bucklescript/api/Belt.html](https://bucklescript.github.io/bucklescript/api/Belt.html)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[BuckleScript API Belt](https://bucklescript.github.io/bucklescript/api/Belt.html)'
- en: Using BuckleScript's built-in JavaScript bindings
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 BuckleScript 内置的 JavaScript 绑定
- en: 'Another great option is to use BuckleScript''s built-in JavaScript bindings,
    found in the `Js` module:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的选择是使用 BuckleScript 内置的 JavaScript 绑定，这些绑定可以在 `Js` 模块中找到：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This option has the advantage of not requiring any dependencies in the compiled
    output. It also has a very familiar API. However, since not all Reason data structures
    exist in JavaScript, you'll likely be using a standard library. If so, prefer
    Belt.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种选项的优点是不需要在编译后的输出中依赖任何依赖。它还有一个非常熟悉的 API。然而，由于并非所有的 Reason 数据结构都存在于 JavaScript
    中，你可能会使用标准库。如果是这样，请优先选择 Belt。
- en: 'BuckleScript''s binding documentation can be found here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript 绑定文档可以在这里找到：
- en: '[https://bucklescript.github.io/bucklescript/api/Js.html](https://bucklescript.github.io/bucklescript/api/Js.html)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[BuckleScript API Js](https://bucklescript.github.io/bucklescript/api/Js.html)'
- en: Using a custom binding
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义绑定
- en: 'There''s nothing stopping you from writing your own custom bindings:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何阻止你编写自己的自定义绑定的：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Of course, you should favor using the built-in bindings in the `Js` module instead.
    We'll explore more custom bindings later in this chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你应该优先使用 `Js` 模块中的内置绑定。我们将在本章后面探索更多自定义绑定。
- en: Using raw JavaScript
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原生 JavaScript
- en: 'A last-resort option is to use actual JavaScript within Reason:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选择是在 Reason 中使用实际的 JavaScript：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: BuckleScript lets us drop into raw JavaScript as a way to stay productive while
    we're learning. Of course, when doing this, we give up the safety that Reason
    provides us with. So, once you are ready, convert any raw JavaScript code back
    into more idiomatic Reason.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript 让我们能够直接进入原生 JavaScript，这样我们可以在学习的同时保持高效。当然，当我们这样做的时候，我们放弃了 Reason
    为我们提供的安全性。所以，一旦你准备好了，将任何原生 JavaScript 代码转换回更符合 Reason 习惯的代码。
- en: 'When it comes to using raw JavaScript, use `%` for expressions and `%%` for
    statements. Remember, the `{| |}` is Reason''s multiline string syntax:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到使用原生 JavaScript 时，使用 `%` 表示表达式，`%%` 表示语句。记住，`{| |}` 是 Reason 的多行字符串语法：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using the raw expression syntax, we''re also able to annotate types:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原始表达式语法，我们也能够注释类型：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can even annotate function types:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以注释函数类型：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Although arrays are familiar when coming from JavaScript, you'll likely find
    yourself using lists instead, as they are ubiquitous in functional programming.
    Lists are both immutable and recursive. Let's now see how to use this recursive
    data structure.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数组在从 JavaScript 过来时很熟悉，但你可能会发现自己更倾向于使用列表，因为它们在函数式编程中无处不在。列表既是不可变的也是递归的。现在让我们看看如何使用这种递归数据结构。
- en: List
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'Reason lists are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 列表如下：
- en: Homogeneous
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同质
- en: Immutable
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变
- en: Fast at prepending and accessing the head of the list
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速在列表前添加和访问头部
- en: 'They look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它们看起来像这样：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The head of the list, in this case, is `"first"`. By now, we've seen that it's
    not difficult to work with immutable data structures. Instead of mutation, we
    create updated copies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，列表的头部是 `"first"`。到目前为止，我们已经看到处理不可变数据结构并不困难。我们不是进行修改，而是创建更新的副本。
- en: 'When working with lists, we can''t use JavaScript bindings directly, since
    lists do not exist in JavaScript as a primitive data structure. However, we can
    convert lists to arrays and vice versa:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理列表时，我们不能直接使用 JavaScript 绑定，因为列表在 JavaScript 中不是一个原始数据结构。然而，我们可以将列表转换为数组，反之亦然：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But we can also map over a list directly:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以直接在列表上使用 `map`：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Logging `list` to the console shows that lists are represented as nested arrays
    in JavaScript where each array always has two elements:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中记录 `list` 显示，列表在 JavaScript 中表示为嵌套数组，其中每个数组总是有两个元素：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This makes sense after understanding that a list is a recursive data structure.
    Reason lists are **singly linked lists**. Each element in a list is either **empty**
    (represented as `0` in JavaScript) or the **combination** of a value and another
    list.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解列表是一个递归数据结构之后，这就有意义了。Reason 列表是**单链表**。列表中的每个元素要么是**空**（在 JavaScript 中表示为
    `0`），要么是值和另一个列表的组合。
- en: 'An example type definition for `list` reveals that `list` is a variant:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`list` 的一个示例类型定义揭示了 `list` 是一个变体：'
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note: type definitions can be recursive.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：类型定义可以是递归的。
- en: 'Reason provides some syntactic sugar that simplifies its more verbose version:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 提供了一些语法糖，简化了其更冗长的版本：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Recursion
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: Since list is a recursive data structure, we typically use recursion when working
    with it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表是一个递归数据结构，我们在处理它时通常使用递归。
- en: 'To get warmed up, let''s write a (naive) function that sums a list of integers:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了热身，让我们编写一个（初级的）求整数列表总和的函数：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a recursive function and therefore requires the `rec` keyword (that
    is, `let rec` instead of just `let`)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个递归函数，因此需要 `rec` 关键字（即，`let rec` 而不是 `let`）
- en: We can pattern match on a list (just like any other variant and many other data
    structures)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在列表上使用模式匹配（就像任何其他变体和许多其他数据结构一样）
- en: From the example type definition, `Empty` is represented as `[]` and `Head` is
    represented as `[hd, ...tl]` where `hd` is the **head** of the list and `tl` is
    the rest (that is, the **tail**) of the list
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从示例类型定义中，`Empty` 表示为 `[]`，`Head` 表示为 `[hd, ...tl]`，其中 `hd` 是列表的**头部**，`tl` 是列表的其余部分（即，**尾部**）
- en: '`tl` could be `[]` (that is, `Empty`) and when it is, recursion stops'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tl` 可以是 `[]`（即，`Empty`），当它是这样的时候，递归停止'
- en: 'Passing `sum` the list `[1, 2, 3]` results in the following steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表 `[1, 2, 3]` 传递给 `sum`，会产生以下步骤：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s get a bit more comfortable with lists and recursion by analyzing another
    (naive) function that reverses a list:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过分析另一个（初级的）反转列表的函数来更熟悉列表和递归：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Again, we use `rec` to define a recursive function
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次，我们使用 `rec` 来定义一个递归函数
- en: Again, we use pattern matching on the list—if it's empty, stop recursion; otherwise,
    continue with a smaller list
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次，我们在列表上使用模式匹配——如果它是空的，停止递归；否则，继续使用更小的列表
- en: The `@` operator appends the second list to the end of the first list
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@` 操作符将第二个列表追加到第一个列表的末尾'
- en: 'Passing in the previously defined list (`["first", "second", "third"]`) results
    in the following steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将先前定义的列表（`["first", "second", "third"]`）传递进去，会产生以下步骤：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This implementation of reverse is naive for two reasons:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 reverse 的实现是初级的，原因有两个：
- en: It's not tail call optimized (nor is our `sum` function)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不是尾调用优化（我们的 `sum` 函数也不是）
- en: It uses `append` (`@`), which is slower than `prepend`
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用 `append` (`@`)，这比 `prepend` 慢
- en: 'A better implementation would be to use a local helper function with an accumulator:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的实现是使用带有累加器的局部辅助函数：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, its tail call is optimized and it uses prepend instead of append. In Reason,
    you prepend to a list using the `...` syntax:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它的尾调用已优化，并使用 `prepend` 代替 `append`。在 Reason 中，您可以使用 `...` 语法向列表中添加元素：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Passing in the list (`["first", "second", "third"]`) roughly results in the
    following steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表（`["first", "second", "third"]`）传入大致相当于以下步骤：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that in the non-tail recursive version, Reason cannot create the list
    until recursion completes. In the tail recursive version, the accumulator (that
    is, the second argument of `aux`) is updated after each iteration.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在非尾递归版本中，Reason 无法在递归完成之前创建列表。在尾递归版本中，累加器（即 `aux` 的第二个参数）在每次迭代后更新。
- en: Tail recursive (that is, tail call optimized) functions have the benefit of
    being able to reuse the current stack frame. As a result, tail recursive functions
    will never have a stack overflow, but non-tail recursive functions may have a
    stack overflow given enough iterations.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归（即尾调用优化）函数的好处是能够重用当前的栈帧。因此，尾递归函数永远不会发生栈溢出，但非尾递归函数在迭代足够多的情况下可能会发生栈溢出。
- en: Pipe operators
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道运算符
- en: 'Reason has two pipe operators:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 有两个管道运算符：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Both pipe operators pass arguments to functions. The `|>` pipe operator pipes
    to a function's last argument and the `->` fast pipe operator pipes to a function's
    first argument.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 两个管道运算符都将参数传递给函数。`|>` 管道运算符将参数传递给函数的最后一个参数，而 `->` 快速管道运算符将参数传递给函数的第一个参数。
- en: 'Take a look at these:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这些：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'They are equivalent to this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它们等同于以下内容：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the function only accepts one argument, then both pipes work the same, since
    the function's first argument is also the function's last argument.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数只接受一个参数，那么两个管道的工作方式相同，因为函数的第一个参数也是函数的最后一个参数。
- en: Using these pipe operators is quite popular, since, once you get the hang of
    it, it makes the code a lot more readable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些管道运算符非常流行，因为一旦您掌握了它们，代码的可读性就会大大提高。
- en: 'We don''t need to use this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要使用这个：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can write it in a way that doesn''t require the reader to read it inside
    out:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以不需要读者从内向外阅读的方式编写它：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, using fast pipe looks similar to chaining in JavaScript. Unlike
    JavaScript, we can pass reduce the `+` function, since it is just a normal function
    that accepts two arguments and adds them. The parentheses are necessary to tell
    Reason to treat the infix operator `(+)` as an identifier.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用快速管道看起来类似于 JavaScript 中的链式调用。与 JavaScript 不同，我们可以传递 `+` 函数进行缩减，因为它只是一个接受两个参数并相加的正常函数。括号是必要的，以便让
    Reason 将中缀运算符 `(+)` 视为一个标识符。
- en: Using Belt
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Belt
- en: Let's use what we've learned so far in this chapter to write a small program
    that creates a deck of cards, shuffles it, and draws five cards from the top of
    the deck. To do so, we'll use Belt's `Option` and `List` modules, as well as the
    fast pipe operator.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用本章到目前为止所学的知识来编写一个小程序，该程序创建一副牌，将其洗牌，并从牌顶抽取五张牌。为此，我们将使用 Belt 的 `Option` 和
    `List` 模块，以及快速管道运算符。
- en: Option module
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项模块
- en: 'Belt''s `Option` module is a collection of utility functions for working with
    the `option` type. For example, to unwrap an option and throw a runtime exception
    if the option''s value is `None`, we can use `getExn`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Belt 的 `Option` 模块是一组用于处理 `option` 类型的实用函数。例如，要解包选项并抛出运行时异常，如果选项的值为 `None`，我们可以使用
    `getExn`：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Belt functions that are able to throw runtime exceptions always have the `Exn`
    suffix.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 能够抛出运行时异常的 Belt 函数总是带有 `Exn` 后缀。
- en: 'An alternative function to unwrap an option that isn''t able to throw a runtime
    exception is `getWithDefault`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 解包无法抛出运行时异常的选项的替代函数是 `getWithDefault`：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `Option` module provides several other functions such as `isSome`, `isNone`,
    `map`, `mapWithDefault`, and more. Check the documentation for details.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option` 模块提供了其他几个函数，如 `isSome`、`isNone`、`map`、`mapWithDefault` 等。有关详细信息，请参阅文档。'
- en: 'Belt Option module documentation can be found here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Belt 选项模块文档可以在这里找到：
- en: '[https://bucklescript.github.io/bucklescript/api/Belt.Option.html](https://bucklescript.github.io/bucklescript/api/Belt.Option.html)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bucklescript.github.io/bucklescript/api/Belt.Option.html](https://bucklescript.github.io/bucklescript/api/Belt.Option.html)'
- en: List module
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表模块
- en: List module are the utilities for list data types. To see what functions Belt
    provides for working with lists, inspect Belt's `List` modules documentation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表模块是用于列表数据类型的实用工具。要查看 Belt 为处理列表提供的函数，请检查 Belt 的 `List` 模块文档。
- en: 'Belt List module documentation can be found here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Belt 列表模块文档可以在这里找到：
- en: '[https://bucklescript.github.io/bucklescript/api/Belt.List.html](https://bucklescript.github.io/bucklescript/api/Belt.List.html)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bucklescript.github.io/bucklescript/api/Belt.List.html](https://bucklescript.github.io/bucklescript/api/Belt.List.html)'
- en: Let's focus on a few of them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注其中的一些。
- en: make
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: make
- en: 'The `make` function is used to create a populated list. It accepts an integer
    for the length of the list and a value for each item in the list. Its type is
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 函数用于创建一个已填充的列表。它接受一个整数作为列表的长度，以及列表中每个项目的值。其类型如下：'
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`Belt.List.t` is exposed as an alias of the `list` type, so we can say the
    type of `Belt.List.make` is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Belt.List.t` 被公开作为 `list` 类型的别名，因此我们可以说 `Belt.List.make` 的类型如下：'
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can use it to create a list containing ten strings, like so:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用它来创建一个包含十个字符串的列表，如下所示：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In [Chapter 5](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml), *Effective ML*,
    we will learn about how to explicitly expose or hide types and bindings from a
    module.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml)，*Effective ML*，我们将学习如何显式地从一个模块中公开或隐藏类型和绑定。
- en: makeBy
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: makeBy
- en: The `makeBy` function is like the `make` function, except it accepts a function
    used to determine the value of each item given the item's index.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeBy` 函数类似于 `make` 函数，但它接受一个函数，用于根据项目的索引确定每个项目的值。'
- en: 'The type of the `makeBy` function is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeBy` 函数的类型如下：'
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can use it to create a list of ten items, where each item is equal to its
    index:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用它来创建一个包含十个项目的列表，其中每个项目等于其索引：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: shuffle
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: shuffle
- en: 'The `shuffle` function randomly shuffles a list. It has type:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`shuffle` 函数随机洗牌。它的类型如下：'
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It accepts a list and returns a new list. Let''s use it to shuffle our list
    of integers:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个列表并返回一个新的列表。让我们用它来洗我们的整数列表：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: take
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: take
- en: 'The `take` function accepts a list and a length and returns a subset of the
    list starting from the head of the list with length equal to the requested length.
    Since the requested length of the subset may exceed the original list''s length,
    the result is wrapped in an option. Its type is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`take` 函数接受一个列表和一个长度，并返回从列表头部开始的长度等于请求长度的子集。由于子集的请求长度可能超过原始列表的长度，因此结果被包裹在选项中。其类型如下：'
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can take the first two items from our shuffled list, like so:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从洗好的列表中取出前两个项目，如下所示：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Deck of cards example
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆叠牌的示例
- en: Now, we're ready to combine this with what we've learned from previous chapters.
    How would you write a program that creates a deck of cards, shuffles it, and draws
    the first five cards? Before looking at the following example, give it a shot
    yourself.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好将之前章节中学到的知识结合起来。你会如何编写一个程序来创建一副牌，洗牌，并抽取前五张牌？在查看以下示例之前，先自己试一试。
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This yields an array of five cards at random in string format:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生一个包含五张随机字符串格式的牌的数组：
- en: '[PRE52]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Currying
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Currying
- en: 'Some of the Belt standard library functions have a *U* suffix, such as this
    one:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Belt 标准库的一些函数有 *U* 后缀，例如这个：
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can see the suffix here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里的后缀：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The *U* suffix stands for *uncurried*. Before going further, let's define currying.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*U* 后缀代表 *uncurried*。在继续之前，让我们定义 currying。'
- en: 'In Reason, every function accepts exactly one argument. This seems to contradict
    many of our earlier examples:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Reason 中，每个函数恰好接受一个参数。这似乎与我们之前的许多例子相矛盾：
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding `add` function looks as if it accepts two arguments, but it is
    actually just syntactic sugar for the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `add` 函数看起来像接受两个参数，但实际上它只是以下内容的语法糖：
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `add` function accepts a single argument, `a`, which returns a function
    that accepts a single argument, `b`, and then returns the result of `a + b`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 函数接受一个单一参数 `a`，它返回一个接受单一参数 `b` 的函数，然后返回 `a + b` 的结果。'
- en: 'In Reason, both versions are valid and have the same compiled output. In JavaScript,
    both of the preceding versions are valid, but they are not the same; they would
    need to be used differently to get the same result. The second would need to be
    called like so:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Reason 中，两种版本都是有效的，并且有相同的编译输出。在 JavaScript 中，前两种版本都是有效的，但它们并不相同；它们需要以不同的方式使用才能得到相同的结果。第二个需要像这样调用：
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This is because `add` returns a function that then needs to be called again,
    hence the two sets of parenthesis. Reason would accept either usage:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `add` 返回一个函数，然后需要再次调用，因此有两个括号组。理由接受两种用法：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The benefit of currying is that it makes composing functions easier. You can
    easily create a function, `addOne`, that is partially applied:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Currying 的好处是它使函数组合更容易。你可以轻松创建一个部分应用的函数，`addOne`：
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This `addOne` function could then be passed to other functions such as `map`.
    Perhaps you'd like to use this feature to pass a function to a ReasonReact child
    component with the parent component's `self` partially applied.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `addOne` 函数可以被传递给其他函数，例如 `map`。也许你想使用这个特性将一个函数传递给 ReasonReact 子组件，并使用父组件的
    `self` 部分应用。
- en: 'Confusingly, the compiled output of either version of `add` is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 令人困惑的是，`add` 的任何版本的编译输出如下：
- en: '[PRE60]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Where is the intermediate function? Wherever possible, BuckleScript optimizes
    the compiled output to avoid the unnecessary function allocation, which improves
    performance.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 中间函数在哪里？尽可能的情况下，BuckleScript 会优化编译输出以避免不必要的函数分配，从而提高性能。
- en: 'Remember, since Reason''s infix operators are just normal functions, we could
    have just done the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，由于 Reason 的中缀运算符只是普通函数，我们本可以这样做：
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Uncurried functions
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未应用柯里化的函数
- en: 'Due to JavaScript''s dynamic nature, BuckleScript cannot always optimize the
    compiled output to remove the intermediate functions. However, you can tell BuckleScript
    to uncurry a function using the following syntax:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 的动态特性，BuckleScript 无法总是优化编译输出以删除中间函数。然而，你可以使用以下语法告诉 BuckleScript
    未应用柯里化一个函数：
- en: '[PRE62]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The uncurry syntax is the dot in the argument list. It needs to be present
    at both the declaration and call sites:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 未应用柯里化的语法是参数列表中的点。它需要在声明和调用位置都存在：
- en: '[PRE63]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'BuckleScript will throw a compile time error if the call site isn''t using
    the uncurry syntax:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用位置没有使用未应用柯里化的语法，BuckleScript 将抛出编译时错误：
- en: '[PRE64]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Also, a compile time error is thrown if some of the function''s arguments are
    missing at the call site:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果在调用位置缺少函数的一些参数，则会抛出编译时错误：
- en: '[PRE65]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The term `arity` refers to the number of arguments a function accepts.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 `arity` 指的是函数接受的参数数量。
- en: makeByU
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: makeByU
- en: 'We can replace `makeBy` with `makeByU` if we uncurry its second argument. This
    will improve performance (a negligible amount in our example):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们未应用其第二个参数，我们可以用 `makeByU` 替换 `makeBy`。这将提高性能（在我们的例子中是微不足道的）：
- en: '[PRE66]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The dot syntax requires parentheses around `i`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 点语法需要在 `i` 的周围使用括号。
- en: JavaScript interoperability
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 互操作性
- en: The term **interoperability** refers to the ability for Reason programs to use
    existing JavaScript within Reason. BuckleScript provides an excellent system for
    using existing JavaScript code within Reason, and also makes it easy to use Reason
    code within JavaScript.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 **互操作性** 指的是 Reason 程序在 Reason 中使用现有 JavaScript 的能力。BuckleScript 提供了一个出色的系统，用于在
    Reason 中使用现有的 JavaScript 代码，并且也使得在 JavaScript 中使用 Reason 代码变得容易。
- en: Using JavaScript in Reason
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Reason 中使用 JavaScript
- en: We've already seen how we can use raw JavaScript in Reason. Let's now focus
    on how to bind to existing JavaScript. To bind a value to a named reference, we
    typically use `let`. That binding can then be used in subsequent code. When the
    value we want to bind to lives is JavaScript, we use `external`. The `external`
    binding is like a `let`, in the sense that it can be used in subsequent code.
    Unlike `let`, `external` is typically accompanied by BuckleScript decorators such
    as `[@bs.val]`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在 Reason 中使用原始 JavaScript。现在让我们关注如何绑定到现有的 JavaScript。要将值绑定到命名引用，我们通常使用
    `let`。然后，该绑定可以在后续代码中使用。当我们要绑定的值位于 JavaScript 中时，我们使用 `external`。`external` 绑定就像
    `let` 一样，因为它可以在后续代码中使用。与 `let` 不同的是，`external` 通常伴随着 BuckleScript 装饰器，如 `[@bs.val]`。
- en: Understanding the [@bs.val] decorator
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 `[@bs.val]` 装饰器
- en: 'We can use `[@bs.val]` to bind to global values and functions. In general,
    the syntax is as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `[@bs.val]` 来绑定到全局值和函数。通常，语法如下：
- en: '[PRE67]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: One or more BuckleScript decorators (that is, `[@bs.val]`)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个 BuckleScript 装饰器（即 `[@bs.val]`）
- en: The `external` keyword
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`external` 关键字'
- en: The binding's named reference
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定的命名引用
- en: The type declaration
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型声明
- en: An equal sign
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个等号
- en: A string
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串
- en: 'The external keyword binds `alert` to a value of type `string => unit` and
    is bound to the string `alert`. The string `alert` is the value of the above external
    declaration and is what is going to be used in the compiled output. When the name
    of the external binding is equal to its string value, the string can be left empty:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`external` 关键字将 `alert` 绑定到类型为 `string => unit` 的值，并绑定到字符串 `alert`。字符串 `alert`
    是上述外部声明的值，也是将在编译输出中使用的值。当外部绑定的名称与其字符串值相等时，字符串可以留空：'
- en: '[PRE68]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Using the binding is just like using any other binding:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绑定就像使用任何其他绑定一样：
- en: '[PRE69]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Understanding the [@bs.scope] decorator
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 `[@bs.scope]` 装饰器
- en: 'To bind to `window.location.pathname`, we add a scope using `[@bs.scope]`.
    This defines the scope for `[@bs.val]`. For example, if you want to bind to the
    `pathname` property of `window.location`, you can specify the scope as `[@bs.scope
    ("window", "location")]`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要绑定到 `window.location.pathname`，我们使用 `[@bs.scope]` 添加一个作用域。这定义了 `[@bs.val]`
    的作用域。例如，如果你想绑定到 `window.location` 的 `pathname` 属性，你可以指定作用域为 `[@bs.scope ("window",
    "location")]`：
- en: '[PRE70]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Or, we could include the scope in the string using only `[@bs.val]`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `[@bs.val]` 仅在字符串中包含作用域：
- en: '[PRE71]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Understanding the [@bs.send] decorator
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 `[@bs.send]` 装饰器
- en: 'The `[@bs.send]` decorator is for binding to an object''s methods and properties.
    When using `[@bs.send]`, the first argument is always the object. If there are
    remaining arguments, they will get applied to the object''s method:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`[@bs.send]` 装饰器用于绑定到对象的函数和方法。当使用 `[@bs.send]` 时，第一个参数总是对象。如果有剩余的参数，它们将被应用到对象的方法上：'
- en: '[PRE72]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `Dom` module is also provided by BuckleScript and provides type declarations
    for the DOM.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dom` 模块也由 BuckleScript 提供，并为 DOM 提供类型声明。'
- en: 'The Dom module documentation can be found here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Dom 模块文档可以在这里找到：
- en: '[https://bucklescript.github.io/bucklescript/api/Dom.html](https://bucklescript.github.io/bucklescript/api/Dom.html)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bucklescript.github.io/bucklescript/api/Dom.html](https://bucklescript.github.io/bucklescript/api/Dom.html)'
- en: 'There is also a Node module for use with Node.js:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个用于 Node.js 的 Node 模块：
- en: '[https://bucklescript.github.io/bucklescript/api/Node.html](https://bucklescript.github.io/bucklescript/api/Node.html)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bucklescript.github.io/bucklescript/api/Node.html](https://bucklescript.github.io/bucklescript/api/Node.html)'
- en: 'Be careful when writing external declarations since you can accidentally lie
    to the type system, which could result in runtime type errors. For example, we
    told Reason that our `getElementById` binding always returns a `Dom.element`,
    but it returns `undefined` when the DOM can''t find an element with the provided
    ID. A more correct binding would be this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写外部声明时要小心，因为你可能会无意中向类型系统撒谎，这可能导致运行时类型错误。例如，我们告诉 Reason 我们的 `getElementById`
    绑定总是返回一个 `Dom.element`，但当 DOM 找不到具有提供的 ID 的元素时，它返回 `undefined`。一个更正确的绑定方式如下：
- en: '[PRE73]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Understanding the [@bs.module] decorator
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 `[@bs.module]` 装饰器
- en: To import a node module, use `[@bs.module]`. The compiled output depends on
    the `package-specs` configuration used within `bsconfig.json`. We're using `es6` as
    the module format.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入一个节点模块，使用 `[@bs.module]`。编译输出取决于在 `bsconfig.json` 中使用的 `package-specs` 配置。我们使用
    `es6` 作为模块格式。
- en: '[PRE74]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This compiles to the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这编译成以下内容：
- en: '[PRE75]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Setting the module format to `commonjs` results in the following compiled output:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块格式设置为 `commonjs` 导致以下编译输出：
- en: '[PRE76]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: When there is no string argument to `[@bs.module]`, the default value is imported.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有字符串参数传递给 `[@bs.module]` 时，默认值将被导入。
- en: Reasonable APIs
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合理的 API
- en: When binding to existing JavaScript APIs, think about how you'd like to use
    the API in Reason. Even existing JavaScript APIs that rely heavily on JavaScript's
    dynamic typing can be used in Reason. BuckleScript leverages advanced type system
    techniques that let us take advantage of Reason's type system with such APIs.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当绑定到现有的 JavaScript API 时，考虑你如何在 Reason 中使用该 API。即使那些严重依赖 JavaScript 动态类型的现有
    JavaScript API 也可以在 Reason 中使用。BuckleScript 利用高级类型系统技术，让我们可以利用 Reason 的类型系统来使用这些
    API。
- en: 'From the BuckleScript documentation, take a look at the following JavaScript
    function:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从 BuckleScript 文档中，查看以下 JavaScript 函数：
- en: '[PRE77]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If we were to bind to this function in Reason, it would be nice to use `padding`
    as a variant. Here is how we would do that:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要在 Reason 中绑定到这个函数，使用 `padding` 作为变体会很方便。以下是实现方式：
- en: '[PRE78]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This compiles to the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这编译成以下内容：
- en: '[PRE79]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The type of `padLeft` is `(string, some_variant) => string`, where `some_variant` uses
    an advanced type system feature called **polymorphic variant**, which that uses `[@bs.unwrap]`
    to get converted to something JavaScript can understand. We'll learn more about
    polymorphic variants in [Chapter 5](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml),
    *Effective ML*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`padLeft` 的类型是 `(string, some_variant) => string`，其中 `some_variant` 使用一个名为
    **多态变体** 的高级类型系统特性，它使用 `[@bs.unwrap]` 将其转换为 JavaScript 可以理解的内容。我们将在 [第 5 章](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml)，*有效的
    ML* 中了解更多关于多态变体的内容。'
- en: BuckleScript documentation
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BuckleScript 文档
- en: Although this was just a brief introduction, you can see that BuckleScript has
    a lot of tools to help us communicate with idiomatic JavaScript. I highly encourage
    you to read the BuckleScript docs to learn more about JavaScript interoperability.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是一个简要的介绍，但你可以看出 BuckleScript 有很多工具可以帮助我们与惯用 JavaScript 进行通信。我强烈建议你阅读 BuckleScript
    文档，以了解更多关于 JavaScript 互操作性的信息。
- en: 'BuckleScript documentation can be found here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript 文档可以在以下位置找到：
- en: '[https://bucklescript.github.io/docs/interop-overview](https://bucklescript.github.io/docs/interop-overview)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bucklescript.github.io/docs/interop-overview](https://bucklescript.github.io/docs/interop-overview)'
- en: Binding to existing ReactJS components
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定到现有的 ReactJS 组件
- en: ReactJS components are not Reason components. To use an existing ReactJS component,
    we use `[@bs.module]` to import the node module, and then use the `ReasonReact.wrapJsForReason`
    helper function to convert the ReactJS component to a Reason component. There
    is also a `ReasonReact.wrapReasonForJs` helper function for using Reason in ReactJS.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS 组件不是 Reason 组件。要使用现有的 ReactJS 组件，我们使用 `[@bs.module]` 来导入节点模块，然后使用 `ReasonReact.wrapJsForReason`
    辅助函数将 ReactJS 组件转换为 Reason 组件。还有一个 `ReasonReact.wrapReasonForJs` 辅助函数用于在 ReactJS
    中使用 Reason。
- en: Let's resume building our app from where we left off in [Chapter 3](21586d11-fa31-446f-99f1-dae3beecdb9b.xhtml),
    *Creating ReasonReact Components:*
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 [第 3 章](21586d11-fa31-446f-99f1-dae3beecdb9b.xhtml) 中我们停止的地方继续构建我们的应用程序：*创建
    ReasonReact 组件*：
- en: '[PRE80]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here, we''ll add route transitions by binding to the existing React Transition
    Group components:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过绑定现有的 React Transition Group 组件来添加路由转换：
- en: 'React Transition Group documentation can be found here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: React Transition Group 文档可以在以下位置找到：
- en: '[https://reactcommunity.org/react-transition-group/](https://reactcommunity.org/react-transition-group/)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://reactcommunity.org/react-transition-group/](https://reactcommunity.org/react-transition-group/)'
- en: Importing dependencies
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入依赖
- en: Run `npm install --save react-transition-group` to install the dependency.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `npm install --save react-transition-group` 来安装依赖。
- en: 'Let''s create a new file called `ReactTransitionGroup.re` to house these bindings.
    In this file, we''ll bind to the `TransitionGroup` and `CSSTransition` components:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `ReactTransitionGroup.re` 的新文件来存放这些绑定。在这个文件中，我们将绑定到 `TransitionGroup`
    和 `CSSTransition` 组件：
- en: '[PRE81]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Creating the make functions
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 make 函数
- en: Next, we create the components' required `make` functions. This is where we
    use the `ReasonReact.wrapJsForReason` helper function.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建组件所需的 `make` 函数。这是我们使用 `ReasonReact.wrapJsForReason` 辅助函数的地方。
- en: 'For `TransitionGroup`, we won''t need any props. Since the `~props` argument
    is required, we pass `Js.Obj.empty()`. The `~reactClass` argument is passed the
    external binding we created in the previous step:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `TransitionGroup`，我们不需要任何属性。由于需要 `~props` 参数，我们传递 `Js.Obj.empty()`。`~reactClass`
    参数传递了我们之前步骤中创建的外部绑定：
- en: '[PRE82]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Now, `ReactTransitionGroup.TransitionGroup` is a ReasonReact component that
    can be used in our app.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`ReactTransitionGroup.TransitionGroup` 是一个 ReasonReact 组件，我们可以在我们的应用程序中使用它。
- en: Using [@bs.deriving abstract]
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 [@bs.deriving abstract]
- en: '`CSSTransitionGroup` will need the following props:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`CSSTransitionGroup` 需要以下属性：'
- en: '`_in`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_in`'
- en: '`timeout`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`'
- en: '`classNames`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classNames`'
- en: Since `in` is a reserved word in Reason, the convention is to use `_in` in Reason
    and have BuckleScript compile it to `in` for JavaScript using `[@bs.as "in"]`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `in` 是 Reason 的保留字，因此约定在 Reason 中使用 `_in`，并由 BuckleScript 编译为 JavaScript
    中的 `in` 使用 `[@bs.as "in"]`。
- en: 'BuckleScript provides `[@bs.deriving abstract]` for easily working with certain
    types of JavaScript objects. Instead of creating an object in JavaScript and binding
    to that object, we can create that object directly using BuckleScript:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript 提供 `[@bs.deriving abstract]` 以便于处理某些类型的 JavaScript 对象。我们不需要在 JavaScript
    中创建对象并绑定到该对象，可以直接使用 BuckleScript 创建该对象：
- en: '[PRE83]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Note: `cssTransitionProps` is not a record type, it just looks like one.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`cssTransitionProps` 不是一个记录类型，它看起来像是一个。
- en: 'When using `[@bs.deriving abstract]`, a helper function is automatically provided
    to create JavaScript objects of that shape. This helper function is also named
    `cssTransitionProps`. We use this helper function in the component''s `make` function
    to create the component''s props:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `[@bs.deriving abstract]` 时，会自动提供一个辅助函数来创建该形状的 JavaScript 对象。这个辅助函数也命名为
    `cssTransitionProps`。我们在组件的 `make` 函数中使用这个辅助函数来创建组件的属性：
- en: '[PRE84]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Using the components
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件
- en: 'Now, in `App.re`, we can change the render function to use these components.
    We''ll change this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `App.re` 中，我们可以更改渲染函数以使用这些组件。我们将更改如下：
- en: '[PRE85]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now it appears as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它看起来如下所示：
- en: '[PRE86]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Note: The key prop is a special ReactJS prop and should not be part of the
    component''s props argument in `ReasonReact.wrapJsForReason`. The same is true
    for the special ReactJS ref prop.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：键（key）属性是一个特殊的 ReactJS 属性，不应成为 `ReasonReact.wrapJsForReason` 组件的 props 参数的一部分。对于特殊的
    ReactJS ref 属性也是如此。
- en: 'For completeness, here is the corresponding CSS, which can be found in `ReactTransitionGroup.scss`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，以下是相应的 CSS，可以在 `ReactTransitionGroup.scss` 中找到：
- en: '[PRE87]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Be sure to require the preceding in `ReactTransitionGroup.re`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要在 `ReactTransitionGroup.re` 中要求前面的内容：
- en: '[PRE88]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Now, when changing routes, the old route's content animates down and fades out
    before the new route's content animates up and fades in.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当切换路由时，旧路由的内容会先向下动画并淡出，然后新路由的内容才会向上动画并淡入。
- en: Summary
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: BuckleScript is incredibly powerful because it lets us interoperate with idiomatic
    JavaScript in a very pleasant way. It also provides the Belt standard library,
    which was created with JavaScript in mind. We learned about arrays and lists,
    and we saw how easy it is to use existing ReactJS components within Reason.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript 非常强大，因为它让我们以一种非常愉快的方式与惯用的 JavaScript 进行交互。它还提供了 Belt 标准库，该库是考虑到
    JavaScript 而创建的。我们学习了数组和列表，并看到了如何在 Reason 中使用现有的 ReactJS 组件是多么容易。
- en: In [Chapter 5](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml), *Effective ML*,
    we'll learn about how to use module signatures to hide a component's implementation
    details while building an autocomplete input component. We'll start with hardcoded
    data at first, and in [Chapter 6](a6ac6581-d3bd-49f3-ad4d-bfed965287ca.xhtml),
    *CSS-in-JS (in Reason)*, we'll move that data to `localStorage` (client-side web
    storage).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml)，《有效的机器学习》中，我们将学习如何使用模块签名在构建自动完成输入组件时隐藏组件的实现细节。我们最初会使用硬编码的数据，然后在
    [第 6 章](a6ac6581-d3bd-49f3-ad4d-bfed965287ca.xhtml)，《CSS-in-JS（在 Reason 中）》中，我们将把数据移动到
    `localStorage`（客户端 Web 存储）。
