- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Key Principles and Components of Microfrontends
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微前端的关键原则和组件
- en: Microfrontends are a double-edged sword. When done right, they can bring a great
    amount of joy and productivity to teams; however, if not implemented the right
    way, they can make things way worse.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端是一把双刃剑。如果做得正确，它们可以为团队带来巨大的快乐和生产力；然而，如果实施不当，它们可能会使事情变得更糟。
- en: Having said that, there are a couple of key principles and considerations we
    need to keep in mind when building a microfrontend architecture.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在构建微前端架构时，我们需要牢记一些关键原则和考虑因素。
- en: In this chapter, we will look at the key design principles of a microfrontend
    architecture and why it is important to treat them as sacrosanct. The reason we
    emphasize these principles is that they lay the foundation of the microfrontend
    architecture. Teams may not be able to extract all the benefits of a microfrontend
    pattern if they choose to ignore these principles. Then, we will look at the key
    components that are critical to any microfrontend architecture.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨微前端架构的关键设计原则以及为什么将它们视为神圣不可侵犯的重要性。我们强调这些原则的原因是，它们为微前端架构奠定了基础。如果团队选择忽视这些原则，他们可能无法从微前端模式中提取所有好处。然后，我们将探讨对任何微前端架构至关重要的关键组件。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the Key Principles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解关键原则
- en: The key Components of a Microfrontend Architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微前端架构的关键组件
- en: By the end of this chapter, you will have a better understanding of the guiding
    principles and key considerations that teams need to keep in mind when designing
    a microfrontend architecture.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将更好地理解团队在设计微前端架构时需要牢记的指导原则和关键考虑因素。
- en: Understanding the Key Principles
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解关键原则
- en: It’s important that all software teams lay down a set of rules and guiding principles
    that all team members and the code they write adhere to. This ensures that when
    teams discuss certain technical approaches, they can validate them against these
    guidelines. This, in turn, ensures that the teams can focus on the outcomes by
    mapping them against these key guidelines and not get too obsessed with the nuances
    of the process. This helps teams to arrive at decisions a lot faster.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有软件团队来说，制定一套规则和指导原则，让所有团队成员和他们编写的代码都遵守，这一点非常重要。这确保了当团队讨论某些技术方法时，他们可以将其与这些指南进行验证。这反过来又确保了团队可以通过将这些关键指南与结果进行映射来专注于结果，而不是过于沉迷于过程的细微差别。这有助于团队更快地做出决策。
- en: In the following sections, we will look at the key principles that teams must
    adhere to when following a microfrontend pattern.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨团队在遵循微前端模式时必须遵守的关键原则。
- en: Domain Driven Teams
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域驱动团队
- en: '*Dan Abramov*, who leads the React project at Meta, once tweeted the question,
    “*Is Microfrontends solving a technology problem or an* *organizational problem?*”'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Meta的React项目负责人Dan Abramov曾发推文提问：“*微前端是在解决技术问题还是组织问题？*”
- en: When you think about it, a lot of problems we see in today’s software development
    do stem from the way teams are organized.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这么想的时候，我们今天在软件开发中看到的大部分问题确实源于团队的组织方式。
- en: Domain Driven Design is a well-established concept in the microservices world.
    Backend microservice teams are commonly organized around these domain models.
    With microfrontends, we extend the same thinking to the frontend world, and by
    re-organizing the frontend teams within these domain models, we are now able to
    create vertically sliced teams, where a domain-driven team can own the responsibility
    of a business functionality from end to end and is able to work independently.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计（Domain Driven Design）是微服务世界中一个成熟的概念。后端微服务团队通常围绕这些领域模型组织。随着微前端的出现，我们将同样的思维方式扩展到前端世界，通过在这些领域模型内重新组织前端团队，我们现在能够创建垂直切分的团队，其中领域驱动团队能够从端到端拥有业务功能的责任，并且能够独立工作。
- en: For us to be successful with microfrontends, it is critical that the micro apps
    and teams that own them are mapped to these domain models and the business value
    they aim to provide.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在微前端方面取得成功，至关重要的是，微应用及其所属团队必须与这些领域模型以及他们旨在提供的业务价值相映射。
- en: 'Let’s have a quick look at what a Domain Driven Team might look like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解一下领域驱动团队可能的样子：
- en: '![Figure 2.1 – Domain-driven teams](img/Figure_2.01_B18987.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 领域驱动团队](img/Figure_2.01_B18987.jpg)'
- en: Figure 2.1 – Domain-driven teams
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 领域驱动团队
- en: The preceding diagram shows three domain-driven teams for an e-commerce application,
    namely **Catalog Team**, **Checkout Team**, and **User Account Team**. Within
    each team, you will see that they have dedicated team members who play the roles
    of frontend, backend, and integration engineers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示显示了电子商务应用程序的三个领域驱动团队，即**目录团队**、**结账团队**和**用户账户团队**。在每一个团队中，你会看到他们有专门负责前端、后端和集成工程师的团队成员。
- en: Isolating Failure
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离故障
- en: Microfrontends are inherently designed to be “decentralized.” One of the many
    benefits of that is isolating failures and reducing the blast radius of an error.
    A common problem with monolith **Single Page Apps** (**SPAs**) is that a single
    line of error in any one of the modules would prevent an entire application from
    being compiled, or a runtime error would cause an entire page to error out.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端天生就是“去中心化”设计的。其众多好处之一就是隔离故障，并减少错误的影响范围。单体**单页应用**（**SPAs**）的一个常见问题是，任何一个模块中的一行错误都会阻止整个应用程序编译，或者运行时错误会导致整个页面出错。
- en: When designing a microfrontend architecture, you need to ensure graceful service
    degradation if one or more of the microfrontends fail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计微前端架构时，你需要确保如果有一个或多个微前端失败，系统可以优雅地降级服务。
- en: If one microfrontend is dependent on another for its functioning, then we are
    breaking one of the key principles of microfrontends, which should be avoided
    at all costs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个微前端依赖于另一个微前端来运行，那么我们就违反了微前端的一个关键原则，这个原则应该不惜一切代价避免。
- en: Deploying Independently
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立部署
- en: Another key principle of a microfrontend architecture is the ability to deploy
    each app independently without having to redeploy the other apps.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端架构的另一个关键原则是能够独立部署每个应用程序，而无需重新部署其他应用程序。
- en: When a new app is deployed, it should immediately be available to a user and
    should not require a restart of the host app or the servers for the changes to
    take effect.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署新应用程序时，它应立即对用户可用，并且不需要重启主机应用程序或服务器以使更改生效。
- en: An interesting observation with different teams working on microfrontends is
    that while, from an architecture standpoint, these micro apps can be updated independently,
    the DevOps pipelines that deploy these microfrontends are designed to deploy all
    the apps simultaneously, thereby negating the benefits of independent deployment.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当不同团队在微前端上工作时，一个有趣的观察是，从架构角度来看，这些微应用可以独立更新，但部署这些微前端的DevOps管道被设计为同时部署所有应用程序，从而抵消了独立部署的好处。
- en: It is critical that the DevOps pipelines are also designed such that when any
    app is ready for deployment, only the relevant pipeline runs and deploys the app,
    without impacting the other apps.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 确保DevOps管道也设计得如此，即当任何应用程序准备好部署时，只有相关的管道运行并部署该应用程序，而不会影响其他应用程序。
- en: This misconfiguration of the DevOps pipelines mainly stems from the problem
    where there are separate DevOps teams that are responsible for building the pipelines
    and production deployments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种DevOps管道配置错误主要源于存在负责构建管道和生产部署的独立DevOps团队的问题。
- en: The best way to fix this is to ensure that we have “full life cycle teams,”
    who are responsible for building the app and also responsible for deploying it
    to production. These teams work closely with the DevOps teams to build the CI
    and CD pipelines and then take over the control of managing and running them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最好方法是确保我们有“全生命周期团队”，这些团队负责构建应用程序，同时也负责将其部署到生产环境中。这些团队与DevOps团队紧密合作，构建CI和CD管道，然后接管管理和运行这些管道的控制权。
- en: Preferring Runtime Integrations
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先考虑运行时集成
- en: A common discussion in the context of microfrontends is build time integrations
    versus runtime integrations. With build time integrations, the different teams
    build and publish their micro apps either to a version control system or an artifact
    repository, such as NPM or Nexus.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在微前端背景下，一个常见的讨论是构建时集成与运行时集成。在构建时集成中，不同的团队将他们的微应用构建并发布到版本控制系统或工件存储库，例如NPM或Nexus。
- en: Then, during building time, all these micro apps are brought together to build
    a single app bundle, which is then deployed to production. We strongly discourage
    this pattern of build-time integration, as it breaks the aforementioned principle
    of independent deployment. A pattern like this may be suitable where you have
    scheduled releases that happen either once or twice a month. However, in that
    case, you probably would be better off with a monolith single-page app and don’t
    really have to deal with all the complexities of a microfrontend architecture.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在构建时间，所有这些微应用被汇集在一起构建一个单一的应用程序包，然后部署到生产环境中。我们强烈反对这种构建时集成的模式，因为它破坏了上述独立部署的原则。这种模式可能适用于你有一个计划发布的版本，每个月发生一次或两次。然而，在这种情况下，你可能更适合使用单体单页应用程序，并且真的不需要处理微前端架构的所有复杂性。
- en: Always prefer runtime integrations when designing a microfrontend architecture.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 设计微前端架构时，始终优先考虑运行时集成。
- en: Your micro apps should immediately be available for use the moment they are
    deployed. This ensures that each team can continuously deploy their micro apps
    to production and are not dependent on other teams to make their app available.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您的微应用应该在部署后立即可用，这确保了每个团队可以持续地将他们的微应用部署到生产环境中，而不依赖于其他团队来使他们的应用可用。
- en: In most microfrontend patterns, we can make use of a host application or a shell
    app that keeps a tab of the different micro apps that load within it, but care
    must be taken to ensure that this host/app shell is built with scalability in
    mind. If the process of checking for new versions of a micro app takes up a lot
    of CPU or memory resources, then there is a high risk that it will become a single
    point of failure when your application scales, in terms of the micro apps and
    the traffic it receives.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数微前端模式中，我们可以利用一个宿主应用程序或外壳应用程序，它跟踪在其中加载的不同微应用，但必须注意确保这个宿主/应用程序外壳是以可扩展性为前提构建的。如果检查微应用新版本的过程消耗了大量的CPU或内存资源，那么当你的应用程序扩展时，它将有很大的风险成为单点故障，无论是从微应用还是从它接收到的流量来看。
- en: Avoiding the “Distributed Monolith” trap
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免陷入“分布式单体”的陷阱
- en: '**Don’t Repeat Yourself** (**DRY**) has a slightly different meaning in the
    microservice/microfrontend world. Most developers associate DRY with code reusability.
    When working with microfrontends, teams can go overboard creating libraries and
    utilities, which eventually get imported and used in each of the micro apps. Now,
    as each team’s needs grow, they start adding functionality to these common libraries
    and utilities, in the hope that it will be beneficial to other teams. However,
    the problem it creates is that additional unused code is now being imported into
    the other micro apps (while tree shaking will solve this problem, in most cases,
    mainly due to poor coding practices, tree shaking doesn’t work well, and we end
    up with unnecessary code imported into the apps). Another problem with these shared
    libraries is that there is a much higher risk of introducing breaking changes,
    with changes made for one micro app now breaking the other micro apps. By going
    overboard with code reusability, we end up with what’s commonly called a “distributed
    monolith,” which is essentially the worst of both worlds.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要重复自己**（DRY）在微服务/微前端的世界中有稍有不同的含义。大多数开发者将DRY与代码重用性联系起来。当与微前端一起工作时，团队可能会过度创建库和实用工具，这些库和实用工具最终被导入并用于每个微应用中。现在，随着每个团队需求的增长，他们开始向这些通用库和实用工具添加功能，希望这对其他团队有益。然而，它造成的问题是现在额外的未使用代码被导入到其他微应用中（虽然摇树优化可以解决这个问题，但在大多数情况下，主要是由于糟糕的编码实践，摇树优化工作得不好，我们最终会在应用程序中导入不必要的代码）。这些共享库的另一个问题是，引入破坏性变化的风险要高得多，一个微应用所做的更改现在会破坏其他微应用。通过过度追求代码重用性，我们最终得到一个通常被称为“分布式单体”的东西，这实际上是两者的最坏之处。'
- en: It’s okay to have some shared libraries or, if using TypeScript, a shared types/interfaces
    file, but we must avoid creating large common libraries.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些共享库或，如果使用TypeScript，一个共享的类型/接口文件是可以的，但我们必须避免创建大型通用库。
- en: In the microservice/microfrontend world, DRY essentially refers to automating
    tasks so that you don’t have to manually repeat the steps for each microservice
    or micro app. These could be things such as automating quality gates, or performance
    and security checks as part of the developers’ pipelines.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务/微前端的世界里，DRY（Don’t Repeat Yourself）本质上是指自动化任务，这样你就不必为每个微服务或微应用手动重复步骤。这些可能包括自动化质量门、性能和安全检查作为开发者管道的一部分。
- en: Technology agnostic
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术中立
- en: Another principle of a microfrontend architecture is that it should be technology
    agnostic, meaning that each of the micro apps could “in theory” be built using
    different frameworks/languages. However, just because it’s possible doesn’t mean
    teams should go all out and use either Vue, Angular, or React to build out different
    micro apps.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端架构的另一个原则是它应该是技术中立的，这意味着每个微应用“理论上”可以使用不同的框架/语言构建。然而，尽管这是可能的，但这并不意味着团队应该全力以赴，使用Vue、Angular或React来构建不同的微应用。
- en: 'There are multiple reasons why this should be avoided:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个原因应该避免这样做：
- en: Multiple libraries/frameworks mean an additional payload being sent down the
    wire to users’ devices
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个库/框架意味着向用户设备发送额外的数据负载
- en: It makes it difficult to rotate team members, and moving from one team to another
    means having to get comfortable with a new framework/library
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得轮换团队成员变得困难，从一个团队转移到另一个团队意味着需要适应新的框架/库
- en: The primary reason for this principle is to allow for incremental upgrades,
    either from an older version to a newer version of the same library or to explore
    the benefits of a new framework.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这一原则的主要目的是允许增量升级，无论是从旧版本到同一库的新版本，还是探索新框架的好处。
- en: Granular Scaling
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 细粒度扩展
- en: When planning out a deployment strategy for your microfrontend, you must ensure
    that it supports granular scaling. By granular scaling, what we mean is that if
    a certain set of pages is getting a lot of traffic, either due to a marketing
    campaign or something similar, then only the servers serving those pages should
    scale, while the rest of the pods serving other parts of your microfrontend can
    remain at their regular levels. This ensures optimal cloud and hosting costs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划微前端的部署策略时，您必须确保它支持细粒度扩展。通过细粒度扩展，我们的意思是，如果某些页面因营销活动或其他类似原因而获得大量流量，那么仅应扩展服务这些页面的服务器，而其他为微前端其他部分服务的Pod可以保持其常规水平。这确保了最佳的云和托管成本。
- en: Culture of Automation and DevOps
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化和DevOps文化
- en: A strong culture of automation and DevOps is critical for the long-term success
    of a microfrontend architecture.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的自动化和DevOps文化对于微前端架构的长期成功至关重要。
- en: As you can imagine with microfrontends, since we break up a single app into
    smaller apps, all the activities associated with tasks such as compiling the app
    and running quality, performance, and security checks will now need to be done
    multiple times for each of the apps. If we don’t have automation processes for
    all of the aforementioned items, then the overall development and release of these
    apps will take a lot longer than what it would have been with a monolith.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，在微前端中，由于我们将单个应用拆分成更小的应用，与编译应用和运行质量、性能和安全检查等任务相关的所有活动现在都需要为每个应用多次执行。如果我们没有上述所有项目的自动化流程，那么这些应用的总体开发和发布将比单体应用所需的时间长得多。
- en: Hence, it is important to invest time and effort into building these automation
    processes, most of which are generally done as part of the DevOps pipelines.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，投入时间和精力构建这些自动化流程非常重要，这些流程通常作为DevOps管道的一部分完成。
- en: Teams can also invest in tooling and building code generators and micro app
    templates that can help speed up the creation of newer micro apps. They can also
    run linters, security, and other quality checks automatically as part of the DevOps
    pipelines.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 团队还可以投资于工具和构建代码生成器和微应用模板，这有助于加快新微应用的创建速度。他们还可以在DevOps管道中自动运行linters、安全和其他质量检查。
- en: With this, we come to the end of this section, where we saw some of the important
    principles that teams must keep in mind when designing a microfrontend architecture.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们来到了本节的结尾，其中我们看到了团队在设计微前端架构时必须牢记的一些重要原则。
- en: We saw how principles such as domain-driven teams, independent deployments,
    and granular scaling allow teams to move consistently and quickly. We saw how
    teams should avoid falling into the trap of a distributed monolith and build a
    pattern that uses build-time integrations, and finally, we saw how keeping the
    architecture technology agnostic and focusing on automation helps an architecture
    to easily evolve and become future-proof.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了诸如领域驱动团队、独立部署和细粒度扩展等原则如何使团队能够持续快速地移动。我们看到了团队应避免陷入分布式单体陷阱，并构建一个使用构建时集成的模式，最后，我们看到了保持架构技术中立并专注于自动化如何帮助架构轻松演进并成为未来证明。
- en: In the next section, we will look at some of the important components of the
    microfrontend architecture.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨微前端架构的一些重要组件。
- en: The key Components of a Microfrontend Architecture
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微前端架构的关键组件
- en: After spending time going through the principles of a microfrontend, now let’s
    look at some of the key components of a microfrontend architecture.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在花时间研究微前端的原则之后，现在让我们来看看微前端架构的一些关键组件。
- en: In this section, we will look at the essential components any microfrontend
    architecture needs to have, and we will look at some of the nuances associated
    with them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨任何微前端架构都需要具备的基本组件，并探讨与它们相关的细微差别。
- en: After completing this section, you will be aware of the four basic components
    that make up any microfrontend architecture.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本节后，你将了解构成任何微前端架构的四个基本组件。
- en: Routing Engine
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由引擎
- en: As we saw in the previous chapter, depending on the type of microfrontend pattern
    you aim to build, the routing engine for your app will be partially or fully decoupled
    from your apps.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，根据你打算构建的微前端模式类型，你的应用的路由引擎将与你的应用部分或完全解耦。
- en: There are multiple approaches we can take. We can use NGINX as a reverse proxy
    and have a list of all the primary routes that map to the respective apps in the
    multi-SPA pattern. If the apps are deployed in a Kubernetes cluster, we can make
    use of Ingress routes to map the primary routes to the respective apps. We will
    go into more detail about this in [*Chapter 8*](B18987_08.xhtml#_idTextAnchor119),
    *Deploying Microfrontends to Kubernetes*, where we will look at deploying these
    microfrontends in the cloud.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取多种方法。我们可以使用NGINX作为反向代理，并有一个所有主要路由映射到多SPA模式中相应应用的列表。如果应用部署在Kubernetes集群中，我们可以使用入口路由将主要路由映射到相应应用。我们将在[*第8章*](B18987_08.xhtml#_idTextAnchor119)“将微前端部署到Kubernetes”中更详细地介绍这一点，我们将探讨在云中部署这些微前端。
- en: A global state and a Communication Channel
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局状态和通信通道
- en: In addition to routing, the next important thing to design well in your microfrontend
    architecture is the communication channel between the different apps and also
    the notion of a global state, which can be shared between the different apps.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了路由之外，在设计微前端架构时，还需要很好地设计不同应用之间的通信通道以及全局状态的概念，这些状态可以在不同应用之间共享。
- en: With a monolith SPA, the most common practice is to use a single global store
    such as Redux or MobX, where everything is written into that store and read from
    it. With microfrontends, the recommendation is to avoid such global client-side
    stores and instead let each micro app get its data from the backend API, as that
    is the real source of truth.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单体SPA，最常用的做法是使用单个全局存储库，如Redux或MobX，其中所有内容都写入该存储库并从中读取。对于微前端，建议避免使用此类全局客户端存储库，而是让每个微应用从后端API获取其数据，因为这才是真正的真相来源。
- en: However, there would be a genuine need for client-side state management to avoid
    making unnecessary calls to the backend, to fetch things such as `user_id` or
    a cart count. For things such as these, we can look to use a really thin global
    store in the app shell or maybe even look toward `localStorage` or `IndexedDB`
    to store the values that are needed to make API calls.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了避免对后端进行不必要的调用，例如获取`user_id`或购物车数量，确实需要客户端状态管理。对于这些事情，我们可以在应用外壳中使用一个非常薄的全球存储库，或者甚至可以考虑使用`localStorage`或`IndexedDB`来存储需要用于API调用的值。
- en: With a micro app microfrontend pattern, it also becomes important to establish
    a common communication channel that the different apps use to communicate with
    each other. A classic use case would be when clicking on the **Add to Cart** button
    on a product page, the mini cart present in the header is automatically incremented.
    In such cases, an event-driven communication channel works best.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微前端模式，建立不同应用之间使用的通用通信通道也变得非常重要。一个典型的用例是在产品页面上点击**添加到购物车**按钮时，页眉中显示的迷你购物车会自动增加。在这种情况下，事件驱动的通信通道效果最佳。
- en: Source code Version Control
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码版本控制
- en: Another important item that teams need to agree on is how they plan to organize
    their Git repositories. Two schools of thought prevail here – organizing your
    apps in a polyrepo or a monorepo. Let’s look at their nuances.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 团队需要达成共识的另一个重要事项是他们计划如何组织他们的Git仓库。这里有两种主要的观点——在多仓库或单仓库中组织应用。让我们看看它们的细微差别。
- en: Polyrepos
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多仓库
- en: Polyrepos are where you have each of your multi-SPAs or micro apps managed in
    its own independent Git repository. These are easiest to start with and give complete
    team independence. From a DevOps standpoint too, they are a lot easier to manage.
    However, this approach has a few drawbacks. There is a higher risk of teams becoming
    siloed and reduced inter-team collaboration. Another drawback is duplication and
    higher maintenance costs for tooling, such as DevOps pipelines and automation
    scripts, which need to be duplicated and updated in each of the repos.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 多代码库（Polyrepos）是指每个多SPA或微应用都管理在自己的独立Git仓库中。这些仓库最容易开始使用，并且提供了完整的团队独立性。从DevOps的角度来看，它们也更容易管理。然而，这种方法有几个缺点。团队之间可能会出现孤岛化，协作减少。另一个缺点是工具（如DevOps管道和自动化脚本）的重复和更高的维护成本，这些工具需要在每个仓库中重复和更新。
- en: Monorepos
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单一代码库
- en: In a monorepo structure, all your multi-SPAs or micro apps are co-located in
    a single Git repo, with each app located within its own individual folder.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在单一代码库结构中，所有多SPA或微应用都位于单个Git仓库中，每个应用位于其自己的单独文件夹中。
- en: Monorepos are starting to become a de facto approach for many frontend teams
    to manage their code repositories. The main advantage of monorepos is increased
    team collaboration, as everybody is able to see every other team’s code and provide
    valuable feedback. Tooling and automation scripts can be centralized, whereby
    optimizations done by one team are immediately available for other teams to follow.
    Some of the drawbacks of monorepos include DevOps setups being a bit complicated.
    Teams also need to set up fine-grained folder-level permissions to prevent teams
    from overwriting each other’s code. In the grand scheme of things, monorepos provide
    more advantages and, hence, are a preferred approach to managing the source code
    for your microfrontends.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 单一代码库（Monorepos）正开始成为许多前端团队管理代码库的事实上的方法。单一代码库的主要优势是增强了团队协作，因为每个人都能看到其他团队的代码并提供有价值的反馈。工具和自动化脚本可以集中管理，这样一支团队所做的优化可以立即供其他团队跟进。单一代码库的一些缺点包括DevOps设置稍微复杂一些。团队还需要设置细粒度的文件夹级权限，以防止团队之间相互覆盖代码。从大局来看，单一代码库提供了更多优势，因此是管理微前端源代码的首选方法。
- en: A Component Library
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件库
- en: When building microfrontends, it is critical to ensure a consistent look and
    feel as a user navigates through the different apps. The way we achieve that is
    by ensuring all apps make use of a common design system and component library.
    It is also recommended that all teams use a common theming and styling engine
    to ensure that all the components look and behave the same, irrespective of which
    app they are served in.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建微前端时，确保用户在浏览不同应用时保持一致的视觉和触感体验至关重要。我们实现这一目标的方式是确保所有应用都使用一个通用的设计系统和组件库。还建议所有团队使用一个通用的主题和样式引擎，以确保所有组件无论在哪个应用中呈现，外观和行为都保持一致。
- en: A common pattern is to publish a component library as an NPM module and set
    up all the other apps to import and use it. Each time a new version of the component
    library is published, teams will need to update their respective apps to the latest
    version.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的模式是将组件库作为NPM模块发布，并将所有其他应用设置为导入和使用它。每次发布组件库的新版本时，团队都需要将各自的应用更新到最新版本。
- en: An emerging trend, thanks to monorepos, is to build directly from source. What
    this means is that a component library is stored within the `libs` section of
    the monorepo and the components are directly linked from the library path. The
    main advantage of this method is that every time teams build their app, they automatically
    receive the latest version of the component library.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单一代码库的出现，一个新兴的趋势是直接从源代码构建。这意味着组件库存储在单一代码库的`libs`部分，组件直接从库路径链接。这种方法的主要优势是每次团队构建应用时，都会自动接收到组件库的最新版本。
- en: In this section, we learned about the key components of a microfrontend architecture,
    namely a routing engine, a global state, and a communication channel. We also
    saw the distinctions between a polyrepo and monorepo and saw why frontend teams
    prefer to use monorepos. Finally, we also learned about the component library
    and different ways teams consume components from a common library.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了微前端架构的关键组件，即路由引擎、全局状态和通信通道。我们还看到了多代码库（polyrepo）和单一代码库（monorepo）之间的区别，并了解了为什么前端团队更喜欢使用单一代码库。最后，我们还学习了组件库以及团队从通用库中消费组件的不同方式。
- en: Summary
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With that, we come to the end of our second chapter. We started the chapter
    by looking at the key principles we need to keep in mind. We saw why it is important
    to break teams down based on domain models, and why it is critical for teams to
    be able to independently deploy their own apps. We learned about the misconceptions
    associated with code reuse and how it can lead to a distributed monolith trap.
    We also saw the importance of DevOps and an automation culture. Finally, we learned
    about the four key components of a microfrontend. Everything that we learned in
    this chapter we will put into practice in the coming chapters, as we go about
    building our very own microfrontend application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就结束了第二章的内容。我们以审视我们需要牢记的关键原则开始这一章。我们看到了为什么基于领域模型拆分团队是重要的，以及为什么团队能够独立部署自己的应用是至关重要的。我们还了解了与代码复用相关的误解以及它如何导致分布式单体陷阱。我们还看到了DevOps和自动化文化的重要性。最后，我们学习了微前端的核心四个组件。在本章中学到的所有内容，我们将在接下来的章节中付诸实践，因为我们着手构建我们自己的微前端应用程序。
- en: In the next chapter, we will dive deeper into monorepos versus polyrepos and
    learn how it’s more about team culture than technology. We will also start off
    by setting up our code repository as a monorepo to set up the foundation for future
    work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨单仓库与多仓库之间的区别，并了解这更多是关于团队文化而非技术。我们还将从设置我们的代码仓库作为单仓库开始，为未来的工作打下基础。
