<html><head></head><body>
<div id="_idContainer065">
<h1 class="chapter-number" id="_idParaDest-146"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-147"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.2.1">Multithreading with Web Workers</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will cover important topics that will highly improve the performance of a web application, especially single-page applications. </span><span class="koboSpan" id="kobo.3.2">First, we will learn how websites and JavaScript work, and how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.4.1">web workers</span></strong><span class="koboSpan" id="kobo.5.1"> to leverage our application processing power, data access, and network communications. </span><span class="koboSpan" id="kobo.5.2">Then, we will introduce two new conceptual design patterns and will implement them in an example application together with other patterns that we have previously seen. </span><span class="koboSpan" id="kobo.5.3">On top of this, we will also introduce two libraries that will facilitate our network communications as well as the handling of our persistent database(s) in IndexedDB. </span><span class="koboSpan" id="kobo.5.4">We will also implement a simple Node.js server to provide us with feedback and test our work in a highly decoupled architecture, where our frontend and backend services communicate using standard APIs over the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">HTTP protocol.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.9.1">WebWorkers</span></span></li>
<li><span class="koboSpan" id="kobo.10.1">Business and </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">dispatcher patterns</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Network communication inside </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">WebWorker</span></strong></span></li>
<li><span class="koboSpan" id="kobo.15.1">A browser’s persistent embedded database – </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">IndexedDB</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">How to build a simple Node.js API server </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">for testing</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.19.1">The concepts in this chapter can be considered “advanced,” but we will condense them down into understandable pieces that we will implement right away. </span><span class="koboSpan" id="kobo.19.2">By the end of this chapter, you will have a solid knowledge of how to implement multithreading in your web applications and also a reference framework to scale and facilitate the use of complex </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">browser APIs.</span></span></p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">This chapter does not add additional requirements to our application. </span><span class="koboSpan" id="kobo.22.2">However, we will only see relevant parts of the code, so to see the entire application working, you should refer to the code examples for </span><a href="B18602_08.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.23.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.24.1">, </span><em class="italic"><span class="koboSpan" id="kobo.25.1">Multithreading with Web Workers</span></em><span class="koboSpan" id="kobo.26.1">, in the book’s GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">at </span></span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter08"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter08</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">Check out the following video to see the Code in </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">Action: </span></span><a href="https://packt.link/D4EHt"><span class="No-Break"><span class="koboSpan" id="kobo.32.1">https://packt.link/D4EHt</span></span></a></p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.33.1">An introduction to web workers</span></h1>
<p><span class="koboSpan" id="kobo.34.1">JavaScript is a single-threaded language, meaning that it doesn’t natively have a way to spawn processes in separate </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.35.1">threads. </span><span class="koboSpan" id="kobo.35.2">This makes web browsers run the JavaScript in a web page on the same thread as other processes, which directly affects the performance of the </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.36.1">page, most notably, the rendering process,that is in charge of presenting the page on the screen. </span><span class="koboSpan" id="kobo.36.2">Bowsers make a considerable effort to optimize the performance of all these moving parts to make a page responsive, performant, fast, and efficient. </span><span class="koboSpan" id="kobo.36.3">However, there are tasks that a web application must do in JavaScript that are heavy and potentially “render-blocking”. </span><span class="koboSpan" id="kobo.36.4">This means that the browser will have to pay attention to the results of the code and use all the resources to complete the running function before it can focus on the rendering (presenting the page to the screen). </span><span class="koboSpan" id="kobo.36.5">If you ever find a process on a web page that makes the site seem “unresponsive” or “stuttering” after you start an action (your mouse may even freeze in some cases), this could be one of </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">the causes.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">If we open the developer tools in a modern browser, we can access some performance tools to analyze how a web page behaves and how much time each process step takes. </span><span class="koboSpan" id="kobo.38.2">For example, here is a quick view of the first load of YouTube on a shared link, in Firefox </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">for Linux:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.40.1"><img alt="Figure 8.1 – The performance of YouTube’s first load, seen using developer tools" src="image/Figure_8.01_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.41.1">Figure 8.1 – The performance of YouTube’s first load, seen using developer tools</span></p>
<p><span class="koboSpan" id="kobo.42.1">The preceding screenshot has zoomed into the actual processing of the page, showing what happens before the first rendering, meaning before the user can actually see something on the screen. </span><span class="koboSpan" id="kobo.42.2">That is represented in the first line, </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">Screenshots</span></strong><span class="koboSpan" id="kobo.44.1">, where for this case, the first visible </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.45.1">elements appear towards the end of the timeline (</span><em class="italic"><span class="koboSpan" id="kobo.46.1">#1</span></em><span class="koboSpan" id="kobo.47.1">). </span><span class="koboSpan" id="kobo.47.2">The second line shows what the main </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">Parent Process</span></strong><span lang="en-US" xml:lang="en-US"> </span><span class="koboSpan" id="kobo.49.1">has been busy doing, and if you pay attention, the very first section (</span><em class="italic"><span class="koboSpan" id="kobo.50.1">#2</span></em><span class="koboSpan" id="kobo.51.1">) is all about processing JavaScript. </span><span class="koboSpan" id="kobo.51.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">Renderer</span></strong><strong class="bold"> </strong><span class="koboSpan" id="kobo.53.1">process, highlighted and displayed with a black bar (#3), can’t even start until the JavaScript has been run. </span><span class="koboSpan" id="kobo.53.2">When it does run, it draws the page on the screen, and you have the visible content from </span><em class="italic"><span class="koboSpan" id="kobo.54.1">#1</span></em><span class="koboSpan" id="kobo.55.1">. </span><span class="koboSpan" id="kobo.55.2">This gives an approximate idea of the work the browser does each cycle in between screen paints (called “frames”). </span><span class="koboSpan" id="kobo.55.3">The browser attempts to </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.56.1">produce as many </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">frames per second</span></strong><span class="koboSpan" id="kobo.58.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.59.1">fps</span></strong><span class="koboSpan" id="kobo.60.1">) as possible. </span><span class="koboSpan" id="kobo.60.2">To keep a fluent 60 fps, it needs to do all this processing in about 16.67 milliseconds or less. </span><span class="koboSpan" id="kobo.60.3">At best, your JavaScript process should be resolved in half that time to keep a fluid experience for the user. </span><span class="koboSpan" id="kobo.60.4">With this in mind, what happens when your JavaScript takes longer than that? </span><span class="koboSpan" id="kobo.60.5">Simple enough, the render process is postponed, the fps drop, and the </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.61.1">user experiences stuttering and a frozen </span><strong class="bold"><span class="koboSpan" id="kobo.62.1">user interface</span></strong><span class="koboSpan" id="kobo.63.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.64.1">UI</span></strong><span class="koboSpan" id="kobo.65.1">) may happen. </span><span class="koboSpan" id="kobo.65.2">Depending on your web application, this could be an </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">important issue.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">You may say, “Wait a minute, why we don’t make heavy tasks asynchronous? </span><span class="koboSpan" id="kobo.67.2">Wouldn’t that resolve the issue?” </span><span class="koboSpan" id="kobo.67.3">The answer is: maybe and no. </span><span class="koboSpan" id="kobo.67.4">When you declare an asynchronous function, it only means that the execution will be deferred to a place in time when the processing of the sequential code has been executed. </span><span class="koboSpan" id="kobo.67.5">Most likely, this pushes the asynchronous code toward the end or after the sequential code has been executed, but then it will be run sequentially as usual. </span><span class="koboSpan" id="kobo.67.6">If the rendering process happens before that, you may perceive a performance gain, but if not, you face the same issue if the async function takes longer (as it will affect the next rendering). </span><span class="koboSpan" id="kobo.67.7">If we moved all functions to be asynchronous, we would end up potentially with the same result as if everything were sequential, plus the overhead of making the </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">asynchronous calls:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.69.1"><img alt="Figure 8.2 – A representation of the execution of async code, moved after the sequential code has been executed (1)" src="image/Figure_8.02_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.70.1">Figure 8.2 – A representation of the execution of async code, moved after the sequential code has been executed (1)</span></p>
<p><span class="koboSpan" id="kobo.71.1">Then, if asynchronous operations would not completely solve the performance issue, how do we resolve it? </span><span class="koboSpan" id="kobo.71.2">Beyond all the optimizations you could make, there is one technology you should also consider at the top of the list of alternatives: the web </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">workers API.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">Web workers are JavaScript scripts that execute in their own process (or thread, depending on the implementation); thus, they </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.74.1">do not compromise the parent process where the rendering happens. </span><span class="koboSpan" id="kobo.74.2">The browser API provides a rather simple yet effective way to communicate to and from the parent process: a messaging system. </span><span class="koboSpan" id="kobo.74.3">These messages can only pass serializable data. </span><span class="koboSpan" id="kobo.74.4">The parent process and each web worker operate in their own environment and memory boundaries, so they cannot share references or functions, hence why all the data passed between them has to be serializable as it is copied into each process. </span><span class="koboSpan" id="kobo.74.5">While this may seem like a disadvantage, it is actually an asset when used properly, as we will see soon here. </span><span class="koboSpan" id="kobo.74.6">Another caveat of this architecture is that web workers do not have access to the </span><strong class="bold"><span class="koboSpan" id="kobo.75.1">Document Object Model</span></strong><span class="koboSpan" id="kobo.76.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.77.1">DOM</span></strong><span class="koboSpan" id="kobo.78.1">) or the Window </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.79.1">objects and, consequently, to any of their services. </span><span class="koboSpan" id="kobo.79.2">They do, however, have access to the network and IndexedDB. </span><span class="koboSpan" id="kobo.79.3">This opens up a wealth of opportunities for the architectural design of your frontend application, as you can easily separate what a presentation layer and a business </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">layer is.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.81.1"><img alt="Figure 8.3 – A layer﻿ed representation of a Vue application with background processes using web workers" src="image/Figure_8.03_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.82.1">Figure 8.3 – A layered representation of a Vue application with background processes using web workers</span></p>
<p><span class="koboSpan" id="kobo.83.1">As you can see in the previous diagram, we can instantiate multiple web workers to represent different types </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.84.1">of layers in our application (</span><strong class="bold"><span class="koboSpan" id="kobo.85.1">Business</span></strong><span class="koboSpan" id="kobo.86.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.87.1">Data</span></strong><span class="koboSpan" id="kobo.88.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.89.1">Communication</span></strong><span class="koboSpan" id="kobo.90.1">, and so on). </span><span class="koboSpan" id="kobo.90.2">While a web worker can be started and terminated </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.91.1">from the parent process at will, both of these </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.92.1">actions are computationally expensive, so the recommendation is that web workers, once created, remain active during the duration of the application and accessed when needed. </span><span class="koboSpan" id="kobo.92.2">It is also recommended not to abuse this resource by creating “too many” web workers, as each one is a different process with its own resources reserved. </span><span class="koboSpan" id="kobo.92.3">There is </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.93.1">no clear definition of what constitutes “too many”, so discretion is advised. </span><span class="koboSpan" id="kobo.93.2">In my experience, while the number of web workers remains in the lower single digits, even low-powered devices should handle your application with excellent performance. </span><span class="koboSpan" id="kobo.93.3">As with many other things, there can be too much of a good thing, and this also applies with </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">web workers.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">Now that we know what web workers are and what they can do for us, let’s see how to implement them in pure JavaScript and then how to do so </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">with Vite.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.97.1">Implementing a Web Worker</span></h2>
<p><span class="koboSpan" id="kobo.98.1">Creating a web worker in </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.99.1">plain JavaScript is quite simple and straightforward. </span><span class="koboSpan" id="kobo.99.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">window</span></strong><strong class="bold"> </strong><span class="koboSpan" id="kobo.101.1">object provides a constructor, properly named </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">Worker</span></strong><span class="koboSpan" id="kobo.103.1">, which receives as a parameter the path to a script file. </span><span class="koboSpan" id="kobo.103.2">For example, considering that our web worker is contained in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">my_worker.js</span></strong><span class="koboSpan" id="kobo.105.1"> file, this is how we can </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">create it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.107.1">
if(window.Worker){
    </span><strong class="bold"><span class="koboSpan" id="kobo.108.1">let my_worker=new Worker("my_worker.js")</span></strong><span class="koboSpan" id="kobo.109.1">
    ...
</span><span class="koboSpan" id="kobo.109.2">}</span></pre>
<p><span class="koboSpan" id="kobo.110.1">Simple enough, if the constructor exists in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">window</span></strong><span class="koboSpan" id="kobo.112.1"> object, then we just create a new worker accessing the constructor directly. </span><span class="koboSpan" id="kobo.112.2">The newly created worker again exposes a </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">simple API:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">.postMessage(message)</span></strong><span class="koboSpan" id="kobo.115.1">: This will send the message to the web worker. </span><span class="koboSpan" id="kobo.115.2">It can be any data type that can be serialized (basic data types, arrays, objects, and </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">so on).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">.onmessage(callback(event))</span></strong><span class="koboSpan" id="kobo.118.1">: This event is triggered when the workers send a </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.119.1">message to the parent process. </span><span class="koboSpan" id="kobo.119.2">The event received has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">.data</span></strong><span class="koboSpan" id="kobo.121.1"> field that contains the message/data passed by </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">the worker.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">.onerror(callback(event))</span></strong><span class="koboSpan" id="kobo.124.1">: When an error occurs in the worker, this event is triggered, and it will contain the </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">following fields:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">.filename</span></strong><span class="koboSpan" id="kobo.127.1">: With the name of the script filename that generated </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">the error.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">.lineno</span></strong><span class="koboSpan" id="kobo.130.1">: The line number where the </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">error occurred.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">.message</span></strong><span class="koboSpan" id="kobo.133.1">: A string containing the description of </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">the error.</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.135.1">This messaging system </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.136.1">allows us to carry on what otherwise could be a very complex </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">form of</span></span>
<strong class="bold"><span class="koboSpan" id="kobo.138.1">inter-process communication</span></strong><span class="koboSpan" id="kobo.139.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.140.1">IPC</span></strong><span class="koboSpan" id="kobo.141.1">). </span><span class="koboSpan" id="kobo.141.2">Our previous code should look as follows due to </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">implementing it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.143.1">
let my_worker=new Worker("my_worker.js")
my_worker</span><strong class="bold"><span class="koboSpan" id="kobo.144.1">.onmessage=</span></strong><span class="koboSpan" id="kobo.145.1">event=&gt;{
    // process message here
    console.log(event.data)
}
my_worker</span><strong class="bold"><span class="koboSpan" id="kobo.146.1">.onerror=</span></strong><span class="koboSpan" id="kobo.147.1">err=&gt;{
    //process error here
}
my_worker</span><strong class="bold"><span class="koboSpan" id="kobo.148.1">.postMessage</span></strong><span class="koboSpan" id="kobo.149.1">("Hello from parent process");</span></pre>
<p><span class="koboSpan" id="kobo.150.1">To complete this, we now need to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">my_worker.js</span></strong><span class="koboSpan" id="kobo.152.1"> script. </span><span class="koboSpan" id="kobo.152.2">For this example, it can be something as simple </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">as this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.154.1">./my_worker.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.155.1">
self</span><strong class="bold"><span class="koboSpan" id="kobo.156.1">.onmesssage=</span></strong><span class="koboSpan" id="kobo.157.1">event=&gt;{
    console.log(event.data)
})
setTimeout(()=&gt;{
</span><strong class="bold"><span class="koboSpan" id="kobo.158.1">    self.postMessage</span></strong><span class="koboSpan" id="kobo.159.1">("Hello from the worker")
},3000)</span></pre>
<p><span class="koboSpan" id="kobo.160.1">Our example worker is very simple. </span><span class="koboSpan" id="kobo.160.2">It prints the data received to the console, and 3 seconds after it has been activated, it sends a message to the parent process. </span><span class="koboSpan" id="kobo.160.3">Notice that we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">self</span></strong><span class="koboSpan" id="kobo.162.1"> reserved word. </span><span class="koboSpan" id="kobo.162.2">This is needed when accessing the API from within a function, as it </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.163.1">references the worker itself. </span><span class="koboSpan" id="kobo.163.2">This is why it is necessary inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">setTimeout</span></strong><span class="koboSpan" id="kobo.165.1"> callback. </span><span class="koboSpan" id="kobo.165.2">At the root level, it is optional, so you can write </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">self.onmessage</span></strong><span class="koboSpan" id="kobo.167.1"> as in our example or </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">directly </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">onmessage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">Web Workers can instantiate other workers and also import other scripts through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">self.importScript()</span></strong><span class="koboSpan" id="kobo.173.1"> method or just </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">importScript()</span></strong><span class="koboSpan" id="kobo.175.1">. </span><span class="koboSpan" id="kobo.175.2">This method receives a string with the script filename as a parameter. </span><span class="koboSpan" id="kobo.175.3">This is analogous to how we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">import</span></strong><span class="koboSpan" id="kobo.177.1"> statement in our services and components in our </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">main application.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">When using Vite, as we are doing to bundle our Vue application, we have an alternative way to import and create a worker by using a suffix. </span><span class="koboSpan" id="kobo.179.2">For example, add the following in our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">main.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.181.1"> script:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.182.1">./main.js</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.183.1">import MyWorker from "my_worker.js?worker"</span></strong><span class="koboSpan" id="kobo.184.1">
const _myWorker=new </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">MyWorker()</span></strong><span class="koboSpan" id="kobo.186.1">
_myWorker.postMessage("Hi there!")
_myWorker.onmessage=(event)=&gt;{...}</span></pre>
<p><span class="koboSpan" id="kobo.187.1">When using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">worker</span></strong><span class="koboSpan" id="kobo.189.1"> suffix notation, Vite wraps the implementation in a constructor, which we can use to instantiate our worker. </span><span class="koboSpan" id="kobo.189.2">This way makes handling workers more akin to using any other class in our application, as we can use the same approach to include it in our application, and this is the </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.190.1">syntax we will use in our examples. </span><span class="koboSpan" id="kobo.190.2">Additionally, Vite will process the scripts from our worker, so we can use our more familiar syntax to import resources (</span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">import ... </span><span class="koboSpan" id="kobo.191.2">from ...</span></strong><span class="koboSpan" id="kobo.192.1">) instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">native </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">self.importScript()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">There is more about web workers to learn. </span><span class="koboSpan" id="kobo.196.2">For our purposes, this is enough and what we will use. </span><span class="koboSpan" id="kobo.196.3">If you </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.197.1">would like to know more, please refer to the documentation on the Mozilla Developer </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">Network (</span></span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers"><span class="No-Break"><span class="koboSpan" id="kobo.199.1">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.200.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">With these building blocks, we can now implement a robust and easier-to-handle connection to our web workers by applying design patterns. </span><span class="koboSpan" id="kobo.201.2">Before we do that, we need to learn two more patterns conceptually: the business delegate and the </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">dispatcher patterns.</span></span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.203.1">The business delegate pattern</span></h1>
<p><span class="koboSpan" id="kobo.204.1">This pattern is used to </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.205.1">hide the complexity of accessing business services or a business layer from the client or presentation layer by providing a single point of access with a well-defined and simple(r) interface. </span><span class="koboSpan" id="kobo.205.2">It can be reasoned to some degree as a variant or evolution of the proxies and decorator patterns that we saw in </span><a href="B18602_02.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.206.1">Chapter 2</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.207.1">, Software Design Principles and Patterns</span></em><span class="koboSpan" id="kobo.208.1">, but applied at a larger logical scale between architectural layers. </span><span class="koboSpan" id="kobo.208.2">It usually involves at least the </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">following entities:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.210.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.211.1">business delegate</span></strong><span class="koboSpan" id="kobo.212.1"> entity, which acts </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.213.1">as the single point of entry for the client to all the </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">available services</span></span></li>
<li><span class="koboSpan" id="kobo.215.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.216.1">business lookup or router</span></strong><span class="koboSpan" id="kobo.217.1"> entity </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.218.1">whose function is to route the execution of the incoming request to the </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">appropriate service</span></span></li>
<li><span class="koboSpan" id="kobo.220.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.221.1">business services</span></strong><span class="koboSpan" id="kobo.222.1"> that </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.223.1">expose a common interface (directly or via a proxy pattern) with the </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">provided function</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.225.1">The pattern can be represented for our purposes in the </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.227.1"><img alt="Figure 8.4 – A representation of the business delegate pattern" src="image/Figure_8.04_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.228.1">Figure 8.4 – A representation of the business delegate pattern</span></p>
<p><span class="koboSpan" id="kobo.229.1">This pattern can be applied to </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.230.1">multiple architectural levels. </span><span class="koboSpan" id="kobo.230.2">In our particular case, we want to apply this design to our application with web workers. </span><span class="koboSpan" id="kobo.230.3">We will consider the parent process as our presentation layer and our web worker as our business layer. </span><span class="koboSpan" id="kobo.230.4">In the parent (or main process), we will have our Vue application, as usual, focusing primarily on providing an excellent user experience. </span><span class="koboSpan" id="kobo.230.5">The worker will then be responsible for providing us with access to services, either local, as in the case of the IndexedDB, or remote, encapsulating the communication with our server and additional services and any additional computationally intensive function. </span><span class="koboSpan" id="kobo.230.6">This separation of concerns has many advantages, not only from the performance point of view but also from the design and implementation of the application as </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">a whole.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">Before we implement the code for this chapter, we need to see one more pattern that we will implement since we </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.233.1">can only pass serializable data between processes and cannot execute function calls as a plain Business Delegate pattern proposes. </span><span class="koboSpan" id="kobo.233.2">We will expand on the idea of the command pattern and use what is called a </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">dispatcher pattern.</span></span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.235.1">The dispatcher pattern</span></h1>
<p><span class="koboSpan" id="kobo.236.1">We have seen previously that </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.237.1">either our parent process or the web worker process can initiate communication by posting (sending) a message to each other. </span><span class="koboSpan" id="kobo.237.2">As long as the proper listener (</span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">onmessage</span></strong><span class="koboSpan" id="kobo.239.1">) has been defined, either one can receive and react to these events. </span><span class="koboSpan" id="kobo.239.2">In the Dispatcher pattern, these messages contain information related to the event, such as data. </span><span class="koboSpan" id="kobo.239.3">The key factor that separates this design pattern is that </span><em class="italic"><span class="koboSpan" id="kobo.240.1">the event messages must be published between threads and scheduled for execution upon arrival</span></em><span class="koboSpan" id="kobo.241.1">. </span><span class="koboSpan" id="kobo.241.2">Of course, this scheduling can also include the “immediate execution” of some task </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">or function.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">The implementation of this pattern is rather trivial, and you may think of it as akin to the Command Pattern that we saw in </span><a href="B18602_02.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.244.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.245.1">, </span><em class="italic"><span class="koboSpan" id="kobo.246.1">Software Design Principles and Patterns</span></em><span class="koboSpan" id="kobo.247.1">, so we will not see this again. </span><span class="koboSpan" id="kobo.247.2">Instead, we will take these concepts of communication between threads, scheduling, and events with data to create our solution to work with </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">web workers.</span></span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.249.1">Establishing a communication pipeline with the web worker</span></h1>
<p><span class="koboSpan" id="kobo.250.1">We have now seen the key </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.251.1">concepts that </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.252.1">we want to apply to our implementation of the communication with web workers for our Vue application. </span><span class="koboSpan" id="kobo.252.2">This model can be used repeatedly from application to application and improved upon as needed. </span><span class="koboSpan" id="kobo.252.3">As a general plan of action, this is what we will build using the design patterns seen </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">thus far:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.254.1">We will create a web worker with a single point of access in our Vue application, following the Business </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">Delegate pattern</span></span></li>
<li><span class="koboSpan" id="kobo.256.1">Each message will raise an event to either process (parent-worker or worker-parent) and include command and payload data, as well as tracking information for scheduling as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">Dispatcher Pattern</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.258.1">Simple enough, the </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.259.1">architecture described </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.260.1">in the preceding points allows us to establish a workflow as </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.262.1"><img alt="Figure 8.5 – Implementation of the communication workflow with the web worker" src="image/Figure_8.05_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.263.1">Figure 8.5 – Implementation of the communication workflow with the web worker</span></p>
<p><span class="koboSpan" id="kobo.264.1">Now that we have the theoretical basis and a broad understanding of what we will create, it is time to move into the code. </span><span class="koboSpan" id="kobo.264.2">We will focus on the most relevant parts of the code that implement the model mentioned previously. </span><span class="koboSpan" id="kobo.264.3">To see the entire application code, please review the full source code from the GitHub repository. </span><span class="koboSpan" id="kobo.264.4">Let’s start by creating a </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.265.1">service that will be our </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.266.1">entry point in the </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">client application:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.268.1">./services/WebWorker.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.269.1">
import </span><strong class="bold"><span class="koboSpan" id="kobo.270.1">WebWorker </span></strong><span class="koboSpan" id="kobo.271.1">from "../webworker/index.js</span><strong class="bold"><span class="koboSpan" id="kobo.272.1">?worker</span></strong><span class="koboSpan" id="kobo.273.1">"
const _worker = </span><strong class="bold"><span class="koboSpan" id="kobo.274.1">new WebWorker()</span></strong><span class="koboSpan" id="kobo.275.1">                               </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">//1</span></strong><span class="koboSpan" id="kobo.277.1">
const service = {
    </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">queue:{},</span></strong><span class="koboSpan" id="kobo.279.1">                                                 </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">//2</span></strong><span class="koboSpan" id="kobo.281.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">request</span></strong><span class="koboSpan" id="kobo.283.1">(command, payload = {}) {                          </span><strong class="bold"><span class="koboSpan" id="kobo.284.1">//3</span></strong><span class="koboSpan" id="kobo.285.1">
        return new Promise((resolve, reject) =&gt; {             </span><strong class="bold"><span class="koboSpan" id="kobo.286.1">//4</span></strong><span class="koboSpan" id="kobo.287.1">
        let message = {
            id: crypto.randomUUID(),
            command,
            payload
        }
        service.queue[</span><strong class="bold"><span class="koboSpan" id="kobo.288.1">message.id</span></strong><span class="koboSpan" id="kobo.289.1">]={resolve, reject}           </span><strong class="bold"><span class="koboSpan" id="kobo.290.1">//5</span></strong><span class="koboSpan" id="kobo.291.1">
       </span><strong class="bold"><span class="koboSpan" id="kobo.292.1"> _worker.postMessage(message);</span></strong><span class="koboSpan" id="kobo.293.1">                         </span><strong class="bold"><span class="koboSpan" id="kobo.294.1">//6</span></strong><span class="koboSpan" id="kobo.295.1">
        })
    },
    </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">processMessage</span></strong><span class="koboSpan" id="kobo.297.1">(data) {
        let id=data.id
        if(data.success){
            service.queue[id]</span><strong class="bold"><span class="koboSpan" id="kobo.298.1">.resolve(data.payload) </span></strong><span class="koboSpan" id="kobo.299.1">          </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">//7</span></strong><span class="koboSpan" id="kobo.301.1">
        }else{
            service.queue[id]</span><strong class="bold"><span class="koboSpan" id="kobo.302.1">.reject(data.payload)</span></strong><span class="koboSpan" id="kobo.303.1">
        }
        delete service.queue[id];                             </span><strong class="bold"><span class="koboSpan" id="kobo.304.1">//8</span></strong><span class="koboSpan" id="kobo.305.1">
    }
}
_worker.</span><strong class="bold"><span class="koboSpan" id="kobo.306.1">onmessage </span></strong><span class="koboSpan" id="kobo.307.1">= (event) =&gt; {
    service.processMessage(</span><strong class="bold"><span class="koboSpan" id="kobo.308.1">event.data</span></strong><span class="koboSpan" id="kobo.309.1">);                      </span><strong class="bold"><span class="koboSpan" id="kobo.310.1">//9</span></strong><span class="koboSpan" id="kobo.311.1">
}
export default service;                                      </span><strong class="bold"><span class="koboSpan" id="kobo.312.1">//10</span></strong></pre>
<p><span class="koboSpan" id="kobo.313.1">This implementation is simple yet effective. </span><span class="koboSpan" id="kobo.313.2">It serves us well to understand how these patterns work. </span><span class="koboSpan" id="kobo.313.3">We start by importing the web worker constructor using Vite’s special suffix </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">worker</span></strong><span class="koboSpan" id="kobo.315.1"> and then creating the instance reference in line </span><em class="italic"><span class="koboSpan" id="kobo.316.1">//1</span></em><span class="koboSpan" id="kobo.317.1">. </span><span class="koboSpan" id="kobo.317.2">As usual, this service will be a singleton, so we create it as a JavaScript object, which we will export later in line </span><em class="italic"><span class="koboSpan" id="kobo.318.1">//10</span></em><span class="koboSpan" id="kobo.319.1">. </span><span class="koboSpan" id="kobo.319.2">The service has only </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">three members:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">queue</span></strong><span class="koboSpan" id="kobo.322.1">: This is defined on line </span><em class="italic"><span class="koboSpan" id="kobo.323.1">//2</span></em><span class="koboSpan" id="kobo.324.1"> and is a dictionary that we will use to store our scheduled calls to the web worker using a unique identification. </span><span class="koboSpan" id="kobo.324.2">Each entry will save the reference to the resolution methods of a promise (</span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">resolve</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.326.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">reject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.329.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">request()</span></strong><span class="koboSpan" id="kobo.331.1"> method: Defined on line //3 here, this will be used by other services and components (the “clients”) to request tasks from the web worker. </span><span class="koboSpan" id="kobo.331.2">It always returns a </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.332.1">promise (line //4). </span><span class="koboSpan" id="kobo.332.2">The </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.333.1">message passed to the web worker encapsulates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">command</span></strong><span class="koboSpan" id="kobo.335.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">payload</span></strong><span class="koboSpan" id="kobo.337.1"> received as parameters with a unique identification. </span><span class="koboSpan" id="kobo.337.2">We save the reference to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">resolve()</span></strong><span class="koboSpan" id="kobo.339.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">reject()</span></strong><span class="koboSpan" id="kobo.341.1"> methods in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">queue</span></strong><span class="koboSpan" id="kobo.343.1"> (line //5), and finally, using the native messaging method of the web worker, we post the message on </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">line //6.</span></span></li>
<li><span class="koboSpan" id="kobo.345.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">processMessage()</span></strong><span class="koboSpan" id="kobo.347.1"> method: This receives the data submitted by the web worker, and based on the identification and the result of the operation passed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">.success</span></strong><span class="koboSpan" id="kobo.349.1"> attribute (Boolean), we access </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">queue</span></strong><span class="koboSpan" id="kobo.351.1"> and either use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">resolve()</span></strong><span class="koboSpan" id="kobo.353.1"> or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">reject()</span></strong><span class="koboSpan" id="kobo.355.1"> function to resolve or reject the promise (line //7). </span><span class="koboSpan" id="kobo.355.2">Finally, we remove the reference from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">queue</span></strong><span class="koboSpan" id="kobo.357.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">line //8.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.359.1">The last step in this file is to link the incoming messages passing the data directly from the worker to </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">service.processMessage()</span></strong><span class="koboSpan" id="kobo.361.1"> in line //9. </span><span class="koboSpan" id="kobo.361.2">It may be clear by now that we have made some decisions regarding the structure of the message and also the reply. </span><span class="koboSpan" id="kobo.361.3">Messages have three components: </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">id</span></strong><span class="koboSpan" id="kobo.363.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">command</span></strong><span class="koboSpan" id="kobo.365.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">payload</span></strong><span class="koboSpan" id="kobo.367.1">. </span><span class="koboSpan" id="kobo.367.2">Replies also have three elements: </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">id</span></strong><span class="koboSpan" id="kobo.369.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">success</span></strong><span class="koboSpan" id="kobo.371.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">payload</span></strong><span class="koboSpan" id="kobo.373.1">. </span><span class="koboSpan" id="kobo.373.2">On the client side, we have chosen to operate with promises, as they do not “</span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">time out”.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">With the client side </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.376.1">resolved, now it’s </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.377.1">time to work on the web worker script. </span><span class="koboSpan" id="kobo.377.2">Create the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">index.js</span></strong><span class="koboSpan" id="kobo.379.1"> file in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">webworker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.381.1"> directory:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.382.1">./webworker/index.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.383.1">
import </span><strong class="bold"><span class="koboSpan" id="kobo.384.1">testService </span></strong><span class="koboSpan" id="kobo.385.1">from "./services/test"
const </span><strong class="bold"><span class="koboSpan" id="kobo.386.1">services</span></strong><span class="koboSpan" id="kobo.387.1">=[</span><strong class="bold"><span class="koboSpan" id="kobo.388.1">testService</span></strong><span class="koboSpan" id="kobo.389.1">]                                </span><strong class="bold"><span class="koboSpan" id="kobo.390.1">//1</span></strong><span class="koboSpan" id="kobo.391.1">
function </span><strong class="bold"><span class="koboSpan" id="kobo.392.1">sendRequest</span></strong><span class="koboSpan" id="kobo.393.1">(id, success=false, payload={}){
    self.postMessage({id, success, payload})                </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">//2</span></strong><span class="koboSpan" id="kobo.395.1">
}
</span><strong class="bold"><span class="koboSpan" id="kobo.396.1">self.onmessage</span></strong><span class="koboSpan" id="kobo.397.1">=(event)=&gt;{                                   </span><strong class="bold"><span class="koboSpan" id="kobo.398.1">//3</span></strong><span class="koboSpan" id="kobo.399.1">
    const data=event.data;
    services.forEach(service=&gt;{                             </span><strong class="bold"><span class="koboSpan" id="kobo.400.1">//4</span></strong><span class="koboSpan" id="kobo.401.1">
        if(service[data.command]){                          </span><strong class="bold"><span class="koboSpan" id="kobo.402.1">//5</span></strong><span class="koboSpan" id="kobo.403.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.404.1">service[data.command](data.payload)</span></strong><span class="koboSpan" id="kobo.405.1">                 </span><strong class="bold"><span class="koboSpan" id="kobo.406.1">//6</span></strong><span class="koboSpan" id="kobo.407.1">
                .then(result=&gt;{
                    sendRequest(data.id, true, result)      </span><strong class="bold"><span class="koboSpan" id="kobo.408.1">//7</span></strong><span class="koboSpan" id="kobo.409.1">
                }, err=&gt;{
                    sendRequest(data.id, false, err)
            })
        }
    })
}</span></pre>
<p><span class="koboSpan" id="kobo.410.1">The web worker is even shorter, and we have also made some decisions regarding the interface implemented by each underlying service: each of their methods has to return a Promise as well. </span><span class="koboSpan" id="kobo.410.2">Let’s see the code and find </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">out why.</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">We start on line //1</span><em class="italic"> </em><span class="koboSpan" id="kobo.413.1">by importing </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">testService</span></strong><span class="koboSpan" id="kobo.415.1"> (we will create it later) and include it in an array of services. </span><span class="koboSpan" id="kobo.415.2">This will make it easier to add new services by importing them and just including them in this array (this could be a stepping stone to a plugin architecture but we’ll stay simple for now). </span><span class="koboSpan" id="kobo.415.3">We then define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">sendRequest()</span></strong><span class="koboSpan" id="kobo.417.1"> global function, which will send a message to the parent process with a coded message with three fields: </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">id</span></strong><span class="koboSpan" id="kobo.419.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">success</span></strong><span class="koboSpan" id="kobo.421.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">payload</span></strong><span class="koboSpan" id="kobo.423.1">, as expected by the client in our defined . </span><span class="koboSpan" id="kobo.423.2">This is what happens in </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">line</span></span><span class="No-Break"><em class="italic"> </em></span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">//2.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">In line //3, we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">onmessage</span></strong><span class="koboSpan" id="kobo.428.1"> event handler to process the incoming messages. </span><span class="koboSpan" id="kobo.428.2">When one is received, we traverse our </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">services</span></strong><span class="koboSpan" id="kobo.430.1"> array to find a matching command (line //4), and when we do (line //5), we execute the function by passing the payload as a </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.431.1">parameter (line //6) after </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.432.1">we parse it through the JSON utility. </span><span class="koboSpan" id="kobo.432.2">Then, with the resolution or rejection of the promise, we transmit the proper result to the client in line </span><em class="italic"><span class="koboSpan" id="kobo.433.1">//7</span></em><span class="koboSpan" id="kobo.434.1">. </span><span class="koboSpan" id="kobo.434.2">This short piece of code acts as the </span><em class="italic"><span class="koboSpan" id="kobo.435.1">business delegator and dispatcher</span></em><span class="koboSpan" id="kobo.436.1">. </span><span class="koboSpan" id="kobo.436.2">Finally, let’s take a look at </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">testService</span></strong><span class="koboSpan" id="kobo.438.1"> to see how </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">it works:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.440.1">./webworker/services/test.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.441.1">
const service={
   test(){
      return new Promise((resolve, reject)=&gt;{
         setTimeout(()=&gt;{
            resolve("Worker alive and working!")
         }, 3000)
      })
   }
}
export default service;</span></pre>
<p><span class="koboSpan" id="kobo.442.1">As you can appreciate, this test service doesn’t do much other than just return a Promise and set a timer to resolve it after 3 seconds. </span><span class="koboSpan" id="kobo.442.2">This delay is artificial since, otherwise, the reply would </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">be immediate.</span></span><span class="koboSpan" id="kobo.444.1">
If you run the example application, when you click the </span><strong class="bold"><span class="koboSpan" id="kobo.445.1">Send request</span></strong><span class="koboSpan" id="kobo.446.1"> button, you will see the message changing from </span><strong class="bold"><span class="koboSpan" id="kobo.447.1">Waiting...</span></strong><span class="koboSpan" id="kobo.448.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.449.1">Worker alive and working!</span></strong><span class="koboSpan" id="kobo.450.1"> after 3 seconds, just </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">as expected:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.452.1"><img alt="Figure 8.6 – The test application dispatches a command to the worker and shows the result" src="image/Figure_8.06_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.453.1">Figure 8.6 – The test application dispatches a command to the worker and shows the result</span></p>
<p><span class="koboSpan" id="kobo.454.1">To make this </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.455.1">happen, in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">App.vue</span></strong><span class="koboSpan" id="kobo.457.1"> component, we import our web worker service and send our request with the </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.458.1">command string as the name of the function in the service we want </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">to execute.</span></span><span class="koboSpan" id="kobo.460.1">
For this example, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.462.1">
import </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">webWorker </span></strong><span class="koboSpan" id="kobo.464.1">from "./services/WebWorker.js"
</span><strong class="bold"><span class="koboSpan" id="kobo.465.1">webWorker.request("test")</span></strong><span class="koboSpan" id="kobo.466.1">.then(data=&gt;{...}, err=&gt;{...})</span></pre>
<p><span class="koboSpan" id="kobo.467.1">These simple lines of code to create and manage a web worker provide your application with a considerable increase in computational power and performance. </span><span class="koboSpan" id="kobo.467.2">Now that our bases are set, it is time to do something more significant with our service worker. </span><span class="koboSpan" id="kobo.467.3">Let’s make it access our local database and </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">the network.</span></span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.469.1">Accessing IndexedDB with DexieJS in the web worker</span></h1>
<p><span class="koboSpan" id="kobo.470.1">IndexedDB is a very </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.471.1">powerful key-value </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.472.1">database; however, the native implementation </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.473.1">provides an API that is rather hard to handle. </span><span class="koboSpan" id="kobo.473.2">The actual recommendation is not to use it but, instead, work with it through a framework or library. </span><span class="koboSpan" id="kobo.473.3">The database engine is fast and very malleable, so multiple libraries have built upon its foundation and recreated functions and features not present originally. </span><span class="koboSpan" id="kobo.473.4">Some libraries even mimic SQL and document-based databases. </span><span class="koboSpan" id="kobo.473.5">Some available and free-to-use libraries are </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.475.1">DexieJS</span></strong><span class="koboSpan" id="kobo.476.1"> (</span><a href="https://dexie.org/"><span class="koboSpan" id="kobo.477.1">https://dexie.org/</span></a><span class="koboSpan" id="kobo.478.1">): A very </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.479.1">fast and well-documented library that implements a NoSQL </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">document-based database.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.481.1">PouchDB</span></strong><span class="koboSpan" id="kobo.482.1"> (</span><a href="https://pouchdb.com/"><span class="koboSpan" id="kobo.483.1">https://pouchdb.com/</span></a><span class="koboSpan" id="kobo.484.1">): A database </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.485.1">that mimics the functionality of Apache’s CouchDB and provides built-in synchronization with </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">remote servers.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.487.1">RxDB</span></strong><span class="koboSpan" id="kobo.488.1"> (</span><a href="https://rxdb.info/"><span class="koboSpan" id="kobo.489.1">https://rxdb.info/</span></a><span class="koboSpan" id="kobo.490.1">): This is a </span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.491.1">database that implements the </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">reactive model.</span></span><span class="koboSpan" id="kobo.493.1">
It also supports replication </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">to CouchDB.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.495.1">IDB</span></strong><span class="koboSpan" id="kobo.496.1"> (</span><a href="https://www.npmjs.com/package/idb"><span class="koboSpan" id="kobo.497.1">https://www.npmjs.com/package/idb</span></a><span class="koboSpan" id="kobo.498.1">): This is a light wrapper implementation </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.499.1">on top of the IndexedDB API, with some changes to improve </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">its usability.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.501.1">Depending on your requirements for local storage, these or other options will suit you well. </span><span class="koboSpan" id="kobo.501.2">We will use DexieJS for this example as it is well documented and boasts impressive speeds for bulk operations. </span><span class="koboSpan" id="kobo.501.3">We will expand our previous example and create a single-component </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.502.1">mini-application to store, retrieve, delete, and view notes. </span><span class="koboSpan" id="kobo.502.2">This covers very basic </span><strong class="bold"><span class="koboSpan" id="kobo.503.1">create, read, update, and delete</span></strong><span class="koboSpan" id="kobo.504.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.505.1">CRUD</span></strong><span class="koboSpan" id="kobo.506.1">) operations. </span><span class="koboSpan" id="kobo.506.2">When you run the example code, it will look something </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.508.1"><img alt="Figure 8.7 – A single-component CRUD example" src="image/Figure_8.07_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.509.1">Figure 8.7 – A single-component CRUD example</span></p>
<p><span class="koboSpan" id="kobo.510.1">In this example, you can create new notes, view what was saved before (this will be persistent based </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.511.1">on the domain), select </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.512.1">them to view the text, and also </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.513.1">delete them. </span><span class="koboSpan" id="kobo.513.2">All the operations will be resolved in the web worker. </span><span class="koboSpan" id="kobo.513.3">Let’s include Dexie in our application </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">npm</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.517.1">
$ npm install dexie</span></pre>
<p><span class="koboSpan" id="kobo.518.1">Next, let’s create our example </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">component application:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.520.1">/src/components/DbNotes.vue</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.521.1">
&lt;script setup&gt;
import </span><strong class="bold"><span class="koboSpan" id="kobo.522.1">webWorker</span></strong><span class="koboSpan" id="kobo.523.1"> from "../services/WebWorker"                 </span><strong class="bold"><span class="koboSpan" id="kobo.524.1">//1</span></strong><span class="koboSpan" id="kobo.525.1">
import { ref } from "vue"
const _notes=ref([]),_note=ref({}),_selected=ref({})          </span><strong class="bold"><span class="koboSpan" id="kobo.526.1">//2</span></strong><span class="koboSpan" id="kobo.527.1">
loadNotes()
function </span><strong class="bold"><span class="koboSpan" id="kobo.528.1">saveNote</span></strong><span class="koboSpan" id="kobo.529.1">(){                                          </span><strong class="bold"><span class="koboSpan" id="kobo.530.1">//3</span></strong><span class="koboSpan" id="kobo.531.1">
   if(_note.value.title &amp;&amp; _note.value.text){
      webWorker
         .request("addNote", </span><strong class="bold"><span class="koboSpan" id="kobo.532.1">JSON.stringify(_note.value)</span></strong><span class="koboSpan" id="kobo.533.1">)
         .then(id=&gt;{loadNotes()},err=&gt;{...})
         .finally(()=&gt;{_note.value={}})
   }
}
function </span><strong class="bold"><span class="koboSpan" id="kobo.534.1">deleteNote</span></strong><span class="koboSpan" id="kobo.535.1">(id){                                      </span><strong class="bold"><span class="koboSpan" id="kobo.536.1">//4</span></strong><span class="koboSpan" id="kobo.537.1">
   WebWorker
      .request("deleteNote", {id})
      .finally(()=&gt;{loadNotes()})
}
function </span><strong class="bold"><span class="koboSpan" id="kobo.538.1">openNote</span></strong><span class="koboSpan" id="kobo.539.1">(note){_selected.value=note;}                </span><strong class="bold"><span class="koboSpan" id="kobo.540.1">//5</span></strong><span class="koboSpan" id="kobo.541.1">
function </span><strong class="bold"><span class="koboSpan" id="kobo.542.1">loadNotes</span></strong><span class="koboSpan" id="kobo.543.1">(){                                         </span><strong class="bold"><span class="koboSpan" id="kobo.544.1">//6</span></strong><span class="koboSpan" id="kobo.545.1">
   webWorker
      .request("getNotes",[])
      .then(data=&gt;{_notes.value=data;},
            ()=&gt;{_notes.value=]})
}
&lt;/script&gt;
&lt;template&gt;
&lt;div&gt;
   &lt;section&gt;
      &lt;h3&gt;New note&lt;/h3&gt;
      &lt;input type="text"
            v-model="_note.title"
            placeholder="Title"&gt;
      &lt;textarea v-model="_note.text"
            placeholder="Note text..."&gt;&lt;/textarea&gt;
      &lt;button </span><strong class="bold"><span class="koboSpan" id="kobo.546.1">@click="saveNote()"</span></strong><span class="koboSpan" id="kobo.547.1">&gt;Save&lt;/button&gt;
   &lt;/section&gt;
   &lt;section&gt;
      &lt;h3&gt;Notes&lt;/h3&gt;
      &lt;div v-for="n in _notes" :key="n.id"&gt;
         &lt;a </span><strong class="bold"><span class="koboSpan" id="kobo.548.1">@click="openNote(n)"</span></strong><span class="koboSpan" id="kobo.549.1">&gt;{{ n.title }}&lt;/a&gt;
         &lt;a </span><strong class="bold"><span class="koboSpan" id="kobo.550.1">@click="deleteNote(n.id)"</span></strong><span class="koboSpan" id="kobo.551.1">&gt;[X]&lt;/a&gt;
      &lt;/div&gt;
   &lt;/section&gt;
   &lt;section&gt;
      &lt;h3&gt;Selected note&lt;/h3&gt;
      &lt;strong&gt;{{ _selected.title }}&lt;/strong&gt;
      &lt;p&gt;{{ _selected.text }}&lt;/p&gt;
   &lt;/section&gt;
&lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.552.1">The preceding file has been stripped of styles and other layout elements, so we can focus on the active parts of the code that implement the operations we are learning about. </span><span class="koboSpan" id="kobo.552.2">We start by importing our service class to handle the web worker in line </span><em class="italic"><span class="koboSpan" id="kobo.553.1">//1</span></em><span class="koboSpan" id="kobo.554.1"> and create a few internal reactive variables in line </span><em class="italic"><span class="koboSpan" id="kobo.555.1">//2</span></em><span class="koboSpan" id="kobo.556.1">. </span><span class="koboSpan" id="kobo.556.2">We will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">_notes</span></strong><span class="koboSpan" id="kobo.558.1"> to hold the full list of notes as extracted from the database, </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">_note</span></strong><span class="koboSpan" id="kobo.560.1"> as a placeholder to create new notes, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">_selected</span></strong><span class="koboSpan" id="kobo.562.1"> to display a note clicked on from the list. </span><span class="koboSpan" id="kobo.562.2">You can find the CRUD operations in </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.563.1">each function (lines </span><em class="italic"><span class="koboSpan" id="kobo.564.1">//3</span></em><span class="koboSpan" id="kobo.565.1"> to </span><em class="italic"><span class="koboSpan" id="kobo.566.1">//6)</span></em><span class="koboSpan" id="kobo.567.1"> and </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.568.1">will notice that they are very similar </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.569.1">other than handling UI reactive elements. </span><span class="koboSpan" id="kobo.569.2">They just gather the necessary information to create a request to the web worker and then apply the result. </span><span class="koboSpan" id="kobo.569.3">However, notice how in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">saveNote()</span></strong><span class="koboSpan" id="kobo.571.1"> function, when it is time to pass the object that describes our new note, we are stringifying the Vue reactive value. </span><span class="koboSpan" id="kobo.571.2">This is because the proxy implementation that Vue uses to handle reactivity is not serializable, so unless we create a copy of the plain object or apply other similar techniques to extract the values, the web worker communication will fail and throw an error. </span><span class="koboSpan" id="kobo.571.3">An easy way to make sure the data object is provided as a clonable object is to convert it into a string with </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">JSON.stringify(_note.value)</span></strong><span class="koboSpan" id="kobo.573.1"> as in our code (you could also create directly a clone, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">JSON.parse(JSON.stringify(_note.value))</span></strong><span class="koboSpan" id="kobo.575.1">. </span><span class="koboSpan" id="kobo.575.2">You need to keep in mind how </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.576.1">the information will be sent so </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.577.1">that it can be properly processed </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.578.1">at the receiving end of the web worker. </span><span class="koboSpan" id="kobo.578.2">This will become apparent now when we see </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">dbService.js</span></strong><span class="koboSpan" id="kobo.580.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">the worker:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.582.1">./src/webworker/services/dbService.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.583.1">
import Dexie from "dexie"
const db=new Dexie("Notes")                                 </span><strong class="bold"><span class="koboSpan" id="kobo.584.1">//1</span></strong><span class="koboSpan" id="kobo.585.1">
db.version(1).stores({notes: </span><strong class="bold"><span class="koboSpan" id="kobo.586.1">"++id,</span></strong><span class="koboSpan" id="kobo.587.1">title"});                </span><strong class="bold"><span class="koboSpan" id="kobo.588.1">//2</span></strong><span class="koboSpan" id="kobo.589.1">
const service={
</span><strong class="bold"><span class="koboSpan" id="kobo.590.1">addNote</span></strong><span class="koboSpan" id="kobo.591.1">(note={}){                                           </span><strong class="bold"><span class="koboSpan" id="kobo.592.1">//3</span></strong><span class="koboSpan" id="kobo.593.1">
  return new Promise(async (resolve, reject)=&gt;{
    try{
      let result_id=await </span><strong class="bold"><span class="koboSpan" id="kobo.594.1">db.notes.add(JSON.parse(note))</span></strong><span class="koboSpan" id="kobo.595.1">    </span><strong class="bold"><span class="koboSpan" id="kobo.596.1">//4</span></strong><span class="koboSpan" id="kobo.597.1">
      resolve({id:result_id})
    }catch(err){reject({})}
})},
</span><strong class="bold"><span class="koboSpan" id="kobo.598.1">getNotes</span></strong><span class="koboSpan" id="kobo.599.1">(){
  return new Promise(async (resolve, reject)=&gt;{
    try{
      let result=await db.notes</span><strong class="bold"><span class="koboSpan" id="kobo.600.1">.toArray()</span></strong><span class="koboSpan" id="kobo.601.1">;                  </span><strong class="bold"><span class="koboSpan" id="kobo.602.1">//5</span></strong><span class="koboSpan" id="kobo.603.1">
      resolve(result)
    }catch{reject([])}
})},
</span><strong class="bold"><span class="koboSpan" id="kobo.604.1">deleteNote</span></strong><span class="koboSpan" id="kobo.605.1">({id}){
  return new Promise(async (resolve, reject)=&gt;{
    try{
      await db.notes.delete(id)                             </span><strong class="bold"><span class="koboSpan" id="kobo.606.1">//6</span></strong><span class="koboSpan" id="kobo.607.1">
      resolve({})
    }catch{reject({})}
})}}
export default service;</span></pre>
<p><span class="koboSpan" id="kobo.608.1">To use Dexie, we first import the constructor as in line </span><em class="italic"><span class="koboSpan" id="kobo.609.1">//1</span></em><span class="koboSpan" id="kobo.610.1">, and we create a new database with the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">Notes</span></strong><span class="koboSpan" id="kobo.612.1">. </span><span class="koboSpan" id="kobo.612.2">Before we can actually use it, we need to define the version and a simple schema of tables/collections with the fields that will be indexed. </span><span class="koboSpan" id="kobo.612.3">This is what happens in line </span><em class="italic"><span class="koboSpan" id="kobo.613.1">//2</span></em><span class="koboSpan" id="kobo.614.1">, where we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">notes</span></strong><span class="koboSpan" id="kobo.616.1"> collection with two indexed fields: </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">id</span></strong><span class="koboSpan" id="kobo.618.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">title</span></strong><span class="koboSpan" id="kobo.620.1">. </span><span class="koboSpan" id="kobo.620.2">These indexed fields are passed as a string, comma-separated by field names. </span><span class="koboSpan" id="kobo.620.3">We also included a double plus sign as a prefix for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">id</span></strong><span class="koboSpan" id="kobo.622.1"> field. </span><span class="koboSpan" id="kobo.622.2">This makes the field auto-generated by the database and auto-incremented with each </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">new record.</span></span></p>
<p><span class="koboSpan" id="kobo.624.1">The next </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.625.1">significant function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">addNote()</span></strong><span class="koboSpan" id="kobo.627.1">, adds </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.628.1">the record to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">notes</span></strong><span class="koboSpan" id="kobo.630.1"> collection. </span><span class="koboSpan" id="kobo.630.2">Since </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.631.1">we are passing data serializing an object as a string in our component, in line </span><em class="italic"><span class="koboSpan" id="kobo.632.1">//4</span></em><span class="koboSpan" id="kobo.633.1">, we need to parse the string to recompose the object.</span></p>
<p><span class="koboSpan" id="kobo.634.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">getNotes()</span></strong><span class="koboSpan" id="kobo.636.1"> function, we just retrieve all the elements from the collection and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">toArray()</span></strong><span class="koboSpan" id="kobo.638.1"> method provided by Dexie, which will convert it into a JavaScript array (line </span><em class="italic"><span class="koboSpan" id="kobo.639.1">//5</span></em><span class="koboSpan" id="kobo.640.1">). </span><span class="koboSpan" id="kobo.640.2">This way, we can return it directly as our result to resolve </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">the promise.</span></span></p>
<p><span class="koboSpan" id="kobo.642.1">A final note on this code is on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">deleteNote()</span></strong><span class="koboSpan" id="kobo.644.1"> method: on line </span><em class="italic"><span class="koboSpan" id="kobo.645.1">//6</span></em><span class="koboSpan" id="kobo.646.1">, we are not capturing the result of the asynchronous operation. </span><span class="koboSpan" id="kobo.646.2">This is because this operation does not return a usable value. </span><span class="koboSpan" id="kobo.646.3">In this case, this operation will always resolve unless a database engine error interrupts </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">the execution.</span></span></p>
<p><span class="koboSpan" id="kobo.648.1">It is important to keep in mind that errors on the web worker will not affect the parent process, and any operations in that process will </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">be unaffected.</span></span></p>
<p><span class="koboSpan" id="kobo.650.1">Now that we have our service in place, it is time to slightly modify the web worker index file. </span><span class="koboSpan" id="kobo.650.2">Add the </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">following lines:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.652.1">./src/webworker/index.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.653.1">
import </span><strong class="bold"><span class="koboSpan" id="kobo.654.1">dbService </span></strong><span class="koboSpan" id="kobo.655.1">from "./services/dbService";
const services=[</span><strong class="bold"><span class="koboSpan" id="kobo.656.1">dbService,</span></strong><span class="koboSpan" id="kobo.657.1"> testService];</span></pre>
<p><span class="koboSpan" id="kobo.658.1">No other change is necessary for this file. </span><span class="koboSpan" id="kobo.658.2">As we can see, it does not take much to implement CRUD operations on the web worker. </span><span class="koboSpan" id="kobo.658.3">Even though these can be done in the parent process, and there is a small penalty from the interprocess communication, the benefits in </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.659.1">performance are considerable and well worth </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.660.1">the effort. </span><span class="koboSpan" id="kobo.660.2">Especially if our </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.661.1">application includes what should be background processes, such as synchronization with a remote server, these </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.662.1">should be done by a web worker. </span><span class="koboSpan" id="kobo.662.2">Let’s see next how we can access the network and consume a </span><strong class="bold"><span class="koboSpan" id="kobo.663.1">Representational State Transfer API </span></strong><span class="koboSpan" id="kobo.664.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.665.1">RESTful API</span></strong><span class="koboSpan" id="kobo.666.1">) from a worker </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">as well.</span></span></p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.668.1">Consuming a RESTful API with the web worker</span></h1>
<p><span class="koboSpan" id="kobo.669.1">One of the </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.670.1">most common applications of network APIs today in web development is through the implementation </span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.671.1">of a RESTful API. </span><span class="koboSpan" id="kobo.671.2">It is a protocol where each communication is stateless and representative of the type of action required at the destination. </span><span class="koboSpan" id="kobo.671.3">The HTTP protocol used on the web provides a perfect match for this type of API, as each network call exposes a method that identifies the type of </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">operation required:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.673.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">GET</span></strong><span class="koboSpan" id="kobo.675.1"> operations retrieve data </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">and files</span></span></li>
<li><span class="koboSpan" id="kobo.677.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">PUT</span></strong><span class="koboSpan" id="kobo.679.1"> operations </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">update data</span></span></li>
<li><span class="koboSpan" id="kobo.681.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">POST</span></strong><span class="koboSpan" id="kobo.683.1"> operations create new data on </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">the server</span></span></li>
<li><span class="koboSpan" id="kobo.685.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">DELETE</span></strong><span class="koboSpan" id="kobo.687.1"> operations erase data on </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">the server</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.689.1">It is easy to see how these methods match CRUD operations, so by making the appropriate network call, the server knows how to process the data received at the proper endpoint. </span><span class="koboSpan" id="kobo.689.2">There are many standards used to format the data sent between endpoints. </span><span class="koboSpan" id="kobo.689.3">In particular, one of the most common ones is the JSON format, which we so conveniently use </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">in JavaScript.</span></span></p>
<p><span class="koboSpan" id="kobo.691.1">Handling asynchronous calls with the native implementation in the browser is, at the very least, cumbersome but not impossible. </span><span class="koboSpan" id="kobo.691.2">The recommendation, for practicality and security, is to use a </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.692.1">well-known library such as </span><strong class="bold"><span class="koboSpan" id="kobo.693.1">Axios</span></strong><span class="koboSpan" id="kobo.694.1">. </span><span class="koboSpan" id="kobo.694.2">To install the library, we need to run the following command from </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">the terminal:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.696.1">
$ npm install axios</span></pre>
<p><span class="koboSpan" id="kobo.697.1">After a few moments, the library will be installed into our project as a dependency. </span><span class="koboSpan" id="kobo.697.2">The library provides very handy methods to launch network calls for each HTTP method. </span><span class="koboSpan" id="kobo.697.3">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">axios.get</span></strong><span class="koboSpan" id="kobo.699.1"> makes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">GET</span></strong><span class="koboSpan" id="kobo.701.1"> request, </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">axios.post</span></strong><span class="koboSpan" id="kobo.703.1"> makes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">POST</span></strong><span class="koboSpan" id="kobo.705.1"> request, and </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">so forth.</span></span></p>
<p><span class="koboSpan" id="kobo.707.1">We will implement </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.708.1">a simple service for our learning exercise to make network calls to a remote server </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.709.1">from within our web worker. </span><span class="koboSpan" id="kobo.709.2">For simplicity, we will only create </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">two methods:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.711.1">./webworker/services/network.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.712.1">
import axios from "axios"
</span><strong class="bold"><span class="koboSpan" id="kobo.713.1">axios.defaults.baseURL="http://localhost:3000"</span></strong><span class="koboSpan" id="kobo.714.1">
const service={
   </span><strong class="bold"><span class="koboSpan" id="kobo.715.1">GET</span></strong><span class="koboSpan" id="kobo.716.1">(payload={}){
     return new Promise((resolve, reject)=&gt;{
       axios
         .</span><strong class="bold"><span class="koboSpan" id="kobo.717.1">get</span></strong><span class="koboSpan" id="kobo.718.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.719.1">payload.url,{params:{data:payload.data}}</span></strong><span class="koboSpan" id="kobo.720.1">)
         .then(result=&gt;{
             if(result.status&gt;=200 &amp;&amp; result.status&lt;300){
                  resolve(result.data)
             }else{reject()}
         }).catch(()=&gt;{reject()})
  })},
  </span><strong class="bold"><span class="koboSpan" id="kobo.721.1">POST</span></strong><span class="koboSpan" id="kobo.722.1">(payload={}){
    return new Promise((resolve, reject)=&gt;{
      axios
         .</span><strong class="bold"><span class="koboSpan" id="kobo.723.1">post</span></strong><span class="koboSpan" id="kobo.724.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.725.1">payload.url,{data:payload.data}</span></strong><span class="koboSpan" id="kobo.726.1">)
         .then(result=&gt;{
           if(result.status&gt;=200 &amp;&amp; result.status&lt;300){
                resolve(result.data)
           }else{reject()}})
         .catch(()=&gt;{reject()})
})}}
export default service;</span></pre>
<p><span class="koboSpan" id="kobo.727.1">This service is rather simple. </span><span class="koboSpan" id="kobo.727.2">In a production application, it would be middleware to serve other services. </span><span class="koboSpan" id="kobo.727.3">This example implements only two methods to match the corresponding </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.728.1">HTTP request methods. </span><span class="koboSpan" id="kobo.728.2">Notice that they are extremely similar, only changing the </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.729.1">name of the method and the signature for some of the parameters. </span><span class="koboSpan" id="kobo.729.2">The first parameter is always the endpoint (URI) to connect. </span><span class="koboSpan" id="kobo.729.3">The second parameter is either data or an object with options. </span><span class="koboSpan" id="kobo.729.4">I refer you to the official documentation for how to handle each specific request and handle edge </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">cases (</span></span><a href="https://axios-http.com/docs/intro"><span class="No-Break"><span class="koboSpan" id="kobo.731.1">https://axios-http.com/docs/intro</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.732.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.733.1">It is worth noting that at the beginning of the file, we set the default domain for all other network calls. </span><span class="koboSpan" id="kobo.733.2">This way, we avoid repeating it in each call. </span><span class="koboSpan" id="kobo.733.3">We can easily set specific HTTP headers </span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.734.1">and options with this library, such as </span><strong class="bold"><span class="koboSpan" id="kobo.735.1">JSON Web Tokens</span></strong><span class="koboSpan" id="kobo.736.1">, for authentication, as we covered in </span><a href="B18602_05.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.737.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.738.1">, </span><em class="italic"><span class="koboSpan" id="kobo.739.1">Single-Page Applications</span></em><span class="koboSpan" id="kobo.740.1">, when we mentioned different </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">authentication methods.</span></span></p>
<p><span class="koboSpan" id="kobo.742.1">To include this service in our web worker, we import it and add it to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">services</span></strong><span class="koboSpan" id="kobo.744.1"> array as we did before. </span><span class="koboSpan" id="kobo.744.2">Modify the beginning of this file so it looks </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.746.1">./webworker/index.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.747.1">
import netService from "./services/network"
const services=[dbService, netService, testService]</span></pre>
<p><span class="koboSpan" id="kobo.748.1">With this new inclusion, our web worker is now ready. </span><span class="koboSpan" id="kobo.748.2">We now implement a single component to test the communication, and it will look </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.750.1"><img alt="Figure 8.8 – A simple test, where the server mirrors back the information sent" src="image/Figure_8.08_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.751.1">Figure 8.8 – A simple test, where the server mirrors back the information sent</span></p>
<p><span class="koboSpan" id="kobo.752.1">Our component will let us select the method for the HTTP request (</span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">GET</span></strong><span class="koboSpan" id="kobo.754.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">POST</span></strong><span class="koboSpan" id="kobo.756.1">) and will send some </span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.757.1">arbitrary data. </span><span class="koboSpan" id="kobo.757.2">The test server will just mirror the data received back to the client, where the component </span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.758.1">will present it on the screen. </span><span class="koboSpan" id="kobo.758.2">The implementation is </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">quite straightforward:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.760.1">./src/components/NetworkCommunication.vue</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.761.1">
&lt;script setup&gt;
import webWorker from "../services/WebWorker"
import { ref } from "vue"
const
    _data_to_send = ref(""),
    _data_received = ref(""),
    _method = ref("GET")
function sendData(){
    webWorker
        .request(</span><strong class="bold"><span class="koboSpan" id="kobo.762.1">_method.value</span></strong><span class="koboSpan" id="kobo.763.1">,                              //1
</span><strong class="bold"><span class="koboSpan" id="kobo.764.1">            {url:"/api/test", data: _data_to_send.value}</span></strong><span class="koboSpan" id="kobo.765.1">)
        .then(reply=&gt;{</span><strong class="bold"><span class="koboSpan" id="kobo.766.1">_data_received.value=reply</span></strong><span class="koboSpan" id="kobo.767.1">},
        ()=&gt;{_data_received.value="Error"
        })
}
&lt;/script&gt;
&lt;template&gt;
    &lt;div&gt;
       &lt;section&gt;
           &lt;h4&gt;Text to send&lt;/h4&gt;
           &lt;div&gt;
               &lt;label&gt;
                    &lt;input
                        type="radio"
                        value="GET"
                        name="method"
                        v-model="_method"&gt;
                    &lt;span&gt;GET Method&lt;/span&gt;
               &lt;/label&gt;
               &lt;label&gt;
                    &lt;input
                        type="radio"
                        value="POST"
                        name="method"
                        v-model="_method"&gt;
                    &lt;span&gt;POST Method&lt;/span&gt;
               &lt;/label&gt;
           &lt;/div&gt;
               &lt;input type="text" v-model="_data_to_send"&gt;
               &lt;button @click="</span><strong class="bold"><span class="koboSpan" id="kobo.768.1">sendData()</span></strong><span class="koboSpan" id="kobo.769.1">"&gt;Send&lt;/button&gt;
       &lt;/section&gt;
       &lt;section&gt;
           &lt;h4&gt;Data received from server&lt;/h4&gt;
               {{ _data_received }}
       &lt;/section&gt;
    &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.770.1">In this component, we import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">webWorker</span></strong><span class="koboSpan" id="kobo.772.1"> service and declare three reactive variables to send and receive data and one to hold the selected method to make the request. </span><span class="koboSpan" id="kobo.772.2">Our simple test server will receive the request and will just mirror back the data that we submit. </span><span class="koboSpan" id="kobo.772.3">We will see later how to create this simple server </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">using Node.js.</span></span></p>
<p><span class="koboSpan" id="kobo.774.1">In the template, the user can choose the type of request to send (</span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">GET</span></strong><span class="koboSpan" id="kobo.776.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">POST</span></strong><span class="koboSpan" id="kobo.778.1">), a choice that we </span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.779.1">save in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">_method</span></strong><span class="koboSpan" id="kobo.781.1"> variable. </span><span class="koboSpan" id="kobo.781.2">We use this value as the command passed to the </span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.782.1">worker in line </span><em class="italic"><span class="koboSpan" id="kobo.783.1">//1</span></em><span class="koboSpan" id="kobo.784.1">. </span><span class="koboSpan" id="kobo.784.2">We pass the data as a member object as a payload. </span><span class="koboSpan" id="kobo.784.3">When this promise resolves, we save the value from the reply in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">_data_received</span></strong><span class="koboSpan" id="kobo.786.1"> variable. </span><span class="koboSpan" id="kobo.786.2">The rest of the source code should be trivial to understand at this point, as it deals mainly with the template and presentation of the information on the screen. </span><span class="koboSpan" id="kobo.786.3">Before we end this chapter, let’s take a look a how the test server can be implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">using Node.js.</span></span></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.788.1">A simple NodeJS server for testing</span></h1>
<p><span class="koboSpan" id="kobo.789.1">To test our </span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.790.1">network communications, it seems fitting that we implement a small server using Node.js to implement the endpoints that we are testing. </span><span class="koboSpan" id="kobo.790.2">In a separate directory from our Vue application, open a terminal window and enter the </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.792.1">
$ npm init</span></pre>
<p><span class="koboSpan" id="kobo.793.1">The command-line wizard </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.794.1">will ask you a few questions to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">package.json</span></strong><span class="koboSpan" id="kobo.796.1"> file that represents a Node.js application. </span><span class="koboSpan" id="kobo.796.2">When it is done, run this command to install the </span><strong class="bold"><span class="koboSpan" id="kobo.797.1">Express.js</span></strong><span class="koboSpan" id="kobo.798.1"> dependency, which will give us a framework to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">web server:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.800.1">
$ npm install express cors</span></pre>
<p><span class="koboSpan" id="kobo.801.1">Once the process completes, create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">index.js</span></strong><span class="koboSpan" id="kobo.803.1"> file with the </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">following code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.805.1">./server/index.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.806.1">
const </span><strong class="bold"><span class="koboSpan" id="kobo.807.1">express </span></strong><span class="koboSpan" id="kobo.808.1">= require("express")                     </span><strong class="bold"><span class="koboSpan" id="kobo.809.1">//1</span></strong><span class="koboSpan" id="kobo.810.1">
const cors=require("cors")                             </span><strong class="bold"><span class="koboSpan" id="kobo.811.1">//2</span></strong><span class="koboSpan" id="kobo.812.1">
const </span><strong class="bold"><span class="koboSpan" id="kobo.813.1">app=express()</span></strong><span class="koboSpan" id="kobo.814.1">                                    </span><strong class="bold"><span class="koboSpan" id="kobo.815.1">//3</span></strong><span class="koboSpan" id="kobo.816.1">
const PORT=3000
</span><strong class="bold"><span class="koboSpan" id="kobo.817.1">app.use(cors())</span></strong><span class="koboSpan" id="kobo.818.1">                                        </span><strong class="bold"><span class="koboSpan" id="kobo.819.1">//4</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.820.1">app.use(express.json())</span></strong><span class="koboSpan" id="kobo.821.1">                                </span><strong class="bold"><span class="koboSpan" id="kobo.822.1">//5</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.823.1">app.get("/api/test",</span></strong><span class="koboSpan" id="kobo.824.1"> (req, res)=&gt;{                     </span><strong class="bold"><span class="koboSpan" id="kobo.825.1">//6</span></strong><span class="koboSpan" id="kobo.826.1">
    const data=req.query                               </span><strong class="bold"><span class="koboSpan" id="kobo.827.1">//7</span></strong><span class="koboSpan" id="kobo.828.1">
    res.jsonp(data)                                    </span><strong class="bold"><span class="koboSpan" id="kobo.829.1">//8</span></strong><span class="koboSpan" id="kobo.830.1">
})
</span><strong class="bold"><span class="koboSpan" id="kobo.831.1">app.post("/api/test",</span></strong><span class="koboSpan" id="kobo.832.1"> (req, res)=&gt;{
    const data=req.body                                </span><strong class="bold"><span class="koboSpan" id="kobo.833.1">//9</span></strong><span class="koboSpan" id="kobo.834.1">
    res.jsonp(data)
})
</span><strong class="bold"><span class="koboSpan" id="kobo.835.1">app.listen(PORT,</span></strong><span class="koboSpan" id="kobo.836.1"> ()=&gt;{                                 </span><strong class="bold"><span class="koboSpan" id="kobo.837.1">//10</span></strong><span class="koboSpan" id="kobo.838.1">
    console.log("Server listening on port " + PORT)
})</span></pre>
<p><span class="koboSpan" id="kobo.839.1">With these few lines of code, we can start a small server that receives and responds with JSON data. </span><span class="koboSpan" id="kobo.839.2">We import the express constructor (line </span><em class="italic"><span class="koboSpan" id="kobo.840.1">//1</span></em><span class="koboSpan" id="kobo.841.1">), and a plugin (line </span><em class="italic"><span class="koboSpan" id="kobo.842.1">//2</span></em><span class="koboSpan" id="kobo.843.1">). </span><span class="koboSpan" id="kobo.843.2">This is important so that we can access this server from any domain (origin). </span><span class="koboSpan" id="kobo.843.3">The </span><strong class="bold"><span class="koboSpan" id="kobo.844.1">Cross-Origin Request Sharing</span></strong><span class="koboSpan" id="kobo.845.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.846.1">CORS</span></strong><span class="koboSpan" id="kobo.847.1">)serves to circumvent the security measure that servers implement to prevent serving </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.848.1">requests from other sources (origins) than their own. </span><span class="koboSpan" id="kobo.848.2">It has to be enabled to allow requests from other origins. </span><span class="koboSpan" id="kobo.848.3">After we create our server application (line </span><em class="italic"><span class="koboSpan" id="kobo.849.1">//3</span></em><span class="koboSpan" id="kobo.850.1">), we pass the plugin (line </span><em class="italic"><span class="koboSpan" id="kobo.851.1">//4</span></em><span class="koboSpan" id="kobo.852.1">). </span><span class="koboSpan" id="kobo.852.2">We also pass another plugin (line </span><em class="italic"><span class="koboSpan" id="kobo.853.1">//5</span></em><span class="koboSpan" id="kobo.854.1">), to make the server identify and reply to network calls with JSON objects. </span><span class="koboSpan" id="kobo.854.2">We then proceed to create two endpoints, one for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">GET</span></strong><span class="koboSpan" id="kobo.856.1"> requests (line </span><em class="italic"><span class="koboSpan" id="kobo.857.1">//6</span></em><span class="koboSpan" id="kobo.858.1">) and another one for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">POST</span></strong><span class="koboSpan" id="kobo.860.1"> request. </span><span class="koboSpan" id="kobo.860.2">The first parameter is the URL where the server will be listening for calls. </span><span class="koboSpan" id="kobo.860.3">In this case, they are the same, as the only difference will be the type of request method. </span><span class="koboSpan" id="kobo.860.4">This is </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">standard practice.</span></span></p>
<p><span class="koboSpan" id="kobo.862.1">Each endpoint </span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.863.1">receives as the last argument a callback function with at least two parameters: </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">req</span></strong><span class="koboSpan" id="kobo.865.1"> (request) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">res</span></strong><span class="koboSpan" id="kobo.867.1"> (response). </span><span class="koboSpan" id="kobo.867.2">These objects contain methods and information about the request received and the necessary methods to create a response to </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.869.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">GET</span></strong><span class="koboSpan" id="kobo.871.1"> requests, the data received is passed attached to the URL as a “query string”, so in order to access it,</span><em class="italic"><span class="koboSpan" id="kobo.872.1"> Express </span></em><span class="koboSpan" id="kobo.873.1">wraps it nicely as an object in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">request.query</span></strong><span class="koboSpan" id="kobo.875.1"> field (line </span><em class="italic"><span class="koboSpan" id="kobo.876.1">//7</span></em><span class="koboSpan" id="kobo.877.1">). </span><span class="koboSpan" id="kobo.877.2">Since we are just replying with the same data received, in line </span><em class="italic"><span class="koboSpan" id="kobo.878.1">//8</span></em><span class="koboSpan" id="kobo.879.1">, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">res</span></strong><span class="koboSpan" id="kobo.881.1">(ponse) object to create a padded JSON reply with the same data object. </span><span class="koboSpan" id="kobo.881.2">We do this because we consider that we could receive calls from any domain (because we enabled CORS) and want to ensure the reply is fully understood. </span><strong class="bold"><span class="koboSpan" id="kobo.882.1">JSON with Padding</span></strong><span class="koboSpan" id="kobo.883.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.884.1">JSONP</span></strong><span class="koboSpan" id="kobo.885.1">) is a method to send the response using a different method. </span><span class="koboSpan" id="kobo.885.2">We </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.886.1">don’t need to worry about this, as both ends (sender and receiver) are handled by the Express server and the </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">Axios client.</span></span></p>
<p><span class="koboSpan" id="kobo.888.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">post </span></strong><span class="koboSpan" id="kobo.890.1">method, the difference is that the data is contained in the body of the message (line </span><em class="italic"><span class="koboSpan" id="kobo.891.1">//9</span></em><span class="koboSpan" id="kobo.892.1">), hence the different treatment. </span><span class="koboSpan" id="kobo.892.2">Finally, the server starts listening on the designated port (line </span><em class="italic"><span class="koboSpan" id="kobo.893.1">//10</span></em><span class="koboSpan" id="kobo.894.1">). </span><span class="koboSpan" id="kobo.894.2">We can now access the server at </span><a href="http://localhost:3000"><span class="koboSpan" id="kobo.895.1">http://localhost:3000</span></a><span class="koboSpan" id="kobo.896.1">, which is the address that we configured in our network service as the default </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">for Axios.</span></span></p>
<p><span class="koboSpan" id="kobo.898.1">With the implementation </span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.899.1">of this server, we can now have a full test of all the parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">the system.</span></span></p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.901.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.902.1">In this chapter, we reviewed some very important concepts to fundamentally improve the architecture and performance of our application. </span><span class="koboSpan" id="kobo.902.2">Web workers is an amazing technology that allows web applications to take advantage of modern hardware architectures and modern operating systems. </span><span class="koboSpan" id="kobo.902.3">From a fixed point of view, multithreading using web workers involves little additional effort and complications, and the gains are highly rewarding. </span><span class="koboSpan" id="kobo.902.4">We also saw how to make use of workers to access network services as well as the local persistent database provided by the browser (IndexedDB). </span><span class="koboSpan" id="kobo.902.5">We learned about two more design patterns to implement a scalable architecture for our application and tested the concepts and implementations through simple components and services. </span><span class="koboSpan" id="kobo.902.6">The use of web workers marks a significant difference in the performance and execution of a well-designed web application. </span><span class="koboSpan" id="kobo.902.7">In the next chapter, we will look into tools and techniques to test our code automatically, ensuring the individual parts comply with their intended purpose to match our software specifications </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">and requirements.</span></span></p>
<h1 id="_idParaDest-158"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.904.1">Review questions</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.905.1">What limitations does JavaScript have that can compromise the performance of a </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">web application?</span></span></li>
<li><span class="koboSpan" id="kobo.907.1">What are web workers? </span><span class="koboSpan" id="kobo.907.2">What are </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">their limitations?</span></span></li>
<li><span class="koboSpan" id="kobo.909.1">How can Vue applications communicate with </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">web workers?</span></span></li>
<li><span class="koboSpan" id="kobo.911.1">What are the benefits of using a design pattern such as the Business Delegate to work with </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">web workers?</span></span></li>
<li><span class="koboSpan" id="kobo.913.1">What can you change in the example code to manage multiple web workers instead of just one? </span><span class="koboSpan" id="kobo.913.2">When would this be advisable, in </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">your opinion?</span></span></li>
</ul>
</div>
</body></html>