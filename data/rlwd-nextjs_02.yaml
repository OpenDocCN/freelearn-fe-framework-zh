- en: '*Chapter 1*: A Brief Introduction to Next.js'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：Next.js简明介绍'
- en: Next.js is an open source JavaScript web framework for React that ships with
    a rich set of features out of the box, such as server-side rendering, static site
    generation, and incremental static regeneration. These are just some of the many
    built-in components and plugins that make Next.js a framework ready for both enterprise-level
    applications and small websites.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js是一个开源的JavaScript网络框架，为React提供了一套丰富的内置功能，例如服务器端渲染、静态站点生成和增量静态再生。这些只是使Next.js成为既适用于企业级应用又适用于小型网站的框架的许多内置组件和插件中的少数几个。
- en: This book aims to show you the full potential of this framework while building
    real-world applications and use cases, such as e-commerce websites and blogging
    platforms. You will learn the basics of Next.js, how to choose between different
    rendering strategies and deployment methodologies, and different tips and approaches
    for making your web application both scalable and maintainable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在在构建真实世界的应用和用例（如电子商务网站和博客平台）的同时，向您展示该框架的全部潜力。您将学习Next.js的基础知识，如何在不同渲染策略和部署方法之间进行选择，以及如何使您的网络应用既可扩展又易于维护的技巧和方法。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to the Next.js framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js框架简介
- en: Comparing Next.js with other popular alternatives
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Next.js与其他流行的替代方案进行比较
- en: Differences between Next.js and client-side React
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js与客户端React之间的区别
- en: Anatomy of a default Next.js project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认Next.js项目的结构
- en: How to develop Next.js applications using TypeScript
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用TypeScript开发Next.js应用
- en: How to customize both Babel and webpack configurations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何自定义Babel和webpack配置
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get started with Next.js, you need to install a couple of dependencies on
    your machine.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Next.js，您需要在您的机器上安装一些依赖项。
- en: 'First of all, you need to install **Node.js** and **npm**. Please refer to
    this blog post if you need a detailed guide for installing them: [https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要安装**Node.js**和**npm**。如果您需要安装它们的详细指南，请参阅这篇博客文章：[https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js)。
- en: If you don't want to install Node.js on your local machine, some online platforms
    will let you follow the code examples in this book using an online IDE for free,
    such as [https://codesandbox.io](https://codesandbox.io) and https://repl.it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想在本地机器上安装Node.js，一些在线平台将允许您免费使用在线IDE跟随本书中的代码示例，例如[https://codesandbox.io](https://codesandbox.io)和https://repl.it。
- en: Once you have both Node.js and npm installed (or you're using an online environment),
    you'll only need to follow the instructions displayed in each section of this
    book for installing the required project-specific dependencies using npm.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装了Node.js和npm（或者您正在使用在线环境），您只需遵循本书每个部分显示的说明，使用npm安装所需的项目特定依赖项。
- en: 'You can find complete code examples on GitHub under the following repository:
    [https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js).
    Feel free to fork, clone, and edit this repository for any experimentation with
    Next.js.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下GitHub仓库中找到完整的代码示例：[https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js)。请随意分支、克隆和编辑此仓库，以进行任何Next.js的实验。
- en: Introducing Next.js
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Next.js
- en: Web development has changed a lot over the last few years. Before the advent
    of modern JavaScript frameworks, creating dynamic web applications was complex,
    and it required many different libraries and configurations to make them work
    as expected.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，网络开发发生了很大的变化。在现代JavaScript框架出现之前，创建动态网络应用非常复杂，需要许多不同的库和配置才能按预期工作。
- en: Angular, React, Vue, and all the other frameworks have enabled the web to evolve
    very quickly, and brought with them some very innovative ideas to frontend web
    development.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Angular、React、Vue以及其他框架使网络发展非常迅速，并为前端网络开发带来了许多非常创新的想法。
- en: React, in particular, was created by *Jordan Walke* at Facebook and was heavily
    influenced by the *XHP Hack Library*. XHP allowed Facebook's PHP and Hack developers
    to create reusable components for the frontend of their applications. The JavaScript
    library became open source in 2013 and forever changed how we build websites,
    web apps, native apps (with **React Native** later on), and even VR experiences
    (with **React VR**). As a result, React has quickly become one of the most loved
    and popular JavaScript libraries, with millions of websites using it in production
    for many different purposes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: React 最初是由 *乔丹·沃尔克* 在 Facebook 创建的，并受到了 *XHP Hack Library* 的强烈影响。XHP 允许 Facebook
    的 PHP 和 Hack 开发者为其应用程序的前端创建可重用组件。该 JavaScript 库于 2013 年开源，并永远改变了我们构建网站、网络应用、原生应用（后来是
    **React Native**）以及甚至 VR 体验（后来是 **React VR**）的方式。因此，React 迅速成为最受欢迎和流行的 JavaScript
    库之一，数百万个网站在生产中使用它用于各种不同的目的。
- en: 'There was just one problem: by default, React runs on the **client side** (meaning
    that it runs on the web browser), so a web application written entirely with that
    library could negatively affect **Search Engine Optimization** (**SEO**) and initial
    load performance, as it takes some time to be correctly rendered on screen. In
    fact, to display the complete web app, the browser had to download the entire
    application bundle, parse its content, then execute it and render the result in
    the browser, which could take up to a few seconds (with very large applications).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个问题：默认情况下，React 在 **客户端** 运行（这意味着它在网页浏览器上运行），因此完全使用该库编写的网络应用可能会对 **搜索引擎优化**（**SEO**）和初始加载性能产生负面影响，因为它需要一些时间才能正确渲染到屏幕上。实际上，为了显示完整的网络应用，浏览器必须下载整个应用包，解析其内容，然后执行它并在浏览器中渲染结果，这可能需要几秒钟（对于非常大的应用）。
- en: Many companies and developers started investigating how to pre-render the application
    on the server, letting the browser display the rendered React app as plain HTML,
    making it interactive as soon as the JavaScript bundle has been transferred to
    the client.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公司和开发者开始研究如何在服务器端预渲染应用，让浏览器显示渲染后的 React 应用作为纯 HTML，一旦 JavaScript 包被传输到客户端，它就可以立即交互。
- en: Then, **Vercel** came up with Next.js, which has turned out to be a game-changer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，**Vercel** 推出了 Next.js，它最终成为了一个颠覆性的产品。
- en: Since its first release, the framework has provided many innovative features
    out of the box, such as automatic code-splitting, server-side rendering, file-based
    routing systems, route pre-fetching, and so on. Next.js showed how easy it should
    be to write universal web applications by allowing developers to write reusable
    code for both client and server sides and making very complex tasks (such as code-splitting
    and server-side rendering) effortless to implement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 自从首次发布以来，该框架已经提供了一些开箱即用的创新功能，例如自动代码拆分、服务器端渲染、基于文件的路由系统、路由预取等等。Next.js 通过允许开发者编写用于客户端和服务器两端的可重用代码，以及使非常复杂的工作（如代码拆分和服务器端渲染）变得容易实现，展示了编写通用网络应用应该是多么简单。
- en: 'Today, Next.js provides tons of new features out of the box, such as the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，Next.js 提供了大量的新功能，例如以下内容：
- en: Static site generation
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态站点生成
- en: Incremental static generation
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐进式静态生成
- en: Native TypeScript support
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生 TypeScript 支持
- en: Automatic polyfills
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动填充
- en: Image optimization
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片优化
- en: Support for internationalization
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际化支持
- en: Performance analytics
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析
- en: All this, along with many other great features that we'll look at in depth later
    on in this book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些，再加上本书后面我们将深入探讨的许多其他优秀功能。
- en: Today, Next.js is used in production by top-level companies such as Netflix,
    Twitch, TikTok, Hulu, Nike, Uber, Elastic, and many others. If you're interested,
    you can read the complete list at https://nextjs.org/showcase.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，Next.js 被Netflix、Twitch、TikTok、Hulu、Nike、Uber、Elastic 等顶级公司用于生产。如果你感兴趣，可以阅读完整的列表，网址为
    https://nextjs.org/showcase。
- en: Next.js showed how versatile React could be for building many different applications
    at any scale, and it's not surprising to see it in use by both big companies and
    small start-ups. By the way, it is not the only framework that lets you render
    JavaScript on the server side, as we'll see in the next section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 展示了 React 在构建任何规模的不同应用时的多功能性，它被大公司和小型初创公司使用并不令人惊讶。顺便说一下，它并不是唯一允许你在服务器端渲染
    JavaScript 的框架，正如我们将在下一节中看到的。
- en: Comparing Next.js to other alternatives
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Next.js 与其他替代方案进行比较
- en: As you may be wondering, Next.js is not the only player in the server-side rendered
    JavaScript world. However, alternatives might be considered depending on the final
    purpose of a project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，Next.js 并不是服务器端渲染 JavaScript 世界中的唯一玩家。然而，根据项目的最终目的，可能会考虑其他替代方案。
- en: Gatsby
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gatsby
- en: One popular alternative is Gatsby. You may want to consider this framework if
    you seek to build static websites. Unlike Next.js, Gatsby only supports static
    site generation and does it incredibly well. Every page is pre-rendered at build
    time and can be served on any **Content Delivery Network** (**CDN**) as a static
    asset, allowing the performance to be incredibly competitive compared to dynamically
    server-side rendered alternatives. The biggest downside of using Gatsby over Next.js
    is that you'll lose the ability of dynamic server-side rendering, which is an
    important feature for building more dynamically data-driven and complex websites.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的替代方案是 Gatsby。如果你想要构建静态网站，你可能需要考虑这个框架。与 Next.js 不同，Gatsby 只支持静态网站生成，并且做得非常出色。每个页面在构建时都会预先渲染，并且可以作为静态资源在任何
    **内容分发网络** (**CDN**) 上提供服务，这使得性能与动态服务器端渲染的替代方案相比具有极高的竞争力。使用 Gatsby 而不是 Next.js
    的最大缺点是，你将失去动态服务器端渲染的能力，这对于构建更动态、数据驱动和复杂的网站来说是一个重要的功能。
- en: Razzle
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Razzle
- en: Less popular than Next.js, Razzle is a tool for creating server-side rendered
    JavaScript applications. It aims to maintain the ease of use of `create-react-app`
    while abstracting all the complex configurations needed for rendering the application
    both on the server and client sides. The most significant advantage of using Razzle
    instead of Next.js (or the following alternatives) is that it is framework agnostic.
    You can choose your favorite frontend framework (or language), such as React,
    Vue, Angular, Elm, or Reason-React… it's your choice.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 相比 Next.js，Razzle 的知名度较低，它是一个用于创建服务器端渲染 JavaScript 应用的工具。它的目标是保持 `create-react-app`
    的易用性，同时抽象出在服务器和客户端渲染应用所需的所有复杂配置。使用 Razzle 而不是 Next.js（或以下替代方案）的最显著优势是它不依赖于任何框架。你可以选择你喜欢的前端框架（或语言），例如
    React、Vue、Angular、Elm 或 Reason-React…由你选择。
- en: Nuxt.js
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nuxt.js
- en: If you have experience with Vue, then Nuxt.js can be a valid Next.js competitor.
    They both offer support for server-side rendering, static site generation, progressive
    web app management, and so on, with no significant differences regarding performance,
    SEO, or development speed. While Nuxt.js and Next.js serve the same purpose, Nuxt.js
    needs more configuration, which is sometimes not a bad thing. In your Nuxt.js
    configuration file, you can define layouts, global plugins and components, routes,
    and so on, while with Next.js, you need to do it *the React way*. Apart from that,
    they share many functionalities, but the most significant difference is the library
    underneath. That said, if you already have a Vue component library, you could
    consider Nuxt.js for server-side rendering it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Vue，那么 Nuxt.js 可以成为 Next.js 的一个有效竞争对手。它们都提供了服务器端渲染、静态网站生成、渐进式Web应用管理等功能，在性能、SEO
    或开发速度方面没有显著差异。虽然 Nuxt.js 和 Next.js 都服务于相同的目的，但 Nuxt.js 需要更多的配置，这有时并不是一件坏事。在你的
    Nuxt.js 配置文件中，你可以定义布局、全局插件和组件、路由等，而使用 Next.js，你需要按照 *React 方式* 来做。除此之外，它们共享许多功能，但最显著的区别是底层的库。也就是说，如果你已经有一个
    Vue 组件库，你可以考虑使用 Nuxt.js 来进行服务器端渲染。
- en: Angular Universal
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular Universal
- en: 'Of course, Angular has also made its move to the JavaScript server-side rendering
    scene, and it proposes Angular Universal as an official way for server-side rendering
    Angular applications. It supports both static site generation and server-side
    rendering and, unlike Nuxt.js and Next.js, it was developed by one of the biggest
    companies out there: Google. So if you are into Angular development and already
    have some components written with that library, Angular Universal can be a natural
    alternative to Nuxt.js, Next.js, and other similar frameworks.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Angular 也已经进入了 JavaScript 服务器端渲染的领域，并提出了 Angular Universal 作为官方的 Angular
    应用服务器端渲染方式。它支持静态网站生成和服务器端渲染，与 Nuxt.js 和 Next.js 不同，它是由世界上最大的公司之一 Google 开发的。所以如果你从事
    Angular 开发并且已经使用该库编写了一些组件，Angular Universal 可以是 Nuxt.js、Next.js 和其他类似框架的自然替代方案。
- en: So, why Next.js?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么，为什么选择 Next.js 呢？
- en: We've now seen some popular alternatives to Next.js, and their strengths and
    weaknesses.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了一些 Next.js 的流行替代方案，以及它们的优缺点。
- en: The main reason why I'd suggest using Next.js instead of any other framework
    is because of its incredible feature set. With Next.js, you get everything you
    need right out of the box, and I'm not only referring to components, configurations,
    and deployment options, although they're probably the most complete I've ever
    seen.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用 Next.js 而不是其他任何框架的主要原因是因为它令人难以置信的功能集。使用 Next.js，你将获得所有你需要的东西，直接从盒子里出来，我不仅指的是组件、配置和部署选项，尽管它们可能是我所见过的最完整的。
- en: In addition, Next.js has an incredibly welcoming and active community ready
    to support you at every step you take in building your application. I would consider
    this as a huge bonus point, because as soon as you have a problem with your code
    base, you'll be able to get help from the massive community across many different
    platforms, including StackOverflow and GitHub, where the Vercel team is also often
    involved in discussions and support requests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Next.js 拥有一个非常友好和活跃的社区，随时准备在你构建应用程序的每一步提供支持。我会把这看作是一个巨大的加分项，因为一旦你在代码库中遇到问题，你将能够从遍布许多不同平台的庞大社区中获得帮助，包括
    StackOverflow 和 GitHub，Vercel 团队也经常参与讨论和支持请求。
- en: Now that you know how Next.js competes with other similar frameworks, let's
    see the main differences between a default client-side React app and a fully-featured
    server-side environment for rendering your JavaScript code base dynamically for
    each request, and statically at build time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了 Next.js 如何与其他类似框架竞争，让我们看看默认客户端 React 应用程序和具有完整功能的用于动态渲染你的 JavaScript
    代码库的每个请求以及构建时的静态环境的区别。
- en: Moving from React to Next.js
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 React 迁移到 Next.js
- en: If you already have some experience with React, you'll find it incredibly easy
    to build your first Next.js website. Its philosophy is very close to React and
    provides a *convention-over-configuration* approach for most of its settings,
    so if you want to take advantage of a specific Next.js feature, you'll easily
    find the official way for doing it without any need for complex configurations.
    An example? In a single Next.js app, you can specify which pages shall be server-side
    rendered and which shall be statically generated at build time without the need
    to write any configuration files or anything like that. You just have to export
    a specific function from your page and let Next.js do its magic (we'll see that
    in [*Chapter 2*](B16985_02_Final_SB_epub.xhtml#_idTextAnchor029)*, Exploring Different
    Rendering Strategies*).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一些 React 的经验，你会发现构建你的第一个 Next.js 网站非常容易。它的哲学与 React 非常接近，并为大多数设置提供了一种
    *约定优于配置* 的方法，所以如果你想利用特定的 Next.js 功能，你将很容易找到官方的做法来做，而不需要任何复杂的配置。一个例子？在一个 Next.js
    应用中，你可以在构建时指定哪些页面应该进行服务器端渲染，哪些应该进行静态生成，而不需要编写任何配置文件或其他类似的东西。你只需要从你的页面导出一个特定的函数，让
    Next.js 做它的魔法（我们将在 [*第 2 章*](B16985_02_Final_SB_epub.xhtml#_idTextAnchor029)*，探索不同的渲染策略*中看到）。
- en: The most significant difference between React and Next.js is that while React
    is just a JavaScript library, Next.js is a framework for building rich and complete
    user experiences both on the client and server sides, adding tons of incredibly
    useful features. Every server-side rendered or statically generated page will
    run on Node.js, so you'll lose access to some browser-specific global objects,
    such as `fetch`, `window`, and `document`, as well as some HTML elements such
    as `canvas`. You will always need to keep that in mind when you're writing your
    Next.js pages, even if the framework provides its own way for dealing with components
    that *must* use such global variables and HTML elements, as we'll see in[*Chapter
    2*](B16985_02_Final_SB_epub.xhtml#_idTextAnchor029)*, Exploring Different Rendering
    Strategies*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: React 和 Next.js 之间最显著的区别在于，虽然 React 只是一个 JavaScript 库，但 Next.js 是一个用于在客户端和服务器端构建丰富和完整用户体验的框架，增加了大量极其有用的功能。每个服务器端渲染或静态生成的页面都将运行在
    Node.js 上，因此你将失去访问一些浏览器特定的全局对象，例如 `fetch`、`window` 和 `document`，以及一些 HTML 元素，如
    `canvas`。当你编写 Next.js 页面时，你始终需要记住这一点，即使框架提供了处理必须使用此类全局变量和 HTML 元素的组件的自己的方式，正如我们将在[*第
    2 章*](B16985_02_Final_SB_epub.xhtml#_idTextAnchor029)*，探索不同的渲染策略*中看到的那样。
- en: On the other hand, there might be times when you want to use Node.js specific
    libraries or APIs, such as `fs` or `child_process`, and Next.js allows you to
    use them by running your server-side code on each request or at build time (depending
    on how you choose to render your pages) before sending the data to the client.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，可能会有时候你想使用Node.js特定的库或API，例如`fs`或`child_process`，Next.js允许你在将数据发送到客户端之前，通过在每个请求或构建时间（取决于你如何选择渲染你的页面）运行你的服务器端代码来使用它们。
- en: But even if you want to create a client-side rendered app, Next.js can be a
    great alternative to the well-known `create-react-app`. Next.js, in fact, can
    be used as a framework for writing progressive and offline-first web apps with
    ease, taking advantage of its incredible built-in components and optimizations.
    So let's get started with Next.js.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你想创建一个客户端渲染的应用程序，Next.js也可以成为知名`create-react-app`的一个很好的替代品。实际上，Next.js可以轻松地用作编写渐进式和离线优先Web应用的框架，利用其惊人的内置组件和优化。那么，让我们开始使用Next.js吧。
- en: Getting started with Next.js
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Next.js
- en: Now that we have some basic knowledge about Next.js use cases and the differences
    between client-side React and other frameworks, it's time to look at the code.
    We'll start by creating a new Next.js app and customizing its default webpack
    and Babel configurations. We'll also see how to use TypeScript as the primary
    language for developing Next.js apps.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Next.js的使用案例和客户端React与其他框架之间的区别有了基本的了解，是时候看看代码了。我们将从创建一个新的Next.js应用并自定义其默认webpack和Babel配置开始。我们还将了解如何将TypeScript作为开发Next.js应用的主要语言。
- en: Default project structure
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认项目结构
- en: 'Getting started with Next.js is incredibly easy. The only system requirement
    is to have both Node.js and `npm` installed on your machine (or development environment).
    The Vercel team created and published a straightforward but powerful tool called
    `create-next-app` for generating the boilerplate code for a basic Next.js app.
    You can use it by typing the following command in the terminal:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用Next.js极其简单。唯一的要求是在你的机器（或开发环境）上安装Node.js和`npm`。Vercel团队创建并发布了一个简单但强大的工具，名为`create-next-app`，用于生成基本Next.js应用的脚手架代码。你可以在终端中输入以下命令来使用它：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It will install all the required dependencies and create a couple of default
    pages. At this point, you can just run `npm run dev`, and a development server
    will start on port `3000`, showing a landing page.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它将安装所有所需的依赖项并创建几个默认页面。此时，你只需运行`npm run dev`，开发服务器就会在端口`3000`上启动，显示一个着陆页。
- en: 'Next.js will initialize your project using the Yarn package manager if installed
    on your machine. You can override this option by passing a flag to tell `create-next-app`
    to use `npm` instead:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的机器上安装了Yarn包管理器，Next.js将使用Yarn初始化你的项目。你可以通过传递一个标志来覆盖此选项，告诉`create-next-app`使用`npm`：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can also ask `create-next-app` to initialize a new Next.js project by downloading
    the boilerplate code from the Next.js GitHub repository. In fact, inside the Next.js
    repository, there's an `examples` folder containing tons of great examples about
    how to use Next.js with different technologies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以要求`create-next-app`通过从Next.js GitHub仓库下载脚手架代码来初始化一个新的Next.js项目。实际上，在Next.js仓库中有一个`examples`文件夹，里面包含大量关于如何使用Next.js与不同技术结合的精彩示例。
- en: 'Let''s say that you want to do some experiments with using Next.js on Docker
    – you can just pass the `--example` flag to the boilerplate code generator:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在Docker上使用Next.js做一些实验——你只需将`--example`标志传递给脚手架代码生成器：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`create-next-app` will download the code from [https://github.com/vercel/next.js/tree/canary/examples/with-docker](https://github.com/vercel/next.js/tree/canary/examples/with-docker)
    and will install the required dependencies for you. At this point, you only have
    to edit the downloaded files, customize them, and you''re ready to go.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-next-app`将从[https://github.com/vercel/next.js/tree/canary/examples/with-docker](https://github.com/vercel/next.js/tree/canary/examples/with-docker)下载代码，并为你安装所需的依赖项。此时，你只需编辑下载的文件，进行定制，就可以开始了。'
- en: You can find other great examples at https://github.com/vercel/next.js/tree/canary/examples.
    If you're already familiar with Next.js, feel free to explore how Next.js can
    integrate with different services and toolkits (we'll see some of them in more
    detail later on in this book).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在https://github.com/vercel/next.js/tree/canary/examples找到其他精彩示例。如果你已经熟悉Next.js，请随意探索Next.js如何与不同的服务和工具包集成（我们将在本书的后续部分更详细地介绍一些）。
- en: 'Now, let''s go back to a default `create-next-app` installation for a moment.
    Let''s open the terminal and generate a new Next.js app together:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们暂时回到默认的 `create-next-app` 安装。让我们打开终端，一起生成一个新的 Next.js 应用程序：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After a few seconds, the boilerplate generation will succeed, and you''ll find
    a new folder called `my-first-next-app` with the following structure:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，模板生成将成功完成，你将找到一个名为 `my-first-next-app` 的新文件夹，其结构如下：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you're coming from React, you may be used to `pages/` folder. In fact, every
    JavaScript file inside the `pages/` directory will be a public page, so if you
    try to duplicate the `index.js` page and rename it `about.js`, you'll be able
    to go to `http://localhost:3000/about` and see an exact copy of your home page.
    We'll look in detail how Next.js handles client-side and server-side routes in
    the next chapter; for now, let's just think of the `pages/` directory as a container
    for your public pages.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自 React，你可能已经习惯了 `pages/` 目录。实际上，`pages/` 目录中的每个 JavaScript 文件都将是一个公开页面，所以如果你尝试复制
    `index.js` 页面并将其重命名为 `about.js`，你将能够访问 `http://localhost:3000/about` 并看到你主页的精确副本。我们将在下一章详细探讨
    Next.js 如何处理客户端和服务器端路由；现在，让我们只是把 `pages/` 目录看作是公开页面的容器。
- en: The `public/` folder contains all the public and static assets used in your
    website. For example, you can put your images, compiled CSS stylesheets, compiled
    JavaScript files, fonts, and so on there.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`public/` 文件夹包含你网站中使用的所有公开和静态资产。例如，你可以将你的图片、编译后的 CSS 样式表、编译后的 JavaScript 文件、字体等放在那里。'
- en: By default, you will also see a `styles/` directory; while this is very useful
    for organizing your application stylesheets, it is not strictly required for a
    Next.js project. The only mandatory and reserved directories are `public/` and
    `pages/`, so make sure not to delete or use them for different purposes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，你还会看到一个 `styles/` 目录；虽然这对于组织你的应用程序样式表非常有用，但对于 Next.js 项目来说并不是严格必需的。唯一必需且保留的目录是
    `public/` 和 `pages/`，所以请确保不要删除或用于其他目的。
- en: That said, you're free to add more directories and files to the project root,
    as it won't negatively interfere with the Next.js build or development process.
    If you want to organize your components under a `components/` directory and your
    utilities under a `utilities/` directory, feel free to add those folders inside
    your project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你可以在项目根目录中自由添加更多目录和文件，因为它不会对 Next.js 的构建或开发过程产生负面影响。如果你想将组件组织在 `components/`
    目录下，将实用工具组织在 `utilities/` 目录下，请随意在你的项目中添加这些文件夹。
- en: If you're not into boilerplate generators, you can bootstrap a new Next.js application
    by just adding all the required dependencies (as previously listed) and the basic
    folder structure that we just saw to your existing React application, and it'll
    just work with no other configuration required.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢模板生成器，你可以通过添加所有必需的依赖（如之前所列）以及我们刚刚看到的基目录结构到现有的 React 应用程序中，来启动一个新的 Next.js
    应用程序，这样它就可以直接工作，无需其他配置。
- en: TypeScript integration
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript 集成
- en: 'The Next.js source code is written in TypeScript and natively provides high-quality
    `tsconfig.json`) inside the root of your project. If you try to run `npm run dev`,
    you''ll see the following output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 的源代码是用 TypeScript 编写的，并在项目根目录中提供了高质量的 `tsconfig.json`。如果你尝试运行 `npm run
    dev`，你会看到以下输出：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, Next.js has correctly detected that you're trying to use TypeScript
    and asks you to install all the required dependencies for using it as the primary
    language for your project. So now you just have to convert your JavaScript files
    to TypeScript, and you're ready to go.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Next.js 已经正确地检测到你正在尝试使用 TypeScript，并要求你安装所有作为项目主要语言所需依赖。因此，你现在只需将你的 JavaScript
    文件转换为 TypeScript，就可以开始使用了。
- en: 'You may notice that even if you created an empty `tsconfig.json` file, after
    installing the required dependencies and rerunning the project, Next.js fills
    it with its default configurations. Of course, you can always customize the TypeScript
    options inside that file, but keep in mind that Next.js uses Babel to handle TypeScript
    files (via the `@babel/plugin-transform-typescript`), and it has some caveats,
    including the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，即使你创建了一个空的 `tsconfig.json` 文件，在安装了必需的依赖并重新运行项目后，Next.js 也会用它的默认配置填充它。当然，你总是可以自定义该文件中的
    TypeScript 选项，但请记住，Next.js 使用 Babel 来处理 TypeScript 文件（通过 `@babel/plugin-transform-typescript`），并且有一些注意事项，包括以下内容：
- en: The `@babel/plugin-transform-typescript` plugin does not support `const enum`,
    often used in TypeScript. To support it, make sure to add `babel-plugin-const-enum`
    to the Babel configuration (we'll see how in the *Custom Babel and webpack configuration*
    section).
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@babel/plugin-transform-typescript` 插件不支持 TypeScript 中常用的 `const enum`，为了支持它，请确保将
    `babel-plugin-const-enum` 添加到 Babel 配置中（我们将在 *自定义 Babel 和 webpack 配置* 部分看到如何操作）。'
- en: Neither `export =` nor `import =` are supported because they cannot be compiled
    to valid ECMAScript code. You should either install `babel-plugin-replace-ts-export-assignment`,
    or convert your imports and exports to valid ECMAScript directives, such as `import
    x, {y} from 'some-package'` and `export default x`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 既不支持 `export =` 也不支持 `import =`，因为它们无法编译成有效的 ECMAScript 代码。你应该安装 `babel-plugin-replace-ts-export-assignment`，或者将你的导入和导出转换为有效的
    ECMAScript 指令，例如 `import x, {y} from 'some-package'` 和 `export default x`。
- en: 'There are other caveats, too; I''d suggest you read them before going further
    with using TypeScript as the main language for developing your Next.js app: [https://babeljs.io/docs/en/babel-plugin-transform-typescript#caveats](https://babeljs.io/docs/en/babel-plugin-transform-typescript#caveats).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他注意事项，我建议你在进一步使用 TypeScript 作为 Next.js 应用程序的主要开发语言之前阅读它们：[https://babeljs.io/docs/en/babel-plugin-transform-typescript#caveats](https://babeljs.io/docs/en/babel-plugin-transform-typescript#caveats)。
- en: 'Also, some compiler options might be a bit different from the default TypeScript
    ones; once again, I''d suggest you read the official Babel documentation, which
    will always be up to date: [https://babeljs.io/docs/en/babel-plugin-transform-typescript#typescript-compiler-options](https://babeljs.io/docs/en/babel-plugin-transform-typescript#typescript-compiler-options).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些编译器选项可能与默认的 TypeScript 选项略有不同；再次建议你阅读官方的 Babel 文档，它将始终是最新的：[https://babeljs.io/docs/en/babel-plugin-transform-typescript#typescript-compiler-options](https://babeljs.io/docs/en/babel-plugin-transform-typescript#typescript-compiler-options)。
- en: Next.js also creates a `next-env.d.ts` file inside the root of your project;
    feel free to edit it if you need, but make sure not to delete it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 还会在你的项目根目录下创建一个 `next-env.d.ts` 文件；如果你需要，可以自由编辑它，但请确保不要删除它。
- en: Custom Babel and webpack configuration
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 Babel 和 webpack 配置
- en: As already mentioned in the *TypeScript Integration* section, we can customize
    **Babel** and **webpack** configurations.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在 *TypeScript 集成* 部分已提到的，我们可以自定义 **Babel** 和 **webpack** 配置。
- en: There might be many reasons we would like to customize our Babel configuration.
    If you're not very familiar with it, let me quickly explain what I'm talking about.
    Babel is a JavaScript transcompiler mainly used for transforming modern JavaScript
    code into a backward-compatible script, which will run without problem on any
    browser.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有很多原因想要自定义 Babel 配置。如果你不太熟悉它，让我快速解释一下我在说什么。Babel 是一个 JavaScript 转换编译器，主要用于将现代
    JavaScript 代码转换为向后兼容的脚本，这样它就可以在任何浏览器上无问题地运行。
- en: If you're writing a web app that *must* support older browsers such as **Internet
    Explorer** (**IE**) 10 or Internet Explorer 11, Babel will help you a lot. It
    allows you to use modern ES6/ESNext features and will transform them into IE-compatible
    code at build time, letting you maintain a beautiful developer experience with
    very few compromises.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写一个必须支持旧版浏览器（如 **Internet Explorer** （**IE**）10 或 Internet Explorer 11）的
    Web 应用程序，Babel 会对你有很大帮助。它允许你使用现代 ES6/ESNext 功能，并在构建时将它们转换为与 IE 兼容的代码，让你在几乎不妥协的情况下保持良好的开发者体验。
- en: Also, the JavaScript language (standardized under the ECMAScript specification)
    is quickly evolving. So while some fantastic features have already been announced,
    you'll have to wait for years before being able to use them in both browsers and
    Node.js environments. That's because after the ECMA committee has accepted these
    features, the companies developing web browsers and communities working on the
    Node.js project will have to plan a roadmap for adding support for these enhancements.
    Babel solves this problem by transpiling modern code into a compatible script
    for today's environments.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JavaScript 语言（在 ECMAScript 规范下标准化）正在快速发展。因此，尽管一些出色的功能已经宣布，但你可能需要等待数年才能在浏览器和
    Node.js 环境中使用它们。这是因为 ECMA 委员会接受这些功能后，开发 Web 浏览器的公司和在 Node.js 项目上工作的社区必须制定一个路线图，以添加对这些增强功能的支持。Babel
    通过将现代代码转换为适用于今天环境的兼容脚本来解决此问题。
- en: 'For example, you may be familiar with this code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能熟悉以下代码：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But if you try to run it in Node.js, it will throw a syntax error because the
    JavaScript engine won't recognize the `export default` keywords.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您尝试在 Node.js 中运行它，它将抛出一个语法错误，因为 JavaScript 引擎不会识别 `export default` 关键字。
- en: 'Babel will transform the preceding code into this equivalent ECMAScript code,
    at least until Node.js gets support for the `export default` syntax:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 将将前面的代码转换为等效的 ECMAScript 代码，至少直到 Node.js 支持 `export default` 语法：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This makes it possible to run this code on Node.js with no problems.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在 Node.js 上运行此代码没有任何问题。
- en: 'You can customize your default Next.js Babel configuration by simply creating
    a new file called `.babelrc` inside the root of your project. You will notice
    that if you leave it empty, the Next.js build/development process will throw an
    error, so make sure to add at least the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在项目根目录下创建一个名为 `.babelrc` 的新文件来自定义 Next.js 的默认 Babel 配置。您会注意到，如果您将其留空，Next.js
    的构建/开发过程将抛出错误，因此请确保至少添加以下代码：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the Babel preset created by the Vercel team specifically for building
    and developing Next.js applications. Let''s say that we''re building an application,
    and we want to use an experimental ECMAScript feature such as the pipeline operator;
    if you''re not familiar with it, it basically allows you to re-write this code
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Vercel 团队专门为构建和开发 Next.js 应用程序而创建的 Babel 预设。假设我们正在构建一个应用程序，并且我们想使用实验性的 ECMAScript
    功能，例如管道操作符；如果您不熟悉它，它基本上允许您将此代码重写如下：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This operator has not been officially accepted yet by **TC39** (the technical
    committee behind the ECMAScript specification), but you can start using it today,
    thanks to Babel.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作符尚未被 **TC39**（ECMAScript 规范背后的技术委员会）官方接受，但您可以通过 Babel 开始使用它。
- en: 'To provide support for this operator in your Next.js app, all you need to do
    is install the Babel plugin using `npm`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的 Next.js 应用中提供对这个操作符的支持，您只需要使用 `npm` 安装 Babel 插件：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then update your custom `.babelrc` file as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下方式更新您的自定义 `.babelrc` 文件：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can now restart your development server and use this experimental feature.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以重新启动开发服务器并使用这个实验性功能。
- en: If you're interested in using TypeScript as the main development language for
    your Next.js app, you can just follow the same procedure for adding all the TypeScript-specific
    plugins to your Babel configuration. There are chances that during your Next.js
    development experience, you may also want to customize the default webpack configuration.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣将 TypeScript 作为 Next.js 应用的主要开发语言，您可以遵循相同的步骤将所有 TypeScript 特定插件添加到您的 Babel
    配置中。在您的 Next.js 开发过程中，您可能还希望自定义默认的 webpack 配置。
- en: While Babel only takes modern code as input and produces backward-compatible
    scripts as output, webpack creates the bundles containing all the compiled code
    for a specific library, page, or feature. For instance, if you create a page containing
    three components from three different libraries, webpack will merge everything
    into a single bundle to be shipped to the client. To put it simply, we can think
    of webpack as an infrastructure for orchestrating different compilation, bundle,
    and minification tasks for every web asset (JavaScript files, CSS, SVG, and so
    on).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Babel 只接受现代代码作为输入并生成向后兼容的脚本作为输出，但 webpack 会创建包含特定库、页面或功能的编译代码的包。例如，如果您创建了一个包含来自三个不同库的三个组件的页面，webpack
    将将所有内容合并成一个单独的包发送到客户端。简单来说，我们可以将 webpack 视为为每个网络资源（JavaScript 文件、CSS、SVG 等）的不同编译、打包和压缩任务进行编排的基础设施。
- en: If you want to use CSS preprocessors such as **SASS** or **LESS** to create
    your app styles, you will need to customize the default webpack configuration
    to parse **SASS**/**LESS** files and produce plain CSS as output. The same, of
    course, occurs for JavaScript code using Babel as a transpiler.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用 **SASS** 或 **LESS** 等 CSS 预处理器来创建您的应用程序样式，您需要自定义默认的 webpack 配置以解析 **SASS**/**LESS**
    文件并生成纯 CSS 作为输出。当然，对于使用 Babel 作为转换器的 JavaScript 代码也是如此。
- en: We talk more in detail about CSS preprocessors in the following chapters, but
    for now, we just need to keep in mind that Next.js provides an easy way for customizing
    the default webpack configuration.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中更详细地讨论 CSS 预处理器，但就目前而言，我们只需要记住 Next.js 提供了一种简单的方式来自定义默认的 webpack 配置。
- en: As we saw earlier, Next.js provides a *convention-over-configuration* approach,
    so you don't need to customize most of its settings for building a real-world
    application; you just have to follow some code conventions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，Next.js提供了一种基于约定的配置方法，因此你不需要为构建实际应用而自定义其大部分设置；你只需遵循一些代码约定即可。
- en: 'But if you really need to build something custom, you''ll be able to edit the
    default settings via the `next.config.js` file most of the time. You can create
    this file inside the root of your project. It should export an object by default,
    where its properties will override the default Next.js configurations:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你真的需要构建一些自定义的东西，你通常可以通过编辑`next.config.js`文件来修改默认设置。你可以在项目的根目录下创建这个文件。默认情况下，它应该导出一个对象，其中它的属性将覆盖Next.js的默认配置：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can customize the default webpack configuration by creating a new property
    inside this object called `webpack`. Let''s suppose that we want to add a new
    imaginary webpack loader called `my-custom-loader`; we can proceed as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在这个对象中创建一个新的属性来自定义默认的webpack配置，称为`webpack`。假设我们想要添加一个名为`my-custom-loader`的新虚拟webpack加载器；我们可以按照以下步骤进行：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, as you can see, we're writing a proper webpack configuration that will later
    be merged with Next.js' default settings. This will allow us to extend, override,
    or even delete any setting from the default configuration, as although deleting
    default settings is generally never a good idea, there might be cases where you
    need it (if you're brave enough!).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如你所见，我们正在编写一个合适的webpack配置，稍后它将与Next.js的默认设置合并。这将允许我们扩展、覆盖或甚至删除默认配置中的任何设置，尽管删除默认设置通常不是一个好主意，但在某些情况下你可能需要这样做（如果你足够勇敢的话！）。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have seen the main differences between default and client-side
    React apps and Next.js, and how Next.js compares with other well-known alternatives.
    You've also learned how to customize a default Next.js project by editing the
    Babel and webpack configurations, as well as adding TypeScript as an alternative
    to JavaScript for developing your applications.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经看到了默认和客户端React应用以及Next.js之间的主要区别，以及Next.js与其他知名替代方案的比较。你还学习了如何通过编辑Babel和webpack配置以及添加TypeScript作为JavaScript的替代品来定制默认的Next.js项目。
- en: 'In the next chapter, we will take a closer look at three different rendering
    strategies: client-side rendering, server-side rendering, and static site generation.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地探讨三种不同的渲染策略：客户端渲染、服务器端渲染和静态站点生成。
