<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer030">
<h1 class="chapter-number" id="_idParaDest-157"><a id="_idTextAnchor159"/>9</h1>
<h1 id="_idParaDest-158"><a id="_idTextAnchor160"/>Form Validation</h1>
<p>For many programmers, TDD makes sense when it involves <em class="italic">toy</em> programs that they learn in a training environment. But they find it hard to join the dots when they are faced with the complexity of <em class="italic">real-world</em> programs. The purpose of this part of this book is for you to apply the techniques you’ve learned to real-world applications.</p>
<p>This chapter takes a somewhat self-indulgent journey<a id="_idIndexMarker881"/> into form validation. Normally, with React, you’d reach for a ready-made form library that handles validation for you. But in this chapter, we’ll hand-craft our own validation logic, as an example of how real-world complexity can be conquered with TDD.</p>
<p>You will uncover an important architectural principle when dealing with frameworks such as React: take every opportunity to move logic out of framework-controlled components and into plain JavaScript objects.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Performing client-side validation</li>
<li>Handling server errors</li>
<li>Indicating form submission status</li>
</ul>
<p>By the end of the chapter, you’ll have seen how tests can be used to introduce validation into your React forms.<a id="_idTextAnchor161"/></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor162"/>Technical requirements</h1>
<p>The code files for this chapter can be found here: </p>
<p><a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter09">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter09</a></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor163"/>Performing client-side validation</h1>
<p>In this <a id="_idIndexMarker882"/>section, we’ll update the <strong class="source-inline">CustomerForm</strong> and <strong class="source-inline">AppointmentForm</strong> components so that they alert the user to any issues with the text they’ve entered. For example, if they enter non-digit characters into the phone number field, the application will display an error.</p>
<p>We’ll listen for<a id="_idIndexMarker883"/> the DOM’s <strong class="source-inline">blur</strong> event on each field to take the current field value and run our validation rules on it.</p>
<p>Any validation errors will be stored as strings, such as <strong class="source-inline">First name is required</strong>,  within a <strong class="source-inline">validationErrors</strong> state variable. Each field has a key in this object. An undefined value (or absence of a value) represents no validation error, and a string value represents an error. Here’s an example:</p>
<pre class="source-code">
{
  firstName: "First name is required",
  lastName: undefined,
  phoneNumber: "Phone number must contain only numbers, spaces, and any of the following: + - ( ) ."
}</pre>
<p>This error is rendered in the browser like this:</p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<img alt="Figure 9.1 – Validation errors displayed to the user " height="306" src="image/Figure_9.01_B18423.jpg" width="812"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Validation errors displayed to the user</p>
<p>To support tests that manipulate the keyboard focus, we need a new function that simulates the <strong class="source-inline">focus</strong> and <strong class="source-inline">blur</strong> events being raised when the user completes a field value. We’ll call this <a id="_idIndexMarker884"/>function <strong class="source-inline">withFocus</strong>. It wraps a test-supplied action (such as changing<a id="_idIndexMarker885"/> the<a id="_idIndexMarker886"/> field value) with the <strong class="source-inline">focus</strong>/<strong class="source-inline">blur</strong> events.</p>
<p>This section will start by checking that the <strong class="source-inline">CustomerForm</strong> first name field is supplied. Then, we’ll generalize that validation so that it works for all three fields in the form. After that, we’ll <a id="_idIndexMarker887"/>ensure validation also runs when the submit button is pressed. Finally, we’ll extract all the logic we’ve built into a separate module.</p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor164"/>Validating a required field</h2>
<p>Each of the <a id="_idIndexMarker888"/>three fields on our page – <strong class="source-inline">firstName</strong>, <strong class="source-inline">lastName</strong>, and <strong class="source-inline">phoneNumber</strong> – are required fields. If a value hasn’t been provided for any of the fields, the user should see a message telling them that. To do that, each of the fields will have an alert message area, implemented <a id="_idIndexMarker889"/>as a <strong class="source-inline">span</strong> with an ARIA role of <strong class="source-inline">alert</strong>.</p>
<p>Let’s begin by adding that alert for the <strong class="source-inline">firstName</strong> field, and then making it operational by validating the field when the user removes focus:</p>
<ol>
<li>Add the following new test to the bottom of the <strong class="source-inline">CustomerForm</strong> test suite. It should be within a new nested <strong class="source-inline">describe</strong> block named <strong class="source-inline">validation</strong>. This test checks that an alert space has been rendered. Notice the CSS selector: it’s a bit of a hack. We’re primarily interested in finding an element that matches <strong class="source-inline">[role=alert]</strong>. However, we are also qualifying it with the <strong class="source-inline">firstNameError</strong> ID since we’ll eventually have multiple alert spaces – one for each field:<p class="source-code">describe("validation", () =&gt; {</p><p class="source-code">  it("renders an alert space for first name validation errors", () =&gt; {</p><p class="source-code">    render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">    expect(</p><p class="source-code">      element("#firstNameError[role=alert]")</p><p class="source-code">    ).not.toBeNull();</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>To make that pass, move to <strong class="source-inline">src/CustomerForm.js</strong> and add the following <strong class="source-inline">span</strong> definition, just<a id="_idIndexMarker890"/> below the <strong class="source-inline">firstName</strong> input field:<p class="source-code">&lt;input</p><p class="source-code">  type="text"</p><p class="source-code">  name="firstName"</p><p class="source-code">  id="firstName"</p><p class="source-code">  value={customer.firstName}</p><p class="source-code">  onChange={handleChange}</p><p class="source-code">/&gt;</p><p class="source-code"><strong class="bold">&lt;span id="firstNameError" role="alert" /&gt;</strong></p></li>
<li>Next, we <a id="_idIndexMarker891"/>want to check that the<a id="_idIndexMarker892"/> field has an <strong class="source-inline">aria-describedby</strong> field that points to the error alert. This helps screen readers understand the content of the page. Add the following new test at the bottom of the test suite:<p class="source-code">it("sets alert as the accessible description for the first name field", async () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">  expect(</p><p class="source-code">    field(</p><p class="source-code">      "firstName"</p><p class="source-code">    ).getAttribute("aria-describedby")</p><p class="source-code">  ).toEqual("firstNameError");</p><p class="source-code">});</p></li>
<li>To make that pass, add the <strong class="source-inline">aria-describedby</strong> attribute to the <strong class="source-inline">firstName</strong> field<a id="_idIndexMarker893"/> definition:<p class="source-code">&lt;input</p><p class="source-code">  type="text"</p><p class="source-code">  name="firstName"</p><p class="source-code">  id="firstName"</p><p class="source-code">  value={customer.firstName}</p><p class="source-code">  onChange={handleChange}</p><p class="source-code"><strong class="bold">  aria-describedby="firstNameError"</strong></p><p class="source-code">/&gt;</p></li>
<li>The next test <a id="_idIndexMarker894"/>we’ll write will use the blur DOM event to trigger validation. For this test, we’ll start by building a new test <a id="_idIndexMarker895"/>extension, <strong class="source-inline">withFocus</strong>, which <a id="_idIndexMarker896"/>calls<a id="_idIndexMarker897"/> the <strong class="source-inline">focus</strong> event to ensure the target element has focus, then runs an action – such as entering text into the focused field – and ends by invoking the <strong class="source-inline">blur</strong> event. In <strong class="source-inline">test/reactTestExtensions.js</strong>, add the following definition for the <strong class="source-inline">withFocus</strong> function:<p class="source-code">export const withFocus = (target, fn) =&gt;</p><p class="source-code">  act(() =&gt; {</p><p class="source-code">    target.focus();</p><p class="source-code">    fn();</p><p class="source-code">    target.blur();</p><p class="source-code">  });</p></li>
</ol>
<p class="callout-heading">The focus and blur sequence</p>
<p class="callout">The initial <a id="_idIndexMarker898"/>call to <strong class="source-inline">focus</strong> is needed because <a id="_idIndexMarker899"/>if the element isn’t focused, JSDOM will think that <strong class="source-inline">blur</strong> has nothing to do.</p>
<ol>
<li value="6">In <strong class="source-inline">test/CustomerForm.test.js</strong>, import the new <strong class="source-inline">withFocus</strong> function:<p class="source-code">import {</p><p class="source-code">  ...,</p><p class="source-code"><strong class="bold">  withFocus,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Add the following <a id="_idIndexMarker900"/>new test at the bottom of the test<a id="_idIndexMarker901"/> suite (still inside the <strong class="source-inline">validation</strong> nested <strong class="source-inline">describe</strong> block). It checks that if the user enters a blank name value, they’ll see a message telling them that a value is required:<p class="source-code">it("displays error after blur when first name field is blank", () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">  withFocus(field("firstName"), () =&gt;</p><p class="source-code">    change(field("firstName"), " ");</p><p class="source-code">  )</p><p class="source-code">  expect(</p><p class="source-code">    element("#firstNameError[role=alert]")</p><p class="source-code">  ).toContainText("First name is required");</p><p class="source-code">});</p></li>
<li>To make this pass, we need to hardcode the message:<p class="source-code">&lt;span id="firstNameError" role="alert"&gt;</p><p class="source-code"><strong class="bold">  First name is required</strong></p><p class="source-code">&lt;/span&gt;</p></li>
<li>Let’s triangulate to replace the hardcoding. The following test asserts that the alert message is initially blank. Notice the use of <strong class="source-inline">toEqual</strong> rather than <strong class="source-inline">not.toContainText</strong>: this is forward planning. When we come to generalize this function in <a id="_idIndexMarker902"/>the next section, the alert text could be anything:<p class="source-code">it("initially has no text in the first name field alert space", async () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">  expect(</p><p class="source-code">    element("#firstNameError[role=alert]").textContent</p><p class="source-code">  ).toEqual("");</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">A matcher for empty text content</p>
<p class="callout">Although not covered in this book, this would be a good opportunity to build a new matcher such as <strong class="source-inline">toHaveNoText</strong>, or maybe <strong class="source-inline">not.toContainAnyText</strong>.</p>
<ol>
<li value="10">To make this test pass, we’ll add support for running validation rules within <strong class="source-inline">CustomerForm</strong>. Start by adding the following inline function definition at the top of <strong class="source-inline">src/CustomerForm.js</strong>, just below the imports but above the <strong class="source-inline">CustomerForm</strong> component definition. This is our first validation rule, <strong class="source-inline">required</strong>, which returns an error string if the supplied value is empty, and <strong class="source-inline">undefined</strong> otherwise:<p class="source-code">const required = value =&gt;</p><p class="source-code">  !value || value.trim() === ""</p><p class="source-code">    ? "First name is required"</p><p class="source-code">    : undefined;</p></li>
<li>Within the <strong class="source-inline">CustomerForm</strong> component, define a <strong class="source-inline">validationErrors</strong> state variable, initially set to an empty object:<p class="source-code">const [</p><p class="source-code">  validationErrors, setValidationErrors</p><p class="source-code">] = useState({});</p></li>
<li>Create a handler function inside <strong class="source-inline">CustomerForm</strong> that can be used when the user switches focus away from the first name field. It runs the <strong class="source-inline">required</strong> validation we <a id="_idIndexMarker903"/>defined in the first step, and then saves the response in the <strong class="source-inline">validationErrors</strong> state object:<p class="source-code">const handleBlur = ({ target }) =&gt; {</p><p class="source-code">  const result = required(target.value);</p><p class="source-code">  setValidationErrors({</p><p class="source-code">    ...validationErrors,</p><p class="source-code">    firstName: result</p><p class="source-code">  });</p><p class="source-code">};</p></li>
<li>Next, define a function that the JSX will use to choose which message to display, named <strong class="source-inline">hasFirstNameError</strong>:<p class="source-code">const hasFirstNameError = () =&gt;</p><p class="source-code">  validationErrors.firstName !== undefined;</p></li>
<li>All that’s left is to modify our JSX so that it invokes the validation logic, and then displays the validation error. Use the following code to set the <strong class="source-inline">onBlur</strong> handler on the existing input field for <strong class="source-inline">firstName</strong> and to render the error text just after it. After this change, your test should be passing:<p class="source-code">&lt;input</p><p class="source-code">  type="text"</p><p class="source-code">  name="firstName"</p><p class="source-code">  ...</p><p class="source-code"><strong class="bold">  onBlur={handleBlur}</strong></p><p class="source-code">/&gt;</p><p class="source-code">&lt;span id="firstNameError" role="alert"&gt;</p><p class="source-code"><strong class="bold">  {hasFirstNameError()</strong></p><p class="source-code"><strong class="bold">    ? validationErrors["firstName"]</strong></p><p class="source-code"><strong class="bold">    : ""}</strong></p><p class="source-code">&lt;/span&gt;</p></li>
</ol>
<p>You now<a id="_idIndexMarker904"/> have a completed, working system for validating the first name field.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor165"/>Generalizing validation for multiple fields</h2>
<p>Next, we’ll<a id="_idIndexMarker905"/> add the required validation to the last name and phone number fields.</p>
<p>Since we’re on green, we can refactor our existing code <em class="italic">before</em> we write the next test. We will update the JSX and the <strong class="source-inline">hasFirstNameError</strong> and <strong class="source-inline">handleBlur</strong> functions so that they work for all the fields on the form.</p>
<p>This will be an exercise in systematic refactoring: breaking the refactoring down into small steps. After each step, we’re aiming for our tests to still be green:</p>
<ol>
<li value="1">First, we’ll extract a function containing a JSX snippet for rendering errors. Just above the JSX return value in <strong class="source-inline">CustomerForm</strong>, add a new function named <strong class="source-inline">renderFirstNameError</strong> with the following content:<p class="source-code">const renderFirstNameError = () =&gt; (</p><p class="source-code">  &lt;span id="firstNameError" role="alert"&gt;</p><p class="source-code">    {hasFirstNameError()</p><p class="source-code">      ? validationErrors["firstName"]</p><p class="source-code">      : ""}</p><p class="source-code">  &lt;span&gt;</p><p class="source-code">);</p></li>
<li>Now, you <a id="_idIndexMarker906"/>can use that in the JSX to replace the <strong class="source-inline">span</strong> alert. Your tests should still be passing at each step:<p class="source-code">&lt;input</p><p class="source-code">  type="text"</p><p class="source-code">  name="firstName"</p><p class="source-code">  ...</p><p class="source-code">/&gt;</p><p class="source-code"><strong class="bold">{renderFirstNameError()}</strong></p></li>
<li>Next, we’ll introduce a parameter into this function that will reference the ID of the field we’re showing the error from. Adjust the line you just added to introduce that new parameter:<p class="source-code">&lt;input</p><p class="source-code">  type="text"</p><p class="source-code">  name="firstName"</p><p class="source-code">  ...</p><p class="source-code">/&gt;</p><p class="source-code">{renderFirstNameError(<strong class="bold">"firstName")}</strong></p></li>
</ol>
<p class="callout-heading">Always having green tests – JavaScript versus TypeScript</p>
<p class="callout">This section is written in a way that your tests should still be passing at every step. In the preceding step, we passed a parameter to <strong class="source-inline">renderFirstNameError</strong> that the function can’t accept yet. In JavaScript, this is <a id="_idIndexMarker907"/>perfectly fine. In TypeScript, you’ll get a type error when attempting to build your source.</p>
<ol>
<li value="4">Introduce that parameter into the <strong class="source-inline">renderFirstNameError</strong> function as follows, replacing occurrences of the <strong class="source-inline">firstName</strong> string with the <strong class="source-inline">fieldName</strong> variable. Your tests should still be passing after this change:<p class="source-code">const renderFirstNameError = <strong class="bold">(fieldName)</strong> =&gt; (</p><p class="source-code">  &lt;span id={`${fieldName}Error`} role="alert"&gt;</p><p class="source-code">    {hasFirstNameError()</p><p class="source-code">      ? validationErrors[fieldName]</p><p class="source-code">      : ""}</p><p class="source-code">  &lt;span&gt;</p><p class="source-code">);</p></li>
<li>Repeat the<a id="_idIndexMarker908"/> same process for the <strong class="source-inline">hasFirstNameError</strong> function by adding a parameter value:<p class="source-code">const renderFirstNameError = (fieldName) =&gt; (</p><p class="source-code">  &lt;span id={`${fieldName}Error`} role="alert"&gt;</p><p class="source-code">    {hasFirstNameError(<strong class="bold">fieldName</strong>)</p><p class="source-code">      ? validationErrors[fieldName]</p><p class="source-code">      : ""}</p><p class="source-code">  &lt;span&gt;</p><p class="source-code">);</p></li>
<li>Add the <strong class="source-inline">fieldName</strong> parameter to <strong class="source-inline">hasFirstNameError</strong> and modify the function body so that it uses the parameter in place of the <strong class="source-inline">firstName</strong> error property: <p class="source-code">const hasFirstNameError = <strong class="bold">fieldName</strong> =&gt;</p><p class="source-code">  validationErrors<strong class="bold">[fieldName]</strong> !== undefined;</p></li>
<li>Now, rename <strong class="source-inline">renderFirstNameError</strong> so that it becomes <strong class="source-inline">renderError</strong> and</li>
</ol>
<p><strong class="source-inline">hasFirstNameError</strong> so that it becomes <strong class="source-inline">hasError</strong>.</p>
<p class="callout-heading">Refactoring support in your IDE</p>
<p class="callout">Your IDE may have renaming support built in. If it does, you should use it. Automated refactoring tools lessen the risk of human error.</p>
<ol>
<li value="8">Let’s <a id="_idIndexMarker909"/>tackle <strong class="source-inline">handleBlur</strong>. We’re already passing the <strong class="source-inline">target</strong> parameter, and we can use <strong class="source-inline">target.name</strong> to key into a map that then tells us which validator to run for each field:<p class="source-code">const handleBlur = ({ target }) =&gt; {</p><p class="source-code"><strong class="bold">  const validators = {</strong></p><p class="source-code"><strong class="bold">    firstName: required</strong></p><p class="source-code"><strong class="bold">  };</strong></p><p class="source-code">  const result = </p><p class="source-code">    <strong class="bold">validators[target.name](</strong>target.value);</p><p class="source-code">  setValidationErrors({</p><p class="source-code">    ...validationErrors,</p><p class="source-code"><strong class="bold">    [target.name]</strong>: result</p><p class="source-code">  });</p><p class="source-code">};</p></li>
</ol>
<p>As you can see, the first half of the function (the definition of <strong class="source-inline">validators</strong>) is now static data that defines how the validation should happen for <strong class="source-inline">firstName</strong>. This object will be extended later, with the <strong class="source-inline">lastName</strong> and <strong class="source-inline">phoneNumber</strong> fields. The second half is generic and will work for any input field that’s passed in, so long as a validator exists for that field.</p>
<ol>
<li value="9">The <strong class="source-inline">required</strong> validator is <a id="_idIndexMarker910"/>hardcoded with the first name description. Let’s pull out the entire message as a variable. We can create a higher-order function that returns a validation function that uses this message. Modify <strong class="source-inline">required</strong> so that it looks as follows:<p class="source-code">const required = <strong class="bold">description =&gt;</strong> value =&gt;</p><p class="source-code">  !value || value.trim() === ""</p><p class="source-code">    ? <strong class="bold">description</strong></p><p class="source-code">    : undefined;</p></li>
<li>Finally, update <a id="_idIndexMarker911"/>the validator so that it calls this new required function:<p class="source-code">const validators = {</p><p class="source-code">  firstName: <strong class="bold">required("First name is required")</strong></p><p class="source-code">};</p></li>
</ol>
<p>At this point, your tests should be passing and you should have a fully generalized solution. Now, let’s generalize the tests too, by converting our four validation tests into test generator functions:</p>
<ol>
<li value="1">Define a <a id="_idIndexMarker912"/>new <strong class="source-inline">errorFor</strong> helper at the top of the <strong class="source-inline">validations</strong> nested <strong class="source-inline">describe</strong> block. This will be used in the test generators:<p class="source-code">const errorFor = (fieldName) =&gt;</p><p class="source-code">  element(`#${fieldName}Error[role=alert]`);</p></li>
<li>Find the first test you’ve written in this section (<strong class="source-inline">renders an alert space...</strong>). Modify it, as shown here, by wrapping it in a function definition that takes a <strong class="source-inline">fieldName</strong> parameter. Use that parameter in the test description and the expectation, replacing the use of <strong class="source-inline">firstName</strong>, and making use of the new <strong class="source-inline">errorFor</strong> helper to find the appropriate field:<p class="source-code"><strong class="bold">const itRendersAlertForFieldValidation = (fieldName) =&gt; {</strong></p><p class="source-code">  it(<strong class="bold">`</strong>renders an alert space for <strong class="bold">${fieldName}</strong> validation errors<strong class="bold">`</strong>, async () =&gt; {</p><p class="source-code">    render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">    expect(<strong class="bold">errorFor(fieldName)</strong>).not.toBeNull();</p><p class="source-code">  });</p><p class="source-code"><strong class="bold">};</strong></p></li>
<li>Since you’ve<a id="_idIndexMarker913"/> now lost the test for the first name, add that back in with a call to the new test generator, just below it:<p class="source-code">itRendersAlertForFieldValidation("firstName");</p></li>
<li>Repeat the same process for the second test: wrap it in a function definition, introduce a <strong class="source-inline">fieldName</strong> parameter, and replace <strong class="source-inline">firstName</strong> with <strong class="source-inline">fieldName</strong> within the test description and expectation:<p class="source-code"><strong class="bold">const itSetsAlertAsAccessibleDescriptionForField = (</strong></p><p class="source-code"><strong class="bold">  fieldName</strong></p><p class="source-code"><strong class="bold">) =&gt; {</strong></p><p class="source-code">  it(<strong class="bold">`</strong>sets alert as the accessible description for the <strong class="bold">${fieldName}</strong> field<strong class="bold">`</strong>, async () =&gt; {</p><p class="source-code">    render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">    expect(</p><p class="source-code">      field(<strong class="bold">fieldName</strong>).getAttribute(</p><p class="source-code">        "aria-describedby"</p><p class="source-code">      )</p><p class="source-code">    ).toEqual<strong class="bold">(`${fieldName}Error`</strong>);</p><p class="source-code">  });</p><p class="source-code">};</p></li>
<li>Then, re-introduce the test case for the <strong class="source-inline">firstName</strong> field:<p class="source-code">itSetsAlertAsAccessibleDescriptionForField(</p><p class="source-code">  "firstName"</p><p class="source-code">);</p></li>
<li>Next, it’s time to tackle the chunkiest test – the <strong class="source-inline">displays error after blur...</strong> test. The previous two test generators used just one parameter, <strong class="source-inline">fieldName</strong>. This one needs two more, <strong class="source-inline">value</strong> and <strong class="source-inline">description</strong>, that are used in the <strong class="bold">Act</strong> phase <a id="_idIndexMarker914"/>and the <strong class="bold">Assert</strong> phase, respectively:<p class="source-code"><strong class="bold">const itInvalidatesFieldWithValue = (</strong></p><p class="source-code"><strong class="bold">  fieldName,</strong></p><p class="source-code"><strong class="bold">  value,</strong></p><p class="source-code"><strong class="bold">  description</strong></p><p class="source-code"><strong class="bold">) =&gt; {</strong></p><p class="source-code">  it(<strong class="bold">`</strong>displays error after blur when <strong class="bold">${fieldName}</strong> field is <strong class="bold">'${value}'`</strong>, () =&gt; {</p><p class="source-code">    render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">    withFocus(field(<strong class="bold">fieldName</strong>), () =&gt;</p><p class="source-code">      change(field(<strong class="bold">fieldName</strong>), <strong class="bold">value</strong>)</p><p class="source-code">    );</p><p class="source-code">    expect(</p><p class="source-code"><strong class="bold">      errorFor(fieldName)</strong></p><p class="source-code">    ).toContainText(<strong class="bold">description</strong>);</p><p class="source-code">  });</p><p class="source-code">};</p></li>
<li>Just below that test generator definition, re-introduce the test case for the <strong class="source-inline">first name</strong> field:<p class="source-code">itInvalidatesFieldWithValue(</p><p class="source-code">  "firstName",</p><p class="source-code">  " ",</p><p class="source-code">  "First name is required"</p><p class="source-code">);</p></li>
<li>Finally, repeat <a id="_idIndexMarker915"/>the same process for the fourth test:<p class="source-code"><strong class="bold">const itInitiallyHasNoTextInTheAlertSpace = (fieldName) =&gt; {</strong></p><p class="source-code">  it(<strong class="bold">`</strong>initially has no text in the <strong class="bold">${fieldName}</strong> field alert space<strong class="bold">`</strong>, async () =&gt; {</p><p class="source-code">    render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">    expect(</p><p class="source-code"><strong class="bold">      errorFor(fieldName)</strong>.textContent</p><p class="source-code">    ).toEqual("");</p><p class="source-code">  });</p><p class="source-code">};</p></li>
<li>Then, re-introduce the <strong class="source-inline">firstName</strong> test case:<p class="source-code">itInitiallyHasNoTextInTheAlertSpace("firstName");</p></li>
<li>After all that effort, it’s time to use the new test generators to build out the validation for the <strong class="source-inline">lastName</strong> field. Add the following single line at the bottom of your test suite:<p class="source-code">itRendersAlertForFieldValidation("lastName");</p></li>
<li>To make that pass, simply add the code to the <strong class="source-inline">CustomerForm</strong> JSX by rendering <a id="_idIndexMarker916"/>another alert just below the <strong class="source-inline">lastName</strong> field:<p class="source-code">&lt;label htmlFor="lastName"&gt;Last name&lt;/label&gt;</p><p class="source-code">&lt;input</p><p class="source-code">  type="text"</p><p class="source-code">  name="lastName"</p><p class="source-code">  id="lastName"</p><p class="source-code">  value={customer.lastName}</p><p class="source-code">  onChange={handleChange}</p><p class="source-code">/&gt;</p><p class="source-code"><strong class="bold">{renderError("lastName")}</strong></p></li>
<li>Next, we must create the <a id="_idIndexMarker917"/>test for the <strong class="source-inline">aria-describedby</strong> attribute:<p class="source-code">itSetsAlertAsAccessibleDescriptionForField(</p><p class="source-code">  "lastName"</p><p class="source-code">);</p></li>
<li>To make it pass, add that attribute to the <strong class="source-inline">lastName</strong> input element:<p class="source-code">&lt;input</p><p class="source-code">  type="text"</p><p class="source-code">  name="lastName"</p><p class="source-code">  ...</p><p class="source-code"><strong class="bold">  aria-describedby="lastNameError"</strong></p><p class="source-code">/&gt;</p></li>
<li>Next, add the test for the required validation rule:<p class="source-code">itInvalidatesFieldWithValue(</p><p class="source-code">  "lastName",</p><p class="source-code">  " ",</p><p class="source-code">  "Last name is required"</p><p class="source-code">);</p></li>
<li>Given<a id="_idIndexMarker918"/> all the hard work we’ve done already, making this test pass is now super simple. Add a <strong class="source-inline">lastName</strong> entry to the <strong class="source-inline">validators</strong> object, as shown here:<p class="source-code">const validators = {</p><p class="source-code">  firstName: required("First name is required"),</p><p class="source-code"><strong class="bold">  lastName: required("Last name is required"),</strong></p><p class="source-code">};</p></li>
<li>For completeness, we need to add the fourth and final test for the <strong class="source-inline">lastName</strong> field. This test passes already since we’re relying on the mechanism we’ve just generalized. However, given that it’s a one-liner, it’s worth specifying, even if it’s not necessary:<p class="source-code">itInitiallyHasNoTextInTheAlertSpace("lastName");</p></li>
<li>Repeat <em class="italic">Steps 10</em> to <em class="italic">16</em> for the <strong class="source-inline">phone number</strong> field.</li>
</ol>
<p class="callout-heading">Who needs test generator functions?</p>
<p class="callout">Test generator functions can look complex. You may prefer to keep duplication in your tests or find some other way to extract common functionality from your tests.</p>
<p class="callout">There is a downside to the test generator approach: you won’t be able to use <strong class="source-inline">it.only</strong> or <strong class="source-inline">it.skip</strong> on individual tests.</p>
<p>With that, we’ve covered the required field validation. Now, let’s add a different type of validation for the <strong class="source-inline">phoneNumber</strong> field. We want to ensure the phone number only contains numbers and a few special characters: brackets, dashes, spaces, and pluses.</p>
<p>To do that, we’ll <a id="_idIndexMarker919"/>introduce a <strong class="source-inline">match</strong> validator that can perform the<a id="_idIndexMarker920"/> phone number matching we need, and a <strong class="source-inline">list</strong> validator that composes validations.</p>
<p>Let’s add that second validation:</p>
<ol>
<li value="1">Add the following new test:<p class="source-code">itInvalidatesFieldWithValue(</p><p class="source-code">  "phoneNumber",</p><p class="source-code">  "invalid",</p><p class="source-code">  "Only numbers, spaces and these symbols are allowed: ( ) + -"</p><p class="source-code">);</p></li>
<li>Add the following definition at the top of <strong class="source-inline">src/CustomerForm.js</strong>. This expects a regular expression, <strong class="source-inline">re</strong>, which can then be matched against:<p class="source-code">const match = (re, description) =&gt; value =&gt;</p><p class="source-code">  !value.match(re) ? description : undefined;</p></li>
</ol>
<p class="callout-heading">Learning regular expressions</p>
<p class="callout">Regular expressions are a flexible<a id="_idIndexMarker921"/> mechanism for matching string formats. If you’re interested in learning more about them, and how to test-drive them, take a look at <a href="https://reacttdd.com/testing-regular-expressions">https://reacttdd.com/testing-regular-expressions</a>.</p>
<ol>
<li value="3">Now, let’s go<a id="_idIndexMarker922"/> for the <strong class="source-inline">list</strong> validator function. This is quite a dense piece of code that returns a short-circuiting validator. It runs each validator that it’s given until it finds one that returns a string, and then returns that string. Add this just below the definition for <strong class="source-inline">match</strong>:<p class="source-code">const list = (...validators) =&gt; value =&gt;</p><p class="source-code">  validators.reduce(</p><p class="source-code">    (result, validator) =&gt; result || validator(value),</p><p class="source-code">    undefined</p><p class="source-code">  );</p></li>
<li>Replace <a id="_idIndexMarker923"/>the existing <strong class="source-inline">phoneNumber</strong> validation in the <strong class="source-inline">handleBlur</strong> function with the following validation, which uses all three validator functions:<p class="source-code">const validators = {</p><p class="source-code">  ...</p><p class="source-code">  phoneNumber: <strong class="bold">list(</strong></p><p class="source-code">    required("Phone number is required"),</p><p class="source-code"><strong class="bold">    match(</strong></p><p class="source-code"><strong class="bold">      /^[0-9+()\- ]*$/,</strong></p><p class="source-code"><strong class="bold">      "Only numbers, spaces and these symbols are allowed: ( ) + -"</strong></p><p class="source-code"><strong class="bold">    )</strong></p><p class="source-code"><strong class="bold">  )</strong></p><p class="source-code">};</p></li>
<li>Your test should now be passing. However, if you look back at the test we just wrote, it says nothing about the allowed set of characters: it just says that <strong class="source-inline">invalid</strong> is not a valid phone number. To prove the use of the <em class="italic">real</em> regular expression, we need an inverse test to check that any combination of characters works. You <a id="_idIndexMarker924"/>can add this in; it should already pass:<p class="source-code">it("accepts standard phone number characters when validating", () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">  withFocus(field("phoneNumber"), () =&gt;</p><p class="source-code">    change(field("phoneNumber"), "0123456789+()- ")</p><p class="source-code">  );</p><p class="source-code">  expect(errorFor("phoneNumber")).not.t<a id="_idTextAnchor166"/>oContainText(</p><p class="source-code">    "Only numbers" </p><p class="source-code">  );</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Is this a valid test?</p>
<p class="callout">This test passes without any required changes. That breaks our rule of only writing tests that fail.</p>
<p class="callout">We got into this situation because we did too much in our previous test: all we needed to do was prove that the <strong class="source-inline">invalid</strong> string wasn’t a valid phone number. But instead, we jumped ahead and implemented the full regular expression.</p>
<p class="callout">If we had triangulated “properly,” with a dummy regular expression to start, we would have ended up in the same place we are now, except we’d have done a bunch of extra intermediate work that ends up being deleted.</p>
<p class="callout">In some scenarios, such as when dealing <a id="_idIndexMarker925"/>with regular expressions, I find it’s okay to short-circuit the process as it saves me some work.</p>
<p>With <a id="_idIndexMarker926"/>that, you’ve learned how to generalize validation using TDD.</p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor167"/>Submitting the form</h2>
<p>What should <a id="_idIndexMarker927"/>happen when we submit the form? For our application, if the user clicks the submit button before the form is complete, the submission process should be canceled and all the fields should display their validation errors at once.</p>
<p>We can do this with two tests: one to check that the form isn’t submitted while there are errors, and another to check that all the fields are showing errors.</p>
<p>Before we do that, we’ll need to update our existing tests that submit the form, as they all assume that the form has been filled in correctly. First, we need to ensure that we pass valid customer data that can be overridden in each test.</p>
<p>Let’s get to work on the <strong class="source-inline">CustomerForm</strong> test suite:</p>
<ol>
<li value="1">We need a new builder to help represent a <strong class="source-inline">validCustomer</strong> record. We’ll update many of our existing tests to use this new value. In <strong class="source-inline">test/builders/customer.js</strong>, define the following object:<p class="source-code">export const validCustomer = {</p><p class="source-code">  firstName: "first",</p><p class="source-code">  lastName: "last",</p><p class="source-code">  phoneNumber: "123456789"</p><p class="source-code">};</p></li>
<li>In <strong class="source-inline">test/CustomerForm.test.js</strong>, update the import that contains <strong class="source-inline">blankCustomer</strong>, pulling in the new <strong class="source-inline">validCustomer</strong> too:<p class="source-code">import {</p><p class="source-code">  blankCustomer,</p><p class="source-code"><strong class="bold">  validCustomer,</strong></p><p class="source-code">} from "./builders/customer";</p></li>
<li>Starting at the top, modify each test that simulates a submit event. Each should be mounted with this new <strong class="source-inline">validCustomer</strong> object. After making these changes, run your tests and make sure they are still passing before continuing:<p class="source-code">render(&lt;CustomerForm <strong class="bold">original={validCustomer}</strong> /&gt;);</p></li>
<li>Add a new test for submitting the form. This can go alongside the other submit tests, rather<a id="_idIndexMarker928"/> than in the validation block:<p class="source-code">it("does not submit the form when there are validation errors", async () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">  await clickAndWait(submitButton());</p><p class="source-code">  expect(global.fetch).not.toBeCalled();</p><p class="source-code">});</p></li>
<li>To make this pass, first, define the following <strong class="source-inline">validateMany</strong> function inside the <strong class="source-inline">CustomerForm</strong> component. Its job is to validate many fields at once. It takes a single parameter, <strong class="source-inline">fields</strong>, which is an object of the field values we care about:<p class="source-code">const validateMany = fields =&gt;</p><p class="source-code">  Object.entries(fields).reduce(</p><p class="source-code">    (result, [name, value]) =&gt; ({</p><p class="source-code">      ...result,</p><p class="source-code">      [name]: validators[name](value)</p><p class="source-code">    }),</p><p class="source-code">    {}</p><p class="source-code">  );</p></li>
<li>The <strong class="source-inline">validateMany</strong> function references the <strong class="source-inline">validators</strong> constant, but that constant is currently defined in the <strong class="source-inline">handleBlur</strong> function. Pull that definition up so that it exists at the top of the component scope and is now accessible by both <strong class="source-inline">handleBlur</strong> and <strong class="source-inline">validateMany</strong>.</li>
<li>We need a new function to check for errors across all fields. That’s <strong class="source-inline">anyErrors</strong>; add<a id="_idIndexMarker929"/> that now, as shown here. It returns <strong class="source-inline">true</strong> if we had any errors at all, and <strong class="source-inline">false</strong> otherwise:<p class="source-code">const anyErrors = errors =&gt;</p><p class="source-code">  Object.values(errors).some(error =&gt; (</p><p class="source-code">    error !== undefined</p><p class="source-code">  )</p><p class="source-code">);</p></li>
<li>Now, we can use <strong class="source-inline">validateMany</strong> and <strong class="source-inline">anyErrors</strong> in our <strong class="source-inline">handleSubmit</strong> function, as shown here. We’re going to wrap most of the existing functions in a conditional. Your test should pass after adding this code:<p class="source-code">const handleSubmit = async e {</p><p class="source-code">  e.preventDefault();</p><p class="source-code"><strong class="bold">  const validationResult = validateMany(customer);</strong></p><p class="source-code"><strong class="bold">  if (!anyErrors(validationResult)) {</strong></p><p class="source-code">    ... existing code ...</p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">}</p></li>
<li>Let’s move on to the next test. We need a couple of new imports, <strong class="source-inline">textOf</strong> and <strong class="source-inline">elements</strong>, so that we can write an expectation across all three of the alert spaces. Add these now:<p class="source-code">import {</p><p class="source-code">  ...,</p><p class="source-code"><strong class="bold">  textOf,</strong></p><p class="source-code"><strong class="bold">  elements,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Next, add the following test at the bottom of the test suite. We want to check whether any<a id="_idIndexMarker930"/> errors appear on the screen:<p class="source-code">it("renders validation errors after submission fails", async () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">  await clickAndWait(submitButton());</p><p class="source-code">  expect(</p><p class="source-code">    textOf(elements("[role=alert]"))</p><p class="source-code">  ).not.toEqual("");</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Using the alert role on multiple elements</p>
<p class="callout">This chapter <a id="_idIndexMarker931"/>uses <a id="_idIndexMarker932"/>multiple alert spaces, one for <a id="_idIndexMarker933"/>each form field. However, screen readers do not behave well when <a id="_idIndexMarker934"/>multiple alert roles show alerts at the same time – for example, if clicking the submit button causes a validation error to appear on all three of our fields.</p>
<p class="callout">An alternative approach would be to rework the UI so that it has an additional element that takes on the alert role when any errors are detected; after that, it should remove the alert role from<a id="_idIndexMarker935"/> the individual field error descriptions. </p>
<ol>
<li value="11">This one is easy to pass; we simply need to call <strong class="source-inline">setValidationErrors</strong> with <strong class="source-inline">validationResult</strong> when <strong class="source-inline">anyErrors</strong> returns <strong class="source-inline">false</strong>:<p class="source-code">if (!anyErrors(validationResult)) {</p><p class="source-code">  ..<a id="_idTextAnchor168"/>.</p><p class="source-code">} <strong class="bold">else {</strong></p><p class="source-code"><strong class="bold">  setValidationErrors(validationResult);</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
</ol>
<p>You’ve<a id="_idIndexMarker936"/> now seen how to run all field validations when the form is submitted.</p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor169"/>Extracting non-React functionality into a new module</h2>
<p>One useful <a id="_idIndexMarker937"/>design <a id="_idIndexMarker938"/>guideline is to get out of “framework land” as soon as possible. You want to be dealing with plain JavaScript objects. This is especially true for React components: extract as much logic as possible out into standalone modules.</p>
<p>There are a few different reasons for this. First, testing components is harder than testing plain objects. Second, the React framework changes more often than the JavaScript language itself. Keeping our code bases up to date with the latest React trends is a large-scale task <em class="italic">if</em> our code base is, first and foremost, a React code base. If we keep React at bay, our lives will be simpler in the longer term. So, we always prefer to write plain JavaScript when it’s an option.</p>
<p>Our validation code is a great example of this. We have several functions that do not care about React at all:</p>
<ul>
<li>The validators: <strong class="source-inline">required</strong>, <strong class="source-inline">match</strong>, and <strong class="source-inline">list</strong></li>
<li><strong class="source-inline">hasError</strong> and <strong class="source-inline">anyErrors</strong></li>
<li><strong class="source-inline">validateMany</strong></li>
<li>Some of the code in <strong class="source-inline">handleBlur</strong>, which is like a single-entry equivalent of <strong class="source-inline">validateMany</strong></li>
</ul>
<p>Let’s pull all of these out into a separate namespace called <strong class="source-inline">formValidation</strong>:</p>
<ol>
<li value="1">Create a new file called <strong class="source-inline">src/formValidation.js</strong>.</li>
<li>Move across the function definitions for <strong class="source-inline">required</strong>, <strong class="source-inline">match</strong>, and <strong class="source-inline">list</strong> from the top of <strong class="source-inline">CustomerForm</strong>. Make sure you delete the old definitions!</li>
<li>Add the word <strong class="source-inline">export</strong> to the front of each definition in the new module.</li>
<li>Add the following import to the top of <strong class="source-inline">CustomerForm</strong>, and then check that your <a id="_idIndexMarker939"/>tests are<a id="_idIndexMarker940"/> still passing:<p class="source-code">import {</p><p class="source-code">  required,</p><p class="source-code">  match,</p><p class="source-code">  list,</p><p class="source-code">} from "./formValidation";</p></li>
<li>In <strong class="source-inline">src/CustomerForm.js</strong>, change <strong class="source-inline">renderError</strong> so that it passes the errors from <strong class="source-inline">state</strong> into <strong class="source-inline">hasError</strong>:<p class="source-code">const renderError = fieldName =&gt; {</p><p class="source-code">  if (hasError(<strong class="bold">validationErrors,</strong> fieldName)) {</p><p class="source-code">    ...</p><p class="source-code"> }</p><p class="source-code">}</p></li>
<li>Update <strong class="source-inline">hasError</strong> so that it includes the new <strong class="source-inline">validationErrors</strong> argument, and uses that rather than <strong class="source-inline">state</strong>:<p class="source-code">const hasError = <strong class="bold">(validationErrors,</strong> fieldName<strong class="bold">)</strong> =&gt;</p><p class="source-code"><strong class="bold">  validationErrors</strong>[fieldName] !== undefined;</p></li>
<li>Update <strong class="source-inline">validateMany</strong> so that it passes in the list of validators as its first argument, rather than using <strong class="source-inline">state</strong>:<p class="source-code">const validateMany = <strong class="bold">(validators,</strong> fields<strong class="bold">)</strong> =&gt;</p><p class="source-code">  Object.entries(fields).reduce(</p><p class="source-code">   (result, [name, value]) =&gt; ({</p><p class="source-code">    ...result,</p><p class="source-code">    [name]: validators[name](value)</p><p class="source-code">  }),</p><p class="source-code">  {}</p><p class="source-code">);</p></li>
<li>Update <strong class="source-inline">handleBlur</strong> so <a id="_idIndexMarker941"/>that<a id="_idIndexMarker942"/> it uses <strong class="source-inline">validateMany</strong>:<p class="source-code">const handleBlur = ({ target }) =&gt; {</p><p class="source-code">  const result = <strong class="bold">validateMany(validators, {</strong></p><p class="source-code"><strong class="bold">    [target.name] : target.value</strong></p><p class="source-code"><strong class="bold">  });</strong></p><p class="source-code">  setValidationErrors({</p><p class="source-code">    ...validationErrors,</p><p class="source-code">    ...result</p><p class="source-code">  });</p><p class="source-code">}</p></li>
<li>Update <strong class="source-inline">handleSubmit</strong> so that it passes <strong class="source-inline">validators</strong> to <strong class="source-inline">validateMany</strong>:<p class="source-code">const validationResult = validateMany(</p><p class="source-code">  <strong class="bold">validators,</strong></p><p class="source-code">  customer</p><p class="source-code">);</p></li>
<li>Move <strong class="source-inline">hasError</strong>, <strong class="source-inline">validateMany</strong>, and <strong class="source-inline">anyErrors</strong> into <strong class="source-inline">src/formValidation.js</strong>, ensuring you delete the functions from the <strong class="source-inline">CustomerForm</strong> component.</li>
<li>Add the word <strong class="source-inline">export</strong> in front of each of these definitions.</li>
<li>Update the import so that it pulls in these functions:<p class="source-code">import {</p><p class="source-code">  required,</p><p class="source-code">  match,</p><p class="source-code">  list<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">  hasError,</strong></p><p class="source-code"><strong class="bold">  validateMany,</strong></p><p class="source-code"><strong class="bold">  anyErrors,</strong></p><p class="source-code">} from "./formValidation";</p></li>
</ol>
<p>Although <a id="_idIndexMarker943"/>this is <a id="_idIndexMarker944"/>enough to extract the code out of React-land, we’ve only just made a start. There is plenty of room for improvement with this API. There are a couple of different approaches that you could take here. The exercises for this chapter contain some suggestions on how to do that.</p>
<p class="callout-heading">Using test doubles for validation functions</p>
<p class="callout">You may be thinking, do these functions now need their own unit tests? And should I update the tests in <strong class="source-inline">CustomerForm</strong> so that test doubles are used in place of these functions?</p>
<p class="callout">In this case, I would probably write a few tests for <strong class="source-inline">formValidation</strong>, just to make it clear how each of the functions should be used. This isn’t test-driving since you already have the code, but you can still mimic the experience by writing tests as you normally would.</p>
<p class="callout">When extracting functionality from components like this, it often makes sense to update the original components to simplify and perhaps move across tests. In this instance, I wouldn’t bother. The tests are high-level enough that they make sense, regardless of how the code is organized internally.</p>
<p>This section covered how to write validation logic for forms. You should now have a good<a id="_idIndexMarker945"/> awareness of how TDD can be used to implement complex requirements such as field validation<a id="_idTextAnchor170"/>s. Next, we’ll integrate server-side errors into the same flow.</p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor171"/>Handling server errors</h1>
<p>The <strong class="source-inline">/customers</strong> endpoint<a id="_idIndexMarker946"/> may return a <strong class="source-inline">422 Unprocessable Entity</strong> error if the customer data failed the validation process. This could happen if, for example, the phone number already exists within the system. If this happens, we want to withhold calling the <strong class="source-inline">onSave</strong> callback and instead display the errors to the user and give them the chance to correct them.</p>
<p>The body of the response will contain error data very similar to the data we’ve built for the validation framework. Here’s an example of the JSON that would be received:</p>
<pre class="source-code">
{
  "errors": {
    "phoneNumber": "Phone number already exists in the system"
  }
}</pre>
<p>We’ll update our code to display these errors in the same way our client errors appeared. Since we already handle errors for <strong class="source-inline">CustomerForm</strong>, we’ll need to adjust our tests in addition to the existing <strong class="source-inline">CustomerForm</strong> code.</p>
<p>Our code to date has made use of the <strong class="source-inline">ok</strong> property that’s returned from <strong class="source-inline">global.fetch</strong>. This property returns <strong class="source-inline">true</strong> if the HTTP status code is <strong class="source-inline">200</strong>, and false otherwise. Now, we need to be more specific. For a status code of <strong class="source-inline">422</strong>, we want to display new errors, and for anything else (such as a <strong class="source-inline">500</strong> error), we want to fall back to the existing behavior.</p>
<p>Let’s add support for those additional status codes:</p>
<ol>
<li value="1">Update <a id="_idIndexMarker947"/>the <strong class="source-inline">fetchResponseError</strong> method in <strong class="source-inline">test/builders/fetch.js</strong>, as shown here:<p class="source-code">const fetchResponseError = (</p><p class="source-code">  <strong class="bold">status = 500,</strong></p><p class="source-code"><strong class="bold">  body = {}</strong></p><p class="source-code">) =&gt; ({</p><p class="source-code">  ok: false<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">  status,</strong></p><p class="source-code"><strong class="bold">  json: () =&gt; Promise.resolve(body),</strong></p><p class="source-code">});</p></li>
<li>Write a test<a id="_idIndexMarker948"/> for <strong class="source-inline">422</strong> errors in <strong class="source-inline">test/CustomerForm.test.js</strong>. I’ve placed this toward the top of the file, next to the other tests that manipulate the HTTP response:<p class="source-code">it("renders field validation errors from server", async () =&gt; {</p><p class="source-code">  const errors = {</p><p class="source-code">    phoneNumber: "Phone number already exists in the system"</p><p class="source-code">  };</p><p class="source-code">  global.fetch.mockResolvedValue(</p><p class="source-code">    fetchResponseError(422, { errors })</p><p class="source-code">  );</p><p class="source-code">  render(&lt;CustomerForm original={validCustomer} /&gt;);</p><p class="source-code">  await clickAndWait(submitButton());</p><p class="source-code">  expect(errorFor("phoneNumber")).toContainText(</p><p class="source-code">    errors.phoneNumber</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>To make that pass, add a new branch to the nested conditional statement in <strong class="source-inline">handleSubmit</strong>, which <a id="_idIndexMarker949"/>handles the response of the fetch request:<p class="source-code">if (result.ok) {</p><p class="source-code">  setError(false);</p><p class="source-code">  const customerWithId = await result.json();</p><p class="source-code">  onSave(customerWithId);</p><p class="source-code"><strong class="bold">} else if (result.status === 422) {</strong></p><p class="source-code"><strong class="bold">  const response = await result.json();</strong></p><p class="source-code"><strong class="bold">  setValidationErrors(response.errors);</strong></p><p class="source-code">} else {</p><p class="source-code">  setError(true);</p><p class="source-code">}</p></li>
</ol>
<p>Your tests should now be passing.</p>
<p>This section has shown you how to integrate server-side errors into the same client-side validatio<a id="_idTextAnchor172"/>n logic that you already have. To finish up, we’ll add some frills.</p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor173"/>Indicating form submission status</h1>
<p>It’d be great if we<a id="_idIndexMarker950"/> could indicate to the user that their form data is being sent to our application servers. The GitHub repository for this book contains a spinner graphic and some CSS that we can use. All that our React component needs to do is display a <strong class="source-inline">span</strong> element with a<a id="_idIndexMarker951"/> class name of <strong class="source-inline">submittingIndicator</strong>.</p>
<p>Before we write out the tests, let’s look at how the production code will work. We will introduce a new <strong class="source-inline">submitting</strong> boolean state variable that is used to toggle between states. It will be toggled to <strong class="source-inline">true</strong> just before we perform the fetch request and toggled to <strong class="source-inline">false</strong> once the request completes. Here’s how we’ll modify <strong class="source-inline">handleSubmit</strong>:</p>
<pre class="source-code">
...
if (!anyErrors(validationResult)) {
<strong class="bold">  setSubmitting(true);</strong>
  const result = await global.fetch(...);
<strong class="bold">  setSubmitting(false);</strong>
  ...
}
...</pre>
<p>If submitting is set to <strong class="source-inline">true</strong>, then we will render the spinner graphic. Otherwise, we will render nothing.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor174"/>Testing state before promise completion</h2>
<p>One of the<a id="_idIndexMarker952"/> trickiest aspects of testing React components is testing what happens <em class="italic">during</em> a task. That’s what we need to do now: we want to<a id="_idIndexMarker953"/> check that the submitting indicator is shown while the form is being submitted. However, the indicator disappears as soon as the promise completes, meaning that we can’t use the standard <strong class="source-inline">clickAndWait</strong> function we’ve used up until now because it will return at the point <em class="italic">after</em> the indicator has disappeared!</p>
<p>Recall that <strong class="source-inline">clickAndWait</strong> uses the asynchronous<a id="_idIndexMarker954"/> form of the <strong class="source-inline">act</strong> test helper. That’s the core of the issue. To get around this, a <em class="italic">synchronous</em> form of our function, <strong class="source-inline">click</strong>, will be needed to return <em class="italic">before</em> the task queue completes – in other words, before the <strong class="source-inline">global.fetch</strong> call returns any results.</p>
<p>However, to stop React’s warning sirens from going off, we still need to include the asynchronous <strong class="source-inline">act</strong> form <em class="italic">somewhere</em> in our test. React knows the submit handler returns a promise and it expects us to wait for its execution via a call to <strong class="source-inline">act</strong>. We need to do that after we’ve <a id="_idIndexMarker955"/>checked the toggle value of submitting, not before.</p>
<p>Let’s build that test now:</p>
<ol>
<li value="1">Add <strong class="source-inline">act</strong> as an import to <strong class="source-inline">test/CustomerForm.test.js</strong>:<p class="source-code">import { act } from "react-dom/test-utils";</p></li>
<li>Re-add<a id="_idIndexMarker956"/> the <strong class="source-inline">click</strong> function import:<p class="source-code">import {</p><p class="source-code">  ...,</p><p class="source-code"><strong class="bold">  click,</strong></p><p class="source-code">  clickAndWait,</p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Create a new nested <strong class="source-inline">describe</strong> block at the bottom of the <strong class="source-inline">CustomerForm</strong> test suite, just below the existing form submission tests. This submits the call itself within a synchronous <strong class="source-inline">click</strong>, as explained previously. Then, we must wrap the expectation in an async <strong class="source-inline">act</strong> call that suppresses any warnings or errors from React:<p class="source-code">describe("submitting indicator", () =&gt; {</p><p class="source-code">  it("displays when form is submitting", async () =&gt; {</p><p class="source-code">    render(</p><p class="source-code">      &lt;CustomerForm</p><p class="source-code">        original={validCustomer}</p><p class="source-code">        onSave={() =&gt; {}}</p><p class="source-code">      /&gt;</p><p class="source-code">    );</p><p class="source-code">    click(submitButton());</p><p class="source-code">    await act(async () =&gt; {</p><p class="source-code">      expect(</p><p class="source-code">        element("span.submittingIndicator")</p><p class="source-code">      ).not.toBeNull();</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>To make this<a id="_idIndexMarker957"/> pass, we just<a id="_idIndexMarker958"/> need to show that <strong class="source-inline">span</strong> within the JSX. Place that just after the submit button, as follows:<p class="source-code">return (</p><p class="source-code">  &lt;form id="customer" onSubmit={handleSubmit}&gt;</p><p class="source-code">    ...</p><p class="source-code">    &lt;input type="submit" value="Add" /&gt;</p><p class="source-code"><strong class="bold">    &lt;span className="submittingIndicator" /&gt;</strong></p><p class="source-code">  &lt;/form&gt;</p><p class="source-code">);</p></li>
<li>Now, we need to triangulate, to ensure the indicator only shows when the form has been submitted and not before:<p class="source-code">it("initially does not display the submitting indicator", () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={validCustomer} /&gt;);</p><p class="source-code">  expect(element(".submittingIndicator")).toBeNull();</p><p class="source-code">});</p></li>
<li>We can make this pass by using a flag called <strong class="source-inline">submitting</strong>. It should be set to <strong class="source-inline">false</strong> when the indicator is disabled, and <strong class="source-inline">true</strong> when it’s enabled. Add the following state variable to the top of the <strong class="source-inline">CustomerForm</strong> component:<p class="source-code">const [submitting, setSubmitting] = useState(false);</p></li>
<li>Change the submitting <strong class="source-inline">span</strong> indicator so that it reads as follows:<p class="source-code"><strong class="bold">{submitting ? (</strong></p><p class="source-code">  &lt;span className="submittingIndicator" /&gt;</p><p class="source-code"><strong class="bold">) : null}</strong></p></li>
<li>The new test <a id="_idIndexMarker959"/>will now be passing, but the original test will be failing. We had to switch <strong class="source-inline">submittingIndicator</strong> to <strong class="source-inline">true</strong> just before we called <strong class="source-inline">fetch</strong>. In <strong class="source-inline">handleSubmit</strong>, add this line just above the call to <strong class="source-inline">fetch</strong>. After adding this code, your test should be passing:<p class="source-code">if (!anyErrors(validationResult)) {</p><p class="source-code"><strong class="bold">  setSubmitting(true);</strong></p><p class="source-code">  const result = await global.fetch(/* ... */);</p><p class="source-code">  ...</p><p class="source-code">}</p></li>
<li>Add this final test, which checks that the indicator disappears once the response has been received. This test is very<a id="_idIndexMarker960"/> similar to our first test for the submitting indicator:<p class="source-code">it("hides after submission", async () =&gt; {</p><p class="source-code">  render(</p><p class="source-code">    &lt;CustomerForm</p><p class="source-code">      original={validCustomer}</p><p class="source-code">      onSave={() =&gt; {}}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  await clickAndWait(submitButton());</p><p class="source-code">  expect(element(".submittingIndicator")).toBeNull();</p><p class="source-code">});</p></li>
<li>This time, we need to add a <strong class="source-inline">setSubmitting</strong> call <em class="italic">after</em> the fetch:<p class="source-code">if (!anyErrors(validationResult)) {</p><p class="source-code">  setSubmitting(true);</p><p class="source-code">  const result = await global.fetch(/* ... */);</p><p class="source-code"><strong class="bold">  setS<a id="_idTextAnchor175"/>ubmitting(false);</strong></p><p class="source-code">  ...</p><p class="source-code">}</p></li>
</ol>
<p>That’s <a id="_idIndexMarker961"/>everything; your tests should all be passing.</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor176"/>Refactoring long methods</h2>
<p>After <a id="_idIndexMarker962"/>this, our <strong class="source-inline">handleSubmit</strong> function is long – I have counted 23 lines in my implementation. That is too long for my liking!</p>
<p>Refactoring <strong class="source-inline">handleSubmit</strong> into smaller methods is an exercise left for you; see the <em class="italic">Exercises</em> section for more details. But here are a couple of hints for how you can go about that systematically:</p>
<ul>
<li>Extract blocks into methods; in this case, that means the contents of <strong class="source-inline">if</strong> statements. For example, if there are no validation errors, you could call out to a <strong class="source-inline">doSave</strong> method, which does the submission.</li>
<li>Look for <strong class="bold">temporal coupling</strong> and <a id="_idIndexMarker963"/>see if there are other ways to format that code. In this case, we have the submitting state variable, which is set to <strong class="source-inline">true</strong>, before the<a id="_idIndexMarker964"/> fetch call, and th<a id="_idTextAnchor177"/>en <strong class="source-inline">false</strong> after. This could be done differently.</li>
</ul>
<p>Now, let’s summarize this chapter.</p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor178"/>Summary</h1>
<p>This chapter has shown you how TDD can be applied beyond just toy examples. Although you may not ever want to implement form validation yourself, you can see how complex code can be test-driven using the same methods that you learned in the first part of this book. </p>
<p>First, you learned how to validate field values at an appropriate moment: when fields lose focus and when forms are submitted. You also saw how server-side errors can be integrated into that, and how to display an indicator to show the user that data is in the process of being saved.</p>
<p>This chapter also covered how to move logic from your React components into their own modules.</p>
<p>In t<a id="_idTextAnchor179"/>he next chapter, we’ll add a new feature to our system: a snazzy search interface.</p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor180"/>Exercises</h1>
<p>The following are some exercises for you to complete:</p>
<ol>
<li value="1">Add a feature that clears any validation errors when the user corrects them. Use the <strong class="source-inline">onChange</strong> handler for this rather than <strong class="source-inline">onBlur</strong>, since we want to let the user know as soon as they’ve corrected the error.</li>
<li>Add a feature that disables the submit button once the form has been submitted.</li>
<li>Write tests for each of the functions within the <strong class="source-inline">formValidation</strong> module.</li>
<li>The <strong class="source-inline">handleSubmit</strong> function is<a id="_idTextAnchor181"/> long. Extract a <strong class="source-inline">doSave</strong> function that pulls out the main body of the <strong class="source-inline">if</strong> statement.</li>
</ol>
<h1 id="_idParaDest-171"><a id="_idTextAnchor182"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>A guide to regular expressions, explained by examples</li>
</ul>
<p><a href="https://reacttdd.com/testing-regular-expressions">https://reacttdd.com/testing-regular-expressions</a></p>
<ul>
<li>More information on ARIA annotations such as <strong class="source-inline">aria-describedby</strong></li>
</ul>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Annotations">https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Annotations</a></p>
</div>
<div>
<div id="_idContainer031">
</div>
</div>
</div></body></html>