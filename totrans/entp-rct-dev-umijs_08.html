<html><head></head><body>
		<div id="_idContainer057">
			<h1 id="_idParaDest-70"><a id="_idTextAnchor096"/>Chapter 6: Testing Front-End Applications</h1>
			<p>Testing software is an essential part of software development. We can prevent errors and ensure that new features don't introduce bugs by implementing well-designed tests.</p>
			<p>In this chapter, you'll understand software testing by learning how to design integration and end-to-end tests and apply them in the development process. After that, you'll learn how to write tests using <strong class="bold">Jest</strong>, a JavaScript test framework focused on simplicity that works well with React. You'll also learn how to test interfaces by simulating user actions with <strong class="bold">Puppeteer</strong> and <strong class="bold">Headless Chrome</strong>.</p>
			<p>In this chapter, we'll cover the following main topics:</p>
			<ul>
				<li>Understanding software testing</li>
				<li>Writing tests with Jest</li>
				<li><a id="_idTextAnchor097"/>Testing interfaces with Puppeteer</li>
			</ul>
			<p>By the end of this chapter, you'll have learned how to design integration and end-to-end tests and how to apply them to improve software quality. You'll have learned how to write tests using Jest, a tool to write and run tests in JavaScript projects. You'll also know how to test interfaces with Puppeteer and Headless Chrome.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor098"/>Technical requirements</h1>
			<p>To complete this chapter's exercises, you just need a computer with any OS (I recommend Ubuntu 20.04 or higher) and the software installed in <a id="_idTextAnchor099"/><a href="B18503_01_Final_JM_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Environment Setup and Introduction to UmiJS</em> (Visual Studio Code, Node.js, and Yarn).</p>
			<p>You can find the complete project in the <strong class="source-inline">Chapter06</strong> folder in the GitHub repository available at the following link: <a href="https://github.com/PacktPublishing/Enterprise-React-Development-with-UmiJs">https://github.com/PacktPublishing/Enterprise-React-Development-with-UmiJs</a></p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor100"/>Understanding software testing</h1>
			<p>In this section, we'll discuss <a id="_idIndexMarker325"/>software testing and how to design <strong class="bold">integration</strong> and <strong class="bold">end-to-end tests</strong> to ensure your application works as expected.</p>
			<p>There are numerous types of software testing, which we can divide into two categories: functional tests, which ensure that functional requirements and specifications are satisfied, and non-functional tests, which focus on testing the behavior and performance of the system. We'll talk about two types of functional tests in this section:</p>
			<ul>
				<li><strong class="bold">Integration tests</strong>: We<a id="_idIndexMarker326"/> write this type of test to ensure that different software components integrate and work correctly to deliver the specified feature.</li>
				<li><strong class="bold">End-to-end tests</strong>: We <a id="_idIndexMarker327"/>write this type of test to cover complete user flows, ensuring that features satisfy user expectations.</li>
			</ul>
			<p>It's important to mention that coding the test is only one task of implementing software testing, and it's not worth it if you don't have solid feature specifications and test plans.</p>
			<p>Let's start discussing integration tests.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor101"/>Understanding integration testing</h2>
			<p>We perform <a id="_idIndexMarker328"/>integration tests to ensure that the different modules present in the application work correctly and communicate to deliver the requested feature.</p>
			<p>Let's take our CRM application as an example. We implemented a feature to show the application in different languages by configuring the Umi locale plugin. We could execute an integration test to ensure that the <strong class="source-inline">SelectLang</strong> component works correctly with <strong class="source-inline">plugin-locale</strong> to show the application in the language selected. In that case, we would need to follow these steps:</p>
			<ol>
				<li>Hover over the user's name in the upper-right corner.</li>
				<li>Select <strong class="bold">English</strong> from the drop-down menu.</li>
				<li>Check whether the page is in English.</li>
			</ol>
			<p>We can manually execute the integration test following a test plan depending on the test strategy. Still, a <a id="_idIndexMarker329"/>better option is to write our tests using automated testing tools for repeating the tests, as necessary, with more agility.</p>
			<p>We'll learn how to use automated test tools to develop integration and end-to-end tests in the upcoming sections. Next, let's learn more about end-to-end tests.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor102"/>Understanding end-to-end testing</h2>
			<p>As the name suggests, an<a id="_idIndexMarker330"/> end-to-end test covers the user journey to execute a task from beginning to end. We need to perform the same actions an actual user must perform, validating the system integrity and alignment with requirements. </p>
			<p>For example, imagine that our CRM application has a feature to print the report on the reposts page. An end-to-end test to validate this scenario should cover the following steps:</p>
			<ol>
				<li value="1">Log into the application.</li>
				<li>Click on the reports menu.</li>
				<li>Wait for the charts to load and validate whether they were correctly rendered.</li>
				<li>Click on the print button.</li>
				<li>Open the generated PDF and validate the report.</li>
			</ol>
			<p>As you can see, this type of test involves several steps depending on the complexity of the system and the task. We can perform end-to-end tests manually following a test plan or automate this process using automated testing tools. </p>
			<p>End-to-end tests usually require robust testing tools and are written by <strong class="bold">quality assurance</strong> (<strong class="bold">QA</strong>) professionals. Still, we can write end-to-end tests during the development phase. This <a id="_idIndexMarker331"/>approach will reduce the issues during the QA phase and accelerate the fixing of issues. </p>
			<p>We'll learn how to use Puppeteer to write and automate end-to-end tests in the upcoming sections.</p>
			<p>Implementing software <a id="_idIndexMarker332"/>testing is an extensive subject. If you want to learn more about this topic, I recommend the article at <a href="https://www.ibm.com/topics/software-testing">https://www.ibm.com/topics/software-testing</a>.</p>
			<p>In this section, we discussed software testing by learning how to design integration and end-to-end tests. Next, you'll learn how to write tests in JavaScript projects using Jest.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor103"/>Writing tests with Jest</h1>
			<p>In<a id="_idIndexMarker333"/> this section, you'll learn how to write tests using the <strong class="bold">Jest framework</strong> in <a id="_idIndexMarker334"/> JavaScript projects.</p>
			<p>Jest is a fast and reliable test framework for JavaScript projects focusing on simplicity. It works with Babel, TypeScript, Node, React, Angular, Vue, and other tools. </p>
			<p>After installing it, we can start using Jest without any extra configuration. In our case, we can write a test and run the <strong class="source-inline">test</strong> command configured in our project without even installing Jest, as Umi already provides Jest with the <strong class="source-inline">umi-test</strong> package.</p>
			<p>Consider this end-to-end test written with Jest to test the login flow:</p>
			<p class="source-code"><strong class="bold">it('[END_TO_END] Should sucessfully login', async () =&gt; {</strong></p>
			<p class="source-code">  const page = await context.newPage();</p>
			<p class="source-code">  await page.goto('http://localhost:8000');</p>
			<p class="source-code">  await page.waitForNavigation();</p>
			<p class="source-code">  await page.type('#username', 'john@doe.com');</p>
			<p class="source-code">  await page.type('#password', 'user');</p>
			<p class="source-code">  await page.click('#loginbtn');</p>
			<p class="source-code">  const loggedUser = await page.waitForSelector('#loggeduser');</p>
			<p class="source-code">  <strong class="bold">expect(lo<a id="_idTextAnchor104"/>ggedUser).toBeTruthy();</strong></p>
			<p class="source-code">});</p>
			<p>In this test, all instructions are written inside the <strong class="source-inline">it</strong> method. You can also use the <strong class="source-inline">test</strong> method instead if you want. The difference between these two methods is just semantics.</p>
			<p>Here, the <strong class="source-inline">it</strong> method receives two arguments: the first argument is the test name and the second is an async function that executes the test instructions. </p>
			<p>Notice <a id="_idIndexMarker335"/>the <strong class="source-inline">expect</strong> method combined with the <strong class="source-inline">toBeTruthy</strong> <strong class="bold">matcher</strong> that we used to validate that the element with the <strong class="source-inline">loggeduser</strong> ID exists on the<a id="_idIndexMarker336"/> page. </p>
			<p>We use matchers to test values against different conditions. You can find a complete list of available Jest matchers<a id="_idIndexMarker337"/> at <a href="https://jestjs.io/docs/expect">https://jestjs.io/docs/expect</a>.</p>
			<p>Next, you'll see how to organize related tests by creating a test suite.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor105"/>Understanding the describe method</h2>
			<p>When writing multiple related tests, you should organize them within a test suite using the <strong class="source-inline">describe</strong> method, as in<a id="_idIndexMarker338"/> the following example:</p>
			<p class="source-code"><strong class="bold">describe('Math test suite', () =&gt; {</strong></p>
			<p class="source-code">  <strong class="bold">it('should return 2', () =&gt; {</strong></p>
			<p class="source-code">    const value = 1 + 1;</p>
			<p class="source-code">    expect(value).toBe(2);</p>
			<p class="source-code">  });</p>
			<p class="source-code">  <strong class="bold">it('should return 25', () =&gt; {</strong></p>
			<p class="source-code">    const value = 5 * 5;</p>
			<p class="source-code">    expect(value).toBe(25);</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>In this example, we used<a id="_idIndexMarker339"/> the <strong class="source-inline">describe</strong> method to create a group for two tests related to math problems.</p>
			<p>Let's see how we can execute some setup work before and after the entire test suite or each test run.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor106"/>Executing instructions before and after tests</h2>
			<p>Sometimes, you'll have some setup to do before running tests, such as initializing a database connection or generating mock data. You can do that by defining the instructions in the <strong class="source-inline">beforeAll</strong> method to execute before all the tests run or the <strong class="source-inline">beforeEach</strong> method to execute <a id="_idIndexMarker340"/>instructions before each test run. Consider the following example:</p>
			<p class="source-code">describe('Product test suite', () =&gt; {</p>
			<p class="source-code">  <strong class="bold">let connection: DBConnection;</strong></p>
			<p class="source-code">  <strong class="bold">let product: Product;</strong></p>
			<p class="source-code">  <strong class="bold">beforeAll(async () =&gt; {</strong></p>
			<p class="source-code">    <strong class="bold">connection = await database.connect();</strong></p>
			<p class="source-code">  <strong class="bold">});</strong></p>
			<p class="source-code">  <strong class="bold">beforeEach(async () =&gt; {</strong></p>
			<p class="source-code">    <strong class="bold">product = connection.query(query);</strong></p>
			<p class="source-code">  <strong class="bold">});</strong></p>
			<p class="source-code">  it('should be greater than 200', async () =&gt; {</p>
			<p class="source-code">    expect(product.units).toBeGreaterThan(200);</p>
			<p class="source-code">  });</p>
			<p class="source-code">  it('should be true', async () =&gt; {</p>
			<p class="source-code">    expect(product.active).toBeTruthy();</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>In this example, before all the <a id="_idIndexMarker341"/>tests ran, we opened the database connection, and before each test run, we used the connection to query the product in the database.</p>
			<p>Also, in this example, we need to <a id="_idIndexMarker342"/>close the database connection after running the test suite. We can do that by adding the <strong class="source-inline">afterAll</strong> method, as shown in the next example:</p>
			<p class="source-code"><strong class="bold">afterAll(() =&gt; connection.close());</strong></p>
			<p>Like the <strong class="source-inline">afterAll</strong> method, you can use the <strong class="source-inline">afterEach</strong> method to execute instructions after each test run.</p>
			<p>In this section, you learned how to write tests using the Jest framework. You learned how to create test suites and execute instructions before and after the tests run. </p>
			<p>Next, let's learn about Puppeteer and write integration and end-to-end tests for our application.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor107"/>Testing interfaces with Puppeteer</h1>
			<p>In this section, you'll learn how to write integration and end-to-end tests using <strong class="bold">Puppeteer</strong> and the <strong class="bold">Headless Chrome browser</strong>.</p>
			<p>Puppeteer is a <a id="_idIndexMarker343"/>Node library to control the Chrome, Chromium, or Firefox <a id="_idIndexMarker344"/>browser over the DevTools protocol (or remote protocol for Firefox), which<a id="_idIndexMarker345"/> makes it an excellent tool for simulating real scenarios during tests. </p>
			<p>When we launch a new browser instance, Puppeteer will default to using <strong class="bold">Chrome's headless mode</strong>. Chrome's headless mode<a id="_idIndexMarker346"/> only includes the browser engine, with no user interface. Puppeteer uses the Chrome DevTools protocol to control the browser. </p>
			<p>With Puppeteer, we<a id="_idIndexMarker347"/> can take screenshots of the page, test responsiveness <a id="_idIndexMarker348"/>by simulating numerous mobile devices, such as tablets and smartphones, and more.</p>
			<p>You can learn more about Puppeteer<a id="_idIndexMarker349"/> on the document page available at <a href="https://developers.google.com/web/tools/puppeteer">https://developers.google.com/web/tools/puppeteer</a>.</p>
			<p>We'll write an integration test and an end-to-end test to demonstrate the use of Puppeteer and Jest.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor108"/>Testing the access and layout plugins</h2>
			<p>Let's start by installing<a id="_idIndexMarker350"/> Puppeteer by running the following command:</p>
			<p class="source-code">yarn add -D puppeteer</p>
			<p>Puppeteer's configuration is as simple as Jest's. By running this command, Puppeteer will install the latest version of the Chromium browser, and we can start using it.</p>
			<p>Now, follow these steps to create the integration test:</p>
			<ol>
				<li value="1">Create a new folder named <strong class="source-inline">tests</strong> in the project's root folder.</li>
				<li>In the <strong class="source-inline">tests</strong> folder, create a new file named <strong class="source-inline">integration.test.ts</strong>. Jest will execute all files with a name that includes <strong class="source-inline">.test.ts</strong>.</li>
				<li>In the <strong class="source-inline">integration.test.ts</strong> file, create a test suite, as follows:<p class="source-code">import puppeteer, { Browser, BrowserContext, Page } from 'puppeteer';</p><p class="source-code">describe('[SUITE] Integration testing', () =&gt; {</p><p class="source-code">  <strong class="bold">let context: BrowserContext;</strong></p><p class="source-code">  <strong class="bold">let browser: Browser;</strong></p><p class="source-code">  <strong class="bold">beforeAll(async () =&gt; {</strong></p><p class="source-code">    <strong class="bold">browser = await puppeteer.launch();</strong></p><p class="source-code">  <strong class="bold">});</strong></p><p class="source-code">  <strong class="bold">beforeEach(async () =&gt; {</strong></p><p class="source-code">    <strong class="bold">context = </strong></p><p class="source-code"><strong class="bold">      await browser.createIncognitoBrowserContext();</strong></p><p class="source-code">  <strong class="bold">});</strong></p><p class="source-code">  <strong class="bold">afterEach(() =&gt; context.close());</strong></p><p class="source-code">  <strong class="bold">afterAll(() =&gt; browser.close());</strong></p><p class="source-code">});</p></li>
			</ol>
			<p>Here, before all <a id="_idIndexMarker351"/>tests run, we launch Puppeteer and store the instance in the <strong class="source-inline">browser</strong> variable. By default, Puppeteer will launch Chromium in headless mode. Still, you can launch the full browser version by setting the <strong class="source-inline">headless</strong> option, as follows:</p>
			<p class="source-code"><strong class="bold">browser = await puppeteer.launch({ headless: false });</strong></p>
			<p>By setting the <strong class="source-inline">headless</strong> option to <strong class="source-inline">false</strong>, you can see Puppeteer opening windows and executing the tests.</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_6.01_B18503.jpg" alt="Figure 6.1 – Running an integration test in the full browser version&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Running an integration test in the full browser version</p>
			<p>We create an <a id="_idIndexMarker352"/>anonymous browser context by opening an incognito window before each test run to execute them in an isolated environment and store the incognito window in the <strong class="source-inline">context</strong> variable. After each test run, we close the incognito window, and after the entire suite run, we close the browser.</p>
			<ol>
				<li value="4">You'll notice that TypeScript can't find Jest types. We must install the declaration file by running the following command:<p class="source-code"><strong class="bold">yarn add -D @types/jest</strong></p></li>
			</ol>
			<p>Now, let's create an integration test to ensure that the Umi access plugin correctly works with the layout plugin to show the 403 error page when unauthorized users try to access a restricted page.</p>
			<ol>
				<li value="5">Add the following test to the test suite in the <strong class="source-inline">integration.test.ts</strong> file under the <strong class="source-inline">tests</strong> folder:<p class="source-code">it('[INTEGRATION] Should successfully block unauthorized access (plugin-access)', async () =&gt; {</p><p class="source-code">  <strong class="bold">const page = await context.newPage();</strong></p><p class="source-code">  <strong class="bold">page.setDefaultTimeout(10000);</strong></p><p class="source-code">  <strong class="bold">await login(page);</strong></p><p class="source-code">  <strong class="bold">await page.goto('http://localhost:8000/workflow');</strong></p><p class="source-code">  <a id="_idTextAnchor109"/><strong class="bold">const message = </strong></p><p class="source-code"><strong class="bold">    await page.waitForSelector('#unauthorized');</strong></p><p class="source-code">  <strong class="bold">const value = await page.evaluate((el) =&gt; </strong></p><p class="source-code"><strong class="bold">    el.textContent, message);</strong></p><p class="source-code">  <strong class="bold">expect(value).toBe('Sorry, you are not authorized to </strong></p><p class="source-code"><strong class="bold">  access this page.');</strong></p><p class="source-code">});</p></li>
			</ol>
			<p>In this test, after<a id="_idIndexMarker353"/> opening a page and setting the default timeout for <strong class="source-inline">async</strong> operations to <strong class="source-inline">10000</strong> milliseconds, Puppeteer performs the following steps:</p>
			<ul>
				<li>Logs into the application as John Doe</li>
				<li>Goes to the workflow page</li>
				<li>Selects the element with the <strong class="source-inline">unauthorized</strong> ID</li>
				<li>Evaluates the text message inside the element and tests whether the message is correct</li>
			</ul>
			<p>Notice that we used the <strong class="source-inline">waitForSelector</strong> method to ensure that the element is already rendered when selecting it.</p>
			<ol>
				<li value="6">Next, we need to create the <strong class="source-inline">login</strong> function. Add the <strong class="source-inline">login</strong> function before the <strong class="source-inline">describe</strong> method, as follows:<p class="source-code">async function login(page: Page) {</p><p class="source-code">  await page.goto('http://loc<a id="_idTextAnchor110"/>alhost:8000');</p><p class="source-code">  <strong class="bold">await page.waitForNavigation();</strong></p><p class="source-code">  await page.type('#username', 'john@doe.com');</p><p class="source-code">  await page.type('#password', 'user');</p><p class="source-code">  await page.click('#loginbtn');</p><p class="source-code">}</p></li>
			</ol>
			<p>This function will <a id="_idIndexMarker354"/>perform the steps to log in to the application as John Doe. We can reuse the <strong class="source-inline">login</strong> function in other tests within the test suite. Notice we used the <strong class="source-inline">waitForNavigation</strong> method to ensure that the components are rendered before performing the steps.</p>
			<p>Now, we need to add the <strong class="source-inline">unauthorized</strong> ID to the element containing the text that we'll validate when running the test. </p>
			<ol>
				<li value="7">Open the <strong class="source-inline">app.tsx</strong> file located in the <strong class="source-inline">src</strong> folder and modify the layout <strong class="source-inline">unAccessible</strong> configuration option, as follows:<p class="source-code"><strong class="bold">unAccessible: (</strong></p><p class="source-code">  &lt;Result</p><p class="source-code">    status="403"</p><p class="source-code">    title="403"</p><p class="source-code">    subTitle={</p><p class="source-code">      <strong class="bold">&lt;span id="unauthorized"&gt;</strong></p><p class="source-code">        Sorry, you are not authorized to access this </p><p class="source-code">        page.</p><p class="source-code">      <strong class="bold">&lt;/span&gt;</strong></p><p class="source-code">    }</p><p class="source-code">    extra={</p><p class="source-code">      &lt;Button type="primary" onClick={() =&gt; </p><p class="source-code">        history.push('/')}&gt;</p><p class="source-code">        Back to Home</p><p class="source-code">      &lt;/Button&gt;</p><p class="source-code">    }</p><p class="source-code">  /&gt;</p><p class="source-code">),</p></li>
			</ol>
			<p>We enclosed the <a id="_idIndexMarker355"/>text with a <strong class="source-inline">span</strong> tag containing the <strong class="source-inline">id</strong> property we need.</p>
			<p>We also need to add the <strong class="source-inline">id</strong> properties to the login form inputs. </p>
			<ol>
				<li value="8">Open the <strong class="source-inline">index.tsx</strong> file located under <strong class="source-inline">src/pages/Login/LoginForm</strong> and modify the username input by adding the <strong class="source-inline">username</strong> ID, as follows:<p class="source-code">&lt;Form.Item</p><p class="source-code">  name="username"</p><p class="source-code">  rules={[</p><p class="source-code">    {</p><p class="source-code">      required: true,</p><p class="source-code">      message: formatMessage({ id: 'login.alert.username' }),</p><p class="source-code">    },</p><p class="source-code">  ]}</p><p class="source-code">&gt;</p><p class="source-code">  &lt;Input</p><p class="source-code">    <strong class="bold">id="username"</strong></p><p class="source-code">    prefix={&lt;UserOutlined className="site-form-item-icon" </p><p class="source-code">      /&gt;}</p><p class="source-code">    placeholder={formatMessage({ id: 'login.placeholder.</p><p class="source-code">      username' })}</p><p class="source-code">  /&gt;</p><p class="source-code">&lt;/Form.Item&gt;</p></li>
				<li>Next, modify the <a id="_idIndexMarker356"/>password input by adding the <strong class="source-inline">password</strong> ID, as follows:<p class="source-code">&lt;Form.Item</p><p class="source-code">  name="password"</p><p class="source-code">  rules={[</p><p class="source-code">    {</p><p class="source-code">      required: true,</p><p class="source-code">      message: formatMessage({ id: 'login.alert.password' </p><p class="source-code">        }),</p><p class="source-code">    },</p><p class="source-code">  ]}</p><p class="source-code">&gt;</p><p class="source-code">  &lt;Input</p><p class="source-code">    <strong class="bold">id="password"</strong></p><p class="source-code">    prefix={&lt;LockOutlined className="site-form-item-icon" </p><p class="source-code">      /&gt;}</p><p class="source-code">    type="password"</p><p class="source-code">    placeholder={formatMessage({ </p><p class="source-code">      id: 'login.placeholder.password' })}</p><p class="source-code">  /&gt;</p><p class="source-code">&lt;/Form.Item&gt;</p></li>
				<li>Finally, add<a id="_idIndexMarker357"/> the <strong class="source-inline">loginbtn</strong> ID to the login button, as follows:<p class="source-code">&lt;Form.Item&gt;</p><p class="source-code">  &lt;Button</p><p class="source-code">    <strong class="bold">id="loginbtn"</strong></p><p class="source-code">    type="primary"</p><p class="source-code">    htmlType="submit"</p><p class="source-code">    className="login-form-button"</p><p class="source-code">  &gt;</p><p class="source-code">    &lt;FormattedMessage id="login.form.login" /&gt;</p><p class="source-code">  &lt;/Button&gt;</p><p class="source-code">  &lt;FormattedMessage id="login.form.or" /&gt;{' '}</p><p class="source-code">  &lt;a href=""&gt;</p><p class="source-code">    &lt;FormattedMessage id="login.form.register" /&gt;!</p><p class="source-code">  &lt;/a&gt;</p><p class="source-code">&lt;/Form.Item&gt;</p></li>
			</ol>
			<p>You can execute the test by running the <strong class="source-inline">yarn test</strong> command. The result should look as in the following screenshot:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_6.02_B18503.jpg" alt="Figure 6.2 – Integration test result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Integration test result</p>
			<p>Now, let's create an end-to-end test to ensure that the feature for editing an opportunity works as expected.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor111"/>Testing the opportunity editing feature</h2>
			<p>Follow these <a id="_idIndexMarker358"/>steps to create the end-to-end test to ensure the editing feature works as expected on the opportunities page:</p>
			<ol>
				<li value="1">We'll create a separate file for end-to-end tests. In the <strong class="source-inline">tests</strong> folder, create a file named <strong class="source-inline">end2end.test.ts</strong>, and create the <strong class="source-inline">describe</strong> method, as follows:<p class="source-code">import puppeteer, { Browser, BrowserContext, Page } from 'puppeteer';</p><p class="source-code">describe('[SUITE] End-to-end testing', () =&gt; {</p><p class="source-code">  let context: BrowserContext;</p><p class="source-code">  let browser: Browser;</p><p class="source-code">  beforeAll(async () =&gt; {</p><p class="source-code">    browser = await puppeteer.launch();</p><p class="source-code">  });</p><p class="source-code">  beforeEach(async () =&gt; {</p><p class="source-code">    context = </p><p class="source-code">      await browser.createIncognitoBrowserContext();</p><p class="source-code">  });</p><p class="source-code">  afterEach(() =&gt; context.close());</p><p class="source-code">  afterAll(() =&gt; browser.close());</p><p class="source-code">});</p></li>
				<li>Next, add the end-to-end test to the <strong class="source-inline">describe</strong> method, as follows:<p class="source-code">it('[END_TO_END] Should sucessfully edit opportunity', async () =&gt; {</p><p class="source-code">  const page = await context.newPage();</p><p class="source-code">  page.setDefaultTimeout(10000);</p><p class="source-code">  <strong class="bold">await page.goto('http://localhost:8000');</strong></p><p class="source-code">  <strong class="bold">await page.waitForNavigation();</strong></p><p class="source-code">});</p></li>
			</ol>
			<p>We have written the instructions for Puppeteer to open a new page and set the default timeout to <strong class="source-inline">1000</strong>, go to the login page, and wait for the page to load.</p>
			<ol>
				<li value="3">Add the <a id="_idIndexMarker359"/>instructions to log into the application, as follows:<p class="source-code"><strong class="bold">await page.type('#username', 'john@doe.com');</strong></p><p class="source-code"><strong class="bold">await page.type('#password', 'user');</strong></p><p class="source-code"><strong class="bold">await page.click('#loginbtn');</strong></p><p class="source-code"><strong class="bold">await page.goto('http://localhost:8000/opportunities');</strong></p></li>
			</ol>
			<p>Puppeteer will type the user's email address in the input with the <strong class="source-inline">username</strong> ID and the password in the input with the <strong class="source-inline">password</strong> ID, then click on the button with the <strong class="source-inline">loginbtn</strong> ID. Finally, Puppeteer will navigate to the opportunities page.</p>
			<ol>
				<li value="4">Add the steps to edit the opportunity topic, as follows:<p class="source-code"><strong class="bold">await(await page.waitForSelector('#editopportunity')).click();</strong></p><p class="source-code"><strong class="bold">const topicInput = await page.$(</strong></p><p class="source-code"><strong class="bold">  'table &gt; tbody &gt; tr &gt; td &gt; div &gt; div &gt; div &gt; div &gt; span </strong></p><p class="source-code"><strong class="bold">  &gt; input',</strong></p><p class="source-code"><strong class="bold">);</strong></p><p class="source-code"><strong class="bold">await topicInput.click({ clickCount: 3 });</strong></p><p class="source-code"><strong class="bold">await topicInput.type('Opportunity topic');</strong></p><p class="source-code"><strong class="bold">await(await page.waitForSelector('#save')).click();</strong></p></li>
			</ol>
			<p>Puppeteer will wait for the element with the id equal to <strong class="source-inline">editopportunity</strong> to be rendered before clicking on it and selecting the text by triple-clicking the input element. Next, Puppeteer will type new text in the topic input and save the opportunity.</p>
			<ol>
				<li value="5">Now, let's <a id="_idIndexMarker360"/>add the steps to evaluate the result, as follows:<p class="source-code"><strong class="bold">const topicCell = await page.waitForSelector(</strong></p><p class="source-code"><strong class="bold">  'tr[data-row-key="0"] &gt; .ant-table-cell',</strong></p><p class="source-code"><strong class="bold">);</strong></p><p class="source-code"><strong class="bold">const value = await page.evaluate((el) =&gt; el.textContent, </strong></p><p class="source-code"><strong class="bold">  topicCell);</strong></p><p class="source-code"><strong class="bold">expect(value).toBe('Opportunity topic');</strong></p></li>
			</ol>
			<p>Puppeteer will select the topic cell in the first row of the opportunities table and evaluate its text content. Next, Jest will test the value to ensure it's correct.</p>
			<ol>
				<li value="6">Finally, let's add the <strong class="source-inline">id</strong> property to the elements we need to find during the test. In the <strong class="source-inline">columns.tsx</strong> file, under the <strong class="source-inline">pages/Opportunities</strong> folder, add the <strong class="source-inline">id</strong> property<a id="_idIndexMarker361"/> to the edit option anchor, as follows: <p class="source-code">{</p><p class="source-code">  title: &lt;FormattedMessage id="table.options" /&gt;,</p><p class="source-code">  valueType: 'option',</p><p class="source-code">  hideInSetting: true,</p><p class="source-code">  hideInDescriptions: true,</p><p class="source-code">  render: (_, record, __, action) =&gt; [</p><p class="source-code">    &lt;a</p><p class="source-code">      key="editable"</p><p class="source-code">      <strong class="bold">id="editopportunity"</strong></p><p class="source-code">      onClick={() =&gt; {</p><p class="source-code">      action?.startEditable(record.id as number);</p><p class="source-code">    }}</p><p class="source-code">    &gt;</p><p class="source-code">    &lt;FormattedMessage id="table.edit" /&gt;</p><p class="source-code">  &lt;/a&gt;,</p><p class="source-code">  &lt;a key="more" onClick={() =&gt; history.push(`/</p><p class="source-code">    opportunity/${record.id}`)}&gt;</p><p class="source-code">    &lt;FormattedMessage id="table.more" /&gt;</p><p class="source-code">  &lt;/a&gt;,</p><p class="source-code">  ],</p><p class="source-code">},</p></li>
				<li>In the <strong class="source-inline">index.ts</strong> file, in <a id="_idIndexMarker362"/>the same folder, add the <strong class="source-inline">saveText</strong> property to the editable attribute of the <strong class="source-inline">ProTable</strong> component, as follows:<p class="source-code">editable={{</p><p class="source-code">  type: 'multiple',</p><p class="source-code">  deletePopconfirmMessage: &lt;FormattedMessage </p><p class="source-code">    id="table.confirm" /&gt;,</p><p class="source-code">  <strong class="bold">saveText: &lt;span id="save"&gt;save&lt;/span&gt;,</strong></p><p class="source-code">  deleteText: &lt;FormattedMessage id="table.disable" /&gt;,</p><p class="source-code">  onDelete: async (key) =&gt; disable(key as string),</p><p class="source-code">  onSave: async (_, record) =&gt; update(record),</p><p class="source-code">}}</p></li>
			</ol>
			<p>Before executing the test, let's add the <strong class="source-inline">--runInBand</strong> flag to the <strong class="source-inline">umi-test</strong> command in the <strong class="source-inline">package.json</strong> file, as follows:</p>
			<p class="source-code"><strong class="bold">"test": "umi-test --runInBand",</strong></p>
			<p>This flag will <a id="_idIndexMarker363"/>prevent a race condition between these two tests as we are using the mock API to simulate the backend.</p>
			<p>Now, you can execute the test by running the <strong class="source-inline">yarn test</strong> command. The result should look like the following:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Figure_6.03_B18503.jpg" alt="Figure 6.3 – End-to-end test result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – End-to-end test result</p>
			<p>In this section, you learned how to write integration tests an<a id="_idTextAnchor112"/>d end-to-end tests using Puppeteer. To demonstrate the use of Puppeteer with Jest, we created an integration test to ensure the Umi locale plugin works correctly with the layout plugin to render the 403 error page. We also created an end-to-end test to ensure the feature to edit an opportunity works as expected.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor113"/>Summary</h1>
			<p>In this chapter, we discussed software testing by learning how to design integration and end-to-end tests. You learned how to use the Jest framework to write tests in React projects. You saw how to use the <strong class="source-inline">describe</strong> and <strong class="source-inline">test</strong> (or <strong class="source-inline">it</strong>) methods to write and organize related tests. You also learned how to execute instructions before and after tests run using the <strong class="source-inline">beforeAll</strong>, <strong class="source-inline">beforeEach</strong>, <strong class="source-inline">afterAll</strong>, and <strong class="source-inline">afterEach</strong> methods.</p>
			<p>You then learned how to write tests using Puppeteer and Headless Chrome by simulating user interaction on your interface. To demonstrate the use of Puppeteer with Jest, we created an integration test to ensure the Umi locale plugin works correctly with the layout plugin and also created an end-to-end test to ensure the feature to edit an opportunity works as expected.</p>
			<p>In the next chapter, we will learn how to compile and deploy our applications to online services.</p>
		</div>
	</body></html>