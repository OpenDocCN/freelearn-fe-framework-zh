- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to its components, React makes it easy to test our applications. There
    are many different tools available that we can use to create tests with React.
    In this chapter, we will cover the most popular ones to understand the benefits
    they provide.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jest** is an *all-in-one* testing framework solution maintained by Christoph
    Nakazawa from Meta and contributors within the community and aims to give you
    the best developer experience.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to create a test environment from
    scratch and write tests for your application’s components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why it is important to test our applications and how they help developers move
    faster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up a Jest environment to test components using Enzyme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the React Testing Library is and why it is a *must-have* for testing React
    applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to test events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement Vitest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React DevTools and some error-handling techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 19+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter in the book’s GitHub repository: [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter16).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the benefits of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing web UIs has always been a difficult job. From unit to end-to-end tests,
    the fact that the interfaces depend on browsers, user interactions, and many other
    variables makes it difficult to implement an effective testing strategy.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever tried to write end-to-end tests for the web, you’ll know how
    complex it is to get consistent results and how the results are often affected
    by false negatives due to different factors, such as the network. Other than that,
    user interfaces are frequently updated to improve the experience, maximize conversions,
    or simply add new features.
  prefs: []
  type: TYPE_NORMAL
- en: If tests are hard to write and maintain, developers are less prone to cover
    their applications. On the other hand, tests are important because they make developers
    more confident with their code, which is reflected in speed and quality. If a
    piece of code is well tested (and the tests are well written), developers can
    be sure that it works and is ready to ship. Similarly, thanks to tests, it becomes
    easier to refactor the code because tests guarantee that the functionalities do
    not change during the rewrite.
  prefs: []
  type: TYPE_NORMAL
- en: Developers tend to focus on the feature they are currently implementing, and
    sometimes it is hard to know if other parts of the application are affected by
    those changes. Tests help to avoid regressions because they can tell if the new
    code breaks the old tests. Greater confidence in writing new features leads to
    faster releases.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the main functionalities of an application makes the code base more
    solid, and whenever a new bug is found, it can be reproduced, fixed, and covered
    by tests so that it does not happen again in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, React (and the component era) makes testing user interfaces easy and
    efficient. Testing components, or trees of components, is a less arduous job because
    every single part of the application has its responsibilities and boundaries.
    If components are built in the right way, if they are pure and aim for composability
    and reusability, they can be tested as simple functions.
  prefs: []
  type: TYPE_NORMAL
- en: Another great power that modern tools bring us is the ability to run tests using
    Node.js and the console. Spinning up a browser for every single test makes tests
    slower and less predictable, degrading the developer experience; instead, running
    the tests using the console is faster.
  prefs: []
  type: TYPE_NORMAL
- en: Testing components only in the console can sometimes give unexpected behaviors
    when they are rendered in a real browser, but in my experience, this is rare.
    When we test React components, we want to make sure that they work properly and
    that, given different sets of props, their output is always correct.
  prefs: []
  type: TYPE_NORMAL
- en: We may also want to cover all the various states that a component can have.
    The state might change by clicking a button, so we write tests to check if all
    the event handlers are doing what they are supposed to do.
  prefs: []
  type: TYPE_NORMAL
- en: When all the functionalities of the component are covered, but we want to do
    more, we can write tests to verify the component’s behavior on **edge cases**.
    Edge cases are states that the component can assume when, for example, all the
    props are null or there is an error. Once the tests are written, we can be pretty
    confident that the component behaves as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a single component is great, but it does not guarantee that multiple
    individually tested components will still work once they are put together. As
    we will see later, with React, we can mount a tree of components and test the
    integration between them.
  prefs: []
  type: TYPE_NORMAL
- en: There are different techniques that we can use to write tests, and one of the
    most popular ones is **test-driven development** (**TDD**). Applying TDD means
    writing the tests first and then writing the code to pass the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Following this pattern helps us to write better code because we are forced to
    think more about the design before implementing the functionalities, which usually
    leads to higher quality.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we have covered all of this, let’s roll up our sleeves and start
    writing tests for our React components. We will also learn about a cool way of
    writing code called test-driven development and use a handy tool called Jest to
    simplify our JavaScript testing. Are you ready? Let’s dive in and start working
    with real code!
  prefs: []
  type: TYPE_NORMAL
- en: Painless JavaScript testing with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important way to learn how to test React components in the right way
    is by writing some code, and that is what we are going to do in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The React documentation says that Facebook uses Jest to tests its components.
    However, React does not force you to use a particular test framework, and you
    can use your favorite one without any problems. To see Jest in action, we are
    going to create a project from scratch, install all the dependencies, and write
    a component with some tests. It’ll be fun!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to move into a new folder and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `package.json` is created, we can start installing the dependencies, with
    the first one being the `jest` package itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To tell `npm` that we want to use the `jest` command to run the tests, we must
    add the following scripts to `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To write components and tests using ES6 and JSX, we must install all Babel-related
    packages so that Jest can use them to transpile and understand the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second set of dependencies is installed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you may know, we now have to create a `.babelrc` file, which is used by Babel
    to know the presets and the plugins that we would like to use inside the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.babelrc` file looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is time to install React and ReactDOM, which we need to create and
    render components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The setup is ready, and we can run Jest against the ES6 code and render our
    components in the DOM, but there is one more thing to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to install `jest-environment-jsdom`, `@testing-library/jest-dom`, and
    `@testing-library/react`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have installed these packages, you must create the `jest.config.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let’s create the `setUpTests.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s imagine we have a `Hello` component (`src/components/Hello/index.tsx`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test this component, we need to create a file with the same name
    but add the `.test` (or `.spec`) suffix to the new file. This will be our test
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in order to run the test, you need to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_16_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: npm test'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **PASS** label means that all tests have been passed successfully; if at
    least one test failed, you will see the **FAIL** label. Let’s change one of our
    tests to make it fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_16_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: Fail tests'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the **FAIL** label is specified with an **X**. Also, the expected
    and received values provide useful information, and you can see which value is
    expected and which value is received.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see the coverage percentage of all your unit tests, you can
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_16_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: Passing tests'
  prefs: []
  type: TYPE_NORMAL
- en: 'The coverage also generates an HTML version of the result; it creates a directory
    called `coverage` and inside another called `Icov-report`. If you open the `index.xhtml`
    file in your browser, you will see the HTML version as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, table  Description automatically generated](img/B18414_16_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: Icov-report'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have done your first tests and you know how to collect the coverage
    data, let’s see how we can test events in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Events are very common in any web application, and we need to test them as
    well, so let’s learn how to test events. For this, let’s create a new `ShowInformation`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create the test file at `src/components/ShowInformation/index.test.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the test and it works fine, you should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_16_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: Passing tests'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Vitest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Vitest** is a unit test framework built on **Vite**, designed for speed and
    minimal configuration. It serves as a replacement for various testing tools such
    as Jest, Mocha, and Chai. Since Vitest is built on top of the Jest API, if you
    already know how to use Jest, it works in a similar manner.'
  prefs: []
  type: TYPE_NORMAL
- en: In this context, we will utilize Vite, a build tool that aims to provide a fast
    and lean development experience for modern web projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, you need to install Vite globally with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After it’s installed, you need to create your first project with the `npm`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It will ask you for the project name. You can use `my-first-vite-project`,
    then for the framework you want to use (`React`), and finally, choose the variant
    (`TypeScript`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_16_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.6: npm create vite@latest'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to install the project dependencies and run the `npm run dev`
    command. If you do so, you will see something similar to the following on port
    `5173`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_16_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.7: Vite app'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Vitest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have your Vite app running, it is time to install Vitest. To do so,
    you simply need to run this command in your project terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After you’ve installed Vitest, you need to modify the `vite.config.ts` file
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we will use the `jsdom` environment, so you’ll need to install
    it as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, Vitest offers a plugin called Vitest UI, which enables Vitest
    to provide a visually appealing user interface for viewing and interacting with
    your tests in the browser. While it is an optional plugin, we will be using it.
    You can install it by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test your code, you need to add the test script to your `package.json`
    file using the `vitest --ui` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be using the same `Hello` component that we used for Jest, although
    there will be a few differences. You need to save this component at `src/components/Hello/index.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you need to create a test file called `index.test.tsx` under the same
    component directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code is quite similar to Jest. However, one of the main
    differences is that we are now importing all the testing methods we will use,
    such as `afterAll`, `describe`, `expect`, and `it`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the `test` command, you should see something similar to this in
    your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_16_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.8: npm test'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have noticed, there is a link that is generated by the Vitest UI plugin
    we installed earlier. If you click on that link, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_16_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.9: Vitest UI'
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, we only have one test file, but if you add more, you will see them
    listed on the sidebar on the left. Now, let’s click on our current `Hello` test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_16_10.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.10 – Report
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be able to see the test cases that are passing correctly. However,
    one of the most interesting advantages of this UI plugin is that you can even
    modify the test code directly in the browser by clicking on the **Code** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_16_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.11: Code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify our code to intentionally cause some tests to fail. You can change
    the first test to say `"Hello Foo"` instead of `"Hello World"` and make sure to
    save it (*Cmd + S*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_16_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.12: Failing test'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, now our first test fails because it is unable to find the `"Hello
    Foo"` text.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling globals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Personally, I prefer importing all the necessary functions or variables in a
    file. However, I am aware that when creating numerous test files, repeatedly importing
    global testing variables like `describe`, `it`, `expect`, and so on, can become
    tedious and cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Vitest offers a configuration option to enable `globals`, eliminating
    the need to import them every time. To enable this feature, you need to modify
    your `vite.config.ts` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After making the changes mentioned earlier, you also need to update your `tsconfig.json`
    file by adding the global types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After following these steps, you will now be able to remove the import of the
    `globals` in your test file. If you still encounter any TypeScript errors, it
    is likely that you will need to restart your TypeScript server or reload the window
    in your VSCode.
  prefs: []
  type: TYPE_NORMAL
- en: In-source testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vitest also offers a way to run tests within your source code alongside the
    implementation, similar to Rust’s module tests.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I have an old-school approach, and I usually prefer to have a separate
    test file for my testing. However, there are situations where the component or
    functions being tested are very small, and creating a new test file may seem excessive.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable this feature, you need to modify your `vite.config.ts` file and add
    the `includeSource` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To resolve the TypeScript issues, you need to make another change by adding
    the `vitest/importMeta` type to your `tsconfig.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s move our `Hello` component test file inside the same `Hello` component.
    Again, this is optional and is just to demonstrate that it is possible to do so.
    In the end, you can decide which testing approach to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we need to add an `if` statement inside our `Hello` component
    to check if we are in testing mode. We can accomplish this with the following
    code: `if (import.meta.vitest)`. Inside this block, we will move all the testing
    cases, and we will also require the **React Testing Library** methods only within
    that block. This way, our code will resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now you can delete your previous file (`index.test.tsx`). If you run your tests
    again, they should work the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference is that now you will be able to see the entire code (`Component`
    and `Test` cases):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_16_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.13: Passing test'
  prefs: []
  type: TYPE_NORMAL
- en: This approach may potentially speed up the testing process for a component or
    a function. However, personally, I still prefer to perform testing in a separate
    test file. Nevertheless, you are free to choose what works best for you and your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: After exploring the concept of in-source testing, let’s proceed to understand
    how React DevTools can be effectively applied in our development process to optimize
    our application’s performance and ensure it runs smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Using React DevTools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When testing in the console is not enough, and we want to inspect our application
    while it is running inside the browser, we can use React DevTools.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install this as a Chrome extension at the following URL: [https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgo
    fadopljbjfkapdkoienihi?hl=en](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en).'
  prefs: []
  type: TYPE_NORMAL
- en: The installation adds a tab to the Chrome DevTools called **React**, where you
    can inspect the rendered tree of components and check which properties they have
    received and what their state is at a particular point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Props and states can be read, and they can be changed in real time to trigger
    updates in the UI and see the results straight away. This is a must-have tool,
    and in the most recent versions, it has a new feature that can be enabled by checking
    the **Trace React Updates** checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: When this functionality is enabled, we can use our application and see which
    components get updated when we perform a particular action. The updated components
    are highlighted with colored rectangles, and it becomes easy to spot possible
    optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Using Redux DevTools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are using Redux in your application, you probably want to use Redux
    DevTools to be able to debug your Redux flow. You can install it at the following
    URL: [https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=es](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=es)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you need to install the `redux-devtools-extension` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Once you have installed React DevTools and Redux DevTools, you will need to
    configure them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to use Redux DevTools directly, it won’t work; this is because we
    need to pass the `composeWithDevTools` method into the Redux store; this should
    be the `configureStore.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is the best tool to test our Redux applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you gained a comprehensive understanding of the benefits of
    testing, as well as the various frameworks and tools available for testing React
    components. You learned how to implement and test components and events using
    the React Testing Library and how to use Jest coverage to optimize your testing
    process. Additionally, you explored tools such as React DevTools and Redux DevTools
    to further enhance your development experience. It’s important to keep in mind
    common solutions when it comes to testing complex components, such as higher-order
    components or forms with multiple nested fields, to ensure that your tests accurately
    reflect the functionality of your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to deploy your application to production.
  prefs: []
  type: TYPE_NORMAL
