- en: 'Chapter 5: Code Style and Formatting Tools'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：代码风格和格式化工具
- en: In addition to meeting business requirements, a professional frontend project
    should feature clean source code that is easy to maintain and extend.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除了满足业务需求外，一个专业的前端项目还应具备易于维护和扩展的干净源代码。
- en: In this chapter, we'll discuss code style and consistency. Next, you'll learn
    how to use **Prettier** and **EditorConfig** to enforce standard code formatting
    in teams with multiple members working with various **integrated development environments**
    (**IDEs**) and editors. Finally, we'll add **ESLint** to our project and configure
    it to work with Prettier and improve your code quality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论代码风格和一致性。接下来，您将学习如何使用**Prettier**和**EditorConfig**在拥有多个成员且使用各种**集成开发环境**（**IDEs**）和编辑器的团队中强制执行标准的代码格式。最后，我们将把**ESLint**添加到我们的项目中，并配置它与Prettier一起工作以提高代码质量。
- en: 'In this chapter, we''ll cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding code style and consistency
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代码风格和一致性
- en: Working with EditorConfig and Prettier
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与EditorConfig和Prettier协作
- en: Configuring ESLint and Prettier
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置ESLint和Prettier
- en: By the end of this chapter, you'll have learned how to configure Prettier and
    EditorConfig, avoiding conflicts and redundancy. You'll also have learned how
    to configure ESLint to improve the code quality and Prettier to format the code
    in the same project, avoiding conflicts between these two tools.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将学会如何配置Prettier和EditorConfig，避免冲突和冗余。您还将学会如何配置ESLint来提高代码质量，并使用Prettier在同一个项目中格式化代码，避免这两个工具之间的冲突。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter's exercises, you only need a computer with any OS (I
    recommend Ubuntu 20.04 or higher) and the software installed in [*Chapter 1*](B18503_01_Final_JM_ePub.xhtml#_idTextAnchor014)*,
    Environment Setup and Introduction to UmiJS* (VS Code, Node.js, and Yarn).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的练习，您只需要一台安装了任何操作系统（我推荐Ubuntu 20.04或更高版本）的计算机以及[*第1章*](B18503_01_Final_JM_ePub.xhtml#_idTextAnchor014)*，环境设置和UmiJS简介*（VS
    Code、Node.js和Yarn）的软件。
- en: You can find the complete project in the `Chapter05` folder in the GitHub repository
    available at [https://github.com/PacktPublishing/Enterprise-React-Development-with-UmiJs](https://github.com/PacktPublishing/Enterprise-React-Development-with-UmiJs).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub仓库中找到完整的项目，该仓库位于[https://github.com/PacktPublishing/Enterprise-React-Development-with-UmiJs](https://github.com/PacktPublishing/Enterprise-React-Development-with-UmiJs)的`Chapter05`文件夹中。
- en: Understanding code style and consistency
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解代码风格和一致性
- en: In this section, we'll discuss code style with some examples, so you will be
    able to understand why it's essential to use tools such as **Prettier**, **EditorConfig**,
    and **ESLint** when working on large enterprise projects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一些示例讨论代码风格，这样您就能理解为什么在处理大型企业项目时使用**Prettier**、**EditorConfig**和**ESLint**等工具是至关重要的。
- en: We will not discuss JavaScript code conventions, but if you want to revise this
    topic, I recommend you read the *Mozilla Developer Network JavaScript Guidelines*
    at [https://developer.mozilla.org/en-US/docs/MDN/Guidelines/Code_guidelines/JavaScript](https://developer.mozilla.org/en-US/docs/MDN/Guidelines/Code_guidelines/JavaScript).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会讨论JavaScript代码约定，但如果您想复习这个主题，我建议您阅读[https://developer.mozilla.org/en-US/docs/MDN/Guidelines/Code_guidelines/JavaScript](https://developer.mozilla.org/en-US/docs/MDN/Guidelines/Code_guidelines/JavaScript)上的*Mozilla开发者网络JavaScript指南*。
- en: 'Each developer has their preferences when deciding how to format code. Even
    when following a specific language convention, some decisions about the code formatting
    can divide developers. Consider the following function invocation example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每位开发者在决定如何格式化代码时都有自己的偏好。即使遵循特定的语言约定，关于代码格式的某些决定也可能使开发者产生分歧。考虑以下函数调用示例：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we invoke the function by passing the arguments inline. In some cases,
    when passing more arguments, you may need to break down the function call, and
    you can do that in different ways. Consider the following example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过传递参数的方式调用函数。在某些情况下，当传递更多参数时，您可能需要分解函数调用，并且您可以通过不同的方式来完成。考虑以下示例：
- en: '![Figure 5.1 – Breaking down a function call in three different styles'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – 以三种不同的风格分解函数调用'
- en: '](img/Figure_5.01_B18503.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.01_B18503.jpg)'
- en: Figure 5.1 – Breaking down a function call in three different styles
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 以三种不同的风格分解函数调用
- en: 'Here, we broke down the same function call using three distinct styles: hug
    the last parenthesis, align the parentheses, and align the arguments. Now imagine
    that the first argument is another function call; the complexity starts to grow.
    Consider another example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以三种不同的风格分解了相同的函数调用：紧贴最后一个括号、对齐括号和对齐参数。现在想象一下，第一个参数又是一个函数调用；复杂性开始增加。考虑另一个例子：
- en: '![Figure 5.2 – Breaking down functions and inner functions'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.2 – Breaking down functions and inner functions](img/Figure_5.02_B18503.jpg)'
- en: '](img/Figure_5.02_B18503.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.02 – Breaking down functions and inner functions](img/Figure_5.02_B18503.jpg)'
- en: Figure 5.2 – Breaking down functions and inner functions
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 分解函数和内部函数
- en: Here, we broke down the function and inner function calls using three different
    code styles. You may have noticed that each approach drastically changes the code
    style. As more developers work on the code and use different styles, the code
    base will become unclean, unprofessional, and hard to read.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用三种不同的代码风格分解了函数和内部函数调用。你可能已经注意到，每种方法都极大地改变了代码风格。随着更多开发者参与代码并使用不同的风格，代码库将变得不整洁、不专业且难以阅读。
- en: 'Some of the style decisions can also make the code harder to understand. Consider
    the following example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一些风格决策也可能使代码更难以理解。考虑以下例子：
- en: '![Figure 5.3 – Conditional ternary operator with and without parentheses'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.3 – Conditional ternary operator with and without parentheses](img/Figure_5.03_B18503.jpg)'
- en: '](img/Figure_5.03_B18503.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.03 – Breaking down functions and inner functions](img/Figure_5.03_B18503.jpg)'
- en: Figure 5.3 – Conditional ternary operator with and without parentheses
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 带括号和不带括号的条件三元运算符
- en: 'Here, we used the conditional ternary operator with two different styles: without
    parentheses and enclosing with parentheses. Using parentheses in complex conditions
    makes the code easier to read and understand.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了两种不同的风格来使用条件三元运算符：不带括号和带括号包围。在复杂条件下使用括号可以使代码更容易阅读和理解。
- en: The professional approach to developing clean and consistent code when working
    with large projects and multiple team members is to define a standard code style
    that every developer must follow. The code style should be discussed and documented
    so that every developer knows how to use it. This approach introduces other challenges,
    however, as we need to ensure that all developers follow the code style. Probably,
    you will end up reviewing the code to fix code style issues, which is a waste
    of time and money as it doesn't deliver value to the customer.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当与大型项目和多个团队成员一起工作时，专业的方法是定义一个标准代码风格，每个开发者都必须遵循。代码风格应该被讨论和记录，以便每个开发者都知道如何使用它。然而，这种方法也引入了其他挑战，因为我们需要确保所有开发者都遵循代码风格。可能的结果是你将不得不审查代码以修复代码风格问题，这既浪费时间又浪费金钱，因为它没有为客户带来价值。
- en: To avoid spending time reviewing code only to fix code style issues, we can
    use formatting tools that enforce the code style.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免花费时间审查代码只是为了修复代码风格问题，我们可以使用强制代码风格的格式化工具。
- en: 'You can use numerous tools to enforce code style and consistency in JavaScript
    projects. In the coming sections, we will focus on three tools that solve the
    problems mentioned previously. We will look at the following three tools:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用众多工具来强制 JavaScript 项目的代码风格和一致性。在接下来的章节中，我们将重点关注三个解决前面提到的问题的工具。我们将查看以下三个工具：
- en: Prettier, a formatting tool that can parse and format JavaScript, LESS style
    sheets, JSX components, and more
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prettier，一个可以解析和格式化 JavaScript、LESS 样式表、JSX 组件等格式的格式化工具
- en: EditorConfig, a tool for enforcing a default code format that almost any IDE
    can follow
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EditorConfig，一个强制默认代码格式的工具，几乎任何 IDE 都可以遵循
- en: ESLint, a tool for formatting and fixing code and finding quality-related issues
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ESLint，一个用于格式化、修复代码和查找质量相关问题的工具
- en: In this section, we discussed different code styles by seeing examples and understanding
    why we need to implement tools and strategies to enforce a consistent code style
    when working on large projects with multiple team members.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过查看示例并理解为什么在多个团队成员的大型项目中实施工具和策略来强制一致的代码风格时需要实施工具和策略。
- en: Now, let's take a closer look at Prettier and EditorConfig to see how these
    two tools can work together to solve the code style problem.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看看 Prettier 和 EditorConfig，看看这两个工具如何协同工作来解决代码风格问题。
- en: Working with EditorConfig and Prettier
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 EditorConfig 和 Prettier
- en: In this section, you'll learn how **Prettier** and **EditorConfig** can work
    together to enforce the code style across IDEs and developers' code and how to
    prevent redundancy when configuring these tools.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解**Prettier**和**EditorConfig**如何协同工作以在IDEs和开发者的代码中强制执行代码风格，以及如何防止配置这些工具时的冗余。
- en: Let's start by learning how EditorConfig works.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习EditorConfig的工作原理开始。
- en: Working with EditorConfig
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与EditorConfig一起工作
- en: EditorConfig consists of a format file and a set of plugins that ensure almost
    any IDE or editor follows the code style you have defined as you type. In some
    cases, you don't even need to install any extensions as various IDEs and editors
    come with native support for EditorConfig. You can read more about EditorConfig
    at [https://editorconfig.org/](https://editorconfig.org/).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: EditorConfig由一个格式文件和一组插件组成，确保几乎任何IDE或编辑器都能遵循你在输入时定义的代码风格。在某些情况下，你甚至不需要安装任何扩展，因为各种IDE和编辑器都自带对EditorConfig的原生支持。你可以在[https://editorconfig.org/](https://editorconfig.org/)了解更多关于EditorConfig的信息。
- en: 'Let''s take the example of the format file that comes with the **umi-app**
    template, which we used to start our project from scratch:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以**umi-app**模板中包含的格式文件为例，我们使用它从头开始启动我们的项目：
- en: .editorconfig
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: .editorconfig
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We used the following options in our project:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们使用了以下选项：
- en: '`root`: We used this option to tell EditorConfig that we are in the `root`
    folder, and it doesn''t need to search for `.editorconfig` files in any other
    folders.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root`: 我们使用此选项告诉EditorConfig我们处于`root`文件夹中，并且它不需要在任意其他文件夹中搜索`.editorconfig`文件。'
- en: '`[*]`: We used this wildcard pattern to apply the following options to every
    file in the project.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[*]`: 我们使用这个通配符模式将以下选项应用于项目中的每个文件。'
- en: '`indent_style`: We used this option to define indentation using spaces instead
    of tabs.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indent_style`: 我们使用此选项来定义使用空格而不是制表符进行缩进。'
- en: '`indent_size`: We used this option to define two spaces for indentation.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indent_size`: 我们使用此选项来定义缩进为两个空格。'
- en: '`end_of_line`: This option sets which control character we want to use to mark
    a line break. We choose the **line feed** (**LF**) character (0x0A).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end_of_line`: 此选项设置我们想要用于标记行断的控制字符。我们选择**换行符**（**LF**）字符（0x0A）。'
- en: The default control character can vary depending on the IDE or editor. Also,
    IDEs don't render this kind of character, so it's essential to use this option
    to ensure consistency across IDEs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的控制字符可能因IDE或编辑器而异。此外，IDEs不会渲染这类字符，因此使用此选项确保跨IDE的一致性至关重要。
- en: '`charset`: We used this option to define the character set as `utf-8`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`charset`: 我们使用此选项来定义字符集为`utf-8`。'
- en: '`trim_trailing_whitespace`: We set this option to `true` to remove any whitespace
    characters before new lines.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trim_trailing_whitespace`: 我们将此选项设置为`true`以删除新行之前的任何空白字符。'
- en: '`insert_final_newline`: We used this option to ensure all files end with a
    new line.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert_final_newline`: 我们使用此选项来确保所有文件都以新行结束。'
- en: '`[*.md]`: We used this wildcard pattern to apply the following option to the
    `README.md` file and other documentation defined using markdown.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[*.md]`: 我们使用这个通配符模式将以下选项应用于`README.md`文件以及其他使用Markdown定义的文档。'
- en: '`trim_trailing_whitespace`: We set this option to `false` to ensure whitespaces
    exist before new lines.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trim_trailing_whitespace`: 我们将此选项设置为`false`以确保在新行之前存在空白字符。'
- en: '`[Makefile]`: We used this wildcard pattern to apply the following option to
    any `Makefile` present in the project.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Makefile]`: 我们使用这个通配符模式将以下选项应用于项目中存在的任何`Makefile`。'
- en: We usually create commands and logic in `Makefile` and use the **make** utility
    to build and compile the application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常在`Makefile`中创建命令和逻辑，并使用**make**实用程序来构建和编译应用程序。
- en: 'You can read more about this tool at: [https://www.gnu.org/software/make/](https://www.gnu.org/software/make/).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解更多关于这个工具的信息：[https://www.gnu.org/software/make/](https://www.gnu.org/software/make/).
- en: '`indent_style`: Here, we used this option to define the indentation using tabs.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indent_style`: 在这里，我们使用此选项来定义使用制表符进行缩进。'
- en: As you may have noticed, we can control every critical aspect of the code style
    and customize the formatting for each resource type in our project using EditorConfig.
    All this configuration works across IDEs and editors so that the code style will
    be consistent no matter what the developers' preferences are.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，我们可以使用EditorConfig控制代码风格的每个关键方面，并为我们项目中的每种资源类型自定义格式化。所有这些配置都在IDEs和编辑器中工作，以确保代码风格的一致性，无论开发者的偏好如何。
- en: Next, we'll see Prettier, another tool that works well with EditorConfig, to
    enforce the code style and consistency.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到另一个与EditorConfig配合得很好的工具Prettier，以强制执行代码风格和一致性。
- en: Working with Prettier
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与Prettier一起工作
- en: Prettier is a code formatting tool that supports numerous JavaScript frameworks,
    style sheet extensions, markup languages, and configuration files.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Prettier 是一个支持众多 JavaScript 框架、样式表扩展、标记语言和配置文件的代码格式化工具。
- en: As you know, we have been using Prettier since [*Chapter 1*](B18503_01_Final_JM_ePub.xhtml#_idTextAnchor014)*,
    Environment Setup and Introduction to UmiJS*. We configured VS Code to use Prettier
    to format the code on saving and pasting.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，我们自从[*第一章*](B18503_01_Final_JM_ePub.xhtml#_idTextAnchor014)*，环境设置和 UmiJS
    简介*以来一直在使用 Prettier。我们配置了 VS Code 在保存和粘贴时使用 Prettier 格式化代码。
- en: In our project, EditorConfig and Prettier share the responsibility to enforce
    the code style but with different approaches. While EditorConfig overrides the
    code style of the IDE or editor and ensures that the code is correctly formatted
    as you type, Prettier applies a standard code style after the developer types
    the code, replacing the styles with a standard code style defined by Prettier.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，EditorConfig 和 Prettier 共同承担着强制执行代码格式的责任，但采用的方法不同。当 EditorConfig 覆盖
    IDE 或编辑器的代码风格并确保代码在输入时正确格式化时，Prettier 在开发者输入代码后应用标准代码风格，用 Prettier 定义的标准化代码风格替换原有风格。
- en: When using Prettier, the developer doesn't need to worry about following a specific
    code style; they can focus on defining interfaces and developing business rules.
    Prettier will do the job of formatting the code with a consistent code style,
    and almost all debates about the team's code style are no longer necessary.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Prettier 时，开发者不需要担心遵循特定的代码风格；他们可以专注于定义接口和开发业务规则。Prettier 将使用一致的代码风格格式化代码，并且几乎不再需要团队就代码风格进行辩论。
- en: 'Although Prettier doesn''t require a lot of configurations, there are some
    options we can define in the `.prettierrc` file. Let''s take a closer look at
    our project''s configuration:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Prettier 不需要很多配置，但在 `.prettierrc` 文件中我们可以定义一些选项。让我们更仔细地看看我们项目的配置：
- en: .prettierrc
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`.prettierrc`'
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These are the options defined in the `.prettierrc` file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 `.prettierrc` 文件中定义的选项：
- en: '`singleQuote`: We used this option to use single quotes instead of double quotes
    in our code, except when writing in JSX files, which skip this option and use
    double quotes.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`singleQuote`：我们使用这个选项在我们的代码中使用单引号而不是双引号，除非在编写 JSX 文件时，该选项被跳过并使用双引号。'
- en: '`trailingComma`: We used this option to print trailing commas wherever possible
    in our code.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trailingComma`：我们使用这个选项在可能的情况下在我们的代码中打印尾随逗号。'
- en: '`printWidth`: We used this option to define the maximum line length before
    Prettier breaks the line.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printWidth`：我们使用这个选项来定义 Prettier 在断行之前的最大行长度。'
- en: '`overrides`: This option is similar to the wildcard pattern from EditorConfig.
    In this option, we can override the options for specific files. Here, we configured
    Prettier to use the `JSON parser` specifically for the `.prettierrc` file.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`overrides`：这个选项类似于 EditorConfig 中的通配符模式。在这个选项中，我们可以覆盖特定文件的选项。在这里，我们配置了 Prettier
    专门为 `.prettierrc` 文件使用 `JSON parser`。'
- en: The options you can set in `.prettierrc` are limited because Prettier enforces
    its standard code style. You can find other options in the Prettier documentation
    at [https://prettier.io/docs/en/options.html](https://prettier.io/docs/en/options.html).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `.prettierrc` 文件中设置的选项有限，因为 Prettier 强制执行其标准代码风格。你可以在 Prettier 文档中找到其他选项，网址为
    [https://prettier.io/docs/en/options.html](https://prettier.io/docs/en/options.html)。
- en: When using Prettier and EditorConfig in the same project, you need to avoid
    setting redundant options between these two tools. A good approach is to put only
    relevant options to override IDE and editor code style in the `.editorconfig`
    file and ensure that you are not repeating these options in the `.prettierrc`
    file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当在同一个项目中使用 Prettier 和 EditorConfig 时，你需要避免在这两个工具之间设置冗余的选项。一种好的方法是只将相关选项放入 `.editorconfig`
    文件中，以覆盖 IDE 和编辑器的代码风格，并确保你不在 `.prettierrc` 文件中重复这些选项。
- en: You can see that, in our project, all the configurations in EditorConfig are
    different to the configurations in Prettier.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在我们的项目中，EditorConfig 和 Prettier 的所有配置都不同。
- en: Prettier will parse the `.editorconfig` file to follow its configuration when
    formatting the code. As the IDE already formated the code by following the EditorConfig
    rules, Prettier can skip those rules and apply its own code style rules.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Prettier 将解析 `.editorconfig` 文件以遵循其配置进行代码格式化。由于 IDE 已经根据 EditorConfig 规则格式化了代码，因此
    Prettier 可以跳过这些规则并应用自己的代码风格规则。
- en: In this section, we learned how to configure EditorConfig by defining code style
    rules in the `.editorconfig` file and Prettier by defining rules in the `.prettierrc`
    file. We also learned how to avoid redundancy when working with these tools together.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何通过在 `.editorconfig` 文件中定义代码样式规则来配置 EditorConfig，通过在 `.prettierrc`
    文件中定义规则来配置 Prettier。我们还学习了如何在使用这些工具时避免冗余。
- en: Next, we'll add ESLint to the project, an essential tool that complements EditorConfig
    and Prettier in improving the code quality.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向项目中添加 ESLint，这是一个补充 EditorConfig 和 Prettier 以提高代码质量的必要工具。
- en: Configuring ESLint and Prettier
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 ESLint 和 Prettier
- en: In this section, we'll configure **ESLint** and integrate Prettier with ESLint
    to improve the code quality, and to prevent conflicts between these two tools.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将配置 **ESLint** 并将 Prettier 与 ESLint 集成以提高代码质量，并防止这两个工具之间的冲突。
- en: ESLint is a tool for analyzing, fixing, and reporting inconsistencies and issues
    that can generate bugs in your code. This tool can format and improve the code
    quality with various plugins that implement the rules that meet your project's
    needs. You can read more about ESLint at [https://eslint.org/](https://eslint.org/).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 是一个用于分析、修复和报告可能导致代码中产生错误的代码不一致性和问题的工具。此工具可以通过实现满足项目需求规则的插件来格式化和提高代码质量。您可以在
    [https://eslint.org/](https://eslint.org/) 上了解更多关于 ESLint 的信息。
- en: Like Prettier and EditorConfig, ESLint also applies style rules to the code.
    In our scenario, where we use EditorConfig to override the IDE code style and
    Prettier to enforce a consistent code style by applying its own rules, we'll use
    only the code quality rules that ESLint offers. We could use only ESLint for code
    quality and formatting, but Prettier excels in code formatting and easily integrates
    with ESLint.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Prettier 和 EditorConfig 一样，ESLint 也将样式规则应用于代码。在我们的场景中，我们使用 EditorConfig 来覆盖
    IDE 代码样式，使用 Prettier 通过应用其自己的规则来强制执行一致的代码样式，我们将仅使用 ESLint 提供的代码质量规则。我们可以仅使用 ESLint
    进行代码质量和格式化，但 Prettier 在代码格式化方面表现卓越，并且可以轻松与 ESLint 集成。
- en: 'Before getting into the details about integrating Prettier and ESLint, let''s
    install and configure ESLint by following these steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解将 Prettier 和 ESLint 集成的细节之前，让我们按照以下步骤安装和配置 ESLint：
- en: 'Install ESLint by running the following command:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装 ESLint：
- en: '[PRE3]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, run the following command to configure ESLint:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令来配置 ESLint：
- en: '[PRE4]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For the first question, **How would you like to use ESLint?**, select the **To
    check syntax and find problems** option in the terminal and press *Enter*:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第一个问题，**您希望如何使用 ESLint？**，在终端中选择 **检查语法并查找问题** 选项并按 *Enter* 键：
- en: '![Figure 5.4 – ESLint configuration – How would you like to use ESLint?'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – ESLint 配置 – 您希望如何使用 ESLint？'
- en: '](img/Figure_5.04_B18503.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.04_B18503.jpg](img/Figure_5.04_B18503.jpg)'
- en: Figure 5.4 – ESLint configuration – How would you like to use ESLint?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – ESLint 配置 – 您希望如何使用 ESLint？
- en: 'For the second question, **What type of modules does your project use?**, select
    the **JavaScript modules (import/export)** option in the terminal and press *Enter*:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第二个问题，**您的项目使用什么类型的模块？**，在终端中选择 **JavaScript 模块（import/export）** 选项并按 *Enter*
    键：
- en: '![Figure 5.5 – ESLint configuration – What type of modules does your project
    use?'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 – ESLint 配置 – 您的项目使用什么类型的模块？'
- en: '](img/Figure_5.05_B18503.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.05_B18503.jpg](img/Figure_5.05_B18503.jpg)'
- en: Figure 5.5 – ESLint configuration – What type of modules does your project use?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – ESLint 配置 – 您的项目使用什么类型的模块？
- en: 'For the third question, **Which framework does your project use?**, select
    the **React** option and press *Enter*:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第三个问题，**您的项目使用哪个框架？**，在终端中选择 **React** 选项并按 *Enter* 键：
- en: '![Figure 5.6 – ESLint configuration – Which framework does your project use?'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – ESLint 配置 – 您的项目使用哪个框架？'
- en: '](img/Figure_5.06_B18503.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.06_B18503.jpg](img/Figure_5.06_B18503.jpg)'
- en: Figure 5.6 – ESLint configuration – Which framework does your project use?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – ESLint 配置 – 您的项目使用哪个框架？
- en: 'For the fourth question, **Does your project use TypeScript?**, select the
    **Yes** option and press *Enter*:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第四个问题，**您的项目是否使用 TypeScript？**，选择 **是** 选项并按 *Enter* 键：
- en: '![Figure 5.7 – ESLint configuration – Does your project use TypeScript?'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7 – ESLint 配置 – 您的项目是否使用 TypeScript？'
- en: '](img/Figure_5.07_B18503.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.07_B18503.jpg](img/Figure_5.07_B18503.jpg)'
- en: Figure 5.7 – ESLint configuration – Does your project use TypeScript?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – ESLint 配置 – 您的项目是否使用 TypeScript？
- en: 'For the fifth question, **Where does your code run?**, select **Browser** and
    press *Enter*:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第五个问题，**您的代码在哪里运行？**，选择 **浏览器** 并按 *Enter* 键：
- en: '![Figure 5.8 – ESLint configuration – Where does your code run?'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8 – ESLint 配置 – 您的代码在哪里运行？'
- en: '](img/Figure_5.08_B18503.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.08_B18503.jpg](img/Figure_5.08_B18503.jpg)'
- en: Figure 5.8 – ESLint configuration – Where does your code run?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – ESLint 配置 – 你的代码在哪里运行？
- en: 'For the sixth question, **What format do you want your config file to be in?**,
    select **JSON** and press *Enter*:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第六个问题，**你希望你的配置文件是什么格式？**，选择 **JSON** 并按 *Enter*：
- en: '![Figure 5.9 – ESLint configuration – What format do you want your config file
    to be in?'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.9 – ESLint 配置 – 你希望你的配置文件是什么格式？](img/Figure_5.9_B18503.jpg)'
- en: '](img/Figure_5.09_B18503.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.09_B18503.jpg)'
- en: Figure 5.9 – ESLint configuration – What format do you want your config file
    to be in?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – ESLint 配置 – 你希望你的配置文件是什么格式？
- en: 'For the seventh question, **Would you like to install them now with npm?**,
    select **No** and press *Enter* as we''ll use Yarn instead of npm:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第七个问题，**你想现在使用 npm 安装它们吗？**，选择 **No** 并按 *Enter*，因为我们将使用 Yarn 而不是 npm：
- en: '![Figure 5.10 – ESLint configuration – Would you like to install them (dependencies)
    now with npm?'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10 – ESLint 配置 – 你想现在使用 npm 安装它们（依赖项）吗？](img/Figure_5.10_B18503.jpg)'
- en: '](img/Figure_5.10_B18503.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.10_B18503.jpg)'
- en: Figure 5.10 – ESLint configuration – Would you like to install them (dependencies)
    now with npm?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10 – ESLint 配置 – 你想现在使用 npm 安装它们（依赖项）吗？](img/Figure_5.10_B18503.jpg)'
- en: 'Next, we need to install the dependencies required by running the following
    command:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要运行以下命令来安装所需的依赖项：
- en: '[PRE5]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, let''s add the VS Code extension to integrate ESLint. Press *Ctrl
    + P*, type the following command, and press *Enter*:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们添加 VS Code 扩展以集成 ESLint。按 *Ctrl + P*，输入以下命令，然后按 *Enter*：
- en: '[PRE6]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After following the preceding steps, a new file called `.eslintrc.json` should
    exist in our project with the ESLint configuration. Let''s take a closer look
    at those configurations:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循前面的步骤之后，我们的项目中应该存在一个名为 `.eslintrc.json` 的新文件，其中包含 ESLint 配置。让我们仔细看看这些配置：
- en: .eslintrc.json
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: .eslintrc.json
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These are the options defined in the `.eslintrc.json` file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 `.eslintrc.json` 文件中定义的选项：
- en: '`env`: This option defines the global variable. Here, ESLint declares that
    we are working in the browser and using ECMAScript 2021.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`: 此选项定义全局变量。在这里，ESLint 声明我们在浏览器中工作并使用 ECMAScript 2021。'
- en: '`extends`: We can extend other configuration files or plugin configurations
    with this option. Here, ESLint extends its recommended rules, `react` plugin rules,
    and `typescript-eslint` plugin rules.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extends`: 使用此选项，我们可以扩展其他配置文件或插件配置。在这里，ESLint 扩展了其推荐规则、`react` 插件规则和 `typescript-eslint`
    插件规则。'
- en: '`parser` and `parserOptions`: With these options, we can define what code parser
    to use and define the parser options. Here, ESLint sets the parser to TypeScript
    using the `typescript-eslint` package and enables the JSX option.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parser` 和 `parserOptions`: 使用这些选项，我们可以定义要使用哪个代码解析器以及定义解析器选项。在这里，ESLint 使用
    `typescript-eslint` 包将解析器设置为 TypeScript 并启用 JSX 选项。'
- en: '`plugins`: With this option, we can set ESLint plugins. Here, ESLint uses the
    `react` and `typescript-eslint` plugins.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plugins`: 使用此选项，我们可以设置 ESLint 插件。在这里，ESLint 使用了 `react` 和 `typescript-eslint`
    插件。'
- en: '`rules`: With this option, we can modify the ESLint rules to meet our project''s
    needs.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rules`: 使用此选项，我们可以修改 ESLint 规则以满足我们项目的需求。'
- en: 'We want Prettier and EditorConfig working on the code style and ESLint working
    on the code quality, so we need to disable the ESLint formatting rules. This approach
    will also prevent conflicts between Prettier and ESLint. Follow these steps to
    disable the ESLint formatting rules:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 Prettier 和 EditorConfig 在代码风格上工作，而 ESLint 在代码质量上工作，因此我们需要禁用 ESLint 的格式化规则。这种方法也将防止
    Prettier 和 ESLint 之间的冲突。按照以下步骤禁用 ESLint 的格式化规则：
- en: 'Install the configurations to disable the ESLint style rules by running the
    following command:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装禁用 ESLint 风格规则的配置：
- en: '[PRE8]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, install the Prettier ESLint plugin by running the following command:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过运行以下命令安装 Prettier ESLint 插件：
- en: '[PRE9]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, extend the Prettier plugin''s recommended configurations as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按照以下方式扩展 Prettier 插件的推荐配置：
- en: '[PRE10]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that we extended the Prettier plugin's configuration as the last element
    in the `extends` array. It's important to follow this order for ESLint to correctly
    merge the shared configurations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将 Prettier 插件的配置作为 `extends` 数组的最后一个元素进行了扩展。对于 ESLint 正确合并共享配置，遵循此顺序很重要。
- en: If you open any page component, you can see ESLint in action. Let's open the
    home page component located in the `index.tsx` file in the `/src/pages/Home` folder.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开任何页面组件，你可以在 `index.tsx` 文件中看到 ESLint 的作用。让我们打开位于 `/src/pages/Home` 文件夹中的主页组件。
- en: '![Figure 5.11 – ESLint react-in-jsx-scope rule'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11 – ESLint react-in-jsx-scope 规则](img/Figure_5.11_B18503.jpg)'
- en: '](img/Figure_5.11_B18503.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.11_B18503.jpg)'
- en: Figure 5.11 – ESLint react-in-jsx-scope rule
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – ESLint react-in-jsx-scope 规则
- en: 'Notice that ESLint found an error based on the `jsx-runtime` configuration
    from the `react` plugin in our ESLint configuration as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 ESLint 根据我们 ESLint 配置中 `react` 插件的 `jsx-runtime` 配置找到了以下错误：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this section, we installed and configured ESLint to ensure code quality.
    We also learned how to integrate Prettier with ESLint by disabling the ESLint
    code style rules and preventing conflicts between these two tools.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们安装并配置了 ESLint 以确保代码质量。我们还学习了如何通过禁用 ESLint 代码风格规则并防止这两个工具之间的冲突来将 Prettier
    与 ESLint 集成。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed code style and learned that it is essential to
    ensure a consistent code style when working on professional projects with multiple
    team members.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了代码风格，并了解到在多个团队成员参与的专业项目中工作时，确保一致的代码风格是至关重要的。
- en: We learned how to use EditorConfig to define a consistent code style across
    IDEs and editors and maintain the same formatting regardless of developers' preferences.
    Next, we learned how to work with Prettier to enforce the code style and how to
    avoid redundancy when working with Prettier and EditorConfig in the same project.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用 EditorConfig 在 IDE 和编辑器之间定义一致的代码风格，并保持相同的格式，无论开发者的偏好如何。接下来，我们学习了如何与
    Prettier 合作来强制执行代码风格，以及如何在同一项目中与 Prettier 和 EditorConfig 一起工作时避免冗余。
- en: We also installed and configured ESLint to improve the code quality by analyzing
    and reporting code issues in your project. We disabled the ESLint style rules
    by installing and extending the Prettier plugin configuration in our ESLint configuration
    file. Finally, we disabled the **react-in-jsx-scope** rule by extending the corresponding
    configuration from the ESLint React plugin.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还安装并配置了 ESLint，通过分析并报告项目中的代码问题来提高代码质量。我们通过在 ESLint 配置文件中安装并扩展 Prettier 插件配置来禁用了
    ESLint 风格规则。最后，我们通过扩展 ESLint React 插件中的相应配置来禁用了 **react-in-jsx-scope** 规则。
- en: In the next chapter, we'll discuss code tests and learn how to write tests using
    the **Jest** and **Puppeteer** libraries.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论代码测试，并学习如何使用 **Jest** 和 **Puppeteer** 库编写测试。
