- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Code Splitting Using Lazy Components and Suspense
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用懒组件和Suspense进行代码拆分
- en: '**Code splitting** has been a significant part of React applications for many
    years, even before official support was included in the **React API**. The evolution
    of React has brought about APIs that are specifically designed to assist in code-splitting
    scenarios. Code splitting becomes crucial when dealing with large applications
    containing a vast amount of JavaScript code that needs to be delivered to a browser.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码拆分**在React应用程序中已经是一个重要的部分，甚至在官方支持被包含在**React API**中之前就已经存在。React的演变带来了专门设计用于帮助代码拆分场景的API。当处理包含大量需要发送到浏览器的JavaScript代码的大型应用程序时，代码拆分变得至关重要。'
- en: In the past, **monolithic JavaScript bundles** containing an entire application
    could cause usability issues due to long initial page load times. Thanks to code
    splitting, we now have much more granular control over how code is transferred
    from the server to the browser. This gives us ample opportunities to optimize
    load-time **User Experience** (**UX**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，包含整个应用的**单体JavaScript包**可能会因为页面加载时间过长而导致可用性问题。多亏了代码拆分，我们现在可以更细致地控制代码从服务器传输到浏览器的方式。这为我们提供了大量优化加载时间**用户体验**（**UX**）的机会。
- en: In this chapter, we will revisit how to implement this in your React applications
    by using the `lazy()` API and the `Suspense` components. These features are very
    powerful tools in the React toolbox. By gaining a thorough understanding of how
    these components function, you’ll be fully equipped to seamlessly integrate code
    splitting into your applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾如何在React应用程序中使用`lazy()` API和`Suspense`组件来实现这一点。这些功能是React工具箱中非常强大的工具。通过深入了解这些组件的工作原理，你将完全准备好无缝地将代码拆分集成到你的应用程序中。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using the `lazy()` API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`lazy()` API
- en: Using the `Suspense` component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Suspense`组件
- en: Avoiding **lazy components**
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用**懒组件**
- en: Exploring **lazy pages** and **routes**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索**懒加载页面**和**路由**
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files of this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter08](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter08).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，链接为[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter08](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter08)。
- en: Using the lazy API
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用懒API
- en: 'There are two pieces involved with using the `lazy()` API in React. First,
    there’s bundling components into their own separate files so that they can be
    downloaded by the browser separately from other parts of the application. Second,
    once you have created the bundles, you can build React components that are lazy:
    they don’t download anything until they are needed. Let’s look at both of these.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中使用`lazy()` API涉及两个部分。首先，将组件打包到它们自己的单独文件中，以便浏览器可以单独从应用程序的其他部分下载它们。其次，一旦创建了这些包，你就可以构建懒加载的React组件：它们在需要之前不会下载任何内容。让我们看看这两个方面。
- en: Dynamic imports and bundles
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态导入和包
- en: The code examples in this book use the **Vite** tooling for creating bundles.
    The nice thing about this approach is that you don’t have to maintain any bundle
    configuration. Instead, bundles are created for you automatically, based on how
    you import your modules. If you’re using the plain `import` statement (not to
    be confused with the `import` method) everywhere, your app will be downloaded
    all at once in one bundle. When your app gets bigger, there will likely be features
    that some users never use or don’t use as frequently as others. You can use the
    `import()` function to import modules on demand. By using this function, you’re
    telling Vite to create a separate bundle for the code that you’re importing dynamically.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码示例使用**Vite**工具创建包。这种方法的优点是，你不需要维护任何包配置。相反，根据你如何导入模块，包会自动为你创建。如果你在所有地方都使用普通的`import`语句（不要与`import`方法混淆），你的应用程序将一次性下载在一个包中。当你的应用程序变大时，可能会出现一些用户可能永远不会使用或不如其他用户频繁使用的功能。你可以使用`import()`函数按需导入模块。通过使用此函数，你是在告诉Vite为动态导入的代码创建一个单独的包。
- en: 'Let’s look at a simple component that we might want to bundle separately from
    the rest of the application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个我们可能希望与应用程序其他部分分开打包的简单组件：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let’s take a look at how we would import this module dynamically using
    the `import()` function, resulting in a separate bundle:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`import()`函数动态导入这个模块，从而创建一个单独的包：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you run this example, you’ll see the `<p>` text rendered right away. If
    you open the browser dev tools and look at the network requests, you’ll notice
    that a separate call is made to fetch the bundle containing the `MyComponent`
    code. This happens because of the call to `import("./MyComponent")`. The `import()`
    function returns a promise that resolves with the module object. Since we need
    the default export to access `MyComponent`, we reference `module.default` when
    we call `setMyComponent()`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个示例时，你会立即看到`<p>`文本被渲染。如果你打开浏览器开发者工具并查看网络请求，你会注意到有一个单独的调用去获取包含`MyComponent`代码的包。这是因为对`import("./MyComponent")`的调用。`import()`函数返回一个解析为模块对象的promise。由于我们需要默认导出以访问`MyComponent`，我们在调用`setMyComponent()`时引用`module.default`。
- en: The reason why we’re setting a component as the `MyComponent` state is that
    when the `App` component renders for the first time, we don’t have the `MyComponent`
    code loaded yet. Once it loads, `MyComponent` will reference the proper value,
    which results in the correct text being rendered.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组件设置为`MyComponent`状态的原因是，当`App`组件首次渲染时，我们还没有加载`MyComponent`的代码。一旦加载，`MyComponent`将引用正确的值，从而渲染出正确的文本。
- en: Now that you have an idea of how bundles get created and are fetched by the
    app, it’s time to see how the `lazy()` API greatly simplifies this process for
    us.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了包是如何被创建并由应用获取的，是时候看看`lazy()` API如何极大地简化了这个过程。
- en: Making components lazy
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使组件懒加载
- en: 'Instead of manually handling the promise returned by `import()` by returning
    the default export and setting state, you can lean on the `lazy()` API. This function
    takes a function that returns an `import()` promise. The return value is a lazy
    component that you can just render. Let’s modify the `App` component to use this
    API:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要手动处理`import()`返回的promise，通过返回默认导出和设置状态，而是可以依赖`lazy()` API。这个函数接收一个返回`import()`
    promise的函数。返回值是一个懒加载组件，你可以直接渲染。让我们修改`App`组件以使用这个API：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `MyComponent` value is created by calling `lazy()`, passing in the dynamic
    module import as an argument. Now, you have a separate bundle for your component
    and a lazy component that loads the bundle when it’s first rendered.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyComponent`的值是通过调用`lazy()`创建的，将动态模块导入作为参数传递。现在，你有一个为你的组件创建的单独包和一个在首次渲染时加载这个包的懒加载组件。'
- en: In this section, you learned how code splitting works. You learned that the
    `import()` function handles bundle creation for you. You also learned that the
    `lazy()` API makes your components lazy and handles all of the gritty work of
    importing components for you. But there’s one last thing we need, the `Suspense`
    component, to help display placeholders while components are loading.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了代码拆分的工作原理。你了解到`import()`函数为你处理了包的创建。你还了解到`lazy()` API使你的组件变得懒加载，并为你处理了导入组件的所有繁琐工作。但我们需要最后一件事，即`Suspense`组件，以帮助在组件加载时显示占位符。
- en: Using the Suspense component
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`Suspense`组件
- en: In this section, we’ll explore some of the more common usage scenarios of the
    `Suspense` component. We’ll look at where to place `Suspense` components in your
    component tree, how to simulate latency when fetching bundles, and some of the
    options available to us to use as the fallback content.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨`Suspense`组件的一些更常见的使用场景。我们将查看在组件树中放置`Suspense`组件的位置，如何在获取包时模拟延迟，以及我们可以用作回退内容的选项。
- en: Top-level Suspense components
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最高层级的`Suspense`组件
- en: '**Lazy components** need to be rendered inside of a `Suspense` component. However,
    they do not have to be direct children of `Suspense` though, which is important
    because this means that you can have one `Suspense` component handle every lazy
    component in your app. Let’s illustrate this concept with an example. Here’s a
    component that we would like to bundle separately and use lazily:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**懒加载组件**需要被渲染在`Suspense`组件内部。然而，它们不必是`Suspense`的直接子组件，这很重要，因为这意味着你可以有一个`Suspense`组件来处理你应用中的所有懒加载组件。让我们用一个例子来说明这个概念。这是一个我们希望单独打包并懒加载的组件：'
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, let’s make the `MyFeature` component lazy and render it inside of a `MyPage`
    component:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将`MyFeature`组件懒加载，并在`MyPage`组件中渲染它：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we’re using the `lazy()` API to make the `MyFeature` component lazy.
    This means that when the `MyPage` component is rendered, the code bundle that
    contains `MyFeature` will be downloaded because `MyFeature` was also rendered.
    What’s important to note with the `MyPage` component is that it is rendering a
    lazy component (`MyFeature`) but isn’t rendering a `Suspense` component. This
    is because our hypothetical app has many page components, each with its own lazy
    components. Having each of these components render its own `Suspense` component
    would be redundant. Instead, we can render one `Suspense` component inside of
    our `App` component, like so:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`lazy()` API使`MyFeature`组件变为懒加载。这意味着当`MyPage`组件被渲染时，包含`MyFeature`的代码包将会被下载，因为`MyFeature`也被渲染了。需要注意的是，对于`MyPage`组件来说，它正在渲染一个懒加载组件（`MyFeature`），但它没有渲染一个`Suspense`组件。这是因为我们的假设应用有许多页面组件，每个页面都有自己的懒加载组件。让每个组件都渲染自己的`Suspense`组件将是多余的。相反，我们可以在`App`组件内部渲染一个`Suspense`组件，如下所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While the `MyFeature` code bundle is being downloaded, `<MyPage>` is replaced
    with the fallback text passed to `Suspense`. So, even though `MyPage` isn’t lazy
    itself, it renders a lazy component that `Suspense` knows about and will replace
    its children with the fallback content while this happens.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当`MyFeature`代码包正在下载时，`<MyPage>`会被替换为传递给`Suspense`的回退文本。所以，即使`MyPage`本身不是懒加载的，它也会渲染一个`Suspense`所知的懒加载组件，并在这一过程中用回退内容替换其子组件。
- en: 'So far, we haven’t really been able to see the fallback content that displays
    while our lazy components load their code bundles. This is because when developing
    locally, these bundles load almost instantly. To be able to see fallback component
    and loading process, you can enable throttling in **Network** tab of the dev tools:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有真正看到在懒加载组件加载代码包时显示的回退内容。这是因为当本地开发时，这些包几乎会立即加载。为了能够看到回退组件和加载过程，你可以在开发者工具的**网络**选项卡中启用限制：
- en: '![](img/B19636_08_01.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_08_01.png)'
- en: 'Figure 8.1: Enabling throttling in the browser'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：在浏览器中启用限制
- en: This setting emulates a slow internet connection. Instead of loading instantly,
    the page will be rendering for a few seconds and you will see a **loading …**
    fallback.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置模拟了慢速的互联网连接。页面不会立即加载，而是会渲染几秒钟，你将看到一个**加载中…**的回退。
- en: In the next section, we’ll look at an approach to use loading spinners as a
    fallback component.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨使用加载`spinner`作为回退组件的方法。
- en: Working with spinner fallbacks
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`spinner`回退
- en: The simplest fallback that you can use with the `Suspense` component is some
    text that indicates to the user that something is happening. The fallback property
    can be any valid React element, which means that we can enhance the fallback to
    be something more visually appealing. For example, the `react-spinners` package
    has a selection of `spinner` components, all of which can be used as a fallback
    with `Suspense`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Suspense`组件的最简单的回退是一些指示用户正在发生什么的文本。回退属性可以是任何有效的React元素，这意味着我们可以增强回退，使其更具视觉吸引力。例如，`react-spinners`包提供了一系列`spinner`组件，所有这些都可以作为`Suspense`的回退使用。
- en: 'Let’s modify the `App` component from the last section to include a `spinner`
    from the `react-spinners` package as the `Suspense` fallback:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将上一节中的`App`组件修改一下，以包含来自`react-spinners`包的`spinner`作为`Suspense`的回退：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `FadeLoader` component will render a `spinner` that we’ve configured with
    a color value of `lightblue`. The rendered element of the `FadeLoader` component
    is passed to the `fallback` property. With the Slow 3G throttling, you should
    be able to see the `spinner` when you first load the app:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`FadeLoader`组件将渲染一个我们配置了`lightblue`颜色的`spinner`。`FadeLoader`组件的渲染元素被传递到`fallback`属性。使用慢速3G限制，你应该能在首次加载应用时看到`spinner`：'
- en: '![](img/B19636_08_02.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_08_02.png)'
- en: 'Figure 8.2: The image rendered by the loader component'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：加载组件渲染的图像
- en: Now, instead of text, we’re showing an animated `spinner`. This likely provides
    a user experience that your users are more accustomed to. The `react-spinners`
    package has several `spinners` for you to choose from, each of which has several
    configuration options. There are other spinner libraries that you can use or implement
    on your own.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再显示文本，而是显示一个动画`spinner`。这很可能会提供一个用户更习惯的用户体验。`react-spinners`包提供了几个`spinner`供你选择，每个`spinner`都有几个配置选项。你也可以使用其他`spinner`库，或者自己实现。
- en: In this section, you learned that you can use a single `Suspense` component
    that will display its fallback content for any lazy components that are lower
    in the tree. You learned how to simulate latency during local development so that
    you can experience what your users will experience with your `Suspense` fallback
    content. Finally, you learned how to use components from other libraries as the
    fallback content to provide something that looks better than plain text.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何使用单个 `Suspense` 组件来显示其回退内容，这对于树中任何较低级别的懒加载组件都是有效的。你学习了如何在本地开发期间模拟延迟，以便你可以体验你的用户将如何体验你的
    `Suspense` 回退内容。最后，你学习了如何使用来自其他库的组件作为回退内容，以提供比纯文本看起来更好的东西。
- en: In the next section, you’ll learn about why it doesn’t make sense to make every
    component in your app a lazy component.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解到为什么将应用中的每个组件都做成懒加载组件是没有意义的。
- en: Avoiding lazy components
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用懒加载组件
- en: 'It might be tempting to make most of your React components lazy components
    that live in their own bundle. After all, there isn’t much extra work that needs
    to happen to set up separate bundles and make lazy components. However, there
    are some downsides to this. If you have too many lazy components, your app will
    end up making several HTTP requests to fetch them: at the same time. There’s no
    benefit to having separate bundles for components used on the same part of the
    app. You’re better off trying to bundle components together in a way that one
    HTTP request is made to load what is needed on the current page.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会很有诱惑力将大多数React组件做成懒加载组件，这些组件各自存在于自己的包中。毕竟，设置单独的包和创建懒加载组件并不需要做太多额外的工作。然而，这样做也有一些缺点。如果你有太多的懒加载组件，你的应用最终会同时发起多个HTTP请求来获取它们：这并没有为在应用同一部分使用的组件使用单独的包带来任何好处。你最好尝试以某种方式将组件打包在一起，使得只需一个HTTP请求就能加载当前页面上所需的内容。
- en: 'A helpful way to think of this is to associate **pages** with **bundles**.
    If you have lazy page components, everything on that page will also be lazy yet
    bundled together with other components on the page. Let’s build an example that
    demonstrates how to organize our lazy components. Let’s say that your app has
    a couple of pages and a few features on each page. We don’t necessarily want to
    make these features lazy if they’re all going to be needed when the page loads.
    Here’s the `App` component that shows the user a selector to pick which page to
    load:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有助于思考的一种方式是将 **页面** 与 **包** 相关联。如果你有懒加载的页面组件，该页面上的一切也将是懒加载的，并且与其他页面上的组件打包在一起。让我们构建一个示例，演示如何组织我们的懒加载组件。假设你的应用有几个页面，每个页面上都有一些功能。如果当页面加载时这些功能都需要，我们就不一定想使这些功能成为懒加载的。以下是显示用户选择要加载哪个页面的
    `App` 组件：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `First` and `Second` components are the pages that make up our app, so
    we want them to be lazy components that load their bundles on demand. The `ShowComponent`
    component renders the appropriate page when the user changes the selector:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`First` 和 `Second` 组件是我们应用中的页面，因此我们希望它们成为按需加载其包的懒加载组件。当用户更改选择器时，`ShowComponent`
    组件会渲染适当的页面：'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, let’s look at the first page and see how it’s composed, starting with
    the `First` component:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看第一页，看看它是如何组成的，从 `First` 组件开始：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `First` component pulls in three components and renders them: `One`, `Two`,
    and `Three`. These three components will be part of the same bundle. While we
    could make them lazy, there would be no point, as all we would be doing is making
    three HTTP requests for bundles at the same time instead of one.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`First` 组件会引入三个组件并将它们渲染出来：`One`、`Two` 和 `Three`。这三个组件将构成同一个包。虽然我们可以使它们成为懒加载的，但这并没有什么意义，因为我们所做的只是同时发起三个HTTP请求来获取包，而不是一个。'
- en: Now that you have a better understanding of how to map the page structures of
    your application to bundles, let’s look at another use case where we use a router
    component to navigate around our app.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更好地理解了如何将应用页面的结构映射到包上，让我们看看另一个用例，其中我们使用路由组件在应用中导航。
- en: Exploring lazy pages and routes
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索懒加载页面和路由
- en: 'In the *Avoiding lazy components* section, you saw where to avoid making components
    lazy when there is no benefit in doing so. The same pattern can be applied when
    you’re using `react-router` as the mechanism to navigate around your application.
    Let’s take a look at an example. Here are the imports we’ll need:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Avoiding lazy components*（避免使用懒加载组件）部分，你看到了在没有好处的情况下应避免使组件成为懒加载的地方。当你在使用
    `react-router` 作为在应用中导航的机制时，可以应用相同的模式。让我们看看一个例子。以下是我们需要导入的内容：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, we have two lazy page components that will be bundled
    separately from the rest of the app. The fallback content in this example uses
    the same `FadeLoader` `spinner` component that was introduced in the *Working
    with spinner fallbacks* section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有两个将单独打包的懒加载页面组件。在这个例子中，回退内容使用了在*使用旋转器回退*部分中引入的相同的`FadeLoader` `spinner`组件。
- en: 'Note that the `Suspense` component is placed beneath the navigation links.
    This means that the fallback content will be rendered in the spot where the page
    content will eventually show when it loads. The children of the `Suspense` component
    are the `Route` components that will render our lazy page components: for example,
    when the `/first` route is activated, the `First` component is rendered for the
    first time, triggering the bundle download.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Suspense`组件放置在导航链接之下。这意味着当内容加载时，将在这个位置渲染出最终显示的页面内容。`Suspense`组件的子元素是`Route`组件，它们将渲染我们的懒加载页面组件：例如，当`/first`路由被激活时，`First`组件将首次渲染，触发包下载。
- en: That brings us to the end of this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们结束了这一章。
- en: Summary
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was all about code splitting and bundling, which are important
    concepts for large React applications. We started by looking at how code is split
    into bundles in your React applications by using the `import()` function. Then,
    we looked at the `lazy()` React API and how it helps to simplify loading bundles
    when components are rendered for the first time. Next, we looked more deeply at
    the `Suspense` component, which is used to manage content while component bundles
    are being fetched. The `fallback` property is how we specify the content to be
    shown while bundles are being loaded. You typically don’t need more than one `Suspense`
    component in your app, as long as you follow a consistent pattern for bundling
    pages of your app.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于代码拆分和打包，这些是大型React应用程序中的重要概念。我们首先通过使用`import()`函数查看如何在你的React应用程序中将代码拆分成包。然后，我们探讨了`lazy()`
    React API以及它是如何帮助简化首次渲染组件时的包加载。接下来，我们更深入地研究了`Suspense`组件，该组件用于在组件包被检索时管理内容。`fallback`属性是我们指定在加载包时显示的内容的方式。只要你的应用程序遵循一致的打包模式，通常你不需要在应用程序中使用超过一个`Suspense`组件。
- en: 'In the next chapter, you’ll learn how to use the **Next.js** framework to handle
    rendering React components on the server. The Next.js framework allows you to
    create pages that act as React components and can be rendered on the server and
    in the browser. This is an important capability for applications that need good
    initial page load performance: that is, all applications.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用**Next.js**框架来处理在服务器上渲染React组件。Next.js框架允许你创建作为React组件的页面，这些页面可以在服务器和浏览器上渲染。这对于需要良好的初始页面加载性能的应用程序来说是一个重要的功能：也就是说，所有应用程序。
