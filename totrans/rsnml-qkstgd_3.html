<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating ReasonReact Components</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now that we've set up our development environment, we're ready to get started with ReasonReact—the future of ReactJS. Both ReasonML and ReasonReact were built by the same person who built ReactJS. ReasonReact is just Reason, much like how ReactJS is just JavaScript. Throughout the rest of this book, we will be working with an application that we will start building in this chapter. The following are screenshots of what we'll have built by the end of this chapter:</p>
<p class="cdpaligncenter"><img src="assets/b88262e1-bf4b-4508-aa96-84b090a76664.png" class="calibre22"/></p>
<p class="mce-root">To follow along, clone this book's GitHub repository and start from <kbd class="calibre11">Chapter03/start</kbd>. Throughout the rest of this book, each directory shares the same development environment as the one we set up at the end of <a href="4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml" target="_blank" class="calibre8">Chapter 2</a>, <em class="calibre15">Setting Up a Development Environm</em><em class="calibre15">ent</em>.</p>
<pre class="calibre16"><strong class="calibre1">git clone https://github.com/PacktPublishing/ReasonML-Quick-Start-Guide.git</strong><br class="title-page-name"/><strong class="calibre1">cd ReasonML-Quick-Start-Guide</strong><br class="title-page-name"/><strong class="calibre1">cd Chapter03/start<br class="title-page-name"/>npm install</strong></pre>
<p class="mce-root"><span class="calibre5">We'll first explore ReasonReact, and at about halfway through this chapter, we'll shift to the </span><kbd class="calibre11">Chapter03/app-start</kbd><span class="calibre5"> directory, where we'll start building an application</span><span class="calibre5"> with ReasonReact's built-in router.</span></p>
<p class="mce-root"><span class="calibre5">In this chapter, we will do the following:</span></p>
<ul class="calibre9">
<li class="calibre10">Explore creating stateless and stateful ReasonReact components</li>
<li class="calibre10"><span>Create an application that includes navigation and routing</span></li>
<li class="calibre10">See how so many of the ReactJS concepts you're already familiar with map nicely to ReasonReact</li>
<li class="calibre10">Learn how ReasonReact can help us create more robust components thanks to Reason's type system</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Component creation basics</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's start by analyzing a simple stateless component. In <kbd class="calibre11">App.re</kbd>, let's render a <kbd class="calibre11">&lt;div /&gt;</kbd> element with some text:</p>
<pre class="calibre16">let component = ReasonReact.statelessComponent("App");<br class="title-page-name"/><br class="title-page-name"/>let make = _children =&gt; {<br class="title-page-name"/>  ...component,<br class="title-page-name"/>  render: _self =&gt; &lt;div&gt; {ReasonReact.string("hello world")} &lt;/div&gt;,<br class="title-page-name"/>};</pre>
<p class="mce-root">And in <kbd class="calibre11">Index.re</kbd>, render the component to a DOM element with an ID of <kbd class="calibre11">"root"</kbd>:</p>
<pre class="calibre16">ReactDOMRe.renderToElementWithId(&lt;App /&gt;, "root");</pre>
<p class="mce-root"><span class="calibre5">Due to Reason's module system, we do not need an</span><span class="calibre5"> </span><kbd class="calibre11">import</kbd><span class="calibre5"> statement in </span><kbd class="calibre11">Index.re</kbd><span class="calibre5"> nor an export statement in <kbd class="calibre11">App.re</kbd>. Every Reason file is a module, and every Reason module is globally available. Later in this book, we will see how a module's implementation details can be hidden so that users of your component only access things they are supposed to access.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Component templates</h1>
                </header>
            
            <article>
                
<p class="mce-root">In ReasonReact, all components are created with one of the following four functions:</p>
<ul class="calibre9">
<li class="calibre10"><kbd class="calibre11">ReasonReact.statelessComponent</kbd></li>
<li class="calibre10"><kbd class="calibre11"><span>ReasonReact.statelessComponentWithRetainedProps</span></kbd></li>
<li class="calibre10"><kbd class="calibre11">ReasonReact.reducerComponent</kbd></li>
<li class="calibre10"><kbd class="calibre11"><span>ReasonReact.reducerComponentWithRetainedProps</span></kbd></li>
</ul>
<p class="mce-root"><span class="calibre5">Each of the four functions accepts a <kbd class="calibre11">string</kbd> and returns a <kbd class="calibre11">record</kbd> corresponding to a different component template. The <kbd class="calibre11">string</kbd> argument is only for debugging purposes. The</span><span class="calibre5"> component gets its name (<kbd class="calibre11">&lt;App /&gt;</kbd>) from its filename (<kbd class="calibre11">App.re</kbd>). The fields the returned record contains are dependent on which of the functions was used. In the case of our previous example, we have the following fields that we can override:</span></p>
<ul class="calibre9">
<li class="calibre10"><kbd class="calibre11">render</kbd></li>
<li class="calibre10"><kbd class="calibre11"><span>didMount</span></kbd></li>
<li class="calibre10"><kbd class="calibre11"><span>willReceiveProps</span></kbd></li>
<li class="calibre10"><kbd class="calibre11"><span>shouldUpdate</span></kbd></li>
<li class="calibre10"><kbd class="calibre11"><span>willUpdate</span></kbd></li>
<li class="calibre10"><kbd class="calibre11"><span>didUpdate</span></kbd></li>
<li class="calibre10"><kbd class="calibre11"><span>willUnmount</span></kbd></li>
</ul>
<p class="mce-root">Aside from the <kbd class="calibre11">render</kbd> field, the rest are just familiar ReactJS life cycle events. To override a field, add that field within the <kbd class="calibre11">make</kbd> function's returned <kbd class="calibre11">record</kbd>. In the preceding example, the component template's <kbd class="calibre11">render</kbd> field was replaced with the custom <kbd class="calibre11">render</kbd> function.</p>
<p class="mce-root">The <kbd class="calibre11">make</kbd> function accepts <kbd class="calibre11">props</kbd> as arguments, and returns a <kbd class="calibre11">record</kbd> of the same shape as the one that was initially created by one of the four component creation functions. The last argument to the <kbd class="calibre11">make</kbd> function must be the <kbd class="calibre11">children</kbd> prop. You may have noticed that <kbd class="calibre11">children</kbd> is prefixed with an <kbd class="calibre11">_</kbd> in the preceding example. If your component does not need a reference to the children prop, then prefixing the argument with an <kbd class="calibre11">_</kbd> prevents a compiler warning for the unused binding.</p>
<p class="mce-root">It may not appear immediately obvious, but the <kbd class="calibre11">make</kbd> function's curly braces belong to the returned <kbd class="calibre11">record</kbd> literal. The <kbd class="calibre11">...component</kbd> expression spreads the contents of the original <kbd class="calibre11">record</kbd> in this new <kbd class="calibre11">record</kbd> so that individual fields can be overridden without having to explicitly set each field.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">self</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd class="calibre11">render</kbd> field holds a callback function that accepts an argument called <kbd class="calibre11">self</kbd>, and returns a value of type <kbd class="calibre11">ReasonReact.reactElement</kbd>. The three fields of the <kbd class="calibre11">self</kbd> record are the following:</p>
<ul class="calibre9">
<li class="calibre10"><kbd class="calibre11">state</kbd></li>
<li class="calibre10"><kbd class="calibre11">handle</kbd></li>
<li class="calibre10"><kbd class="calibre11">send</kbd></li>
</ul>
<p class="mce-root">By choice, ReasonReact does not have the concept of JavaScript's <kbd class="calibre11">this</kbd>. Instead, <kbd class="calibre11">self</kbd> holds the necessary information and is provided to callbacks that need it. We'll see more of <kbd class="calibre11">self</kbd> when using stateful components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Event handlers</h1>
                </header>
            
            <article>
                
<p class="mce-root">In our render function, we can attach event listeners to DOM elements the same way that we would in ReactJS. For example, to listen for the click event, we add an <kbd class="calibre11">onClick</kbd> attribute and set its value to an event handler:</p>
<pre class="calibre16">let component = ReasonReact.statelessComponent("App");<br class="title-page-name"/><br class="title-page-name"/>let make = _children =&gt; {<br class="title-page-name"/>  ...component,<br class="title-page-name"/>  render: _self =&gt;<br class="title-page-name"/>    &lt;div onClick={_event =&gt; Js.log("clicked")}&gt;<br class="title-page-name"/>      {ReasonReact.string("hello world")}<br class="title-page-name"/>    &lt;/div&gt;,<br class="title-page-name"/>};</pre>
<p class="mce-root">However, this <span class="calibre5">callback</span> function must accept exactly one argument (corresponding to a JavaScript DOM event) and must<em class="calibre15"> </em>return a type called <kbd class="calibre11">unit</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">unit</h1>
                </header>
            
            <article>
                
<p class="mce-root">In Reason, <kbd class="calibre11">unit</kbd> is a type that means "nothing." A function whose return type is <kbd class="calibre11">unit</kbd> cannot return anything other than <kbd class="calibre11">unit</kbd>. There is exactly one value of type <kbd class="calibre11">unit</kbd>: <kbd class="calibre11">()</kbd> (that is, a pair of empty parentheses, which is also called <kbd class="calibre11">unit</kbd>).</p>
<p class="mce-root">In contrast, there are exactly two values of type <kbd class="calibre11">bool</kbd>: <kbd class="calibre11">true</kbd> and <kbd class="calibre11">false</kbd>. There are an infinite number of values of type <kbd class="calibre11">int</kbd>.</p>
<p class="mce-root">As discussed in <a href="75c7a9ae-b7e6-4ba7-97d0-eaa5cad2967c.xhtml" target="_blank" class="calibre8">Chapter 1</a>, <em class="calibre15">Introduction to ReasonML</em>, the idiomatic way to represent a nullable value in Reason is with the <kbd class="calibre11">option</kbd> type. The major difference between the <kbd class="calibre11">option</kbd> type and the <kbd class="calibre11">unit</kbd> type is that a value of type <kbd class="calibre11">option</kbd> could be nothing, or it could be some value where as a value of type <kbd class="calibre11">unit</kbd> is always <kbd class="calibre11">()</kbd>.</p>
<p class="mce-root">A function that accepts and/or returns <kbd class="calibre11">unit</kbd> likely causes side effects. For example, <kbd class="calibre11">Js.log</kbd> is a function that returns <kbd class="calibre11">unit</kbd>. The <kbd class="calibre11">onClick</kbd> event handler is also a function that returns <kbd class="calibre11">unit</kbd>.</p>
<p class="mce-root"><kbd class="calibre11">Random.bool</kbd> is an example of a function that accepts <kbd class="calibre11">unit</kbd> as its argument and returns a <kbd class="calibre11">bool</kbd>. The syntax for calling a function with <kbd class="calibre11">unit</kbd> is quite familiar:</p>
<pre class="calibre16">Random.bool()</pre>
<p class="mce-root">Since <kbd class="calibre11">onClick</kbd> needs a function that returns <kbd class="calibre11">unit</kbd>, the following will result in a type error:</p>
<pre class="calibre16">let component = ReasonReact.statelessComponent("App");<br class="title-page-name"/><br class="title-page-name"/>let make = _children =&gt; {<br class="title-page-name"/>  ...component,<br class="title-page-name"/>  render: _self =&gt;<br class="title-page-name"/>    &lt;div onClick={_event =&gt; 42}&gt; {ReasonReact.string("hello world")} &lt;/div&gt;,<br class="title-page-name"/>};</pre>
<p class="mce-root">The type error is shown here:</p>
<pre class="calibre16"><span>Error: This expression has type int but an expression was expected of type<br class="title-page-name"/></span><span>  unit</span></pre>
<p class="mce-root">In the error message, <kbd class="calibre11">This expression</kbd> refers to <kbd class="calibre11">42</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSX</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="calibre5">Reason comes with the JSX</span><span class="calibre5"> syntax. One difference in ReasonReact's version of JSX is that we cannot do the following in ReasonReact:</span></p>
<pre class="calibre16">&lt;div&gt;"hello world"&lt;/div&gt;</pre>
<p class="mce-root">Instead, we need to convert the <kbd class="calibre11">string</kbd> to a <kbd class="calibre11">ReasonReact.reactElement</kbd><span class="calibre5"> with the <kbd class="calibre11">ReasonReact.string</kbd> function:</span></p>
<pre class="calibre16">&lt;div&gt;ReasonReact.string("hello world")&lt;/div&gt;</pre>
<p class="mce-root">However, this still doesn't work. We need to also wrap the expression with <kbd class="calibre11">{ }</kbd> to help the parser differentiate between multiple possible children:</p>
<pre class="calibre16">&lt;div&gt; {ReasonReact.string("hello world")} &lt;/div&gt;</pre>
<p class="mce-root">You're free to create an alias that is less verbose and use that instead:</p>
<pre class="calibre16">let str = ReasonReact.string;<br class="title-page-name"/>&lt;div&gt; {str("hello world")} &lt;/div&gt;;</pre>
<p class="mce-root">When a custom component is invoked in JSX, its <kbd class="calibre11">make</kbd> function is called. The <kbd class="calibre11">&lt;App /&gt;</kbd> syntax desugars to the following:</p>
<pre class="calibre16"><span>ReasonReact.element(App.make(</span><span>[||]))</span></pre>
<p class="mce-root">When a component will receive new props, its <kbd class="calibre11">make</kbd> function will again be called with the new props as arguments. The <kbd class="calibre11">make</kbd> function is like a combination of ReactJS's <kbd class="calibre11">constructor</kbd> and ReactJS's <span class="calibre5"><kbd class="calibre11">componentWillReceiveProps</kbd>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Props</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's add a few props to our <kbd class="calibre11">&lt;App /&gt;</kbd> component:</p>
<pre class="calibre16">let make = (~greeting, ~name, _children) =&gt; {<br class="title-page-name"/>  ...component,<br class="title-page-name"/>  render: _self =&gt; &lt;div&gt; {ReasonReact.string(greeting ++ " " ++ name)} &lt;/div&gt;,<br class="title-page-name"/>};</pre>
<p class="mce-root">After compiling, we get a compiler error, because in <kbd class="calibre11">Index.re</kbd> we aren't providing the required <kbd class="calibre11">greeting</kbd> and <kbd class="calibre11">name</kbd> props:</p>
<pre class="calibre16">We've found a bug for you!<br class="title-page-name"/>  <br class="title-page-name"/>1 │ ReactDOMRe.renderToElementWithId(&lt;App /&gt;, "root");<br class="title-page-name"/>  <br class="title-page-name"/>This call is missing arguments of type:<br class="title-page-name"/>(~greeting: string),<br class="title-page-name"/>(~name: string)</pre>
<p class="mce-root"><kbd class="calibre11">greeting</kbd> and <kbd class="calibre11">name</kbd> are <strong class="calibre4">labelled arguments</strong> of the <kbd class="calibre11">make</kbd> function, meaning that they can be provided in any order. To convert an argument to a labelled argument, prefix it with a tilde (<kbd class="calibre11">~</kbd>). Reason also supports optional arguments as well as arguments with defaults. Let's give <kbd class="calibre11">greeting</kbd> a default value and make <kbd class="calibre11">name</kbd> optional:</p>
<pre class="calibre16">let make = (~greeting="hello", ~name=?, _children) =&gt; {<br class="title-page-name"/>  ...component,<br class="title-page-name"/>  render: _self =&gt; {<br class="title-page-name"/>    let name =<br class="title-page-name"/>      switch (name) {<br class="title-page-name"/>      | None =&gt; ""<br class="title-page-name"/>      | Some(name) =&gt; name<br class="title-page-name"/>      };<br class="title-page-name"/>    &lt;div&gt; {ReasonReact.string(greeting ++ " " ++ name)} &lt;/div&gt;;<br class="title-page-name"/>  },<br class="title-page-name"/>};</pre>
<p class="mce-root">Since <kbd class="calibre11">name</kbd> is an optional argument, it's wrapped in an <kbd class="calibre11">option</kbd> type, and we can then pattern match on its value. Of course, this is just a long-winded way of providing <kbd class="calibre11">name</kbd> with a default argument of <kbd class="calibre11">""</kbd>.</p>
<p class="mce-root">Now, our example compiles even if <kbd class="calibre11">&lt;App /&gt;</kbd> isn't provided with any props:</p>
<pre class="calibre16"><span>ReactDOMRe</span><span>.</span><span>renderToElementWithId(</span><span>&lt;</span><span>App</span><span> </span><span>/&gt;</span><span>,</span><span> </span><span>"root"</span><span>)</span><span>;<br class="title-page-name"/>/* hello */<br class="title-page-name"/><br class="title-page-name"/>ReactDOMRe.renderToElementWithId(<br class="title-page-name"/>  &lt;App greeting="welcome," name="reason" /&gt;,<br class="title-page-name"/>  "root",<br class="title-page-name"/>);<br class="title-page-name"/>/* welcome, reason */<br class="title-page-name"/></span></pre>
<p class="mce-root">If we then decide to remove the name prop, the compiler will tell us where we need to update the usage of <kbd class="calibre11">&lt;App /&gt;</kbd>. This gives us the freedom to refactor our components without worrying about forgetting to update an area of our codebase. The compiler has our back!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Children</h1>
                </header>
            
            <article>
                
<p class="mce-root">The last argument to the <kbd class="calibre11">make</kbd> function is always the <kbd class="calibre11">children</kbd> prop—it's mandatory. Just like other props, children can be any data structure. As long as the component allows it, we can use the render prop pattern that is popular in ReactJS. Importantly, ReasonReact always wraps children in an array, so we need to unwrap the array with the <kbd class="calibre11">...</kbd> syntax if we don't want this wrapping.</p>
<p class="mce-root">In <kbd class="calibre11">App.re</kbd>, we'll remove all props except for the required <kbd class="calibre11">children</kbd> prop. In the render function, we invoke children with our hardcoded greeting:</p>
<pre class="calibre16">/* App.re */<br class="title-page-name"/>let component = ReasonReact.statelessComponent("App");<br class="title-page-name"/><br class="title-page-name"/>let make = children =&gt; {<br class="title-page-name"/>  ...component,<br class="title-page-name"/>  render: _self =&gt; children("hello"),<br class="title-page-name"/>};</pre>
<p class="mce-root">And in <kbd class="calibre11">Index.re</kbd>, we add a function as a child of <kbd class="calibre11">&lt;App /&gt;</kbd> that accepts the provided greeting and returns JSX (which is of type <kbd class="calibre11">ReasonReact.reactElement</kbd>). Notice the <kbd class="calibre11">...</kbd> syntax used to unwrap the array that all ReasonReact children are wrapped with:</p>
<pre class="calibre16">/* Index.re */<br class="title-page-name"/>ReactDOMRe.renderToElementWithId(<br class="title-page-name"/>  &lt;App&gt; ...{greeting =&gt; &lt;div&gt; {ReasonReact.string(greeting)} &lt;/div&gt;} &lt;/App&gt;,<br class="title-page-name"/>  "root",<br class="title-page-name"/>);</pre>
<p class="mce-root">If we forget the <kbd class="calibre11">...</kbd>, the compiler will kindly let us know:</p>
<pre class="calibre16">We've found a bug for you!<br class="title-page-name"/><br class="title-page-name"/>1 │ ReactDOMRe.renderToElementWithId(<br class="title-page-name"/>2 │ &lt;App&gt; {greeting =&gt; &lt;div&gt; {ReasonReact.string(greeting)} &lt;/div&gt;} &lt;/App&gt;,<br class="title-page-name"/>3 │ "root",<br class="title-page-name"/>4 │ );<br class="title-page-name"/><br class="title-page-name"/>This has type:<br class="title-page-name"/>  array('a)<br class="title-page-name"/>But somewhere wanted:<br class="title-page-name"/>  string =&gt; ReasonReact.reactElement</pre>
<p class="mce-root">We'll even get a similar compiler message if we don't include any children (that is, just <kbd class="calibre11">&lt;App /&gt;</kbd>), since that translates into an empty array. This means that we're guaranteed that users of our component have to provide a function of type <kbd class="calibre11">string =&gt; ReasonReact.reactElement</kbd> as a child of <kbd class="calibre11">&lt;App /&gt;</kbd> if it's going to type check.</p>
<p class="mce-root">We can also mandate that our component accepts other children types, for example, a tuple of two strings:</p>
<pre class="calibre16">/* App.re */<br class="title-page-name"/>let component = ReasonReact.statelessComponent("App");<br class="title-page-name"/><br class="title-page-name"/>let make = children =&gt; {<br class="title-page-name"/>  ...component,<br class="title-page-name"/>  render: _self =&gt; {<br class="title-page-name"/>    let (greeting, name) = children;<br class="title-page-name"/>    &lt;div&gt; {ReasonReact.string(greeting ++ " " ++ name)} &lt;/div&gt;;<br class="title-page-name"/>  },<br class="title-page-name"/>};</pre>
<pre class="calibre16">/* Index.re */<br class="title-page-name"/>ReactDOMRe.renderToElementWithId(&lt;App&gt; ...("hello", "tuple") &lt;/App&gt;, "root");</pre>
<p class="mce-root">Reason is able to infer that children must be a tuple of type <kbd class="calibre11">(string, string)</kbd> because of its use in <kbd class="calibre11">App.re</kbd>. For example, consider the following usage:</p>
<pre class="calibre16">ReactDOMRe.renderToElementWithId(&lt;App&gt; ("hello") &lt;/App&gt;, "root");</pre>
<p class="mce-root">This will result in a friendly compiler error because the <kbd class="calibre11">App</kbd> component requires its children to be a tuple but the <kbd class="calibre11">App</kbd> component's children is not a tuple.</p>
<pre class="calibre16">We've found a bug for you!<br class="title-page-name"/><br class="title-page-name"/>1 │ ReactDOMRe.renderToElementWithId(&lt;App&gt; ("hello") &lt;/App&gt;, "root");<br class="title-page-name"/><br class="title-page-name"/>This has type:<br class="title-page-name"/>  array('a)<br class="title-page-name"/>But somewhere wanted:<br class="title-page-name"/>  (string, string)</pre>
<p class="mce-root">This is incredibly powerful. Since we get these guarantees at compile time, we don't have to worry about runtime checks on the shape of our component's children. Similarly, we are guaranteed that props type check at compile time. Refactoring components is much less stressful because the compiler guides us along the way. What's more, thanks to Reason's powerful type inference, we haven't had to explicitly annotate any types so far.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Life cycles</h1>
                </header>
            
            <article>
                
<p class="mce-root">ReasonReact supports the familiar ReactJS life cycle events. We will get a closer look at some of the life cycle events as we build our app, but, for now, let's see how we can implement ReactJS's <kbd class="calibre11">componentDidMount</kbd> life cycle hook for <kbd class="calibre11">&lt;App /&gt;</kbd>:</p>
<pre class="calibre16">let make = _children =&gt; {<br class="title-page-name"/>  ...component,<br class="title-page-name"/>  didMount: _self =&gt; Js.log("mounted"),<br class="title-page-name"/>  render: _self =&gt; &lt;div&gt; {ReasonReact.string("hello")} &lt;/div&gt;,<br class="title-page-name"/>};</pre>
<p class="mce-root">Instead of <kbd class="calibre11">componentDidMount</kbd>, we use <kbd class="calibre11">didMount</kbd>. Again, <kbd class="calibre11">didMount</kbd> is just a field within a record returned by the component's <kbd class="calibre11">make</kbd> function.<span class="calibre5"> </span>The type of <kbd class="calibre11">didMount</kbd> is <kbd class="calibre11">self =&gt; unit</kbd>, which is a function that accepts <kbd class="calibre11">self</kbd> and returns <kbd class="calibre11">unit</kbd>. Since it returns <kbd class="calibre11">unit</kbd>, it's likely that <kbd class="calibre11">didMount</kbd> causes a side effect, and in our example it does. Running this in the browser results in <kbd class="calibre11">mounted</kbd> logged to the console.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Subscriptions helper</h1>
                </header>
            
            <article>
                
<p class="mce-root">To make writing cleanup code more convenient and easier to remember, ReasonReact provides <span class="calibre5"><kbd class="calibre11">self.onUnmount</kbd>, which can be used directly within a component's <kbd class="calibre11">didMount</kbd> life cycle (or anywhere that has access to <kbd class="calibre11">self</kbd>). This allows you to write the cleanup code alongside its complement instead of separately, within <kbd class="calibre11">willUnmount</kbd>:</span></p>
<pre class="calibre16">didMount: self =&gt; {<br class="title-page-name"/>  let intervalId = Js.Global.setInterval(() =&gt; Js.log("hello!"), 1000);<br class="title-page-name"/>  self.onUnmount(() =&gt; Js.Global.clearInterval(intervalId));<br class="title-page-name"/>},</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stateful components</h1>
                </header>
            
            <article>
                
<p class="mce-root">So far, we've only used the <span class="calibre5"><kbd class="calibre11">ReasonReact.statelessComponent</kbd> template. To create a stateful component, we switch out the component template to <kbd class="calibre11">ReasonReact.reducerComponent</kbd> and override some additional fields within the record returned by its <kbd class="calibre11">make</kbd> function. As we'll soon see, we'll also need to declare custom type definitions for use in these additional fields. It's called <kbd class="calibre11">reducerComponent</kbd> because it has the concept of state, actions, and reducers built in—just like Redux, except state, actions, and reducers are local to the component.</span></p>
<p class="mce-root">A simple counter component with buttons to increment and decrement the current count is shown here:</p>
<pre class="calibre16">type state = int;<br class="title-page-name"/><br class="title-page-name"/>type action =<br class="title-page-name"/>  | Increment<br class="title-page-name"/>  | Decrement;<br class="title-page-name"/><br class="title-page-name"/>let component = ReasonReact.reducerComponent("App");<br class="title-page-name"/><br class="title-page-name"/>let make = _children =&gt; {<br class="title-page-name"/>  ...component,<br class="title-page-name"/>  initialState: () =&gt; 0,<br class="title-page-name"/>  reducer: (action, state) =&gt;<br class="title-page-name"/>    switch (action) {<br class="title-page-name"/>    | Increment =&gt; ReasonReact.Update(state + 1)<br class="title-page-name"/>    | Decrement =&gt; ReasonReact.Update(state - 1)<br class="title-page-name"/>    },<br class="title-page-name"/>  render: self =&gt;<br class="title-page-name"/>    &lt;&gt;<br class="title-page-name"/>      &lt;button onClick={_event =&gt; self.send(Decrement)}&gt;<br class="title-page-name"/>        {ReasonReact.string("-")}<br class="title-page-name"/>      &lt;/button&gt;<br class="title-page-name"/>      &lt;span&gt; {ReasonReact.string(string_of_int(self.state))} &lt;/span&gt;<br class="title-page-name"/>      &lt;button onClick={_event =&gt; self.send(Increment)}&gt;<br class="title-page-name"/>        {ReasonReact.string("+")}<br class="title-page-name"/>      &lt;/button&gt;<br class="title-page-name"/>    &lt;/&gt;,<br class="title-page-name"/>};</pre>
<p class="mce-root">The ReactJS Fragment syntax (<kbd class="calibre11">&lt;&gt;</kbd> and <kbd class="calibre11">&lt;/&gt;</kbd>) is used here to wrap the <kbd class="calibre11">&lt;button&gt;</kbd> and <kbd class="calibre11">&lt;span&gt;</kbd> elements without adding an unnecessary DOM node.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">State, action, and reducer</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's break this down. At the top of the file, we see two type declarations, one for state and one for actions. The names <kbd class="calibre11">state</kbd> and <kbd class="calibre11">action</kbd> are a convention, but you can use any name you like:</p>
<pre class="calibre16">type state = int;<br class="title-page-name"/><br class="title-page-name"/>type action =<br class="title-page-name"/>  | Increment<br class="title-page-name"/>  | Decrement;</pre>
<p class="mce-root"><span class="calibre5">Just as in Redux, events trigger actions that are sent to a reducer that then updates state. Next, the button's click event triggers a <kbd class="calibre11">Decrement</kbd> action that gets sent to the component's reducer via <kbd class="calibre11">self.send</kbd>. Remember, the render function is provided <kbd class="calibre11">self</kbd> as its argument:</span></p>
<pre class="calibre16">&lt;button onClick={_event =&gt; self.send(Increment)}&gt;<br class="title-page-name"/>  {ReasonReact.string("+")}<br class="title-page-name"/>&lt;/button&gt;</pre>
<p class="mce-root"><span class="calibre5">The <kbd class="calibre11">state</kbd> type declaration defines the shape of our state. In this case, our state is just an integer that holds the component's current count. The component's initial state is <kbd class="calibre11">0</kbd>:</span></p>
<pre class="calibre16">initialState: () =&gt; 0,</pre>
<p class="mce-root"><kbd class="calibre11">initialState</kbd> requires a function of type <kbd class="calibre11">unit =&gt; state</kbd>.</p>
<p class="mce-root">When triggered by an action, the reducer function accepts that action as well as the current state, and returns a new state. Pattern matching is used on the current action, and <kbd class="calibre11">ReasonReact.Update</kbd> is used to return a new state:</p>
<pre class="calibre16">reducer: (action, state) =&gt;<br class="title-page-name"/>  switch (action) {<br class="title-page-name"/>  | Increment =&gt; ReasonReact.Update(state + 1)<br class="title-page-name"/>  | Decrement =&gt; ReasonReact.Update(state - 1)<br class="title-page-name"/>  },</pre>
<p class="mce-root">To help keep your ReasonReact apps ready for the coming <span class="calibre5">ReactJS Fiber release, ensure that everything in <kbd class="calibre11">reducer</kbd> is pure. One way to trigger side effects indirectly while keeping <kbd class="calibre11">reducer</kbd> pure is by using <kbd class="calibre11">ReasonReact.UpdateWithSideEffects</kbd>:</span></p>
<pre class="calibre16">reducer: (action, state) =&gt;<br class="title-page-name"/>  switch (action) {<br class="title-page-name"/>  | Increment =&gt;<br class="title-page-name"/>    ReasonReact.UpdateWithSideEffects(<br class="title-page-name"/>      state + 1,<br class="title-page-name"/>      (_self =&gt; Js.log("incremented")),<br class="title-page-name"/>    )<br class="title-page-name"/>  | Decrement =&gt; ReasonReact.Update(state - 1)<br class="title-page-name"/>  },</pre>
<p class="mce-root">The return value of <kbd class="calibre11">reducer</kbd> must be one of the following variant constructors:</p>
<ul class="calibre9">
<li class="calibre10"><kbd class="calibre11">ReasonReact.NoUpdate</kbd></li>
<li class="calibre10"><kbd class="calibre11">ReasonReact.Update(state)</kbd></li>
<li class="calibre10"><kbd class="calibre11">ReasonReact.SideEffects(self =&gt; unit)</kbd></li>
<li class="calibre10"><kbd class="calibre11">ReasonReact.UpdateWithSideEffects(state, self =&gt; unit)</kbd></li>
</ul>
<p class="mce-root">We can trigger new actions from within our side effects, since we're again provided with <kbd class="calibre11">self</kbd>:</p>
<pre class="calibre16">reducer: (action, state) =&gt;<br class="title-page-name"/>  switch (action) {<br class="title-page-name"/>  | Increment =&gt;<br class="title-page-name"/>    ReasonReact.UpdateWithSideEffects(<br class="title-page-name"/>      state + 1,<br class="title-page-name"/>      (<br class="title-page-name"/>        self =&gt;<br class="title-page-name"/>          Js.Global.setTimeout(() =&gt; self.send(Decrement), 1000) |&gt; ignore<br class="title-page-name"/>      ),<br class="title-page-name"/>    )<br class="title-page-name"/>  | Decrement =&gt; ReasonReact.Update(state - 1)<br class="title-page-name"/>  },</pre>
<p class="mce-root">After incrementing, the <kbd class="calibre11">reducer</kbd> triggers a side-effect that triggers the <kbd class="calibre11">Decrement</kbd> action after one second.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refactoring</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's imagine we now need our stateful component to display a message that congratulates the user when they get to a count of 10, and once the message is displayed, the user can close the message by clicking a close button. Thanks to our helpful compiler, we can follow these steps:</p>
<ol class="calibre12">
<li class="calibre10">Update the shape of <kbd class="calibre11">state</kbd></li>
<li class="calibre10">Update the available <kbd class="calibre11">actions</kbd></li>
<li class="calibre10">Step through the compiler errors</li>
<li class="calibre10">Update the <kbd class="calibre11">render</kbd> function</li>
</ol>
<p class="mce-root">The compiler messages will remind us to update the component's initial state and reducer. Since we now need to also keep track of whether or not to display a message, let's change the shape of <kbd class="calibre11">state</kbd> to this:</p>
<pre class="calibre16">type state = {<br class="title-page-name"/>  count: int,<br class="title-page-name"/>  showMessage: bool<br class="title-page-name"/>};</pre>
<p class="mce-root">For our actions, let's combine <kbd class="calibre11">Increment</kbd> and <kbd class="calibre11">Decrement</kbd> into one constructor that accepts an <kbd class="calibre11">int</kbd>, and we'll have a new constructor to toggle the message:</p>
<pre class="calibre16">type action =<br class="title-page-name"/>  | UpdateCount(int)<br class="title-page-name"/>  | ToggleMessage;</pre>
<p class="mce-root">Now, instead of <kbd class="calibre11">Increment</kbd> and <kbd class="calibre11">Decrement</kbd>, we have <kbd class="calibre11">UpdateCount</kbd>, which holds an integer representing the amount to change the current count by.</p>
<p class="mce-root">After compiling, we see a friendly error letting us know that our previous action <kbd class="calibre11">Decrement</kbd> cannot be found:</p>
<pre class="calibre16">We've found a bug for you!<br class="title-page-name"/>24 | render: self =&gt;<br class="title-page-name"/>25 | &lt;&gt;<br class="title-page-name"/>26 | &lt;button onClick={_event =&gt; self.send(Decrement)}&gt;<br class="title-page-name"/>27 | {ReasonReact.string("-")}<br class="title-page-name"/>28 | &lt;/button&gt;<br class="title-page-name"/>The variant constructor Decrement can't be found.<br class="title-page-name"/>- If it's defined in another module or file, bring it into scope by:<br class="title-page-name"/>- Annotating it with said module name: let food = MyModule.Apple<br class="title-page-name"/>- Or specifying its type: let food: MyModule.fruit = Apple<br class="title-page-name"/>- Constructors and modules are both capitalized. Did you want the latter?<br class="title-page-name"/>Then instead of let foo = Bar, try module Foo = Bar.</pre>
<p class="mce-root">In the <kbd class="calibre11">render</kbd> function, replace  <kbd class="calibre11">Increment</kbd>  with <kbd class="calibre11">UpdateCount(+1)</kbd> and <kbd class="calibre11">Decrement</kbd> with <kbd class="calibre11">UpdateCount(-1)</kbd>:</p>
<pre class="calibre16">render: self =&gt;<br class="title-page-name"/>  &lt;&gt;<br class="title-page-name"/>    &lt;button onClick={_event =&gt; self.send(UpdateCount(-1))}&gt;<br class="title-page-name"/>      {ReasonReact.string("-")}<br class="title-page-name"/>    &lt;/button&gt;<br class="title-page-name"/>    &lt;span&gt; {ReasonReact.string(string_of_int(self.state))} &lt;/span&gt;<br class="title-page-name"/>    &lt;button onClick={_event =&gt; self.send(UpdateCount(1))}&gt;<br class="title-page-name"/>      {ReasonReact.string("+")}<br class="title-page-name"/>    &lt;/button&gt;<br class="title-page-name"/>  &lt;/&gt;,</pre>
<p class="mce-root">Compiling again, we're informed that in our reducer, <kbd class="calibre11">Increment</kbd><span class="calibre5"> does not belong to type <kbd class="calibre11">action</kbd>. Let's update our reducer to handle both <kbd class="calibre11">UpdateCount</kbd> and <kbd class="calibre11">ToggleMessage</kbd>. If we were to forget a constructor, the compiler would let us know that the switch expression in the reducer is not exhaustive:</span></p>
<pre class="calibre16">reducer: (action, state) =&gt;<br class="title-page-name"/>  switch (action) {<br class="title-page-name"/>  | UpdateCount(delta) =&gt;<br class="title-page-name"/>    let count = state.count + delta;<br class="title-page-name"/>    ReasonReact.UpdateWithSideEffects(<br class="title-page-name"/>      {...state, count},<br class="title-page-name"/>      (<br class="title-page-name"/>        self =&gt;<br class="title-page-name"/>          if (count == 10) {<br class="title-page-name"/>            self.send(ToggleMessage);<br class="title-page-name"/>          }<br class="title-page-name"/>      ),<br class="title-page-name"/>    );<br class="title-page-name"/>  | ToggleMessage =&gt;<br class="title-page-name"/>    ReasonReact.Update({...state, showMessage: !state.showMessage})<br class="title-page-name"/>  },</pre>
<p class="mce-root">There are few things to mention regarding the preceding code snippet:</p>
<ul class="calibre9">
<li class="calibre10">In <kbd class="calibre11">UpdateCount</kbd>, we're declaring a binding <kbd class="calibre11">count</kbd> that reflects the new count.</li>
<li class="calibre10">We're using<span> </span><kbd class="calibre11">...</kbd><span> </span>to <span>override just a portion of the state record.</span></li>
<li class="calibre10">Thanks to record punning support, we can write <kbd class="calibre11">{...state, count}</kbd> instead of <kbd class="calibre11">{...state, count: count}</kbd>.</li>
<li class="calibre10"><kbd class="calibre11">UpdateCount</kbd> is <span>using </span><kbd class="calibre11">UpdateWithSideEffects</kbd><span> to </span>trigger a <kbd class="calibre11">ToggleMessage</kbd> action when the count reaches 10; we could have instead done this:</li>
</ul>
<pre class="calibre18">| UpdateCount(delta) =&gt;<br class="title-page-name"/>  let count = state.count + delta;<br class="title-page-name"/>  ReasonReact.Update(<br class="title-page-name"/>    if (count == 10) {<br class="title-page-name"/>      {count, showMessage: true};<br class="title-page-name"/>    } else {<br class="title-page-name"/>      {...state, count};<br class="title-page-name"/>    },<br class="title-page-name"/>  );</pre>
<p class="mce-root">I prefer using <kbd class="calibre11">UpdateWithSideEffects</kbd> so that <kbd class="calibre11">UpdateCount</kbd> only ever has to worry about its count field, and if some other field needs to get updated, <kbd class="calibre11">UpdateCount</kbd> can trigger the right action for that to happen, without needing to know how it needs to happen. </p>
<p class="mce-root">After compiling here, we get an interesting compiler error:</p>
<pre class="calibre16">We've found a bug for you!<br class="title-page-name"/><br class="title-page-name"/>16 | switch (action) {<br class="title-page-name"/>17 | | UpdateCount(delta) =&gt;<br class="title-page-name"/>18 | let count = state.count + delta;<br class="title-page-name"/>19 | ReasonReact.UpdateWithSideEffects(<br class="title-page-name"/>20 | {...state, count},<br class="title-page-name"/><br class="title-page-name"/>This has type:<br class="title-page-name"/>  int<br class="title-page-name"/>But somewhere wanted:<br class="title-page-name"/>  state</pre>
<p class="mce-root">The compiler sees <kbd class="calibre11">state</kbd> in <kbd class="calibre11">state.count</kbd> on line 18 (shown previously) as having type <kbd class="calibre11">int</kbd> instead of type <kbd class="calibre11">state</kbd>. This is because our render function is using <kbd class="calibre11">string_of_int(self.state)</kbd> instead of <kbd class="calibre11">string_of_int(self.state.count)</kbd>. After updating our render function to reflect this, we get another similar message complaining that type <kbd class="calibre11">int</kbd> and type <kbd class="calibre11">state</kbd> are incompatible. That's because our initial state is still returning <kbd class="calibre11">0</kbd> instead of a record of type <kbd class="calibre11">state</kbd>.</p>
<p class="mce-root">After updating initial state, the code finally compiles successfully:</p>
<pre class="calibre16">initialState: () =&gt; {count: 0, showMessage: false},</pre>
<p class="mce-root">Now, we're ready to update the render function to display a message when the count reaches 10:</p>
<pre class="calibre16">render: self =&gt;<br class="title-page-name"/>  &lt;&gt;<br class="title-page-name"/>    &lt;button onClick={_event =&gt; self.send(UpdateCount(-1))}&gt;<br class="title-page-name"/>      {ReasonReact.string("-")}<br class="title-page-name"/>    &lt;/button&gt;<br class="title-page-name"/>    &lt;span&gt; {ReasonReact.string(string_of_int(self.state.count))} &lt;/span&gt;<br class="title-page-name"/>    &lt;button onClick={_event =&gt; self.send(UpdateCount(1))}&gt;<br class="title-page-name"/>      {ReasonReact.string("+")}<br class="title-page-name"/>    &lt;/button&gt;<br class="title-page-name"/>    {<br class="title-page-name"/>      if (self.state.showMessage) {<br class="title-page-name"/>        &lt;&gt;<br class="title-page-name"/>          &lt;p&gt;<br class="title-page-name"/>            {ReasonReact.string("Congratulations! You've reached ten!")}<br class="title-page-name"/>          &lt;/p&gt;<br class="title-page-name"/>          &lt;button onClick={_event =&gt; self.send(ToggleMessage)}&gt;<br class="title-page-name"/>            {ReasonReact.string("close")}<br class="title-page-name"/>          &lt;/button&gt;<br class="title-page-name"/>        &lt;/&gt;;<br class="title-page-name"/>      } else {<br class="title-page-name"/>        ReasonReact.null;<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/>  &lt;/&gt;,</pre>
<p class="mce-root">Since <kbd class="calibre11">if/else</kbd> is an expression in Reason, we can use it within JSX to either render markup or <kbd class="calibre11">ReasonReact.null</kbd> (which has type <kbd class="calibre11">ReasonReact.reactElement</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Instance variables</h1>
                </header>
            
            <article>
                
<p class="mce-root">Although our example correctly shows the message when count reaches 10 for the first time, there is nothing preventing our <kbd class="calibre11">ToggleMessage</kbd> action from getting fired again within the <kbd class="calibre11">UpdateCount</kbd> case in the reducer. If a user gets to 10, then decrements and then increments, the message is toggled again. To ensure that <kbd class="calibre11">UpdateCount</kbd> only ever triggers the <kbd class="calibre11">ToggleMessage</kbd> action once, we can use an <strong class="calibre4">instance variable</strong> in state.</p>
<p class="mce-root">In ReactJS, every time something in state changes, the component gets re-rendered. In ReasonReact, instance variables never trigger a re-render, and can be correctly placed within a component's state. </p>
<p class="mce-root">Let's add an instance variable to keep track of whether the user has already seen the message:</p>
<pre class="calibre16">type state = {<br class="title-page-name"/>  count: int,<br class="title-page-name"/>  showMessage: bool,<br class="title-page-name"/>  userHasSeenMessage: ref(bool)<br class="title-page-name"/>};</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ref and mutable records</h1>
                </header>
            
            <article>
                
<p class="mce-root">The difference between ReasonReact instance variables and normal state variables is the use of <kbd class="calibre11">ref</kbd>. Previously, we saw that <kbd class="calibre11">state.userHasSeenMessage</kbd> is of type <kbd class="calibre11">ref(bool)</kbd> instead of <kbd class="calibre11">bool</kbd>. That makes <kbd class="calibre11">state.userHasSeenMessage</kbd> an instance variable.</p>
<p class="mce-root">Since <kbd class="calibre11">ref</kbd> is just syntactic sugar for a record type with a mutable field, let's first discuss mutable record fields.</p>
<p class="mce-root">To allow a record field to be mutable, prefix the field's name with <kbd class="calibre11">mutable</kbd>. Then, those fields can be updated in place using the <kbd class="calibre11">=</kbd> operator:</p>
<pre class="calibre16">type ref('a) = {<br class="title-page-name"/>  mutable contents: 'a<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>let foo = {contents: 5};<br class="title-page-name"/>Js.log(foo.contents); /* 5 */<br class="title-page-name"/>foo.contents = 6;<br class="title-page-name"/>Js.log(foo.contents); /* 6 */</pre>
<p class="mce-root">However, the type declaration is already included in Reason's standard library, so we can omit it, and the rest of the preceding code would still work, declaring it shadowed the original type declaration. We can prove this by shadowing the <kbd class="calibre11">ref</kbd> type with an immutable record:</p>
<pre class="calibre16">type ref('a) = {contents: 'a};<br class="title-page-name"/><br class="title-page-name"/>let foo = {contents: 5};<br class="title-page-name"/>Js.log(foo.contents); /* 5 */<br class="title-page-name"/>foo.contents = 6;<br class="title-page-name"/>Js.log(foo.contents); /* 6 */</pre>
<p class="mce-root">The compiler fails with the following error:</p>
<pre class="calibre16"><span>We've found a bug for you!</span>

The record field contents is not mutable</pre>
<p class="mce-root">In addition to having a built-in type definition, <kbd class="calibre11">ref</kbd> also has some built-in functions. Namely, <kbd class="calibre11">ref</kbd> is used to create a record of type <kbd class="calibre11">ref</kbd>, and <kbd class="calibre11">^</kbd> is used to get the contents of a <kbd class="calibre11">ref</kbd>, and <kbd class="calibre11">:=</kbd> is used to set the contents of a ref:</p>
<pre class="calibre16">type foo = ref(int);<br class="title-page-name"/><br class="title-page-name"/>let foo = ref(5);<br class="title-page-name"/>Js.log(foo^); /* 5 */<br class="title-page-name"/>foo := 6;<br class="title-page-name"/>Js.log(foo^); /* 6 */</pre>
<p class="mce-root">Let's go back to our ReasonReact example, and let's use our new <kbd class="calibre11">userHasSeenMessage</kbd> instance variable. After updating the shape of our state, we need to also update the component's initial state:</p>
<pre class="calibre16">initialState: () =&gt; {<br class="title-page-name"/>  count: 0,<br class="title-page-name"/>  showMessage: false,<br class="title-page-name"/>  userHasSeenMessage: ref(false),<br class="title-page-name"/>},</pre>
<p class="mce-root">Now, our code again compiles, and we can update <kbd class="calibre11">reducer</kbd> to use this instance variable:</p>
<pre class="calibre16">reducer: (action, state) =&gt;<br class="title-page-name"/>  switch (action) {<br class="title-page-name"/>  | UpdateCount(delta) =&gt;<br class="title-page-name"/>    let count = state.count + delta;<br class="title-page-name"/>    if (! state.userHasSeenMessage^ &amp;&amp; count == 10) {<br class="title-page-name"/>      state.userHasSeenMessage := true;<br class="title-page-name"/>      ReasonReact.UpdateWithSideEffects(<br class="title-page-name"/>        {...state, count},<br class="title-page-name"/>        (self =&gt; self.send(ToggleMessage)),<br class="title-page-name"/>      );<br class="title-page-name"/>    } else {<br class="title-page-name"/>      ReasonReact.Update({...state, count});<br class="title-page-name"/>    };<br class="title-page-name"/>  | ToggleMessage =&gt;<br class="title-page-name"/>    ReasonReact.Update({...state, showMessage: !state.showMessage})<br class="title-page-name"/>  },</pre>
<p class="mce-root">Now, the message is correctly displayed once and only once.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Navigation menu</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's use what we've learned so far as a foundation to build upon while creating an application with a navigation menu and client-side routing. On touch devices, users will be able to swipe to close the menu, and the menu will respond in real time to the user's touch. If the user swipes the menu when it's more than 50% closed and then releases, the menu will close; otherwise, it will remain open. The one exception is if the user swipes the menu closed with a high enough velocity; it will always close.</p>
<p class="mce-root">We will be working with this application throughout the rest of the book. To follow along, clone the GitHub repo and navigate to the directory representing the start of this chapter:</p>
<pre class="calibre16"><strong class="calibre1">git clone https://github.com/PacktPublishing/ReasonML-Quick-Start-Guide.git</strong><br class="title-page-name"/><strong class="calibre1">cd ReasonML-Quick-Start-Guide</strong><br class="title-page-name"/><strong class="calibre1">cd Chapter03/app-start<br class="title-page-name"/>npm install</strong></pre>
<p class="mce-root">Let's take a moment to see what we have to work with. You will see the following directory structure:</p>
<pre class="calibre16">├── bsconfig.json<br class="title-page-name"/>├── package-lock.json<br class="title-page-name"/>├── package.json<br class="title-page-name"/>├── src<br class="title-page-name"/>│   ├── App.re<br class="title-page-name"/>│   ├── App.scss<br class="title-page-name"/>│   ├── Index.re<br class="title-page-name"/>│   ├── Index.scss<br class="title-page-name"/>│   ├── img<br class="title-page-name"/>│   │   └── icon<br class="title-page-name"/>│   │   ├── arrow.svg<br class="title-page-name"/>│   │   ├── chevron.svg<br class="title-page-name"/>│   │   └── hamburger.svg<br class="title-page-name"/>│   └── index.html<br class="title-page-name"/>└── webpack.config.js</pre>
<p class="mce-root">Our <kbd class="calibre11">bsconfig.json</kbd> is set up to place compiled <kbd class="calibre11">.bs.js</kbd> files within <kbd class="calibre11">lib/es6/src</kbd>, and we've configured webpack to look for <kbd class="calibre11">lib/es6/src/Index.bs.js</kbd> as an entry point. </p>
<p class="mce-root">Run <kbd class="calibre11">npm install</kbd> and then <kbd class="calibre11">npm start</kbd> to serve our app at <kbd class="calibre11">http://localhost:3000</kbd> with both bsb and webpack in watch mode.</p>
<p class="mce-root">Currently, our app displays a blue navigation bar with a hamburger icon. Clicking on the icon opens a menu and clicking outside the menu closes it.</p>
<p class="mce-root">In <kbd class="calibre11">App.re</kbd>, our state is currently a single field record that keeps track of the menu's state:</p>
<pre class="calibre16">type state = {isOpen: bool};</pre>
<p class="mce-root">We have one action:</p>
<pre class="calibre16">type action =<br class="title-page-name"/>  | ToggleMenu(bool);</pre>
<p class="mce-root">And our reducer takes care of updating the menu's state:</p>
<pre class="calibre16">reducer: (action, _state) =&gt;<br class="title-page-name"/>  switch (action) {<br class="title-page-name"/>  | ToggleMenu(isOpen) =&gt; ReasonReact.Update({isOpen: isOpen})<br class="title-page-name"/>  },</pre>
<div class="packt_figref1">Although Reason supports record punning, it does not work for single field records, since Reason treats <kbd class="calibre20">{isOpen}</kbd> as a block instead of a record.</div>
<p class="mce-root">Our render function renders a <kbd class="calibre11">&lt;div /&gt;</kbd> element with a conditional class name depending on the current state:</p>
<pre class="calibre16">&lt;div<br class="title-page-name"/>  className={"App" ++ (self.state.isOpen ? " overlay" : "")}<br class="title-page-name"/>  onClick={<br class="title-page-name"/>    _event =&gt;<br class="title-page-name"/>      if (self.state.isOpen) {<br class="title-page-name"/>        self.send(ToggleMenu(false));<br class="title-page-name"/>      }<br class="title-page-name"/>  }&gt;</pre>
<p class="mce-root"><kbd class="calibre11">App.scss</kbd> uses the <kbd class="calibre11">overlay</kbd> class to display a dark overlay behind the navigation menu only when it's open:</p>
<pre class="calibre16">.App {<br class="title-page-name"/>  min-height: 100vh;<br class="title-page-name"/><br class="title-page-name"/>  &amp;:after {<br class="title-page-name"/>    content: "";<br class="title-page-name"/>    transition: opacity 450ms cubic-bezier(0.23, 1, 0.32, 1),<br class="title-page-name"/>      transform 0ms cubic-bezier(0.23, 1, 0.32, 1) 450ms;<br class="title-page-name"/>    position: fixed;<br class="title-page-name"/>    top: 0;<br class="title-page-name"/>    right: 0;<br class="title-page-name"/>    bottom: 0;<br class="title-page-name"/>    left: 0;<br class="title-page-name"/>    background-color: rgba(0, 0, 0, 0.33);<br class="title-page-name"/>    transform: translateX(-100%);<br class="title-page-name"/>    opacity: 0;<br class="title-page-name"/>    z-index: 1;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  &amp;.overlay {<br class="title-page-name"/>    &amp;:after {<br class="title-page-name"/>      transition: opacity 450ms cubic-bezier(0.23, 1, 0.32, 1);<br class="title-page-name"/>      transform: translateX(0%);<br class="title-page-name"/>      opacity: 1;<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>  ...<br class="title-page-name"/>}</pre>
<p class="mce-root"><span class="calibre5">Notice how the </span><kbd class="calibre11">transition</kbd><span class="calibre5"> property is defined for </span><span class="calibre5">both  </span><kbd class="calibre11">.App:after</kbd><span class="calibre5">  and  </span><kbd class="calibre11">.App.overly:after</kbd><span class="calibre5">, the former includes a transition on the <kbd class="calibre11">transform</kbd> property with a </span><kbd class="calibre11">450ms</kbd><span class="calibre5"> delay while the latter removes that transition. This has the effect of allowing a smooth transition even when the menu is closed.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bindings</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="calibre5">Let's inspect the binding to JavaScript's </span><kbd class="calibre11">require</kbd><span class="calibre5"> function at the top of </span><kbd class="calibre11">App.re</kbd><span class="calibre5">. </span>Since we're going to dive deeper into BuckleScript in <a href="201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml" target="_blank" class="calibre8">Chapter 4</a>, <em class="calibre15">BuckleScript, Belt, and Interoperability</em>, let's defer discussing the details and just briefly see what this binding is doing:</p>
<pre class="calibre16">[@bs.val] external require: string =&gt; string = "";<br class="title-page-name"/><br class="title-page-name"/>require("../../../src/App.scss");</pre>
<p class="mce-root">The <kbd class="calibre11">external</kbd> keyword creates a new binding, similar to the <kbd class="calibre11">let</kbd> keyword. After binding to JavaScript's <kbd class="calibre11">require</kbd> function, we can use it in Reason, as long as we're using the BuckleScript compiler. We use it to require <kbd class="calibre11">App.scss</kbd> as well as a few images. Inspecting the compiled output at <kbd class="calibre11">lib/es6/src/App.bs.js</kbd> shows that the preceding Reason code compiles to the following:</p>
<pre class="calibre16">require("../../../src/App.scss");</pre>
<p class="mce-root">Webpack handles the rest from there.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Events</h1>
                </header>
            
            <article>
                
<p class="mce-root">Since the top-level <kbd class="calibre11">&lt;div /&gt;</kbd> element has a click event handler that always closes the menu, any clicks on its children also fire that top-level click event handler. To allow the menu to open (or remain open), we need to call <kbd class="calibre11">event.stopPropagation()</kbd> on click events for some of its child elements.</p>
<p class="mce-root">In ReasonReact, we can do this with the <kbd class="calibre11">ReactEvent</kbd> module:</p>
<pre class="calibre16">onClick=(event =&gt; ReactEvent.Mouse.stopPropagation(event))</pre>
<p class="mce-root">The <kbd class="calibre11">ReactEvent</kbd> module has submodules corresponding to each of ReactJS's synthetic events:</p>
<ul class="calibre9">
<li class="calibre10">Clipboard events</li>
<li class="calibre10">Composition events</li>
<li class="calibre10">Keyboard events</li>
<li class="calibre10">Focus events</li>
<li class="calibre10">Form events</li>
<li class="calibre10">Mouse events</li>
<li class="calibre10">Pointer events</li>
<li class="calibre10">Selection events</li>
<li class="calibre10">Touch events</li>
<li class="calibre10">UI events</li>
<li class="calibre10">Wheel events</li>
<li class="calibre10">Media events</li>
<li class="calibre10">Image events</li>
<li class="calibre10">Animation events</li>
<li class="calibre10">Transition events</li>
</ul>
<p class="mce-root">For more information on ReactJS's synthetic events, visit <a href="https://reactjs.org/docs/events.html" class="calibre8">https://reactjs.org/docs/events.html</a>.</p>
<p class="mce-root">To get values such as <kbd class="calibre11">event.changedTouches.item(0).clientX</kbd> from a touch event, we use a combination of ReasonReact and BuckleScript.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Js.t Object</h1>
                </header>
            
            <article>
                
<p class="mce-root">BuckleScript allows us to access arbitrary JavaScript object fields using the <kbd class="calibre11">##</kbd> syntax. We can use syntax on any <kbd class="calibre11">Js.t</kbd> type, which is a Reason type for arbitrary JavaScript objects. We'll learn more about this and other interoperability features in <a href="201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml" target="_blank" class="calibre8">Chapter 4</a>, <em class="calibre15">BuckleScript, Belt, and Interoperability</em>. </p>
<p class="mce-root">Since <kbd class="calibre11">ReactEvent.Touch.changedTouches(event)</kbd> returns a plain old JavaScript object, we can access its fields using the following:</p>
<pre class="calibre16">/* App.re */<br class="title-page-name"/>ReactEvent.Touch.changedTouches(event)##item(0)##clientX</pre>
<p class="mce-root">Looking in the compiled output, we see that it is what we want:</p>
<pre class="calibre16"><span>/* App.bs.js */<br class="title-page-name"/>event.changedTouches.item(0).clientX</span></pre>
<p class="mce-root">We'll use this to add the touch feature to our menu so that users can swipe the menu closed and see the menu move as they swipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding actions</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's start by adding actions for <kbd class="calibre11">TouchStart</kbd>, <kbd class="calibre11">TouchMove</kbd>, and <kbd class="calibre11">TouchEnd</kbd>:</p>
<pre class="calibre16">type action =<br class="title-page-name"/>  | ToggleMenu(bool)<br class="title-page-name"/>  | TouchStart(float)<br class="title-page-name"/>  | TouchMove(float)<br class="title-page-name"/>  | TouchEnd;</pre>
<p class="mce-root">We'll need the touch event's <kbd class="calibre11">clientX</kbd> property only for <kbd class="calibre11">TouchStart</kbd> and <kbd class="calibre11">TouchMove</kbd>.</p>
<p class="mce-root">Let's add the event listeners on the top-level <kbd class="calibre11">&lt;div /&gt;</kbd> component:</p>
<pre class="calibre16">render: self =&gt;<br class="title-page-name"/>  &lt;div<br class="title-page-name"/>    className={"App" ++ (self.state.isOpen ? " overlay" : "")}<br class="title-page-name"/>    onClick={<br class="title-page-name"/>      _event =&gt;<br class="title-page-name"/>        if (self.state.isOpen) {<br class="title-page-name"/>          self.send(ToggleMenu(false));<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>    onTouchStart={<br class="title-page-name"/>      event =&gt;<br class="title-page-name"/>        self.send(<br class="title-page-name"/>          TouchStart(<br class="title-page-name"/>            ReactEvent.Touch.changedTouches(event)##item(0)##clientX,<br class="title-page-name"/>          ),<br class="title-page-name"/>        )<br class="title-page-name"/>    }<br class="title-page-name"/>    onTouchMove={<br class="title-page-name"/>      event =&gt;<br class="title-page-name"/>        self.send(<br class="title-page-name"/>          TouchMove(<br class="title-page-name"/>            ReactEvent.Touch.changedTouches(event)##item(0)##clientX,<br class="title-page-name"/>          ),<br class="title-page-name"/>        )<br class="title-page-name"/>    }<br class="title-page-name"/>    onTouchEnd={_event =&gt; self.send(TouchEnd)}&gt;</pre>
<p class="mce-root">In our reducer, let's just log those <kbd class="calibre11">clientX</kbd> values for now:</p>
<pre class="calibre16">reducer: (action, state) =&gt;<br class="title-page-name"/>  switch (action) {<br class="title-page-name"/>  | ToggleMenu(isOpen) =&gt; ReasonReact.Update({isOpen: isOpen})<br class="title-page-name"/>  | TouchStart(clientX) =&gt;<br class="title-page-name"/>    Js.log2("Start", clientX);<br class="title-page-name"/>    ReasonReact.NoUpdate;<br class="title-page-name"/>  | TouchMove(clientX) =&gt;<br class="title-page-name"/>    Js.log2("Move", clientX);<br class="title-page-name"/>    ReasonReact.NoUpdate;<br class="title-page-name"/>  | TouchEnd =&gt;<br class="title-page-name"/>    Js.log("End");<br class="title-page-name"/>    ReasonReact.NoUpdate;<br class="title-page-name"/>  },</pre>
<p class="mce-root">To figure out the overall direction of a user's swipe, we need the first and last <kbd class="calibre11">clientX</kbd> values for that swipe. The menu should move in proportion to the difference of the first and last <kbd class="calibre11">clientX</kbd> values, but only if the user is swiping in the direction that would close the menu.</p>
<p class="mce-root">Our state now includes a <kbd class="calibre11">touches</kbd> record that holds the value for the first and last <kbd class="calibre11">clientX</kbd> values:</p>
<pre class="calibre16">type touches = {<br class="title-page-name"/>  first: option(float),<br class="title-page-name"/>  last: option(float),<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>type state = {<br class="title-page-name"/>  isOpen: bool,<br class="title-page-name"/>  touches,<br class="title-page-name"/>};</pre>
<p class="mce-root">Since we cannot nest record type definitions, we define the <kbd class="calibre11">touches</kbd> type separately and include it in <kbd class="calibre11">state</kbd>. You'll notice <kbd class="calibre11">state.touches.first</kbd> is of type <kbd class="calibre11">option(float)</kbd> because<span class="calibre5"> it's possible that</span> the user isn't using a touch device or that the user hasn't yet interacted.</p>
<p class="mce-root">Changing the shape of our state requires us to also change the initial state:</p>
<pre class="calibre16">initialState: () =&gt; {<br class="title-page-name"/>  isOpen: false,<br class="title-page-name"/>  touches: {<br class="title-page-name"/>    first: None,<br class="title-page-name"/>    last: None,<br class="title-page-name"/>  },<br class="title-page-name"/>},</pre>
<p class="mce-root">In the reducer, if the menu is open, we update <kbd class="calibre11">state.touches</kbd> with a fresh new record in the <kbd class="calibre11">TouchStart</kbd> case, but in the <kbd class="calibre11">TouchMove</kbd> case, we only update <kbd class="calibre11">state.touches.last</kbd>. If the menu is not currently open, <kbd class="calibre11">ReasonReact.NoUpdate</kbd> is returned:</p>
<pre class="calibre16">reducer: (action, state) =&gt;<br class="title-page-name"/>  switch (action) {<br class="title-page-name"/>  | ToggleMenu(isOpen) =&gt; ReasonReact.Update({...state, isOpen})<br class="title-page-name"/>  | TouchStart(clientX) =&gt;<br class="title-page-name"/>    if (state.isOpen) {<br class="title-page-name"/>      ReasonReact.Update({<br class="title-page-name"/>        ...state,<br class="title-page-name"/>        touches: {<br class="title-page-name"/>          first: Some(clientX),<br class="title-page-name"/>          last: None,<br class="title-page-name"/>        },<br class="title-page-name"/>      });<br class="title-page-name"/>    } else {<br class="title-page-name"/>      ReasonReact.NoUpdate;<br class="title-page-name"/>    }<br class="title-page-name"/>  | TouchMove(clientX) =&gt;<br class="title-page-name"/>    if (state.isOpen) {<br class="title-page-name"/>      ReasonReact.Update({<br class="title-page-name"/>        ...state,<br class="title-page-name"/>        touches: {<br class="title-page-name"/>          ...state.touches,<br class="title-page-name"/>          last: Some(clientX),<br class="title-page-name"/>        },<br class="title-page-name"/>      });<br class="title-page-name"/>    } else {<br class="title-page-name"/>      ReasonReact.NoUpdate;<br class="title-page-name"/>    }<br class="title-page-name"/>  | TouchEnd =&gt; ReasonReact.NoUpdate<br class="title-page-name"/>  },</pre>
<p class="mce-root">We'll soon use this state to conditionally set an inline style on the <kbd class="calibre11">&lt;nav /&gt;</kbd> element.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inline styles</h1>
                </header>
            
            <article>
                
<p class="mce-root">In ReasonReact, we can add inline styles via <kbd class="calibre11">ReactDOMRe.Style.make</kbd>, which accepts CSS properties as optional labelled arguments. Since they are all optional, passing <kbd class="calibre11">unit</kbd> is <span class="calibre5">necessary to call the function:</span></p>
<pre class="calibre16">style={ReactDOMRe.Style.make(~backgroundColor="yellow", ())}</pre>
<p class="mce-root">Applying this to our <kbd class="calibre11">&lt;nav /&gt;</kbd> element, we can conditionally add a style if we have both a first and last touch in state:</p>
<pre class="calibre16">style={<br class="title-page-name"/>  switch (self.state.touches) {<br class="title-page-name"/>  | {first: Some(x), last: Some(x')} =&gt;<br class="title-page-name"/>    ReactDOMRe.Style.make(<br class="title-page-name"/>      ~transform=<br class="title-page-name"/>        "translateX("<br class="title-page-name"/>        ++ string_of_float(x' -. x &gt; 0.0 ? 0.0 : x' -. x)<br class="title-page-name"/>        ++ "0px)",<br class="title-page-name"/>      ~transition="none",<br class="title-page-name"/>      (),<br class="title-page-name"/>    )<br class="title-page-name"/>  | _ =&gt; ReactDOMRe.Style.make()<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">Within the <kbd class="calibre11">transform</kbd> property, we concatenate with <kbd class="calibre11">"0px"</kbd> instead of just <kbd class="calibre11">"px"</kbd> since the <kbd class="calibre11">float</kbd> type always includes a decimal point, but it's possible that the user swipes a distance of exactly one hundred pixels, and <kbd class="calibre11">transform: translateX(100.px)</kbd> is not valid CSS, but <span class="calibre5"><kbd class="calibre11">transform: translateX(100.0px)</kbd> is.</span></p>
<p class="mce-root">Running this on a touch device shows that we're able to get the menu's position to change based on the user's swipe. Now, let's focus on the <kbd class="calibre11">TouchEnd</kbd> case within the reducer. For now, let's set the menu to remain open if the user swipes the menu less than half way closed, and close it otherwise. I<span class="calibre5">f </span><kbd class="calibre11">state.touches.last</kbd><span class="calibre5"> is </span><kbd class="calibre11">None</kbd><span class="calibre5">, then the user did not swipe, and we don't update <kbd class="calibre11">state</kbd>:</span></p>
<pre class="calibre16">| TouchEnd =&gt;<br class="title-page-name"/>  if (state.isOpen) {<br class="title-page-name"/>    let x = Belt.Option.getWithDefault(state.touches.last, 0.0);<br class="title-page-name"/>    if (x &lt; 300.0 /. 2.0) {<br class="title-page-name"/>      ReasonReact.UpdateWithSideEffects(<br class="title-page-name"/>        {<br class="title-page-name"/>          ...state,<br class="title-page-name"/>          touches: {<br class="title-page-name"/>            first: None,<br class="title-page-name"/>            last: None,<br class="title-page-name"/>          },<br class="title-page-name"/>        },<br class="title-page-name"/>        (self =&gt; self.send(ToggleMenu(false))),<br class="title-page-name"/>      );<br class="title-page-name"/>    } else {<br class="title-page-name"/>      ReasonReact.Update({<br class="title-page-name"/>        ...state,<br class="title-page-name"/>        touches: {<br class="title-page-name"/>          first: None,<br class="title-page-name"/>          last: None,<br class="title-page-name"/>        },<br class="title-page-name"/>      });<br class="title-page-name"/>    };<br class="title-page-name"/>  } else {<br class="title-page-name"/>    ReasonReact.NoUpdate;<br class="title-page-name"/>  }</pre>
<p class="mce-root">Notice that we reset <kbd class="calibre11">state.touches</kbd> to a fresh new record with <kbd class="calibre11">{first: None, last: None}</kbd>, which results in an empty style prop on the <kbd class="calibre11">&lt;nav /&gt;</kbd> element.</p>
<p class="mce-root">This current implementation assumes that the width of the navigation is <kbd class="calibre11">300px</kbd>. Instead of assuming, we can use a React re<span class="calibre5">f to get a reference to the DOM node, and then get its <kbd class="calibre11">clientWidth</kbd>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">React ref </h1>
                </header>
            
            <article>
                
<p class="mce-root">The React ref is just an instance variable of <kbd class="calibre11">state</kbd>:</p>
<pre class="calibre16">type state = {<br class="title-page-name"/>  isOpen: bool,<br class="title-page-name"/>  touches,<br class="title-page-name"/>  width: ref(float),<br class="title-page-name"/>};</pre>
<p class="mce-root">We attach the React ref on the <kbd class="calibre11">&lt;nav /&gt;</kbd> element by setting the <kbd class="calibre11">ref</kbd> property to the result of <kbd class="calibre11">self.handle((ref, self) =&gt; ...)</kbd>:</p>
<pre class="calibre16">ref={<br class="title-page-name"/>  self.handle((ref, self) =&gt;<br class="title-page-name"/>    self.state.width :=<br class="title-page-name"/>      (<br class="title-page-name"/>        switch (Js.Nullable.toOption(ref)) {<br class="title-page-name"/>        | None =&gt; 0.0<br class="title-page-name"/>        | Some(r) =&gt; ReactDOMRe.domElementToObj(r)##clientWidth<br class="title-page-name"/>        }<br class="title-page-name"/>      )<br class="title-page-name"/>  )<br class="title-page-name"/>}</pre>
<p class="mce-root">Since a React ref could be <kbd class="calibre11">null</kbd> in JavaScript, we convert it to an option and pattern match on its value.</p>
<p class="mce-root">The type of the React ref depends on whether it is a DOM element or a React component. The former's type is <kbd class="calibre11">Dom.element</kbd>, and the latter's is <span class="calibre5"><kbd class="calibre11">ReasonReact.reactRef</kbd>. To convert a <kbd class="calibre11">ReasonReact.reactRef</kbd> to a JavaScript object, use <kbd class="calibre11">ReasonReact.refToJsObj</kbd> instead of <kbd class="calibre11">ReactDOMRe.domElementToObj</kbd>.</span></p>
<p class="mce-root">Then, in the reducer, we can use <kbd class="calibre11">state.width</kbd> instead of <kbd class="calibre11">300.0</kbd> as the menu's width. Since the <kbd class="calibre11">TouchStart</kbd> and <kbd class="calibre11">TouchMove</kbd> actions always update state when the menu is open, the <kbd class="calibre11">&lt;App /&gt;</kbd> component is always re-rendered, which causes our React ref function to re-run, and we can be reasonably sure that the menu's width is always correct.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Velocity</h1>
                </header>
            
            <article>
                
<p class="mce-root">To get the velocity of a user's swipe, we'll need to also store the current time along with the touch event's <kbd class="calibre11">clientX</kbd>. Let's bind to the browser's <kbd class="calibre11">performance.now()</kbd> method:</p>
<pre class="calibre16">[@bs.val] [@bs.scope "performance"] external now: unit =&gt; float = "";</pre>
<p class="mce-root">And we'll make some room for the touch's current time in the <kbd class="calibre11">touches</kbd> type:</p>
<pre class="calibre16">type touches = {<br class="title-page-name"/>  first: option((float, float)),<br class="title-page-name"/>  last: option((float, float)),<br class="title-page-name"/>};</pre>
<p class="mce-root">In the reducer, we then change <kbd class="calibre11">Some(clientX)</kbd> to <kbd class="calibre11">Some((clientX, now()))</kbd>.</p>
<p class="mce-root">Now, we can calculate the velocity of a user's swipe in the <kbd class="calibre11">TouchEnd</kbd> case:</p>
<pre class="calibre16">| TouchEnd =&gt;<br class="title-page-name"/>  if (state.isOpen) {<br class="title-page-name"/>    let (x, t) =<br class="title-page-name"/>      Belt.Option.getWithDefault(state.touches.first, (0.0, 0.0));<br class="title-page-name"/>    let (x', t') =<br class="title-page-name"/>      Belt.Option.getWithDefault(state.touches.last, (0.0, 0.0));<br class="title-page-name"/>    let velocity = (x' -. x) /. (t' -. t);<br class="title-page-name"/>    let state = {<br class="title-page-name"/>      ...state,<br class="title-page-name"/>      touches: {<br class="title-page-name"/>        first: None,<br class="title-page-name"/>        last: None,<br class="title-page-name"/>      },<br class="title-page-name"/>    };<br class="title-page-name"/>    if (velocity &lt; (-0.3) || x' &lt; state.width^ /. 2.0) {<br class="title-page-name"/>      ReasonReact.UpdateWithSideEffects(<br class="title-page-name"/>        state,<br class="title-page-name"/>        (self =&gt; self.send(ToggleMenu(false))),<br class="title-page-name"/>      );<br class="title-page-name"/>    } else {<br class="title-page-name"/>      ReasonReact.Update(state);<br class="title-page-name"/>    };<br class="title-page-name"/>  } else {<br class="title-page-name"/>    ReasonReact.NoUpdate;<br class="title-page-name"/>  }</pre>
<p class="mce-root">A velocity of <kbd class="calibre11">-0.3</kbd> pixels per millisecond feels right to me, but feel free to use whatever feels right for you.</p>
<p class="mce-root"/>
<p class="mce-root">Notice how we can use pattern matching to destructure <kbd class="calibre11">(x, t)</kbd>, which creates two bindings in scope. Also, <kbd class="calibre11">x'</kbd> is a valid name for a binding in Reason and is commonly pronounced <em class="calibre15">x prime</em>. Lastly, notice how our state is shadowed to prevent writing duplicate code.</p>
<p class="mce-root">To finish the velocity feature, we update the <kbd class="calibre11">style</kbd> property in the render function to treat both <kbd class="calibre11">state.touches.first</kbd> and <kbd class="calibre11">state.touches.last</kbd> as tuples:</p>
<pre class="calibre16">style=(<br class="title-page-name"/>  switch (self.state.touches) {<br class="title-page-name"/>  | {first: Some((x, _)), last: Some((x', _))} =&gt;<br class="title-page-name"/>    ReactDOMRe.Style.make(<br class="title-page-name"/>      ~transform=<br class="title-page-name"/>        "translateX("<br class="title-page-name"/>        ++ string_of_float(x' -. x &gt; 0.0 ? 0.0 : x' -. x)<br class="title-page-name"/>        ++ "0px)",<br class="title-page-name"/>      ~transition="none",<br class="title-page-name"/>      (),<br class="title-page-name"/>    )<br class="title-page-name"/>  | _ =&gt; ReactDOMRe.Style.make()<br class="title-page-name"/>  }<br class="title-page-name"/>)</pre>
<p class="mce-root">Now, when open, the menu responds nicely to a touch—super cool!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client-side routing</h1>
                </header>
            
            <article>
                
<p class="mce-root">ReasonReact comes with a built-in router found in the <kbd class="calibre11">ReasonReact.Router</kbd> module. It is quite unopinionated and therefore flexible. The public API has only four functions:</p>
<ul class="calibre9">
<li class="calibre10"><kbd class="calibre11">ReasonReact.Router.watchUrl: (url =&gt; unit) =&gt; watcherID</kbd></li>
<li class="calibre10"><kbd class="calibre11">ReasonReact.Router.unwatchUrl: watcherID =&gt; unit</kbd></li>
<li class="calibre10"><kbd class="calibre11">ReasonReact.Router.push: string =&gt; unit</kbd></li>
<li class="calibre10"><kbd class="calibre11">ReasonReact.Router.dangerouslyGetInitialUrl: unit =&gt; url</kbd></li>
</ul>
<p class="mce-root">The <kbd class="calibre11">watchUrl</kbd> function starts watching the URL for changes. When changed, the <kbd class="calibre11">url =&gt; unit</kbd> callback is called. The <kbd class="calibre11">unwatchUrl</kbd> function stops watching the URL.</p>
<p class="mce-root">The <kbd class="calibre11">push</kbd> function sets the URL, and the <kbd class="calibre11">dangerouslyGetInitialUrl</kbd> function gets a record of type <kbd class="calibre11">url</kbd>. The <kbd class="calibre11">dangerouslyGetInitialUrl</kbd> function is meant to be used only within the <kbd class="calibre11">didMount</kbd> lifecycle hook, alongside <kbd class="calibre11">watchUrl</kbd>, to prevent issues with stale information.</p>
<p class="mce-root">The <kbd class="calibre11">url</kbd> type is defined as follows:</p>
<pre class="calibre16">type url = {<br class="title-page-name"/>  path: list(string),<br class="title-page-name"/>  hash: string,<br class="title-page-name"/>  search: string,<br class="title-page-name"/>};</pre>
<p class="mce-root"><span class="calibre5">We'll learn more about the </span><kbd class="calibre11">list</kbd> type constructor <span class="calibre5">in</span><span class="calibre5"> <a href="201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml" target="_blank" class="calibre8">Chapter 4</a>, <em class="calibre15">BuckleScript, Belt, and Interoperability</em>. The <kbd class="calibre11">path</kbd> field in the <kbd class="calibre11">url</kbd> record is of type <kbd class="calibre11">list(string)</kbd>. If the value of <kbd class="calibre11">window.location.pathname</kbd> is <kbd class="calibre11">"/book/title/edit"</kbd>, the value of <kbd class="calibre11">url.path</kbd> will be <kbd class="calibre11">["book", "title", "edit"]</kbd>, which is a list of strings. The syntax makes it look like a JavaScript array, but there are some differences. </span>Briefly, Reason lists are singly linked lists that are immutable and homogeneous, meaning all elements must be of the same type.</p>
<p class="mce-root"><span class="calibre5">The </span><kbd class="calibre11">watcherID</kbd><span class="calibre5"> type is an </span><strong class="calibre4">abstract type</strong><span class="calibre5">. We'll learn more about abstract types in <a href="a6ac6581-d3bd-49f3-ad4d-bfed965287ca.xhtml" target="_blank" class="calibre8">Chapter 6</a>,  <em class="calibre15">CSS-in-JS (in Reason)</em>. The only way to get a value of type </span><kbd class="calibre11">watcherID</kbd><span class="calibre5"> is as the return value of </span><kbd class="calibre11">ReasonReact.Router.watchUrl</kbd><span class="calibre5">. </span></p>
<p class="mce-root">Let's create a router component that wraps our <kbd class="calibre11">&lt;App /&gt;</kbd> component and provides it with a <kbd class="calibre11">currentRoute</kbd> prop. What follows was inspired by an example from Khoa Nguyen (<kbd class="calibre11">@thangngoc89</kbd>).</p>
<p class="mce-root">First, let's create placeholder components for <kbd class="calibre11">&lt;Home /&gt;</kbd>, <kbd class="calibre11">&lt;Page1 /&gt;</kbd>, <kbd class="calibre11">&lt;Page2 /&gt;</kbd>, and <kbd class="calibre11">&lt;Page3 /&gt;</kbd>. Then, within <kbd class="calibre11">Router.re</kbd>, let's create a type that represents a route along with a list of routes:</p>
<pre class="calibre16">type route = {<br class="title-page-name"/>  href: string,<br class="title-page-name"/>  title: string,<br class="title-page-name"/>  component: ReasonReact.reactElement,<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>let routes = [<br class="title-page-name"/>  {href: "/", title: "Home", component: &lt;Home /&gt;},<br class="title-page-name"/>  {href: "/page1", title: "Page1", component: &lt;Page1 /&gt;},<br class="title-page-name"/>  {href: "/page2", title: "Page2", component: &lt;Page2 /&gt;},<br class="title-page-name"/>  {href: "/page3", title: "Page3", component: &lt;Page3 /&gt;},<br class="title-page-name"/>];</pre>
<p class="mce-root">Each route has an <kbd class="calibre11">href</kbd>, <kbd class="calibre11">title</kbd>, and an associated <kbd class="calibre11">component</kbd>, which will be rendered within <kbd class="calibre11">&lt;App /&gt;</kbd> if that route is the current route.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Current route</h1>
                </header>
            
            <article>
                
<p class="mce-root">In <kbd class="calibre11">Index.re</kbd>, let's wrap <kbd class="calibre11">&lt;App /&gt;</kbd> within a router component that provides the <kbd class="calibre11">currentRoute</kbd> prop:</p>
<pre class="calibre16">ReactDOMRe.renderToElementWithId(<br class="title-page-name"/>  &lt;Router.WithRouter&gt;<br class="title-page-name"/>    ...((~currentRoute) =&gt; &lt;App currentRoute /&gt;)<br class="title-page-name"/>  &lt;/Router.WithRouter&gt;,<br class="title-page-name"/>  "root",<br class="title-page-name"/>);</pre>
<p class="mce-root">In <kbd class="calibre11">Router.re</kbd>, we define three components—<kbd class="calibre11">&lt;WithRouter /&gt;</kbd>, <kbd class="calibre11">&lt;Link /&gt;</kbd>, and <kbd class="calibre11">&lt;NavLink /&gt;</kbd>—using the <kbd class="calibre11">module</kbd> syntax. Since each file is also a module, those three components are nested under the <kbd class="calibre11">Router</kbd> module, and in <kbd class="calibre11">Index.re</kbd> we need to tell the compiler to look for <kbd class="calibre11">&lt;WithRouter /&gt;</kbd> within the <kbd class="calibre11">Router</kbd> module:</p>
<pre class="calibre16">module WithRouter = {<br class="title-page-name"/>  type state = route;<br class="title-page-name"/>  type action =<br class="title-page-name"/>    | ChangeRoute(route);<br class="title-page-name"/>  let component = ReasonReact.reducerComponent("WithRouter");<br class="title-page-name"/>  let make = children =&gt; {<br class="title-page-name"/>    ...component,<br class="title-page-name"/>    didMount: self =&gt; {<br class="title-page-name"/>      let watcherID =<br class="title-page-name"/>        ReasonReact.Router.watchUrl(url =&gt;<br class="title-page-name"/>          self.send(ChangeRoute(urlToRoute(url)))<br class="title-page-name"/>        );<br class="title-page-name"/>      ();<br class="title-page-name"/>      self.onUnmount(() =&gt; ReasonReact.Router.unwatchUrl(watcherID));<br class="title-page-name"/>    },<br class="title-page-name"/>    initialState: () =&gt;<br class="title-page-name"/>      urlToRoute(ReasonReact.Router.dangerouslyGetInitialUrl()),<br class="title-page-name"/>    reducer: (action, _state) =&gt;<br class="title-page-name"/>      switch (action) {<br class="title-page-name"/>      | ChangeRoute(route) =&gt; ReasonReact.Update(route)<br class="title-page-name"/>      },<br class="title-page-name"/>    render: self =&gt; children(~currentRoute=self.state),<br class="title-page-name"/>  };<br class="title-page-name"/>};</pre>
<p class="mce-root">We've seen all of these concepts before. <kbd class="calibre11">&lt;WithRouter /&gt;</kbd> is just a reducer component. The component's state is the same route type defined earlier and there is only one action to change the route. Once <kbd class="calibre11">&lt;WithRouter /&gt;</kbd> is mounted, <kbd class="calibre11">ReasonReact.Router</kbd> begins watching the URL, and whenever it changes, the <kbd class="calibre11">ChangeRoute</kbd> action is triggered, which calls the reducer, which then updates state, which then re-renders <kbd class="calibre11">&lt;App /&gt;</kbd> with an updated <kbd class="calibre11">currentRoute</kbd> prop.</p>
<p class="mce-root">To ensure that our menu closes whenever <kbd class="calibre11">&lt;App /&gt;</kbd> receives a fresh <kbd class="calibre11">currentRoute</kbd> prop, we add a <kbd class="calibre11">willReceiveProps</kbd> lifecycle hook for <kbd class="calibre11">&lt;App /&gt;</kbd>:</p>
<pre class="calibre16">willReceiveProps: self =&gt; {...self.state, isOpen: false},</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Helper functions</h1>
                </header>
            
            <article>
                
<p class="mce-root">Since <span class="calibre5"><kbd class="calibre11">url.path</kbd> of</span> <kbd class="calibre11">ReasonReact.Router</kbd> is a list of strings, and our <kbd class="calibre11">Router.route.href</kbd> is a string, we need a way to convert from string to a list of strings:</p>
<pre class="calibre16">let hrefToPath = href =&gt;<br class="title-page-name"/>  Js.String.replaceByRe([%bs.re "/(^\\/)|(\\/$)/"], "", href)<br class="title-page-name"/>  |&gt; Js.String.split("/")<br class="title-page-name"/>  |&gt; Belt.List.fromArray;</pre>
<div class="packt_infobox"><span>We'll discuss Reason's pipe operator (</span><kbd class="calibre20">|&gt;</kbd><span>) and JavaScript interoperability in <a href="201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml" target="_blank" class="calibre17">Chapter 4</a>, <em class="calibre19">BuckleScript, Belt, and Interoperability</em>.</span></div>
<p class="mce-root">We also need a way to convert a <kbd class="calibre11">url</kbd> to a <kbd class="calibre11">route</kbd> for use in initial state, as well as within the callback function of <kbd class="calibre11">watchUrl</kbd>:</p>
<pre class="calibre16">let urlToRoute = (url: ReasonReact.Router.url) =&gt;<br class="title-page-name"/>  switch (<br class="title-page-name"/>    Belt.List.getBy(routes, route =&gt; url.path == hrefToPath(route.href))<br class="title-page-name"/>  ) {<br class="title-page-name"/>  | None =&gt; Belt.List.headExn(routes)<br class="title-page-name"/>  | Some(route) =&gt; route<br class="title-page-name"/>  };</pre>
<p class="mce-root">In <a href="201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml" target="_blank" class="calibre8">Chapter 4</a>, <em class="calibre15">BuckleScript, Belt, and Interoperability</em>, we will dive deeper into BuckleScript, Belt, and JavaScript interoperability. The <kbd class="calibre11">urlToRoute</kbd> function tries to find a <kbd class="calibre11">route</kbd> within the <kbd class="calibre11">routes</kbd> list whose <kbd class="calibre11">url.path</kbd> is structurally equal to <kbd class="calibre11">route.href</kbd> after it's converted to a list of strings.</p>
<p class="mce-root">If no such <kbd class="calibre11">route</kbd> exists, it returns the first <kbd class="calibre11">route</kbd> from the <kbd class="calibre11">routes</kbd> list, which is the one associated with the <kbd class="calibre11">&lt;Home /&gt;</kbd> component. Otherwise, the matching <kbd class="calibre11">route</kbd> is returned.</p>
<p class="mce-root">The <kbd class="calibre11">&lt;Link /&gt;</kbd> component is a simple stateless component that renders an anchor link. Note how the click handler prevents the default browser behavior and updates the URL:</p>
<pre class="calibre16">module Link = {<br class="title-page-name"/>  let component = ReasonReact.statelessComponent("Link");<br class="title-page-name"/>  let make = (~href, ~className="", children) =&gt; {<br class="title-page-name"/>    ...component,<br class="title-page-name"/>    render: self =&gt;<br class="title-page-name"/>      &lt;a<br class="title-page-name"/>        href<br class="title-page-name"/>        className<br class="title-page-name"/>        onClick=(<br class="title-page-name"/>          self.handle((event, _self) =&gt; {<br class="title-page-name"/>            ReactEvent.Mouse.preventDefault(event);<br class="title-page-name"/>            ReasonReact.Router.push(href);<br class="title-page-name"/>          })<br class="title-page-name"/>        )&gt;<br class="title-page-name"/>        ...children<br class="title-page-name"/>      &lt;/a&gt;,<br class="title-page-name"/>  };<br class="title-page-name"/>};</pre>
<p class="mce-root">The <kbd class="calibre11">&lt;NavLink /&gt;</kbd> component wraps the <kbd class="calibre11">&lt;Link /&gt;</kbd> component, and is provided with the current route as a prop that it uses to conditionally set an <kbd class="calibre11">active</kbd> class:</p>
<pre class="calibre16">module NavLink = {<br class="title-page-name"/>  let component = ReasonReact.statelessComponent("NavLink");<br class="title-page-name"/>  let make = (~href, children) =&gt; {<br class="title-page-name"/>   ...component,<br class="title-page-name"/>   render: _self =&gt;<br class="title-page-name"/>    &lt;WithRouter&gt;<br class="title-page-name"/>      ...(<br class="title-page-name"/>          (~currentRoute) =&gt;<br class="title-page-name"/>            &lt;Link<br class="title-page-name"/>              href className=(currentRoute.href == href ? "active" : "")&gt;<br class="title-page-name"/>              ...children<br class="title-page-name"/>            &lt;/Link&gt;<br class="title-page-name"/>          )<br class="title-page-name"/>    &lt;/WithRouter&gt;,<br class="title-page-name"/>  };<br class="title-page-name"/>};</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Usage</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now that we've defined the router, we can rewrite our navigation menu links to use the <kbd class="calibre11">&lt;NavLink /&gt;</kbd> component instead of the raw anchor link directly:</p>
<pre class="calibre16">&lt;li&gt;<br class="title-page-name"/>  &lt;Router.NavLink href="/"&gt;<br class="title-page-name"/>    (ReasonReact.string("Home"))<br class="title-page-name"/>  &lt;/Router.NavLink&gt;<br class="title-page-name"/>&lt;/li&gt;</pre>
<p class="mce-root">Wherever we want to display the current page's title, we can simply access the <kbd class="calibre11">title</kbd> field on the current route:</p>
<pre class="calibre16">&lt;h1&gt; (ReasonReact.string(currentRoute.title)) &lt;/h1&gt;</pre>
<p class="mce-root">And, we can render a route's associated component in a similar way:</p>
<pre class="calibre16">&lt;main&gt; currentRoute.component &lt;/main&gt;</pre>
<p class="mce-root">It's important to emphasize that ReasonReact's router does not dictate what the callback of <kbd class="calibre11">watchUrl</kbd> should do. In our case, we trigger an action that updates the current route, which is just an arbitrary record. It's completely reasonable for the route type to be something entirely different. Also, there is no law that says the router should be the top-level component. There is a lot of room for creativity here and I'm personally excited to see what the community comes up with.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we saw how ReasonReact is a simpler, safer way to build React components. Having Reason's type system enforcing correct component usage at compile time is a huge win. Also, it makes refactoring safer, cheaper, and a much more pleasant experience. ReasonReact is <em class="calibre15">just</em> Reason, much like how ReactJS is <em class="calibre15">just</em> JavaScript. All of what we've done so far is just Reason and ReasonReact without any third-party libraries such as Redux or React Router.</p>
<p class="mce-root">As we'll see in <a href="201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml" target="_blank" class="calibre8">Chapter 4</a>, <em class="calibre15">BuckleScript, Belt, and Interoperability</em>, we also have the option to use existing JavaScript (and ReactJS) solutions within Reason. After getting more comfortable with BuckleScript, the Belt standard library, and JavaScript interoperability, we'll add route transitions.</p>


            </article>

            
        </section>
    </body></html>