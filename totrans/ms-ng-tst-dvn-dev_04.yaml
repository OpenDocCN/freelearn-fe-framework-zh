- en: <st c="0">4</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Mocking and Stubbing Dependencies in Angular Tests</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="52">To write effective and reliable tests for Angular applications, it’s
    essential to understand how to handle dependencies.</st> <st c="174">Dependencies
    can often introduce complexity and make testing difficult.</st> <st c="246">However,
    by taking advantage of techniques such as mocking and stubbing, we can better
    control our tests and ensure the accuracy and stability of</st> <st c="392">our
    application.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="408">In this chapter, we’ll explore the concept of spies and method substitutes.</st>
    <st c="485">Spies allow us to monitor and verify the behavior of dependencies
    during testing.</st> <st c="567">We’ll learn how to create spies using the Jasmine
    test framework and use them to find out whether certain methods have been called,
    how many times they’ve been called, and with what parameters.</st> <st c="761">In
    addition, we’ll discover the power of method substitutes, which allow us to replace
    the implementation of a method with our own</st> <st c="892">custom logic.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="905">Next, we’ll take a look at</st> `<st c="933">TestBed</st>` <st c="940">providers
    and how they allow us to inject simulated dependencies into our tests.</st> <st
    c="1022">TestBed is a powerful Angular testing utility that allows us to create
    a test module and configure it with the necessary dependencies.</st> <st c="1157">We’re
    going to learn how to create and configure</st> <st c="1206">TestBed providers
    to replace real dependencies with simulated versions.</st> <st c="1278">This technique
    allows us to isolate the component or service under test and control the behavior
    of</st> <st c="1378">its dependencies.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1395">Finally, we’ll explore how to handle asynchronous operations and
    complex scenarios when setting up dependencies.</st> <st c="1509">We’ll discover
    the</st> `<st c="1528">async</st>` <st c="1533">and</st> `<st c="1538">fakeAsync</st>`
    <st c="1547">utilities provided by the Angular testing framework and see how to
    use them to manage asynchronous code in our tests.</st> <st c="1666">In addition,
    we’ll discuss strategies for handling complex scenarios, such as dependencies
    with multiple methods or dependencies that require specific</st> <st c="1817">initialization
    steps.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1838">In summary, here are the main topics that will be covered in</st>
    <st c="1900">this chapter:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1913">Monitoring and controlling dependency calls using method stubs</st>
    <st c="1977">and stubs</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1986">Injecting mocked dependencies using</st> <st c="2023">TestBed providers</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2040">Handling async operations and</st> <st c="2071">complex scenarios</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2088">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2111">To follow along with the examples and exercises in this chapter,
    you will need to have a basic understanding of Angular and TypeScript.</st> <st
    c="2248">You will also need</st> <st c="2267">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2281">Node.js and npm installed on</st> <st c="2311">your computer</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2324">Angular CLI</st> <st c="2337">installed globally</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2355">A code editor, such as Visual Studio Code, installed on</st> <st
    c="2412">your computer</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2425">The code files of this chapter can be found</st> <st c="2470">at</st>
    [<st c="2473">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%204</st>](https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%204)<st
    c="2571">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2572">Monitoring and controlling dependency calls using method stubs
    and spies</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2645">One crucial aspect</st> <st c="2664">of testing</st> <st c="2676">in
    Angular applications is the ability to monitor and control dependency calls.</st>
    <st c="2756">Dependencies are external resources or services that a piece of code
    relies on to function correctly.</st> <st c="2858">Monitoring and controlling
    these dependency calls allows developers to ensure that their code interacts correctly
    with external systems and handles different</st> <st c="3016">scenarios gracefully.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3037">Spies and method stubs are two powerful techniques within Angular’s
    testing framework that enable developers to achieve this level of control.</st>
    <st c="3181">Spies allow developers to monitor function calls, record information
    about those calls, and assert expectations about their usage.</st> <st c="3312">On
    the other hand, method stubs provide a way to replace real dependencies with simplified
    versions, allowing developers to control the behavior of those dependencies</st>
    <st c="3479">during testing.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3494">By using spies, developers can verify that the correct functions
    are called with the right parameters and that they are called the expected number
    of times.</st> <st c="3652">This is particularly useful when testing code that
    interacts with external APIs or databases</st><st c="3744">. Method stubs, on
    the other hand, enable developers to simulate different scenarios and provide
    predefined responses to method calls.</st> <st c="3879">This allows for thorough
    testing of edge cases and ensures the</st> <st c="3942">code’s robustness.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3960">In this section, we’ll explore the concepts of spies and method
    stubs in the Angular testing framework.</st> <st c="4065">We’ll dive into their
    applications and show their usefulness in monitoring and controlling dependency
    calls.</st> <st c="4174">Still based on our project related to a calculator application,
    we’ll demonstrate how spies and method substitutes can be used to create reliable
    and complete</st> <st c="4333">tests, with</st> <st c="4345">an emphasis on the</st>
    <st c="4364">principles of</st> **<st c="4378">test-driven</st>** **<st c="4390">development</st>**
    <st c="4401">(</st>**<st c="4403">TDD</st>**<st c="4406">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4409">Method stubs and spies</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="4432">Method stubs, also</st> <st c="4451">known as fake or dummy objects,
    are used to replace real dependencies with simplified versions during testing.</st>
    <st c="4563">By providing predefined responses to method calls, method substitutes
    enable developers to isolate and control the behavior of the code</st> <st c="4699">under
    test.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4710">In the calculator application, let’s consider a scenario in which
    the user performs a division operation with a divisor equal to zero.</st> <st
    c="4846">We want to make sure that the application handles this scenario correctly.</st>
    <st c="4921">By creating a method plug for the divide function, we can simulate
    the divide-by-zero scenario and check that the application displays an appropriate</st>
    <st c="5071">error message.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5085">At present, our calculator’s division operation does not handle
    the exception related to division</st> <st c="5184">by zero.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5192">In our</st> `<st c="5200">calculator.component.spec.ts</st>` <st
    c="5228">test file, we’re going to add the test that allows us to raise this exception.</st>
    <st c="5308">Since we’re following TDD principles, the test should</st> <st c="5362">fail
    naturally.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5377">After running our test, we notice that the test has indeed failed,
    as shown in the</st> <st c="5461">following screenshot:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Division-by-zero test case](img/B21146_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="5745">Figure 4.1 – Division-by-zero test case</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Division-by-zero test case failed](img/B21146_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="6446">Figure 4.2 – Division-by-zero test case failed</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6492">To correct this, we need to update our</st> `<st c="6532">CalculatorService</st>`<st
    c="6549">. In our present scenario, there’s a clever approach to refrain from
    direct interaction with our core service and ensure</st> <st c="6669">that everything
    is operational prior to any such action.</st> <st c="6727">This approach involves
    the utilization of a method</st> <st c="6778">stub concept.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6791">Basically, we’ll point our</st> `<st c="6819">CalculatorService</st>`
    <st c="6836">ser</st><st c="6840">vice at a fake service that will enable us to
    check the correctness of the logic we want to implement before modifying the service
    itself.</st> <st c="6980">In fact, this fake service will simply be a stub method
    that replaces the classic division of our basic</st> `<st c="7084">CalculatorService</st>`
    <st c="7101">service.</st> <st c="7111">To start with, you’ll need to com</st><st
    c="7144">ment out all the tests linked to other operators in our</st> `<st c="7201">calculator.component.spec.ts</st>`
    <st c="7229">file, if you already have some.</st> <st c="7262">Next, we’ll declare
    this</st> <st c="7287">stub method:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="7446">Then, in the</st> `<st c="7460">describe</st>` <st c="7468">method,
    within the</st> `<st c="7488">configureTestingModule</st>` <st c="7510">method,
    we will replace our</st> `<st c="7539">CalculatorService</st>` <st c="7556">provider
    with</st> <st c="7571">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="7666">Finally, here is</st> <st c="7684">the test case for our fake</st>
    `<st c="7711">calculatorServiceStub</st>` <st c="7732">service, which contains
    our stub</st> `<st c="7766">divide</st>` <st c="7772">method:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="8044">Here’s the complete code for implementing our</st> <st c="8091">fake
    service:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="9792">Let’s go through</st> <st c="9810">the code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9819">The</st> `<st c="9824">calculatorServiceStub</st>` <st c="9845">object
    is created to mock the</st> `<st c="9876">divide</st>` <st c="9882">method of
    the</st> `<st c="9897">CalculatorService</st>` <st c="9914">service.</st> <st
    c="9924">The</st> `<st c="9928">divide</st>` <st c="9934">method takes two parameters,</st>
    `<st c="9964">a</st>` <st c="9965">and</st> `<st c="9970">b</st>`<st c="9971">,
    and performs the division operation.</st> <st c="10010">In this case, the stub
    checks whether</st> `<st c="10048">b</st>` <st c="10049">is equal to zero.</st>
    <st c="10068">If it is, an</st> <st c="10081">error is thrown to simulate the</st>
    <st c="10113">division-by-zero scenario.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10139">The last</st> `<st c="10149">expect</st>` <st c="10155">statement
    checks whether the</st> `<st c="10185">result</st>` <st c="10191">property of
    the component is equal to</st> `<st c="10230">'Division by zero'</st>`<st c="10248">.
    This verifies that the error message is correctly displayed when division by</st>
    <st c="10327">zero occurs.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10339">Notice that our test execution has failed.</st> <st c="10383">This
    is a typing problem, as</st> `<st c="10412">result</st>` <st c="10418">is of the
    type</st> `<st c="10434">number</st>` <st c="10440">and</st> <st c="10445">not</st>
    `<st c="10449">string</st>`<st c="10455">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10456">So, we’re going to write the minimum amount of code we need in
    our</st> `<st c="10524">CalculatorComponent</st>` <st c="10543">to solve</st>
    <st c="10553">the problem:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Updating the declaration of the result property](img/B21146_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="10592">Figure 4.3 – Updating the declaration of the result property</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10652">After running the tests, notice that all the tests have turned
    green, as shown in</st> <st c="10735">our screenshot:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Division-by-zero test case succeeded](img/B21146_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="11130">Figure 4.4 – Division-by-zero test case succeeded</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11179">Now we’re going to refactor, as required by the principles of
    TDD.</st> <st c="11247">We’re going to create a</st> `<st c="11271">stubs</st>`
    <st c="11276">folder in our project’s</st> `<st c="11301">core</st>` <st c="11305">folder
    and create a</st> `<st c="11326">calculator.service.stub.ts</st>` <st c="11352">file</st>
    <st c="11358">in it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – calculator.service.stub.ts file arborescence](img/B21146_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="11443">Figure 4.5 – calculator.service.stub.ts file arborescence</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11500">Once the file has</st> <st c="11518">been created, we will move
    the source code of our fake stub-based service from</st> `<st c="11598">calculator.component.spec.ts</st>`
    <st c="11626">into our</st> `<st c="11636">calculator.service.stub.ts</st>` <st
    c="11662">file</st> <st c="11668">like this:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – calculator.service.stub.ts code source](img/B21146_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="11891">Figure 4.6 – calculator.service.stub.ts code source</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11942">Since it’s a service, we’ll be using the dependency injection
    technique, as we’ll see in more detail in the next section.</st> <st c="12065">At
    this stage, here’s what we’ll do in a couple</st> <st c="12113">of steps:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12122">Create a class in</st> `<st c="12141">calculator.service.stub.ts</st>`
    <st c="12167">called</st> `<st c="12175">CalculatorServiceStub</st>`<st c="12196">.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="12197">Implement all the operator methods of our</st> <st c="12240">calculator
    application.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="12263">Here’s what</st> <st c="12276">the source code</st> <st c="12292">looks
    like:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="12631">After updating our fake service, we’ll go into our</st> `<st c="12683">calculator.component.spec.ts</st>`
    <st c="12711">test file to replace the provider</st> <st c="12746">like this:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="12925">Now we can uncomment all the methods in our</st> `<st c="12970">calculator.component.spec.ts</st>`
    <st c="12998">file, except</st> <st c="13011">the</st> `<st c="13016">it('should
    display error message for division by zero')</st>` <st c="13071">test case.</st>
    <st c="13083">Notice that all</st> <st c="13099">our tests are green, as shown
    in the</st> <st c="13136">following figure:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.7 – CalculatorComponent succeeded using CalculatorServiceStub test
    cases](img/B21146_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="13646">Figure 4.7 – CalculatorComponent succeeded using CalculatorServiceStub
    test cases</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13727">Spies and method stubs are powerful tools in Angular’s testing
    framework that enable developers to monitor and control the behavior of dependencies
    in their applications.</st> <st c="13899">By incorporating these techniques into
    the TDD process, developers can write more comprehensive and reliable tests, ensuring
    the functionality and stability of their Angular applications.</st> <st c="14087">The
    calculator app example illustrates how spies and method stubs can be applied to
    simulate different scenarios and validate the behavior of the code under test.</st>
    <st c="14250">In the next section, we’ll take a closer look at how to inject mocked
    dependencies</st> <st c="14332">using</st> <st c="14339">TestBed providers.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14357">Injecting mocked dependencies using TestBed providers</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="14411">Mocked dependencies</st> <st c="14431">are simplified</st> <st
    c="14447">versions of external services or resources that mimic the behavior of
    the actual dependencies.</st> <st c="14542">By injecting these mocked dependencies
    using TestBed providers, developers can control their behavior during testing,
    ensuring reliable and thorough testing without relying on</st> <st c="14718">external
    systems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14735">In this section, we will explore the concept of TestBed providers
    in Angular’s testing framework.</st> <st c="14834">We will delve into their applications
    and showcase how they enable developers to inject mocked dependencies into their
    code.</st> <st c="14959">By doing so, we can create isolated and controlled testing
    environments, adhering to the principles</st> <st c="15059">of TDD.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15066">By injecting mocked dependencies using TestBed providers, developers
    can focus on testing specific units of code without worrying about the complexities
    of the actual dependencies.</st> <st c="15248">This approach allows for easier
    debugging, improved test coverage, and better overall</st> <st c="15334">code
    quality.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15347">Throughout this section, we will emphasize the principles of TDD
    and demonstrate the usage of TestBed providers in a practical example, using our
    calculator app.</st> <st c="15510">By understanding and utilizing TestBed providers
    effectively, developers can write reliable, maintainable, and thoroughly tested</st>
    <st c="15639">Angular applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15660">Let’s consider adding the ability to calculate the square root
    of a number to our calculator application, while still relying on our</st> `<st
    c="15794">CalculatorService</st>` <st c="15811">service.</st> <st c="15821">In
    this case, we’ll focus on the square root functionality of the</st> <st c="15887">calculator
    application.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15910">First, we need to create a mock service that mimics the behavior
    of the actual square root service.</st> <st c="16011">We can create a simple class
    that returns predefined square root values for different inputs.</st> <st c="16105">This
    class, named</st> `<st c="16123">MockSquareRootService</st>`<st c="16144">, will
    be created in the</st> `<st c="16169">mocks</st>` <st c="16174">folder, which
    we’ll create at the same arborescence level as the</st> `<st c="16240">stubs</st>`
    <st c="16245">folder, as demonstrated in the</st> <st c="16277">following screenshot:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – mock-square-root.service.mock.ts file arborescence](img/B21146_04_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="16373">Figure 4.8 – mock-square-root.service.mock.ts file arborescence</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16436">Here’s an example of a mock square</st> <st c="16472">root service:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <st c="16669">Next, we</st> <st c="16679">will</st> <st c="16683">configure
    the test module using TestBed providers to replace the real square root service
    with the simulated version in</st> `<st c="16804">calculator.component.spec.ts</st>`<st
    c="16832">. Here’s an example of how to configure the</st> <st c="16876">test
    module:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <st c="17130">In the preceding code, we provide the</st> `<st c="17169">CalculatorService</st>`
    <st c="17186">service token and specify the</st> `<st c="17217">useClass</st>`
    <st c="17225">property with</st> `<st c="17240">MockSquareRootService</st>` <st
    c="17261">service.</st> <st c="17271">This configuration tells TestBed to use
    the mock service whenever the code under test requests an instance of the actual
    square</st> <st c="17399">root service.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17412">Now, when we run our tests for the calculator app, any code that
    depends on the square root service will receive an instance of the mocked service.</st>
    <st c="17561">We can control the behavior of the service during testing, ensuring
    that the calculator app correctly performs square root calculations under different
    scenarios.</st> <st c="17724">Here’s some example code for the</st> `<st c="17757">MockSquareRootService</st>`
    <st c="17778">service that mimics the behavior of the</st> `<st c="17819">CalculatorService</st>`
    <st c="17836">service</st> <st c="17845">by</st> <st c="17848">returning predefined
    square root values for</st> <st c="17892">different inputs:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: <st c="18215">Let’s finish writing our test on the square roots of numbers by
    adding this sequence to our test</st> <st c="18313">file,</st> `<st c="18319">calculator.component</st><st
    c="18339">.spec.ts</st>`<st c="18347">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: <st c="18594">To make it functional, you need to add the</st> `<st c="18638">squareRoot()</st>`
    <st c="18650">method to</st> `<st c="18661">calculator.component.ts</st>` <st
    c="18684">and</st> `<st c="18689">calculator.service.ts</st>`<st c="18710">. I
    won’t do this in the current project, as the aim is to show how to set up a</st>
    <st c="18790">mock briefly.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18803">TestBed providers in Angular allow you to inject mocked dependencies
    into your tests.</st> <st c="18890">This is a</st> <st c="18900">powerful</st>
    <st c="18909">feature that enables you to control the behavior of external dependencies
    and isolate the code</st> <st c="19004">under test.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19015">When configuring the testing module using</st> `<st c="19058">TestBed.configureTestingModule</st>`<st
    c="19088">, you can provide a list of providers that specify the tokens for the
    dependencies you want to mock.</st> <st c="19189">You can then use either the</st>
    `<st c="19217">useClass</st>` <st c="19225">or</st> `<st c="19229">useValue</st>`
    <st c="19237">property to provide a mock or stub implementation for</st> <st c="19292">each
    dependency.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19308">By providing a mock implementation, you can define the behavior
    of the dependency during testing.</st> <st c="19407">This allows you to simulate
    different scenarios and control the return values or error conditions of the dependency.</st>
    <st c="19524">You can also verify the interaction between the code under test
    and the dependency by using spies or other</st> <st c="19631">testing techniques.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19650">Injecting mocked dependencies using TestBed providers helps to
    improve the reliability and stability of your tests.</st> <st c="19767">It allows
    you to focus on testing the specific functionality of your code without relying
    on the actual implementation of external dependencies.</st> <st c="19912">This
    makes your tests more deterministic and less prone to failures caused by changes
    in the behavior of</st> <st c="20017">the dependencies.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20034">Overall, TestBed providers provide a convenient way to inject
    mocked dependencies into your Angular tests.</st> <st c="20142">They allow you
    to control the behavior of external dependencies and isolate the code under test,
    resulting in more reliable and focused tests.</st> <st c="20285">We’ll be taking
    a hands-on approach in the chapters to come.</st> <st c="20346">The aim here is
    to understand the relevance of asynchronous</st> <st c="20406">tasks and</st>
    <st c="20416">why we need to be careful when implementing tests about them.</st>
    <st c="20478">In the next section, we will manage asynchronous operations and</st>
    <st c="20542">complex scenarios.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20560">Handling async operations and complex scenarios</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="20608">Testing asynchronous</st> <st c="20630">operations and complex
    scenarios is a crucial part of ensuring the reliability and functionality of modern
    software applications.</st> <st c="20760">In today’s software development landscape,
    applications often rely on asynchronous operations, such as promises and observables,
    to handle data fetching, processing, and user interactions.</st> <st c="20949">Additionally,
    complex scenarios, involving intricate workflows, conditional logic, and multiple
    dependencies, need to be thoroughly tested to ensure the application behaves as
    expected in</st> <st c="21137">various scenarios.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21155">Testing these asynchronous operations and complex scenarios requires
    the use of specialized techniques and tools to handle the unique challenges they
    present.</st> <st c="21315">In the context of Angular, a popular JavaScript framework,
    developers have access to a comprehensive testing framework that provides powerful
    utilities for testing</st> <st c="21479">such scenarios.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21494">In this section, we will explore the importance of testing asynchronous
    operations, such as promises and observables, and complex scenarios in Angular
    applications.</st> <st c="21660">We will delve into various techniques and best
    practices for effectively testing these scenarios, ensuring reliable and comprehensive</st>
    <st c="21794">test coverage.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21808">Understanding asynchronous operations</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="21846">Asynchronous</st> <st c="21860">operations are tasks that can
    be executed independently of the main program flow.</st> <st c="21942">They are
    typically used to handle time-consuming operations, such as network requests,
    file I/O, or database queries.</st> <st c="22060">Instead of waiting for these
    operations to complete, the program can continue executing other tasks, improving
    overall performance</st> <st c="22191">and responsiveness.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22210">One common approach to handling asynchronous operations is through
    callbacks.</st> <st c="22289">A callback is a function that is passed to another
    function as an argument and executed once the asynchronous operation is complete.</st>
    <st c="22422">This allows us to define what should happen after the operation
    finishes.</st> <st c="22496">However, managing callbacks can lead to callback
    hell, making the code hard to read and maintain.</st> <st c="22594">To solve this
    problem,</st> `<st c="22617">promises</st>` <st c="22625">were born.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22636">Promises provide a more structured way to handle asynchronous
    operations.</st> <st c="22711">A promise represents the eventual completion or
    failure of an asynchronous operation and allows us to attach callbacks to handle
    these outcomes.</st> <st c="22856">Promises offer a more readable and maintainable
    way to work with asynchronous code by chaining methods,</st> <st c="22959">such
    as</st> `<st c="22968">.then()</st>` <st c="22975">and</st> `<st c="22980">.catch()</st>`<st
    c="22988">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22989">However, a new way of implementing promises has been introduced
    in new versions of JavaScript.</st> `<st c="23085">async</st>`<st c="23090">/</st>`<st
    c="23092">await</st>` <st c="23097">is a clean and concise syntax for working
    with asynchronous operations.</st> <st c="23170">It allows us to write asynchronous
    code that looks like synchronous code, making it easier to reason about and maintain.</st>
    <st c="23291">Using the</st> `<st c="23301">async</st>` <st c="23306">keyword,
    we can define functions that can pause and resume execution using the</st> `<st
    c="23386">await</st>` <st c="23391">keyword, which waits for a promise to be resolved</st>
    <st c="23442">or rejected.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23454">In addition, another</st> <st c="23476">approach to asynchronous
    operations is to pass observables.</st> <st c="23536">Observables are a powerful
    tool for managing data flows and asynchronous operations in reactive programming.</st>
    <st c="23645">They represent a sequence of values that can be observed over time.</st>
    <st c="23713">Observables can output multiple values asynchronously and provide
    a wide range of operators for transforming, filtering, and combining data streams.</st>
    <st c="23862">They are commonly used in frameworks such as Angular to handle events,
    HTTP requests, and other asynchronous operations</st> <st c="23982">with RxJS.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23992">Asynchronous operations and observables also enable concurrency
    and parallelism in our code.</st> <st c="24086">Concurrency refers to the ability
    to execute multiple tasks at the same time, while parallelism</st> <st c="24182">refers
    to executing tasks simultaneously across multiple processors or threads.</st>
    <st c="24262">Asynchronous programming and observables allow us to handle multiple
    operations concurrently, improving performance in applications that require heavy
    computation</st> <st c="24425">or I/O.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24432">Handling asynchronous operations</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="24465">Let’s consider that our</st> <st c="24490">calculator application
    that performs addition, subtraction, multiplication, and division now has a service
    that performs these operations and returns the result as</st> <st c="24654">an
    observable.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24668">First, let’s assume we have another calculator service called</st>
    `<st c="24731">CalculatorAsyncService</st>`<st c="24753">, which we’ll create
    in the</st> `<st c="24781">services</st>` <st c="24789">folder.</st> <st c="24798">We
    need to execute this command line in the terminal once in the</st> `<st c="24863">services</st>`
    <st c="24871">folder:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: it('should add two numbers', fakeAsync(() => {
  prefs: []
  type: TYPE_NORMAL
- en: let result = 0;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: service.add(1, 2).subscribe((val) => {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result = val;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expect(result).toBe(3);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}));'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: it('should add two numbers', fakeAsync(() => {
  prefs: []
  type: TYPE_NORMAL
- en: let result = 0;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'service.add(1, 2).subscribe((val: number) => {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result = val;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expect(result).toBe(3);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}));'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'add(a: number, b: number): Observable<number> {'
  prefs: []
  type: TYPE_NORMAL
- en: return of(a + b);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: it('should subtract two numbers', fakeAsync(() => {
  prefs: []
  type: TYPE_NORMAL
- en: let result = 0;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'service.subtract(5, 3).subscribe((val: number) => {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result = val;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expect(result).toBe(2);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}));'
  prefs: []
  type: TYPE_NORMAL
- en: it('should multiply two numbers', fakeAsync(() => {
  prefs: []
  type: TYPE_NORMAL
- en: let result = 0;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'service.multiply(3, 4).subscribe((val: number) => {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result = val;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expect(result).toBe(12);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}));'
  prefs: []
  type: TYPE_NORMAL
- en: it('should divide two numbers', fakeAsync(() => {
  prefs: []
  type: TYPE_NORMAL
- en: let result = 0;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'service.divide(10, 2).subscribe((val: number) => {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result = val;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expect(result).toBe(5);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}));'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'subtract(a: number, b: number): Observable<number> {'
  prefs: []
  type: TYPE_NORMAL
- en: return of(a - b);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'multiply(a: number, b: number): Observable<number> {'
  prefs: []
  type: TYPE_NORMAL
- en: return of(a * b);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'divide(a: number, b: number): Observable<number> {'
  prefs: []
  type: TYPE_NORMAL
- en: return of(a / b);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'it(''should throw an error when dividing by zero'', fakeAsync(() => { let error
    = { message: '''' }; ;'
  prefs: []
  type: TYPE_NORMAL
- en: service.divide(10, 0).subscribe({
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'error: (err) => (error = err),'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expect(error).toBeTruthy();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expect(error.message).toBe('Cannot divide by zero');
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}));'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'divide(a: number, b: number): Observable<number> {'
  prefs: []
  type: TYPE_NORMAL
- en: if (b === 0) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return throwError(() => new Error('Cannot divide by zero'));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}  return of(a / b).pipe('
  prefs: []
  type: TYPE_NORMAL
- en: catchError((error) => {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return throwError(() => error);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: );
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
