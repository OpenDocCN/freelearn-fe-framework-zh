<html><head></head><body>
<div id="_idContainer080">
<h1 class="chapter-number" id="_idParaDest-174"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-175"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.2.1">Processing Real-Time Updates</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.3.1">Real time</span></strong><span class="koboSpan" id="kobo.4.1"> refers to the capability of an application to handle and respond to data or events immediately as they happen, without any noticeable delay or latency. </span><span class="koboSpan" id="kobo.4.2">This is a very hot topic nowadays, with the demand for real-time features growing in web applications, particularly in areas such as live financial trading, live tracking systems, and live monitoring, analytics, and healthcare. </span><span class="koboSpan" id="kobo.4.3">Ultimately, the quicker you get the data, the sooner you can react and make decisions, increasing the chances of </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">higher profits.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">So, how can you process real-time messages in the frontend and update the displayed data automatically in the UI? </span><span class="koboSpan" id="kobo.6.2">This is what we will cover in this chapter. </span><span class="koboSpan" id="kobo.6.3">We will start by explaining the real-time requirement, and then we will walk you through the different steps to implement the reactive pattern for consuming real-time updates. </span><span class="koboSpan" id="kobo.6.4">Finally, we will learn the reactive pattern for </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">handling reconnection.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">Defining the requirements of </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">real time</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Learning the reactive pattern for consuming </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">real-time messages</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Learning the reactive pattern for </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">handling reconnection</span></span></li>
</ul>
<h1 id="_idParaDest-176"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.16.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.17.1">This chapter assumes that you have a basic understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">of RxJS.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">We used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.20.1">ws</span></strong><span class="koboSpan" id="kobo.21.1"> library, which is a WebSocket Node.js library, in order to support WS in our backend. </span><span class="koboSpan" id="kobo.21.2">For more details, check out this </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">link: </span></span><a href="https://github.com/websockets/ws"><span class="No-Break"><span class="koboSpan" id="kobo.23.1">https://github.com/websockets/ws</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.24.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">The source code of this chapter is available </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">at </span></span><a href="https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-for-Angular-16-2nd-Edition/tree/main/Chap12"><span class="No-Break"><span class="koboSpan" id="kobo.27.1">https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-for-Angular-16-2nd-Edition/tree/main/Chap12</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.28.1">.</span></span></p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.29.1">Defining the requirements of real time</span></h1>
<p><span class="koboSpan" id="kobo.30.1">There are two </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.31.1">techniques available for publishing real-time data on </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">the web:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.33.1">Pull technique</span></strong><span class="koboSpan" id="kobo.34.1">: This is </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.35.1">where the client raises a request to get the latest version </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.36.1">of data. </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">HTTP polling</span></strong><span class="koboSpan" id="kobo.38.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">HTTP long polling</span></strong><span class="koboSpan" id="kobo.40.1"> are two examples</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.41.1"> of implementations of this </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">pull technique.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.43.1">Push technique</span></strong><span class="koboSpan" id="kobo.44.1">: This is where the server pushes updates to the client. </span><strong class="bold"><span class="koboSpan" id="kobo.45.1">WebSockets</span></strong><span class="koboSpan" id="kobo.46.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">server-sent events</span></strong><span class="koboSpan" id="kobo.48.1"> are</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.49.1"> two implementations</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.50.1"> of this </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">push technique.</span></span></li>
</ul>
<p><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.52.1">We are not going to discuss or compare these techniques in detail, as it is not the goal of this chapter; however, in general, push techniques </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.53.1">have a lower latency compared to pull ones. </span><span class="koboSpan" id="kobo.53.2">For this reason, we will use the push technique and WebSocket as the implementation for </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">our requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">In short, the WebSocket protocol is a stateful communication protocol that establishes a low-latency bi-directional communication channel between a client and a server. </span><span class="koboSpan" id="kobo.55.2">In this way, messages can be sent back and forth between the server and </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">The </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.58.1">following diagram illustrates the WebSocket </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">communication flow:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.60.1"><img alt="Figure 12.1 – WebSocket communication" src="image/B21180_12_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.61.1">Figure 12.1 – WebSocket communication</span></p>
<p><span class="koboSpan" id="kobo.62.1">As illustrated, there are three steps in </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">WebSocket communication:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.64.1">Opening the connection</span></strong><span class="koboSpan" id="kobo.65.1">: In</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.66.1"> this step, the client issues an HTTP request to tell the server that a protocol upgrade will occur (from HTTP to WebSocket). </span><span class="koboSpan" id="kobo.66.2">If the server supports WebSockets, then the protocol switch will </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">be accepted.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.68.1">Establishing the communication channel</span></strong><span class="koboSpan" id="kobo.69.1">: Once the protocol upgrade is done, then a bi-directional communication channel will be created, and messages start to be sent back and forth between the server and </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">the client.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.71.1">Closing the connection</span></strong><span class="koboSpan" id="kobo.72.1">: When the communication is over, a request will be issued to close </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">the connection.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.74.1">At this level, that </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.75.1">is all that you need to know about WebSockets. </span><span class="koboSpan" id="kobo.75.2">Now, let’s quickly review what we’ll be doing in </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">our app.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">In our recipe app, </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.79.1"> is responsible for displaying the list of recipes. </span><span class="koboSpan" id="kobo.79.2">We will simulate the addition of a new recipe (a recipe for chilli chicken) after a delay of 5 seconds following the rendering of </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.81.1">. </span><span class="koboSpan" id="kobo.81.2">The UI should then be updated instantly to include this new recipe by rendering it in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">RecipesList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.83.1"> page.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">You will find a ready-to-use WebSocket backend under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">recipes-book-api</span></strong><span class="koboSpan" id="kobo.86.1"> folder; this is what pushes the new recipe to the frontend 5 seconds after establishing the connection. </span><span class="koboSpan" id="kobo.86.2">We will also use a timer in the backend to simulate the arrival of a new recipe. </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.88.1"> should then consume the message coming from the WebSocket server and push the newly received recipe in the already displayed list of recipes. </span><span class="koboSpan" id="kobo.88.2">The UI should be updated automatically without having to trigger any </span><strong class="bold"><span class="koboSpan" id="kobo.89.1">Refresh</span></strong><span class="koboSpan" id="kobo.90.1"> button to get </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">the updates.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">So, without further ado, in the next section, let’s see how we can implement all of this using </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">RxJS’s </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">WebSocketSubject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">.</span></span></p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.96.1">Learning the reactive pattern for consuming real-time messages</span></h1>
<p><span class="koboSpan" id="kobo.97.1">RxJS has a special </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.98.1">type of subject </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.99.1">called </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">WebSocketSubject</span></strong><span class="koboSpan" id="kobo.101.1">; this is nothing </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.102.1">but a wrapper around the W3C WebSocket object, which is available in the browser. </span><span class="koboSpan" id="kobo.102.2">It allows you to communicate with a WebSocket server, both sending and consuming data through a </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">WebSocket connection.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">Let’s explore the capabilities of </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">WebSocketSubject</span></strong><span class="koboSpan" id="kobo.106.1"> and learn how to use it to consume real-time messages in </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">our project.</span></span><a id="_idIndexMarker518"/><a id="_idIndexMarker519"/></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.108.1">Creating and using WebSocketSubject</span></h2>
<p><span class="koboSpan" id="kobo.109.1">In order</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.110.1"> to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">WebSocketSubject</span></strong><span class="koboSpan" id="kobo.112.1">, you have to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">webSocket</span></strong><span class="koboSpan" id="kobo.114.1"> factory function that produces this special type of subject and takes the endpoint of your WebSocket server as input. </span><span class="koboSpan" id="kobo.114.2">The following is the </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">function signature:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.116.1">
webSocket&lt;T&gt;(urlConfigOrSource: string | WebSocketSubjectConfig&lt;T&gt;): WebSocketSubject&lt;T&gt;;</span></pre> <p><span class="koboSpan" id="kobo.117.1">It accepts two types of arguments, either of </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.119.1">A string representing the URL of your WebSocket </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">server endpoint</span></span></li>
<li><span class="koboSpan" id="kobo.121.1">A special object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">WebSocketSubjectConfig</span></strong><span class="koboSpan" id="kobo.123.1"> type that contains the URL of your endpoint, along with other properties (we will explore </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">WebSocketSubjectConfig</span></strong><span class="koboSpan" id="kobo.125.1"> in detail in the </span><em class="italic"><span class="koboSpan" id="kobo.126.1">Learning the reactive pattern for handling </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.127.1">reconnection</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.128.1"> section)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.129.1">The following code is an example of calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">webSocket</span></strong><span class="koboSpan" id="kobo.131.1"> factory function with the first type </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">of argument:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.133.1">
import { webSocket } from "rxjs/webSocket";
const subject = webSocket("ws://localhost:8081");</span></pre> <p><span class="koboSpan" id="kobo.134.1">The next piece of code is an example of calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">webSocket</span></strong><span class="koboSpan" id="kobo.136.1"> factory function using the second type </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">of argument:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.138.1">
import { webSocket } from 'rxjs/webSocket';
const subject$ = webSocket({url:'ws://localhost:8081'});</span></pre> <p><span class="koboSpan" id="kobo.139.1">In our case, the URL of our endpoint is </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">ws://localhost:8081</span></strong><span class="koboSpan" id="kobo.141.1">. </span><span class="koboSpan" id="kobo.141.2">You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">wss</span></strong><span class="koboSpan" id="kobo.143.1"> for a secure WebSocket connection (which is the same as HTTPS for a secure </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">HTTP connection).</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">We will be using both types of arguments in </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">Let’s now see how we can establish the connection to the WebSocket in the </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">following section.</span></span></p>
<h3><span class="koboSpan" id="kobo.149.1">Opening the connection</span></h3>
<p><span class="koboSpan" id="kobo.150.1">Now that you have </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.151.1">a reference for </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">WebSocketSubject</span></strong><span class="koboSpan" id="kobo.153.1">, you should subscribe </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.155.1">
import { webSocket } from 'rxjs/webSocket';
const subject$ = webSocket({url:'ws://localhost:8081'});
subject$.subscribe();</span></pre> <p><span class="koboSpan" id="kobo.156.1">This will establish the connection with your </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">ws</span></strong><span class="koboSpan" id="kobo.158.1"> endpoint and allow you to start receiving and sending data. </span><span class="koboSpan" id="kobo.158.2">Of course, if you don’t subscribe, the</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.159.1"> connection will not </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">be created.</span></span></p>
<h3><span class="koboSpan" id="kobo.161.1">Listening to incoming messages from the server</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">WebSocketSubject</span></strong><span class="koboSpan" id="kobo.163.1"> is nothing but a regular RxJS subject, whereby you can register callbacks</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.164.1"> to listen and process the incoming messages from the </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">WebSocket server.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">In order to listen to messages, you should subscribe to the produced </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">WebSocketSubject</span></strong><span class="koboSpan" id="kobo.168.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">webSocket</span></strong><span class="koboSpan" id="kobo.170.1"> factory function and register a callback, </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.172.1">
const subject$ = webSocket('ws://localhost:8080');
// Listen to messages from the server
const subscription = subject$.subscribe(msg =&gt; {
  console.log('Message received from the socket'+ msg);
});</span></pre> <p><span class="koboSpan" id="kobo.173.1">Here, we’re simply subscribing to the WebSocket subject to initiate a connection with the WebSocket server and then logging any received messages to </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">the console.</span></span></p>
<h3><span class="koboSpan" id="kobo.175.1">Pushing messages to the server</span></h3>
<p><span class="koboSpan" id="kobo.176.1">To</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.177.1"> send messages to the server, we just use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">next</span></strong><span class="koboSpan" id="kobo.179.1"> method available in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">subject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.181.1"> type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.182.1">
// Push messages to the server
subject$.next('Message to the server');</span></pre> <h3><span class="koboSpan" id="kobo.183.1">Handling errors</span></h3>
<p><span class="koboSpan" id="kobo.184.1">You can</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.185.1"> also catch errors coming from the server using </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">catchError</span></strong><span class="koboSpan" id="kobo.187.1"> as usual and push errors to the server by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">error</span></strong><span class="koboSpan" id="kobo.189.1"> method. </span><span class="koboSpan" id="kobo.189.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.191.1">
// Push errors to the server
subject$.error('Something wrong happens')
// Handle incoming errors from the server
subject$.pipe(catchError(error=&gt;of('Something wrong happens')))</span></pre> <p><span class="koboSpan" id="kobo.192.1">However, bear in mind that when you send an error, the server will get notified about this error, and then</span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.193.1"> the connection will be closed. </span><span class="koboSpan" id="kobo.193.2">So, nothing will get </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">emitted thereafter.</span></span></p>
<h3><span class="koboSpan" id="kobo.195.1">Closing the connection</span></h3>
<p><span class="koboSpan" id="kobo.196.1">You</span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.197.1"> can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">unsubscribe</span></strong><span class="koboSpan" id="kobo.199.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">complete</span></strong><span class="koboSpan" id="kobo.201.1"> to close </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">the connection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.203.1">
// Close the connection
subject$.complete();
//or
subject$.unsubscribe();</span></pre> <p><span class="koboSpan" id="kobo.204.1">So, to wrap up what we’ve been discussing, only the creation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">WebSocketSubject</span></strong><span class="koboSpan" id="kobo.206.1"> is specific to this special kind of subject. </span><span class="koboSpan" id="kobo.206.2">However, all the other APIs used (</span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">subscribe</span></strong><span class="koboSpan" id="kobo.208.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">unsubscribe</span></strong><span class="koboSpan" id="kobo.210.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">complete</span></strong><span class="koboSpan" id="kobo.212.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">catchError</span></strong><span class="koboSpan" id="kobo.214.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">next</span></strong><span class="koboSpan" id="kobo.216.1">, and so on) are the same as those used for regular subjects. </span><span class="koboSpan" id="kobo.216.2">The following figure illustrates this </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">whole process:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<span class="koboSpan" id="kobo.218.1"><img alt="Figure 12.2 – WebSocketSubject possible events" src="image/B21180_12_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.219.1">Figure 12.2 – WebSocketSubject possible events</span></p>
<p><span class="koboSpan" id="kobo.220.1">Now that we’ve covered various WebSocket manipulations, from creating and establishing connections to sending messages, handling errors, and consuming incoming messages, let’s explore a common pitfall you should keep </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">in mind.</span></span></p>
<h3><span class="koboSpan" id="kobo.222.1">Connection management</span></h3>
<p><span class="koboSpan" id="kobo.223.1">At this point, there is a particular behavior you should be aware of. </span><span class="koboSpan" id="kobo.223.2">If the same</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.224.1"> instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">WebSocketSubject</span></strong><span class="koboSpan" id="kobo.226.1"> has many subscribers, then they will share the same connection to save resources. </span><span class="koboSpan" id="kobo.226.2">However, if we have two different instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">WebSocketSubject</span></strong><span class="koboSpan" id="kobo.228.1">, it will establish two distinct connections, even if they are referencing the </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">same endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">The following code explains the connection management for both </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">use cases:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.232.1">
const firstSubject$ = webSocket('ws://localhost:8080');
const  secondSubject$ = webSocket('ws://localhost:8080');
// the first subscriber, opens the WebSocket connection
const subscription1 = firstSubject$.subscribe(msg =&gt; {
});
// the second subscriber, uses the already opened WebSocket
   connection
const subscription2 = firstSubject$.subscribe(msg =&gt; {
});
//this subscriber opens a new connection
const subscription3 = secondSubject$.subscribe(msg =&gt; {
});</span></pre> <p><span class="koboSpan" id="kobo.233.1">Let’s explain what’s happening in this code. </span><span class="koboSpan" id="kobo.233.2">First, we create two instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">WebSocketSubject</span></strong><span class="koboSpan" id="kobo.235.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">firstSubject$</span></strong><span class="koboSpan" id="kobo.237.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">secondSubject$</span></strong><span class="koboSpan" id="kobo.239.1">, respectively, which both reference the same </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">ws</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.241.1"> endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">Then, we create a subscription to </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">firstSubject$</span></strong><span class="koboSpan" id="kobo.244.1">; this first subscription will open the WebSocket connection. </span><span class="koboSpan" id="kobo.244.2">Then, we create a </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.245.1">second subscription to the same Observable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">firstSubject$</span></strong><span class="koboSpan" id="kobo.247.1">; this second subscription will use the already opened </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">WebSocket connection.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">However, the subscription to </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">secondSubject$</span></strong><span class="koboSpan" id="kobo.251.1"> will open a new WebSocket connection. </span><span class="koboSpan" id="kobo.251.2">Why? </span><span class="koboSpan" id="kobo.251.3">Because it is a new reference to the WebSocket subject, even though it references the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">ws</span></strong><span class="koboSpan" id="kobo.253.1"> endpoint </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">firstSubject$</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">Now, if we have many subscribers sharing the same connection and one of those subscribers decides to complete, then the connection will be released unless there are no more subscribers listening, as described in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.259.1">
const subject$ = webSocket('ws://localhost:8080');
// the first subscriber, opens the WebSocket connection
const subscription1 = subject$.subscribe(msg =&gt; {});
// the second subscriber, uses the already opened WebSocket connection
const subscription2 = subject$.subscribe(msg =&gt; {});
// the connection stays open
subscription1.unsubscribe();
// closes the connection
subscription2.unsubscribe();</span></pre> <p><span class="koboSpan" id="kobo.260.1">This is all that</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.261.1"> you need </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.262.1">to know to make a basic scenario work. </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">Simple, right?</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">Now, let’s see the recommended pattern for putting our recipe app </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">in place.</span></span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.266.1">WebSocketSubject in action</span></h2>
<p><span class="koboSpan" id="kobo.267.1">Now that</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.268.1"> we know how to create a connection to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">ws</span></strong><span class="koboSpan" id="kobo.270.1"> endpoint, it is time to explore the different steps to consume real-time messages in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">RecipesApp</span></strong><span class="koboSpan" id="kobo.272.1">. </span><span class="koboSpan" id="kobo.272.2">In particular, we will establish a connection to the WebSocket server, and once the new recipe is sent to the frontend, we will update it in the UI. </span><span class="koboSpan" id="kobo.272.3">Let’s delve into the various steps necessary to fulfill </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">this requirement.</span></span></p>
<h3><span class="koboSpan" id="kobo.274.1">Step one – create a real-time service</span></h3>
<p><span class="koboSpan" id="kobo.275.1">The first step is to isolate all the interactions with </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">WebSocketSubject</span></strong><span class="koboSpan" id="kobo.277.1"> in a separate Angular service. </span><span class="koboSpan" id="kobo.277.2">To do this, we will </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.278.1">create an Angular service called </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">RealTimeService</span></strong><span class="koboSpan" id="kobo.280.1"> under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">src/app/core/services</span></strong><span class="koboSpan" id="kobo.282.1"> path. </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">RealTimeService</span></strong><span class="koboSpan" id="kobo.284.1"> will look </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
import { Injectable } from '@angular/core';
import { webSocket, WebSocketSubject } from 'rxjs/webSocket';
import { environment } from '../../../environments/environment';
import { Recipe } from '../model/recipe.model';
export const WS_ENDPOINT = environment.wsEndpoint;
@Injectable({
  providedIn: 'root'
})
export class RealTimeService {
  private socket$: WebSocketSubject&lt;Recipe[]&gt; | undefined;
  private messagesSubject$ = new
    BehaviorSubject&lt;Observable&lt;Recipe[]&gt;&gt;(EMPTY);
  private getNewWebSocket(): WebSocketSubject&lt;Recipe[]&gt; {
    return webSocket(WS_ENDPOINT);
  }
  sendMessage(msg: Recipe[]) {
    this.socket$?.next(msg);
  }
  close() {
    this.socket$?.complete();
  } }</span></pre> <p><span class="koboSpan" id="kobo.287.1">Let’s break down what’s happening at the level of this code in the service that </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">we defined:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.289.1">We have a private property, </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">socket$</span></strong><span class="koboSpan" id="kobo.291.1">, of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">WebSocketSubject&lt;Recipe[]&gt;|undefined</span></strong><span class="koboSpan" id="kobo.293.1">, as we will receive an array containing one or more recipes from the backend. </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">socket$</span></strong><span class="koboSpan" id="kobo.295.1"> contains the reference to the WebSocket subject that we will create using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">getNewWebSocket()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.297.1"> method.</span></span></li>
<li><span class="koboSpan" id="kobo.298.1">We have a private </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.300.1"> named </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">messagesSubject$</span></strong><span class="koboSpan" id="kobo.302.1">, which is responsible for transmitting the latest incoming messages from the WebSocket server to new subscribers. </span><span class="koboSpan" id="kobo.302.2">We’ve provided the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">Observable&lt;Recipe[]&gt;</span></strong><span class="koboSpan" id="kobo.304.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">messagesSubject$</span></strong><span class="koboSpan" id="kobo.306.1">, as it will emit an Observable containing an array of recipe objects. </span><span class="koboSpan" id="kobo.306.2">Initially, we’ve set it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">EMPTY</span></strong><span class="koboSpan" id="kobo.308.1">, which is an Observable that immediately completes without emitting </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">any values.</span></span></li>
<li><span class="koboSpan" id="kobo.310.1">We have a private method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">getNewWebSocket()</span></strong><span class="koboSpan" id="kobo.312.1">, that calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">webSocket</span></strong><span class="koboSpan" id="kobo.314.1"> factory function, passing a constant named </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">WS_ENDPOINT</span></strong><span class="koboSpan" id="kobo.316.1"> as input, and this </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">WebSocketSubject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">.</span></span><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">WS_ENDPOINT</span></strong><span class="koboSpan" id="kobo.321.1"> represents the endpoint of the WebSocket server defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">src/environments/environment.ts</span></strong><span class="koboSpan" id="kobo.323.1"> file as </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">wsEndpoint</span></strong><span class="koboSpan" id="kobo.325.1">. </span><span class="koboSpan" id="kobo.325.2">Note that URLs are environment-specific configurations, which means they can change from one environment to another (e.g., development, staging, and production). </span><span class="koboSpan" id="kobo.325.3">Defining endpoint URLs in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">environment.ts</span></strong><span class="koboSpan" id="kobo.327.1"> file is a common practice in Angular applications because it provides a centralized location to handle environment-specific configuration settings, so you can easily switch between environments without modifying your </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">application code.</span></span></p></li>
<li><span class="koboSpan" id="kobo.329.1">We have a public method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">sendMessage()</span></strong><span class="koboSpan" id="kobo.331.1">, that sends a message that is given as input to the socket, which will forward the message to </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">the server.</span></span></li>
<li><span class="koboSpan" id="kobo.333.1">Finally, we have a public method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">close()</span></strong><span class="koboSpan" id="kobo.335.1">, that closes the connection by completing </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">the subject.</span></span></li>
</ul>
<p><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.337.1">Then, we will </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.338.1">add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">connect()</span></strong><span class="koboSpan" id="kobo.340.1"> method, which will listen to the incoming messages in a reactive way and emit messages to the subscribers </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.342.1">
  public connect(): void {
      if (!this.socket$ || this.socket$.closed) {
      this.socket$ = this.getNewWebSocket();
      const messages = this.socket$.pipe(
        tap({
          error: error =&gt; console.log(error),
        }), catchError(_ =&gt; EMPTY));
      this.messagesSubject$.next(messages);
    }
  }</span></pre> <p><span class="koboSpan" id="kobo.343.1">Let’s break down what is going on in this method. </span><span class="koboSpan" id="kobo.343.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">socket$</span></strong><span class="koboSpan" id="kobo.345.1"> is undefined (not yet created) or closed, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">socket$</span></strong><span class="koboSpan" id="kobo.347.1"> will be populated by the newly produced </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">WebSocketSubject</span></strong><span class="koboSpan" id="kobo.349.1"> from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">getNewWebSocket</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.351.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.352.1">Then, we will combine the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">tap</span></strong><span class="koboSpan" id="kobo.354.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">catchError</span></strong><span class="koboSpan" id="kobo.356.1"> operators; the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">tap</span></strong><span class="koboSpan" id="kobo.358.1"> operator is used to log a message when an error occurs or when the connection closes, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">catchError</span></strong><span class="koboSpan" id="kobo.360.1"> operator handles errors and returns an </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">empty Observable.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">The returned Observable from the pipe operation will be stored in a constant called </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">messages</span></strong><span class="koboSpan" id="kobo.364.1">. </span><span class="koboSpan" id="kobo.364.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">messagesSubject$</span></strong><span class="koboSpan" id="kobo.366.1"> Observable will emit the messages’ Observable (so, it is an Observable </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">of Observables):</span></span></p>
<p><span class="koboSpan" id="kobo.368.1">After that, we will</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.369.1"> provide a read-only copy from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">messagesSubject$</span></strong><span class="koboSpan" id="kobo.371.1"> Observable through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">messages$</span></strong><span class="koboSpan" id="kobo.373.1"> public Observable defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">RealTimeService</span></strong><span class="koboSpan" id="kobo.375.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">follows: :</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.377.1">
  public messages$ = this.messagesSubject$.pipe(
  switchAll(), catchError(e =&gt; { throw e }));</span></pre> <p><span class="koboSpan" id="kobo.378.1">We used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">SwitchAll</span></strong><span class="koboSpan" id="kobo.380.1"> operator to flatten the Observable of an Observable, and we will be subscribing to </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">messages$</span></strong><span class="koboSpan" id="kobo.382.1"> in every component that needs to consume real-time updates. </span><span class="koboSpan" id="kobo.382.2">Why do we do this? </span><span class="koboSpan" id="kobo.382.3">The idea is to protect </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">Subject$</span></strong><span class="koboSpan" id="kobo.384.1"> and the incoming messages from any external update and expose the messages to the consumers as read only. </span><span class="koboSpan" id="kobo.384.2">In this way, any component interested in consuming the real-time messages has to subscribe to </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">messages$</span></strong><span class="koboSpan" id="kobo.386.1">, and all the logic related to the socket will be handled privately in </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">this service.</span></span></p>
<h3><span class="koboSpan" id="kobo.388.1">Step two – trigger the connection</span></h3>
<p><span class="koboSpan" id="kobo.389.1">After </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.390.1">putting the service in place, we should call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">connect</span></strong><span class="koboSpan" id="kobo.392.1"> method. </span><span class="koboSpan" id="kobo.392.2">As we want the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">connect</span></strong><span class="koboSpan" id="kobo.394.1"> method to be triggered just once, we will call it from the root component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">src/app/app.component.ts</span></strong><span class="koboSpan" id="kobo.396.1">, after injecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">RealTimeService</span></strong><span class="koboSpan" id="kobo.398.1">. </span><span class="koboSpan" id="kobo.398.2">Here’s the code to </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">be added:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.400.1">
constructor(private service: RealTimeService ) {
this.service.connect();
}</span></pre> <h3><span class="koboSpan" id="kobo.401.1">Step three – define the Observable emitting live updates</span></h3>
<p><span class="koboSpan" id="kobo.402.1">Next, we should call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">messages$</span></strong><span class="koboSpan" id="kobo.404.1"> Observable</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.405.1"> in the adequate Angular component. </span><span class="koboSpan" id="kobo.405.2">As we want to update the list of recipes with the newest ones, we should define the Observable </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">RecipesListComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">But wait! </span><span class="koboSpan" id="kobo.409.2">We already have an Observable in </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.411.1"> named </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">recipes$</span></strong><span class="koboSpan" id="kobo.413.1"> that fetches the list of recipes </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">RecipesService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.417.1">
recipes$=this.service.recipes$;</span></pre> <p><span class="koboSpan" id="kobo.418.1">Could we use this existing Observable instead of creating a new </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">one? </span><span class="koboSpan" id="kobo.419.2">Absolutely!</span></span></p>
<p><span class="koboSpan" id="kobo.420.1">Our goal is to initially display the list of recipes emitted by </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">recipes$</span></strong><span class="koboSpan" id="kobo.422.1"> and then seamlessly incorporate any newly added recipes emitted by </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">messages$</span></strong><span class="koboSpan" id="kobo.424.1">. </span><span class="koboSpan" id="kobo.424.2">We can achieve this using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">combineLatest</span></strong><span class="koboSpan" id="kobo.426.1"> operator </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">from RxJS.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">combineLatest</span></strong><span class="koboSpan" id="kobo.430.1"> operator merges the latest values from multiple Observables into an array and emits a new array whenever any of the source Observables emits a value. </span><span class="koboSpan" id="kobo.430.2">By leveraging this operator, we can combine </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">recipes$</span></strong><span class="koboSpan" id="kobo.432.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">messages$</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.434.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.435.1">
recipes$=combineLatest([this.service.recipes$,
this.realTimeservice.messages$]).pipe(map(([recipes,
updatedRecipes]) =&gt; {
    // Merge or concatenate the two arrays into a single
       array
    return [...recipes, ...updatedRecipes];
  }));</span></pre> <p><span class="koboSpan" id="kobo.436.1">In the code, we combined </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">recipes$</span></strong><span class="koboSpan" id="kobo.438.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">messages$</span></strong><span class="koboSpan" id="kobo.440.1"> and then used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">map</span></strong><span class="koboSpan" id="kobo.442.1"> operator to extract the latest values emitted by each. </span><span class="koboSpan" id="kobo.442.2">We then merge these values into a single array, which is then returned. </span><span class="koboSpan" id="kobo.442.3">This ensures that </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">recipes$</span></strong><span class="koboSpan" id="kobo.444.1"> consistently emits a unified array containing </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">all recipes.</span></span></p>
<h4><span class="koboSpan" id="kobo.446.1">Preventing data loss with the scan operator</span></h4>
<p><span class="koboSpan" id="kobo.447.1">Now, let’s quickly consider a scenario where a recipe with an ID of 12 is initially pushed and added to the recipes list. </span><span class="koboSpan" id="kobo.447.2">If another recipe with, for example, an ID of 14 is pushed afterward from the server, then the newest pushed recipe (ID 14) will override the previous one (ID 12). </span><span class="koboSpan" id="kobo.447.3">Therefore, the ID 12 recipe will be lost. </span><span class="koboSpan" id="kobo.447.4">To prevent this data loss, we can use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">scan</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.449.1"> operator.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">scan</span></strong><span class="koboSpan" id="kobo.452.1"> operator in RxJS is similar to the reduce function in JavaScript. </span><span class="koboSpan" id="kobo.452.2">It applies an accumulator function over an Observable sequence and returns each intermediate result, emitting the accumulated value each time a new value is emitted by the source Observable. </span><span class="koboSpan" id="kobo.452.3">In simpler terms, it continuously applies a function to each value emitted by the source Observable, accumulating these values over time and emitting the intermediate results. </span><span class="koboSpan" id="kobo.452.4">This operator is useful for maintaining the state, accumulating values, or performing any kind of stateful transformation on </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">Observable streams.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">So, in our case, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">scan</span></strong><span class="koboSpan" id="kobo.456.1"> operator </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.458.1">
  recipes$ = combineLatest([
    this.service.recipes$,
    this.realTimeService.messages$
  ]).pipe(
    scan((acc: Recipe[], [recipes, updatedRecipes]:
    [Recipe[], Recipe[]]) =&gt; {
      // Merge or concatenate the two arrays into a single
         array
      return acc.length === 0 &amp;&amp;
        updatedRecipes.length === 0 ? </span><span class="koboSpan" id="kobo.458.2">recipes : [...acc,
          ...updatedRecipes,];
    }, [])
  );</span></pre> <p><span class="koboSpan" id="kobo.459.1">In this context, </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">scan</span></strong><span class="koboSpan" id="kobo.461.1"> ensures that all emitted recipes, including both the initial recipes fetched from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">this.service.recipes$</span></strong><span class="koboSpan" id="kobo.463.1"> stream and any subsequent updates received from </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">this.realTimeService.messages$</span></strong><span class="koboSpan" id="kobo.465.1">, are accumulated into a single array. </span><span class="koboSpan" id="kobo.465.2">This prevents the loss of data that could occur if a simple mapping operation were used. </span><span class="koboSpan" id="kobo.465.3">As a result, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">recipes$</span></strong><span class="koboSpan" id="kobo.467.1"> Observable stream contains a comprehensive and up-to-date list of recipes, reflecting all changes from both sources throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">its lifetime.</span></span></p>
<h3><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.469.1">Step four – subscribe to the Observable emitting live updates</span></h3>
<p><span class="koboSpan" id="kobo.470.1">Finally, we just have to subscribe to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">recipes$</span></strong><span class="koboSpan" id="kobo.472.1"> Observable in our component’s template using the async pipe, which is already carried out </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">recipes-list.component.html</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.476.1">
@if ( recipes$ | async; as recipes) {
....
</span><span class="koboSpan" id="kobo.476.2">}</span></pre> <p><span class="koboSpan" id="kobo.477.1">However, we have one more tweak to consider! </span><span class="koboSpan" id="kobo.477.2">Since we’ve established that </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">messages$</span></strong><span class="koboSpan" id="kobo.479.1"> emits after a 5-second delay following the emission of </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">recipes$</span></strong><span class="koboSpan" id="kobo.481.1">, there’s a slight problem: </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">combineLatest</span></strong><span class="koboSpan" id="kobo.483.1"> only emits once both Observables have </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">emitted values.</span></span></p>
<p><span class="koboSpan" id="kobo.485.1">To circumvent this brief latency while waiting for </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">messages$</span></strong><span class="koboSpan" id="kobo.487.1"> to emit, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">RealTimeService</span></strong><span class="koboSpan" id="kobo.489.1">, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">startWith()</span></strong><span class="koboSpan" id="kobo.491.1"> operator on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">messages$</span></strong><span class="koboSpan" id="kobo.493.1"> subject to supply an initial value of an empty array </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.495.1">
  public messages$ =
  this.messagesSubject$.pipe(switchAll(), startWith([]),
  catchError(e =&gt; { throw e }));</span></pre> <p><span class="koboSpan" id="kobo.496.1">After executing this code, you will notice that 5 seconds after displaying 11 recipes, the recipe with an ID of </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">12</span></strong><span class="koboSpan" id="kobo.498.1"> (chili chicken) will be added to the list on the second page of our cards list. </span><span class="koboSpan" id="kobo.498.2">If another recipe is pushed afterward, it will be accumulated to the current list </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">of recipes.</span></span></p>
<p><span class="koboSpan" id="kobo.500.1">Note that in the case</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.501.1"> of frequent updates in the UI, it is highly recommended to set the change detection strategy to </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">onPush</span></strong><span class="koboSpan" id="kobo.503.1"> in order to optimize the performance, </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.505.1">
@Component({
  selector: 'app-recipes-list',
  standalone: true,
  changeDetection: ChangeDetectionStrategy.OnPush
})</span></pre> <p><span class="koboSpan" id="kobo.506.1">And that’s it! </span><span class="koboSpan" id="kobo.506.2">You will be able to consume live updates in a reactive way using </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">this pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.508.1">At this point, you may be wondering how to handle reconnection. </span><span class="koboSpan" id="kobo.508.2">When the server is restarted or the connection crashes for whatever reason, does this subject restore the lost connection under </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">the hood?</span></span></p>
<p><span class="koboSpan" id="kobo.510.1">The answer is </span><strong class="bold"><span class="koboSpan" id="kobo.511.1">no</span></strong><span class="koboSpan" id="kobo.512.1">. </span><span class="koboSpan" id="kobo.512.2">The reconnection capability is not provided </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">WebSocketSubject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.516.1">However, you can implement this easily in your web application using RxJS. </span><span class="koboSpan" id="kobo.516.2">Let’s learn how you can do this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">next section.</span></span></p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.518.1">Learning the reactive pattern for handling reconnection</span></h1>
<p><span class="koboSpan" id="kobo.519.1">When the </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.520.1">connection to the WebSocket server is lost, the channel will be closed, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">WebSocketSubjet</span></strong><span class="koboSpan" id="kobo.522.1"> will no longer emit values. </span><span class="koboSpan" id="kobo.522.2">This is not the expected behavior in the world of real time. </span><span class="koboSpan" id="kobo.522.3">The reconnection capability is a must in </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">most cases.</span></span></p>
<p><span class="koboSpan" id="kobo.524.1">Therefore, let’s imagine, for example, that after a disconnection, a system tries to reconnect after every 3 seconds. </span><span class="koboSpan" id="kobo.524.2">The solution, in this case, is intercepting the closure of the socket and retrying the connection. </span><span class="koboSpan" id="kobo.524.3">How can we intercept the closure of </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">the connection?</span></span></p>
<p><span class="koboSpan" id="kobo.526.1">This is possible thanks to </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">WebSocketSubjectConfig</span></strong><span class="koboSpan" id="kobo.528.1">, which is responsible for customizing some behavior in the socket life cycle. </span><span class="koboSpan" id="kobo.528.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">WebSocketSubjectConfig</span></strong><span class="koboSpan" id="kobo.530.1"> interface in RxJS provides several properties that you can use to configure a WebSocketSubject. </span><span class="koboSpan" id="kobo.530.2">These properties allow you to customize various aspects of </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">WebSocket communication:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.532.1">
export interface WebSocketSubjectConfig&lt;T&gt; {
  url: string;
  protocol?: string | Array&lt;string&gt;;
  /** @deprecated Will be removed in v8. </span><span class="koboSpan" id="kobo.532.2">Use {@link
  deserializer} instead. </span><span class="koboSpan" id="kobo.532.3">*/
  resultSelector?: (e: MessageEvent) =&gt; T;
  openObserver?: NextObserver&lt;Event&gt;;
  serializer?: (value: T) =&gt; WebSocketMessage;
  deserializer?: (e: MessageEvent) =&gt; T;
  closeObserver?: NextObserver&lt;CloseEvent&gt;;
  closingObserver?: NextObserver&lt;void&gt;;
  WebSocketCtor?: { new(url: string,
  protocols?:string|string[]): WebSocket };
  binaryType?: 'blob' | 'arraybuffer';
}</span></pre> <p><span class="koboSpan" id="kobo.533.1">Let’s explain the different properties available </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">WebSocketSubjectConfig</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">url</span></strong><span class="koboSpan" id="kobo.538.1">: This property specifies the URL of the WebSocket endpoint to connect to (we’ve already explained and and used this in </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">this chapter).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">protocol</span></strong><span class="koboSpan" id="kobo.541.1">: This property specifies the subprotocol to use during the WebSocket handshake (refer to </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.542.1">Figure 12</span></em></span><em class="italic"><span class="koboSpan" id="kobo.543.1">.1</span></em><span class="koboSpan" id="kobo.544.1">). </span><span class="koboSpan" id="kobo.544.2">It can be a single string or an array of strings representing </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">the subprotocols.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">resultSelector</span></strong><span class="koboSpan" id="kobo.547.1">: This property specifies a function that takes the WebSocket event as input and returns the value to be emitted by </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">WebSocketSubject</span></strong><span class="koboSpan" id="kobo.549.1">. </span><span class="koboSpan" id="kobo.549.2">It’s commonly used to extract specific data from WebSocket events; however, it is deprecated and will be removed in version 8 </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">of RxJS.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">closeObserver</span></strong><span class="koboSpan" id="kobo.552.1">: This property specifies an observer object that listens for the WebSocket connection closing. </span><span class="koboSpan" id="kobo.552.2">It can be used to handle cleanup tasks or perform actions when the connection </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">is closed.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">openObserver</span></strong><span class="koboSpan" id="kobo.555.1">: This property specifies an observer object that listens for the WebSocket connection opening. </span><span class="koboSpan" id="kobo.555.2">It can be used to perform actions when the connection is </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">successfully established.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">binaryType</span></strong><span class="koboSpan" id="kobo.558.1">: This property specifies the binary type of WebSocket messages. </span><span class="koboSpan" id="kobo.558.2">It can be either of the JavaScript types </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">blob</span></strong><span class="koboSpan" id="kobo.560.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">arraybuffer</span></strong><span class="koboSpan" id="kobo.562.1">. </span><span class="koboSpan" id="kobo.562.2">By default, it’s set </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">blob</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">serializer</span></strong><span class="koboSpan" id="kobo.567.1">: This property specifies a function used to serialize outgoing messages before sending them over the WebSocket connection. </span><span class="koboSpan" id="kobo.567.2">It’s commonly used to convert objects or complex data structures </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">into strings.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">deserializer</span></strong><span class="koboSpan" id="kobo.570.1">: This property specifies a function used to deserialize incoming messages received over the WebSocket connection. </span><span class="koboSpan" id="kobo.570.2">It’s commonly used to parse received strings back into objects or other </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">data types.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.572.1">These properties provide flexibility and control over WebSocket communication in RxJS. </span><span class="koboSpan" id="kobo.572.2">You can customize them according to your specific requirements to optimize WebSocket interactions in </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">your application.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.574.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.575.1">The full description of each property is available in the official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">link: </span></span><a href="http://bit.ly/RxJS-WebSocket"><span class="No-Break"><span class="koboSpan" id="kobo.577.1">http://bit.ly/RxJS-WebSocket</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.578.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.579.1">In order to</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.580.1"> benefit from </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">WebSocketSubjectConfig</span></strong><span class="koboSpan" id="kobo.582.1">, you should call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">webSocket</span></strong><span class="koboSpan" id="kobo.584.1"> factory function, which takes the second type of parameter. </span><span class="koboSpan" id="kobo.584.2">The following code creates </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">WebSocketSubject</span></strong><span class="koboSpan" id="kobo.586.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">WebSocketSubjectConfig</span></strong><span class="koboSpan" id="kobo.588.1"> and simply intercepts the closure event to display a </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">custom message:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.590.1">
private getNewWebSocket() {
  return webSocket({
    url: WS_ENDPOINT,
    closeObserver: {
      next: () =&gt; {
        console.log('[RealTimeService]: connection
                    closed');
      }
    },
  });
}</span></pre> <p><span class="koboSpan" id="kobo.591.1">Now that we know how to intercept the closure of the connection, let’s learn how to retry the reconnection. </span><span class="koboSpan" id="kobo.591.2">We can</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.592.1"> combine the </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">retryWhen</span></strong><span class="koboSpan" id="kobo.594.1"> operator that conditionally resubscribes to an Observable after it completes using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">delayWhen</span></strong><span class="koboSpan" id="kobo.596.1"> operator that sets the delay between two </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">consecutive connections.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">So, let’s create a function that will retry to connect to a given Observable for every configurable </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">RECONNECT_INTERVAL</span></strong><span class="koboSpan" id="kobo.600.1">; we will log into the browser’s console on every attempt </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">at reconnection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.602.1">
    private reconnect(observable: Observable&lt; Recipe[] &gt;):
    Observable&lt; Recipe[] &gt; {
      return observable.pipe(retryWhen(errors =&gt;
        errors.pipe(
          tap(val =&gt; console.log('[Data Service]
            Try to reconnect', val)),
              delayWhen(_ =&gt; timer(RECONNECT_INTERVAL)))));
    }</span></pre> <p><span class="koboSpan" id="kobo.603.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">reconnect</span></strong><span class="koboSpan" id="kobo.605.1"> function</span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.606.1"> will be used as an RxJS custom operator to handle the reconnection after the socket’s closure in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">connect()</span></strong><span class="koboSpan" id="kobo.608.1"> method of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">RealTimeService</span></strong><span class="koboSpan" id="kobo.610.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.612.1">
public connect(cfg: { reconnect: boolean } = { reconnect: false }): void {
  if (!this.socket$ || this.socket$.closed) {
    this.socket$ = this.getNewWebSocket();
    const messages = this.socket$.pipe(cfg.reconnect ?
</span><span class="koboSpan" id="kobo.612.2">    this.reconnect : o =&gt; o,
      tap({
        error: error =&gt; console.log(error),
      }), catchError(_ =&gt; EMPTY))
    this.messagesSubject$.next(messages);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.613.1">As you can see, a new Boolean </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">reconnect</span></strong><span class="koboSpan" id="kobo.615.1"> parameter is added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">connect</span></strong><span class="koboSpan" id="kobo.617.1"> function to differentiate between the reconnection and the first connection. </span><span class="koboSpan" id="kobo.617.2">This optimizes the code and avoids adding an </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">additional function.</span></span></p>
<p><span class="koboSpan" id="kobo.619.1">Then, all you have to do is call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">connect</span></strong><span class="koboSpan" id="kobo.621.1"> function with </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">reconnect: true</span></strong><span class="koboSpan" id="kobo.623.1"> when intercepting the </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">con</span><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.625.1">nection closure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.626.1">
    private getNewWebSocket() {
      return webSocket({
        url: WS_ENDPOINT,
        closeObserver: {
          next: () =&gt; {
            console.log('[DataService]: connection
                        closed');
            this.socket$ = undefined;
            this.connect({ reconnect: true });
          }
        },
      });</span></pre> <p><span class="koboSpan" id="kobo.627.1">In this way, after the connection closure, you will see many outgoing requests from the client trying to reach the server every </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">3 seconds.</span></span></p>
<p><span class="koboSpan" id="kobo.629.1">The </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.630.1">reconnection capability is a must in the world of real time. </span><span class="koboSpan" id="kobo.630.2">This is how we handled it using RxJS in a few lines of code. </span><span class="koboSpan" id="kobo.630.3">Many developers don’t know that RxJS offers this feature, which enables you to consume real-time messages coming from WebSocket and add many third-party libraries to handle this requirement, and it is also available out of the box. </span><span class="koboSpan" id="kobo.630.4">So, choosing RxJS, in this case, is one </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">less dependency!</span></span></p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.632.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.633.1">In this chapter, we delved into a practical demonstration of consuming real-time messages from a WebSocket server in a reactive manner. </span><span class="koboSpan" id="kobo.633.2">We first outlined the requirements and provided context for the implementation. </span><span class="koboSpan" id="kobo.633.3">Subsequently, we explored the capabilities of WebSocketSubject and described the step-by-step process, from establishing a connection to handling incoming messages from the socket.Next. </span><span class="koboSpan" id="kobo.633.4">We applied these concepts to a real-world scenario within the recipe app, gaining insights into best practices for implementing real-time functionality and ensuring robust </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">connection control.</span></span></p>
<p><span class="koboSpan" id="kobo.635.1">Finally, we expanded our understanding by incorporating a reconnection mechanism in a reactive way, leveraging the WebSocketSubjectConfig and RxJS operators to achieve seamless </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">connection management.</span></span></p>
<p><span class="koboSpan" id="kobo.637.1">Now, as we approach the final chapter of this book, let’s switch gears and focus on </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">testing Observables.</span></span></p>
</div>


<div class="Content" id="_idContainer081">
<h1 id="_idParaDest-183" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.1.1">Part 5: Final Touches</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, you’ll discover the different strategies to test reactive streams. </span><span class="koboSpan" id="kobo.2.2">We’ll explore their benefits and when to use each one, reinforcing your learning with </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">practical examples.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapter:</span></span></p>
<ul>
<li><a href="B21180_13.xhtml#_idTextAnchor191"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 13</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Testing RxJS Observables</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer082">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer083">
</div>
</div>
</body></html>