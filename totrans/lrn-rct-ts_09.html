<html><head></head><body>
		<div id="_idContainer139">
			<h1 id="_idParaDest-218" class="chapter-number"><a id="_idTextAnchor220"/>9</h1>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor221"/>Interacting with RESTful APIs</h1>
			<p>In this chapter, we will build a page that lists blog posts fetched from a REST API, as well as also a form to submit blog posts to the REST API. Through this, we will learn about various approaches to interacting with a REST API from a <span class="No-Break">React component.</span></p>
			<p>The first approach will be using React’s <strong class="source-inline">useEffect</strong> hook with the browser’s <strong class="source-inline">fetch</strong> function. As part of this process, we learn how to use a type assertion function to strongly type the data from a REST API. We will then use the data loading capability of <strong class="bold">React Router</strong> and experience its benefits. After that, we will move on to use a popular library called <strong class="bold">React Query</strong> and experience its benefits, before using React Query and React Router together to get the best of both <span class="No-Break">these libraries.</span></p>
			<p>So, in this chapter, we’ll cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Getting <span class="No-Break">set up</span></li>
				<li>Using the effect hook <span class="No-Break">with fetch</span></li>
				<li>Posting data <span class="No-Break">with fetch</span></li>
				<li>Using <span class="No-Break">React Router</span></li>
				<li>Using <span class="No-Break">React Query</span></li>
				<li>Using React Router with <span class="No-Break">React Query</span></li>
			</ul>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor222"/>Technical requirements</h1>
			<p>We will use the following technologies in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><strong class="bold">Node.js</strong> and <strong class="bold">npm</strong>: You can install them <span class="No-Break">from </span><a href="https://nodejs.org/en/download/"><span class="No-Break">https://nodejs.org/en/download/</span></a></li>
				<li><strong class="bold">Visual Studio Code</strong>: You can install it <span class="No-Break">from </span><a href="https://code.visualstudio.com/"><span class="No-Break">https://code.visualstudio.com/</span></a></li>
			</ul>
			<p>All the code snippets in this chapter can be found online <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter9"><span class="No-Break">https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter9</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor223"/>Creating the project</h1>
			<p>In this section, we <a id="_idIndexMarker664"/>will start by creating the project for the app we will build. We will then create a REST API for the app <span class="No-Break">to consume.</span></p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor224"/>Setting up the project</h2>
			<p>We will develop the <a id="_idIndexMarker665"/>app using Visual Studio Code and require a new Create React App-based project setup. We’ve previously covered this several times, so we will not cover the steps in this chapter – instead, see <a href="B19051_03.xhtml#_idTextAnchor072"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Setting Up React </em><span class="No-Break"><em class="italic">and TypeScript</em></span><span class="No-Break">.</span></p>
			<p>We will style the app with Tailwind CSS. We have previously covered how to install and configure Tailwind in Create React App in <a href="B19051_05.xhtml#_idTextAnchor127"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Approaches to Styling Frontends</em>. So, after you have created the React and TypeScript project, install and <span class="No-Break">configure Tailwind.</span></p>
			<p>We will use React Router to load data, so see <a href="B19051_06.xhtml#_idTextAnchor151"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Routing with React Router,</em> for information on how to <span class="No-Break">do this.</span></p>
			<p>We will use <strong class="bold">React Hook Form</strong> to implement<a id="_idIndexMarker666"/> the form that creates blog posts, and the <strong class="source-inline">@tailwindcss/forms</strong> plugin to style the form. See <a href="B19051_07.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Working with Forms,</em> for a reminder of how to <span class="No-Break">implement these.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor225"/>Understanding the component structure</h2>
			<p>The app will <a id="_idIndexMarker667"/>be a single page containing a form for adding new posts above a list of all the existing posts. The app will be structured into the <span class="No-Break">following components:</span></p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B19051_09_01.jpg" alt="Figure 9.1 – App component structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – App component structure</p>
			<p>Here’s a description of <span class="No-Break">these components:</span></p>
			<ul>
				<li><strong class="source-inline">PostsPage</strong> will render the whole page by referencing the <strong class="source-inline">NewPostForm</strong> and <strong class="source-inline">PostsLists</strong> components. It will also interact with the <span class="No-Break">REST API.</span></li>
				<li><strong class="source-inline">NewPostForm</strong> will render a form that allows a user to enter a new blog post. This will use<a id="_idIndexMarker668"/> the <strong class="source-inline">ValidationError</strong> component to render validation error messages. The <strong class="source-inline">ValidationError</strong> component will be the same as the one created in <a href="B19051_07.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><span class="No-Break">.</span></li>
				<li><strong class="source-inline">PostsList</strong> will render the list of <span class="No-Break">blog posts.</span></li>
			</ul>
			<p>Right, now we know the component structure, let’s create the <span class="No-Break">REST API.</span></p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor226"/>Creating a REST API</h2>
			<p>We will create a <a id="_idIndexMarker669"/>REST API using a tool<a id="_idIndexMarker670"/> called <strong class="bold">JSON Server</strong>, which allows a REST API to be quickly created. Install JSON Server by running the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
npm i -D json-server</pre>
			<p>We then define the data behind the API in a JSON file. Create a file called <strong class="source-inline">db.json</strong> in the root of the project containing <span class="No-Break">the following:</span></p>
			<pre class="source-code">
{
  "posts": [
    {
      "title": "Getting started with fetch",
      "description": "How to interact with backend APIs using         fetch",
      "id": 1
    },
    {
      "title": "Getting started with useEffect",
      "description": "How to use React's useEffect hook for         interacting with backend APIs",
      "id": 2
    }
  ]
}</pre>
			<p>The preceding JSON <a id="_idIndexMarker671"/>means that the data behind the API will initially contain two blog posts (this code snippet can be copied <span class="No-Break">from </span><a href="https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter9/useEffect-fetch/db.json"><span class="No-Break">https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter9/useEffect-fetch/db.json</span></a><span class="No-Break">).</span></p>
			<p>Now we need to define an npm script to start the JSON server and handle requests. Open <strong class="source-inline">package.json</strong> and add a script called <strong class="source-inline">server</strong> <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
{
  ...,
  "scripts": {
    ...,
    <strong class="bold">"server": "json-server --watch db.json --port 3001 --delay       2000"</strong>
  },
  ...
}</pre>
			<p>The script starts the JSON server and watches the JSON file we just created. We have specified that the API runs on port <strong class="source-inline">3001</strong> so that it doesn’t clash with the app running on port <strong class="source-inline">3000</strong>. We have also slowed down the API responses by adding a 2-second delay, which will help us see when data is being fetched from the <span class="No-Break">React app.</span></p>
			<p>In a terminal, start the API by running the script we just created, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
npm run server</pre>
			<p>After a few seconds, the API starts. To check that the API is working correctly, open a browser and enter <a id="_idIndexMarker672"/>the following address: <strong class="source-inline">http://localhost:3001/posts</strong>. The blog post data should appear in the browser <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B19051_09_02.jpg" alt="Figure 9.2 – Blog posts REST API"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Blog posts REST API</p>
			<p>For more information<a id="_idIndexMarker673"/> on JSON Server, see the following <span class="No-Break">link: </span><a href="https://github.com/typicode/json-server"><span class="No-Break">https://github.com/typicode/json-server</span></a><span class="No-Break">.</span></p>
			<p>Now that the project is set up with a REST API, keeping the API running, next, we will learn how to interact with the REST API <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">useEffect</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor227"/>Using the effect hook with fetch</h1>
			<p>In this section, we will<a id="_idIndexMarker674"/> create a page that lists the blog posts returned from the REST API we just created. We will use the browser’s <strong class="source-inline">fetch</strong> function and React’s <strong class="source-inline">useEffect</strong> hook to interact with the <span class="No-Break">REST API.</span></p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor228"/>Getting blog posts using fetch</h2>
			<p>We will start by<a id="_idIndexMarker675"/> creating a function that gets blog posts from the REST API using the browser’s <strong class="source-inline">fetch</strong> function; we will store the API URL in an environment variable. To do this, carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>The same URL will be used to get, as well as save, new blog posts to the REST API. We will store this URL in an environment variable. So, create a file called <strong class="source-inline">.env</strong> in the root of the project containing this variable, <span class="No-Break">as follows:</span><pre class="source-code">
REACT_APP_API_URL = http://localhost:3001/posts/</pre></li>
			</ol>
			<p>This environment variable is injected into the code at build time and can be accessed by code using <strong class="source-inline">process.env.REACT_APP_API_URL</strong>. Environment variables in Create React App projects must be prefixed with <strong class="source-inline">React_APP_</strong>. For more information on environment variables, see the following <span class="No-Break">link: </span><a href="https://create-react-app.dev/docs/adding-custom-environment-variables/"><span class="No-Break">https://create-react-app.dev/docs/adding-custom-environment-variables/</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="2">Now, create a folder called <strong class="source-inline">posts</strong> in the <strong class="source-inline">src</strong> folder for all the files for the blog <span class="No-Break">post feature.</span></li>
				<li>Create a file called <strong class="source-inline">getPosts.ts</strong> in the <strong class="source-inline">posts</strong> folder. In this file, add the following function that gets the <span class="No-Break">blog posts:</span><pre class="source-code">
export async function getPosts() {</pre><pre class="source-code">
  const response = await fetch(</pre><pre class="source-code">
    process.env.REACT_APP_API_URL!</pre><pre class="source-code">
  );</pre><pre class="source-code">
  const body = await response.json()</pre><pre class="source-code">
  return body;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The <strong class="source-inline">fetch</strong> function has an argument for the URL to the REST API. We have used the <strong class="source-inline">REACT_APP_API_URL</strong> environment variable to specify this URL. Environment variable values can be <strong class="source-inline">undefined</strong>, but we know this isn’t the case, so we have <a id="_idIndexMarker676"/>added a <strong class="bold">not null assertion</strong> (<strong class="source-inline">!</strong>) <span class="No-Break">after it.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">A not null assertion operator is a special operator in TypeScript. It is used to inform the TypeScript compiler that the expression before it can’t be <strong class="source-inline">null</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">undefined</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">fetch</strong> returns a <strong class="source-inline">Response</strong> object and we call its <strong class="source-inline">json</strong> method to get the response body in JSON format. The <strong class="source-inline">json</strong> method is asynchronous, so we need to <span class="No-Break"><strong class="source-inline">await</strong></span><span class="No-Break"> it.</span></p>
			<p>For more information on <strong class="source-inline">fetch</strong>, see the following <span class="No-Break">link: </span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API</span></a><span class="No-Break">.</span></p>
			<p>That completes an<a id="_idIndexMarker677"/> initial version of <strong class="source-inline">getPosts</strong>. However, the return value type from <strong class="source-inline">getPosts</strong> is currently <strong class="source-inline">any</strong>, which means no type checking will occur on it. We will improve <span class="No-Break">this next.</span></p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor229"/>Strongly typing response data</h2>
			<p>In <a href="B19051_02.xhtml#_idTextAnchor044"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Introducing TypeScript</em>, we <a id="_idIndexMarker678"/>learned how to make unknown data strongly typed using the <strong class="source-inline">unknown</strong> type and type predicates. We will use the <strong class="source-inline">unknown</strong> type with a slightly different TypeScript feature<a id="_idIndexMarker679"/> called a <strong class="bold">type assertion function</strong> to type the response data in the <strong class="source-inline">getPosts</strong> function. Carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Add a type assertion to the JSON response so that the <strong class="source-inline">body</strong> variable has a type <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">unknown</strong></span><span class="No-Break">:</span><pre class="source-code">
export async function getPosts() {</pre><pre class="source-code">
  const response = await fetch(postsUrl);</pre><pre class="source-code">
  const body = <strong class="bold">(</strong>await response.json()<strong class="bold">) as unknown</strong>;</pre><pre class="source-code">
  return body;</pre><pre class="source-code">
}</pre></li>
				<li>Next, add the following type assertion function <span class="No-Break">beneath </span><span class="No-Break"><strong class="source-inline">getPosts</strong></span><span class="No-Break">:</span><pre class="source-code">
export function assertIsPosts(</pre><pre class="source-code">
  postsData: unknown</pre><pre class="source-code">
    ): asserts postsData is PostData[] {</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>Notice the return type annotation: <strong class="source-inline">asserts postsData is PostData[]</strong>. This is<a id="_idIndexMarker680"/> called an <strong class="bold">assertion signature</strong> and specifies that the <strong class="source-inline">postsData</strong> parameter is of the <strong class="source-inline">PostData[]</strong> type if no error occurs in the <span class="No-Break">function </span><span class="No-Break"><a id="_idIndexMarker681"/></span><span class="No-Break">execution.</span></p>
			<p>Don’t worry about the compile error where <strong class="source-inline">PostData</strong> is referenced – we will create the <strong class="source-inline">PostData</strong> type in <span class="No-Break"><em class="italic">s</em></span><span class="No-Break"><em class="italic">tep 8</em></span><span class="No-Break">.</span></p>
			<ol>
				<li value="3">Let’s carry on with the implementation of <strong class="source-inline">assertIsPosts</strong>. It will be a series of checks on the <strong class="source-inline">postsData</strong> parameter and it will throw an exception if a check fails. Start the implementation by checking that <strong class="source-inline">postsData</strong> is <span class="No-Break">an array:</span><pre class="source-code">
export function assertIsPosts(</pre><pre class="source-code">
  postsData: unknown</pre><pre class="source-code">
): asserts postsData is PostData[] {</pre><pre class="source-code">
  <strong class="bold">if (!Array.isArray(postsData)) {</strong></pre><pre class="source-code">
<strong class="bold">    throw new Error("posts isn't an array");</strong></pre><pre class="source-code">
<strong class="bold">  }</strong></pre><pre class="source-code">
<strong class="bold">  if (postsData.length === 0) {</strong></pre><pre class="source-code">
<strong class="bold">    return;</strong></pre><pre class="source-code">
<strong class="bold">  }</strong></pre><pre class="source-code">
}</pre></li>
				<li>Now, let’s do a check on the array items to see whether they have an <span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> property:</span><pre class="source-code">
export function assertIsPosts(</pre><pre class="source-code">
  postsData: unknown</pre><pre class="source-code">
): asserts postsData is PostData[] {</pre><pre class="source-code">
  ...</pre><pre class="source-code">
<strong class="bold">  postsData.forEach((post) =&gt; {</strong></pre><pre class="source-code">
<strong class="bold">    if (!('id' in post)) {</strong></pre><pre class="source-code">
<strong class="bold">      throw new Error("post doesn't contain id");</strong></pre><pre class="source-code">
<strong class="bold">    }</strong></pre><pre class="source-code">
<strong class="bold">    if (typeof post.id !== 'number') {</strong></pre><pre class="source-code">
<strong class="bold">      throw new Error('id is not a number');</strong></pre><pre class="source-code">
<strong class="bold">    }</strong></pre><pre class="source-code">
<strong class="bold">  });</strong></pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>We loop around <a id="_idIndexMarker682"/>all the posts using the array’s <strong class="source-inline">forEach</strong> method. Inside the loop, we check that the <strong class="source-inline">id</strong> property exists using the <strong class="source-inline">in</strong> operator. We also check that the <strong class="source-inline">id</strong> value is of the <strong class="source-inline">number</strong> type using the <span class="No-Break"><strong class="source-inline">typeof</strong></span><span class="No-Break"> operator.</span></p>
			<ol>
				<li value="5">We can do similar checks for the <strong class="source-inline">title</strong> and <span class="No-Break"><strong class="source-inline">description</strong></span><span class="No-Break"> properties:</span><pre class="source-code">
export function assertIsPosts(</pre><pre class="source-code">
  postsData: unknown</pre><pre class="source-code">
): asserts postsData is PostData[] {</pre><pre class="source-code">
  …</pre><pre class="source-code">
  postsData.forEach((post) =&gt; {</pre><pre class="source-code">
    ...</pre><pre class="source-code">
    <strong class="bold">if '!('ti'le' in post)) {</strong></pre><pre class="source-code">
<strong class="bold">      throw new Err"r("post do'sn't contain ti"le");</strong></pre><pre class="source-code">
<strong class="bold">    }</strong></pre><pre class="source-code">
<strong class="bold">    if (typeof post.title !'= 'str'ng') {</strong></pre><pre class="source-code">
<strong class="bold">      throw new Err'r('title is not a str'ng');</strong></pre><pre class="source-code">
<strong class="bold">    }</strong></pre><pre class="source-code">
<strong class="bold">    if '!('descript'on' in post)) {</strong></pre><pre class="source-code">
<strong class="bold">      throw new Err"r("post do'sn't contain         descript"on");</strong></pre><pre class="source-code">
<strong class="bold">    }</strong></pre><pre class="source-code">
<strong class="bold">    if (typeof post.description !'= 'str'ng') {</strong></pre><pre class="source-code">
<strong class="bold">      throw new Err'r('description is not a str'ng');</strong></pre><pre class="source-code">
<strong class="bold">    }</strong></pre><pre class="source-code">
  });</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>That completes <a id="_idIndexMarker683"/>the implementation of the type <span class="No-Break">assertion function.</span></p>
			<ol>
				<li value="6">Moving back to <strong class="source-inline">getPosts</strong>, add a call to the <span class="No-Break"><strong class="source-inline">assert</strong></span><span class="No-Break"> function:</span><pre class="source-code">
export async function getPosts() {</pre><pre class="source-code">
  const response = await fetch(postsUrl);</pre><pre class="source-code">
  const body = (await response.json()) as unknown;</pre><pre class="source-code">
<strong class="bold">  assertIsPosts(body);</strong></pre><pre class="source-code">
  return body;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The <strong class="source-inline">body</strong> variable will now be of the <strong class="source-inline">PostData[]</strong> type after a successful call to <strong class="source-inline">assertIsPosts</strong>. You can hover over the <strong class="source-inline">body</strong> variable in the return statement to <span class="No-Break">confirm this.</span></p>
			<ol>
				<li value="7">The final steps are to add the <strong class="source-inline">PostData</strong> type. Add an import statement at the top of <strong class="source-inline">getPosts.ts</strong> as follows to <span class="No-Break">import </span><span class="No-Break"><strong class="source-inline">PostData</strong></span><span class="No-Break">:</span><pre class="source-code">
import { PostData } from './types';</pre></li>
			</ol>
			<p>The file will still have compile errors because the <strong class="source-inline">types</strong> file doesn’t exist yet – we’ll do this in the <span class="No-Break">next step.</span></p>
			<ol>
				<li value="8">Add a file called <strong class="source-inline">types.ts</strong> in the <strong class="source-inline">posts</strong> folder with the following definition for the <span class="No-Break"><strong class="source-inline">PostData</strong></span><span class="No-Break"> type:</span><pre class="source-code">
export type PostData = {</pre><pre class="source-code">
  id: number;</pre><pre class="source-code">
  title: string;</pre><pre class="source-code">
  description: string;</pre><pre class="source-code">
};</pre></li>
			</ol>
			<p>This type represents a blog post from the <span class="No-Break">REST API.</span></p>
			<p>Now, we have a<a id="_idIndexMarker684"/> strongly typed function that gets blog posts from the REST API. Next, we will create a React component that lists the <span class="No-Break">blog posts.</span></p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor230"/>Creating a blog posts list component</h2>
			<p>We will create a<a id="_idIndexMarker685"/> React component<a id="_idIndexMarker686"/> that takes in the blog post data and renders it in a list. Carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">PostsList.tsx</strong> in the <strong class="source-inline">posts</strong> folder with the following <span class="No-Break">import statement:</span><pre class="source-code">
import { PostData } from './types';</pre></li>
				<li>Next, start to implement the component <span class="No-Break">as follows:</span><pre class="source-code">
type Props = {</pre><pre class="source-code">
  posts: PostData[];</pre><pre class="source-code">
};</pre><pre class="source-code">
export function PostsList({ posts }: Props) {</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The component has a prop called <strong class="source-inline">posts</strong> that will contain the <span class="No-Break">blog posts.</span></p>
			<ol>
				<li value="3">Now, render<a id="_idIndexMarker687"/> the blog<a id="_idIndexMarker688"/> posts in an unordered list, <span class="No-Break">as follows:</span><pre class="source-code">
export function PostsList({ posts }: Props) {</pre><pre class="source-code">
  <strong class="bold">return (</strong></pre><pre class="source-code">
<strong class="bold">    &lt;ul className="list-none"&gt;</strong></pre><pre class="source-code">
<strong class="bold">      {posts.map((post) =&gt; (</strong></pre><pre class="source-code">
<strong class="bold">        &lt;li key={post.id} className="border-b py-4"&gt;</strong></pre><pre class="source-code">
<strong class="bold">          &lt;h3 className="text-slate-900 font-bold"&gt;</strong></pre><pre class="source-code">
<strong class="bold">            {post.title}</strong></pre><pre class="source-code">
<strong class="bold">          &lt;/h3&gt;</strong></pre><pre class="source-code">
<strong class="bold">          &lt;p className=" text-slate-900 "&gt;{post.description}&lt;/p&gt;</strong></pre><pre class="source-code">
<strong class="bold">        &lt;/li&gt;</strong></pre><pre class="source-code">
<strong class="bold">      ))}</strong></pre><pre class="source-code">
<strong class="bold">    &lt;/ul&gt;</strong></pre><pre class="source-code">
<strong class="bold">  );</strong></pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The Tailwind CSS classes add gray lines between the blog posts with <span class="No-Break">bold titles.</span></p>
			<p>That completes the <strong class="source-inline">PostsList</strong> component. Next, we will create a page component that<a id="_idIndexMarker689"/> references <a id="_idIndexMarker690"/>the <span class="No-Break"><strong class="source-inline">PostsList</strong></span><span class="No-Break"> component.</span></p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor231"/>Creating a blog posts page component</h2>
			<p>We will create a<a id="_idIndexMarker691"/> blog posts page <a id="_idIndexMarker692"/>component that gets blog post data using the <strong class="source-inline">getPosts</strong> function and renders it using the <strong class="source-inline">PostsList</strong> component we just created. Carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">PostsPage.tsx</strong> in the <strong class="source-inline">posts</strong> folder components with the following <span class="No-Break">import statements:</span><pre class="source-code">
import { useEffect, useState } from 'react';</pre><pre class="source-code">
import { getPosts } from './getPosts';</pre><pre class="source-code">
import { PostData } from './types';</pre><pre class="source-code">
import { PostsList } from './PostsList';</pre></li>
			</ol>
			<p>We have imported the <strong class="source-inline">getPosts</strong> function, the <strong class="source-inline">PostList</strong> component, and the <strong class="source-inline">PostData</strong> type we created in the last section. We have also imported the <strong class="source-inline">useState</strong> and <strong class="source-inline">useEffect</strong> hooks from React. We will use React state to store the blog posts and use <strong class="source-inline">useEffect</strong> to call <strong class="source-inline">getPosts</strong> when the page component <span class="No-Break">is mounted.</span></p>
			<ol>
				<li value="2">Start the implementation of the page component by defining the state for the blog posts and whether they are <span class="No-Break">being fetched:</span><pre class="source-code">
export function PostsPage() {</pre><pre class="source-code">
  const [isLoading, setIsLoading] = useState(true);</pre><pre class="source-code">
  const [posts, setPosts] = useState&lt;PostData[]&gt;([]);</pre><pre class="source-code">
}</pre></li>
				<li>Next, call the <strong class="source-inline">getPosts</strong> function using the <strong class="source-inline">useEffect</strong> hook <span class="No-Break">as follows:</span><pre class="source-code">
export function PostsPage() {</pre><pre class="source-code">
  …</pre><pre class="source-code">
  <strong class="bold">useEffect(() =&gt; {</strong></pre><pre class="source-code">
<strong class="bold">    let cancel = false;</strong></pre><pre class="source-code">
<strong class="bold">    getPosts().then((data) =&gt; {</strong></pre><pre class="source-code">
<strong class="bold">      if (!cancel) {</strong></pre><pre class="source-code">
<strong class="bold">        setPosts(data);</strong></pre><pre class="source-code">
<strong class="bold">        setIsLoading(false);</strong></pre><pre class="source-code">
<strong class="bold">      }</strong></pre><pre class="source-code">
<strong class="bold">    });</strong></pre><pre class="source-code">
<strong class="bold">    return () =&gt; {</strong></pre><pre class="source-code">
<strong class="bold">      cancel = true;</strong></pre><pre class="source-code">
<strong class="bold">    };</strong></pre><pre class="source-code">
<strong class="bold">  }, []);</strong></pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>We use the older promise syntax when calling <strong class="source-inline">getPosts</strong> because the newer <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> syntax can’t be directly used <span class="No-Break">within </span><span class="No-Break"><strong class="source-inline">useEffect</strong></span><span class="No-Break">.</span></p>
			<p>If the <strong class="source-inline">PostsPage</strong> component<a id="_idIndexMarker693"/> is <a id="_idIndexMarker694"/>unmounted while the call to <strong class="source-inline">getPosts</strong> is still in progress, the setting of the <strong class="source-inline">data</strong> and <strong class="source-inline">isLoading</strong> state variables will result in an error. For this reason, we have used a <strong class="source-inline">cancel</strong> flag to ensure that the component is still mounted when the <strong class="source-inline">data</strong> and <strong class="source-inline">isLoading</strong> state variables <span class="No-Break">are set.</span></p>
			<p>We have also specified an empty array as the effect dependencies so that the effect only runs when the component <span class="No-Break">is mounted.</span></p>
			<ol>
				<li value="4">Add a loading indicator while the data is being fetched after the call <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">useEffect</strong></span><span class="No-Break">:</span><pre class="source-code">
export function PostsPage() {</pre><pre class="source-code">
  ...</pre><pre class="source-code">
  useEffect(...);</pre><pre class="source-code">
  <strong class="bold">if (isLoading) {</strong></pre><pre class="source-code">
<strong class="bold">    return (</strong></pre><pre class="source-code">
<strong class="bold">      &lt;div className="w-96 mx-auto mt-6"&gt;</strong></pre><pre class="source-code">
<strong class="bold">        Loading ...</strong></pre><pre class="source-code">
<strong class="bold">      &lt;/div&gt;</strong></pre><pre class="source-code">
<strong class="bold">    );</strong></pre><pre class="source-code">
<strong class="bold">  }</strong></pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The Tailwind CSS classes position the loading indicator horizontally in the center of the page with a bit of margin <span class="No-Break">above it.</span></p>
			<ol>
				<li value="5">Finally, render a<a id="_idIndexMarker695"/> page<a id="_idIndexMarker696"/> title and the posts list after the conditional <span class="No-Break">loading indicator:</span><pre class="source-code">
export function PostsPage() {</pre><pre class="source-code">
  ...</pre><pre class="source-code">
  if (isLoading) {</pre><pre class="source-code">
    return (</pre><pre class="source-code">
      &lt;div className="w-96 mx-auto mt-6"&gt;</pre><pre class="source-code">
        Loading ...</pre><pre class="source-code">
      &lt;/div&gt;</pre><pre class="source-code">
    );</pre><pre class="source-code">
  }</pre><pre class="source-code">
  <strong class="bold">return (</strong></pre><pre class="source-code">
<strong class="bold">    &lt;div className="w-96 mx-auto mt-6"&gt;</strong></pre><pre class="source-code">
<strong class="bold">      &lt;h2 className="text-xl text-slate-900 font-bold"&gt;Posts&lt;/h2&gt;</strong></pre><pre class="source-code">
<strong class="bold">      &lt;PostsList posts={posts} /&gt;</strong></pre><pre class="source-code">
<strong class="bold">    &lt;/div&gt;</strong></pre><pre class="source-code">
<strong class="bold">  );</strong></pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The Tailwind CSS classes position the list in the center of the page with a bit of margin above. A large <strong class="bold">Posts</strong> title is also rendered above the list in a dark <span class="No-Break">gray color.</span></p>
			<ol>
				<li value="6">Now, open <strong class="source-inline">App.tsx</strong> and replace its contents with the following so that it renders the page<a id="_idIndexMarker697"/> component<a id="_idIndexMarker698"/> we <span class="No-Break">just created:</span><pre class="source-code">
import { PostsPage } from './posts/PostsPage';</pre><pre class="source-code">
function App() {</pre><pre class="source-code">
  return &lt;PostsPage /&gt;;</pre><pre class="source-code">
}</pre><pre class="source-code">
export default App;</pre></li>
				<li>Run the app by running <strong class="source-inline">npm start</strong> in a new terminal separate from the one running the REST API. The loading indicator will appear briefly as the data is <span class="No-Break">being fetched:</span></li>
			</ol>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B19051_09_03.jpg" alt="Figure 9.3 – Loading indicator"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Loading indicator</p>
			<p>The blog post list will then appear <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B19051_09_04.jpg" alt="Figure 9.4 – Blog posts list"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Blog posts list</p>
			<p>That completes this version of the <span class="No-Break"><strong class="source-inline">PostsPage</strong></span><span class="No-Break"> component.</span></p>
			<p>Here are the key points we learned in this section on interacting with HTTP <strong class="source-inline">GET</strong> requests in a REST API using <strong class="source-inline">fetch</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">useEffect</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">fetch</strong> will make the actual HTTP request that has the REST API’s URL as <span class="No-Break">a parameter</span></li>
				<li>A type assertion function can be used to strongly type <span class="No-Break">response data</span></li>
				<li><strong class="source-inline">useEffect</strong> can trigger the <strong class="source-inline">fetch</strong> call when the component that holds the data in state <span class="No-Break">is mounted</span></li>
				<li>A flag can be used inside <strong class="source-inline">useEffect</strong> to check that the component hasn’t been unmounted during the HTTP request before the data state <span class="No-Break">is set</span></li>
			</ul>
			<p>Still keeping the <a id="_idIndexMarker699"/>app and REST API<a id="_idIndexMarker700"/> running, in the next section, we will learn how to post data to a REST API <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">fetch</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor232"/>Posting data with fetch</h1>
			<p>In this section, we <a id="_idIndexMarker701"/>will create a form that submits a new blog post to our REST API. We will create a function that uses <strong class="source-inline">fetch</strong> to post to the REST API. That function will be called in the form’s <span class="No-Break">submit handler.</span></p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor233"/>Creating new blog posts using fetch</h2>
			<p>We will start by<a id="_idIndexMarker702"/> creating the function that sends a new blog post to the REST API. This will use the browser’s <strong class="source-inline">fetch</strong> function, but this time, using an HTTP <strong class="source-inline">POST</strong> request. Carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">We will start by opening <strong class="source-inline">types.ts</strong> in the <strong class="source-inline">posts</strong> folder and adding the following <span class="No-Break">two types:</span><pre class="source-code">
export type NewPostData = {</pre><pre class="source-code">
  title: string;</pre><pre class="source-code">
  description: string;</pre><pre class="source-code">
};</pre><pre class="source-code">
export type SavedPostData = {</pre><pre class="source-code">
  id: number;</pre><pre class="source-code">
};</pre></li>
			</ol>
			<p>The first type represents a new blog post, and the second type represents the data from the API when the blog post is <span class="No-Break">successfully saved.</span></p>
			<ol>
				<li value="2">Create a new file called <strong class="source-inline">savePost.ts</strong> in the <strong class="source-inline">posts</strong> folder and add the following <span class="No-Break">import statement:</span><pre class="source-code">
import { NewPostData, SavedPostData } from './types';</pre></li>
			</ol>
			<p>We have also imported the types we <span class="No-Break">just created.</span></p>
			<ol>
				<li value="3">Start to implement the <strong class="source-inline">savePost</strong> function <span class="No-Break">as follows:</span><pre class="source-code">
export async function savePost(</pre><pre class="source-code">
  newPostData: NewPostData</pre><pre class="source-code">
) {</pre><pre class="source-code">
  const response = await fetch(</pre><pre class="source-code">
    process.env.REACT_APP_API_URL!,</pre><pre class="source-code">
    {</pre><pre class="source-code">
      method: 'POST',</pre><pre class="source-code">
      body: JSON.stringify(newPostData),</pre><pre class="source-code">
      headers: {</pre><pre class="source-code">
        'Content-Type': 'application/json',</pre><pre class="source-code">
      },</pre><pre class="source-code">
    }</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The <strong class="source-inline">savePost</strong> function has a parameter, <strong class="source-inline">newPostData</strong>, containing the title and description for the new blog post, and sends it to the REST API using <strong class="source-inline">fetch</strong>. A second argument has been specified in the <strong class="source-inline">fetch</strong> call to specify that an HTTP <strong class="source-inline">POST</strong> request should be used and that the new blog post data should be included in the<a id="_idIndexMarker703"/> request body. The request body has also been declared as being in <span class="No-Break">JSON format.</span></p>
			<ol>
				<li value="4">Next, strongly type the response body <span class="No-Break">as follows:</span><pre class="source-code">
export async function savePost(newPostData: NewPostData) {</pre><pre class="source-code">
  const response = await fetch( ... );</pre><pre class="source-code">
<strong class="bold">  const body = (await response.json()) as unknown;</strong></pre><pre class="source-code">
<strong class="bold">  assertIsSavedPost(body);</strong></pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>We set the response body as having the <strong class="source-inline">unknown</strong> type and then use a type assertion function to give it a specific type. This will raise a compile error until we implement <strong class="source-inline">assertIsSavedPost</strong> in <span class="No-Break"><em class="italic">step 6</em></span><span class="No-Break">.</span></p>
			<ol>
				<li value="5">Finish the implementation of <strong class="source-inline">savePost</strong> by merging the blog post ID from the response with the blog post title and description supplied to <span class="No-Break">the function:</span><pre class="source-code">
export async function savePost(newPostData: NewPostData) {</pre><pre class="source-code">
  ...</pre><pre class="source-code">
<strong class="bold">  return { ...newPostData, ...body };</strong></pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>So, the object returned from the function will be a new blog post with the ID from the <span class="No-Break">REST API.</span></p>
			<ol>
				<li value="6">The last step is to implement the type <span class="No-Break">assertion function:</span><pre class="source-code">
function assertIsSavedPost(</pre><pre class="source-code">
  post: any</pre><pre class="source-code">
): asserts post is SavedPostData {</pre><pre class="source-code">
  if (!('id' in post)) {</pre><pre class="source-code">
    throw new Error("post doesn't contain id");</pre><pre class="source-code">
  }</pre><pre class="source-code">
  if (typeof post.id !== 'number') {</pre><pre class="source-code">
    throw new Error('id is not a number');</pre><pre class="source-code">
  }</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The function checks whether the response data contains a numeric <strong class="source-inline">id</strong> property, and if it does, it asserts that the data is of the <span class="No-Break"><strong class="source-inline">SavedPostData</strong></span><span class="No-Break"> type.</span></p>
			<p>That completes the<a id="_idIndexMarker704"/> implementation of the <strong class="source-inline">savePost</strong> function. Next, we will add a form component that allows the user to enter new <span class="No-Break">blog posts.</span></p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor234"/>Creating a blog post form component</h2>
			<p>We will create<a id="_idIndexMarker705"/> a component that contains <a id="_idIndexMarker706"/>a form that captures a new blog post. When the form is submitted, it will call the <strong class="source-inline">savePost</strong> function we <span class="No-Break">just created.</span></p>
			<p>We will use React Hook Form to implement the form along with a <strong class="source-inline">ValidationError</strong> component. We covered React Hook Form and the <strong class="source-inline">ValidationError</strong> component in detail in <a href="B19051_07.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, so the implementation steps won’t be covered in <span class="No-Break">much detail.</span></p>
			<p>Carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">We will start by creating a <strong class="source-inline">ValidationError</strong> component that will render form validation errors. Create a file called <strong class="source-inline">ValidationError.tsx</strong> in the <strong class="source-inline">posts</strong> folder<a id="_idIndexMarker707"/> with the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker708"/></span><span class="No-Break">content:</span><pre class="source-code">
import { FieldError } from 'react-hook-form';</pre><pre class="source-code">
type Props = {</pre><pre class="source-code">
  fieldError: FieldError | undefined,</pre><pre class="source-code">
};</pre><pre class="source-code">
export function ValidationError({ fieldError }: Props) {</pre><pre class="source-code">
  if (!fieldError) {</pre><pre class="source-code">
    return null;</pre><pre class="source-code">
  }</pre><pre class="source-code">
  return (</pre><pre class="source-code">
    &lt;div role="alert" className="text-red-500 text-xs       mt-1"&gt;</pre><pre class="source-code">
      {fieldError.message}</pre><pre class="source-code">
    &lt;/div&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre></li>
				<li>Create a new file in the <strong class="source-inline">posts</strong> folder called <strong class="source-inline">NewPostForm.tsx</strong>. This will contain a form to capture the title and description for a new blog post. Add the following import statements to <span class="No-Break">the file:</span><pre class="source-code">
import { FieldError, useForm } from 'react-hook-form';</pre><pre class="source-code">
import { ValidationError } from './ValidationError';</pre><pre class="source-code">
import { NewPostData } from './types';</pre></li>
				<li>Start to implement the form component <span class="No-Break">as follows:</span><pre class="source-code">
type Props = {</pre><pre class="source-code">
  onSave: (newPost: NewPostData) =&gt; void;</pre><pre class="source-code">
};</pre><pre class="source-code">
export function NewPostForm({ onSave }: Props) {</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The component has a prop for saving a new blog post so that the interaction with the REST API can be handled outside of this <span class="No-Break">form component.</span></p>
			<ol>
				<li value="4">Now, destructure <a id="_idIndexMarker709"/>the <strong class="source-inline">register</strong> and <strong class="source-inline">handleSubmit</strong> functions<a id="_idIndexMarker710"/> and useful state variables from React Hook Form’s <span class="No-Break"><strong class="source-inline">useForm</strong></span><span class="No-Break"> hook:</span><pre class="source-code">
type Props = {</pre><pre class="source-code">
  onSave: (newPost: NewPostData) =&gt; void;</pre><pre class="source-code">
};</pre><pre class="source-code">
export function NewPostForm({ onSave }: Props) {</pre><pre class="source-code">
<strong class="bold">  const {</strong></pre><pre class="source-code">
<strong class="bold">    register,</strong></pre><pre class="source-code">
<strong class="bold">    handleSubmit,</strong></pre><pre class="source-code">
<strong class="bold">    formState: { errors, isSubmitting, isSubmitSuccessful },</strong></pre><pre class="source-code">
<strong class="bold">  } = useForm&lt;NewPostData&gt;();</strong></pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>We pass the type for the new post data into the <strong class="source-inline">useForm</strong> hook so it knows the shape of the data <span class="No-Break">to capture.</span></p>
			<ol>
				<li value="5">Create a variable for the field container style and a function for the <span class="No-Break">editor style:</span><pre class="source-code">
export function NewPostForm({ onSave }: Props) {</pre><pre class="source-code">
  ...</pre><pre class="source-code">
  <strong class="bold">const fieldStyle = 'flex flex-col mb-2';</strong></pre><pre class="source-code">
<strong class="bold">  function getEditorStyle(</strong></pre><pre class="source-code">
<strong class="bold">    fieldError: FieldError | undefined</strong></pre><pre class="source-code">
<strong class="bold">  ) {</strong></pre><pre class="source-code">
<strong class="bold">    return fieldError ? 'border-red-500' : '';</strong></pre><pre class="source-code">
<strong class="bold">  }</strong></pre><pre class="source-code">
}</pre></li>
				<li>Render <strong class="source-inline">title</strong> and <strong class="source-inline">description</strong> fields <a id="_idIndexMarker711"/>in a <strong class="source-inline">form</strong> element<a id="_idIndexMarker712"/> <span class="No-Break">as follows:</span><pre class="source-code">
export function NewPostForm({ onSave }: Props) {</pre><pre class="source-code">
  ...</pre><pre class="source-code">
<strong class="bold">  return (</strong></pre><pre class="source-code">
<strong class="bold">    &lt;form</strong></pre><pre class="source-code">
<strong class="bold">      noValidate</strong></pre><pre class="source-code">
<strong class="bold">      className="border-b py-4"</strong></pre><pre class="source-code">
<strong class="bold">      onSubmit={handleSubmit(onSave)}</strong></pre><pre class="source-code">
<strong class="bold">    &gt;</strong></pre><pre class="source-code">
<strong class="bold">      &lt;div className={fieldStyle}&gt;</strong></pre><pre class="source-code">
<strong class="bold">        &lt;label htmlFor="title"&gt;Title&lt;/label&gt;</strong></pre><pre class="source-code">
<strong class="bold">        &lt;input</strong></pre><pre class="source-code">
<strong class="bold">          type="text"</strong></pre><pre class="source-code">
<strong class="bold">          id="title"</strong></pre><pre class="source-code">
<strong class="bold">          {...register('title', {</strong></pre><pre class="source-code">
<strong class="bold">            required: 'You must enter a title',</strong></pre><pre class="source-code">
<strong class="bold">          })}</strong></pre><pre class="source-code">
<strong class="bold">          className={getEditorStyle(errors.title)}</strong></pre><pre class="source-code">
<strong class="bold">        /&gt;</strong></pre><pre class="source-code">
<strong class="bold">        &lt;ValidationError fieldError={errors.title} /&gt;</strong></pre><pre class="source-code">
<strong class="bold">      &lt;/div&gt;</strong></pre><pre class="source-code">
<strong class="bold">      &lt;div className={fieldStyle}&gt;</strong></pre><pre class="source-code">
<strong class="bold">        &lt;label htmlFor="description"&gt;Description&lt;/label&gt;</strong></pre><pre class="source-code">
<strong class="bold">        &lt;textarea</strong></pre><pre class="source-code">
<strong class="bold">          id="description"</strong></pre><pre class="source-code">
<strong class="bold">          {...register('description', {</strong></pre><pre class="source-code">
<strong class="bold">            required: 'You must enter the description',</strong></pre><pre class="source-code">
<strong class="bold">          })}</strong></pre><pre class="source-code">
<strong class="bold">          className={getEditorStyle(errors.description)}</strong></pre><pre class="source-code">
<strong class="bold">        /&gt;</strong></pre><pre class="source-code">
<strong class="bold">        &lt;ValidationError fieldError={errors.description}           /&gt;</strong></pre><pre class="source-code">
<strong class="bold">      &lt;/div&gt;</strong></pre><pre class="source-code">
<strong class="bold">    &lt;/form&gt;</strong></pre><pre class="source-code">
<strong class="bold">  );</strong></pre><pre class="source-code">
}</pre></li>
				<li>Lastly, render a <strong class="source-inline">Save</strong> button <a id="_idIndexMarker713"/>and the<a id="_idIndexMarker714"/> <span class="No-Break">success message:</span><pre class="source-code">
&lt;form</pre><pre class="source-code">
  noValidate</pre><pre class="source-code">
  className="border-b py-4"</pre><pre class="source-code">
  onSubmit={handleSubmit(onSave)}</pre><pre class="source-code">
&gt;</pre><pre class="source-code">
  &lt;div className={fieldStyle}&gt; ... &lt;/div&gt;</pre><pre class="source-code">
  &lt;div className={fieldStyle}&gt; ... &lt;/div&gt;</pre><pre class="source-code">
  <strong class="bold">&lt;div className={fieldStyle}&gt;</strong></pre><pre class="source-code">
<strong class="bold">    &lt;button</strong></pre><pre class="source-code">
<strong class="bold">      type="submit"</strong></pre><pre class="source-code">
<strong class="bold">      disabled={isSubmitting}</strong></pre><pre class="source-code">
<strong class="bold">      className="mt-2 h-10 px-6 font-semibold bg-black         text-white"</strong></pre><pre class="source-code">
<strong class="bold">    &gt;</strong></pre><pre class="source-code">
<strong class="bold">      Save</strong></pre><pre class="source-code">
<strong class="bold">   &lt;/button&gt;</strong></pre><pre class="source-code">
<strong class="bold">    {isSubmitSuccessful &amp;&amp; (</strong></pre><pre class="source-code">
<strong class="bold">      &lt;div</strong></pre><pre class="source-code">
<strong class="bold">        role="alert"</strong></pre><pre class="source-code">
<strong class="bold">        className="text-green-500 text-xs mt-1"</strong></pre><pre class="source-code">
<strong class="bold">      &gt;</strong></pre><pre class="source-code">
<strong class="bold">        The post was successfully saved</strong></pre><pre class="source-code">
<strong class="bold">     &lt;/div&gt;</strong></pre><pre class="source-code">
<strong class="bold">    )}</strong></pre><pre class="source-code">
<strong class="bold">  &lt;/div&gt;</strong></pre><pre class="source-code">
&lt;/form&gt;</pre></li>
			</ol>
			<p>That completes<a id="_idIndexMarker715"/> the implementation<a id="_idIndexMarker716"/> of the <span class="No-Break"><strong class="source-inline">NewPostForm</strong></span><span class="No-Break"> component.</span></p>
			<ol>
				<li value="8">Now open <strong class="source-inline">PostPage.tsx</strong> and import the <strong class="source-inline">NewPostForm</strong> component and the <strong class="source-inline">savePost</strong> function we created earlier. Also, import the <span class="No-Break"><strong class="source-inline">NewPostData</strong></span><span class="No-Break"> type:</span><pre class="source-code">
import { useEffect, useState } from 'react';</pre><pre class="source-code">
import { getPosts } from './getPosts';</pre><pre class="source-code">
import { PostData<strong class="bold">, NewPostData</strong> } from './types';</pre><pre class="source-code">
import { PostsList } from './PostsList';</pre><pre class="source-code">
<strong class="bold">import { savePost } from './savePost';</strong></pre><pre class="source-code">
<strong class="bold">import { NewPostForm } from './NewPostForm';</strong></pre></li>
				<li>In the <strong class="source-inline">PostPage</strong> JSX, add the <strong class="source-inline">NewPostForm</strong> form above <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">PostsList</strong></span><span class="No-Break">:</span><pre class="source-code">
&lt;div className="w-96 mx-auto mt-6"&gt;</pre><pre class="source-code">
  &lt;h2 className="text-xl text-slate-900 font-    bold"&gt;Posts&lt;/h2&gt;</pre><pre class="source-code">
  <strong class="bold">&lt;NewPostForm onSave={handleSave} /&gt;</strong></pre><pre class="source-code">
  &lt;PostsList posts={posts} /&gt;</pre><pre class="source-code">
&lt;/div&gt;;</pre></li>
				<li>Add the save <a id="_idIndexMarker717"/>handler function just below the effect that gets <span class="No-Break">blog posts:</span><pre class="source-code">
useEffect(() =&gt; {</pre><pre class="source-code">
  ...</pre><pre class="source-code">
}, []);</pre><pre class="source-code">
<strong class="bold">async function handleSave(newPostData: NewPostData) {</strong></pre><pre class="source-code">
<strong class="bold">  const newPost = await savePost(newPostData);</strong></pre><pre class="source-code">
<strong class="bold">  setPosts([newPost, ...posts]);</strong></pre><pre class="source-code">
<strong class="bold">}</strong></pre></li>
				<li>The hander calls <strong class="source-inline">savePost</strong> with the data from the form. After the post has been saved, it is added to the start of the <span class="No-Break"><strong class="source-inline">posts</strong></span><span class="No-Break"> array.</span></li>
				<li>In the running app, the new blog post form will appear above the blog post list, <span class="No-Break">as follows:</span></li>
			</ol>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/B19051_09_05.jpg" alt="Figure 9.5 – New blog post form above the posts list"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – New blog post form above the posts list</p>
			<ol>
				<li value="13">Fill in <a id="_idIndexMarker718"/>the form with a new blog <a id="_idIndexMarker719"/>post and press the <strong class="bold">Save</strong> button. The new post should appear at the top of the list after a couple <span class="No-Break">of seconds.</span></li>
			</ol>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B19051_09_06.jpg" alt="Figure 9.6 – New blog post added to posts list"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – New blog post added to posts list</p>
			<p>That completes the <a id="_idIndexMarker720"/>implementation<a id="_idIndexMarker721"/> of the form and its integration into the blog <span class="No-Break">posts page.</span></p>
			<p>Here are a couple of key points we learned in this section on posting data <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">fetch</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>The second parameter in the <strong class="source-inline">fetch</strong> function allows the HTTP method to be specified. In this section, we used this parameter to make an HTTP <span class="No-Break"><strong class="source-inline">POST</strong></span><span class="No-Break"> request.</span></li>
				<li>The second parameter in <strong class="source-inline">fetch</strong> also allows the request body to <span class="No-Break">be supplied.</span></li>
			</ul>
			<p>Once again, keeping the app and REST API running, in the next section, we will use React Router’s data-fetching capabilities to simplify our <span class="No-Break">data-fetching code.</span></p>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor235"/>Using React Router</h1>
			<p>In this section, we <a id="_idIndexMarker722"/>will learn about how React Router can integrate with the data-fetching process. We will use this knowledge to simplify the code that fetches blog posts in <span class="No-Break">our app.</span></p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor236"/>Understanding React Router data loading</h2>
			<p>React Router <a id="_idIndexMarker723"/>data loading is similar to React Router forms, which we learned about in <a href="B19051_07.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>. Instead of defining an action that handles form submission, we <a id="_idIndexMarker724"/>define a <strong class="bold">loader</strong> that handles data loading. The following code snippet defines a loader on a <span class="No-Break"><strong class="source-inline">some-page</strong></span><span class="No-Break"> route:</span></p>
			<pre class="source-code">
const router = createBrowserRouter([
  ...,
  {
    path: '/some-page',
    element: &lt;SomePage /&gt;,
    <strong class="bold">loader: async () =&gt; {</strong>
<strong class="bold">      const response = fetch('https://somewhere');</strong>
<strong class="bold">      return await response.json();</strong>
<strong class="bold">    }</strong>
  },
  ...
]);</pre>
			<p>React Router calls the loader to get the data before it renders the component defined on the route. The data is then available in the component via a <span class="No-Break"><strong class="source-inline">useLoaderData</strong></span><span class="No-Break"> hook:</span></p>
			<pre class="source-code">
export function SomePage() {
  <strong class="bold">const data = useLoaderData();</strong>
  ...
}</pre>
			<p>This approach is efficient as the route component is only rendered once because the data is available on the <span class="No-Break">first render.</span></p>
			<p>For more information<a id="_idIndexMarker725"/> on React Router loaders, see the following link: <a href="https://reactrouter.com/en/main/route/loader">https://reactrouter.com/en/main/route/loader</a>. For more information on the <strong class="source-inline">useLoaderData</strong> hook, see the following <span class="No-Break">link: </span><a href="https://reactrouter.com/en/main/hooks/use-loader-data"><span class="No-Break">https://reactrouter.com/en/main/hooks/use-loader-data</span></a><span class="No-Break">.</span></p>
			<p>Now that we are <a id="_idIndexMarker726"/>starting to understand data loading in React Router, we will use this in <span class="No-Break">our app.</span></p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor237"/>Using React Router for data loading</h2>
			<p>Carry out the <a id="_idIndexMarker727"/>following steps to use a React Router data loader in <span class="No-Break">our app:</span></p>
			<ol>
				<li value="1">Open <strong class="source-inline">App.tsx</strong> and add the following <span class="No-Break">import statement:</span><pre class="source-code">
import {</pre><pre class="source-code">
  createBrowserRouter,</pre><pre class="source-code">
  RouterProvider</pre><pre class="source-code">
} from 'react-router-dom';</pre></li>
				<li>Also, import the <span class="No-Break"><strong class="source-inline">getPosts</strong></span><span class="No-Break"> function:</span><pre class="source-code">
import { getPosts } from './posts/getPosts';</pre></li>
			</ol>
			<p><strong class="source-inline">getPosts</strong> will be the <span class="No-Break">loader function.</span></p>
			<ol>
				<li value="3">Add the following router definition above the <span class="No-Break"><strong class="source-inline">App</strong></span><span class="No-Break"> component:</span><pre class="source-code">
const router = createBrowserRouter([</pre><pre class="source-code">
  {</pre><pre class="source-code">
    path: "/",</pre><pre class="source-code">
    element: &lt;PostsPage /&gt;,</pre><pre class="source-code">
    loader: getPosts</pre><pre class="source-code">
  }</pre><pre class="source-code">
]);</pre></li>
				<li>In the <strong class="source-inline">App</strong> component, replace <strong class="source-inline">PostsPage</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">RouterProvider</strong></span><span class="No-Break">:</span><pre class="source-code">
function App() {</pre><pre class="source-code">
  return <strong class="bold">&lt;RouterProvider router={router} /&gt;</strong>;</pre><pre class="source-code">
}</pre></li>
				<li>Open <strong class="source-inline">PostsPage.tsx</strong> and remove the React import statement, as this is no longer required in <span class="No-Break">this component.</span></li>
				<li>Also, add <strong class="source-inline">assertIsPosts</strong> to the <strong class="source-inline">getPosts</strong> import statement and <span class="No-Break">remove </span><span class="No-Break"><strong class="source-inline">getPosts</strong></span><span class="No-Break">:</span><pre class="source-code">
import { <strong class="bold">assertIsPosts</strong> } from './getPosts';</pre></li>
			</ol>
			<p>We will eventually need <strong class="source-inline">assertIsPosts</strong> to type <span class="No-Break">the data.</span></p>
			<ol>
				<li value="7">Still in <strong class="source-inline">PostsPage.tsx</strong>, add the following import statement for a hook in React Router<a id="_idIndexMarker728"/> that allows us to access the <span class="No-Break">loader data:</span><pre class="source-code">
import { useLoaderData } from 'react-router-dom';</pre></li>
				<li>Inside the <strong class="source-inline">PostsPage</strong> component, remove the <strong class="source-inline">isLoading</strong> and <strong class="source-inline">posts</strong> state definitions. These won’t be needed because we will get the data from React Router without having to do <span class="No-Break">any waiting.</span></li>
				<li>Remove the call to <strong class="source-inline">useEffect</strong> that currently gets <span class="No-Break">the data.</span></li>
				<li>Remove the second line of the <strong class="source-inline">handleSave</strong> function that sets the <strong class="source-inline">posts</strong> state. <strong class="source-inline">handleSave</strong> should now read <span class="No-Break">as follows:</span><pre class="source-code">
async function handleSave(newPostData: NewPostData) {</pre><pre class="source-code">
  await savePost(newPostData);</pre><pre class="source-code">
}</pre></li>
				<li>Remove the loading indicator <span class="No-Break">as well.</span></li>
				<li>Now at the top of the <strong class="source-inline">PostsPage</strong> component, make a call to <strong class="source-inline">useLoaderData</strong> and assign the result to a <span class="No-Break"><strong class="source-inline">posts</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
export function PostsPage() {</pre><pre class="source-code">
  <strong class="bold">const posts = useLoaderData();</strong></pre><pre class="source-code">
  …</pre><pre class="source-code">
}</pre></li>
				<li>Unfortunately, <strong class="source-inline">posts</strong> is of the <strong class="source-inline">unknown</strong> type, so there is a type error where it is passed to the <strong class="source-inline">PostsLists</strong> component. Use the <strong class="source-inline">assertsIsPosts</strong> function to type the data <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">PostData[]</strong></span><span class="No-Break">:</span><pre class="source-code">
const posts = useLoaderData();</pre><pre class="source-code">
<strong class="bold">assertIsPosts(posts);</strong></pre></li>
			</ol>
			<p>The type errors are <span class="No-Break">now resolved.</span></p>
			<p>Note that <strong class="source-inline">PostData</strong> from the <strong class="source-inline">types</strong> import statement is unused. Leave it intact because we will use this again in the <span class="No-Break">next section.</span></p>
			<ol>
				<li value="14">The running app should look and behave similarly to how it previously did. One thing you may notice is that when a new blog post is added using the form, it doesn’t appear in the list – you have to manually refresh the page for it to appear. This will be resolved when we use React Query later in <span class="No-Break">this chapter.</span></li>
			</ol>
			<p>Notice how much code we just removed – this indicates that the code is much simpler now. Another <a id="_idIndexMarker729"/>benefit of using React Router to load the data is that <strong class="source-inline">PostsPage</strong> isn’t re-rendered after the data is fetched – the data is fetched before <strong class="source-inline">PostsPage</strong> <span class="No-Break">is rendered.</span></p>
			<p>Next, we will improve the user experience of the <span class="No-Break">data-fetching process.</span></p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor238"/>Deferred React Router data fetching</h2>
			<p>If the data-fetching <a id="_idIndexMarker730"/>process is slow, there will be a noticeable delay before a component is rendered by React Router. Fortunately, there is a solution to this using React Router’s <strong class="source-inline">defer</strong> function and <strong class="source-inline">Await</strong> component, along with React’s <strong class="source-inline">Suspense</strong> component. Carry out the following steps to add these to <span class="No-Break">our app:</span></p>
			<ol>
				<li value="1">Start by opening <strong class="source-inline">App.tsx</strong> and add the <strong class="source-inline">defer</strong> function to the React Router <span class="No-Break">import statement:</span><pre class="source-code">
import {</pre><pre class="source-code">
  createBrowserRouter,</pre><pre class="source-code">
  RouterProvider<strong class="bold">,</strong></pre><pre class="source-code">
<strong class="bold">  defer</strong></pre><pre class="source-code">
} from 'react-router-dom';</pre></li>
				<li>Update the <strong class="source-inline">loader</strong> function as follows in the <span class="No-Break">route definition:</span><pre class="source-code">
const router = createBrowserRouter([</pre><pre class="source-code">
  {</pre><pre class="source-code">
    path: "/",</pre><pre class="source-code">
    element: ...,</pre><pre class="source-code">
    loader:<strong class="bold"> async () =&gt; defer({ posts: getPosts() })</strong></pre><pre class="source-code">
  }</pre><pre class="source-code">
]);</pre></li>
			</ol>
			<p>React Router’s <strong class="source-inline">defer</strong> function<a id="_idIndexMarker731"/> takes in an object of promised data. The property name in the object is a unique key for the data, which is <strong class="source-inline">posts</strong> in our case. The value is the function that fetches the data, which is <strong class="source-inline">getPosts</strong> in <span class="No-Break">our case.</span></p>
			<p>Notice that we don’t await <strong class="source-inline">getPosts</strong> because we want the loader to complete and <strong class="source-inline">PostsPage</strong> to <span class="No-Break">immediately render.</span></p>
			<ol>
				<li value="3">Open <strong class="source-inline">PostsPage.tsx</strong> and add an import statement for React’s <span class="No-Break"><strong class="source-inline">Suspense</strong></span><span class="No-Break"> component:</span><pre class="source-code">
import { Suspense } from 'react';</pre></li>
				<li>Add the <strong class="source-inline">Await</strong> component to the React Router <span class="No-Break">import statement:</span><pre class="source-code">
import { useLoaderData<strong class="bold">, Await</strong> } from 'react-router-dom';</pre></li>
				<li>In the component, update the call to <strong class="source-inline">useLoaderData</strong> to assign the result to a <strong class="source-inline">data</strong> variable instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">posts</strong></span><span class="No-Break">:</span><pre class="source-code">
const <strong class="bold">data</strong> = useLoaderData();</pre></li>
			</ol>
			<p>The shape of the loader data is a little different now – it will be an object containing a <strong class="source-inline">posts</strong> property containing the blog posts. The blog posts also won’t immediately be there as they previously were – the <strong class="source-inline">data.posts</strong> property will contain a promise for the blog <span class="No-Break">posts instead.</span></p>
			<ol>
				<li value="6">Also, remove the call to <strong class="source-inline">assertIsPosts</strong> – we will use this later in <span class="No-Break"><em class="italic">step 9</em></span><span class="No-Break">.</span></li>
				<li>The <strong class="source-inline">data</strong> variable is of the <strong class="source-inline">unknown</strong> type, so add a type assertion function beneath the<a id="_idIndexMarker732"/> component that can be used to strongly <span class="No-Break">type it:</span><pre class="source-code">
type Data = {</pre><pre class="source-code">
  posts: PostData[];</pre><pre class="source-code">
};</pre><pre class="source-code">
export function assertIsData(</pre><pre class="source-code">
  data: unknown</pre><pre class="source-code">
): asserts data is Data {</pre><pre class="source-code">
  if (typeof data !== 'object') {</pre><pre class="source-code">
    throw new Error("Data isn't an object");</pre><pre class="source-code">
  }</pre><pre class="source-code">
  if (data === null) {</pre><pre class="source-code">
    throw new Error('Data is null');</pre><pre class="source-code">
  }</pre><pre class="source-code">
  if (!('posts' in data)) {</pre><pre class="source-code">
    throw new Error("data doesn't contain posts");</pre><pre class="source-code">
  }</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The type assertion function checks that the <strong class="source-inline">data</strong> parameter is an object containing a <span class="No-Break"><strong class="source-inline">posts</strong></span><span class="No-Break"> property.</span></p>
			<ol>
				<li value="8">We can now use the assertion function to type the <strong class="source-inline">data</strong> variable in <span class="No-Break">the component:</span><pre class="source-code">
const data = useLoaderData();</pre><pre class="source-code">
<strong class="bold">assertIsData(data);</strong></pre></li>
				<li>In the JSX, wrap <strong class="source-inline">Suspense</strong> and <strong class="source-inline">Await</strong> around <strong class="source-inline">PostsList</strong> <span class="No-Break">as </span><span class="No-Break"><a id="_idIndexMarker733"/></span><span class="No-Break">follows:</span><pre class="source-code">
<strong class="bold">&lt;Suspense fallback={&lt;div&gt;Fetching...&lt;/div&gt;}&gt;</strong></pre><pre class="source-code">
<strong class="bold">  &lt;Await resolve={data.posts}&gt;</strong></pre><pre class="source-code">
<strong class="bold">    {(posts) =&gt; {</strong></pre><pre class="source-code">
<strong class="bold">      assertIsPosts(posts);</strong></pre><pre class="source-code">
<strong class="bold">      return</strong> &lt;PostsList posts={posts} /&gt;<strong class="bold">;</strong></pre><pre class="source-code">
<strong class="bold">    }}</strong></pre><pre class="source-code">
<strong class="bold">  &lt;/Await&gt;</strong></pre><pre class="source-code">
<strong class="bold">&lt;/Suspense&gt;</strong></pre></li>
			</ol>
			<p><strong class="source-inline">Suspense</strong> and <strong class="source-inline">Await</strong> work together to only render <strong class="source-inline">PostsLists</strong> when the data has been fetched. We use <strong class="source-inline">Suspense</strong> to render a <strong class="bold">Fetching…</strong> message while the data is being fetched. We also use <strong class="source-inline">assertIsPosts</strong> to ensure that <strong class="source-inline">posts</strong> is <span class="No-Break">typed correctly.</span></p>
			<ol>
				<li value="10">In the running app, you will now notice the <strong class="bold">Fetching…</strong> message when the <span class="No-Break">page loads:</span></li>
			</ol>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B19051_09_07.jpg" alt="Figure 9.7 – Fetching message during data fetching"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Fetching message during data fetching</p>
			<ol>
				<li value="11">Stop the app from running by pressing <em class="italic">Ctrl</em> +<em class="italic"> C</em> in the terminal that is running the app but keep the <span class="No-Break">API running.</span></li>
			</ol>
			<p>The great thing about this solution is that a re-render still doesn’t occur when <strong class="source-inline">PostsPage</strong> is rendered because of the use of <strong class="source-inline">Suspense</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Await</strong></span><span class="No-Break">.</span></p>
			<p>We will now quickly<a id="_idIndexMarker734"/> recap what we have learned with React Router’s <span class="No-Break">data-fetching capabilities:</span></p>
			<ul>
				<li>React Router’s <strong class="source-inline">loader</strong> allows us to efficiently load fetched data into a <span class="No-Break">route component</span></li>
				<li>React Router’s <strong class="source-inline">defer</strong> allows the route component not to be blocked from rendering the component while data is <span class="No-Break">being fetched</span></li>
				<li>React Router’s <strong class="source-inline">useLoaderData</strong> hook allows a component to access a route’s <span class="No-Break">loader data</span></li>
				<li>React’s <strong class="source-inline">Suspense</strong> and React Router’s <strong class="source-inline">Await</strong> allow a component to render while data is still <span class="No-Break">being fetched</span></li>
			</ul>
			<p>For more information on deferred data in React Router, see the following <span class="No-Break">link: </span><a href="https://reactrouter.com/en/main/guides/deferred"><span class="No-Break">https://reactrouter.com/en/main/guides/deferred</span></a><span class="No-Break">.</span></p>
			<p>In the next section, we will use another popular library for managing server data to further improve the <span class="No-Break">user experience.</span></p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor239"/>Using React Query</h1>
			<p>React Query is a popular <a id="_idIndexMarker735"/>library for interacting with REST APIs. The key thing it does is manage the state surrounding REST API calls. One thing that it does that React Router doesn’t is that it maintains a cache of the fetched data, which improves the perceived performance of <span class="No-Break">an app.</span></p>
			<p>In this section, we will refactor the app to use React Query rather than React Router’s loader capability. We will then refactor the app again to use both React Query and React Router’s loader to get the best of both <span class="No-Break">these worlds.</span></p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor240"/>Installing React Query</h2>
			<p>Our first job is to<a id="_idIndexMarker736"/> install React Query, which we can do by running the following command in <span class="No-Break">a terminal:</span></p>
			<pre class="source-code">
npm i @tanstack/react-query</pre>
			<p>This library includes TypeScript types, so no additional package is required to <span class="No-Break">be installed.</span></p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor241"/>Adding the React Query provider</h2>
			<p>React Query requires a <a id="_idIndexMarker737"/>provider component in the component tree above the components that need access to the data it manages. Eventually, React Query will hold the blog post data in our app. Carry out the following steps to add the React Query provider component to the <span class="No-Break"><strong class="source-inline">App</strong></span><span class="No-Break"> component:</span></p>
			<ol>
				<li value="1">Open <strong class="source-inline">App.tsx</strong> and add the following <span class="No-Break">import statement:</span><pre class="source-code">
import {</pre><pre class="source-code">
  QueryClient,</pre><pre class="source-code">
  QueryClientProvider,</pre><pre class="source-code">
} from '@tanstack/react-query';</pre></li>
			</ol>
			<p><strong class="source-inline">QueryClient</strong> provides access to the data. <strong class="source-inline">QueryClientProvider</strong> is the provider component we need to place in the <span class="No-Break">component tree.</span></p>
			<ol>
				<li value="2">Wrap <strong class="source-inline">QueryClientProvider</strong> around <strong class="source-inline">RouterProvider</strong> <span class="No-Break">as follows:</span><pre class="source-code">
<strong class="bold">const queryClient = new QueryClient();</strong></pre><pre class="source-code">
const router = createBrowserRouter( ... );</pre><pre class="source-code">
function App() {</pre><pre class="source-code">
  return (</pre><pre class="source-code">
<strong class="bold">    &lt;QueryClientProvider client={queryClient}&gt;</strong></pre><pre class="source-code">
      &lt;RouterProvider router={router} /&gt;</pre><pre class="source-code">
   <strong class="bold"> &lt;/QueryClientProvider&gt;</strong></pre><pre class="source-code">
  );</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p><strong class="source-inline">QueryClientProvider</strong> requires an instance of <strong class="source-inline">QueryClient</strong> to be passed into it, so we create this instance outside of the <strong class="source-inline">App</strong> component. We place the <strong class="source-inline">queryClient</strong> variable above the router definition because we will eventually use it in the <span class="No-Break">router definition.</span></p>
			<p>The <strong class="source-inline">PostsPage</strong> component<a id="_idIndexMarker738"/> now has access to React Query. Next, we will use React Query <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">PostsPage</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor242"/>Getting data using React Query</h2>
			<p>React Query refers<a id="_idIndexMarker739"/> to a request to fetch data as a <strong class="bold">query</strong> and <a id="_idIndexMarker740"/>has a <strong class="source-inline">useQuery</strong> hook to carry out this. We will use React Query’s <strong class="source-inline">useQuery</strong> hook in the <strong class="source-inline">PostsPage</strong> component to call the <strong class="source-inline">getPosts</strong> function and store the data it returns. This will temporarily replace the use of React Router’s loader. Carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Import <strong class="source-inline">useQuery</strong> from <span class="No-Break">React Query:</span><pre class="source-code">
import { useQuery } from '@tanstack/react-query';</pre></li>
				<li>Add <strong class="source-inline">getPosts</strong> to the <strong class="source-inline">getPosts</strong> <span class="No-Break">import statement:</span><pre class="source-code">
import { assertIsPosts<strong class="bold">, getPosts</strong> } from './getPosts';</pre></li>
			</ol>
			<p>We will eventually use <strong class="source-inline">getPosts</strong> to fetch data and store it within <span class="No-Break">React Query.</span></p>
			<ol>
				<li value="3">In the <strong class="source-inline">PostPage</strong> component, comment out the <span class="No-Break"><strong class="source-inline">data</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
<strong class="bold">// </strong>const data = useLoaderData();</pre><pre class="source-code">
<strong class="bold">// </strong>assertIsData(data);</pre></li>
			</ol>
			<p>We are commenting these lines out rather than removing them because we will use them again in the next section when we use React Router and React <span class="No-Break">Query together.</span></p>
			<ol>
				<li value="4">Now, add<a id="_idIndexMarker741"/> a call to <strong class="source-inline">useQuery</strong> <span class="No-Break">as follows:</span><pre class="source-code">
export function PostsPage() {</pre><pre class="source-code">
  <strong class="bold">const {</strong></pre><pre class="source-code">
<strong class="bold">    isLoading,</strong></pre><pre class="source-code">
<strong class="bold">    isFetching,</strong></pre><pre class="source-code">
<strong class="bold">    data: posts,</strong></pre><pre class="source-code">
<strong class="bold">  } = useQuery(['postsData'], getPosts);</strong></pre><pre class="source-code">
  // const data = useLoaderData();</pre><pre class="source-code">
  // assertIsData(data);</pre><pre class="source-code">
  ...</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The first argument passed to <strong class="source-inline">useQuery</strong> is a unique key for the data. This is because React Query can store many datasets and uses the key to identify each one. The key is an array containing the name given to the data in our case. However, the key array could include things like the ID of a particular record we want to fetch or a page number if we want to only fetch a page <span class="No-Break">of records.</span></p>
			<p>The second argument passed to <strong class="source-inline">useQuery</strong> is the fetching function, which is our existing <span class="No-Break"><strong class="source-inline">getPosts</strong></span><span class="No-Break"> function.</span></p>
			<p>We have destructured the following <span class="No-Break">state variables:</span></p>
			<ul>
				<li><strong class="source-inline">isLoading</strong> – Whether the component is being loaded for the <span class="No-Break">first time.</span></li>
				<li><strong class="source-inline">isFetching</strong> – Whether the fetching function is being called. React Query will refetch data when it thinks it is stale. We will experience refetching later when we play with <span class="No-Break">the app.</span></li>
				<li><strong class="source-inline">data</strong> – The data that has been fetched. We have aliased this <strong class="source-inline">posts</strong> variable to match the previous <strong class="source-inline">posts</strong> state value. Keeping the same name minimizes the changes required in the rest of <span class="No-Break">the component.</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">There are other useful state variables that can be destructured from <strong class="source-inline">useQuery</strong>. An example is <strong class="source-inline">isError</strong>, which indicates whether the <strong class="source-inline">fetch</strong> function errored. See the following link for more <span class="No-Break">information: </span><a href="https://tanstack.com/query/v4/docs/reference/useQuery"><span class="No-Break">https://tanstack.com/query/v4/docs/reference/useQuery</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="5">Add a <a id="_idIndexMarker742"/>loading indicator above the <span class="No-Break">return statement:</span><pre class="source-code">
<strong class="bold">if (isLoading || posts === undefined) {</strong></pre><pre class="source-code">
<strong class="bold">  return (</strong></pre><pre class="source-code">
<strong class="bold">    &lt;div className="w-96 mx-auto mt-6"&gt;</strong></pre><pre class="source-code">
<strong class="bold">      Loading ...</strong></pre><pre class="source-code">
<strong class="bold">    &lt;/div&gt;</strong></pre><pre class="source-code">
<strong class="bold">  );</strong></pre><pre class="source-code">
<strong class="bold">}</strong></pre><pre class="source-code">
return ...</pre></li>
			</ol>
			<p>The check for the <strong class="source-inline">posts</strong> state being <strong class="source-inline">undefined</strong> means that the TypeScript compiler knows that <strong class="source-inline">posts</strong> isn’t <strong class="source-inline">undefined</strong> when referenced in <span class="No-Break">the JSX.</span></p>
			<ol>
				<li value="6">In the JSX, comment out <strong class="source-inline">Suspense</strong> and <span class="No-Break">its children:</span><pre class="source-code">
return (</pre><pre class="source-code">
  &lt;div className="w-96 mx-auto mt-6"&gt;</pre><pre class="source-code">
    &lt;h2 className="text-xl text-slate-900 font-      bold"&gt;Posts&lt;/h2&gt;</pre><pre class="source-code">
    &lt;NewPostForm onSave={mutate} /&gt;</pre><pre class="source-code">
    <strong class="bold">{/*</strong> &lt;Suspense fallback={&lt;div&gt;Fetching ...&lt;/div&gt;}&gt;</pre><pre class="source-code">
        &lt;Await resolve={data.posts}           errorElement={&lt;p&gt;Error!&lt;/p&gt;}&gt;</pre><pre class="source-code">
          {(posts) =&gt; {</pre><pre class="source-code">
            assertIsPosts(posts);</pre><pre class="source-code">
            return &lt;PostsList posts={posts} /&gt;;</pre><pre class="source-code">
          }}</pre><pre class="source-code">
        &lt;/Await&gt;</pre><pre class="source-code">
      &lt;/Suspense&gt; <strong class="bold">*/}</strong></pre><pre class="source-code">
  &lt;/div&gt;</pre><pre class="source-code">
);</pre></li>
			</ol>
			<p>We have commented this block out rather than removing it because we will revert to it in the <a id="_idIndexMarker743"/>next section when we use React Router and React <span class="No-Break">Query together.</span></p>
			<ol>
				<li value="7">When data is being fetched, display a fetching indicator and render the blog posts when the data has <span class="No-Break">been fetched:</span><pre class="source-code">
&lt;div className="w-96 mx-auto mt-6"&gt;</pre><pre class="source-code">
  &lt;h2 className="text-xl text-slate-900 font-    bold"&gt;Posts&lt;/h2&gt;</pre><pre class="source-code">
  &lt;NewPostForm onSave={handleSave} /&gt;</pre><pre class="source-code">
  <strong class="bold">{isFetching ? (</strong></pre><pre class="source-code">
<strong class="bold">    &lt;div&gt;Fetching ...&lt;/div&gt;</strong></pre><pre class="source-code">
<strong class="bold">  ) : (</strong></pre><pre class="source-code">
<strong class="bold">    &lt;PostsList posts={posts} /&gt;</strong></pre><pre class="source-code">
  <strong class="bold">)}</strong></pre><pre class="source-code">
  ...</pre><pre class="source-code">
&lt;/div&gt;</pre></li>
				<li>Run the app by running <strong class="source-inline">npm start</strong> in the terminal. The blog post page will appear the same as it did before. A technical difference is that the <strong class="source-inline">PostsPage</strong> is re-rendered after the data has <span class="No-Break">been fetched.</span></li>
				<li>Leave the browser window and set the focus to a different window, such as your code editor. Now, set your focus back on the browser window and notice that the fetching <a id="_idIndexMarker744"/>indicator appears for a <span class="No-Break">split second:</span></li>
			</ol>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B19051_09_08.jpg" alt="Figure 9.8 – Fetching indicator when data is refetched"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Fetching indicator when data is refetched</p>
			<p>This is because React Query, by default, assumes that data is stale when the browser regains focus. For more information on this behavior, see the following link in the React Query <span class="No-Break">documentation: </span><a href="https://tanstack.com/query/v4/docs/guides/window-focus-refetching"><span class="No-Break">https://tanstack.com/query/v4/docs/guides/window-focus-refetching</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="10">A great feature of React Query is that it maintains a cache of the data. This allows us to render components with data from the cache while fresh data is being fetched. To experience this, in the <strong class="source-inline">PostsPage</strong> JSX, remove the <strong class="source-inline">isFetching</strong> condition for when <strong class="source-inline">PostsList</strong> <span class="No-Break">is rendered:</span><pre class="source-code">
&lt;PostsList posts={posts} /&gt;</pre></li>
			</ol>
			<p>So, <strong class="source-inline">PostsList</strong> will now render even if the data <span class="No-Break">is stale.</span></p>
			<ol>
				<li value="11">In the running app, press <em class="italic">F5</em> to refresh the page. Then, leave the browser window and set the focus to a different window. Set your focus back on the browser window and notice that no fetching indicator appears and the blog posts list <span class="No-Break">remains intact.</span></li>
				<li>Repeat the previous step but this time, observe the <strong class="bold">Network</strong> tab in the browser’s DevTools. Notice<a id="_idIndexMarker745"/> that a second network request is made when the app <span class="No-Break">is refocused:</span></li>
			</ol>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/B19051_09_09.jpg" alt="Figure 9.9 – Two API requests for blog posts"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Two API requests for blog posts</p>
			<p>So, React Query seamlessly allows the component to render the old data and re-renders it with the new data after it has <span class="No-Break">been fetched.</span></p>
			<p>Next, we will continue to refactor the posts page to use React Query when a new blog post is sent to <span class="No-Break">the API.</span></p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor243"/>Updating data using React Query</h2>
			<p>React Query can<a id="_idIndexMarker746"/> update data using a feature <a id="_idIndexMarker747"/>called <strong class="bold">mutations</strong> using a <strong class="source-inline">useMutation</strong> hook. Carry out the following steps in <strong class="source-inline">PostsPage.tsx</strong> to change the saving of a new blog post to use a React <span class="No-Break">Query mutation:</span></p>
			<ol>
				<li value="1">Update the React Query import <span class="No-Break">as follows:</span><pre class="source-code">
import {</pre><pre class="source-code">
  useQuery<strong class="bold">,</strong></pre><pre class="source-code">
<strong class="bold">  useMutation,</strong></pre><pre class="source-code">
<strong class="bold">  useQueryClient,</strong></pre><pre class="source-code">
} from '@tanstack/react-query';</pre></li>
			</ol>
			<p>The <strong class="source-inline">useMutation</strong> hook allows us to carry out a mutation. The <strong class="source-inline">useQueryClient</strong> hook will enable us to get the instance of <strong class="source-inline">queryClient</strong> that the component is using and access and update the <span class="No-Break">cached data.</span></p>
			<ol>
				<li value="2">Add a call to <strong class="source-inline">useMutation</strong> after the call to <strong class="source-inline">useQuery</strong> <span class="No-Break">as follows:</span><pre class="source-code">
const {</pre><pre class="source-code">
  isLoading,</pre><pre class="source-code">
  data: posts,</pre><pre class="source-code">
  isFetching,</pre><pre class="source-code">
} = useQuery(['postsData'], getPosts);</pre><pre class="source-code">
<strong class="bold">const { mutate } = useMutation(savePost);</strong></pre></li>
			</ol>
			<p>We pass <strong class="source-inline">useMutation</strong> the function that performs the REST API HTTP <strong class="source-inline">POST</strong> request. We destructure the <strong class="source-inline">mutate</strong> function from the return value of <strong class="source-inline">useMutation</strong>, which we will use in <em class="italic">step 4</em> to trigger <span class="No-Break">the mutation.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are other useful state variables that can be destructured from <strong class="source-inline">useMutation</strong>. An example is <strong class="source-inline">isError</strong>, which indicates whether the <strong class="source-inline">fetch</strong> function errored. See the following link for more <span class="No-Break">information: </span><a href="https://tanstack.com/query/v4/docs/reference/useMutation"><span class="No-Break">https://tanstack.com/query/v4/docs/reference/useMutation</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="3">When the mutation has successfully been completed, we want to update the <strong class="source-inline">posts</strong> cache to contain the new blog post. Make the following highlighted changes to<a id="_idIndexMarker748"/> <span class="No-Break">implement this:</span><pre class="source-code">
<strong class="bold">const queryClient = useQueryClient();</strong></pre><pre class="source-code">
const { mutate } = useMutation(savePost<strong class="bold">, {</strong></pre><pre class="source-code">
<strong class="bold">  onSuccess: (savedPost) =&gt; {</strong></pre><pre class="source-code">
<strong class="bold">    queryClient.setQueryData&lt;PostData[]&gt;(</strong></pre><pre class="source-code">
<strong class="bold">      ['postsData'],</strong></pre><pre class="source-code">
<strong class="bold">      (oldPosts) =&gt; {</strong></pre><pre class="source-code">
<strong class="bold">        if (oldPosts === undefined) {</strong></pre><pre class="source-code">
<strong class="bold">          return [savedPost];</strong></pre><pre class="source-code">
<strong class="bold">        } else {</strong></pre><pre class="source-code">
<strong class="bold">          return [savedPost, ...oldPosts];</strong></pre><pre class="source-code">
<strong class="bold">        }</strong></pre><pre class="source-code">
<strong class="bold">      }</strong></pre><pre class="source-code">
<strong class="bold">    );</strong></pre><pre class="source-code">
<strong class="bold">  },</strong></pre><pre class="source-code">
<strong class="bold">}</strong>);</pre></li>
			</ol>
			<p>The second argument on <strong class="source-inline">useMutation</strong> allows the mutation to be configured. The <strong class="source-inline">onSuccess</strong> configuration option is a function called when the mutation has been <span class="No-Break">successfully completed.</span></p>
			<p><strong class="source-inline">useQueryClient</strong> returns the query client that the component is using. This query client has a method called <strong class="source-inline">setQueryData</strong>, which allows the cached data to be updated. <strong class="source-inline">setQueryData</strong> has arguments for the key of the cached data and the new copy of data to <span class="No-Break">be cached.</span></p>
			<ol>
				<li value="4">We can trigger the mutation when the new post is saved by calling the destructured <strong class="source-inline">mutate</strong> function in the <strong class="source-inline">onSave</strong> prop on the <strong class="source-inline">NewPostForm</strong> <span class="No-Break">JSX element:</span><pre class="source-code">
&lt;NewPostForm onSave={<strong class="bold">mutate</strong>} /&gt;</pre></li>
				<li>Now, we can remove the <strong class="source-inline">handleSave</strong> function because this is <span class="No-Break">now redundant.</span></li>
				<li>The imported <strong class="source-inline">NewPostData</strong> type can be removed as well. This type’s import statement should now be <span class="No-Break">as follows:</span><pre class="source-code">
import { PostData } from './types';</pre></li>
				<li>In the running app, if you enter and save a new blog post, it will appear in the list as in the<a id="_idIndexMarker749"/> <span class="No-Break">previous implementation:</span></li>
			</ol>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/B19051_09_10.jpg" alt="Figure 9.10 – New blog post added to posts list"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – New blog post added to posts list</p>
			<p>That completes the refactoring of saving new blog posts to use a React Query mutation. That also completes this section on React Query – here’s a recap of the <span class="No-Break">key points:</span></p>
			<ul>
				<li>React Query is a popular library that manages data from a backend API in a cache, helping to <span class="No-Break">improve performance</span></li>
				<li>React Query doesn’t actually make the HTTP requests – the browser’s <strong class="source-inline">fetch</strong> function can be used to <span class="No-Break">do this</span></li>
				<li>React Query’s <strong class="source-inline">QueryClientProvider</strong> component needs to be placed high in the component tree above where backend data <span class="No-Break">is needed</span></li>
				<li>React Query’s <strong class="source-inline">useQuery</strong> hook allows data to be fetched and cached <span class="No-Break">in state</span></li>
				<li>React Query’s <strong class="source-inline">useMutation</strong> hook allows data to <span class="No-Break">be updated</span></li>
			</ul>
			<p>For more <a id="_idIndexMarker750"/>information on React Query, visit the library’s documentation <span class="No-Break">site: </span><a href="https://tanstack.com/query"><span class="No-Break">https://tanstack.com/query</span></a><span class="No-Break">.</span></p>
			<p>Next, we will learn how to integrate React Query into React Router’s <span class="No-Break">data-fetching capabilities.</span></p>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor244"/>Using React Router with React Query</h1>
			<p>So far, we have <a id="_idIndexMarker751"/>experienced the benefits of both React Router and React Query data fetching. React Router reduces the number of re-renders, while React Query provides a client-side cache of the data. In this section, we will use these libraries together in our app so that it has both <span class="No-Break">these benefits.</span></p>
			<p>Carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Start by opening <strong class="source-inline">App.tsx</strong> and change the loader function on the route definition to <span class="No-Break">the following:</span><pre class="source-code">
const router = createBrowserRouter([</pre><pre class="source-code">
  {</pre><pre class="source-code">
    path: '/',</pre><pre class="source-code">
    element: ...,</pre><pre class="source-code">
    <strong class="bold">loader: async () =&gt; {</strong></pre><pre class="source-code">
<strong class="bold">      const existingData = queryClient.getQueryData([</strong></pre><pre class="source-code">
<strong class="bold">        'postsData',</strong></pre><pre class="source-code">
<strong class="bold">      ]);</strong></pre><pre class="source-code">
<strong class="bold">      if (existingData) {</strong></pre><pre class="source-code">
<strong class="bold">        return defer({ posts: existingData });</strong></pre><pre class="source-code">
<strong class="bold">      }</strong></pre><pre class="source-code">
<strong class="bold">      return defer({</strong></pre><pre class="source-code">
<strong class="bold">        posts: queryClient.fetchQuery(</strong></pre><pre class="source-code">
<strong class="bold">          ['postsData'],</strong></pre><pre class="source-code">
<strong class="bold">          getPosts</strong></pre><pre class="source-code">
<strong class="bold">        )</strong></pre><pre class="source-code">
<strong class="bold">      });</strong></pre><pre class="source-code">
<strong class="bold">    }</strong></pre><pre class="source-code">
  }</pre><pre class="source-code">
])</pre></li>
			</ol>
			<p>Inside the loader, we use React Query’s <strong class="source-inline">getQueryData</strong> function on the query client to get the<a id="_idIndexMarker752"/> existing data from its cache. If there is cached data, it is returned; otherwise, the data is fetched, deferred, and added to <span class="No-Break">the cache.</span></p>
			<ol>
				<li value="2">Open <strong class="source-inline">PostsPage.tsx</strong> and remove the use of React Query’s <strong class="source-inline">useQuery</strong> because the React Router loader manages the data loading <span class="No-Break">process now.</span></li>
				<li>Remove the <strong class="source-inline">getPosts</strong> function from the <strong class="source-inline">getPosts</strong> import statement because this is used in the React Router <span class="No-Break">loader now.</span></li>
				<li>Also, remove the loading indicator because we will revert to using React Suspense in <span class="No-Break"><em class="italic">step 6</em></span><span class="No-Break">.</span></li>
				<li>The data will be retrieved using React Router’s <strong class="source-inline">useLoaderData</strong> hook again, so uncomment those two lines <span class="No-Break">of code:</span><pre class="source-code">
export function PostsPage() {</pre><pre class="source-code">
  const queryClient = useQueryClient();</pre><pre class="source-code">
  const { mutate } = useMutation( ... );</pre><pre class="source-code">
  <strong class="bold">const data = useLoaderData();</strong></pre><pre class="source-code">
<strong class="bold">  assertIsData(data);</strong></pre><pre class="source-code">
  return ...</pre><pre class="source-code">
}</pre></li>
				<li>Also, reinstate the use of <strong class="source-inline">Suspense</strong> and <strong class="source-inline">Await</strong> in the JSX. The JSX should be as <span class="No-Break">follows now:</span><pre class="source-code">
&lt;div className="w-96 max-w-xl mx-auto mt-6"&gt;</pre><pre class="source-code">
  &lt;h2 className="text-xl text-slate-900 font-bold"&gt;</pre><pre class="source-code">
    Posts</pre><pre class="source-code">
  &lt;/h2&gt;</pre><pre class="source-code">
  &lt;NewPostForm onSave={mutate} /&gt;</pre><pre class="source-code">
  <strong class="bold">&lt;Suspense fallback={&lt;div&gt;Fetching ...&lt;/div&gt;}&gt;</strong></pre><pre class="source-code">
<strong class="bold">    &lt;Await resolve={data.posts}&gt;</strong></pre><pre class="source-code">
<strong class="bold">      {(posts) =&gt; {</strong></pre><pre class="source-code">
<strong class="bold">        assertIsPosts(posts);</strong></pre><pre class="source-code">
<strong class="bold">        return &lt;PostsList posts={posts} /&gt;;</strong></pre><pre class="source-code">
<strong class="bold">      }}</strong></pre><pre class="source-code">
<strong class="bold">    &lt;/Await&gt;</strong></pre><pre class="source-code">
<strong class="bold">  &lt;/Suspense&gt;</strong></pre><pre class="source-code">
&lt;/div&gt;</pre></li>
				<li>The running app<a id="_idIndexMarker753"/> will appear and display the blog posts just as before, but a second render of <strong class="source-inline">PostsPage</strong> will no longer occur when the app is first loaded. However, after adding a new blog post using the form, it doesn’t appear in the list. We will resolve this in the <span class="No-Break">next step.</span></li>
				<li>After the new blog post has been saved, we need to cause the route component to re-render in order to get the latest data. We can do this by causing the router to navigate to the <a id="_idIndexMarker754"/>page we are already on, <span class="No-Break">as follows:</span><pre class="source-code">
import {</pre><pre class="source-code">
  useLoaderData,</pre><pre class="source-code">
  Await,</pre><pre class="source-code">
  <strong class="bold">useNavigate</strong></pre><pre class="source-code">
} from 'react-router-dom';</pre><pre class="source-code">
...</pre><pre class="source-code">
export function PostsPage() {</pre><pre class="source-code">
<strong class="bold">  const navigate = useNavigate();</strong></pre><pre class="source-code">
  const queryClient = useQueryClient();</pre><pre class="source-code">
  const { mutate } = useMutation(savePost, {</pre><pre class="source-code">
    onSuccess: (savedPost) =&gt; {</pre><pre class="source-code">
      queryClient.setQueryData&lt;PostData[]&gt;(</pre><pre class="source-code">
        ['postsData'],</pre><pre class="source-code">
        (oldPosts) =&gt; {</pre><pre class="source-code">
          if (oldPosts === undefined) {</pre><pre class="source-code">
            return [savedPost];</pre><pre class="source-code">
          } else {</pre><pre class="source-code">
            return [savedPost, ...oldPosts];</pre><pre class="source-code">
          }</pre><pre class="source-code">
        }</pre><pre class="source-code">
      );</pre><pre class="source-code">
      <strong class="bold">navigate('/');</strong></pre><pre class="source-code">
    },</pre><pre class="source-code">
  });</pre><pre class="source-code">
  ...</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>We perform the navigation after the blog post has been saved and added to the cache. This means the route’s loader will execute and populate its data from the cache. <strong class="source-inline">PostsPage</strong> will then be rendered with <strong class="source-inline">useLoaderData</strong> returning the <span class="No-Break">up-to-date data.</span></p>
			<p>That completes this final revision of the app and this section on using React Router with React Query. By integrating these two libraries, we get the following key benefits of <span class="No-Break">each library:</span></p>
			<ul>
				<li>React Router’s data loader prevents an unnecessary re-render when data is loaded onto <span class="No-Break">a page</span></li>
				<li>React Query’s cache prevents unnecessary calls to the <span class="No-Break">REST API</span></li>
			</ul>
			<p>The way these<a id="_idIndexMarker755"/> two libraries integrate is to get and set data in the React Query cache, in the React <span class="No-Break">Router loader.</span></p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor245"/>Summary</h1>
			<p>In this chapter, we used the browser’s <strong class="source-inline">fetch</strong> function to make HTTP <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> requests. The request’s URL is the first argument on the <strong class="source-inline">fetch</strong> function. The second argument on <strong class="source-inline">fetch</strong> allows the request options to be specified, such as the HTTP method <span class="No-Break">and body.</span></p>
			<p>A type assertion function can be used to strongly type the data in the response body of an HTTP request. The function takes in the data having an <strong class="source-inline">unknown</strong> type. The function then carries out checks to validate the type of data and throws an error if it is invalid. If no errors occur, the asserted type for the data is specified in the functions <span class="No-Break">assertion signature.</span></p>
			<p>React’s <strong class="source-inline">useEffect</strong> hook can be used to execute a call to fetch data from a backend API and store the data in the state when the component is mounted. A flag can be used inside <strong class="source-inline">useEffect</strong> to ensure the component is still mounted after the HTTP request before the data state <span class="No-Break">is set.</span></p>
			<p>React Query and React Router replace the use of <strong class="source-inline">useEffect</strong> and <strong class="source-inline">useState</strong> in the data-fetching process and simplify our code. React Router’s loader function allows data to be fetched and passed into the component route removing an unnecessary re-render. React Query contains a cache that can be used in components to render data optimistically while up-to-date data is being fetched. React Query also contains a <strong class="source-inline">useMutation</strong> hook to enable data to <span class="No-Break">be updated.</span></p>
			<p>In the next chapter, we will cover how to interact with <span class="No-Break">GraphQL APIs.</span></p>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor246"/>Questions</h1>
			<p>Answer the following questions to check what you have learned in <span class="No-Break">this chapter:</span></p>
			<ol>
				<li value="1">The following effect attempts to fetch data from a REST API and store it in <span class="No-Break">the state:</span><pre class="source-code">
useEffect(async () =&gt; {</pre><pre class="source-code">
  const response = await fetch('https://some-rest-api/');</pre><pre class="source-code">
  const data = await response.json();</pre><pre class="source-code">
  setData(data);</pre><pre class="source-code">
}, []);</pre></li>
			</ol>
			<p>What are the problems with <span class="No-Break">this implementation?</span></p>
			<ol>
				<li value="2">The following fetching function returns an array of <span class="No-Break">first names:</span><pre class="source-code">
export async function getFirstNames() {</pre><pre class="source-code">
  const response = await fetch('https://some-    firstnames/');</pre><pre class="source-code">
  const body = await response.json();</pre><pre class="source-code">
  return body;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>However, the return type of the function is <strong class="source-inline">any</strong>. So, how can we improve the implementation to have a return type <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">string[]</strong></span><span class="No-Break">?</span></p>
			<ol>
				<li value="3">In the <strong class="source-inline">fetch</strong> function argument, what should be specified in the <strong class="source-inline">method</strong> option for it to make an HTTP <span class="No-Break"><strong class="source-inline">PUT</strong></span><span class="No-Break"> request?</span><pre class="source-code">
fetch(url, {</pre><pre class="source-code">
  method: <strong class="bold">???</strong>,</pre><pre class="source-code">
  body: JSON.stringify(data),</pre><pre class="source-code">
});</pre></li>
				<li>How do you specify a bearer token in an HTTP <strong class="source-inline">Authorization</strong> header when making an HTTP request to a protected resource <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">fetch</strong></span><span class="No-Break">?</span></li>
				<li>A component uses React Query’s <strong class="source-inline">useQuery</strong> to fetch data but the component errors with the <span class="No-Break">following error:</span></li>
			</ol>
			<p><strong class="bold">Uncaught Error: No QueryClient set, use QueryClientProvider to </strong><span class="No-Break"><strong class="bold">set one</strong></span></p>
			<p>What do you think the <span class="No-Break">problem is?</span></p>
			<ol>
				<li value="6">What state variable can be destructured from React Query’s <strong class="source-inline">useMutation</strong> to determine whether the HTTP request has returned <span class="No-Break">an error?</span></li>
			</ol>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor247"/>Answers</h1>
			<ol>
				<li value="1">There are two problems with <span class="No-Break">the implementation:</span><ul><li><strong class="source-inline">useEffect</strong> doesn’t support <span class="No-Break">top-level </span><span class="No-Break"><strong class="source-inline">async</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">await</strong></span></li><li>If the component is umounted during the HTTP request, an error will occur when the <strong class="source-inline">data</strong> state <span class="No-Break">is set</span></li></ul></li>
			</ol>
			<p>Here is an implementation with those <span class="No-Break">issues resolved:</span></p>
			<pre class="source-code">
useEffect(() =&gt; {
  let cancel = false;
  fetch('https://some-rest-api/')
    .then((response) =&gt; data.json())
    .then((data) =&gt; {
      if (!cancel) {
        setData(data);
      }
    });
  return () =&gt; {
    cancel = true;
  };
}, []);</pre>
			<ol>
				<li value="2">An <strong class="source-inline">assert</strong> function can be used on the response body object <span class="No-Break">as follows:</span><pre class="source-code">
export async function getFirstNames() {</pre><pre class="source-code">
  const response = await fetch('https://some-    firstnames/');</pre><pre class="source-code">
  const body = await response.json();</pre><pre class="source-code">
<strong class="bold">  assertIsFirstNames(body);</strong></pre><pre class="source-code">
  return body;</pre><pre class="source-code">
}</pre><pre class="source-code">
<strong class="bold">function assertIsFirstNames(</strong></pre><pre class="source-code">
<strong class="bold">  firstNames: unknown</strong></pre><pre class="source-code">
<strong class="bold">): asserts firstNames is string[] {</strong></pre><pre class="source-code">
<strong class="bold">  if (!Array.isArray(firstNames)) {</strong></pre><pre class="source-code">
<strong class="bold">    throw new Error('firstNames isn't an array');</strong></pre><pre class="source-code">
<strong class="bold">  }</strong></pre><pre class="source-code">
<strong class="bold">  if (firstNames.length === 0) {</strong></pre><pre class="source-code">
<strong class="bold">    return;</strong></pre><pre class="source-code">
<strong class="bold">  }</strong></pre><pre class="source-code">
<strong class="bold">  firstNames.forEach((firstName) =&gt; {</strong></pre><pre class="source-code">
<strong class="bold">    if (typeof firstName !== 'string') {</strong></pre><pre class="source-code">
<strong class="bold">      throw new Error('firstName is not a string');</strong></pre><pre class="source-code">
<strong class="bold">    }</strong></pre><pre class="source-code">
<strong class="bold">  });</strong></pre><pre class="source-code">
<strong class="bold">}</strong></pre></li>
				<li>The method option should <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">'PUT'</strong></span><span class="No-Break">:</span><pre class="source-code">
fetch(url, {</pre><pre class="source-code">
  method: <strong class="source-inline">'PUT'</strong>,</pre><pre class="source-code">
  body: JSON.stringify(data),</pre><pre class="source-code">
});</pre></li>
				<li>The <strong class="source-inline">headers.Authorization</strong> option can be used to specify a bearer token when making an HTTP request to a protected resource <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">fetch</strong></span><span class="No-Break">:</span><pre class="source-code">
fetch(url, {</pre><pre class="source-code">
  headers: {</pre><pre class="source-code">
    <strong class="bold">Authorization: 'Bearer some-bearer-token',</strong></pre><pre class="source-code">
    'Content-Type': 'application/json',</pre><pre class="source-code">
  },</pre><pre class="source-code">
});</pre></li>
				<li>The problem is that React Query’s <strong class="source-inline">QueryClientProvider</strong> hasn’t been placed above the component using <strong class="source-inline">useQuery</strong> in the <span class="No-Break">component tree.</span></li>
				<li>The <strong class="source-inline">isError</strong> state variable can be destructured from React Query’s <strong class="source-inline">useMutation</strong> to determine whether the HTTP request has returned an error. Alternatively, the <strong class="source-inline">status</strong> state variable can be checked for a value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">'error'</strong></span><span class="No-Break">.</span></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer140" class="IMG---Figure">
			</div>
		</div>
	</body></html>