- en: Working with the Angular Router and Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we're already familiar with the core of the framework. We know how to
    define components and directives in order to develop the view of our applications.
    We also know how to encapsulate business-related logic into services and wire
    everything together with the DI mechanism of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll explain a few more concepts that will help us build
    real-life Angular applications. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The component-based router of the framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Angular's forms module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing custom form validators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing template-driven forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Developing the "Coders repository" application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the process of explaining the listed concepts, we'll develop a sample
    application that contains a repository of developers. Before we start coding,
    let's discuss the structure of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The "Coders repository" will allow its users to add developers, either by filling
    a form with details about them or by providing the GitHub handle for the developer
    and importing their profile from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of this chapter, we will store information about the developers
    in memory, which means that after the page is refreshed, we'll lose all the data
    stored during the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will have the following views:'
  prefs: []
  type: TYPE_NORMAL
- en: A list of all the developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A view for adding or importing new developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A view that shows the given developer''s details. This view has two subviews:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic details**: Shows the name of the developer and their GitHub avatar
    if available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced profile**: Shows all the details known of the developer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The end result of the application''s home page will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb477887-300a-486a-8df1-e49671acc949.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build only a few of the listed views. The rest of the
    application will be explained in [Chapter 8](503e1c1c-afb1-4dd4-98e2-657ceb32cc59.xhtml),
    *Explaining Pipes and Communicating with RESTful Services*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each developer will be an instance of the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'All the developers will reside within the `DeveloperCollection` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The classes mentioned here encapsulate a simple business logic and don't have
    anything Angular-specific, so we won't get into any details.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's continue with the implementation by exploring the new router.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Angular router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already know, in order to bootstrap any Angular application, we need to
    develop a root NgModule and a bootstrap component. The "Coders repository" application
    is not any different; the only addition in this specific case is that we will
    have multiple pages that need to be connected together with the Angular router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the imports required for the router''s configuration and
    define the root component right after this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we import `RouterModule` directly from `@angular/router`;
    as we can see, the router is externalized outside the framework's core. This module
    declares all the routing-specific directives, as well as all the routing-related
    providers, which means that, if we import it, we'll get access to all of them.
  prefs: []
  type: TYPE_NORMAL
- en: The `LocationStrategy` class is an abstract class that defines the common logic
    between `HashLocationStrategy`—used for hash-based routing, and `PathLocationStrategy`—used
    for HTML5-based routing by taking advantage of the history API.
  prefs: []
  type: TYPE_NORMAL
- en: '`HashLocationStrategy` does not support server-side rendering, because the
    hash of the page does not get sent to the server. Since the hash is our application''s
    view identifier, the server will not be aware of the page that needs to be rendered.
    Fortunately, all modern browsers except IE9 support the HTML5 history API. You
    can find more about server-side rendering in the final chapter of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define a bootstrap component and configure the application''s root
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we can notice a syntax we're already familiar with,
    from [Chapter 5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml), *Getting Started
    with Angular Components and Directives* and [Chapter 6](3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml),
    *Dependency Injection in Angular*. We define a component with an `app` selector,
    `template`, which we will take a look at later, and sets of providers and directives.
  prefs: []
  type: TYPE_NORMAL
- en: The `App` component declares a single provider associated with the `DeveloperCollection`
    token. This is the class that contains all of the developers stored by the application.
    Later, we invoke the `forRoot` method of `RouterModule`; this method allows us
    to configure the router by declaring the root routes of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have imported the module, returned as a result of the invocation of
    `forRoot`, we already have access to a set of directives. These directives can
    help us link to the other routes defined as part of the router's configuration
    (the `routerLink` directive) and declare the place where the components associated
    with the different routes should be rendered (`router-outlet`). We'll explain
    how we can use them later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the configuration of our `AppModule` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We add a single declaration—the `App` component—that we use for bootstrapping
    the application. Note that, here, we import not only `BrowserModule`, but also
    the result returned from the invocation of the `forRoot` method of `RouterModule`.
    In the `providers` array, we configure the provider for `LocationStrategy`. The
    default `LocationStrategy` implementation, which Angular uses, is `PathLocationStrategy`
    (that is, the HTML5-based one); however, in this case, we will use the hash-based
    one.
  prefs: []
  type: TYPE_NORMAL
- en: When we have to choose between the two location strategies, we should bear in
    mind that the default location strategy (`PathLocationStrategy`) is supported
    by the server-rendering module of Angular, and the URL of the application looks
    more natural to the end user (there's no `#` used). On the other hand, if we use
    `PathLocationStrategy`, we may need to configure our application server in order
    to work with the HTML5 history API, which is not necessary for `HashLocationStrategy`.
  prefs: []
  type: TYPE_NORMAL
- en: Using PathLocationStrategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `PathLocationStrategy` class uses `APP_BASE_HREF`, which, by default, has
    the `"/"` string as a value. This means that, in case the base pathname of our
    application is different, we must set it explicitly in order to have a properly
    functioning routing. For instance, in our case, the configuration should look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `APP_BASE_HREF` represents the base path of the application. For instance,
    in our case, the "Coders repository" will be located under the `/dist/dev/ch7/multi-page-template-driven/`
    directory (or, if we include the schema and the host, `http://localhost:5555/dist/dev/ch7/multi-page-template-driven/`).
  prefs: []
  type: TYPE_NORMAL
- en: We will need to provide the value of `APP_BASE_HREF` in order to hint to Angular,
    which part of the path is an application route (that is, meaningful for the router).
    For instance, for the `http://localhost:5555/dist/dev/ch7/multi-page-template-driven/home` URL,
    by having `APP_BASE_HREF` equal to `/dist/dev/ch7/multi-page-template-driven/`,
    Angular will know that it needs to provide the component associated with the `home`
    path since the rest of the URL is not relevant to the declared routes within the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the next step, let''s update the declarations of the routes. Open `ch7/step-0/app.ts`
    and update the invocation of the `forRoot` method of `RouteModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As the preceding snippet shows, the `forRoot` method accepts an array of route
    declarations as an argument. We define two redirects and two routes with components
    associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each nonlazy-loaded route must define the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`component`: The component associated with the given route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: The path to be used for the route—it will be visible in the browser''s
    location bar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, the redirect''s definition should contain these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path`: The path to be used for the redirection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redirectTo`: The path the user will be redirected to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pathMatch`: This defines the matching strategy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous example, we declare that when the user navigates to `/add-dev`,
    we want them to be redirected to `/dev-add`. As we mentioned, `pathMatch` defines
    the path matching strategy. By default, it has the `"prefix"` value, which means
    that the router will try to match the beginning of the current route with the
    `path` property declared in the redirect. In contrast, when we set the `pathMatch`
    property to the `"full"` value, the router will redirect to the `redirectTo` path
    only when the entire path has been matched. It's important to explicitly set `pathMatch`
    to `"full"` in the first redirect, otherwise, every route will match the `""`
    path in case of a match by prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to make everything work, we will need to define the `AddDeveloper`
    and `Home` components, which are referenced in the router''s configuration. First,
    we will provide a basic implementation that we''ll incrementally extend over time,
    through the course of this chapter. In `ch7/step-0`, let''s create a file called
    `home.ts` and enter the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the file called `add_developer.ts`, and enter the following content
    in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Do not forget to import the `Home` and `AddDeveloper` components in `app.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Using routerLink and router-outlet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have the declarations of the routes and all the components associated with
    them. The only thing left is to define the template of the root `App` component
    in order to link everything together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following content to the `template` property inside the `@Component`
    decorator in `ch7/step-0/app.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the template, there are two Angular-specific directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`routerLink`: This allows us to add a link to a specific route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router-outlet`: This defines the container where the components associated
    with the currently selected route should be rendered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at the `routerLink` directive. As value, it accepts an array
    of route paths and parameters. In our case, we provide only a single route path.
    Note that the route name used by `routerLink` is declared by the `path` property
    of the route declaration inside `forRoot`. Later in this book, we'll see how we
    can link to nested routes and pass route parameters.
  prefs: []
  type: TYPE_NORMAL
- en: This directive allows us to declare links independently from `LocationStrategy`
    that we configured. For instance, imagine we are using `HashLocationStrategy`;
    this means that we will need to prefix all the routes in our templates with `#`.
    In case we switch to `PathLocationStrategy`, we'll need to remove all the hash
    prefixes. This is only a partial benefit of the neat abstraction that `routerLink`
    creates on top of path references.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next directive that is new to us from the previous template is `router-outlet`.
    It has a similar responsibility to the `ng-view` directive in AngularJS. Basically,
    they both have the same role: to point out where the target component should be
    rendered. This means that, according to the definition, when the user navigates
    to `/`, the `Home` component will be rendered at the position pointed out by `router-outlet`,
    the same for the `AddDeveloper` component once the user navigates to `dev-add`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have these two routes up and running! Open `http://localhost:5555/dist/dev/ch7/step-0/`,
    and you should see a page which looks similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e3d8485-a8e6-4311-9e6f-6c6cbe4056ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2
  prefs: []
  type: TYPE_NORMAL
- en: If you don't, just take a look at `ch7/step-1` that contains the result.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy-loading with loadChildren
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AngularJS modules allow us to group together logically-related building units
    of the application. However, by default, they need to be available during the
    initial bootstrap of the application and do not allow deferred loading. This requires
    downloading the entire code base of the application during the initial page load
    that, in case of large single-page apps, can be an unacceptable performance hit.
  prefs: []
  type: TYPE_NORMAL
- en: In a perfect scenario, we would want to load only the code associated with the
    page the user is currently viewing or to prefetch bundled modules based on heuristics
    related to the user's behavior, which is beyond the scope of this book. For instance,
    open the application from the first step of our example, `http://localhost:5555/dist/dev/ch7/step-1/`.
    Once the user is at `/`, we only need the `Home` component to be available, and
    once they navigate to `dev-add`, we want to load the `AddDeveloper` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s inspect what is actually going on in Chrome DevTools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72667ce4-8def-4017-a66a-249b40950eaf.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3
  prefs: []
  type: TYPE_NORMAL
- en: We can notice that during the initial page load, Angular downloads the components
    associated with all the routes, even `AddDeveloper`, which is not required. This
    happens because, in `app.ts`, we explicitly require both the `Home` and `AddDeveloper`
    components, and use them in the declarations of the routes.
  prefs: []
  type: TYPE_NORMAL
- en: In this specific case, loading both components may not seem like a big problem
    because, at this step, they are pretty lean and do not have any dependencies.
    However, in real-life applications, they will have imports of other directives,
    components, pipes, services, or even third-party libraries. Once any of the components
    is required, its entire dependency graph will be downloaded, even if the component
    is not needed at that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The router of Angular comes with a solution to this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The declaration of the lazy-loaded routes is an object with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loadChildren`: A string that points to the path of the lazy-loaded module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: The path of the route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the user navigates to a route that matches any of the definitions of the
    lazy-routes, a module loader (by default, SystemJS) will download the module from
    the location provided by `loadChildren`. When the promise returned by the loader
    is resolved with a value of the target module, the module will be cached and its
    bootstrap component will be rendered. The next time the user navigates to the
    same route, the cached module will be used, so the routing module won't download
    the same component twice.
  prefs: []
  type: TYPE_NORMAL
- en: Note the `#` symbol in the value of the `loadChildren` property. If we split
    the string by the `#` symbol, its first part will be the module's URL and its
    second part will be the name of the export that represents the Angular module
    the router will use for the route. If we don't provide a module name, Angular
    will use the default export.
  prefs: []
  type: TYPE_NORMAL
- en: The previous example uses `loadChildren`, which, by default, loads modules with
    SystemJS. You can use a more advanced configuration and a custom module loader.
    For further information, take a look at the Angular documentation at [http://angular.io](http://angular.io).
  prefs: []
  type: TYPE_NORMAL
- en: Prefetching of the lazy-loaded routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already mentioned, in the perfect scenario, we would want to download
    only the minimum set of resources that the user needs at a given time. For instance,
    if the user visits the home page, we'd want to download only the bundle that corresponds
    to the home module (that is, `HomeModule`).
  prefs: []
  type: TYPE_NORMAL
- en: Later, when the user navigates to `dev-add`, the router will need to download
    `AddDeveloperModule`. Although, this way, the user will consume network bandwidth
    only for the assets they use, the user experience will be far from perfect because
    of the slowdown that happens while navigating to as yet unvisited pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to handle this problem, we can add a route preloading strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we declare that we want to use the default `preloadingStrategy`
    abstract class that Angular provides. As a result, when the user opens `home`
    and `HomeModule` is successfully downloaded, the router will automatically start
    prefetching all the other routes. So, next time, when the user navigates to a
    different page, it will most likely be already available in-memory. This will
    introduce a neat improvement to the user experience at almost no cost.
  prefs: []
  type: TYPE_NORMAL
- en: By providing a custom implementation of the `PreloadingStrategy` abstract class
    (located in the `@angular/router` package), we can introduce a custom mechanism
    for the prefetching of lazy-loaded modules.
  prefs: []
  type: TYPE_NORMAL
- en: RouterModule.forRoot versus RouterModule.forChild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two methods we can invoke using `RouterModule` in order to register
    routes.
  prefs: []
  type: TYPE_NORMAL
- en: In case we declare the top-level routes of our application, we need to use `RouterModule.forRoot`.
    This method will register the top-level routes and return the routing module that
    should be imported by the root module of the application.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to define routes in a lazy-loaded module and import the module returned
    by the invocation of the `forRoot` method, we'll get a runtime error. This is
    because the `forRoot` method will return a module with providers, which should
    be imported only once, by the top-level module. In order to register nested routes
    in a lazy-loaded module, we will need to use the `forChild` method.
  prefs: []
  type: TYPE_NORMAL
- en: We'll take a further look at how we can define nested routes in [Chapter 8](503e1c1c-afb1-4dd4-98e2-657ceb32cc59.xhtml),
    *Explaining Pipes and Communicating with RESTful Services.*
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, we can remember that `RouterModule.forRoot` is meant for
    the registration of top-level routes, and `RouterModule.forChild` should be used
    only for the registration of nested routes in a lazy-loaded module.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular's forms module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's continue with the implementation of the application. For the next
    step, we'll work on the `AddDeveloper` and `Home` components. You can continue
    your implementation by extending what you currently have in `ch7/step-0`, or if
    you haven't reached step 1 yet, you can keep working on the files in `ch7/step-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular offers two ways of developing forms with validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A template-driven approach**: This provides a declarative API where we declare
    the validations into the template of the component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A model-driven approach (also known as reactive forms)**: This provides an
    imperative, reactive API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the template-driven approach for now and explore the model-driven
    approach in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Developing template-driven forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms are essential for each **Create Retrieve Update and Delete** (**CRUD**)
    application. In our case, we want to build a form for entering the details of
    the developers we want to store.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this section, we''ll have a form that allows us to enter the
    real name of a given developer, to add their preferred technology, enter their
    email, and declare whether they are popular in the community or not yet. The end
    result will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d99fcff0-d7ba-4a13-89d3-64a803b03b09.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following import to `app.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The next thing we need to do is import `FormsModule` in our `AppModule` class.
    The `FormsModule` class contains a set of predefined directives for managing Angular
    forms, such as the `form` and `ngModel` directives. The `FormsModule` class also
    declares an array with a predefined set of form-related providers that we can
    use in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the import of the `FormsModule` class, our `app.ts` file will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, update the `AddDeveloper` implementation to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `developer` property contains the information associated with the current
    developer that we're adding with the form. The last two properties, `errorMessage`
    and `successMessage`, will be used to display the current form's error or success
    messages, respectively, once the developer has been successfully added to the
    developers collection, or when an error has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Digging into the markup of the template-driven form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the next step, let''s create the template for the `AddDeveloper` component
    (`step-1/add_developer.html`). Add the following content to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These two elements are intended to display the error and success messages when
    we add a new developer. They will be visible when `errorMessage` or `successMessage`
    have nonfalsy values (that is, something different from the empty string, `false`,
    `undefined`, `0`, `NaN`, or `null`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s develop the actual form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We declare a new form using the HTML `form` tag. Once Angular finds such tags
    in a template with an included form directive in the parent component, it will
    automatically enhance its functionality in order to be used as an Angular form.
    Once the form is processed by Angular, we can apply form validation and data bindings.
    After this, using `#f="ngForm"`, we define a local variable in template, which
    allows us to reference to the form using the `f` identifier. The last thing left
    from the form element is the submit event handler. We use a syntax that we're
    already familiar with, `(ngSubmit)="expr"`; in this case, the value of the expression
    is the call of the `addDeveloper` method defined in the component's controller.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at the `div` element with the `control-group` class name.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is not an Angular-specific class; it is a CSS class defined by
    Bootstrap that we use in order to provide a better look and feel to the form.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `div` element, we can find a `label` element that doesn't have any
    Angular-specific markup and an input element that allows us to set the real name
    of the current developer. We set the control to be of a type text and declare
    its identifier and name equal to `realNameInput`. The `required` attribute is
    defined by the HTML5 specification and is used for validation. Using it on the
    element, we declare that this element is required to have a value. Although the
    `required` attribute is not Angular-specific, Angular will extend its semantics
    by including an Angular-specific validation behavior. This behavior includes setting
    specific CSS classes on the control when its status changes and managing its state,
    which the framework keeps internally.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of the form controls will be enhanced by running validation over
    them when their values change and applying specific classes during the controls
    life cycles. You may be familiar with this from AngularJS, where the form controls
    are decorated with the `ng-pristine`, `ng-invalid`, and `ng-valid` classes and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the CSS classes that the framework adds to the
    form controls during their life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Classes** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `ng-untouched` | The control hasn''t been visited |'
  prefs: []
  type: TYPE_TB
- en: '| `ng-touched` | The control has been visited |'
  prefs: []
  type: TYPE_TB
- en: '| `ng-pristine` | The control''s value hasn''t been changed |'
  prefs: []
  type: TYPE_TB
- en: '| `ng-dirty` | The control''s value has been changed |'
  prefs: []
  type: TYPE_TB
- en: '| `ng-valid` | All the validators attached to the control detected that the
    value is valid |'
  prefs: []
  type: TYPE_TB
- en: '| `ng-invalid` | Any of the validators attached to the control detected that
    the value is invalid |'
  prefs: []
  type: TYPE_TB
- en: 'According to this table, we can define that we want all the input controls
    with an invalid value to have a red border in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The exact semantics behind the preceding CSS in the context of Angular is that
    we use a red border for all the input elements whose values were changed and are
    invalid according to the validators attached to them.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's explore how we can attach validation behavior to our controls.
  prefs: []
  type: TYPE_NORMAL
- en: Using the built-in validators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen that we can alter validation behavior to any control using
    the `required` attribute. Angular provides two more built-in validators, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`minlength`: This allows us to specify the minimum length of the value that
    a given control should have'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxlength`: This allows us to specify the maximum length of the value that
    a given control should have'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These validators are defined with Angular directives and can be used in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This way, we specify that we want the value of the input to be between `2` and
    `30` characters.
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom validators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another data property defined in the `Developer` class is `email`. Let''s add
    an input field for it. Above the Add button in the preceding form, add the following
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can think of the `[(ngModel)]` attribute as an alternative to the `ng-model`
    directive from AngularJS. We will explain it in detail in the *Two-way data binding
    with Angular* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Angular provides a set of predefined validators, they are not enough
    for all the various formats our data can live in. Sometimes, we''ll need custom
    validation logic for our application-specific data. For instance, in this case,
    we want to define an email validator. A typical regular expression, which works
    in general cases (but does not cover the entire specification that defines the
    format of the email addresses), looks as follows: `/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$/`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `ch7/step-1/email_validator.ts`, define a function that accepts an instance
    of Angular control as an argument and returns `null` if the control''s value is
    empty or matches the regular expression mentioned earlier, and `{ ''invalidEmail'':
    true }` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, from the `@angular/common` and `@angular/core` modules, import `NG_VALIDATORS`
    and `Directive`, and wrap this validation function within the following directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined a multiprovider for the `NG_VALIDATORS` token.
    Once we inject the value associated with this token, we'll get an array with all
    the validators attached to the given control (for reference, take a look at the
    section for multiproviders in [Chapter 6](3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml),
    *Dependency Injection in Angular*).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only two steps left in order to make our custom validation work.
    First, add the `email-input` attribute to the email control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the directive to the declarations in the `AppModule` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We're using an external template for the `AddDeveloper` control. There's no
    ultimate answer to whether a given template should be externalized or inlined.
    Best practice states that we should inline the short templates and externalize
    the longer ones. However, there's no specific definition as to which templates
    are considered short and which are considered long. The decision of whether the
    template should be used inline or put into an external file depends on the developer's
    personal preferences or common conventions within the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Using select inputs with Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the next step, we should allow the user of the application to enter the technology
    in which the input developer has the most proficiency. We can define a list of
    technologies and show them in the form as a select input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `AddDeveloper` class, add the `technologies` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the template, just above the Add button, add the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like for the input elements we declared earlier, Angular will add the
    same classes depending on the state of the select input. In order to show a red
    border around the select element when its value is invalid, we will need to alter
    the CSS rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that inlining all the styles in our components' declaration could be a
    bad practice because, this way, they won't be reusable. What we can do is extract
    all the common styles across our components into separate files. The `@Component`
    decorator has a property called `styleUrls` of the `string[]` type where we can
    add a reference to the extracted styles used by the given component. This way,
    we can inline only the component-specific styles, if required.
  prefs: []
  type: TYPE_NORMAL
- en: Right after this, we declare the name of the control to be equal to `"technology"`
    using `name="technology"`. Using the `required` attribute, we declare that the
    user of the application must specify the technology in which the current developer
    is proficient. Let's skip the `[(ngModel)]` attribute for now and see how we can
    define the options of the `select` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `select` element, we define the different options using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is a syntax we're already familiar with. We simply iterate over all the
    technologies defined within the `AddDeveloper` class, and for each technology
    we show an `option` element with a value for the technology name.
  prefs: []
  type: TYPE_NORMAL
- en: Using the NgForm directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already mentioned that the form directive enhances the HTML5 form''s
    behavior by adding some additional Angular-specific logic. Now, let''s take a
    step back and take a look at the form that surrounds the input elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we define a new identifier called `f`, which references to
    the form. We can think of the form as a composition of controls; we can access
    the individual controls through the `controls` property of the form. On top of
    this, the form has the **touched**, **untouched**, **pristine**, **dirty**, **invalid**,
    and **valid** properties, which depend on the individual controls defined within
    the form. For example, if none of the controls within the form have been `touched`,
    then the form itself will show `untouched` as its status. However, if any of the
    controls in the form have been `touched` at least once, the form will show its
    status as `touched`. Similarly, the form will be valid only if all its controls
    are valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to illustrate the usage of the `form` element, let''s define a component
    with the `control-errors` selector, which shows the current errors for a given
    control. We can use it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that we've also added the `maxlength` validator to the `realName` control.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `control-errors` element has the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`control`: This declares the name of the control we want to show errors for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`errors`: This creates a mapping between control error and an error message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, create a new file called `control_errors.ts` and add the following imports
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In these imports, `NgForm` represents the Angular forms, and `Host` is a parameter
    decorator related to the DI mechanism, which we have already covered in [Chapter
    6](3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml), *Dependency Injection in Angular*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a part of the component''s definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ControlErrors` component defines two inputs: `control`, the name of the
    control (the value of the `name` attribute) and `errors`, the mapping between
    an error identifier and an error message; they can be specified by the `control`
    and `errors` attributes of the `control-errors` element, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s suppose we have the following input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can declare its associated `control-errors` component using the following
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `currentError` getter, in the declaration of the preceding `ControlErrors`
    class, we need to do the following two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Find a reference to the component declared with the `control` attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the error message associated with any of the errors that make the current
    control invalid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a snippet that implements this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line of the implementation of `currentError`, we get the target
    control using the `controls` property of the injected form. The `controls` property
    is of the `{[key: string]: AbstractControl}` type, where `key` is the name of
    the control we''ve declared with the `name` attribute. Once we have a reference
    to the instance of the target control, we can check whether its status is `touched`
    (that is, whether it has been focused), and if it is, we can loop over all the
    errors within the `errors` property of the instance of `ControlErrors`. The `map`
    function will return an array with either an error message or a `null` value.
    The only thing left to do is to filter all the `null` values and get only the
    error messages. Once we get the error messages for each error, we will return
    the last one by popping it from the `errorMessages` array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The end result should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/623d00e4-2a81-4766-9997-395ed4ad1d12.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5
  prefs: []
  type: TYPE_NORMAL
- en: If you experience any problems during the implementation of the `ControlErrors`
    component, you can take a look at its implementation at `ch7/step-2/control_errors.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `hasError` method of every control accepts as an argument an error message
    identifier, which is defined by the corresponding validator. For instance, in
    our example, where we defined the custom email validator, we return the `{ ''invalidEmail'':
    true }` object literal when the input control has an invalid value. If we apply
    the `ControlErrors` component to the email control, its declaration should look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Two-way data binding with Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most famous rumors about Angular was that the two-way data binding
    functionality was removed because of the enforced unidirectional data flow. This
    is not exactly true; the Angular''s form module implements a directive with the
    `[(ngModel)]` selector (we''ll also refer to this directive as `NgModel`, because
    of the name of its controller), which allows us to easily achieve data binding
    in two directions: from the view to the model and from the model to the view.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following simple component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we import `FormsModule` from the `@angular/common`
    package. Later, in the template, we set the `[(ngModel)]` attribute to `name`.
  prefs: []
  type: TYPE_NORMAL
- en: At first, the `[(ngModel)]` syntax might seem a little bit unusual. From [Chapter
    5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml), *Getting Started with Angular
    Components and Directives*, we know that the `(eventName)` syntax is used for
    binding to events (or outputs) triggered by a given component. On the other hand,
    we use the `[propertyName]="foobar"` syntax to achieve one-way data binding by
    setting the value of the property (or, in the terminology of the Angular components,
    the input) with the `propertyName` name to the result of the evaluation of the `foobar` expression.
    The `[(ngModel)]` syntax combines both in order to achieve data binding in two
    directions. That's why we can think of it more like a syntax sugar, rather than
    a new concept. One of the main advantages of this syntax compared to AngularJS
    is that we can tell which bindings are one way and which are two way by just looking
    at the template.
  prefs: []
  type: TYPE_NORMAL
- en: Another name of the `[(foo)]` syntax is the *banana in a box* or *banana brackets*
    syntax. Inspiration for this name is this paper: *Functional Programming with
    Bananas, Lenses, Envelopes and Barbed Wire* by *Erik Meijer*, *Maarten Fokkinga*,
    and *Ross Paterson* ([http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf](http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf)).
    Just like `(click)` has its canonical syntax `on-click`, and `[propertyName]`
    has its own `bind-propertyName`, the alternative syntax of `[(ngModel)]` is `bindon-ngModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open `http://localhost:5555/dist/dev/ch7/simple-two-way-data-binding/`,
    you will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3797fa6-0885-49ff-becd-bf024e5176a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6
  prefs: []
  type: TYPE_NORMAL
- en: Once the value of the input box is changed, the label below it will be updated
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already used the `[(ngModel)]` directive in the previous snippets.
    For example, we bound to the developer''s email using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This way, the value of the email property of the developer object defined in
    the `AddDeveloper` component's instance will be updated once we change the value
    of the text input.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the form data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a peek at the interface of the `AddDeveloper` component''s controller
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface has a field of the `Developer` type, and we bind the form controls
    to its properties using the `NgModel` directive. The class also has a method called
    `addDeveloper`, which is being invoked on the submission of the form. We declare
    this by binding to the `ngSubmit` event using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we should notice two more things. We got a reference
    to the form using `#f="ngForm"` and bound the disabled property of the button
    to the `!f.form.valid` expression. We have already described the `NgForm` control
    in the previous section; its `valid` property will have a `true` value once all
    the controls within the form have valid values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose we''ve entered valid values for all the input controls
    in the form. This means that its `submit` button will be enabled. Once we press
    *Enter* or click on the `submit` button, the `addDeveloper` method will be invoked.
    The following is a sample implementation of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we set the `id` property of the current developer equal to the total
    number of developers in `DeveloperCollection`, plus one. Later, we add the developer
    to the collection and set the value of the `successMessage` property. Right after
    this, we set the property submitted equal to `true`, which will result in hiding
    the form.
  prefs: []
  type: TYPE_NORMAL
- en: Listing all the stored data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can add a new entry to the developers' collection, let's show a
    list of all the developers on the front page of the "Coders repository."
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ch7/step-1/home.ts` file (or step-2, depending on your progress during
    the past section), and enter the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing new to us here. We extend the functionality of the `Home` component
    by providing an external template and implementing the `getDevelopers` method,
    which delegates its call to the instance of `DeveloperCollection` that is injected
    in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template itself uses directives we''re already familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We list all the developers as rows within an HTML table. For each developer,
    we check the status of its `popular` flag. If its value is `true`, then for the
    Popular column, we show a span with the text `Yes`, otherwise we set the text
    to `No`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you enter a few developers in the Add developer page and then navigate
    to the home page, you should see a result similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cee62104-8348-47cc-94d9-0dc72017e256.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete implementation of the application at `ch7/multi-page-template-driven`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have explained the basics of routing in Angular. We took a look at
    how we can define different routes and implement the components associated with
    them that are displayed on route change. In order to link to the different routes,
    we introduced `routerLink`, and we also used the `router-outlet` directives for
    pointing out where the components associated with the individual routes should
    be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we took a look at was the functionality of the Angular forms with
    built-in and custom validation. After this, we explained the `NgModel` directive,
    which provides us with two-way data binding.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover how we can develop model-driven forms and
    child and parameterized routes, use the `Http` module, and transform data with
    custom pipes.
  prefs: []
  type: TYPE_NORMAL
