<html><head></head><body>
<div id="_idContainer038">
<h1 class="chapter-number" id="_idParaDest-122"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-123"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.2.1">Session Management</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Session management describes the process of preserving data across different user interactions and request-response roundtrips. </span><span class="koboSpan" id="kobo.3.2">Session management is crucial to provide personalized experiences on the web. </span><span class="koboSpan" id="kobo.3.3">In this chapter, we will work with Remix’s primitives to manage application state and user session data. </span><span class="koboSpan" id="kobo.3.4">This chapter covers the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.5.1">Working with </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">search parameters</span></span></li>
<li><span class="koboSpan" id="kobo.7.1">Creating user sessions </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">with cookies</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Authenticating access to </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">user data</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.11.1">First, we will work with Remix's primitives to tie application states to URL search parameters. </span><span class="koboSpan" id="kobo.11.2">Then, we will utilize HTTP cookies to persist </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.12.1">user session data. </span><span class="koboSpan" id="kobo.12.2">Finally, we will use the session cookie to authenticate users in </span><strong class="source-inline"><span class="koboSpan" id="kobo.13.1">loader</span></strong><span class="koboSpan" id="kobo.14.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.15.1">action</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.16.1"> functions.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">After reading this chapter, you will understand how to work with search parameters to control application states in Remix. </span><span class="koboSpan" id="kobo.17.2">You will also know how to submit forms programmatically using Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.18.1">useSubmit</span></strong><span class="koboSpan" id="kobo.19.1"> hook. </span><span class="koboSpan" id="kobo.19.2">You will further practice working with Remix’s session cookie helpers and learn how to implement login, signup, and logout functionalities in Remix. </span><span class="koboSpan" id="kobo.19.3">Finally, you will understand how to authenticate users on the server and how to access loader data globally across </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">your application.</span></span></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">You can find the code for this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">here: </span></span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/08-session-management/"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/08-session-management/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.25.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">Before starting this chapter, follow the instructions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">README.md</span></strong><span class="koboSpan" id="kobo.28.1"> file in this chapter’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">bee-rich</span></strong><span class="koboSpan" id="kobo.30.1"> folder on GitHub. </span><span class="koboSpan" id="kobo.30.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">README</span></strong><span class="koboSpan" id="kobo.32.1"> file guides you through adding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">User</span></strong><span class="koboSpan" id="kobo.34.1"> model to the database schema of the BeeRich application. </span><span class="koboSpan" id="kobo.34.2">It further helps you initiate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">session.server.ts</span></strong><span class="koboSpan" id="kobo.36.1"> file with some useful helper functions. </span><span class="koboSpan" id="kobo.36.2">Note that following the </span><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">README</span></strong><span class="koboSpan" id="kobo.38.1"> guide will temporarily break the create and edit expense and income form actions. </span><span class="koboSpan" id="kobo.38.2">We will update the code in this chapter. </span><span class="koboSpan" id="kobo.38.3">Until then, use the seed data to populate the database for </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">testing purposes.</span></span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.40.1">Working with search parameters</span></h1>
<p><span class="koboSpan" id="kobo.41.1">The URL stores</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.42.1"> information about the user’s current location. </span><span class="koboSpan" id="kobo.42.2">We already utilize dynamic route parameters for expense and invoice identifiers. </span><span class="koboSpan" id="kobo.42.3">Similarly, we can use URL search parameters to store additional </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">application states.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">A URL is the perfect place to persist state that concerns only one or a few pages. </span><span class="koboSpan" id="kobo.44.2">In this section, we will use URL search parameters to create a search filter on the expense overview page </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">in BeeRich.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">Did you know that Google uses a search parameter to implement search queries? </span><span class="koboSpan" id="kobo.46.2">Open </span><a href="http://google.com"><span class="koboSpan" id="kobo.47.1">google.com</span></a><span class="koboSpan" id="kobo.48.1"> and use the search input field to start a new Google search. </span><span class="koboSpan" id="kobo.48.2">After pressing </span><em class="italic"><span class="koboSpan" id="kobo.49.1">Enter</span></em><span class="koboSpan" id="kobo.50.1">, Google navigates you to the search results page. </span><span class="koboSpan" id="kobo.50.2">If you inspect the URL, you will see that Google uses a search parameter called </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">q</span></strong><span class="koboSpan" id="kobo.52.1"> (short for query probably) to store your search </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">query: </span></span><a href="https://www.google.com/search?q=Using+search+params+in+Remix.run"><span class="No-Break"><span class="koboSpan" id="kobo.54.1">https://www.google.com/search?q=Using+search+params+in+Remix.run</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.55.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">Search parameters are key-value pairs that are added to the URL after the pathname following a question mark (</span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">?</span></strong><span class="koboSpan" id="kobo.58.1">) and appended via ampersands (</span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">&amp;</span></strong><span class="koboSpan" id="kobo.60.1">). </span><span class="koboSpan" id="kobo.60.2">Search parameters allow us to store additional optional application states outside of the </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">URL path.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">Let’s build an experience similar to Google Search in BeeRich to filter the expense list through a </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">search filter.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.64.1">Reading search parameters in loader functions</span></h2>
<p><span class="koboSpan" id="kobo.65.1">The </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.66.1">expenses list is fetched and rendered in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">dashboard.expenses.tsx</span></strong><span class="koboSpan" id="kobo.68.1"> route module. </span><span class="koboSpan" id="kobo.68.2">Now, we want to allow users to filter the list by using a search </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">input field.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">We can divide the work into </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">two steps:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.72.1">Update the database query so that it filters by a </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">search query.</span></span></li>
<li><span class="koboSpan" id="kobo.74.1">Provide the user with the UI so that they can enter </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">search queries.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.76.1">First, let’s update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">loader</span></strong><span class="koboSpan" id="kobo.78.1"> function. </span><span class="koboSpan" id="kobo.78.2">The goal is to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">loader</span></strong><span class="koboSpan" id="kobo.80.1"> function so that it only fetches expenses that match the query string provided through the </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">request URL:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.82.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">dashboard.expenses.tsx</span></strong><span class="koboSpan" id="kobo.84.1"> route module in your editor and inspect the module’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">loader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.86.1"> function.</span></span></li>
<li><span class="koboSpan" id="kobo.87.1">First, add</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.88.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">request</span></strong><span class="koboSpan" id="kobo.90.1"> parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">loader</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.92.1">function arguments:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.93.1">
import type { </span><strong class="bold"><span class="koboSpan" id="kobo.94.1">LoaderFunctionArgs</span></strong><span class="koboSpan" id="kobo.95.1"> } from '@remix-run/node';export async function loader(</span><strong class="bold"><span class="koboSpan" id="kobo.96.1">{ request }: LoaderFunctionArgs</span></strong><span class="koboSpan" id="kobo.97.1">)</span></pre></li> <li><span class="koboSpan" id="kobo.98.1">Next, access the URL string of the request to create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">URL</span></strong><span class="koboSpan" id="kobo.100.1"> object and get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">q</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.102.1">search parameter:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.103.1">
export async function loader({ request }: LoaderFunctionArgs) {  </span><strong class="bold"><span class="koboSpan" id="kobo.104.1">const url = new URL(request.url);</span></strong><span class="koboSpan" id="kobo.105.1">  </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">const searchString = url.searchParams.get('q');</span></strong><span class="koboSpan" id="kobo.107.1">  const expenses = await db.expense.findMany({    orderBy: {      createdAt: 'desc',    },  });  return json(expenses);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.108.1">Following Google’s implementation, we call the parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">q</span></strong><span class="koboSpan" id="kobo.110.1"> - short for query. </span><span class="koboSpan" id="kobo.110.2">You can find more information about the URL interface in the MDN Web </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">Docs: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/API/URL"><span class="No-Break"><span class="koboSpan" id="kobo.112.1">https://developer.mozilla.org/en-US/docs/Web/API/URL</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.113.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.114.1">Update the database query so that it only returns the expenses where the title contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">search string:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.116.1">
const expenses = await db.expense.findMany({  orderBy: {    createdAt: 'desc',  },  where: {    title: {      contains: searchString ? </span><span class="koboSpan" id="kobo.116.2">searchString : '',    },  },});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.117.1">If the </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.118.1">URL does not contain a query string, we search against an empty string, which matches all expenses. </span><span class="koboSpan" id="kobo.118.2">In this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">loader</span></strong><span class="koboSpan" id="kobo.120.1"> function behaves </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">as before.</span></span></p></li> <li><span class="koboSpan" id="kobo.122.1">Run BeeRich in development mode by executing </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">npm run dev</span></strong><span class="koboSpan" id="kobo.124.1"> in a terminal and navigate to the expenses overview </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">page (</span></span><a href="http://localhost:3000/dashboard/expenses"><span class="No-Break"><span class="koboSpan" id="kobo.126.1">http://localhost:3000/dashboard/expenses</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.127.1">).</span></span><p class="list-inset"><span class="koboSpan" id="kobo.128.1">Since we didn’t include a query string in the URL, we still return the full list </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">of expenses.</span></span></p></li>
<li><span class="koboSpan" id="kobo.130.1">Next, update the URL in the URL bar by adding a query string such as </span><a href="http://localhost:3000/dashboard/expenses?q=Groceries"><span class="koboSpan" id="kobo.131.1">http://localhost:3000/dashboard/expenses?q=Groceries</span></a><span class="koboSpan" id="kobo.132.1"> and refresh the page. </span><span class="koboSpan" id="kobo.132.2">It should now display a filtered list </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">of expenses.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.134.1">Great! </span><span class="koboSpan" id="kobo.134.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">loader</span></strong><span class="koboSpan" id="kobo.136.1"> function now handles the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">q</span></strong><span class="koboSpan" id="kobo.138.1"> search parameters when present and returns a filtered list of expenses. </span><span class="koboSpan" id="kobo.138.2">Next, let’s add a search input field to let the user search for </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">specific expenses.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.140.1">Updating search parameters with form submissions</span></h2>
<p><span class="koboSpan" id="kobo.141.1">Next, we’ll </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.142.1">provide the user with a search </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">input field:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.144.1">Optionally, disable JavaScript to ensure the base implementation works without </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">client-side JavaScript.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.146.1">You can disable JavaScript in your browser’s developer tools or by removing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">Script</span></strong><span class="koboSpan" id="kobo.148.1"> component </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">root.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">.</span></span></p></li>
<li><span class="koboSpan" id="kobo.152.1">Import Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">Form</span></strong><span class="koboSpan" id="kobo.154.1"> component </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">@remix-run/react</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.158.1">
import { useNavigation, Outlet, useLoaderData, useParams, </span><strong class="bold"><span class="koboSpan" id="kobo.159.1">Form</span></strong><span class="koboSpan" id="kobo.160.1"> } from '@remix-run/react';</span></pre></li> <li><span class="koboSpan" id="kobo.161.1">Import BeeRich’s styled </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">Input</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.163.1"> component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.164.1">
import { Input } from '~/components/forms';</span></pre></li> <li><span class="koboSpan" id="kobo.165.1">Next, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">Form</span></strong><span class="koboSpan" id="kobo.167.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">Input</span></strong><span class="koboSpan" id="kobo.169.1"> components to implement a search input field between the </span><strong class="bold"><span class="koboSpan" id="kobo.170.1">All expenses</span></strong><span class="koboSpan" id="kobo.171.1"> screenreader heading and the unordered list </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">of expenses:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.173.1">
&lt;h2 className="sr-only"&gt;All expenses&lt;/h2&gt;&lt;Form </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">method="GET"</span></strong><span class="koboSpan" id="kobo.175.1">&gt;  &lt;Input </span><strong class="bold"><span class="koboSpan" id="kobo.176.1">name="q"</span></strong><span class="koboSpan" id="kobo.177.1"> type="search" label="Search by title" /&gt;&lt;/Form&gt;&lt;ul className="flex flex-col"&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.178.1">Note that the search form does not mutate data. </span><span class="koboSpan" id="kobo.178.2">We use the form to navigate to a new page with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">q</span></strong><span class="koboSpan" id="kobo.180.1"> search parameter. </span><span class="koboSpan" id="kobo.180.2">For this, we set the form method to </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">GET</span></strong><span class="koboSpan" id="kobo.182.1"> to perform an HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">GET request.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.184.1">Conveniently, by default, a form submission appends the form data as search parameters to the request URL. </span><span class="koboSpan" id="kobo.184.2">We add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">name</span></strong><span class="koboSpan" id="kobo.186.1"> attribute to the input field as only named input fields are part of </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">the submission.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.188.1">We still have one problem to solve: since the search form is rendered on a layout parent route, it is visible on several pages. </span><span class="koboSpan" id="kobo.188.2">By default, the form submits and navigates to </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">/dashboard/expenses</span></strong><span class="koboSpan" id="kobo.190.1">. </span><span class="koboSpan" id="kobo.190.2">However, we would like the user to remain on their </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">current page.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.192.1">Since</span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.193.1"> we are not targeting a specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">action</span></strong><span class="koboSpan" id="kobo.195.1"> function, we can point the form action to the current URL path. </span><span class="koboSpan" id="kobo.195.2">This ensures that a form submission does not redirect users away from their </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">current page.</span></span></p></li> <li><span class="koboSpan" id="kobo.197.1">Import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">useLocation</span></strong><span class="koboSpan" id="kobo.199.1"> hook from Remix to access the current </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">URL path:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.201.1">
import { Form, Outlet, useLoaderData, </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">useLocation</span></strong><span class="koboSpan" id="kobo.203.1">, useNavigation, useParams } from '@remix-run/react';</span></pre></li> <li><span class="koboSpan" id="kobo.204.1">Access the location in the function body of the </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">route component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.206.1">
const location = useLocation();</span></pre></li> <li><span class="koboSpan" id="kobo.207.1">Use the path of the current location to set the form’s </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">action dynamically:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.209.1">
&lt;Form method="GET" </span><strong class="bold"><span class="koboSpan" id="kobo.210.1">action={location.pathname}</span></strong><span class="koboSpan" id="kobo.211.1">&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.212.1">A submission now creates a GET request to the current page with an updated search parameter to filter the list </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">of expenses.</span></span></p></li> <li><span class="koboSpan" id="kobo.214.1">Try out the new search input field by typing a search query and hitting </span><em class="italic"><span class="koboSpan" id="kobo.215.1">Enter</span></em><span class="koboSpan" id="kobo.216.1"> to submit </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">the form.</span></span></li>
<li><span class="koboSpan" id="kobo.218.1">Note that the search input field is empty after every full-page reload, even when a </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">q</span></strong><span class="koboSpan" id="kobo.220.1"> search parameter </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">is set.</span></span></li>
<li><span class="koboSpan" id="kobo.222.1">Import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">useSearchParams</span></strong><span class="koboSpan" id="kobo.224.1"> hook </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">from Remix:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.226.1">
import { Form, Outlet, useLoaderData, useLocation, useNavigation, useParams, </span><strong class="bold"><span class="koboSpan" id="kobo.227.1">useSearchParams</span></strong><span class="koboSpan" id="kobo.228.1"> } from '@remix-run/react';</span></pre></li> <li><span class="koboSpan" id="kobo.229.1">Retrieve</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.230.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">q</span></strong><span class="koboSpan" id="kobo.232.1"> search parameter in the </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">route component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.234.1">
const [searchParams] = useSearchParams();const searchQuery = searchParams.get('q') || '';</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.235.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">searchParams</span></strong><span class="koboSpan" id="kobo.237.1"> object implements the web's </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">URLSearchParams</span></strong><span class="koboSpan" id="kobo.239.1"> interface that we also use in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">loader</span></strong><span class="koboSpan" id="kobo.241.1"> function when accessing the </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">URL's </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">searchParams</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.245.1">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">searchQuery</span></strong><span class="koboSpan" id="kobo.247.1"> value as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">defaultValue</span></strong><span class="koboSpan" id="kobo.249.1"> property for the </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">input field:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.251.1">
&lt;Input name="q" type="search" label="Search by title" </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">defaultValue={searchQuery}</span></strong><span class="koboSpan" id="kobo.253.1"> /&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.254.1">The input field’s value is now set to the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">searchQuery</span></strong><span class="koboSpan" id="kobo.256.1"> by default, even during </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">server-side rendering:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.258.1"><img alt="Figure 8.1 – Screenshot of the filtered expenses list" src="image/Figure_8.01_B17399.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.259.1">Figure 8.1 – Screenshot of the filtered expenses list</span></p>
<p><span class="koboSpan" id="kobo.260.1">Great! </span><span class="koboSpan" id="kobo.260.2">Hitting </span><em class="italic"><span class="koboSpan" id="kobo.261.1">Enter</span></em><span class="koboSpan" id="kobo.262.1"> after</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.263.1"> typing a search query submits the form and updates the URL so that it includes the search query. </span><span class="koboSpan" id="kobo.263.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">loader</span></strong><span class="koboSpan" id="kobo.265.1"> function then returns an updated filtered list of expenses. </span><span class="koboSpan" id="kobo.265.2">Note that we didn’t use any React state to implement this feature, and as always, the search feature also works </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">without JavaScript.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.267.1">Mapping UIs to URLs</span></p>
<p class="callout"><span class="koboSpan" id="kobo.268.1">The advantage of search parameters over React state is that they can be accessed on the server by reading from the request URL. </span><span class="koboSpan" id="kobo.268.2">Search parameters persist on full-page reloads and work with the browser’s back and forward buttons. </span><span class="koboSpan" id="kobo.268.3">Additionally, search parameters create URL variants that CDNs and browsers </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">can cache.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">Implement the same behavior for the income overview route. </span><span class="koboSpan" id="kobo.270.2">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">dashboard.income.tsx</span></strong><span class="koboSpan" id="kobo.272.1"> route module’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">loader</span></strong><span class="koboSpan" id="kobo.274.1"> function and implement the search form to query invoices. </span><span class="koboSpan" id="kobo.274.2">Once the income route has been updated, we can enhance the experience with </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">custom JavaScript.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.276.1">Programmatically submitting forms</span></h2>
<p><span class="koboSpan" id="kobo.277.1">Currently, the </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.278.1">user needs to press </span><em class="italic"><span class="koboSpan" id="kobo.279.1">Enter</span></em><span class="koboSpan" id="kobo.280.1"> to trigger a new search. </span><span class="koboSpan" id="kobo.280.2">Let’s add a debounced search that submits the form automatically whenever the user changes the value in the </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">input field:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.282.1">First, import </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">useSubmit</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.284.1">from Remix:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.285.1">
import {  Form,  Outlet,  useLoaderData,  useLocation,  useNavigation,  useParams,  useSearchParams,  </span><strong class="bold"><span class="koboSpan" id="kobo.286.1">useSubmit</span></strong><span class="koboSpan" id="kobo.287.1">,} from '@remix-run/react';</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.288.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">useSubmit</span></strong><span class="koboSpan" id="kobo.290.1"> hook lets us submit forms programmatically. </span><span class="koboSpan" id="kobo.290.2">You might remember that </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">useFetcher</span></strong><span class="koboSpan" id="kobo.292.1"> also offers a </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">submit</span></strong><span class="koboSpan" id="kobo.294.1"> function. </span><span class="koboSpan" id="kobo.294.2">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">useSubmit</span></strong><span class="koboSpan" id="kobo.296.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">useFetcher().submit</span></strong><span class="koboSpan" id="kobo.298.1"> allow us to submit </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">forms programmatically.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.300.1">Fetcher submissions behave like </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">fetch</span></strong><span class="koboSpan" id="kobo.302.1"> requests and do not trigger global transitions in Remix. </span><span class="koboSpan" id="kobo.302.2">They don’t affect the global </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">useNavigation</span></strong><span class="koboSpan" id="kobo.304.1"> state or initiate page navigations. </span><span class="koboSpan" id="kobo.304.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">useSubmit</span></strong><span class="koboSpan" id="kobo.306.1"> hook mimics Remix’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">Form</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.308.1"> behavior.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.309.1">In our case, we use Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">Form</span></strong><span class="koboSpan" id="kobo.311.1"> component for the search and want to retrigger the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">/dashboard/expenses</span></strong><span class="koboSpan" id="kobo.313.1"> route module’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">loader</span></strong><span class="koboSpan" id="kobo.315.1"> function so that the loader data updates. </span><span class="koboSpan" id="kobo.315.2">For such cases, we want to use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">useSubmit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.317.1"> hook.</span></span></p></li> <li><span class="koboSpan" id="kobo.318.1">In the</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.319.1"> route module’s component body, create a new submit function by </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">useSubmit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.323.1">
  const submit = useSubmit();</span></pre></li> <li><span class="koboSpan" id="kobo.324.1">Add the following change event handler to the </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">search input:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.326.1">
Replace code example with just this line:onChange={(e) =&gt; submit(e.target.form)}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.327.1">On change, we programmatically submit the form using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">submit</span></strong><span class="koboSpan" id="kobo.329.1"> function. </span><span class="koboSpan" id="kobo.329.2">We pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">submit</span></strong><span class="koboSpan" id="kobo.331.1"> the HTML form element, accessing it from the event's </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">target object.</span></span></p></li> <li><span class="koboSpan" id="kobo.333.1">Try out the current implementation and type something into the search </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">input field.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.335.1">You may notice that we are currently submitting a new form for every change event. </span><span class="koboSpan" id="kobo.335.2">This is not very efficient. </span><span class="koboSpan" id="kobo.335.3">Instead, we should delay the submission until the user finishes typing. </span><span class="koboSpan" id="kobo.335.4">This method of delaying a function call is </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">called debouncing.</span></span></p></li>
<li><span class="koboSpan" id="kobo.337.1">Replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">Input</span></strong> <a id="_idIndexMarker336"/><span class="No-Break"><span class="koboSpan" id="kobo.339.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">SearchInput</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.342.1">
import { </span><strong class="bold"><span class="koboSpan" id="kobo.343.1">SearchInput</span></strong><span class="koboSpan" id="kobo.344.1"> } from '~/components/forms';</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.345.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">SearchInput</span></strong><span class="koboSpan" id="kobo.347.1"> component adds debouncing with a 500-millisecond delay. </span><span class="koboSpan" id="kobo.347.2">Refer to the implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">/app/components/forms.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.351.1">Now, update the JSX so that it renders </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">SearchInput</span></strong><span class="koboSpan" id="kobo.353.1"> instead of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">Input</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.355.1"> component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.356.1">
&lt;</span><strong class="bold"><span class="koboSpan" id="kobo.357.1">SearchInput</span></strong><span class="koboSpan" id="kobo.358.1"> name="q" type="search" label="Search by title" defaultValue={searchQuery} /&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.359.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">SearchInput</span></strong><span class="koboSpan" id="kobo.361.1"> component uses Remix's </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">useSubmit</span></strong><span class="koboSpan" id="kobo.363.1"> hook to programmatically submit the form that it is embedded in after a timeout once the user </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">finishes typing.</span></span></p></li> <li><span class="koboSpan" id="kobo.365.1">Since the submission is now handled inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">SearchInput</span></strong><span class="koboSpan" id="kobo.367.1"> component, remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">useSubmit</span></strong><span class="koboSpan" id="kobo.369.1"> hook from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">dashboard.expenses.tsx</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.371.1">route module.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.372.1">You now know three ways of submitting data in Remix: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">Form</span></strong><span class="koboSpan" id="kobo.374.1"> component, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">useFetcher</span></strong><span class="koboSpan" id="kobo.376.1"> hook, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">useSubmit</span></strong><span class="koboSpan" id="kobo.378.1"> hook. </span><span class="koboSpan" id="kobo.378.2">This raises the question of when to best use </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">which utility.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.380.1">When to use Remix data fetching primitives</span></p>
<p class="callout"><span class="koboSpan" id="kobo.381.1">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">Form</span></strong><span class="koboSpan" id="kobo.383.1"> component for the main interactions on the page. </span><span class="koboSpan" id="kobo.383.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">Form</span></strong><span class="koboSpan" id="kobo.385.1"> component is the most straightforward way to implement a form interaction in Remix. </span><span class="koboSpan" id="kobo.385.2">Stick with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">Form</span></strong><span class="koboSpan" id="kobo.387.1"> component for all simple </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">use cases.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.389.1">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">useSubmit</span></strong><span class="koboSpan" id="kobo.391.1"> hook when you want to programmatically submit a </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">Form</span></strong><span class="koboSpan" id="kobo.393.1"> component (for example, on change). </span><span class="koboSpan" id="kobo.393.2">You can add </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">useSubmit</span></strong><span class="koboSpan" id="kobo.395.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">Form</span></strong><span class="koboSpan" id="kobo.397.1"> implementations to enhance the </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">experience progressively.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.399.1">Remember that there can only ever be one active navigation at a time. </span><span class="koboSpan" id="kobo.399.2">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">useFetcher</span></strong><span class="koboSpan" id="kobo.401.1"> hook to implement a list of forms, or aside user interactions, that should support concurrent submissions. </span><span class="koboSpan" id="kobo.401.2">Aside interactions are usually not meant to trigger page navigations and should have access to isolated navigation states and action data. </span><span class="koboSpan" id="kobo.401.3">Whenever you want to trigger a </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">useFetcher</span></strong><span class="koboSpan" id="kobo.403.1"> hook’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Form</span></strong><span class="koboSpan" id="kobo.405.1"> component programmatically, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">useFetcher.load</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.407.1">and</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.408.1"> useFetcher.submit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">In this</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.411.1"> section, you learned how to handle application state with the URL. </span><span class="koboSpan" id="kobo.411.2">You also learned that forms can execute GET requests by setting the form method to </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">"GET"</span></strong><span class="koboSpan" id="kobo.413.1">. </span><span class="koboSpan" id="kobo.413.2">Finally, you practiced how to programmatically submit a form </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">useSubmit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">Ensure you update the income route to practice what you’ve learned in this section. </span><span class="koboSpan" id="kobo.417.2">Once you’ve done that, we can start investigating how to handle user sessions </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">with cookies.</span></span></p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.419.1">Creating user sessions with cookies</span></h1>
<p><span class="koboSpan" id="kobo.420.1">A session maintains</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.421.1"> the state of a user’s interactions with a web application across multiple requests. </span><span class="koboSpan" id="kobo.421.2">Sessions track information such as user authentication credentials, shopping cart contents, color scheme preferences, and other user-specific data. </span><span class="koboSpan" id="kobo.421.3">In this section, we will use Remix’s session cookie helpers to create a login and signup flow </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">in BeeRich.</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">One way to manage sessions is via cookies. </span><span class="koboSpan" id="kobo.423.2">Cookies contain small pieces of data and are appended to both document and fetch requests, making them a great way to handle user sessions, personalization, and tracking. </span><span class="koboSpan" id="kobo.423.3">Additionally, cookies can be encrypted to securely carry user credentials without </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">client access.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">Cookies are part of the HTTP protocol and enable persisting information in the otherwise stateless HTTP protocol. </span><span class="koboSpan" id="kobo.425.2">Where URL search parameters are visible to the user and can be </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.426.1">bookmarked and shared, cookie data can be encrypted and are then only accessible on the server. </span><span class="koboSpan" id="kobo.426.2">Search parameters are handy for storing application states that are not tied to specific users. </span><span class="koboSpan" id="kobo.426.3">Cookies are ideal for authenticating users and storing small chunks of private </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">session data.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">A web server can append a cookie to the current session by setting the </span><strong class="bold"><span class="koboSpan" id="kobo.429.1">Set-Cookie</span></strong><span class="koboSpan" id="kobo.430.1"> header on the HTTP response. </span><span class="koboSpan" id="kobo.430.2">Once a cookie has been set, the browser attaches the cookie using the </span><strong class="bold"><span class="koboSpan" id="kobo.431.1">Cookie</span></strong><span class="koboSpan" id="kobo.432.1"> header to all subsequent requests based on the lifetime specified during </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">cookie setup.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">Remix provides two different abstractions to work </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">with cookies:</span></span></p>
<ol>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">createCookie</span></strong><span class="koboSpan" id="kobo.437.1"> to read and </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">write cookies</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">createCookieSessionStorage</span></strong><span class="koboSpan" id="kobo.440.1"> to implement a session storage using </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">a cookie</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.442.1">In this chapter, we will use Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">createCookieSessionStorage</span></strong><span class="koboSpan" id="kobo.444.1"> function since our goal is to implement user sessions for authentication and authorization. </span><span class="koboSpan" id="kobo.444.2">We will have a look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">createCookie</span></strong><span class="koboSpan" id="kobo.446.1"> helper function in </span><a href="B17399_15.xhtml#_idTextAnchor214"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.447.1">Chapter 15</span></em></span></a><span class="koboSpan" id="kobo.448.1">, </span><em class="italic"><span class="koboSpan" id="kobo.449.1">Advanced Session Management,</span></em><span class="koboSpan" id="kobo.450.1"> to persist visitor </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">tracking data.</span></span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.452.1">Working with Remix’s session helpers</span></h2>
<p><span class="koboSpan" id="kobo.453.1">Let’s implement the</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.454.1"> register and login pages </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">in BeeRich:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.456.1">First, follow the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">README.md</span></strong><span class="koboSpan" id="kobo.458.1"> file in this chapter’s folder on GitHub to prepare BeeRich for </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">this section.</span></span></li>
<li><span class="koboSpan" id="kobo.460.1">Once you’ve followed the setup guide in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">README.md</span></strong><span class="koboSpan" id="kobo.462.1"> file, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">modules/session/session.server.ts</span></strong><span class="koboSpan" id="kobo.464.1"> file in </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">your editor.</span></span></li>
<li><span class="koboSpan" id="kobo.466.1">Next, import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">createCookieSessionStorage</span></strong><span class="koboSpan" id="kobo.468.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">redirect</span></strong><span class="koboSpan" id="kobo.470.1"> helper functions </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">from Remix:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.472.1">
import { </span><strong class="bold"><span class="koboSpan" id="kobo.473.1">createCookieSessionStorage</span></strong><span class="koboSpan" id="kobo.474.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.475.1">redirect</span></strong><span class="koboSpan" id="kobo.476.1"> } from '@remix-run/node'</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.477.1">Remix provides session helper functions for different session management strategies. </span><span class="koboSpan" id="kobo.477.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">createCookieSessionStorage</span></strong><span class="koboSpan" id="kobo.479.1"> helper function builds on top of Remix’s cookie helpers to store session data in </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">a cookie.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.481.1">Refer to </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.482.1">the Remix documentation for alternative session helpers. </span><span class="koboSpan" id="kobo.482.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">createMemorySessionStorage</span></strong><span class="koboSpan" id="kobo.484.1"> manages session data in the server’s memory; </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">createSessionStorage</span></strong><span class="koboSpan" id="kobo.486.1"> is more generic and allows us to retrieve session data from a custom storage implementation while storing only the session identifier in </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">a cookie.</span></span></p></li> <li><span class="koboSpan" id="kobo.488.1">Now, add the following code below the already existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">registerUser</span></strong><span class="koboSpan" id="kobo.490.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">loginUser</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.492.1"> functions:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.493.1">
const sessionSecret = process.env.</span><strong class="bold"><span class="koboSpan" id="kobo.494.1">SESSION_SECRET</span></strong><span class="koboSpan" id="kobo.495.1">;if (!sessionSecret) {  throw new Error('SESSION_SECRET must be set');}const { </span><strong class="bold"><span class="koboSpan" id="kobo.496.1">getSession</span></strong><span class="koboSpan" id="kobo.497.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.498.1">commitSession</span></strong><span class="koboSpan" id="kobo.499.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.500.1">destroySession</span></strong><span class="koboSpan" id="kobo.501.1"> } = createCookieSessionStorage({  cookie: {    name: 'bee-rich-session',    secure: process.env.NODE_ENV === 'production',    secrets: [sessionSecret],    sameSite: 'lax',    path: '/',    maxAge: 60 * 60 * 24 * 30,    httpOnly: true,  },});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.502.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">createCookieSessionStorage</span></strong><span class="koboSpan" id="kobo.504.1"> helper function to create a session storage object. </span><span class="koboSpan" id="kobo.504.2">The object contains three functions to help us manage the lifecycle of our </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">user sessions.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.506.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">createCookieSessionStorage</span></strong><span class="koboSpan" id="kobo.508.1"> function expects a cookie configuration object to set the session cookie’s lifetime (</span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">maxAge</span></strong><span class="koboSpan" id="kobo.510.1">), its access rules (</span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">secure</span></strong><span class="koboSpan" id="kobo.512.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">sameSite</span></strong><span class="koboSpan" id="kobo.514.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">path</span></strong><span class="koboSpan" id="kobo.516.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">httpOnly</span></strong><span class="koboSpan" id="kobo.518.1">), and signing secrets (</span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">secrets</span></strong><span class="koboSpan" id="kobo.520.1">). </span><span class="koboSpan" id="kobo.520.2">You can refer to the Remix documentation for more </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.521.1">information about the </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">configuration options.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.523.1">We set the cookie to expire after 30 days, meaning it will be automatically deleted after that period. </span><span class="koboSpan" id="kobo.523.2">By setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">httpOnly</span></strong><span class="koboSpan" id="kobo.525.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">true</span></strong><span class="koboSpan" id="kobo.527.1">, we ensure that the cookie cannot be read by the client, enhancing security. </span><span class="koboSpan" id="kobo.527.2">We also use secrets to sign the cookie, adding an extra layer </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">of verification.</span></span></p></li> <li><span class="koboSpan" id="kobo.529.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">.env</span></strong><span class="koboSpan" id="kobo.531.1"> file in your project’s root folder and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">SESSION_SECRET</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.533.1">environment variable:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.534.1">
SESSION_SECRET="[A secret string]"</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.535.1">HTTP cookie signing involves adding a cryptographic signature to a cookie using a secret key known only to the server. </span><span class="koboSpan" id="kobo.535.2">When the client sends this signed cookie back in future requests, the server uses the secret key to verify that the cookie has not been tampered with. </span><span class="koboSpan" id="kobo.535.3">This adds an extra layer </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">of security.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.537.1">We read the environment variables when first starting our server environment. </span><span class="koboSpan" id="kobo.537.2">Make sure you restart your development server in case it is currently running to ensure the new environment variable is </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">picked up.</span></span></p></li> <li><span class="koboSpan" id="kobo.539.1">Finally, add the following helper function to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">session.server.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.541.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.542.1">
export async function createUserSession(user: User, headers = new Headers()) {  const session = await </span><strong class="bold"><span class="koboSpan" id="kobo.543.1">getSession</span></strong><span class="koboSpan" id="kobo.544.1">();  session.set('userId', user.id);  headers.set('Set-Cookie', await </span><strong class="bold"><span class="koboSpan" id="kobo.545.1">commitSession</span></strong><span class="koboSpan" id="kobo.546.1">(session));  return headers;}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.547.1">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">createUserSession</span></strong><span class="koboSpan" id="kobo.549.1"> to initiate the session cookie after successful registration </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">or login.</span></span></p><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">createUserSession</span></strong><span class="koboSpan" id="kobo.552.1"> expects a user object and an optional </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">headers</span></strong><span class="koboSpan" id="kobo.554.1"> parameter. </span><span class="koboSpan" id="kobo.554.2">The function then calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">getSession</span></strong><span class="koboSpan" id="kobo.556.1"> to create a new session object for the current user. </span><span class="koboSpan" id="kobo.556.2">We add </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">userId</span></strong><span class="koboSpan" id="kobo.558.1"> to the session object and use </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">commitSession</span></strong><span class="koboSpan" id="kobo.560.1"> to parse the object into a cookie value. </span><span class="koboSpan" id="kobo.560.2">We set the cookie to the </span><strong class="bold"><span class="koboSpan" id="kobo.561.1">Set-Cookie</span></strong><span class="koboSpan" id="kobo.562.1"> header and return the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">Headers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.564.1"> object.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.565.1">Note that </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.566.1">cookies can only store a small amount of data (a few KB). </span><span class="koboSpan" id="kobo.566.2">Hence, we only store </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">userId</span></strong><span class="koboSpan" id="kobo.568.1">. </span><span class="koboSpan" id="kobo.568.2">When storing more data, it might make sense to store the session data in a database and only store a session identifier in the session cookie (for example, using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">createSessionStorage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.570.1"> helper).</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.571.1">Now that we can create new user sessions, let’s implement a signup flow to register </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">new users.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.573.1">Adding a user registration flow</span></h2>
<p><span class="koboSpan" id="kobo.574.1">In this section, we </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.575.1">will apply what we have learned thus far to implemnet a registration form and associated </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">action</span></strong><span class="koboSpan" id="kobo.577.1"> function. </span><span class="koboSpan" id="kobo.577.2">Before reading through the solution, I encourage you to try it yourself. </span><span class="koboSpan" id="kobo.577.3">Start by updating the signup route module component. </span><span class="koboSpan" id="kobo.577.4">Then, add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">action</span></strong><span class="koboSpan" id="kobo.579.1"> function and parse the </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">form data.</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">Now, let’s go through the implementation step </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">by step:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.583.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">_layout.signup.tsx</span></strong><span class="koboSpan" id="kobo.585.1"> route module and update the route </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">module component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.587.1">
import { useNavigation } from '@remix-run/react';import { Button } from '~/components/buttons';import { Card } from '~/components/containers';import { Form, Input } from '~/components/forms';import { H1 } from '~/components/headings';export default function Component() {  const navigation = useNavigation();  const isSubmitting = navigation.state !== 'idle' &amp;&amp;    navigation.formAction === '/signup';  return (    &lt;Card&gt;      &lt;Form method="POST" action="/signup"&gt;        &lt;H1&gt;Sign Up&lt;/H1&gt;        &lt;Input label="Name:" name="name" required /&gt;        &lt;Input label="Email:" name="email" type="email" required          /&gt;        &lt;Input label="Password:" name="password" type="password"          required /&gt;        &lt;Button disabled={isSubmitting} type="submit" isPrimary&gt;          {isSubmitting ? </span><span class="koboSpan" id="kobo.587.2">'Signing you up...' </span><span class="koboSpan" id="kobo.587.3">: 'Sign up!'}        &lt;/Button&gt;      &lt;/Form&gt;    &lt;/Card&gt;  );}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.588.1">Note that we use some reusable components to add our custom styles. </span><span class="koboSpan" id="kobo.588.2">Also, note that we set the form method to POST. </span><span class="koboSpan" id="kobo.588.3">A signup flow mutates data and must not be a GET request. </span><span class="koboSpan" id="kobo.588.4">Finally, we again utilize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">useNavigation</span></strong><span class="koboSpan" id="kobo.590.1"> hook to add pending indicators when the form </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">is submitting.</span></span></p></li> <li><span class="koboSpan" id="kobo.592.1">Next, add</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.593.1"> an </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">action</span></strong><span class="koboSpan" id="kobo.595.1"> function to handle registration </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">form submissions:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.597.1">
import type { ActionFunctionArgs } from '@remix-run/node';import { json, redirect } from '@remix-run/node';import { createUserSession, registerUser } from '~/modules/session/session.server';export async function action({ request }: ActionFunctionArgs) {  </span><strong class="bold"><span class="koboSpan" id="kobo.598.1">const formData = await request.formData();</span></strong><span class="koboSpan" id="kobo.599.1">  const { name, email, password } = Object.fromEntries    (formData);  if (!name || !email || !password) {    return json({ error: 'Please fill out all fields.' </span><span class="koboSpan" id="kobo.599.2">});  }  if (typeof name !== 'string' || typeof email !== 'string' ||    typeof password !== 'string') {    throw new Error('Invalid form data.');  }  try {    </span><strong class="bold"><span class="koboSpan" id="kobo.600.1">const user = await registerUser({ name, email, password });</span></strong><span class="koboSpan" id="kobo.601.1">    return redirect('/dashboard', {      headers: </span><strong class="bold"><span class="koboSpan" id="kobo.602.1">await createUserSession(user)</span></strong><span class="koboSpan" id="kobo.603.1">,    });  } catch (error: any) {    return json(</span><strong class="bold"><span class="koboSpan" id="kobo.604.1">{ error: error?.message || 'Something went      wrong.' </span><span class="koboSpan" id="kobo.604.2">}</span></strong><span class="koboSpan" id="kobo.605.1">);  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.606.1">First, we </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.607.1">parse the form data from the request object. </span><span class="koboSpan" id="kobo.607.2">Then, we validate the form data and ensure that all required fields are present and of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">string</span></strong><span class="koboSpan" id="kobo.609.1">. </span></p><p class="list-inset"><span class="koboSpan" id="kobo.610.1">Once the data has been validated, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">registerUser</span></strong><span class="koboSpan" id="kobo.612.1"> function to create a new user object or throw an error if the user already exists in the database. </span><span class="koboSpan" id="kobo.612.2">If the creation is successful, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">createUserSession</span></strong><span class="koboSpan" id="kobo.614.1"> to add the session cookie to the response headers. </span><span class="koboSpan" id="kobo.614.2">Otherwise, we return an </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">error response.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.616.1">On success, we redirect the user to the dashboard. </span><span class="koboSpan" id="kobo.616.2">On error, we return the error message as action data. </span><span class="koboSpan" id="kobo.616.3">Next, let's display the error message to </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">the users.</span></span></p></li> <li><span class="koboSpan" id="kobo.618.1">Import </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">useActionData</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.620.1">from Remix:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.621.1">
import { </span><strong class="bold"><span class="koboSpan" id="kobo.622.1">useActionData</span></strong><span class="koboSpan" id="kobo.623.1">, useNavigation } from '@remix-run/react';</span></pre></li> <li><span class="koboSpan" id="kobo.624.1">Access the error message action data in the </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">route component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.626.1">
const actionData = useActionData&lt;typeof action&gt;();</span></pre></li> <li><span class="koboSpan" id="kobo.627.1">Import our styled inline </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">error component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.629.1">
import { InlineError } from '~/components/texts';</span></pre></li> <li><span class="koboSpan" id="kobo.630.1">Render the </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">InlineError</span></strong><span class="koboSpan" id="kobo.632.1"> component below the submit button to display any </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">error messages:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.634.1">
&lt;InlineError aria-live="assertive"&gt;{</span><strong class="bold"><span class="koboSpan" id="kobo.635.1">actionData?.error &amp;&amp; actionData.error</span></strong><span class="koboSpan" id="kobo.636.1">}&lt;/InlineError&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.637.1">Try out</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.638.1"> the registration flow by running the application with </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">npm run dev</span></strong><span class="koboSpan" id="kobo.640.1"> and visiting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">signup</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.643.1"> page.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.644.1">After form submission, you should be redirected to the dashboard. </span><span class="koboSpan" id="kobo.644.2">Great! </span><span class="koboSpan" id="kobo.644.3">But what if we want to log out? </span><span class="koboSpan" id="kobo.644.4">For now, we can clear the cookie using the </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">developer tools.</span></span></p></li>
<li><span class="koboSpan" id="kobo.646.1">Open the developer tools in your browser window and navigate to the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.647.1">Application</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.648.1"> tab:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.649.1"><img alt="Figure 8.2 – The Application tab of the developer tools" src="image/Figure_8.02_B17399.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.650.1">Figure 8.2 – The Application tab of the developer tools</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.651.1">Under </span><strong class="bold"><span class="koboSpan" id="kobo.652.1">Cookies</span></strong><span class="koboSpan" id="kobo.653.1">, you should find the session cookie for BeeRich. </span><span class="koboSpan" id="kobo.653.2">Note that the cookie value is encrypted because of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">httpOnly</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.655.1"> flag.</span></span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.656.1">Right-click on the cookie and </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.658.1">Delete</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">.</span></span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.660.1">This allows us to play around with the registration form a bit more before we implement our </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">logout flow.</span></span></p>
<ol>
<li value="9"><span class="koboSpan" id="kobo.662.1">Try to register the same email address again. </span><span class="koboSpan" id="kobo.662.2">You should now see an inline </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">error. </span><span class="koboSpan" id="kobo.663.2">Awesome!</span></span><p class="list-inset"><span class="koboSpan" id="kobo.664.1">Feel free to spend more time on this section and investigate the code flow through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">action</span></strong><span class="koboSpan" id="kobo.666.1"> function and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">session.server.ts</span></strong><span class="koboSpan" id="kobo.668.1"> file. </span><span class="koboSpan" id="kobo.668.2">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">debugger</span></strong><span class="koboSpan" id="kobo.670.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">console.log</span></strong><span class="koboSpan" id="kobo.672.1"> statements to review what happens </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">during signup.</span></span></p></li>
</ol>
<p><span class="koboSpan" id="kobo.674.1">Once you feel </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.675.1">comfortable with the added code, delete the cookie using the developer tools. </span><span class="koboSpan" id="kobo.675.2">This will let us implement and test the </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">login flow.</span></span></p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.677.1">Adding a user login flow</span></h2>
<p><span class="koboSpan" id="kobo.678.1">Copy and paste the </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.679.1">route module component from the registration flow and see whether you can update it to make it work for the login page. </span><span class="koboSpan" id="kobo.679.2">Maybe try the same for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">action</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.681.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.682.1">Once you have tried it out, let’s go through the </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">implementation together:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.684.1">Add the following code to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">_layout.login.tsx</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.686.1">route component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.687.1">
import { useActionData, useNavigation } from '@remix-run/react';import { Button } from '~/components/buttons';import { Card } from '~/components/containers';import { Form, Input } from '~/components/forms';import { H1 } from '~/components/headings';import { InlineError } from '~/components/texts';export default function Component() {  const navigation = useNavigation();  const isSubmitting = navigation.state !== 'idle' &amp;&amp;    navigation.formAction === '/login';  const actionData = useActionData&lt;typeof action&gt;();  return (    &lt;Card&gt;      &lt;Form method="POST" action="/login"&gt;        &lt;H1&gt;Log In&lt;/H1&gt;        &lt;Input label="Email:" name="email" type="email" required          /&gt;        &lt;Input label="Password:" name="password" type="password"          required /&gt;        &lt;Button disabled={isSubmitting} type="submit" isPrimary&gt;          {isSubmitting ? </span><span class="koboSpan" id="kobo.687.2">'Logging you in...' </span><span class="koboSpan" id="kobo.687.3">: 'Log in!'}        &lt;/Button&gt;        &lt;InlineError aria-live="assertive"&gt;{actionData?.error &amp;&amp;          actionData.error}&lt;/InlineError&gt;      &lt;/Form&gt;    &lt;/Card&gt;  );}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.688.1">The login </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.689.1">and signup forms are nearly identical; only the number of input </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">fields differs.</span></span></p></li> <li><span class="koboSpan" id="kobo.691.1">Next, add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">action</span></strong><span class="koboSpan" id="kobo.693.1"> function to handle the login </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">form submissions:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.695.1">
import type { ActionFunctionArgs } from '@remix-run/node';import { json, redirect } from '@remix-run/node';import { createUserSession, loginUser } from '~/modules/session/session.server';export async function action({ request }: ActionFunctionArgs) {  </span><strong class="bold"><span class="koboSpan" id="kobo.696.1">const formData = await request.formData();</span></strong><span class="koboSpan" id="kobo.697.1">  const email = formData.get('email');  const password = formData.get('password');  if (!email || !password) {    return json({ error: 'Please fill out all fields.' </span><span class="koboSpan" id="kobo.697.2">});  }  if (typeof email !== 'string' || typeof password !== 'string') {    throw new Error('Invalid form data.');  }  try {    </span><strong class="bold"><span class="koboSpan" id="kobo.698.1">const user = await loginUser({ email, password });</span></strong><span class="koboSpan" id="kobo.699.1">    return redirect('/dashboard', {      headers: </span><strong class="bold"><span class="koboSpan" id="kobo.700.1">await createUserSession(user)</span></strong><span class="koboSpan" id="kobo.701.1">,    });  } catch (error: any) {    return json(</span><strong class="bold"><span class="koboSpan" id="kobo.702.1">{ error: error?.message || 'Something went      wrong.' </span><span class="koboSpan" id="kobo.702.2">}</span></strong><span class="koboSpan" id="kobo.703.1">);  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.704.1">We parse the form data from the request, validate the form data, and log the user in using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">loginUser</span></strong><span class="koboSpan" id="kobo.706.1"> helper function. </span><span class="koboSpan" id="kobo.706.2">If the user can be found in the database </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.707.1">and the password matches, we create the session cookie and add it to the response. </span><span class="koboSpan" id="kobo.707.2">Otherwise, we use the error message to return a </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">JSON response.</span></span></p></li> <li><span class="koboSpan" id="kobo.709.1">Try out the login flow using the email address you used during the registration flow. </span><span class="koboSpan" id="kobo.709.2">You should now be able to register and log in </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">to BeeRich.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.711.1">So far, we have utilized session helper functions to create a user session after successful registration or login. </span><span class="koboSpan" id="kobo.711.2">By inspecting the developer tools, we ensured that the browser registered the cookie. </span><span class="koboSpan" id="kobo.711.3">Next, we’ll add a logout flow that removes the </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">session cookie.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.713.1">Deleting a session during logout</span></h2>
<p><span class="koboSpan" id="kobo.714.1">Removing a</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.715.1"> session cookie is straightforward. </span><span class="koboSpan" id="kobo.715.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">session.server.ts</span></strong><span class="koboSpan" id="kobo.717.1">, we have access to three session life cycle methods: </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">getSession</span></strong><span class="koboSpan" id="kobo.719.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">commitSession</span></strong><span class="koboSpan" id="kobo.721.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">destroySession</span></strong><span class="koboSpan" id="kobo.723.1">. </span><span class="koboSpan" id="kobo.723.2">Follow </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.725.1">Let’s add a helper function to </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">session.server.ts</span></strong><span class="koboSpan" id="kobo.727.1"> to get the current user session from an </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">incoming request:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.729.1">
function getUserSession(request: Request) {  return </span><strong class="bold"><span class="koboSpan" id="kobo.730.1">getSession(request.headers.get('Cookie'));</span></strong><span class="koboSpan" id="kobo.731.1">}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.732.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">getUserSession</span></strong><span class="koboSpan" id="kobo.734.1"> function is a helper that we will utilize to access the current session object from the cookie header of </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">a request.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.736.1">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">getSession</span></strong><span class="koboSpan" id="kobo.738.1"> function parses the cookie header and returns a session object we can use to access the stored data. </span><span class="koboSpan" id="kobo.738.2">Once we have the session object, we can read from it or destroy it using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">destroySession</span></strong><span class="koboSpan" id="kobo.740.1"> life </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">cycle method.</span></span></p></li> <li><span class="koboSpan" id="kobo.742.1">Add a logout function </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">session.server.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.746.1">
export async function logout(</span><strong class="bold"><span class="koboSpan" id="kobo.747.1">request: Request</span></strong><span class="koboSpan" id="kobo.748.1">) {  const session = await getUserSession(request);  return redirect('/login', {    headers: {      </span><strong class="bold"><span class="koboSpan" id="kobo.749.1">'Set-Cookie': await destroySession(session),</span></strong><span class="koboSpan" id="kobo.750.1">    },  });}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.751.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">logout</span></strong><span class="koboSpan" id="kobo.753.1"> function parses</span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.754.1"> the current session object from the incoming request and then redirects the user to the login page. </span><span class="koboSpan" id="kobo.754.2">The returned response uses the </span><strong class="bold"><span class="koboSpan" id="kobo.755.1">Set-Cookie</span></strong><span class="koboSpan" id="kobo.756.1"> header to clear the current </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">session cookie.</span></span></p></li> <li><span class="koboSpan" id="kobo.758.1">Now, create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">_layout.logout.tsx</span></strong><span class="koboSpan" id="kobo.760.1"> route module and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.762.1">
import type { ActionFunctionArgs } from '@remix-run/node';import { redirect } from '@remix-run/node';import { logout } from '~/modules/session/session.server';export function action({ request }: ActionFunctionArgs) {  </span><strong class="bold"><span class="koboSpan" id="kobo.763.1">return logout(request);</span></strong><span class="koboSpan" id="kobo.764.1">}export function loader() {  return redirect('/login');}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.765.1">The logout route module has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">action</span></strong><span class="koboSpan" id="kobo.767.1"> function that executes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">logout</span></strong><span class="koboSpan" id="kobo.769.1"> function. </span><span class="koboSpan" id="kobo.769.2">This removes the session cookie and redirects the user to </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">login</span></strong><span class="koboSpan" id="kobo.771.1">. </span><span class="koboSpan" id="kobo.771.2">The logout route module also has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">loader</span></strong><span class="koboSpan" id="kobo.773.1"> function to redirect all traffic to </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">login</span></strong><span class="koboSpan" id="kobo.775.1">. </span><span class="koboSpan" id="kobo.775.2">This is convenient if a user accidentally navigates to the </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">logout page.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.777.1">Remember </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.778.1">that Remix refetches all loader data from all active </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">loader</span></strong><span class="koboSpan" id="kobo.780.1"> functions after an </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">action</span></strong><span class="koboSpan" id="kobo.782.1"> function executes. </span><span class="koboSpan" id="kobo.782.2">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">logout</span></strong><span class="koboSpan" id="kobo.784.1"> mutates the server state (the user session), we use an </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">action</span></strong><span class="koboSpan" id="kobo.786.1"> function and not a </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">loader</span></strong><span class="koboSpan" id="kobo.788.1"> function to implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">logout</span></strong><span class="koboSpan" id="kobo.790.1">. </span><span class="koboSpan" id="kobo.790.2">After logging out, we want to remove all user-specific data from the page by revalidating all </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">loader data.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.792.1">Note that the logout route module does not export a route component. </span><span class="koboSpan" id="kobo.792.2">Thus, it is not a document but a </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">resource route.</span></span></p></li> <li><span class="koboSpan" id="kobo.794.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">dashboard.tsx</span></strong><span class="koboSpan" id="kobo.796.1"> route module and locate the current logout link in the </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">navigation bar:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.798.1">
&lt;RemixLink to="/404"&gt;Log out&lt;/RemixLink&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.799.1">Currently, the logout button is a placeholder linking to a </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">non-existent page.</span></span></p></li> <li><span class="koboSpan" id="kobo.801.1">Import </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">Form</span></strong><span class="koboSpan" id="kobo.803.1"> from Remix and replace the code to create a form that submits a POST request to the </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">logout route:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.805.1">
&lt;Form method="POST" action="/logout"&gt;  &lt;button type="submit"&gt;Log out&lt;/button&gt;&lt;/Form&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.806.1">Clicking </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.807.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.808.1">Log out</span></strong><span class="koboSpan" id="kobo.809.1"> link submits a form to the logout action function, redirecting the user to log in and removing the current user session cookie. </span><span class="koboSpan" id="kobo.809.2">And with that, we have successfully implemented a logout flow </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">in BeeRich.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.811.1">In this section, we practiced creating and deleting session cookies using Remix’s session cookie helpers. </span><span class="koboSpan" id="kobo.811.2">Next, we will read from the session cookie to authenticate the user and return user-specific data from our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">loader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.813.1"> functions.</span></span></p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.814.1">Authenticating access to user data</span></h1>
<p><span class="koboSpan" id="kobo.815.1">We can access cookies in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">loader</span></strong><span class="koboSpan" id="kobo.817.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">action</span></strong><span class="koboSpan" id="kobo.819.1"> functions as cookies are appended to every HTTP request to the web server. </span><span class="koboSpan" id="kobo.819.2">This makes cookies a great tool for managing sessions. </span><span class="koboSpan" id="kobo.819.3">In this section, we will read from the session cookie to authenticate users and query </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">user-specific data.</span></span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.821.1">Accessing cookie data on the server</span></h2>
<p><span class="koboSpan" id="kobo.822.1">Once </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.823.1">we append a cookie to a response, we can access the cookie data on every following request to the server. </span><span class="koboSpan" id="kobo.823.2">This lets us build personalized and session-based user experiences. </span><span class="koboSpan" id="kobo.823.3">Let’s add some helper functions to make this </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">task easier:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.825.1">Add the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">session.server.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.827.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.828.1">
export async function getUserId(request: Request) {  </span><strong class="bold"><span class="koboSpan" id="kobo.829.1">const session = await getUserSession(request);</span></strong><span class="koboSpan" id="kobo.830.1">  const userId = </span><strong class="bold"><span class="koboSpan" id="kobo.831.1">session.get('userId');</span></strong><span class="koboSpan" id="kobo.832.1">  if (!userId || typeof userId !== 'string') return null;  return userId;}export async function getUser(request: Request) {  const userId = await getUserId(request);  if (typeof userId !== 'string') {    return null;  }  try {    return db.user.findUnique({      where: { id: userId },      select: { id: true, name: true, email: true, createdAt: true, updatedAt: true },    });  } catch {    throw logout(request);  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.833.1">On </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.834.1">register and login, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">createUserSession</span></strong><span class="koboSpan" id="kobo.836.1"> to write </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">userId</span></strong><span class="koboSpan" id="kobo.838.1"> to the session cookie. </span></p><p class="list-inset"><span class="koboSpan" id="kobo.839.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">getUserId</span></strong><span class="koboSpan" id="kobo.841.1"> function expects a </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">Request</span></strong><span class="koboSpan" id="kobo.843.1"> object and returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">userId</span></strong><span class="koboSpan" id="kobo.845.1"> from the session cookie if it’s present, or null otherwise. </span><span class="koboSpan" id="kobo.845.2">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">getUserSession</span></strong><span class="koboSpan" id="kobo.847.1"> to get the current session object from the cookie header of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">Request</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.849.1"> object.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.850.1">We also add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">getUser</span></strong><span class="koboSpan" id="kobo.852.1"> function that uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">getUserId</span></strong><span class="koboSpan" id="kobo.854.1"> function under the hood and returns the user object from the database. </span><span class="koboSpan" id="kobo.854.2">To avoid exposing the user’s password hash, we ensure not to query the password field from </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">the database.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.856.1">Let’s see how we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">getUserId</span></strong><span class="koboSpan" id="kobo.858.1"> to check whether a user is </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">logged in.</span></span></p></li> <li><span class="koboSpan" id="kobo.860.1">Add the</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.861.1"> following </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">loader</span></strong><span class="koboSpan" id="kobo.863.1"> functions to the login and signup </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">route modules:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.865.1">
import type { LoaderFunctionArgs } from '@remix-run/node';import { redirect } from '@remix-run/node';import { </span><strong class="bold"><span class="koboSpan" id="kobo.866.1">getUserId</span></strong><span class="koboSpan" id="kobo.867.1"> } from '~/modules/session/session.server';export async function loader({ request }: LoaderFunctionArgs) {  </span><strong class="bold"><span class="koboSpan" id="kobo.868.1">const userId = await getUserId(request);</span></strong><span class="koboSpan" id="kobo.869.1">  if (userId) {    return redirect('/dashboard');  }  return {};}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.870.1">Once a user is logged in, we ensure they are redirected away should they visit the login and </span><span class="No-Break"><span class="koboSpan" id="kobo.871.1">signup pages.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.872.1">If a session cookie is appended to the request and </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">userId</span></strong><span class="koboSpan" id="kobo.874.1"> exists, then we can be sure that the user has already been authenticated. </span><span class="koboSpan" id="kobo.874.2">In this case, we redirect to the dashboard. </span><span class="koboSpan" id="kobo.874.3">Otherwise, we show the login or </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">signup page.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.876.1">Note that we return an empty object for our base case in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">loader</span></strong><span class="koboSpan" id="kobo.878.1"> function. </span><span class="koboSpan" id="kobo.878.2">This is </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.879.1">because a </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">loader</span></strong><span class="koboSpan" id="kobo.881.1"> function cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.882.1">return </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">undefined</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.885.1">In this section, we implemented the </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">getUserId</span></strong><span class="koboSpan" id="kobo.887.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">getUser</span></strong><span class="koboSpan" id="kobo.889.1"> helper functions. </span><span class="koboSpan" id="kobo.889.2">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">getUserId</span></strong><span class="koboSpan" id="kobo.891.1"> to check whether a user is logged in. </span><span class="koboSpan" id="kobo.891.2">Next, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">getUser</span></strong><span class="koboSpan" id="kobo.893.1"> to get the user object of the currently logged-in user, </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">if any.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.895.1">Working with user data on the client</span></h2>
<p><span class="koboSpan" id="kobo.896.1">In this section, we</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.897.1"> will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">getUser</span></strong><span class="koboSpan" id="kobo.899.1"> to work with the user object of the currently </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">logged-in user:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.901.1">First, import </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">LoaderFunctionArgs</span></strong><span class="koboSpan" id="kobo.903.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">getUser</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.905.1">in root.tsx.</span></span><pre class="source-code"><span class="koboSpan" id="kobo.906.1">
import type { LinksFunction, </span><strong class="bold"><span class="koboSpan" id="kobo.907.1">LoaderFunctionArgs</span></strong><span class="koboSpan" id="kobo.908.1">, MetaFunction } from '@remix-run/node';import { getUser } from './modules/session/session.server';</span></pre></li> <li><span class="koboSpan" id="kobo.909.1">Next, add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">loader</span></strong><span class="koboSpan" id="kobo.911.1"> export to </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">root.tsx</span></strong><span class="koboSpan" id="kobo.913.1">, querying and returning the current </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">user object:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.915.1">
export async function loader({ request }: LoaderFunctionArgs) {  </span><strong class="bold"><span class="koboSpan" id="kobo.916.1">const user = await getUser(request);</span></strong><span class="koboSpan" id="kobo.917.1">  return { user };}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.918.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">getUser</span></strong><span class="koboSpan" id="kobo.920.1"> returns a user object without the password property. </span><span class="koboSpan" id="kobo.920.2">This is important as we forward the user object to the client. </span><span class="koboSpan" id="kobo.920.3">We must not leak user or app secrets to the </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">client application.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.922.1">We can now access the user object with </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">useLoaderData</span></strong><span class="koboSpan" id="kobo.924.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">root.tsx</span></strong><span class="koboSpan" id="kobo.926.1">. </span><span class="koboSpan" id="kobo.926.2">However, we likely want to have access to the user object throughout our application. </span><span class="koboSpan" id="kobo.926.3">Let’s see how we can do this </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">with Remix.</span></span></p></li> <li><span class="koboSpan" id="kobo.928.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">session.ts</span></strong><span class="koboSpan" id="kobo.930.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">app/modules/session</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.933.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.934.1">We plan to create a small React hook to access the root loader user data across our React app. </span><span class="koboSpan" id="kobo.934.2">Since we also want to access the hook in our React app on the client, we must not put the hook in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">session.server.ts</span></strong><span class="koboSpan" id="kobo.936.1"> file as it is only included in the </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">server bundle.</span></span></p></li>
<li><span class="koboSpan" id="kobo.938.1">Add the </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.939.1">following </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">useUser</span></strong><span class="koboSpan" id="kobo.941.1"> hook </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">session.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.945.1">
import type { User } from '@prisma/client';import { </span><strong class="bold"><span class="koboSpan" id="kobo.946.1">useRouteLoaderData</span></strong><span class="koboSpan" id="kobo.947.1"> } from '@remix-run/react';import type { loader } from '~/root';type PublicUser = Omit&lt;User, 'password'&gt;;export function useUser(): PublicUser | null {  </span><strong class="bold"><span class="koboSpan" id="kobo.948.1">const data = useRouteLoaderData&lt;typeof loader&gt;('root');</span></strong><span class="koboSpan" id="kobo.949.1">  if (!data || !data.user) return null;  const deserializedUser: PublicUser = {    ...data.user,    createdAt: new Date(data.user.createdAt),    updatedAt: new Date(data.user.updatedAt),  };  return deserializedUser;}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.950.1">We use Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">useRouteLoaderData</span></strong><span class="koboSpan" id="kobo.952.1"> hook to access the root loader data user object. </span><span class="koboSpan" id="kobo.952.2">We also import the type of the root </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">loader</span></strong><span class="koboSpan" id="kobo.954.1"> function for type inference. </span><span class="koboSpan" id="kobo.954.2">We further deserialize the user object to match the </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">User</span></strong><span class="koboSpan" id="kobo.956.1"> type from </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">@prisma/client</span></strong><span class="koboSpan" id="kobo.958.1"> without the </span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">password property.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.960.1">Note that Remix assigns every route module a unique identifier. </span><span class="koboSpan" id="kobo.960.2">The ID of the root route module is "root". </span><span class="koboSpan" id="kobo.960.3">We must pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">useRouteLoaderData</span></strong><span class="koboSpan" id="kobo.962.1"> the ID of the route module of which we want to access the loader data. </span><span class="koboSpan" id="kobo.962.2">Remix's route module IDs match the route file name relative to the app folder. </span><span class="koboSpan" id="kobo.962.3">You can find more information in the Remix </span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">documentation: </span></span><a href="https://remix.run/docs/en/2/hooks/use-route-loader-data"><span class="No-Break"><span class="koboSpan" id="kobo.964.1">https://remix.run/docs/en/2/hooks/use-route-loader-data</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.965.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.966.1">We</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.967.1"> can now call </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">useUser</span></strong><span class="koboSpan" id="kobo.969.1"> throughout our Remix application to access the current user object. </span><span class="koboSpan" id="kobo.969.2">You can use the same pattern for any global </span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">application state.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.971.1">Let’s try out the hook </span><span class="No-Break"><span class="koboSpan" id="kobo.972.1">in action!</span></span></p></li> <li><span class="koboSpan" id="kobo.973.1">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">useUser</span></strong><span class="koboSpan" id="kobo.975.1"> hook in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">_layout.tsx</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.977.1">route component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.978.1">
const user = useUser();</span></pre></li> <li><span class="koboSpan" id="kobo.979.1">In the unordered list of the navigation, replace the current </span><strong class="bold"><span class="koboSpan" id="kobo.980.1">Log in</span></strong><span class="koboSpan" id="kobo.981.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.982.1">Sign in</span></strong><span class="koboSpan" id="kobo.983.1"> list items with the </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.985.1">
{user ? </span><span class="koboSpan" id="kobo.985.2">(  &lt;li className="ml-auto"&gt;    &lt;NavLink to="/dashboard" prefetch="intent"&gt;      Dashboard    &lt;/NavLink&gt;  &lt;/li&gt;) : (  &lt;&gt;    &lt;li className="ml-auto"&gt;      &lt;NavLink to="/login" prefetch="intent"&gt;        Log in      &lt;/NavLink&gt;    &lt;/li&gt;    &lt;li&gt;      &lt;NavLink to="/signup" prefetch="intent"&gt;        Sign up      &lt;/NavLink&gt;    &lt;/li&gt;  &lt;/&gt;)}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.986.1">We now conditionally render the </span><strong class="bold"><span class="koboSpan" id="kobo.987.1">Log in</span></strong><span class="koboSpan" id="kobo.988.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.989.1">Sign up </span></strong><span class="koboSpan" id="kobo.990.1">links if no user is logged in or a link to </span><strong class="bold"><span class="koboSpan" id="kobo.991.1">Dashboard</span></strong><span class="koboSpan" id="kobo.992.1"> if a user is already </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">logged in.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.994.1">Note that the </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.995.1">user object returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">useUser</span></strong><span class="koboSpan" id="kobo.997.1"> can also be </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">null</span></strong><span class="koboSpan" id="kobo.999.1">. </span><span class="koboSpan" id="kobo.999.2">We try to query a user object if a session exists or return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">null</span></strong><span class="koboSpan" id="kobo.1001.1"> otherwise. </span><span class="koboSpan" id="kobo.1001.2">However, sometimes, we must ensure that a user is logged in. </span><span class="koboSpan" id="kobo.1001.3">We’ll look at enforcing authentication in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">next section.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.1003.1">Enforcing authentication on the server</span></h2>
<p><span class="koboSpan" id="kobo.1004.1">The dashboard</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.1005.1"> routes of BeeRich are for logged-in users only. </span><span class="koboSpan" id="kobo.1005.2">Can you think of a way to enforce that a session cookie </span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">is present?</span></span></p>
<p><span class="koboSpan" id="kobo.1007.1">Let’s implement some authentication logic that redirects the user to the login page if no user </span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">session exists:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1009.1">Create another helper function </span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">session.server.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1013.1">
export async function requireUserId(request: Request) {  const session = await getUserSession(request);  const userId = session.get('userId');</span><strong class="bold"><span class="koboSpan" id="kobo.1014.1">  if (!userId || typeof userId !== 'string') {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1015.1">    throw redirect('/login');</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1016.1">  }</span></strong><span class="koboSpan" id="kobo.1017.1">  return userId;}</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">requireUserId</span></strong><span class="koboSpan" id="kobo.1019.1"> looks similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">getUserId</span></strong><span class="koboSpan" id="kobo.1021.1">, but this time, we throw a redirect </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">Response</span></strong><span class="koboSpan" id="kobo.1023.1"> if no user session </span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1">was found.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.1025.1">Note that throwing a redirect </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">Response</span></strong><span class="koboSpan" id="kobo.1027.1"> does not trigger the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">ErrorBoundary</span></strong><span class="koboSpan" id="kobo.1029.1"> component. </span><span class="koboSpan" id="kobo.1029.2">Redirects are a special case where we leave the current route module and navigate to another one instead. </span><span class="koboSpan" id="kobo.1029.3">The final </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">Response</span></strong><span class="koboSpan" id="kobo.1031.1"> of a redirect is the document response of the redirected </span><span class="No-Break"><span class="koboSpan" id="kobo.1032.1">route module.</span></span></p></li> <li><span class="koboSpan" id="kobo.1033.1">Next, add </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.1034.1">the following line to the top of all </span><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">loader</span></strong><span class="koboSpan" id="kobo.1036.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1037.1">action</span></strong><span class="koboSpan" id="kobo.1038.1"> functions in the dashboard </span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">route modules:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1040.1">
await requireUserId(request);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1041.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">requireUserId</span></strong><span class="koboSpan" id="kobo.1043.1"> call ensures that the user is redirected to the login page in case they are </span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">not authenticated.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.1045.1">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">loader</span></strong><span class="koboSpan" id="kobo.1047.1"> functions run in parallel and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">action</span></strong><span class="koboSpan" id="kobo.1049.1"> functions expose API endpoints over the internet, we must add the authentication check to every single </span><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">loader</span></strong><span class="koboSpan" id="kobo.1051.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1052.1">action</span></strong><span class="koboSpan" id="kobo.1053.1"> function that </span><span class="No-Break"><span class="koboSpan" id="kobo.1054.1">requires authentication.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.1055.1">We must also ensure that we only retrieve data associated with the current </span><strong class="source-inline"><span class="koboSpan" id="kobo.1056.1">userId</span></strong><span class="koboSpan" id="kobo.1057.1">. </span><span class="koboSpan" id="kobo.1057.2">A user should not be able to view the expenses and invoices of other users. </span><span class="koboSpan" id="kobo.1057.3">Let’s update our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">loader</span></strong><span class="koboSpan" id="kobo.1059.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">action</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1061.1">functions further.</span></span></p></li> <li><span class="koboSpan" id="kobo.1062.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">dashboard.tsx</span></strong><span class="koboSpan" id="kobo.1064.1"> route module and update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">loader</span></strong><span class="koboSpan" id="kobo.1066.1"> function to require a user session and use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">userId</span></strong><span class="koboSpan" id="kobo.1068.1"> to query user-specific expense and </span><span class="No-Break"><span class="koboSpan" id="kobo.1069.1">income objects:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1070.1">
import type { </span><strong class="bold"><span class="koboSpan" id="kobo.1071.1">LoaderFunctionArgs</span></strong><span class="koboSpan" id="kobo.1072.1">, SerializeFrom } from '@remix-run/node';import { </span><strong class="bold"><span class="koboSpan" id="kobo.1073.1">requireUserId</span></strong><span class="koboSpan" id="kobo.1074.1"> } from '~/session.server';export async function loader(</span><strong class="bold"><span class="koboSpan" id="kobo.1075.1">{ request }: LoaderFunctionArgs</span></strong><span class="koboSpan" id="kobo.1076.1">) {  </span><strong class="bold"><span class="koboSpan" id="kobo.1077.1">const userId = await requireUserId(request);</span></strong><span class="koboSpan" id="kobo.1078.1">  const expenseQuery = db.expense.findFirst({    orderBy: { createdAt: 'desc' },    </span><strong class="bold"><span class="koboSpan" id="kobo.1079.1">where: { userId },</span></strong><span class="koboSpan" id="kobo.1080.1">  });  const invoiceQuery = db.invoice.findFirst({    orderBy: { createdAt: 'desc' },    </span><strong class="bold"><span class="koboSpan" id="kobo.1081.1">where: { userId },</span></strong><span class="koboSpan" id="kobo.1082.1">  });  const [firstExpense, firstInvoice] = await Promise.all([expenseQuery, invoiceQuery]);  return json({ firstExpense, firstInvoice });}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1083.1">By </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.1084.1">requiring </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">userId</span></strong><span class="koboSpan" id="kobo.1086.1">, we ensure that a session cookie is present. </span><span class="koboSpan" id="kobo.1086.2">If no session cookie is present, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">requireUserId</span></strong><span class="koboSpan" id="kobo.1088.1"> will throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">redirect</span></strong><span class="koboSpan" id="kobo.1090.1"> to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1091.1">login route.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.1092.1">We also filter our database queries for user-specific content. </span><span class="koboSpan" id="kobo.1092.2">We now query for the last expense and invoice objects created by the </span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1">logged-in user.</span></span></p></li> <li><span class="koboSpan" id="kobo.1094.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">dashboard.expenses.tsx</span></strong><span class="koboSpan" id="kobo.1096.1"> route module and update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">loader</span></strong><span class="koboSpan" id="kobo.1098.1"> function so that it checks for an existing </span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1">user session:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1100.1">
import { </span><strong class="bold"><span class="koboSpan" id="kobo.1101.1">requireUserId</span></strong><span class="koboSpan" id="kobo.1102.1"> } from '~/session.server';export async function loader({ request }: LoaderFunctionArgs) {  </span><strong class="bold"><span class="koboSpan" id="kobo.1103.1">const userId = await requireUserId(request);</span></strong><span class="koboSpan" id="kobo.1104.1">  const url = new URL(request.url);  const searchString = url.searchParams.get('q');  const expenses = await db.expense.findMany({    orderBy: {      createdAt: 'desc',    },    where: {      </span><strong class="bold"><span class="koboSpan" id="kobo.1105.1">userId,</span></strong><span class="koboSpan" id="kobo.1106.1">      title: {        contains: searchString ? </span><span class="koboSpan" id="kobo.1106.2">searchString : '',      },    },  });  return json(expenses);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1107.1">Again, we</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.1108.1"> ensure that a user session is present and use the stored </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">userId</span></strong><span class="koboSpan" id="kobo.1110.1"> to only filter for </span><span class="No-Break"><span class="koboSpan" id="kobo.1111.1">user-specific data.</span></span></p></li> <li><span class="koboSpan" id="kobo.1112.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">dashboard.expenses._index.tsx</span></strong><span class="koboSpan" id="kobo.1114.1"> route module and update the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">action</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1116.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1117.1">
import { requireUserId } from '~/modules/session/session.server';export async function action({ request }: ActionFunctionArgs) {  </span><strong class="bold"><span class="koboSpan" id="kobo.1118.1">const userId = await requireUserId(request);</span></strong><span class="koboSpan" id="kobo.1119.1">  const formData = await request.formData();  const title = formData.get('title');  const description = formData.get('description');  const amount = formData.get('amount');  if (typeof title !== 'string' || typeof description !== 'string' || typeof amount !== 'string') {    throw Error('something went wrong');  }  const amountNumber = Number.parseFloat(amount);  if (Number.isNaN(amountNumber)) {    throw Error('something went wrong');  }  const expense = await db.expense.create({    data: {      title,      description,      amount: amountNumber,      currencyCode: 'USD',</span><strong class="bold"><span class="koboSpan" id="kobo.1120.1">      user: {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1121.1">        connect: {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1122.1">          id: userId,</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1123.1">        },</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1124.1">      },</span></strong><span class="koboSpan" id="kobo.1125.1">    },  });  return redirect(`/dashboard/expenses/${expense.id}`);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1126.1">On </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.1127.1">expense creation, we now connect the new expense object to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1128.1">userId</span></strong><span class="koboSpan" id="kobo.1129.1"> parameter that was retrieved from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1130.1">session cookie.</span></span></p></li> <li><span class="koboSpan" id="kobo.1131.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1132.1">dashboard.expenses.$id.tsx</span></strong><span class="koboSpan" id="kobo.1133.1"> route module and update the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">loader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1135.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1136.1">
export async function loader({ </span><strong class="bold"><span class="koboSpan" id="kobo.1137.1">request</span></strong><span class="koboSpan" id="kobo.1138.1">, params }: LoaderFunctionArgs) {  </span><strong class="bold"><span class="koboSpan" id="kobo.1139.1">const userId = await requireUserId(request);</span></strong><span class="koboSpan" id="kobo.1140.1">  const { id } = params;  if (!id) throw Error('id route parameter must be defined');  const expense = await db.expense.findUnique(</span><strong class="bold"><span class="koboSpan" id="kobo.1141.1">{ where: { id_   userId: { id, userId } } }</span></strong><span class="koboSpan" id="kobo.1142.1">);  if (!expense) throw new Response('Not found', { status: 404 });  return json(expense);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1143.1">We query for an expense matching the route parameter identifier and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1">userId</span></strong><span class="koboSpan" id="kobo.1145.1"> cookie value. </span><span class="koboSpan" id="kobo.1145.2">This ensures that a user can’t visit different expense detail pages and view the content of </span><span class="No-Break"><span class="koboSpan" id="kobo.1146.1">other users.</span></span></p></li> <li><span class="koboSpan" id="kobo.1147.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">deleteExpense</span></strong><span class="koboSpan" id="kobo.1149.1"> handler function </span><span class="No-Break"><span class="koboSpan" id="kobo.1150.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">dashboard.expenses.$id.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1153.1">
async function deleteExpense(request: Request, id: string, </span><strong class="bold"><span class="koboSpan" id="kobo.1154.1">userId: string</span></strong><span class="koboSpan" id="kobo.1155.1">): Promise&lt;Response&gt; {  const referer = request.headers.get('referer');  const redirectPath = referer || '/dashboard/expenses';  try {    </span><strong class="bold"><span class="koboSpan" id="kobo.1156.1">await db.expense.delete({ where: { id_userId: { id, userId } } });</span></strong><span class="koboSpan" id="kobo.1157.1">  } catch (err) {    throw new Response('Not found', { status: 404 });  }  if (redirectPath.includes(id)) {    return redirect('/dashboard/expenses');  }  return redirect(redirectPath);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1158.1">We update </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.1159.1">the database call to query both by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">id</span></strong><span class="koboSpan" id="kobo.1161.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">userId</span></strong><span class="koboSpan" id="kobo.1163.1">. </span><span class="koboSpan" id="kobo.1163.2">This ensures that a user can only ever delete an expense that was also created by </span><span class="No-Break"><span class="koboSpan" id="kobo.1164.1">that user.</span></span></p></li> <li><span class="koboSpan" id="kobo.1165.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1166.1">updateExpense</span></strong><span class="koboSpan" id="kobo.1167.1"> handler function </span><span class="No-Break"><span class="koboSpan" id="kobo.1168.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">dashboard.expenses.$id.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1170.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1171.1">
async function updateExpense(formData: FormData, id: string, </span><strong class="bold"><span class="koboSpan" id="kobo.1172.1">userId: string</span></strong><span class="koboSpan" id="kobo.1173.1">): Promise&lt;Response&gt; {  const title = formData.get('title');  const description = formData.get('description');  const amount = formData.get('amount');  if (typeof title !== 'string' || typeof description !==    'string' || typeof amount !== 'string') {    throw Error('something went wrong');  }  const amountNumber = Number.parseFloat(amount);  if (Number.isNaN(amountNumber)) {    throw Error('something went wrong');  }  await db.expense.update({    </span><strong class="bold"><span class="koboSpan" id="kobo.1174.1">where: { id_userId: { id, userId } },</span></strong><span class="koboSpan" id="kobo.1175.1">    data: { title, description, amount: amountNumber },  });  return json({ success: true });}</span></pre></li> <li><span class="koboSpan" id="kobo.1176.1">Finally, update </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.1177.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">action</span></strong><span class="koboSpan" id="kobo.1179.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">dashboard.expenses.$id.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1182.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1183.1">
export async function action({ params, request }: ActionFunctionArgs) {  </span><strong class="bold"><span class="koboSpan" id="kobo.1184.1">const userId = await requireUserId(request);</span></strong><span class="koboSpan" id="kobo.1185.1">  const { id } = params;  if (!id) throw Error('id route parameter must be defined');  const formData = await request.formData();  const intent = formData.get('intent');  if (intent === 'delete') {    return deleteExpense(request, id, </span><strong class="bold"><span class="koboSpan" id="kobo.1186.1">userId</span></strong><span class="koboSpan" id="kobo.1187.1">);  }  if (intent === 'update') {    return updateExpense(formData, id, </span><strong class="bold"><span class="koboSpan" id="kobo.1188.1">userId</span></strong><span class="koboSpan" id="kobo.1189.1">);  }  throw new Response('Bad request', { status: 400 });}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1190.1">Again, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">requireUserId</span></strong><span class="koboSpan" id="kobo.1192.1"> to enforce an existing user session. </span><span class="koboSpan" id="kobo.1192.2">Then, we pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">userId</span></strong><span class="koboSpan" id="kobo.1194.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1195.1">deleteExpense</span></strong><span class="koboSpan" id="kobo.1196.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">updateExpense</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1198.1">handler functions.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.1199.1">That </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.1200.1">was quite a bit of code to go through, but by making some minor changes here and there, we have fully authenticated our application’s HTTP endpoints and ensured that only authenticated users can visit our </span><span class="No-Break"><span class="koboSpan" id="kobo.1201.1">dashboard pages.</span></span></p></li> <li><span class="koboSpan" id="kobo.1202.1">Now is a good time to play around with BeeRich. </span><span class="koboSpan" id="kobo.1202.2">See whether you can still access any of the dashboard routes without logging </span><span class="No-Break"><span class="koboSpan" id="kobo.1203.1">in first.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.1204.1">See whether you can hack into BeeRich by playing around with several tabs. </span><span class="koboSpan" id="kobo.1204.2">Open the expense creation form in the first tab and log yourself out in the second tab. </span><span class="koboSpan" id="kobo.1204.3">Can you still successfully create a new expense? </span><span class="koboSpan" id="kobo.1204.4">Notice how cookies are appended and updated across </span><span class="No-Break"><span class="koboSpan" id="kobo.1205.1">different tabs.</span></span></p></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.1206.1">Securing loader and action functions</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1207.1">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">loader</span></strong><span class="koboSpan" id="kobo.1209.1"> functions run in parallel for faster execution. </span><span class="koboSpan" id="kobo.1209.2">However, their concurrent nature also dictates that we must secure each loader function. </span><span class="koboSpan" id="kobo.1209.3">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">loader</span></strong><span class="koboSpan" id="kobo.1211.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">action</span></strong><span class="koboSpan" id="kobo.1213.1"> functions are accessible over the internet and must be treated and secured like </span><span class="No-Break"><span class="koboSpan" id="kobo.1214.1">API endpoints.</span></span></p>
<p><span class="koboSpan" id="kobo.1215.1">We still need to update the income routes. </span><span class="koboSpan" id="kobo.1215.2">This will be good practice to ensure you understand</span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.1216.1"> how to authenticate </span><strong class="source-inline"><span class="koboSpan" id="kobo.1217.1">loader</span></strong><span class="koboSpan" id="kobo.1218.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1219.1">action</span></strong><span class="koboSpan" id="kobo.1220.1"> functions. </span><span class="koboSpan" id="kobo.1220.2">Take your time and go over each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1221.1">loader</span></strong><span class="koboSpan" id="kobo.1222.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1223.1">action</span></strong><span class="koboSpan" id="kobo.1224.1"> function in the income routes to practice what you’ve learned in </span><span class="No-Break"><span class="koboSpan" id="kobo.1225.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.1226.1">In this section, you learned how to access state from session cookies in Remix and how to use session cookies to authenticate users in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1227.1">loader</span></strong><span class="koboSpan" id="kobo.1228.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1229.1">action</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1230.1"> functions.</span></span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.1231.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1232.1">In this chapter, you learned about session and state management in Remix. </span><span class="koboSpan" id="kobo.1232.2">First, you learned how to use URL search parameters to persist application state using Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">Form</span></strong><span class="koboSpan" id="kobo.1234.1"> component and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1235.1">useSearchParams</span></strong><span class="koboSpan" id="kobo.1236.1"> hook. </span><span class="koboSpan" id="kobo.1236.2">The URL is often all we need to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.1237.1">application state.</span></span></p>
<p><span class="koboSpan" id="kobo.1238.1">You also practiced using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1239.1">useSubmit</span></strong><span class="koboSpan" id="kobo.1240.1"> to submit a form programmatically and learned more about Remix’s different mutation utilities. </span><span class="koboSpan" id="kobo.1240.2">We concluded that we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1241.1">Form</span></strong><span class="koboSpan" id="kobo.1242.1"> component and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1243.1">useSubmit</span></strong><span class="koboSpan" id="kobo.1244.1"> hook for the primary actions on the page; </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">useFetcher</span></strong><span class="koboSpan" id="kobo.1246.1"> is used to support concurrent submissions with isolated </span><span class="No-Break"><span class="koboSpan" id="kobo.1247.1">submission states.</span></span></p>
<p><span class="koboSpan" id="kobo.1248.1">Next, you learned that cookies are part of the HTTP protocol and can be used to persist state across page transitions. </span><span class="koboSpan" id="kobo.1248.2">Cookies are a great tool for session management. </span><span class="koboSpan" id="kobo.1248.3">Remix provides helper functions for working with cookies and sessions. </span><span class="koboSpan" id="kobo.1248.4">Remix’s session primitives allow us to manage sessions using different strategies, such as storing session data in memory, files, databases, </span><span class="No-Break"><span class="koboSpan" id="kobo.1249.1">or cookies.</span></span></p>
<p><span class="koboSpan" id="kobo.1250.1">We utilized Remix’s primitives to implement an authentication flow with login, signup, and logout functionalities in BeeRich. </span><span class="koboSpan" id="kobo.1250.2">You learned how to authenticate users and use session cookies to query for </span><span class="No-Break"><span class="koboSpan" id="kobo.1251.1">user-specific content.</span></span></p>
<p><span class="koboSpan" id="kobo.1252.1">On register and login, we create and fetch a user object and write </span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">userId</span></strong><span class="koboSpan" id="kobo.1254.1"> to Remix’s session object. </span><span class="koboSpan" id="kobo.1254.2">The object is then serialized to a string and added as a cookie to the HTTP response using the </span><strong class="bold"><span class="koboSpan" id="kobo.1255.1">Set-Cookie</span></strong><span class="koboSpan" id="kobo.1256.1"> header. </span><span class="koboSpan" id="kobo.1256.2">Once a cookie has been set to the response, the browser will append it to all the following requests. </span><span class="koboSpan" id="kobo.1256.3">This enables us to read the cookie header in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1257.1">loader</span></strong><span class="koboSpan" id="kobo.1258.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1259.1">action</span></strong><span class="koboSpan" id="kobo.1260.1"> functions to authenticate user sessions and query </span><span class="No-Break"><span class="koboSpan" id="kobo.1261.1">user-specific data.</span></span></p>
<p><span class="koboSpan" id="kobo.1262.1">You also learned how to access loader data globally throughout your application using Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1263.1">useRouteLoaderData</span></strong><span class="koboSpan" id="kobo.1264.1"> hook. </span><span class="koboSpan" id="kobo.1264.2">You practiced creating a small custom hook to abstract accessing the user object from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1265.1">root </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">loader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1267.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1268.1">After reading this chapter, you understand that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">action</span></strong><span class="koboSpan" id="kobo.1270.1"> functions are standalone endpoints and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1271.1">loader</span></strong><span class="koboSpan" id="kobo.1272.1"> functions run in parallel. </span><span class="koboSpan" id="kobo.1272.2">Conclusively, we must authenticate the user in every restricted </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">loader</span></strong><span class="koboSpan" id="kobo.1274.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">action</span></strong><span class="koboSpan" id="kobo.1276.1"> function to prevent </span><span class="No-Break"><span class="koboSpan" id="kobo.1277.1">unauthorized access.</span></span></p>
<p><span class="koboSpan" id="kobo.1278.1">In the next chapter, you will learn more about working with static assets and files </span><span class="No-Break"><span class="koboSpan" id="kobo.1279.1">in Remix.</span></span></p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.1280.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.1281.1">Review the MDN Web Docs for more information about URL search parameters and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1282.1">URLSearchParams</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1283.1">interface: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams"><span class="No-Break"><span class="koboSpan" id="kobo.1284.1">https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1285.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1286.1">Also refer to the MDN Web Docs if you want to learn more about HTTP cookies: </span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies"><span class="koboSpan" id="kobo.1287.1">https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies</span></a><span class="koboSpan" id="kobo.1288.1"> or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1289.1">Headers</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1290.1">interface: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Headers"><span class="No-Break"><span class="koboSpan" id="kobo.1291.1">https://developer.mozilla.org/en-US/docs/Web/API/Headers</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1292.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1293.1">Refresh your knowledge about HTML forms by reading through the MDN Web </span><span class="No-Break"><span class="koboSpan" id="kobo.1294.1">Docs: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form"><span class="No-Break"><span class="koboSpan" id="kobo.1295.1">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1296.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1297.1">Remix provides several primitives for working with sessions. </span><span class="koboSpan" id="kobo.1297.2">You can find more information in the Remix </span><span class="No-Break"><span class="koboSpan" id="kobo.1298.1">documentation: </span></span><a href="https://remix.run/docs/en/2/utils/sessions"><span class="No-Break"><span class="koboSpan" id="kobo.1299.1">https://remix.run/docs/en/2/utils/sessions</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1300.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1301.1">Remix also provides lower-level primitives for working with </span><span class="No-Break"><span class="koboSpan" id="kobo.1302.1">cookies: </span></span><a href="https://remix.run/docs/en/2/utils/cookies"><span class="No-Break"><span class="koboSpan" id="kobo.1303.1">https://remix.run/docs/en/2/utils/cookies</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1304.1">.</span></span></p>
</div>
</body></html>