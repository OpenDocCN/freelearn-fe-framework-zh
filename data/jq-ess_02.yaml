- en: Chapter 2. jQuery Selectors and Filters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。jQuery 选择器和过滤器
- en: The name "jQuery" comes from the library's ability to quickly and intelligently
    query the **DOM** (**Document Object Model**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 名称“jQuery”来自于该库快速而智能地查询**DOM**（**文档对象模型**）的能力。
- en: 'In this chapter, we will learn how to query the DOM ourselves and, once we
    have a set of items, how to use filters to further refine our dataset. We will
    cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何自己查询 DOM，并且一旦我们有了一组项目，我们将学习如何使用过滤器进一步细化我们的数据集。我们将涵盖以下主题：
- en: What selectors and filters are
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择器和过滤器是什么
- en: How to create a selector
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建选择器
- en: How to create a filter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建过滤器
- en: How to query based on element attributes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何根据元素属性进行查询
- en: How chaining allows us to quickly and neatly continue queries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用链式方法快速而整洁地继续查询
- en: jQuery selectors
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jQuery 选择器
- en: Underneath every browser web page is the DOM. The DOM keeps track of all the
    individual objects that are rendered to the page. Being able to find DOM elements
    is the first step toward creating a dynamic web page. The browser comes with built-in
    methods to query the DOM. These methods usually begin with the word `document`.
    There is `document.getElementById`, `document.getElementsByClass`, and so on.
    The problem with these methods is that their interface is neither consistent nor
    complete.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个浏览器网页的底层是 DOM。DOM 跟踪渲染到页面上的所有单个对象。能够找到 DOM 元素是创建动态网页的第一步。浏览器带有内置方法来查询 DOM。这些方法通常以`document`开头。有`document.getElementById`、`document.getElementsByClass`等等。这些方法的问题在于它们的接口既不一致也不完整。
- en: jQuery gets its name from its ability to query the DOM. Unlike browser methods,
    its interface is both complete and feature-rich. Querying the DOM begins by creating
    a selector. A selector is a string that tells jQuery how to find the elements
    you want. Since it is a string of text, the possible number of selectors is limitless.
    But don't panic; they all fall into a few broad classes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 之所以得名于其查询 DOM 的能力。与浏览器方法不同，它的接口既完整又功能丰富。查询 DOM 的开始是创建选择器。选择器是一个字符串，告诉
    jQuery 如何找到你想要的元素。由于它是一串文本，因此可能的选择器数量是无限的。但不要惊慌；它们都属于几个广泛的类别。
- en: The chapter code
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 章节代码
- en: 'The code for this chapter is contained in a directory named `chapter02`. Keep
    in mind that this is sample code meant to teach, and it is not intended for production.
    The code does two things that are particularly tedious and worth mentioning. First,
    it uses inline JavaScript, which means that the JavaScript is contained in a script
    tag with the main page''s HTML. This violates the rule of separation of concerns
    and can lead to poorly performing code. Second, it makes heavy use of alerts.
    The browser `alert` method is a quick and dirty way to display something on a
    screen, and unlike the `console.log` method, all browsers support it. But it is
    not recommended for use in production. Alerts can''t be styled, so they will stick
    out like a sore thumb unless your website is not styled as well. Second, alerts
    cause the browser to stop everything and force the user to acknowledge them, which
    is obviously something that can quickly become annoying to the user:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包含在一个名为`chapter02`的目录中。请记住，这是用于教学的示例代码，不适用于生产。代码做了两件特别乏味而值得一提的事情。首先，它使用内联
    JavaScript，这意味着 JavaScript 包含在主页面的 HTML 中的脚本标签中。这违反了关注点分离的规则，可能会导致性能不佳的代码。其次，它大量使用警报。浏览器的`alert`方法是在屏幕上快速而肮脏地显示东西的一种方法，与`console.log`方法不同，所有浏览器都支持它。但不建议在生产中使用。警报无法进行样式设置，因此除非您的网站未进行样式设置，否则它们会显得非常突兀。其次，警报会使浏览器停止所有操作，并强制用户承认它们，这显然是会让用户快速变得烦躁的事情：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The method used to display the jQuery object is named `showJqueryObject()`.
    It iterates through the jQuery object, showing each of the nodes in turn. Now,
    to be perfectly honest, I only use this method for the purpose of this book. When
    working on issues while developing my own programs, I normally rely on the browser's
    `console.log` method. But since not all browsers support it, and for those that
    support it differently, the easiest way to display something on the screen is
    to roll my own method.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用于显示 jQuery 对象的方法被命名为`showJqueryObject()`。它通过 jQuery 对象进行迭代，依次显示每个节点。现在，说实话，我只在这本书中使用这个方法。在开发自己的程序时，处理问题时，我通常依赖于浏览器的`console.log`方法。但由于并非所有浏览器都支持它，而且对支持它的浏览器来说，显示东西在屏幕上的最简单方法是编写自己的方法。
- en: Protocol-relative URLs
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议相对 URL
- en: A curious thing that keen-eyed readers might notice is that the protocol is
    missing from the URL in the script tag. I am not a web security expert, but I
    am smart enough to pay heed to the warnings of web security experts, all of whom
    will say that mixing HTTP protocols is dangerous. Protocol-relative URLs make
    it easy to keep your site secure. These days, many sites will run on either open
    HTTP or secured HTTP (HTTPS). Achieving this feat previously required loading
    all JavaScript libraries from your own site, foregoing the benefits of CDNs, or
    including some complicated bit of inline JavaScript that detects your site's protocol
    and uses `document.write` to inject some new JavaScript onto the page.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一件敏锐的读者可能会注意到的有趣事情是脚本标签中缺少了 URL 的协议。我不是网络安全专家，但我足够聪明，足以留意网络安全专家的警告，所有这些专家都会说混合使用
    HTTP 协议是危险的。协议相对 URL 使得保持网站安全变得容易。现在，许多网站都会在开放的 HTTP 或安全的 HTTP（HTTPS）上运行。以前实现这一点需要从你自己的网站加载所有
    JavaScript 库，放弃 CDN 的好处，或者包含一些复杂的内联 JavaScript 代码来检测你网站的协议，并使用`document.write`将一些新的
    JavaScript 注入到页面中。
- en: With protocol-relative URLs, you simply omit the protocol from the URL. Then
    when your site is loaded, if it is loaded from HTTP, the libraries will also be
    loaded from HTTP. If it is loaded via HTTPS, then all of the libraries will also
    be loaded via HTTPS.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协议相对 URL，你只需省略 URL 中的协议。然后，当你的网站被加载时，如果它是通过 HTTP 加载的，则库也将通过 HTTP 加载。如果是通过
    HTTPS 加载的，那么所有库也将通过 HTTPS 加载。
- en: The jQuery object
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery 对象
- en: Before we take a look at the classes of jQuery selectors, let's first look at
    what gets returned by the selector. The result of a call to a selector is always
    a jQuery object. A jQuery object has a lot of array-like features, but it is not
    an array. If you use the jQuery `isArray()` function on it, it will return false.
    For many things, the difference doesn't matter, but occasionally, you may want
    to execute something like `concat()`, but unfortunately, this array method doesn't
    exist on a jQuery object though it has a nearly equivalent method, `add()`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看 jQuery 选择器的类之前，让我们先看看选择器返回了什么。调用选择器的结果始终是一个 jQuery 对象。jQuery 对象具有许多类似数组的功能，但它不是数组。如果你在其上使用
    jQuery 的 `isArray()` 函数，它将返回 false。对于许多事情，这种差异并不重要，但偶尔你可能想要执行像 `concat()` 这样的操作，但不幸的是，这个数组方法在
    jQuery 对象上不存在，尽管它有一个几乎相等的方法 `add()`。
- en: If no elements matching the selector are found, then the length of the jQuery
    object is zero. The null value is never returned. The result is a jQuery object
    with a length of zero or more. This is an important thing to understand since
    it reduces the amount of work you need to do when checking the results of a jQuery
    call. You only have to check whether the length is greater than zero.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到匹配选择器的元素，则 jQuery 对象的长度为零。永远不会返回 null 值。结果是一个长度为零或更多的 jQuery 对象。理解这一点很重要，因为它减少了在检查
    jQuery 调用结果时需要做的工作量。你只需检查长度是否大于零即可。
- en: When making a call to jQuery, you can use its formal name, `jQuery`, or its
    shortened name, '`$`'. Also, keep in mind that strings in JavaScript can begin
    with either a single or double quote just so long as they end with the same quotation
    mark. So, in the examples, you may see either single or double quotes, and there
    is usually no rhyme or reason why I chose one over the other.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 jQuery 时，你可以使用其正式名称`jQuery`，也可以使用其缩写名称`$`。此外，请注意，在 JavaScript 中，字符串可以以单引号或双引号开头，只要它们以相同的引号结束即可。因此，在示例中，你可能会看到单引号或双引号，而且通常没有选择单引号或双引号的原因。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One of the interesting things about JavaScript in the browser is that some methods
    are not actually part of JavaScript; instead, they are provided by the browser.
    This becomes clear when you use JavaScript in an environment that is not browser-based,
    such as `node.js`. The methods of the document method, for example, are not part
    of JavaScript; they are part of the browser. In `node.js`, there is no document
    object and hence no document method. Two other sources of browser methods are
    window and navigator objects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关于浏览器中 JavaScript 的有趣之处之一是，一些方法实际上不是 JavaScript 的一部分；相反，它们是由浏览器提供的。当你在非基于浏览器的环境中使用
    JavaScript，比如 `node.js` 时，这一点就变得很明显。例如，文档方法的方法不是 JavaScript 的一部分；它们是浏览器的一部分。在
    `node.js` 中，没有文档对象，因此也没有文档方法。浏览器方法的另外两个来源是 window 和 navigator 对象。
- en: Creating selectors
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建选择器
- en: One of the things that makes jQuery selectors so cool and easy to learn is that
    they are based on the selectors used by CSS; this is not the case with the browser
    methods. So, if you already know how to create CSS selectors, you will have no
    trouble learning about jQuery selectors. If you don't know about CSS selectors,
    don't worry; jQuery selectors are still easy to learn, and knowing about them
    will give you a head start on learning about CSS selectors.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使 jQuery 选择器如此酷且易学的一点是它们基于 CSS 中使用的选择器；这在浏览器方法中并非如此。因此，如果您已经知道如何创建 CSS 选择器，那么学习
    jQuery 选择器将毫不费力。如果您不了解 CSS 选择器，也不用担心；jQuery 选择器仍然很容易学习，并且了解它们将让您提前学习 CSS 选择器。
- en: ID selectors
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ID 选择器
- en: 'The first kind of selector we will look at is the ID selector. It begins with
    a hash sign and is followed by the same string used in the ID attribute of the
    desired element. Take a look at this example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的第一种选择器是 ID 选择器。它以井号开头，后跟所需元素的 ID 属性中使用的相同字符串。看看这个例子：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the preceding example, note that the result of the selector call is a jQuery
    object. We are free to use either style of quote marks. Also, we can make the
    call using either the formal name or the shortened one. For the remainder of this
    book, I will use the short name, `$`. The `ID` selector returns an array that
    contains either zero or one element. It will never return more than one element.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述示例可以看出，选择器调用的结果是一个 jQuery 对象。我们可以自由地使用引号的任一样式。此外，我们可以使用正式名称或缩写名称进行调用。在本书的其余部分，我将使用简称`$`。`ID`选择器返回一个数组，其中包含零个或一个元素。它永远不会返回多于一个元素。
- en: According to the **W3C** (**World Wide Web Consortium**) specification, each
    DOM element can have one `ID selector` at most, and each `ID selector` must be
    unique to the web page. Now, I've seen a lot of websites that violate the uniqueness
    rule. These are bad sites; don't emulate them. Also, they have unpredictable code.
    When more than one element with the same ID exists, only one will be returned,
    but there is no specification that says which one should be returned. So, code
    may behave differently depending on which browser it is run on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根据**W3C**（**万维网联盟**）规范，每个 DOM 元素最多可以有一个`ID 选择器`，并且每个`ID 选择器`必须对网页唯一。现在，我见过很多违反唯一性规则的网站。这些都是糟糕的网站；不要效仿它们。而且，它们有不可预测的代码。当存在多个具有相同
    ID 的元素时，只返回一个元素，但没有规定应该返回哪一个。因此，代码可能会根据运行的浏览器不同而表现不同。
- en: Class selectors
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类选择器
- en: The next type of selector that we will examine is the class selector. The class
    selector begins with a period and is followed by the name of a class that all
    of desired elements have. Unlike the ID selector that will return one element
    at most, the class selector can return zero, one, or more elements.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的下一个选择器类型是类选择器。类选择器以句点开头，后跟所有所需元素的类的名称。与最多返回一个元素的 ID 选择器不同，类选择器可以返回零个、一个或多个元素。
- en: 'The order of the class in the element makes no difference. It can be the first,
    the last, or some class in the middle, and jQuery will find it:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 元素中类的顺序无关紧要。它可以是第一个、最后一个或中间的某个类，jQuery 都可以找到它：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tag selectors
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签选择器
- en: 'Sometimes, your desired elements don''t have an ID or a class name; they simply
    have the same tag name. This is when you will use the tag selector. It searches
    for elements with a specific tag name, such as `div`, `p`, `li`, and so on. To
    create a tag selector, you pass the name of the tag surrounded by quote marks:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您想要的元素既没有 ID 也没有类名；它们只是具有相同的标签名称。这就是您将使用标签选择器的时候。它搜索具有特定标签名称的元素，例如`div`、`p`、`li`等等。要创建标签选择器，只需传递带引号括起来的标签名称：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Combining selectors
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合选择器
- en: 'What should we do if we want all of the paragraph tags in a single set on the
    page and all elements that contain the `active` class? We could make two calls
    and then use the jQuery `add` method to add the resulting objects together. A
    better way is to combine the selectors and let jQuery do the grunt work of combining
    the results together. To combine selectors, simply put two or more selectors together
    in the string and separate them with a comma:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在页面上将所有段落标签和所有包含`active`类的元素放在一个集合中，我们可以进行两次调用，然后使用 jQuery 的`add`方法将结果对象相加。更好的方法是组合选择器，让
    jQuery 执行组合结果的繁重工作。要组合选择器，只需将两个或更多选择器放在字符串中并用逗号分隔：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is important to remember that a comma is used to separate the selectors.
    If you forget the comma, you won't get an error; you will get a result, only not
    the result you were expecting. Instead, it will be the end result of a descendent
    selector, which is something we will cover in just a bit.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，逗号用来分隔选择器。如果忘记了逗号，你不会收到错误消息；你会得到一个结果，只是不是你所期望的结果。相反，它将是后代选择器的最终结果，这是我们马上就会讨论的一个东西。
- en: Descendent selectors
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后代选择器
- en: 'Sometimes, the elements you want don''t have an easy-to-design selector. Maybe
    they are all children or grandchildren of a specific element. This is where descendent
    selectors come in. They allow you to narrow the focus of the query to a specific
    ancestor and then query from there. There are two types of descendent selectors:
    child selectors and descendant selectors. The desired child must be a direct child
    of the parent. To create a child selector, you create the parent selector, add
    a greater than symbol, and then add the selector to find the children from within
    the result of the parent''s results set.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你希望选择的元素没有一个易于设计的选择器。也许它们都是特定元素的子元素或孙子元素。这就是后代选择器的用武之地。它们允许你将查询的焦点缩小到特定的祖先，然后在那里查询。后代选择器有两种类型：子选择器和后代选择器。所需的子元素必须是父元素的直接子元素。要创建一个子选择器，你需要创建父选择器，加上一个大于符号，然后加上要在父元素结果集中查找子元素的选择器。
- en: 'Consider the following HTML markup:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 HTML 标记：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Take a look at the following code as well:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 还看一下以下代码：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code sample will return all of the `<li>` tags that are children
    of the `<ul id="languages">` element. It will not return the `<li>` tags that
    are children of the `<ul class="greetings">` tag because these are its grandchildren:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码示例将返回所有是 `<ul id="languages">` 元素的子级的 `<li>` 标签。它不会返回 `<ul class="greetings">`
    标签的子级 `<li>` 标签，因为这些是它的孙子：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A descendant selector is nearly identical to a child selector except that it
    lacks the greater than sign. The second query will return all of the `<li>` tags
    contained in `<ul id="languages">` regardless of how far down the descendant tree
    they are.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 后代选择器几乎与子选择器完全相同，只是没有大于号。第二个查询将返回包含在 `<ul id="languages">` 中的所有 `<li>` 标签，而不管它们在后代树中的位置。
- en: Attribute selectors
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性选择器
- en: In addition to selecting elements based on their basic characteristics, such
    as the name, tag, and classes, we can also select elements based on their attributes.
    Attribute selectors are a bit tricky to work with because their syntax is more
    complicated. Also, keep in mind that like other jQuery selectors, if you get the
    syntax wrong, you will not get an error; you will simply get a jQuery object of
    zero length.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了根据元素的基本特征（如名称、标签和类）选择元素外，我们还可以根据它们的属性选择元素。属性选择器在工作时有点棘手，因为它们的语法比较复杂。另外，请记住，与其他
    jQuery 选择器一样，如果你的语法错误，不会收到错误消息；你只会得到一个长度为零的 jQuery 对象。
- en: 'There are only nine attribute selectors, so they are fairly easy to remember,
    and they are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 只有九个属性选择器，所以它们相当容易记住，具体如下：
- en: The `Has Attribute` selector
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`有属性`选择器'
- en: The `Attribute Equals` selector
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`属性等于`选择器'
- en: The `Attribute Not Equal` selector
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`属性不等于`选择器'
- en: The `Attribute Contains` selector
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`属性包含`选择器'
- en: The `Attribute Starts With` selector
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`属性起始为`选择器'
- en: The `Attribute Ends With` selector
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`属性结尾为`选择器'
- en: The `Attribute Contains Prefix` selector
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`属性包含前缀`选择器'
- en: The `Attribute Contains Word` selector
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`属性包含单词`选择器'
- en: The `Multiple Attribute` selector
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`多个属性`选择器'
- en: 'Let''s begin with the simplest one: the `Has Attribute` selector. This selects
    all of the elements that have the specified attribute. The value of the attribute
    doesn''t matter; in fact, it doesn''t even have to have a value:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的一个开始：`有属性`选择器。它选择所有具有指定属性的元素。属性的值无关紧要；事实上，甚至不必有值：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As far as selectors go, this one is very simple. It consists of the name of
    the desired attribute surrounded by square braces. The next two selectors are
    only slightly more complicated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 就选择器而言，这个非常简单。它由所需属性的名称括在方括号中组成。接下来的两个选择器略微复杂一些。
- en: 'The `Has Attribute` selector doesn''t care about the attribute''s value, but
    sometimes, you need the attribute to either have or not have a specific value.
    This is where the `Attribute Equals` selector and its opposite, the `Attribute
    Not Equals` selector, come in. The former returns all of the elements that have
    both the desired attribute and the desired value. Keep in mind that this must
    be an exact match; something close won''t count. The latter returns all of the
    elements that either don''t have the desired attribute or have it but don''t have
    the desired value. The `Attribute Not Equals` selector returns all of the elements
    that weren''t returned by the `Attribute Equals` selector. This is confusing to
    people sometimes, but it shouldn''t be. Just remember that these two selectors
    are opposites:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Has Attribute` 选择器不关心属性的值，但有时，您需要属性要么具有特定的值，要么不具有特定的值。这就是 `Attribute Equals`
    选择器及其相反者 `Attribute Not Equals` 选择器的作用。前者返回所有具有所需属性和所需值的元素。请记住，这必须是精确匹配；接近的东西不算。后者返回所有没有所需属性或者具有但不具有所需值的元素。`Attribute
    Not Equals` 选择器返回 `Attribute Equals` 选择器未返回的所有元素。有时这会让人感到困惑，但不应该。只要记住这两个选择器是相反的：'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next three selectors are also related to each other. Each looks for an
    attribute with a value, only now the value is a substring instead of an exact
    match. The thing that differentiates the three is where they look for the substring.
    The first one, the `Attribute Contains` selector looks for a substring anywhere
    in the attribute''s value. So as long as the string is contained with the value,
    it passes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的三个选择器也彼此相关。每个选择器都寻找一个具有值的属性，只是现在值是子字符串而不是完全匹配。区分这三者的是它们寻找子字符串的位置。第一个选择器，`Attribute
    Contains`，在属性值的任何位置寻找子字符串。只要字符串包含在值中，它就通过：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Attribute Starts With` selector is more specific about where the specified
    substring is located. With it, the string must be at the beginning of the value.
    The value string doesn''t have to be a complete match; only the beginning of the
    strings must match:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Attribute Starts With` 选择器更加具体地指定了子字符串的位置。它要求字符串必须位于值的开头。值字符串不必完全匹配；只有字符串的开头必须匹配：'
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Attribute Ends With` selector matches the specified string to the end
    of the value string. If the end of the value string matches the specified string,
    all is good. Just like with the `Attribute Starts With` selector, the rest of
    the string doesn''t have to match:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Attribute Ends With` 选择器将指定的字符串与值字符串的末尾匹配。如果值字符串的末尾与指定的字符串匹配，那就没问题。就像 `Attribute
    Starts With` 选择器一样，剩下的字符串不必匹配：'
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Telling these selectors apart can be a bit of a pain since they only vary by
    one character, but if you know JavaScript regular expressions, you will recognize
    that jQuery borrowed from them. The '`^`' in a regular expression refers to the
    beginning of a string, and it is used by the `Attribute Begins With` selector.
    The '`$`' in a regular expression refers to the end of a string, and it used in
    the `Attribute Ends With` selector. The `Attribute Contains` selector uses the
    asterisk, `*`, which is the regular expression wildcard character.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 区分这些选择器有点麻烦，因为它们只有一个字符的差异，但是如果您了解 JavaScript 正则表达式，您会认识到 jQuery 借鉴了它们。正则表达式中的
    '`^`' 表示字符串的开头，它用于 `Attribute Begins With` 选择器。正则表达式中的 '`$`' 表示字符串的结尾，它用于 `Attribute
    Ends With` 选择器。`Attribute Contains` 选择器使用了星号 `*`，它是正则表达式通配符字符。
- en: The `Attribute Contains Prefix` selector looks for the specified string at the
    beginning of the value string. It differs from the `Attribute Begins With` selector
    in that the string must match the value exactly if there is no hyphen. If there
    is a hyphen in the value, then the string needs to match the hyphen.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Attribute Contains Prefix` 选择器在值字符串的开头寻找指定的字符串。它与 `Attribute Begins With`
    选择器的区别在于，如果没有连字符，则字符串必须与值完全匹配。如果值中有连字符，则字符串需要与连字符匹配。'
- en: 'The `Attribute Contains Word` selector checks for the specified string anywhere
    in the value string. This may sound suspiciously like the `Attribute Contains`
    selector, but there is a subtle difference. The specified string must be surrounded
    by whitespace, whereas the `Attribute Contains` selector doesn''t care where the
    string is or what is delimiting it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Attribute Contains Word` 选择器检查值字符串中的指定字符串。这听起来可能与 `Attribute Contains` 选择器很相似，但有一个微妙的区别。指定的字符串必须被空白符包围，而
    `Attribute Contains` 选择器不关心字符串在哪里或者什么是分隔它的：'
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The final attribute selector is the `Multiple Attribute` selector, which is
    just a combination of any of the previous attribute selectors. Each selector is
    contained within its own square brackets and is concatenated together. There is
    no need for any separation character:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个属性选择器是`Multiple Attribute`选择器，它只是前面任何属性选择器的组合。每个选择器都包含在自己的方括号内，并连接在一起。不需要任何分隔字符：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have learned some ways to select elements, let's learn how to filter
    the result set of our selection.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了一些选择元素的方法，让我们学习如何过滤我们选择的结果集。
- en: Creating basic filter selectors
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本过滤器选择器
- en: 'Filters take the results of a selector call and whittle it down some more.
    There are three types of filter selectors: basic, child, and content. Basic selectors
    just operate on the jQuery object result set. Child selectors operate on the parent-child
    relation between elements. And the content filters work on the contents of each
    of the elements of the result set.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器将选择器调用的结果进一步减少。有三种类型的过滤器选择器：基本、子、内容。基本选择器仅在 jQuery 对象结果集上操作。子选择器在元素之间的父子关系上操作。内容过滤器处理结果集中每个元素的内容。
- en: There are 14 basic filter selectors. The first group deals with the position
    of a result in the result set. Let's deal with them first.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有 14 个基本过滤器选择器。第一组处理结果集中结果的位置。让我们首先处理它们。
- en: 'One of the easiest to understand is the `:eq()` filter selector. It retrieves
    the result when the index number is passed. It is very much like accessing an
    element in a JavaScript array. And like an array, it is zero-based, so the first
    element is zero, not one:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易理解的之一是`:eq()`过滤选择器。当传递索引号时，它检索结果。它非常类似于访问 JavaScript 数组中的元素。就像数组一样，它是从零开始的，所以第一个元素是零，而不是一：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You create an `:eq()` filter selector by adding a colon and `eq(x)` to a regular
    selector. The `x` here refers to the element's index. If your index is out of
    bounds, no error will be generated.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在常规选择器后添加冒号和`eq(x)`来创建一个`:eq()`过滤选择器。这里的`x`是元素的索引。如果索引超出范围，将不会生成错误。
- en: 'The `:eq()` filter selector allows you to access any item in the result set
    as long as you know the range of possible indexes. But sometimes, this is too
    much work. You may only want to know the first or the last element. For these
    occasions, jQuery provides the `:first` and `:last` filter selectors. Each does
    exactly as their name says: it gets the first or last element:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`:eq()`过滤器选择器允许您访问结果集中的任何项，只要您知道可能的索引范围。但有时候，这太费力了。您可能只想知道第一个或最后一个元素。对于这些情况，jQuery
    提供了`:first`和`:last`过滤选择器。每个选择器都正如它们的名字所说的那样：它获取第一个或最后一个元素：'
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Sticking with the theme of index operations, there are times when we want all
    of the elements up to a certain index or all of those with an index greater than
    a number. For these times, there are the `:lt()` and `:gt()` selectors. The `:lt()`
    selectors return all of the elements whose index is less than the passed value.
    The `:gt()` selectors return all of the elements that are greater than it. Both
    of these selectors also accept negative values, which count from the end of the
    result set rather than the start:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 保持与索引操作的主题一致，有时我们想要获取到某个索引之前的所有元素或所有索引大于某个数字的元素。对于这些时候，有`:lt()`和`:gt()`选择器。`:lt()`选择器返回所有索引小于传递值的元素。`:gt()`选择器返回所有索引大于传递值的元素。这两个选择器还接受负值，它们是从结果集的末尾开始计数而不是从开头开始：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The final two of the basic filters are super handy. They are the `:even` and
    `:odd` selectors. They are pretty simple except for one small weirdness. JavaScript
    is zero-based, so 0 is the first element and zero is even, which means that the
    even selector will grab the first, third, fifth (and so on) elements. Also, the
    odd selector will get the second, fourth, sixth (and so on) elements. It seems
    weird, but it makes perfect sense as long as you remember that JavaScript is zero-based.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个基本过滤器非常方便。它们是`:even`和`:odd`选择器。它们非常简单，除了一个小小的怪异之处。JavaScript 是从零开始的，所以 0
    是第一个元素，零是偶数，这意味着偶数选择器将获取第一个、第三个、第五个（以此类推）元素。另外，奇数选择器将获取第二个、第四个、第六个（以此类推）元素。看起来有些奇怪，但只要记住
    JavaScript 是从零开始的就完全说得通。
- en: The remaining basic attribute filters don't fit neatly into any category. So,
    we will just walk through them one by one, beginning with the `:animated` selector.
    The `:animated` selector returns all of the elements that are currently performing
    animation. Keep in mind that it won't autoupdate, so the state of things that
    were there at the time the query was run, but things will change afterwards.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的基本属性过滤器没有清晰地归入任何类别。因此，我们将逐一讨论它们，从 `:animated` 选择器开始。`:animated` 选择器返回当前正在执行动画的所有元素。请记住，它不会自动更新，因此在运行查询时，事物的状态是在那时存在的，但之后事物会发生变化。
- en: 'The `:focus` selector returns the currently selected element if it is in the
    current result set. Be careful with this selector. I will deal with performance
    issues in a later chapter, but this one can have extremely poor performance if
    it is not used with a result set. Consider that you simply make the following
    call:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`:focus` 选择器返回当前选定的元素（如果它在当前结果集中）。对于这个选择器要小心。我将在后面的章节中讨论性能问题，但是如果不与结果集一起使用，这个选择器的性能可能非常差。考虑一下，你只是简单地调用以下内容：'
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It will search the entire DOM tree for the focused element, which may or may
    not exist. While the preceding call will work, there are much faster ways to do
    this.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它将搜索整个 DOM 树以找到焦点元素，该元素可能存在，也可能不存在。虽然前面的调用会起作用，但是有更快的方法可以做到这一点。
- en: 'The `:header` selector is a handy utility method that returns all of the elements,
    which are `<h1>`, `<h2>`, `<h3>`, `<h4>`, `<h5>`, and `<h6>`. It would be pretty
    easy to make an equivalent to this method yourself, but why bother when this shortcut
    is readily at hand:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`:header` 选择器是一个方便的实用方法，返回所有 `<h1>`、`<h2>`、`<h3>`、`<h4>`、`<h5>` 和 `<h6>` 元素。你自己制作这个方法的等效版本应该相当容易，但是为什么要费这个事呢，当这个快捷方式随手可得时：'
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `:lang` selector will find all of the elements that match the specified
    language. It will match either the language code by itself, `en`, or the language
    code paired with the country code, `en-us`. With the increased emphasis on creating
    global websites, this selector grows more important everyday:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`:lang` 选择器将查找所有与指定语言匹配的元素。它将匹配单独的语言代码，如 `en`，或者语言代码与国家代码配对，如 `en-us`。随着越来越多的全球性网站的重视，这个选择器每天都变得更加重要：'
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `:not` selector is not one of my favorite selectors. It does a logical `not`
    operation on the passed selectors.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`:not` 选择器不是我的最爱之一。它对传递的选择器执行逻辑 `not` 操作。'
- en: 'It has been around since the beginning of jQuery, but in my humble opinion,
    it leads to confusing code. And the last thing that jQuery needs is even hard-to-read
    code. I will talk more about writing readable jQuery code in [Chapter 6](part0047_split_000.html#1CQAE2-6309aac535bb4c1b83b0d7aa1f605023
    "Chapter 6. Better Forms with jQuery"), *Better Forms with jQuery*, but for now,
    you should avoid this one if you can:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它从 jQuery 的开始就存在了，但是在我看来，它导致了混乱的代码。而 jQuery 最不需要的就是更难以阅读的代码。我将在[第 6 章](part0047_split_000.html#1CQAE2-6309aac535bb4c1b83b0d7aa1f605023
    "第 6 章。使用 jQuery 改进表单")中更多地讨论如何编写可读的 jQuery 代码，*使用 jQuery 改进表单*，但是现在，如果可以的话，你应该避免使用它：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `:target` selector sounds complicated, but given the abundance of single
    page JavaScript apps, it can be very useful. It looks at the URL of the current
    page. If it has a fragment, which is identified with a hash sign, it will match
    the element whose ID matches that fragment. This is one of the more recent additions
    to jQuery, having been added with the 1.9 version.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`:target` 选择器听起来很复杂，但是鉴于单页 JavaScript 应用程序的丰富性，它可能非常有用。它查看当前页面的 URL。如果它有一个片段，即用散列符号标识的片段，它将匹配
    ID 与该片段相匹配的元素。这是 jQuery 的较新的添加之一，它是在 1.9 版本中添加的。'
- en: 'And finally, let''s talk about the `:root` selector. I will be honest and admit
    I haven''t needed to use this one yet. It returns the root element of the document,
    which is always the `<html>` element in HTML:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们谈谈 `:root` 选择器。我要诚实地承认，我还没有需要使用这个选择器。它返回文档的根元素，这个根元素始终是 HTML 中的 `<html>`
    元素：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Content filters
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容过滤器
- en: There are only four content filter selectors. I will give a general word of
    caution with all of these selectors since they can be performance-challenged.
    I will go into more details on performance in [Chapter 7](part0054_split_000.html#1JFUC1-6309aac535bb4c1b83b0d7aa1f605023
    "Chapter 7. Talking to Your Server"), *Talking to Your Server*, but until then
    use these selectors only if you must.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 只有四个内容过滤选择器。我会对所有这些选择器提出一个一般性的警告，因为它们可能性能不佳。我将在[第 7 章](part0054_split_000.html#1JFUC1-6309aac535bb4c1b83b0d7aa1f605023
    "第 7 章。与服务器交流")中更详细地讨论性能，*与服务器交流*，但是在那之前，只有在必要时才使用这些选择器。
- en: The first two of these selectors, `:empty` and `:parent`, are inverses of each
    other. The first one, the `:empty` selector, returns all of the elements that
    have no children. The second one, the `:parent` selector, selects all the elements
    that have at least one child.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选择器中的前两个，`:empty`和`:parent`，是彼此的反义词。第一个，`:empty`选择器，返回所有没有子元素的元素。第二个，`:parent`选择器，选择至少有一个子元素的所有元素。
- en: The `:contains` selector returns all of the elements that have the specified
    string. The case of the strings must match. The string can be on any descendent.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`:contains`选择器返回所有具有指定字符串的元素。字符串的大小写必须匹配。字符串可以位于任何后代元素中。'
- en: The `:has()` selector selects all the elements that contain at least one match
    for the specified selector.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`:has()`选择器选择所有包含至少一个匹配项的元素。'
- en: 'Next, there are child selectors. These all deal with the parent-child relationship
    between elements. The first group is pretty easy to understand; it deals with
    the position of the child among all of the children. All of the example code will
    reference the following markup:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是子选择器。这些都涉及元素之间的父子关系。第一组很容易理解；它处理子元素在所有子元素中的位置。所有示例代码都将引用以下标记：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'First up is the `:first-child` selector; it selects all of the elements that
    are the first child of their parent. Unlike the `:first` selector, it can return
    multiple elements:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是`:first-child`选择器；它选择所有作为其父元素的第一个子元素的元素。与`:first`选择器不同，它可以返回多个元素：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first line of the example code says that you should grab all of the paragraph
    descendants of the `div` tags. There are three defined `<div>` tags; the first
    one has five paragraphs, the second one has three paragraphs, and the third one
    has only one paragraph. The `:first-child` selector looks at those nine paragraphs
    and finds the three that are the first children of their respective parents. Here
    they are:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码的第一行说你应该获取所有`div`标签的段落后代。有三个定义的`<div>`标签；第一个有五个段落，第二个有三个段落，第三个只有一个段落。`:first-child`选择器查看这九个段落，并找到它们各自父元素的前三个子元素。这里它们是：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `:last-child` selector operates in a manner similar to `first-child` except
    that it searches for the last child of their respective parent:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`:last-child`选择器的操作方式类似于`first-child`，只是它搜索其各自父元素的最后一个子元素：'
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Again, we are asking for all of the paragraph children of the `div` tags and
    then filtering the return set with the child selector. This example is nearly
    identical to the previous, except that the elements returned by it are counted
    from the end, not the beginning:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们要求获取所有`div`标签的段落子元素，然后用子选择器过滤返回集。这个示例几乎与之前的示例相同，只是返回的元素是从末尾而不是从开头计数的：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you did a double-take on the fact that the last paragraph, `<p>I am the
    only child of div #3.</p>`, is identical for both method calls, don''t be alarmed.
    Remember, it is the only child of the third `<div>`, so it is both the first and
    the last child.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对最后一段`<p>我是第三个div的唯一子元素。</p>`与两个方法调用相同这一事实感到惊讶，不要惊慌。记住，它是第三个`<div>`的唯一子元素，因此它既是第一个也是最后一个子元素。
- en: 'Next, we have the `:nth-child()` selector. It returns the children whose index
    is passed to the method. The `first-child` selector can be thought of as a special
    case of this selector where the passed index is 1\. As I''ve mentioned previously,
    if you pass an index value that is out of range, there is no error; you simply
    get a jQuery object of a length that equals 0:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`:nth-child()`选择器。它返回传递给方法的索引的子元素。`first-child`选择器可以被视为传递索引为1的这个选择器的特殊情况。正如我之前提到的，如果传递了超出范围的索引值，不会出现错误；你只会得到一个长度等于0的jQuery对象：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A special thing about this and the `:nth-last-child()` selectors is that in
    addition to passing an index value, you can also pass in some special values.
    The first two special values are `even` and `odd`. These will return the even
    and the odd children of their respective parents. The result set is different
    from that of the `:even` selector. Because these selectors are based on CSS, counting
    begins with one, not the zero of JavaScript. So, take a look at the following
    code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个和`:nth-last-child()`选择器的一个特殊之处是，除了传递索引值之外，你还可以传递一些特殊值。前两个特殊值是`even`和`odd`。这些将返回其各自父元素的偶数和奇数子元素。结果集与`:even`选择器的结果集不同。因为这些选择器是基于CSS的，计数从一开始，而不是JavaScript中的零。所以，看一下以下代码：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The odd parameter will return the first, third, fifth (and so forth) elements:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 奇数参数将返回第一个、第三个、第五个（依此类推）元素：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `:nth-last-child()` selector is essentially the same as the `nth-child()`
    selector except that it counts backwards from the end of the list instead of the
    beginning. The `:last-child` selector can, likewise, be thought of as a special
    case of this selector with a passed index of 1\. And like the `:nth-child` selector,
    it can accept the special parameters of even, odd, or a formula:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`:nth-last-child()` 选择器与 `nth-child()` 选择器本质上相同，只是从列表末尾向前计数而不是从开头。同样，`:last-child`
    选择器也可以被视为该选择器的特例，传递的索引为1。和 `:nth-child` 选择器一样，它可以接受 even、odd 或公式等特殊参数：'
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The result set from the example code consists of two elements, the third child
    from the end of their respective parents:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码的结果集由两个元素组成，分别是它们各自父元素的倒数第三个子元素：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The last of the child selectors is `:only-child`. It returns the elements that
    only children of their respective parents can:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 子选择器中的最后一个是 `:only-child`。它返回其各自父元素的唯一子元素：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since there is only one paragraph that is an only child, the following element
    is displayed:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有一个段落是唯一的子元素，所以下一个元素被显示：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next selectors are the `of-type` selectors. All of these selectors work
    on siblings of the same element type. The first of these is the `:first-of-type`
    selector, which will return the first element of the type for each parent:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的选择器是 `of-type` 选择器。所有这些选择器都作用于相同元素类型的兄弟元素。其中第一个是 `:first-of-type` 选择器，它将返回每个父元素类型的第一个元素：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The difference between the child selectors and the `of-type` selectors is subtle
    but important. The `of-type` selectors don't specify the parent element. You simply
    tell jQuery about the children, and it figures out which ones are siblings and
    who the parents are.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 子选择器和 `of-type` 选择器之间的区别微妙但重要。`of-type` 选择器不指定父元素。你只需告诉 jQuery 关于子元素，它就会弄清哪些是兄弟元素，父元素是谁。
- en: 'The `:last-of-type` selector does exactly what we should expect based on everything
    we''ve already learned about jQuery. It returns the last element of the type:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`:last-of-type` 选择器根据我们已经学到的关于 jQuery 的所有内容，做的正是我们所期望的。它返回了该类型的最后一个元素：'
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The last of the `of-type` selectors will seem familiar; it is the `:only-of-type`
    selector. Like the `:only-child` selector, it returns the only children. But unlike
    the :`only-child` selector, it looks at the type of the element. So, consider
    that we change the third `<div>` to the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`of-type` 选择器中的最后一个看起来很熟悉；它是 `:only-of-type` 选择器。像 `:only-child` 选择器一样，它返回唯一的子元素。但不像
    `:only-child` 选择器，它查看元素的类型。所以，考虑到我们将第三个 `<div>` 更改为以下内容：'
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We make the change when we run the following code sample:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码示例时，我们进行了更改：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This returns the following element:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下元素：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'However, the corresponding code written using the `:only-child` selector returns
    no elements:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 `:only-child` 选择器编写的相应代码不返回任何元素：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using chaining to quickly and neatly continue queries
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用链接快速整洁地继续查询
- en: One of the nice things about jQuery is its ability to chain queries. Any method
    call that returns the jQuery object can be chained, which means that all you need
    to do is add a period and your next method call. Be careful since not all methods
    return the jQuery object. Some methods, such as `.width()`, return a value that
    can't be chained. Each method of the chain performs its operations on the result
    set of the previous method call. If you perform filter operations further down
    the chain, then the result set is reduced, and the chained methods will work on
    the reduced set and not the original.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 的一个好处是它能够链接查询。任何返回 jQuery 对象的方法调用都可以链接，这意味着你只需要添加一个句点和你的下一个方法调用。但要小心，因为并不是所有方法都返回
    jQuery 对象。一些方法，如 `.width()`，返回无法链接的值。链中的每个方法都在前一个方法调用的结果集上执行其操作。如果在链的后续操作中执行过滤操作，则结果集将减少，链式方法将在减少的集合上工作而不是原始集合上。
- en: 'The next example isn''t the greatest, but hopefully, it will begin to demonstrate
    the power of chaining:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例不是最好的，但希望它能开始展示链接的强大之处：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this example, we first ask for all of the `<li>` elements on the page. Then,
    with the results set in hand, we ask for all of the `<ul>` elements it contains.
    We can ask for this more succinctly with the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先要求页面上的所有 `<li>` 元素。然后，有了结果集，我们要求它包含的所有 `<ul>` 元素。我们可以用以下代码更简洁地请求：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The point here is that we used jQuery's chaining ability to perform more operations
    on the result set. Often, you will use chaining to perform different operations
    in each link in the chain. You might want to add a CSS class at one step, perform
    DOM manipulations on another, and so on. For the sake of clarity, try to keep
    all of the operations related, or you may end up writing code that can't be read
    easily.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的要点是我们利用了 jQuery 的链式能力来在结果集上执行更多操作。通常情况下，您会使用链式来在链中的每个链接中执行不同的操作。您可能想在一个步骤中添加
    CSS 类，对另一个步骤进行 DOM 操作，依此类推。为了清晰起见，请尽量保持所有操作相关，否则您可能会编写难以阅读的代码。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we began to dig into jQuery, and hopefully, we found out that
    it isn't as hopelessly complicated as it looks from the outside. We also saw that
    jQuery makes a habit of using preexisting ways of doing things. For example, it
    uses CSS selectors and symbols similar to those used by JavaScript regular expressions.
    It also follows a regular pattern of breaking things down. Once you get used to
    these patterns, you can almost predict the existence of certain methods.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始深入研究 jQuery，并希望发现它并不像从外面看起来那样复杂。我们也看到 jQuery 习惯于使用现有的做事方式。例如，它使用 CSS
    选择器和与 JavaScript 正则表达式类似的符号。它还遵循一种常规模式来分解事物。一旦你习惯了这些模式，你几乎可以预测某些方法的存在。
- en: Now that we have learned how to read elements from the DOM, in the next chapter,
    we will learn how to write markups to the DOM and begin to make dynamic web pages.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何从 DOM 中读取元素，在下一章中，我们将学习如何向 DOM 写入标记，并开始制作动态网页。
