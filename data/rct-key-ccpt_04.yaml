- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Working with Events and State
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与事件和状态一起工作
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下几点：
- en: Add user event handlers (for example, for reacting to button clicks) to React
    apps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向React应用添加用户事件处理器（例如，用于对按钮点击做出反应）
- en: Update the **user interface** ( **UI** ) via a concept called **state**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一个称为**状态**的概念来更新**用户界面**（**UI**）
- en: Build real dynamic and interactive UIs (that is, so that they are not static
    anymore)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建真正的动态和交互式UI（即它们不再是静态的）
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapters, you learned how to build UIs with the help of React
    **components** . You also learned about **props** —a concept and feature that
    enables React developers to build and reuse configurable components.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何在React **组件** 的帮助下构建UI。你也了解了**属性**——这是一个概念和功能，它使React开发者能够构建和重用可配置的组件。
- en: These are all important React features and building blocks, but with these features
    alone, you would only be able to build static React apps (that is, web apps that
    never change). You would not be able to change or update the content on the screen
    if you only had access to those features. You also would not be able to react
    to any user events and update the UI in response to such events (for instance,
    to show an overlay window upon a button click).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是重要的React特性和构建块，但仅凭这些特性，你只能构建静态的React应用（即永远不会改变的Web应用）。如果你只能访问这些特性，你就无法更改或更新屏幕上的内容。你也不能对任何用户事件做出反应，并更新UI以响应这些事件（例如，在按钮点击时显示覆盖窗口）。
- en: Put in other words, you would not be able to build real websites and web applications
    if you were limited to just components and props.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 用其他的话说，如果你仅仅局限于组件和属性，你就无法构建真正的网站和Web应用。
- en: 'Therefore, in this chapter, a brand-new concept is introduced: state. State
    is a React feature that allows developers to update internal data and trigger
    a UI update based on such data adjustments. In addition, you will learn how to
    react (no pun intended) to user events such as button clicks or text being entered
    into input fields.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，引入了一个全新的概念：状态。状态是React的一个功能，允许开发者更新内部数据，并根据这些数据调整触发UI更新。此外，你还将学习如何对用户事件（如按钮点击或输入字段中输入的文本）做出反应。
- en: What’s the Problem?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题是什么？
- en: 'As outlined previously, at this point in the book, there is a problem with
    all React apps and sites you might be building: they’re static. The UI can’t change.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在本书的这个阶段，你可能会遇到所有构建的React应用和网站的问题：它们是静态的。UI无法改变。
- en: 'To understand this issue a bit better, take a look at a typical React component,
    as you are able to build it up to this point in the book:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个问题，看看一个典型的React组件，就像你现在能够构建到本书的这个阶段一样：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This component might look strange though. Why is there a `<p>` element that
    informs the user about an incorrect email address?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件可能看起来有点奇怪。为什么会有一个 `<p>` 元素通知用户关于不正确的电子邮件地址？
- en: Well, the goal might be to show that paragraph only if the user *did* enter
    an incorrect email address. That is to say, the web app should wait for the user
    to start typing and evaluate the user input once the user is done typing (that
    is, once the input loses focus). Then, the error message should be shown if the
    email address is considered invalid (for example, an empty input field or a missing
    `@` symbol).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，目标可能是只有在用户*确实*输入了不正确的电子邮件地址时才显示那个段落。也就是说，Web应用应该等待用户开始输入，并在用户完成输入（即输入失去焦点）后评估用户输入。然后，如果电子邮件地址被认为无效（例如，空输入字段或缺少`@`符号），则应显示错误消息。
- en: But at the moment, with the React skills picked up thus far, this is something
    you would not be able to build. Instead, the error message would always be shown
    since there is no way of changing it based on user events and dynamic conditions.
    In other words, this React app is a static app, not dynamic. The UI can’t change.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但目前，凭借到目前为止学到的React技能，这是你无法构建的。相反，错误消息总是会显示，因为没有方法可以根据用户事件和动态条件来更改它。换句话说，这个React应用是一个静态应用，不是动态的。UI无法改变。
- en: Of course, changing UIs and dynamic web apps are things you might want to build.
    Almost every website that exists contains some dynamic UI elements and features.
    Therefore, that’s the problem that will be solved in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，改变UI和动态Web应用是你可能想要构建的事情。几乎每个存在的网站都包含一些动态UI元素和功能。因此，这就是本章要解决的问题。
- en: How Not to Solve the Problem
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何不解决问题
- en: How could the component shown previously be made more dynamic?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使之前展示的组件更加动态？
- en: 'The following is one solution you could come up with ( *spoiler* , *the code
    won’t work, so you don’t need to try running it* ):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可能想到的一个解决方案（*剧透*，这段代码将无法工作，所以你不需要尝试运行它）：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code won’t work, because you can’t select React-rendered DOM elements from
    inside the same component file this way. This is just meant as a dummy example
    of how you could try to solve this. That being said, you could put the code below
    the component function some place where it does execute successfully (for example,
    into a `setTimeout()` callback that fires after a second, allowing the React app
    to render all elements onto the screen).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将无法工作，因为你不能以这种方式从同一组件文件内部选择React渲染的DOM元素。这只是一个示例，说明你可以尝试如何解决这个问题。话虽如此，你可以在组件函数下方某个地方放置下面的代码，以便它能够成功执行（例如，放入`setTimeout()`回调函数中，在1秒后触发，允许React应用将所有元素渲染到屏幕上）。
- en: Put in the right place, this code will add the email validation behavior described
    earlier in this chapter. Upon the built-in `blur` event, the `evaluateEmail` function
    is triggered. This function receives the `event` object as an argument (automatically,
    by the browser), and therefore the `evaluateEmail` function is able to parse the
    entered value from that `event` object via `event.target.value` . The entered
    value can then be used in an `if` check to conditionally display or remove the
    error message.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码放在正确的位置，这段代码将添加本章前面描述的电子邮件验证行为。在内置的`blur`事件发生时，`evaluateEmail`函数被触发。这个函数接收`event`对象作为参数（由浏览器自动提供），因此`evaluateEmail`函数能够通过`event.target.value`解析从该`event`对象中输入的值。然后，可以使用`if`检查来有条件地显示或删除错误消息。
- en: '**Note**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: All the preceding code that deals with the `blur` event (such as `addEventListener`
    ) and the `event` object, including the code in the `if` check, is standard JavaScript
    code. It is not specific to React in any way.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有处理`blur`事件（如`addEventListener`）和`event`对象的代码，包括`if`检查中的代码，都是标准的JavaScript代码。它以任何方式都不特定于React。
- en: If you find yourself struggling with this non-React code, it’s strongly recommended
    that you dive into more vanilla JavaScript resources (such as the guides on the
    MDN website at [https://developer.mozilla.org/en-US/docs/Web/JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)
    ) first.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己在这段非React代码上遇到了困难，强烈建议你首先深入研究更多纯JavaScript资源（例如，MDN网站上的指南[https://developer.mozilla.org/en-US/docs/Web/JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)）。
- en: But what’s wrong with this code if it would work in some places of the overall
    application code?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果这段代码在某些地方的工作正常，它有什么问题呢？
- en: It’s imperative code! That means you are writing down step-by-step instructions
    on what the browser should do. You are not declaring the desired end state; you
    are instead describing a way of getting there; and it’s not using React.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命令式代码！这意味着你正在写下浏览器应该按步骤执行的指令。你并没有声明所需的最终状态；相反，你描述了一种达到该状态的方式；而且这不是使用React。
- en: Keep in mind that React is all about controlling the UI and that writing React
    code is about writing declarative code—instead of imperative code. Revisit *Chapter
    2* , *Understanding React Components and JSX* , if that sounds brand new to you.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，React的全部内容都是关于控制UI，编写React代码是关于编写声明式代码——而不是命令式代码。如果你觉得这一点听起来很新鲜，请重新阅读*第2章*，*理解React组件和JSX*。
- en: You could achieve your goal by introducing this kind of code, but you would
    be working against React and its philosophy (React’s philosophy being that you
    declare your desired end states and let React figure out how to get there). A
    clear indicator of this is the fact that you would be forced to find the right
    place for this kind of code in order for it to work.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过引入这种类型的代码来实现你的目标，但你会与React及其哲学作对（React的哲学是声明你的所需最终状态，让React找出如何达到那里）。一个明显的迹象是，你将被迫找到这种代码的正确位置，以便它能够工作。
- en: This is not a philosophical problem, and it’s not just some weird hard rule
    that you should follow. Instead, by working against React like this, you will
    make your life as a developer unnecessarily hard. You are neither using the tools
    React gives you nor letting React figure out how to achieve the desired (UI) state.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个哲学问题，也不仅仅是一些奇怪的硬性规则，你应该遵循。相反，通过这样与React作对，你将使作为开发者的生活变得不必要地艰难。你既没有使用React提供的工具，也没有让React找出如何实现所需（UI）状态的方法。
- en: That does not just mean that you spend time on solving problems you wouldn’t
    have to solve. It also means that you’re passing up possible optimizations React
    might be able to perform under the hood. Your solution is very likely not just
    leading to more work (that is, more code) for you; it also might result in a buggy
    result that could also suffer from suboptimal performance.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅意味着你花费时间解决你本不必解决的问题。这也意味着你放弃了React可能在底层执行的可能优化。你的解决方案很可能不仅导致你做更多的工作（也就是说，写更多的代码），还可能导致有缺陷的结果，也可能遭受性能不佳的问题。
- en: The example shown previously is a simple one. Think about more complex websites
    and web apps, such as online shops, vacation rental websites, or web apps such
    as Google Docs. There, you might have dozens or hundreds of (dynamic) UI features
    and elements. Managing them all with a mixture of React code and standard vanilla
    JavaScript code will quickly become a nightmare. Again, refer to *Chapter 2, Understanding
    React Components and JSX,* of this book to understand the merits of React.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的例子是一个简单的例子。想想更复杂的网站和Web应用，比如在线商店、度假租赁网站，或者像Google Docs这样的Web应用。在那里，你可能会有数十个或数百个（动态）UI功能和元素。用React代码和标准vanilla
    JavaScript代码的混合来管理它们将很快变成一场噩梦。再次参考本书的*第2章，理解React组件和JSX*，以了解React的优点。
- en: A Better Incorrect Solution
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的错误解决方案
- en: 'The naïve approach discussed previously doesn’t work well. It forces you to
    figure out how to make the code run correctly (for example, by wrapping parts
    of it in some `setTimeout()` call to defer execution) and leads to your code being
    scattered all over the place (that is, inside of React component functions, outside
    of those functions, and maybe also in totally unrelated files). How about a solution
    that embraces React, like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 之前讨论的简单方法效果不佳。它迫使你找出如何使代码正确运行（例如，通过将部分代码包裹在某个`setTimeout()`调用中以延迟执行）并导致你的代码四处散落（也就是说，在React组件函数内部，外部，也许也在完全不相关的文件中）。那么，一个拥抱React的解决方案如何呢？
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code again would not work (even though it’s technically valid JavaScript
    code). Selecting JSX elements doesn’t work like this. It doesn’t work because
    `document.querySelector('input')` executes before anything is rendered to the
    DOM (when the component function is executed for the first time). Again, you would
    have to delay the execution of that code until the first render cycle is over
    (you would therefore be once again working against React).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码再次无法工作（尽管它在技术上有效的JavaScript代码）。选择JSX元素的方式不是这样的。它无法工作是因为`document.querySelector('input')`在将任何内容渲染到DOM之前执行（当组件函数第一次执行时）。再次强调，你必须将这段代码的执行延迟到第一次渲染周期结束（因此你又一次与React作对）。
- en: But even though it still would not work, it’s closer to the correct solution.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它仍然不会工作，但它更接近正确的解决方案。
- en: It’s closer to the ideal implementation because it embraces React way more than
    the first attempted solution did. All the code is contained in the component function
    to which it belongs. The error message is handled via an `errorMessage` variable
    that is output as part of the JSX code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它更接近理想的实现，因为它比第一次尝试的解决方案更多地采用了React的方式。所有代码都包含在它所属的组件函数中。错误信息通过一个作为JSX代码一部分输出的`errorMessage`变量来处理。
- en: The idea behind this possible solution is that the React component that controls
    a certain UI feature or element is also responsible for its state and events.
    You might identify two important keywords of this chapter here!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可能解决方案背后的想法是，控制某个UI功能或元素的React组件也负责其状态和事件。你可能会在这个章节中识别出两个重要的关键词！
- en: 'This approach is definitely going in the right direction, but it still wouldn’t
    work for two reasons:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法肯定是在正确的方向上，但仍有两个原因它不会工作：
- en: Selecting the JSX `<input>` element via `document.querySelector('input')` would
    fail.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`document.querySelector('input')`选择JSX `<input>`元素将失败。
- en: Even if the input could be selected, the UI would not update as expected.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使输入可以被选择，UI也不会按预期更新。
- en: These two problems will be solved next—finally leading to an implementation
    that embraces React and its features. The upcoming solution will avoid mixing
    React and non-React code. As you will see, the result will be easier code where
    you have to do less work (that is, write less code).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个将要解决这两个问题——最终实现一个完全拥抱React及其特性的实现。即将到来的解决方案将避免混合React和非React代码。正如你将看到的，结果将是更简单的代码，你不需要做更多的工作（也就是说，写更少的代码）。
- en: Improving the Solution by Properly Reacting to Events
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过正确响应事件改进解决方案
- en: Instead of mixing imperative JavaScript code such as `document.querySelector('input')`
    with React-specific code, you should fully embrace React and its features.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与将命令式 JavaScript 代码（如 `document.querySelector('input')`）与 React 特定代码混合相比，您应该完全拥抱
    React 及其功能。
- en: Since listening to events and triggering actions upon events is an extremely
    common requirement, React has a built-in solution. You can attach event listeners
    directly to the JSX elements to which they belong.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于监听事件并在事件上触发动作是一个极其常见的需求，React 提供了一个内置的解决方案。您可以直接将事件监听器附加到它们所属的 JSX 元素上。
- en: 'The preceding example would be rewritten like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例将重写如下：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code still will not update the UI, but at least the event is handled properly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码仍然不会更新 UI，但至少事件得到了适当的处理。
- en: The `onBlur` prop was added to the built-in input element. This prop is made
    available by React, just as all these base HTML elements (such as `<input>` and
    `<p>` ) are made available as components by React. In fact, all these built-in
    HTML components come with their standard HTML attributes as React props (plus
    some extra props, such as the `onBlur` event handling prop).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBlur` 属性被添加到内置的输入元素。这个属性是由 React 提供的，就像所有这些基础 HTML 元素（如 `<input>` 和 `<p>`）都是由
    React 作为组件提供的。实际上，所有这些内置的 HTML 组件都带有它们的标准 HTML 属性作为 React 属性（加上一些额外的属性，如 `onBlur`
    事件处理属性）。'
- en: React exposes all standard events that can be connected to DOM elements as `onXYZ`
    props (where `XYZ` is the event name, such as `blur` or `click` , starting with
    a capital character). You can react to the `blur` event by adding the `onBlur`
    prop. You could listen to a `click` event via the `onClick` prop. You get the
    idea.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: React 将所有可以连接到 DOM 元素的标准事件都暴露为 `onXYZ` 属性（其中 `XYZ` 是事件名称，例如 `blur` 或 `click`，以大写字母开头）。您可以通过添加
    `onBlur` 属性来响应 `blur` 事件。您可以通过 `onClick` 属性来监听 `click` 事件。您应该已经明白了。
- en: '**Note**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: For more information on standard events, see [https://developer.mozilla.org/en-US/docs/Web/Events#event_listing](https://developer.mozilla.org/en-US/docs/Web/Events#event_listing)
    .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 更多有关标准事件的信息，请参阅 [https://developer.mozilla.org/en-US/docs/Web/Events#event_listing](https://developer.mozilla.org/en-US/docs/Web/Events#event_listing)。
- en: These props require values to fulfill their job. To be precise, they need a
    pointer to the function that should be executed when the event occurs. In the
    preceding example, the `onBlur` prop receives a pointer to the `evaluateEmail`
    function as a value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性需要值来履行其职责。更准确地说，它们需要一个指向在事件发生时应执行的函数的指针。在上面的例子中，`onBlur` 属性接收一个指向 `evaluateEmail`
    函数的指针作为值。
- en: '**Note**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'There’s a subtle difference between `evaluateEmail` and `evaluateEmail()` .
    The first is a pointer to the function; the second actually executes the function
    (and yields the return value, if any). Again, this is not something specific to
    React but a standard JavaScript concept. If it’s not clear, this resource explains
    it in greater detail: [https://developer.mozilla.org/en-US/docs/Web/Events#event_listing](https://developer.mozilla.org/en-US/docs/Web/Events#event_listing)
    .'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`evaluateEmail` 和 `evaluateEmail()` 之间有一个细微的差别。前者是指向函数的指针；后者实际上执行了函数（如果有的话，则返回其返回值）。再次强调，这并不是
    React 特有的，而是标准的 JavaScript 概念。如果还不清楚，这个资源可以更详细地解释它：[https://developer.mozilla.org/en-US/docs/Web/Events#event_listing](https://developer.mozilla.org/en-US/docs/Web/Events#event_listing)。'
- en: 'By using these event props, the preceding example code will now finally execute
    without throwing any errors. You could verify this by adding a `console.log(''Hello'');`
    statement inside the `evaluateEmail` function. This will display the `''Hello''`
    text in the console of your browser developer tools, whenever the input loses
    focus:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些事件属性，前面的示例代码现在最终将执行而不会抛出任何错误。您可以通过在 `evaluateEmail` 函数内添加 `console.log('Hello');`
    语句来验证这一点。这将显示 `'Hello'` 文本在浏览器开发者工具的控制台中，每当输入失去焦点时：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the browser console, this looks as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器控制台中，它看起来如下：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_04_01.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B31339_04_01.png)'
- en: 'Figure 4.1: Displaying some text in the browser console upon removing focus
    from the input field'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：在从输入字段移除焦点时在浏览器控制台中显示一些文本
- en: This is definitely one step closer to the best possible implementation, but
    it also still won’t produce the desired result of updating the page content dynamically.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个向最佳可能实现迈进的一步，但它仍然不会产生动态更新页面内容所需的结果。
- en: Updating State Correctly
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确更新状态
- en: By now, you understand how to correctly set up event listeners and execute functions
    upon certain events. What’s missing is a feature that forces React to update the
    visible UI on the screen and the content that is displayed to the app users.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经了解了如何正确设置事件监听器并在某些事件上执行函数。缺少的是一种强制React更新屏幕上可见的UI和显示给应用用户的内容的特性。
- en: That’s where React’s **state** concept comes into play. Like props, state is
    a key concept of React, but whereas props are about receiving external data inside
    a component, state is about managing and updating **internal data** . Most importantly,
    whenever state is updated, React goes ahead and updates the parts of the UI that
    are affected by the state change.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正是React的**状态**概念在这里发挥作用。与props一样，状态是React的关键概念，但与props关于在组件内部接收外部数据不同，状态是关于管理和更新**内部数据**。最重要的是，每当状态更新时，React都会更新受状态变化影响的UI部分。
- en: 'Here’s how state is used in React (of course, the code will then be explained
    in detail afterward):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中如何使用状态（当然，代码将在之后详细解释）：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Compared to the example code discussed earlier in this chapter, this code doesn’t
    look much different. But there is a key difference: the usage of the `useState()`
    Hook.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章前面讨论的示例代码相比，这段代码看起来并没有太大的不同。但有一个关键的区别：`useState()` Hook的使用。
- en: '**Hooks** are another key concept of React. These are special functions that
    can only be used inside of React components (or inside of other Hooks, as will
    be covered in *Chapter 12* , *Building Custom React Hooks* ). Hooks add special
    features and behaviors to the React components in which they are used. For example,
    the `useState()` Hook allows a component (and therefore, implicitly React) to
    set and manage some state that is tied to this component. React provides various
    built-in Hooks, and they are not all focused on state management. You will learn
    about other Hooks and their purposes throughout this book.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hooks**是React的另一个关键概念。这些是只能在React组件内部（或在其他Hooks内部，如第12章*构建自定义React Hooks*所述）使用的特殊函数。Hooks为它们所使用的React组件添加了特殊的功能和行为。例如，`useState()`
    Hook允许组件（以及隐式地React）设置和管理与该组件相关联的一些状态。React提供了各种内置的Hooks，它们并不都专注于状态管理。你将在本书中了解其他Hooks及其用途。'
- en: The `useState()` Hook is an extremely important and commonly used Hook as it
    enables you to manage data inside a component, which, when updated, tells React
    to update the UI accordingly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState()` Hook是一个极其重要且常用的Hook，因为它允许你在组件内部管理数据，当数据更新时，它会告诉React相应地更新UI。'
- en: 'That is the core idea behind state management and this state concept: state
    is data, which, when changed, should force React to re-evaluate a component and
    update the UI if needed.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是状态管理和状态概念背后的核心思想：状态是数据，当它改变时，应该迫使React重新评估组件，并在需要时更新UI。
- en: 'Using Hooks, such as `useState()` , is pretty straightforward: you import them
    from `''react''` and you then call them like a function inside your component
    function. You call them like a function because, as mentioned, React Hooks are
    functions—just special functions (from React’s perspective).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Hooks，如`useState()`，相当简单：你从`'react'`导入它们，然后在组件函数内部像调用函数一样调用它们。你像调用函数一样调用它们，因为如前所述，React
    Hooks是函数——只是特殊的函数（从React的角度来看）。
- en: A Closer Look at useState()
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入了解useState()
- en: How exactly does the `useState()` Hook work and what does it do internally?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState()` Hook究竟是如何工作的，它内部做了什么？'
- en: 'By calling `useState()` inside a component function, you register some data
    with React. It’s a bit like defining a variable or constant in vanilla JavaScript.
    But there is something special: React will track the registered value internally,
    and whenever you update it, React will re-evaluate the component function in which
    the state was registered.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在组件函数内部调用`useState()`，你向React注册了一些数据。这有点像在纯JavaScript中定义一个变量或常量。但有一个特别之处：React会内部跟踪注册的值，每当更新它时，React都会重新评估注册状态的组件函数。
- en: React does this by checking whether the data used in the component changed.
    Most importantly, React validates whether the UI needs to change because of changed
    data (for example, because a value is output inside the JSX code). If React determines
    that the UI needs to change, it goes ahead and updates the real DOM in the places
    where an update is needed (for example, changing some text that’s displayed on
    the screen). If no update is needed, React ends the component re-evaluation without
    updating the DOM.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: React 通过检查组件中使用的数据是否发生变化来完成此操作。最重要的是，React 验证 UI 是否需要因为数据的变化而更改（例如，因为 JSX 代码中输出了一个值）。如果
    React 确定UI需要更改，它将更新需要更新的真实 DOM 中的位置（例如，更改屏幕上显示的文本）。如果不需要更新，React 将在更新 DOM 之前结束组件的重新评估。
- en: React’s internal workings will be discussed in great detail *Chapter 10* , *Behind
    the Scenes of React and Optimization Opportunities* .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: React 的内部工作原理将在第 10 章 *React 和优化机会的幕后* 中详细讨论。
- en: 'The entire process starts with calling `useState()` inside a component. This
    creates a state value (which will be stored and managed by React) and ties it
    to a specific component. An initial state value is registered by simply passing
    it as a parameter value to `useState()` . In the preceding example, an empty string
    ( `''''` ) is registered as a first value:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程从在组件内部调用 `useState()` 开始。这创建了一个状态值（将由 React 存储和管理）并将其绑定到特定的组件。通过简单地将它作为参数值传递给
    `useState()` 来注册初始状态值。在先前的例子中，一个空字符串（`''`）被注册为第一个值：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see in the example, `useState()` does not just accept a parameter
    value. It also returns a value: an array with exactly two elements.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`useState()` 不仅接受一个参数值，它还返回一个值：一个包含恰好两个元素的数组。
- en: The preceding example uses **array destructuring** , which is a standard JavaScript
    feature that allows developers to retrieve values from an array and immediately
    assign them to variables or constants. In the example, the two elements that make
    up the array returned by `useState()` are pulled out of that array and stored
    in two constants ( `errorMessage` and `setErrorMessage` ). You don’t have to use
    array destructuring when working with React or `useState()` , though.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的例子使用了 **数组解构**，这是 JavaScript 的一个标准特性，允许开发者从数组中检索值并将其立即分配给变量或常量。在例子中，组成 `useState()`
    返回的数组的两个元素被从该数组中提取出来并存储在两个常量（`errorMessage` 和 `setErrorMessage`）中。尽管如此，在处理 React
    或 `useState()` 时，你不必使用数组解构。
- en: 'You could also write the code like this instead:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以这样编写代码：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This works absolutely fine, but when using array destructuring, the code stays
    a bit more concise. That’s why you typically see the syntax using array destructuring
    when browsing React apps and examples. You also don’t have to use constants; variables
    (via `let` ) would be fine as well. As you will see throughout this chapter and
    the rest of the book, though, the variables won’t be reassigned, so using constants
    makes sense (but it is not required in any way).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全没问题，但使用数组解构时，代码会更加简洁。这就是为什么在浏览 React 应用和示例时，你通常看到使用数组解构的语法。你也不必使用常量；通过 `let`
    的变量也可以。然而，正如你将在本章和本书的其余部分看到的那样，变量不会被重新赋值，因此使用常量是有意义的（但并非必须）。
- en: '**Note**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: If array destructuring or the difference between variables and constants sounds
    brand new to you, it’s strongly recommended that you refresh your JavaScript basics
    before progressing with this book. As always, MDN provides great resources for
    that (see [http://packt.link/3B8Ct](http://packt.link/3B8Ct) for array destructuring,
    [https://packt.link/hGjqL](https://packt.link/hGjqL) for information on the `let`
    variable, and [https://packt.link/TdPPS](https://packt.link/TdPPS) for guidance
    on the use of `const` ).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对于数组解构或变量与常量的区别感到陌生，强烈建议你在继续阅读本书之前先复习一下 JavaScript 的基础知识。正如往常一样，MDN 提供了很好的资源（有关数组解构，请参阅
    [http://packt.link/3B8Ct](http://packt.link/3B8Ct)，有关 `let` 变量的信息，请参阅 [https://packt.link/hGjqL](https://packt.link/hGjqL)，有关
    `const` 的使用指南，请参阅 [https://packt.link/TdPPS](https://packt.link/TdPPS)）。
- en: As mentioned before, `useState()` returns an array with exactly two elements.
    It will always be exactly two elements—and always exactly the same kind of elements.
    The first element is always the current state value, and the second element is
    a function that you can call to set the state to a new value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`useState()` 返回一个包含恰好两个元素的数组。它总是恰好两个元素——并且总是同一种类的元素。第一个元素总是当前状态值，第二个元素是一个你可以调用的函数，用于将状态设置为新的值。
- en: But how do these two values (the state value and the state-updating function)
    work together? What does React do with them internally? How are these two array
    elements used (by React) to update the UI?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但这两个值（状态值和状态更新函数）是如何一起工作的呢？React在内部如何使用它们？这两个数组元素是如何（由React）用来更新UI的？
- en: A Look Under the Hood of React
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入了解React的内部机制
- en: 'React manages the state values for you, in some internal storage that you,
    the developer, can’t directly access. Since you often do need access to a state
    value (for instance, some entered email address, as in the preceding example),
    React provides a way of reading state values: the first element in the array returned
    by `useState()` . The first element of the returned array holds the current state
    value. You can therefore use this element in any place where you need to work
    with the state value (for example, in the JSX code to output it there).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: React为你管理状态值，在某个你，即开发者，无法直接访问的内部存储中。由于你经常需要访问状态值（例如，一些输入的电子邮件地址，如前例所示），React提供了一种读取状态值的方法：`useState()`返回的数组中的第一个元素。返回数组的第一个元素包含当前状态值。因此，你可以在任何需要使用状态值的地方使用此元素（例如，在JSX代码中输出它）。
- en: In addition, you often also need to update the state—for example, because a
    user entered a new email address. Since you don’t manage the state value yourself,
    React gives you a function that you can call to inform React about the new state
    value. That’s the second element in the returned array.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你通常还需要更新状态——例如，因为用户输入了新的电子邮件地址。由于你无法自行管理状态值，React提供了一个你可以调用的函数来通知React关于新的状态值。这就是返回数组中的第二个元素。
- en: In the example shown before, you call `setErrorMessage('Error!')` to set the
    `errorMessage` state value to a new string ( `'Error!'` ).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面显示的示例中，你调用`setErrorMessage('Error!')`来将`errorMessage`状态值设置为一个新的字符串（`'Error!'`）。
- en: But why is this managed like this? Why not just use a standard JavaScript variable
    that you can assign and reassign as needed?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么是这样管理的呢？为什么不直接使用一个标准的JavaScript变量，根据需要分配和重新分配呢？
- en: Because React must be informed whenever there’s a state that impacts the UI
    changes. Otherwise, the visible UI doesn’t change at all, even in cases where
    it should. React does not track regular variables and changes to their values,
    so they have no influence on the state of the UI.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每当有影响UI变化的状态时，React都必须被告知。否则，可见的UI根本不会改变，即使在应该改变的情况下。React不跟踪常规变量及其值的变化，因此它们对UI的状态没有影响。
- en: The state-updating function exposed by React (that second array element returned
    by `useState()` ) *does* trigger some internal UI-updating effect though. This
    state-updating function does more than set a new value; it also informs React
    that a state value changed and that the UI might therefore be in need of an update.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: React暴露的状态更新函数（`useState()`返回的第二个数组元素）确实会触发一些内部UI更新效果。这个状态更新函数不仅设置了一个新值；它还通知React状态值已更改，因此UI可能需要更新。
- en: So, whenever you call `setErrorMessage('Error!')` , React does not just update
    the value that it stores internally; it also checks the UI and updates it when
    needed. UI updates can involve anything from simple text changes up to the complete
    removal and addition of various DOM elements. Anything is possible there!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次你调用`setErrorMessage('Error!')`时，React不仅更新它内部存储的值；它还会检查UI并在需要时更新它。UI更新可能涉及从简单的文本更改到各种DOM元素的完全删除和添加。任何情况都是可能的！
- en: React determines the new target UI by rerunning (also called re-evaluating)
    any component functions that are affected by a state change. That includes the
    component function that executed the `useState()` function that returned the state-updating
    function that was called. But it also includes any child components, since an
    update in a parent component could lead to new state data that’s also used by
    some child components (the state value could be passed to child components via
    props).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: React通过重新运行（也称为重新评估）受状态变化影响的任何组件函数来确定新的目标UI。这包括执行了`useState()`函数并返回了状态更新函数的组件函数。但也包括任何子组件，因为父组件的更新可能会导致新的状态数据，这些数据也被某些子组件使用（状态值可以通过props传递给子组件）。
- en: 'If you need a visual of how all this fits together, consider the following
    diagram:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个如何将这些内容组合在一起的视觉表示，请考虑以下图表：
- en: '![A diagram of a system  Description automatically generated](img/B31339_04_02.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![系统图解，描述自动生成](img/B31339_04_02.png)'
- en: 'Figure 4.2: React state updating flow'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：React状态更新流程
- en: It’s important to understand and keep in mind that React will re-execute (re-evaluate)
    a component function if a state-updating function is called in the component function
    or some parent component function. This also explains why the state value returned
    by `useState()` (that is, the first array element) can be a constant, even though
    you can assign new values by calling the state-updating function (the second array
    element). Since the entire component function is re-executed, `useState()` is
    also called again (because all the component function code is executed again)
    and hence a new array with two new elements is returned by React. The first array
    element is still the current state value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是理解和记住，如果在组件函数或某些父组件函数中调用了状态更新函数，React 将会重新执行（重新评估）组件函数。这也解释了为什么 `useState()`
    返回的状态值（即第一个数组元素）可以是一个常量，尽管你可以通过调用状态更新函数（第二个数组元素）来分配新值。由于整个组件函数都会重新执行，`useState()`
    也会再次被调用（因为所有组件函数的代码都会再次执行），因此 React 会返回一个新的包含两个新元素的数组。第一个数组元素仍然是当前的状态值。
- en: However, as the component function was called because of a state update, the
    current state value is now the updated value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于组件函数是因为状态更新而被调用的，当前的状态值现在是更新后的值。
- en: This can be a bit tricky to wrap your head around, but it is how React works
    internally. In the end, it’s just about component functions being called multiple
    times by React, just as any JavaScript function can be called multiple times.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点难以理解，但这就是 React 内部的工作方式。最终，这只是 React 多次调用组件函数，就像任何 JavaScript 函数都可以被多次调用一样。
- en: Naming Conventions
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 命名约定
- en: 'The `useState()` Hook is typically used in combination with array destructuring,
    like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState()` 钩子通常与数组解构一起使用，如下所示：'
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But when using array destructuring, the names of the variables or constants
    ( `enteredEmail` and `setEnteredEmail` , in this case) are up to you, the developer.
    Therefore, a valid question is how you should name these variables or constants.
    Fortunately, there is a clear convention when it comes to React and `useState()`
    , and these variable or constant names.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但当使用数组解构时，变量或常量的名称（在这种情况下为 `enteredEmail` 和 `setEnteredEmail`）由你，即开发者来决定。因此，一个合理的问题是，你应该如何命名这些变量或常量。幸运的是，在
    React 和 `useState()` 方面有一个明确的约定，以及这些变量或常量的命名。
- en: The **first element** (that is, the current state value) should be named such
    that it describes what the state value is all about. Examples would be `enteredEmail`
    , `userEmail` , `providedEmail` , just `email` , or similar names. You should
    avoid generic names such as `a` or `value` or misleading names such as `setValue`
    (which sounds like it is a function—but it isn’t).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一个元素**（即当前状态值）的命名应该能够描述状态值的内容。例如，可以是 `enteredEmail`、`userEmail`、`providedEmail`、仅仅是
    `email` 或类似的名字。你应该避免使用通用名称，如 `a` 或 `value`，或者误导性的名称，如 `setValue`（听起来像是一个函数——但实际上不是）。'
- en: The **second element** (that is, the state-updating function) should be named
    such that it becomes clear that it is a function and that it does what it does.
    Examples would be `setEnteredEmail` or `setEmail` . In general, the convention
    for this function is to name it `setXYZ` , where `XYZ` is the name you chose for
    the first element, the current state value variable. (Note, though, that you start
    with an uppercase character, as in `setEnteredEmail` , not `setenteredEmail` .)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二个元素**（即状态更新函数）的命名应该能够清楚地表明它是一个函数，并且它执行了什么操作。例如，可以是 `setEnteredEmail` 或
    `setEmail`。一般来说，这个函数的约定是命名为 `setXYZ`，其中 `XYZ` 是你为第一个元素，当前状态值变量所选择的名称。（注意，尽管如此，你应该以大写字母开头，就像
    `setEnteredEmail` 而不是 `setenteredEmail`。）'
- en: Allowed State Value Types
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 允许的状态值类型
- en: Managing entered email addresses (or user input in general) is indeed a common
    use case and example for working with state. However, you’re not limited to this
    scenario and value type.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 管理输入的电子邮件地址（或一般用户输入）确实是处理状态的一个常见用例和示例。然而，你并不局限于这种场景和值类型。
- en: In the case of entered user input, you will often deal with string values such
    as email addresses, passwords, blog posts, or similar values. But any valid JavaScript
    value type can be managed with the help of `useState()` . You could, for example,
    manage the total sum of multiple shopping cart items—that is, a number—or a Boolean
    value (for example, *“Did a user confirm the terms of use?”* ).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理用户输入的情况下，你通常会处理诸如电子邮件地址、密码、博客文章或类似值的字符串。但任何有效的 JavaScript 值类型都可以通过 `useState()`
    的帮助来管理。例如，你可以管理多个购物车项目的总价——即一个数字——或者一个布尔值（例如，“用户是否确认了使用条款？”）。
- en: Besides managing primitive value types, you can also store and update reference
    data types such as objects and arrays.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了管理原始值类型外，你还可以存储和更新引用数据类型，如对象和数组。
- en: '**Note**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'If the difference between primitive and reference data types is not entirely
    clear, it’s strongly recommended that you dive into this core JavaScript concept
    before proceeding with this book through the following link: [https://academind.com/tutorials/reference-vs-primitive-values](https://academind.com/tutorials/reference-vs-primitive-values)
    .'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对原始数据类型和引用数据类型之间的区别并不完全清楚，强烈建议你在继续阅读本书之前，通过以下链接深入了解这个核心JavaScript概念：[https://academind.com/tutorials/reference-vs-primitive-values](https://academind.com/tutorials/reference-vs-primitive-values)。
- en: React gives you the flexibility of managing all these value types as state.
    You can even switch the value type at runtime (just as you can in vanilla JavaScript).
    It is absolutely fine to store a number as the initial state value and update
    it to a string at a later point in time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: React 允许你将所有这些值类型作为状态来管理。你甚至可以在运行时切换值类型（就像在纯JavaScript中一样）。将数字作为初始状态值，并在稍后将其更新为字符串是完全没问题的。
- en: Just as with vanilla JavaScript, you should, of course, ensure that your program
    deals with this behavior appropriately, though there’s nothing technically wrong
    with switching types.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在纯JavaScript中一样，当然你应该确保你的程序适当地处理这种行为，尽管在技术上切换类型并没有错误。
- en: Working with Multiple State Values
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与多个状态值一起工作
- en: When building anything but very simple web apps or UIs, you will need multiple
    state values. Maybe users can not only enter their email but also a username or
    their address. Maybe you also need to track some error state or save shopping
    cart items. Maybe users can click a “like” button whose state should be saved
    and reflected in the UI. There are many values that change frequently and whose
    changes should be reflected in the UI.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建除了非常简单的Web应用或UI之外的应用时，你需要多个状态值。也许用户不仅能够输入他们的电子邮件，还可以输入用户名或地址。也许你还需要跟踪一些错误状态或保存购物车项目。也许用户可以点击一个“喜欢”按钮，其状态应该被保存并反映在UI上。有许多值会频繁变化，并且其变化应该在UI中体现出来。
- en: 'Consider this concrete scenario: you have a component that needs to manage
    both the value entered by a user into an email input field and the value that
    was inserted into a password field. Each value should be captured once a field
    loses focus.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个具体的场景：你有一个需要管理用户在电子邮件输入字段中输入的值和密码字段中插入的值的组件。每个值都应该在字段失去焦点时被捕获。
- en: 'Since you have two input fields that hold different values, you have two state
    values: the entered email and the entered password. Even though you might use
    both values together at some point (for example, to log a user in), the values
    are not provided simultaneously. In addition, you might also need every value
    to stand alone, since you use it to show potential error messages (for example,
    *“password too short”* ) while the user is entering data.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你有两个包含不同值的输入字段，因此你有两个状态值：输入的电子邮件和输入的密码。即使你可能在某个时刻使用这两个值（例如，用于登录用户），这些值并不是同时提供的。此外，你可能还需要每个值独立存在，因为你在用户输入数据时使用它来显示潜在的错误消息（例如，“密码太短”）。
- en: 'Scenarios like this are very common, and therefore, you can also manage multiple
    state values with the `useState()` Hook. There are two main ways of doing that:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况非常常见，因此，你也可以使用`useState()` Hook来管理多个状态值。主要有两种方法：
- en: Use multiple **state slices** (multiple state values)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用多个**状态片段**（多个状态值）
- en: Using one single, *big* state object
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个单一的、*大的*状态对象
- en: Using Multiple State Slices
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个状态片段
- en: You can manage multiple state values (also often called **state slices** ) by
    simply calling `useState()` multiple times in your component function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在组件函数中多次调用`useState()`来管理多个状态值（也常被称为**状态片段**）。
- en: 'For the example described previously, a (simplified) component function could
    look like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前描述的例子，一个（简化的）组件函数可能看起来像这样：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, two state slices are managed by calling `useState()` twice.
    Therefore, React registers and manages two state values internally. These two
    values can be read and updated independently from each other.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，通过两次调用`useState()`来管理两个状态片段。因此，React内部注册并管理两个状态值。这两个值可以独立于彼此进行读取和更新。
- en: '**Note**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: In the example, the functions that are triggered upon events start with `handle`
    ( `handleUpdateEmail` and `handleUpdatePassword` ). This is a convention used
    by some React developers. Event handler functions start with `handle…` to make
    it clear that these functions handle certain (user-triggered) events. This is
    not a convention you have to follow. The functions could have also been named
    `updateEmail` , `updatePassword` , `emailUpdateHandler` , `passwordUpdateHandler`
    , or anything else. If the name is meaningful and follows some stringent convention,
    it’s a valid choice.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，触发事件时调用的函数以 `handle` 开头（`handleUpdateEmail` 和 `handleUpdatePassword`）。这是一些
    React 开发者使用的约定。事件处理函数以 `handle…` 开头，以清楚地表明这些函数处理某些（用户触发的）事件。这不是你必须遵循的约定。函数也可以命名为
    `updateEmail`、`updatePassword`、`emailUpdateHandler`、`passwordUpdateHandler` 或其他任何名称。如果名称有意义并且遵循某些严格的约定，那么它是一个有效的选择。
- en: You can register as many state slices (by calling `useState()` multiple times)
    as you need in a component. You could have one state value, but you could also
    have dozens or even hundreds. Typically, though, you will only have a couple of
    state slices per component since you should try to split bigger components (which
    might be doing lots of different things) into multiple smaller components to keep
    them manageable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在组件中注册任意数量的状态切片（通过多次调用 `useState()`），以满足你的需要。你可能只有一个状态值，但也可能有几十个甚至几百个。通常情况下，你将只为每个组件拥有几个状态切片，因为你应该尝试将较大的组件（可能执行许多不同的操作）拆分成多个较小的组件，以保持其可管理性。
- en: The advantage of managing multiple state values like this is that you can update
    them independently. If the user enters a new email address, you only need to update
    that email state value. The password state value doesn’t matter for your purposes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式管理多个状态值的优势在于你可以独立地更新它们。如果用户输入了一个新的电子邮件地址，你只需要更新那个电子邮件状态值。对于你的目的来说，密码状态值并不重要。
- en: A possible disadvantage could be that multiple state slices—and therefore multiple
    `useState()` calls—lead to lots of lines of code that might bloat your component.
    As mentioned before, though, you typically should try to break up big components
    (that handle lots of different slices of state) into multiple smaller components
    anyway.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的缺点是，多个状态切片——因此是多个 `useState()` 调用——会导致大量的代码行，这可能会膨胀你的组件。然而，正如之前提到的，你通常应该尝试将大组件（处理许多不同的状态切片）拆分成多个较小的组件。
- en: 'Still, there is an alternative to managing multiple state values like this:
    you can also manage a single, *merged* state value object.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，管理多个状态值还有另一种选择：你也可以管理一个单一的、*合并的*状态值对象。
- en: Managing Merged State Objects
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理合并状态对象
- en: 'Instead of calling `useState()` for every single state slice, you can go for
    one *big* state object that combines all the different state values:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是为每个单独的状态切片调用 `useState()`，你可以选择一个 *大的* 状态对象，它结合了所有不同的状态值：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, `useState()` is called only once (i.e., there’s only one state
    slice), and the initial value passed to `useState()` is a JavaScript object. The
    object contains two properties: `email` and `password` . The property names are
    up to you, but they should describe the values that will be stored in the properties.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`useState()` 只被调用了一次（即只有一个状态切片），传递给 `useState()` 的初始值是一个 JavaScript 对象。该对象包含两个属性：`email`
    和 `password`。属性名由你决定，但它们应该描述将存储在属性中的值。
- en: '`useState()` still returns an array with exactly two elements. That the initial
    value is an object does not change anything about that. The first element of the
    returned array is now just an object instead of a string (as it was in the examples
    shown earlier). As mentioned before, any valid JavaScript value type can be used
    when working with `useState()` . Primitive value types such as strings or numbers
    can be used just as you would reference value types such as objects or arrays
    (which, technically, are objects of course).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState()` 仍然返回一个包含恰好两个元素的数组。初始值是一个对象并不会改变这一点。现在返回数组的第一个元素是一个对象，而不是一个字符串（正如之前展示的例子中那样）。正如之前提到的，当使用
    `useState()` 时，可以使用任何有效的 JavaScript 值类型。原始值类型，如字符串或数字，可以像引用值类型（如对象或数组，技术上它们当然也是对象）一样使用。'
- en: The state-updating function ( `setUserData` , in the preceding example) is still
    a function created by React that you can call to set the state to a new value.
    Also, you wouldn’t have to set it to an object again, though that is typically
    the default. You don’t change value types when updating state unless you have
    a good reason for doing so (though, technically, you are allowed to switch to
    a different type at any time).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 状态更新函数（例如前一个示例中的 `setUserData`）仍然是React创建的函数，您可以调用它来将状态设置为新的值。尽管通常情况下您不需要再次将其设置为对象，但这通常是默认行为。除非您有充分的理由，否则在更新状态时不要更改值类型（尽管，技术上，您可以在任何时候切换到不同的类型）。
- en: '**Note**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: In the preceding example, the way the state-updating function is used is not
    entirely correct. It would work but it does violate recommended best practices.
    You will learn later in this chapter why this is the case and how you should use
    the state-updating function instead.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，使用状态更新函数的方式并不完全正确。它将工作，但它违反了推荐的最佳实践。您将在本章后面学习为什么这是这种情况以及如何使用状态更新函数。
- en: 'When managing state objects as shown in the preceding example, there’s one
    crucial thing you should keep in mind: you must always set all properties the
    object contains, even the ones that didn’t change. This is required because, when
    calling the state-updating function, you *tell* React which new state value should
    be stored internally.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理状态对象，如前一个示例所示，有一件至关重要的事情您必须记住：您必须始终设置对象包含的所有属性，即使是没有更改的属性。这是必需的，因为，在调用状态更新函数时，您“告诉”React应该存储哪个新的状态值。
- en: Thus, any value you pass as an argument to the state-updating function will
    overwrite the previously stored value. If you provide an object that contains
    only the properties that changed, all other properties will be lost since the
    previous state object is replaced by the new one, which contains fewer properties.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您传递给状态更新函数的任何值都将覆盖之前存储的值。如果您提供一个只包含已更改属性的对象，所有其他属性都将丢失，因为上一个状态对象被新的一个替换，而新的对象包含的属性更少。
- en: 'This is a common pitfall and therefore something you must pay attention to.
    For this reason, in the example shown previously, the property that is not changed
    is set to the previous state value—for example, `email: userData.email` , where
    `userData` is the current state snapshot and the first element of the array returned
    by `useState()` , while setting `password` to `event.target.value` .'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个常见的陷阱，因此您必须注意这一点。因此，在前面示例中，未更改的属性被设置为上一个状态值——例如，`email: userData.email`，其中`userData`是当前状态快照，也是`useState()`返回的数组的第一个元素，同时将`password`设置为`event.target.value`。'
- en: It is totally up to you whether you prefer to manage one state value (that is,
    an object grouping together multiple values) or multiple state slices (that is,
    multiple `useState()` calls) instead. There is no right or wrong way and both
    approaches have their advantages and disadvantages.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您完全可以根据自己的喜好来管理一个状态值（即，将多个值组合在一起的对象）或多个状态切片（即，多个`useState()`调用）。没有正确或错误的方法，两种方法都有其优点和缺点。
- en: However, it is worth noting that you should typically try to break up *big*
    components into smaller ones. Just as regular JavaScript functions shouldn’t do
    too much work in a single function (it is considered a good practice to have separate
    functions for different tasks), components should focus on one or only a few tasks
    per component as well. Instead of having a huge `<App />` component that handles
    multiple forms, user authentication, and a shopping cart directly in one component,
    it would be preferable to split the code of that component into multiple smaller
    components that are then combined to build the overall app.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，您通常应该尝试将大型组件拆分成更小的组件。就像常规JavaScript函数不应该在单个函数中做太多工作（被认为是一种良好的实践，为不同的任务有单独的函数）一样，组件也应该专注于每个组件的一个或几个任务。而不是有一个巨大的`<App
    />`组件，该组件直接在一个组件中处理多个表单、用户身份验证和购物车，最好是将其代码拆分成多个较小的组件，然后将这些组件组合起来构建整个应用程序。
- en: When following that advice, most components shouldn’t have too much state to
    manage anyway, since managing many state values is an indicator of a component
    doing *too much work* . That’s why you might end up using a few state slices per
    component, instead of large state objects.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循那条建议时，大多数组件实际上不需要管理太多状态，因为管理许多状态值是组件做“太多工作”的指标。这就是为什么您可能会在每个组件中使用几个状态切片，而不是大型状态对象。
- en: Updating State Based on Previous State Correctly
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确基于前一个状态更新状态
- en: When learning about objects as state values, you learned that it’s easy to accidentally
    overwrite (and lose) data because you might set the new state to an object that
    contains only the properties that changed—not the ones that didn’t. That’s why,
    when working with objects or arrays as state values, it’s important to always
    add the existing properties and elements to the new state value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当学习对象作为状态值时，你了解到很容易不小心覆盖（并丢失）数据，因为你可能将新状态设置为只包含已更改属性的对象——而不是未更改的属性。这就是为什么在处理对象或数组作为状态值时，始终将现有属性和元素添加到新状态值中很重要的原因。
- en: Also, in general, setting a state value to a new value that is (at least partially)
    based on the previous state is a common task. You might set `password` to `event.target.value`
    but also set `email` to `userData.email` to ensure that the stored email address
    is not lost due to updating a part of the overall state (that is, because of updating
    the password to the newly entered value).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通常，将状态值设置为基于前一个状态的新值（至少部分基于前一个状态）是一个常见任务。你可能将`password`设置为`event.target.value`，但也将`email`设置为`userData.email`，以确保存储的电子邮件地址不会因为更新整体状态的一部分（即，因为更新密码为新输入的值）而丢失。
- en: 'That’s not the only scenario where the new state value could be based on the
    previous one, though. Another example would be a `counter` component—for example,
    a component like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是新状态值可能基于前一个状态的唯一场景。另一个例子是一个`counter`组件——例如，一个像这样的组件：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, a `click` event handler is registered for `<button>` (via the
    `onClick` prop). Upon every click, the counter state value is incremented by `1`
    .
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，为`<button>`元素注册了一个`click`事件处理程序（通过`onClick`属性）。每次点击时，计数器的状态值都会增加`1`。
- en: 'This component would work, but the code shown in the example snippet is actually
    violating an important best practice and recommendation: state updates that depend
    on some previous state should be performed with the help of a function that’s
    passed to the state-updating function. To be precise, the example should be rewritten
    like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件可以正常工作，但示例代码片段中展示的代码实际上违反了一个重要的最佳实践和推荐：依赖于某些先前状态的状态更新应该通过传递给状态更新函数的函数来完成。更准确地说，示例应该这样重写：
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This might look a bit strange. It might seem like a function is now passed as
    the new state value to the state-updating function (that is, the number stored
    in `counter` is replaced with a function). But, indeed, that is not the case.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点奇怪。它可能看起来像是现在将一个函数作为新的状态值传递给了状态更新函数（即，`counter`中存储的数字被一个函数所替代）。但实际上并非如此。
- en: 'Technically, a function *is* passed as an argument to the state-updating function,
    but React won’t store that function as the new state value. Instead, when receiving
    a function as a new state value in the state-updating function, React will call
    that function for you and pass the latest state value to that function. Therefore,
    you should provide a function that accepts at least one parameter: the previous
    state value. This value will be passed into the function automatically by React
    when React executes the function (which it will do internally).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，确实是将一个函数作为参数传递给了状态更新函数，但React不会将这个函数存储为新状态值。相反，当状态更新函数接收到一个函数作为新的状态值时，React会为你调用这个函数，并将最新的状态值传递给它。因此，你应该提供一个至少接受一个参数的函数：前一个状态值。这个值将由React在执行函数时（它将在内部执行）自动传递给函数。
- en: The function should then also return a value—the new state value that should
    be stored by React. Also, since the function receives the previous state value,
    you can now derive the new state value based on the previous state value (for
    example, by adding the number 1 to it, but any operation could be performed here).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数应该返回一个值——React应该存储的新状态值。此外，由于函数接收到了前一个状态值，你现在可以根据前一个状态值推导出新状态值（例如，通过将其与数字1相加，但这里可以执行任何操作）。
- en: Why is this required if the app worked fine before this change as well? It’s
    required because, in more complex React applications and UIs, React could be processing
    many state updates simultaneously—potentially triggered from different sources
    at different times.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在这次更改之前应用运行正常的情况下还需要这样做呢？这是因为，在更复杂的React应用和UI中，React可能会同时处理多个状态更新——这些更新可能来自不同的来源，在不同的时间触发。
- en: When *not* using the approach discussed in the last paragraphs, the order of
    state updates might not be the expected one and bugs could be introduced into
    the app. Even if you know that your use case won’t be affected and the app does
    its job without issue, it is recommended to simply adhere to the discussed best
    practice and pass a function to the state-updating function if the new state depends
    on the previous state.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当**不**使用上一段中讨论的方法时，状态更新的顺序可能不是预期的，并且可能会在应用中引入错误。即使你知道你的用例不会受到影响，并且应用在没有问题的状态下完成其工作，也建议简单地遵循讨论过的最佳实践，并在新状态依赖于前一个状态时将函数传递给状态更新函数。
- en: 'With this newly gained knowledge in mind, take another look at an earlier code
    example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在心中牢记这一新获得的知识，再看看之前的代码示例：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Can you spot the error in this code?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你能在这段代码中找到错误吗？
- en: It’s not a technical error; the code will execute fine, and the app will work
    as expected. But there is a problem with this code nonetheless. It violates the
    discussed best practice. In the code snippet, the state in both handler functions
    is updated by referring to the current state snapshot via `userData.password`
    and `userData.email` , respectively.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个技术错误；代码将正常执行，应用将按预期工作。但尽管如此，这段代码还是有问题。它违反了讨论过的最佳实践。在代码片段中，两个处理函数中的状态都是通过`userData.password`和`userData.email`分别引用当前状态快照来更新的。
- en: 'The code snippet should be rewritten like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段应该这样重写：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By passing an arrow function as an argument to `setUserData` , you allow React
    to call that function. React will do this automatically (that is, if it receives
    a function in this place, React will call it) and it will provide the previous
    state ( `prevState` ) automatically. The returned value (the object that stores
    the updated `email` or `password` and the currently stored `email` or `password`
    ) is then set as the new state. The result, in this case, might be the same as
    before, but now the code adheres to recommended best practices.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将箭头函数作为`setUserData`的参数传递，你允许React调用该函数。React会自动这样做（也就是说，如果它在这一点上收到一个函数，React会调用它），并且它会自动提供前一个状态（`prevState`）。然后返回的值（存储更新后的`email`或`password`以及当前存储的`email`或`password`的对象）被设置为新的状态。在这种情况下，结果可能与之前相同，但现在代码遵循了推荐的最佳实践。
- en: '**Note**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: In the previous example, an arrow function was used instead of a “regular” function.
    Both approaches are fine, though. You can use either of the two function types;
    the result will be the same.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，使用了箭头函数而不是“常规”函数。两种方法都很好，你可以使用这两种函数类型中的任何一种；结果将是相同的。
- en: In summary, you should always pass a function to the state-updating function
    if the new state depends on the previous state. Otherwise, if the new state depends
    on some other value (for instance, user input), directly passing the new state
    value as a function argument is absolutely fine and recommended.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，如果你新状态依赖于前一个状态，你应该始终将函数传递给状态更新函数。否则，如果新状态依赖于其他值（例如，用户输入），直接将新状态值作为函数参数传递是完全没问题且推荐的。
- en: Two-Way Binding
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双向绑定
- en: 'There is one special usage of React’s state concept that is worth discussing:
    **two-way binding** .'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 值得讨论的是React状态概念的一个特殊用法：**双向绑定**。
- en: Two-way binding is a concept that is used if you have an input source (typically
    an `<input>` element) that sets some state upon user input (for instance, upon
    the `change` event) and outputs the input at the same time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 双向绑定是一个概念，如果你有一个输入源（通常是`<input>`元素），它在用户输入时（例如，在`change`事件上）设置一些状态，并同时输出输入。
- en: 'Here’s an example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Compared to the other code snippets and examples, the difference here is that
    the component does not just store the user input (upon the `change` event, in
    this case) but that the entered value is also output in the `<input>` element
    (via the default `value` prop) thereafter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他代码片段和示例相比，这里的区别在于组件不仅仅在`change`事件（在这种情况下）上存储用户输入，而且输入的值还会在之后的`<input>`元素中输出（通过默认的`value`属性）。
- en: This might look like an infinite loop, but React deals with this and ensures
    that it doesn’t become one. Instead, this is what’s commonly referred to as two-way
    binding as a value is both set and read from the same source.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一个无限循环，但React会处理这种情况，确保它不会变成一个无限循环。相反，这通常被称为双向绑定，因为值既从同一源设置又从同一源读取。
- en: You may wonder why this is being discussed here, but it is important to know
    that it is perfectly valid to write code like this. Also, this kind of code could
    be necessary if you don’t just want to set a value (in this case, the `email`
    value) upon user input in the `<input>` field but also from other sources. For
    example, you might have a button in the component that, when clicked, should clear
    the entered email address.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么这个问题在这里被讨论，但重要的是要知道，编写这样的代码是完全有效的。此外，如果你不仅想在 `<input>` 字段的用户输入时设置值（在这个例子中，是
    `email` 值），还希望从其他来源设置值，这种代码可能是必要的。例如，你可能有一个按钮在组件中，当点击时，应该清除输入的电子邮件地址。
- en: 'It might look like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能看起来像这样：
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this updated example, the `handleClearInput` function is executed when `<button>`
    is clicked. Inside the function, the `email` state is set back to an empty string.
    Without two-way binding, the state would be updated, but the change would not
    be reflected in the `<input>` element. There, the user would still see their last
    input. The state reflected on the UI (the website) and the state managed internally
    by React would be different—a bug you absolutely must avoid.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更新的示例中，当点击 `<button>` 时会执行 `handleClearInput` 函数。在函数内部，`email` 状态被设置回空字符串。如果没有双向绑定，状态会更新，但变化不会反映在
    `<input>` 元素上。在那里，用户仍然会看到他们最后的输入。UI（网站）上反映的状态和React内部管理的状态将不同——这是一个绝对必须避免的错误。
- en: Deriving Values from State
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从状态中推导值
- en: As you can probably tell by now, state is a key concept in React. State allows
    you to manage data that, when changed, forces React to re-evaluate a component
    and, ultimately, the UI.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如你至今可能已经注意到的，状态是React中的一个关键概念。状态允许你管理数据，当数据改变时，它会迫使React重新评估组件，并最终更新UI。
- en: 'As a developer, you can use state values anywhere in your component (and in
    your child components, by passing state to them via props). You could, for example,
    repeat what a user entered like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你可以在组件的任何地方（以及通过props将状态传递给子组件）使用状态值。例如，你可以像这样重复用户输入的内容：
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This component might not be too useful, but it will work, and it does use state.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件可能不是非常有用，但它会工作，并且它确实使用了状态。
- en: 'Often, in order to do more useful things, you will need to use a state value
    as a basis to derive a new (often more complex) value. For example, instead of
    simply repeating what the user entered, you could count the number of entered
    characters and show that information to the user:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了做更有用的事情，你需要使用状态值作为基础来推导一个新的（通常是更复杂的）值。例如，你不仅可以简单地重复用户输入的内容，还可以计算输入的字符数，并将该信息显示给用户：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note the addition of the new `numChars` constant (it could also be a variable,
    via `let` ). This constant is derived from the `userInput` state by accessing
    the `length` property on the string value that’s stored in the `userInput` state.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意新添加的 `numChars` 常量（它也可以通过 `let` 变量）。这个常量是通过访问存储在 `userInput` 状态中的字符串值的 `length`
    属性来从 `userInput` 状态推导出来的。
- en: This is important! You’re not limited to working with state values only. You
    can manage some key value as state (that is, the value that will change) and derive
    other values based on that state value—such as, in this case, the number of characters
    entered by the user. Indeed, this is something you will do frequently as a React
    developer.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要！你不仅限于只与状态值一起工作。你可以将某些关键值作为状态（即会改变的值）来管理，并基于该状态值推导其他值——例如，在这个例子中，用户输入的字符数。实际上，作为React开发者，你将经常这样做。
- en: You might also be wondering why `numChars` is a constant and outside of the
    `handleChange` function. After all, that is the function that is executed upon
    user input (that is, upon every keystroke the user makes).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还在想为什么 `numChars` 是一个常量，并且位于 `handleChange` 函数之外。毕竟，那是用户输入时（即用户每次按键时）执行的功能。
- en: Keep in mind what you learned about how React handles state internally. When
    you call the state-updating function ( `setUserInput` , in this case), React will
    re-evaluate the component to which the state belongs. This means that the `CharCounter`
    component function will be called again by React. All the code in that function
    is therefore executed again.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住你学到的关于React如何处理内部状态的知识。当你调用状态更新函数（在这个例子中是 `setUserInput`）时，React会重新评估属于该状态组件。这意味着React会再次调用
    `CharCounter` 组件函数。因此，该函数中的所有代码都会再次执行。
- en: '![A diagram of a component  Description automatically generated](img/B31339_04_03.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![组件图  描述自动生成](img/B31339_04_03.png)'
- en: 'Figure 4.3: The numChars value is derived from state when the component function
    executes again'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：当组件函数再次执行时，numChars值是从状态中派生出来的
- en: React does re-execute component functions to determine what the UI should look
    like after the state update; and, if it detects any differences compared to the
    currently rendered UI, React will go ahead and update the browser UI (that is,
    the DOM) accordingly. Otherwise, nothing will happen.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: React会重新执行组件函数以确定在状态更新后UI应该是什么样子；如果它检测到与当前渲染UI的差异，React将相应地更新浏览器UI（即DOM）。否则，不会发生任何事。
- en: Since React calls the component function again, `useState()` will yield its
    array of values (current state value and state-updating function). The current
    state value will be the state to which it was set when `setUserInput` was called.
    Therefore, this new `userInput` value can be used to perform other calculations
    anywhere in the component function—such as deriving `numChars` by accessing the
    `length` property of `userInput` (as shown in *Figure 4.3* ).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于React会再次调用组件函数，`useState()`将产生其值数组（当前状态值和状态更新函数）。当前状态值将是`setUserInput`被调用时设置的状态。因此，这个新的`userInput`值可以在组件函数的任何地方使用来执行其他计算——例如，通过访问`userInput`的`length`属性来推导`numChars`（如*图4.3*所示）。
- en: That’s why `numChars` can be a constant. For this component execution, it won’t
    be re-assigned. A new value might only be derived when the component function
    is executed again in the future (that is if `setUserInput` is called again). In
    that case, a brand-new `numChars` constant would be created (and the old one would
    be discarded).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`numChars`可以是一个常量。对于此组件执行，它不会被重新分配。只有在组件函数在未来再次执行时（即如果再次调用`setUserInput`），才可能派生新的值。在这种情况下，将创建一个新的`numChars`常量（而旧的将被丢弃）。
- en: Working with Forms and Form Submission
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与表单和表单提交一起工作
- en: State is commonly used when working with forms and user input. Indeed, most
    examples in this chapter dealt with some form of user input.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理表单和用户输入时，通常使用状态。实际上，本章中的大多数示例都涉及某种形式的用户输入。
- en: Up to this point, all examples focused on listening to user events that are
    directly attached to individual input elements. That makes sense because you will
    often want to listen to events such as keystrokes or an input losing focus. Especially
    when adding input validation (that is, checking entered values), you might want
    to use input events to give website users useful feedback while they’re typing.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有示例都集中在监听直接附加到单个输入元素的用户事件上。这很有意义，因为你会经常想要监听诸如按键或输入失去焦点等事件。特别是当添加输入验证（即检查输入值）时，你可能想使用输入事件在用户输入时提供有用的反馈。
- en: But it’s also quite common to react to the overall form submission. For example,
    the goal could be to combine the input from various input fields and send the
    data to some backend server. How could you achieve this? How can you listen and
    react to the submission of a form?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但对整体表单提交做出反应也是很常见的。例如，目标可能是将来自各个输入字段的输入组合起来，并将数据发送到某个后端服务器。你该如何实现这一点？你该如何监听并响应表单的提交？
- en: You can do all these things with the help of standard JavaScript events and
    the appropriate event handler props provided by React. Specifically, the `onSubmit`
    prop can be added to `<form>` elements to assign a function that should be executed
    once a form is submitted. To then handle the submission with React and JavaScript,
    you must ensure that the browser won’t do its default thing and generate (and
    send) an HTTP request automatically.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在标准JavaScript事件和React提供的适当事件处理属性的帮助下完成所有这些操作。具体来说，可以将`onSubmit`属性添加到`<form>`元素中，以分配一个在表单提交时应执行的功能。为了使用React和JavaScript处理提交，你必须确保浏览器不会执行其默认操作并自动生成（并发送）HTTP请求。
- en: As in vanilla JavaScript, this can be achieved by calling the `preventDefault()`
    method on the automatically generated event object.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与纯JavaScript一样，这可以通过在自动生成的事件对象上调用`preventDefault()`方法来实现。
- en: 'Here’s a full example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个完整的示例：
- en: '[PRE19]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code snippet handles form submission via the `handleSignup()` function
    that’s assigned to the built-in `onSubmit` prop. User input is still fetched with
    the help of two state slices ( `email` and `agreed` ), which are updated upon
    the inputs’ change events.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段通过将`handleSignup()`函数分配给内置的`onSubmit`属性来处理表单提交。用户输入仍然通过两个状态片段（`email`和`agreed`）获取，这些状态片段在输入更改事件发生时更新。
- en: '**Note**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'In the preceding code example, you might’ve noticed a new prop that wasn’t
    used before in this book: `htmlFor` . This is a special prop, built into React
    and the core JSX elements it provides. It can be added to `<label>` elements in
    order to set the `for` attribute for these elements. The reason it is called `htmlFor`
    instead of just `for` is that, as explained earlier in the book, JSX looks like
    HTML but isn’t HTML. It’s JavaScript under the hood. In JavaScript, `for` is a
    reserved keyword for `for` loops. To prevent problems, the prop is therefore named
    `htmlFor` .'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，你可能注意到了一个之前在这本书中没有使用过的新属性：`htmlFor`。这是一个特殊的属性，它是React及其提供的核心JSX元素内置的。它可以添加到`<label>`元素中，以便为这些元素设置`for`属性。之所以称为`htmlFor`而不是仅仅`for`，是因为，正如本书前面所解释的，JSX看起来像HTML，但实际上不是HTML。它是底层的JavaScript。在JavaScript中，`for`是一个用于`for`循环的保留关键字。为了避免问题，因此将属性命名为`htmlFor`。
- en: 'Using `onSubmit` (combined with `preventDefault()` ) for handling form submissions
    is a very common way of dealing with user input and forms in React. But when working
    on projects that use React 19 or higher, you can also use an alternative way for
    handling form submissions: you can use a React feature called **Form Actions**
    , which will be covered in great detail in *Chapter 9* , *Handling User Input
    & Forms with Form Actions* .'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`onSubmit`（结合`preventDefault()`）处理表单提交是处理React中用户输入和表单的一种非常常见的方式。但是，当你在使用React
    19或更高版本的项目上工作时，你也可以使用另一种处理表单提交的方法：你可以使用一个称为**表单操作**的React功能，这将在第9章*使用表单操作处理用户输入和表单*中详细讨论。
- en: Lifting State Up
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升状态
- en: 'Here’s a common scenario and problem: you have two components in your React
    app and a change or event in component A should change the state in component
    B. To make this less abstract, consider the following simple example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的场景和问题：在你的React应用程序中有两个组件，组件A中的更改或事件应该改变组件B中的状态。为了使这个问题更具体，考虑以下简单的例子：
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, the `Overview` component should output the entered search term.
    However, the search term is actually managed in another component—namely, the
    `SearchBar` component. In this simple example, the two components could of course
    be merged into one single component, and the problem would be solved. But it’s
    very likely that when building more realistic apps, you’ll face similar scenarios
    but with way more complex components. Breaking components up into smaller pieces
    is considered a good practice since it keeps the individual components manageable.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Overview`组件应该输出输入的搜索词。然而，搜索词实际上是在另一个组件中管理的——即`SearchBar`组件。在这个简单的例子中，当然可以将这两个组件合并成一个单独的组件，问题也就解决了。但在构建更现实的应用程序时，你可能会遇到类似的场景，但组件会更复杂。将组件拆分成更小的部分被认为是良好的实践，因为它保持了各个组件的可管理性。
- en: Having multiple components depend on some shared piece of state is therefore
    a scenario you will face frequently when working with React.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在处理React时，多个组件依赖于某些共享的状态是一个你将经常遇到的场景。
- en: This problem can be solved by *lifting state up* . When lifting state up, the
    state is not managed in either of the two components that use it—neither in `Overview`
    , which reads the state, nor in `SearchBar` , which sets the state—but in a shared
    ancestor component instead. To be precise, it is managed in the **closest** shared
    ancestor component. Keep in mind that components are nested into each other and
    thus a “tree of components” (with the `App` component as the root component) is
    built up in the end.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可以通过*提升状态*来解决。当提升状态时，状态不是在两个使用它的组件中管理——既不在读取状态的`Overview`组件中，也不在设置状态的`SearchBar`组件中——而是在一个共享的祖先组件中。更准确地说，它是在**最近的**共享祖先组件中管理的。记住，组件是嵌套的，因此最终会构建出一个“组件树”（其中`App`组件是根组件）。
- en: '![img](img/B31339_04_04.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_04_04.jpg)'
- en: 'Figure 4.4: An example component tree'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：一个示例组件树
- en: In the previous simple code example, the `App` component is the closest (and,
    in this case, only) ancestor component of both `SearchBar` and `Overview` . If
    the app was structured as shown in the figure, with state set in one of the `Product`
    components and used in `Cart` , `Products` would be the closest ancestor component.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的简单代码示例中，`App`组件是`SearchBar`和`Overview`两个组件最近的（在这个例子中，也是唯一的）祖先组件。如果应用程序的结构如图所示，状态设置在一个`Product`组件中并在`Cart`中使用，`Products`将是最近的祖先组件。
- en: 'State is lifted by using props in the components that need to manipulate (that
    is, set) or read state, and by registering state in the ancestor component that
    is shared by the two other components. Here’s the updated example from previously:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在需要操作（即设置）或读取状态的组件中使用属性，以及通过在两个其他组件共享的祖先组件中注册状态，来提升状态。以下是之前更新的示例：
- en: '[PRE21]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code didn’t actually change that much; it mostly moved around a bit. The
    state is now managed inside of the shared ancestor and `App` component, and the
    two other components get access to it via props.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 代码实际上并没有改变多少；它主要只是移动了一下位置。现在状态是在共享的祖先和`App`组件内部管理的，而其他两个组件通过属性访问它。
- en: 'Three key things are happening in this example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中有三个关键的事情发生：
- en: The `SearchBar` component receives a prop called `onUpdateSearch` , whose value
    is a function—a function created in the `App` component and passed down to `SearchBar`
    from `App` .
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SearchBar`组件接收一个名为`onUpdateSearch`的属性，其值是一个函数——这是一个在`App`组件中创建并从`App`传递到`SearchBar`的函数。'
- en: The `onUpdateSearch` prop is then set as a value to the `onChange` prop on the
    `<input>` element inside of the `SearchBar` component.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`onUpdateSearch`属性设置为`SearchBar`组件内部`<input>`元素的`onChange`属性的值。
- en: The `searchTerm` state (that is, its current value) is passed from `App` to
    `Overview` via a prop named `currentTerm` .
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`searchTerm`状态（即其当前值）通过名为`currentTerm`的属性从`App`传递到`Overview`。'
- en: The first two points could be confusing. But keep in mind that, in JavaScript,
    functions are first-class objects and regular values. You can store functions
    in variables and, when using React, pass functions as values for props. Indeed,
    you could already see that in action at the very beginning of this chapter. When
    introducing events and event handling, functions were provided as values to all
    these `onXYZ` props ( `onChange` , `onBlur` , and so on).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 前两点可能有些令人困惑。但请记住，在JavaScript中，函数是一等对象和常规值。你可以将函数存储在变量中，并在使用React时，将函数作为属性值传递。实际上，你已经在本章的开头看到了这一点。在介绍事件和事件处理时，函数被作为值传递给了所有这些`onXYZ`属性（`onChange`、`onBlur`等等）。
- en: In this code snippet, a function is passed as a value for a custom prop (that
    is, a prop expected in a component created by you, not built into React). The
    `onUpdateSearch` prop expects a function as a value because the prop is then itself
    being used as a value for the `onChange` prop on the `<input>` element.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，一个函数被作为自定义属性（即，你创建的组件中期望的属性，而不是React内置的属性）的值传递。`onUpdateSearch`属性期望一个函数作为值，因为该属性本身被用作`<input>`元素上的`onChange`属性的值。
- en: The prop is named `onUpdateSearch` to make it clear that it expects a function
    as a value and that it will be connected to an event. Any name could’ve been chosen
    though; it doesn’t have to start with `on` . But it’s a common convention to name
    props that expect functions as values and that are intended to be connected to
    events like this.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性被命名为`onUpdateSearch`，以使其明确期望一个函数作为值，并且它将被连接到事件。当然，可以选择任何名称；它不必以`on`开头。但这是一个常见的约定，为期望函数作为值并且打算连接到类似事件的属性命名。
- en: Of course, `updateSearch` is not a default event, but since the function will
    effectively be called upon the `change` event of the `<input>` element, the prop
    acts like a custom event.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`updateSearch`不是一个默认事件，但由于该函数将在`<input>`元素的`change`事件上被调用，因此该属性的行为就像一个自定义事件。
- en: With this structure, the state was lifted up to the `App` component. This component
    registers and manages the state. However, it also exposes the state-updating function
    (indirectly, in this case, as it is wrapped by the `handleUpdateSearchTerm` function)
    to the `SearchBar` component. It also provides the current state value ( `searchTerm`
    ) to the `Overview` component via the `currentTerm` prop.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种结构，状态被提升到了`App`组件。该组件注册并管理状态。然而，它还通过`handleUpdateSearchTerm`函数（在这种情况下，间接地）将状态更新函数暴露给`SearchBar`组件。它还通过`currentTerm`属性将当前状态值（`searchTerm`）传递给`Overview`组件。
- en: Since the child and descendent components are also re-evaluated by React when
    state changes in a component, changes in the `App` component will also lead to
    the `SearchBar` and `Overview` components being re-evaluated. Therefore, the new
    prop value for `searchTerm` will be picked up, and the UI will be updated by React.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于子组件和后代组件在组件状态变化时也会被React重新评估，因此`App`组件的变化也会导致`SearchBar`和`Overview`组件被重新评估。因此，`searchTerm`的新属性值将被获取，React将通过UI更新。
- en: No new React features are needed for this. It’s only a combination of state
    and props. However, depending on how these features are connected and where they
    are used, both simple and more complex app patterns can be achieved.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此操作不需要新的React功能。这只是一个状态和props的组合。然而，根据这些功能如何连接以及它们在哪里使用，可以实现简单和更复杂的app模式。
- en: Summary and Key Takeaways
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概括和要点
- en: Event handlers can be added to JSX elements via `on[EventName]` props (for example,
    `onClick` , `onChange` ).
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过`on[EventName]`属性（例如，`onClick`，`onChange`）将事件处理器添加到JSX元素中。
- en: Any function can be executed upon (user) events.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何函数都可以在（用户）事件上执行。
- en: In order to force React to re-evaluate components and (possibly) update the
    rendered UI, state must be used.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了强制React重新评估组件和（可能）更新渲染的UI，必须使用状态。
- en: State refers to data managed internally by React, and a state value can be defined
    via the `useState()` Hook.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态是指React内部管理的数据，可以通过`useState()` Hook定义状态值。
- en: React Hooks are JavaScript functions that add special features to React components
    (for example, the state feature, in this chapter).
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Hooks是JavaScript函数，它们为React组件添加特殊功能（例如，本章中的状态功能）。
- en: '`useState()` always returns an array with exactly two elements:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState()`总是返回一个包含恰好两个元素的数组：'
- en: The **first element** is the current state value.
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一个元素**是当前状态值。'
- en: The **second element** is a function to set the state to a new value (the *state-updating
    function* ).
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二个元素**是一个将状态设置为新的值（即*状态更新函数*）的函数。'
- en: When setting the state to a new value that depends on the previous value, a
    function should be passed to the state-updating function. This function then receives
    the previous state as a parameter (which will be provided automatically by React)
    and returns the new state that should be set.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设置状态为新值，该值依赖于前一个值时，应将一个函数传递给状态更新函数。然后，该函数接收前一个状态作为参数（将由React自动提供）并返回应设置的新状态。
- en: Any valid JavaScript value can be set as state—besides primitive values such
    as strings or numbers. This also includes reference values such as objects and
    arrays.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何有效的JavaScript值都可以设置为状态——除了字符串或数字等原始值。这还包括对象和数组等引用值。
- en: If state needs to change because of some event that occurs in another component,
    you should *lift the state up* and manage it on a higher, shared level (that is,
    a common ancestor component).
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态需要因为另一个组件中发生的事件而改变，你应该*提升状态*并在更高、共享的级别（即公共祖先组件）上管理它。
- en: What’s Next?
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: State is an extremely important building block because it enables you to build
    truly dynamic applications. With this key concept out of the way, the next chapter
    will dive into utilizing state (and other concepts learned thus far) to render
    content conditionally and to render lists of content.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是一个极其重要的构建块，因为它使你能够构建真正动态的应用程序。在这个关键概念解决之后，下一章将深入探讨利用状态（以及迄今为止学到的其他概念）来条件性地渲染内容和渲染内容列表。
- en: These are common tasks that are required in almost any UI or web app you’re
    building, no matter whether it’s about showing a warning overlay or displaying
    a list of products. The next chapter will help you add such features to your React
    apps.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在几乎任何你正在构建的UI或Web应用中都需要执行的任务，无论它是关于显示警告覆盖层还是显示产品列表。下一章将帮助你向你的React应用添加这些功能。
- en: Test Your Knowledge!
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你的知识！
- en: Test your knowledge about the concepts covered in this chapter by answering
    the following questions. You can then compare your answers to examples that can
    be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/04-state-events/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/04-state-events/exercises/questions-answers.md)
    .
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你对本章涵盖的概念的了解。然后你可以将你的答案与可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/04-state-events/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/04-state-events/exercises/questions-answers.md)找到的示例进行比较。
- en: Which “problem” does state solve?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态解决了哪个“问题”？
- en: What’s the difference between props and state?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: props和状态之间的区别是什么？
- en: How is state registered in a component?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态是如何在组件中注册的？
- en: Which values does the `useState()` Hook provide?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useState()` Hook提供了哪些值？'
- en: How many state values can be registered for a single component?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单个组件可以注册多少个状态值？
- en: Does state affect other components (than the component in which it was registered)
    as well?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态是否也会影响其他组件（而不仅仅是注册状态的组件）？
- en: How should state be updated if the new state depends on the previous state?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果新状态依赖于前一个状态，应该如何更新状态？
- en: How can state be shared across multiple components?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 怎样才能在多个组件之间共享状态？
- en: Apply What You Learned
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用所学知识
- en: With the new knowledge gained in this chapter, you are finally able to build
    truly dynamic UIs and React applications. Instead of being limited to hardcoded,
    static content and pages, you can now use state to set and update values and force
    React to re-evaluate components and the UI.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中获得的新知识使你最终能够构建真正动态的UI和React应用程序。现在，你不再局限于硬编码的静态内容和页面，可以使用状态来设置和更新值，并强制React重新评估组件和UI。
- en: Here, you will find an activity that allows you to apply all the knowledge,
    including this new state knowledge, you have acquired up to this point.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以找到一个活动，让你应用到目前为止所获得的所有知识，包括新的状态知识。
- en: 'Activity 4.1: Building a Simple Calculator'
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动四.1：构建简单计算器
- en: In this activity, you’ll build a very basic calculator that allows users to
    add, subtract, multiply, and divide two numbers with each other.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将构建一个非常基本的计算器，允许用户将两个数字相加、相减、相乘和相除。
- en: 'The steps are as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: Build the UI by using React components. Be sure to build four separate components
    for the four math operations, even though lots of code could be reused.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用React组件构建UI。确保为四个数学运算构建四个单独的组件，即使有很多代码可以复用。
- en: Collect the user input and update the result whenever the user enters a value
    into one of the two related input fields.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在两个相关输入字段之一中输入值时，收集用户输入并更新结果。
- en: Note that when working with numbers and getting those numbers from user input,
    you will need to ensure that the entered values are treated as numbers and not
    as strings.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当与数字打交道并从用户输入中获取这些数字时，你需要确保输入的值被当作数字处理，而不是字符串。
- en: 'The final result and UI of the calculator should look like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 计算器的最终结果和UI应该看起来像这样：
- en: '![img](img/B31339_04_05.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_04_05.png)'
- en: 'Figure 4.5: Calculator UI'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：计算器UI
- en: '**Note**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'Styling will, of course, differ. To get the same styling as shown in the screenshot,
    use my prepared starting project, which you can find here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-1-start)
    .'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 样式当然会有所不同。要获得截图中所显示的相同样式，请使用我准备的起始项目，你可以在这里找到：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-1-start)。
- en: Analyze the `index.css` file in that project to determine how to structure your
    JSX code to apply the styles.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 分析那个项目中的`index.css`文件，以确定如何结构化你的JSX代码来应用样式。
- en: '**Note**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You’ll find the full example solution here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-1)
    .'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到完整的示例解决方案：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-1)。
- en: 'Activity 4.2: Enhancing the Calculator'
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动四.2：增强计算器
- en: In this activity, you’ll build upon *Activity 4.1* to make the calculator built
    there slightly more complex. The goal is to reduce the number of components and
    build one single component in which users can select the mathematical operation
    via a drop-down element. In addition, the result should be output in a different
    component—that is, not in the component where the user input is gathered.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将基于*活动4.1*来构建一个稍微复杂一点的计算器。目标是减少组件数量，并构建一个单组件，用户可以通过下拉元素选择数学运算。此外，结果应该输出到不同的组件中——也就是说，不是在收集用户输入的组件中。
- en: 'The steps are as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: Remove three of the four components from the previous activity and use one single
    component for all mathematical operations.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个活动中移除四个组件中的三个，并使用一个单组件来处理所有数学运算。
- en: Add a drop-down element ( `<select>` element) to that remaining component (between
    the two inputs) and add the four math operations as options ( `<option>` elements)
    to it.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在剩余的组件（两个输入之间）添加一个下拉元素（`<select>`元素），并将四个数学运算作为选项（`<option>`元素）添加到其中。
- en: Use state to gather both the numbers entered by the user and the math operation
    chosen via the drop-down (it’s up to you whether you prefer one single state object
    or multiple state slices).
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用状态来收集用户输入的数字和通过下拉菜单选择的数学运算（是否喜欢一个单一的状态对象或多个状态片段由你决定）。
- en: 'Output the result in another component. (Hint: choose a good place for registering
    and managing the state.)'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个组件中输出结果。（提示：选择一个合适的地方来注册和管理状态。）
- en: 'The result and UI of the calculator should look like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 计算器的结果和UI应该看起来像这样：
- en: '![img](img/B31339_04_06.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_04_06.png)'
- en: 'Figure 4.6: UI of the enhanced calculator'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：增强计算器的UI
- en: '**Note**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You’ll find the full example solution here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-2)
    .'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到完整的示例解决方案：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-2)
    .
