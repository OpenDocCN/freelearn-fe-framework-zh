- en: '*Chapter 1*: Winning Components Communication'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*：获胜的组件通信'
- en: In this chapter, you'll master component communication in Angular. You'll learn
    different techniques to establish communication between components and will learn
    which technique is suitable in which situation. You'll also learn how to create
    a dynamic Angular component in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将掌握Angular中的组件通信。您将学习建立组件之间通信的不同技术，并了解哪种技术适用于哪种情况。您还将学习如何在本章中创建一个动态的Angular组件。
- en: 'The following are the recipes we''re going to cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将要涵盖的配方：
- en: Components communication using component `@Input(s)` and `@Output(s)`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组件`@Input(s)`和`@Output(s)`进行组件通信
- en: Components communication using services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务进行组件通信
- en: Using setters for intercepting input property changes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用setter拦截输入属性的更改
- en: Using `ngOnChanges` to intercept input property changes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ngOnChanges`拦截输入属性的更改
- en: Accessing a child component in a parent template via template variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模板变量在父模板中访问子组件
- en: Accessing a child component in a parent component class using `ViewChild`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`ViewChild`在父组件类中访问子组件
- en: Creating your first dynamic component in Angular
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular中创建你的第一个动态组件
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the recipes in this chapter, make sure you have **Git** and **Node.js**
    installed on your machine. You also need to have the `@angular/cli` package installed,
    which you can do with `npm install -g @angular/cli` from your terminal. The code
    for this chapter can be found at [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter01](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter01).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的配方中，请确保您的计算机上安装了**Git**和**Node.js**。您还需要安装`@angular/cli`包，可以在终端中使用`npm install
    -g @angular/cli`来安装。本章的代码可以在[https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter01](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter01)找到。
- en: Components communication using component @Input(s) and @Output(s)
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件@Input(s)和@Output(s)进行组件通信
- en: You'll start with an app with a parent component and two child components. You'll
    then use Angular `@Input` and `@Ouput` decorators to establish communication between
    them using attributes and `EventEmitter`(s).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您将从一个具有父组件和两个子组件的应用程序开始。然后，您将使用Angular的`@Input`和`@Ouput`装饰器，使用属性和`EventEmitter`(s)在它们之间建立通信。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter01/start_here/cc-inputs-outputs`
    inside the cloned repository:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的项目位于克隆存储库中的`chapter01/start_here/cc-inputs-outputs`中：
- en: Open the project in Visual Studio Code.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
    Once done, run `ng serve -o`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，你应该看到以下内容：
- en: '![Figure 1.1 – The cc-inputs-outputs app running on http://localhost:4200'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1 - 运行在http://localhost:4200上的cc-inputs-outputs应用程序'
- en: '](image/Figure_1.01_B15150.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.01_B15150.jpg)'
- en: Figure 1.1 – The cc-inputs-outputs app running on http://localhost:4200
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 - 运行在http://localhost:4200上的cc-inputs-outputs应用程序
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'So far, we have an app with `AppComponent`, `NotificationsButtonComponent`,
    and `NotificationsManagerComponent`. While `AppComponent` is the parent of the
    other two components mentioned, there is absolutely no component communication
    between them to sync the notification count value. Let''s establish the appropriate
    communication between them using the following steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个带有`AppComponent`、`NotificationsButtonComponent`和`NotificationsManagerComponent`的应用程序。虽然`AppComponent`是其他两个组件的父组件，但它们之间绝对没有组件通信来同步通知计数值。让我们使用以下步骤建立它们之间的适当通信：
- en: 'We''ll move the `notificationsCount` variable from `NotificationsManagerComponent`
    and host it in `AppComponent`. To do so, just create a `notificationsCount` property
    in `app.component.ts`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从`NotificationsManagerComponent`中移除`notificationsCount`变量，并将其放在`AppComponent`中。为此，只需在`app.component.ts`中创建一个`notificationsCount`属性即可：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, convert the `notificationsCount` property in `notifications-manager.component.ts`
    to `@Input()`, rename it to `count`, and replace its usages as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`notifications-manager.component.ts`中的`notificationsCount`属性转换为`@Input()`，并将其重命名为`count`，并替换其用法如下：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Update `notifications-manager.component.html` to use `count` instead of `notificationsCount`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`notifications-manager.component.html`以使用`count`而不是`notificationsCount`：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, pass the `notificationsCount` property from `app.component.html` to the
    `<app-notifications-manager>` element as an input:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`app.component.html`中的`notificationsCount`属性作为输入传递给`<app-notifications-manager>`元素：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You could now test whether the value is being correctly passed from `app.component.html`
    to `app-notifications-manager` by assigning the value of `notificationsCount`
    in `app.component.ts` as `10`. You''ll see that in `NotificationsManagerComponent`,
    the initial value shown will be `10`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过将`app.component.ts`中的`notificationsCount`的值分配为`10`来测试是否正确地从`app.component.html`传递到`app-notifications-manager`。您将看到，在`NotificationsManagerComponent`中，显示的初始值将为`10`：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, create an `@Input()` in `notifications-button.component.`ts named `count`
    as well:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`notifications-button.component.ts`中创建一个`@Input()`，命名为`count`：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Pass `notificationsCount` to `<app-notifications-button>` as well from `app.component.html`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时也将`notificationsCount`传递给`<app-notifications-button>`，并在`app.component.html`中进行相应设置：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use the `count` input in `notifications-button.component.html` with the notification
    bell icon:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`notifications-button.component.html`中使用`count`输入与通知图标：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should now see the value `10` for the notification bell icon count as well.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您还应该看到通知图标计数为`10`的值。
- en: '*Right now, if you change the count by adding/removing notifications from*
    `NotificationsManagerComponent`, *the count on the notification bell icon won''t
    change.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在，如果您通过从`NotificationsManagerComponent`中添加/删除通知来更改计数，通知图标上的计数将不会改变。*'
- en: 'To communicate the change from `NotificationsManagerComponent` to `NotificationsButtonComponent`,
    we''ll use Angular `@Output`(s) now. Use `@Ouput` and `@EventEmitter` from `''@angular/core''`
    inside `notifications-manager.component.ts`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将来自`NotificationsManagerComponent`到`NotificationsButtonComponent`的更改进行通信，我们现在将使用Angular的`@Output`。在`notifications-manager.component.ts`中使用`@Output`和`@EventEmitter`来自`'@angular/core'`：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we''ll listen in `app.component.html` for the previously emitted event
    from `NotificationsManagerComponent` and update the `notificationsCount` property
    accordingly:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在`app.component.html`中监听来自`NotificationsManagerComponent`的先前发出的事件，并相应地更新`notificationsCount`属性：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since we''ve listened to the `countChanged` event previously and called the
    `updateNotificationsCount` method, we need to create this method in `app.component.ts`
    and update the value of the `notificationsCount` property accordingly:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们先前已经监听了`countChanged`事件并调用了`updateNotificationsCount`方法，我们需要在`app.component.ts`中创建这个方法，并相应地更新`notificationsCount`属性的值：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In order to communicate between components using `@Input`(s) and `@Output`(s),
    the data flow will always go **from** the *child components* **to** the *parent
    component*, which can provide the new (updated) value *as input* back to the required
    child components. So, `NotificationsManagerComponent` emits the `countChanged`
    event. `AppComponent` (being the parent component) listens for the event and updates
    the value of `notificationsCount`, which automatically updates the `count` property
    in `NotificationsButtonComponent` because `notificationsCount` is being passed
    as the `@Input()` count to `NotificationsButtonComponent`. *Figure 1.2* shows
    the entire process:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`@Input`和`@Output`在组件之间进行通信，数据流将始终从*子组件* **到** *父组件*，父组件可以将新的（更新的）值*作为输入*提供给所需的子组件。因此，`NotificationsManagerComponent`发出`countChanged`事件。`AppComponent`（作为父组件）监听该事件并更新`notificationsCount`的值，这将自动更新`NotificationsButtonComponent`中的`count`属性，因为`notificationsCount`被传递为`@Input()`
    count到`NotificationsButtonComponent`。*图1.2*显示了整个过程：
- en: '![Figure 1.2 – How component communication works with inputs and outputs'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 - 使用输入和输出进行组件通信的工作原理'
- en: '](image/Figure_1.02_B15150.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.02_B15150.jpg)'
- en: Figure 1.2 – How component communication works with inputs and outputs
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 - 使用输入和输出进行组件通信的工作原理
- en: See also
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: How do Angular components communicate? [https://www.thirdrocktechkno.com/blog/how-angular-components-communicate](https://www.thirdrocktechkno.com/blog/how-angular-components-communicate)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular组件如何通信？[https://www.thirdrocktechkno.com/blog/how-angular-components-communicate](https://www.thirdrocktechkno.com/blog/how-angular-components-communicate)
- en: '*Component Communication in Angular* by Dhananjay Kumar: [https://www.youtube.com/watch?v=I8Z8g9APaDY](https://www.youtube.com/watch?v=I8Z8g9APaDY)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Dhananjay Kumar的Angular组件通信*：[https://www.youtube.com/watch?v=I8Z8g9APaDY](https://www.youtube.com/watch?v=I8Z8g9APaDY)'
- en: Components communication using services
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务进行组件通信
- en: In this recipe, you'll start with an app with a parent component and a child
    component. You'll then use an Angular service to establish communication between
    them. We're going to use `BehaviorSubject` and Observable streams to communicate
    between components and the service.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将从一个具有父组件和子组件的应用程序开始。然后，您将使用Angular服务来建立它们之间的通信。我们将使用`BehaviorSubject`和Observable流来在组件和服务之间进行通信。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The project for this recipe resides in `chapter01/start_here/cc-services`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的配方项目位于`chapter01/start_here/cc-services`中：
- en: Open the project in Visual Studio Code.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see the app as
    follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新的浏览器标签中打开应用程序，您应该看到应用程序如下所示：
- en: '![Figure 1.3 – The cc-services app running on http://localhost:4200'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3 - cc-services应用程序运行在http://localhost:4200'
- en: '](image/Figure_1.03_B15150.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.03_B15150.jpg)'
- en: Figure 1.3 – The cc-services app running on http://localhost:4200
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 - cc-services应用程序运行在http://localhost:4200
- en: How to do it…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Similar to the previous recipe, we have an app with `AppComponent`, `NotificationsButtonComponent`,
    and `NotificationsManagerComponent`. `AppComponent` is the parent of the other
    two components mentioned previously, and we need to establish the appropriate
    communication between them using the following steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的配方类似，我们有一个带有`AppComponent`、`NotificationsButtonComponent`和`NotificationsManagerComponent`的应用程序。`AppComponent`是前面提到的另外两个组件的父组件，我们需要使用以下步骤在它们之间建立适当的通信：
- en: Create a new folder inside the `chapter01/start_here/cc-services/src/app` project
    named `services`. This is where our new service will reside.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chapter01/start_here/cc-services/src/app`项目中创建一个名为`services`的新文件夹。这将是我们新服务的所在地。
- en: 'From the terminal, navigate into the project, that is, inside `chapter01/start_here/cc-services`,
    and create a new service called `NotificationService`, as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端中，导航到项目中，即`chapter01/start_here/cc-services`内，并创建一个名为`NotificationService`的新服务，如下所示：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a `BehaviorSubject` named `count` inside `notifications.service.ts`
    and initialize it with `0`, as a `BehaviorSubject` requires an initial value:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`notifications.service.ts`中创建一个名为`count`的`BehaviorSubject`，并将其初始化为`0`，因为`BehaviorSubject`需要一个初始值：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that the `BehaviorSubject` is a `private` property and we'll only update
    it from within the service using a `public` method later on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`BehaviorSubject`是一个`private`属性，我们稍后将仅从服务内部使用`public`方法来更新它。
- en: 'Now, create an `Observable` named `count$` using the `.asObservable()` method
    on the `count` `BehaviorSubject`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`count`的`BehaviorSubject`上的`.asObservable()`方法创建一个名为`count$`的`Observable`：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Convert the `notificationsCount` property in `notifications-manager.component.ts`
    to an Observable named `notificationsCount$`. Inject `NotificationsService` in
    the component and assign the service''s `count$` Observable to the component''s
    `notificationsCount$` variable:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`notifications-manager.component.ts`中的`notificationsCount`属性转换为名为`notificationsCount$`的Observable。在组件中注入`NotificationsService`并将服务的`count$`
    Observable分配给组件的`notificationsCount$`变量：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Comment out the code that updates the notification count for now; we''ll come
    back to it later:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂时注释掉更新通知计数的代码；我们稍后会回来处理它：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use the `notificationsCount$` Observable in `notifications-manager.component.html`
    with the `async` pipe to show its value:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`notifications-manager.component.html`中使用`notificationsCount$` Observable和`async`管道来显示其值：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, similarly inject `NotificationsService` in `notifications-button.component.ts`,
    create an Observable named `notificationsCount$` inside `NotificationsButtonComponent`,
    and assign the service''s `count$` Observable to it:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，类似地在`notifications-button.component.ts`中注入`NotificationsService`，在`NotificationsButtonComponent`中创建一个名为`notificationsCount$`的Observable，并将服务的`count$`
    Observable分配给它：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Use the `notificationsCount$` Observable in `notifications-button.component.html`
    with the `async` pipe:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`notifications-button.component.html`中使用`notificationsCount$` Observable和`async`管道：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you refresh the app now, you should be able to see the value `0` for both
    the notifications manager component and the notifications button component.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在刷新应用程序，您应该能够看到通知管理器组件和通知按钮组件的值都为`0`。
- en: 'Change the initial value for the `count` `BehaviorSubject` to `10` and see
    whether that reflects in both components:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`count`的`BehaviorSubject`的初始值更改为`10`，并查看是否在两个组件中都反映出来：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, create a method named `setCount` in `notifications.service.ts` so we are
    able to update the value of the `count` `BehaviorSubject`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`notifications.service.ts`中创建一个名为`setCount`的方法，这样我们就能够更新`count`的`BehaviorSubject`的值：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that we have the `setCount` method in place, let''s use it inside `notifications-manager.component.ts`
    to update its value based on the button clicks. In order to do so, we need to
    get the latest value of the `notificationsCount$` Observable and then perform
    some action. We''ll first create a `getCountValue` method inside `NotificationsManagerComponent`
    as follows, and will use `subscribe` with the `first` operator on the `notificationsCount$`
    Observable to get its latest value:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了`setCount`方法，让我们在`notifications-manager.component.ts`中使用它来根据按钮点击更新其值。为了这样做，我们需要获取`notificationsCount$`
    Observable的最新值，然后执行一些操作。我们首先在`NotificationsManagerComponent`中创建一个`getCountValue`方法，如下所示，并在`notificationsCount$`
    Observable上使用`subscribe`和`first`操作符来获取其最新值：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we''ll use the `getCountValue` method within our `addNotification`, `removeNotification`,
    and `resetCount` methods. We''ll have to pass the callback function from these
    methods to the `getCountValue` method. Let''s start with the `addNotification`
    method first:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在我们的`addNotification`、`removeNotification`和`resetCount`方法中使用`getCountValue`方法。我们将不得不从这些方法中将回调函数传递给`getCountValue`方法。让我们先从`addNotification`方法开始：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With the preceding code, you should already see both components reflecting the
    updated values correctly whenever we click the **Add Notification** button.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述代码，每当我们点击**添加通知**按钮时，您应该已经看到两个组件正确地反映了更新的值。
- en: 'Let''s implement the same logic for `removeNotification` and `resetCount` now:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们实现`removeNotification`和`resetCount`的相同逻辑：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: '`BehaviorSubject` is a special type of `Observable` that requires an initial
    value and can be used by many subscribers. In this recipe, we create a `BehaviorSubject`
    and then create an `Observable` using the `.asObservable()` method on `BehaviorSubject`.
    Although we could''ve just used `BehaviorSubject`, using the `.asObservable()`
    approach is recommended by the community.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`BehaviorSubject`是一种特殊类型的`Observable`，它需要一个初始值，并且可以被多个订阅者使用。在这个食谱中，我们创建了一个`BehaviorSubject`，然后使用`BehaviorSubject`上的`.asObservable()`方法创建了一个`Observable`。虽然我们本来可以直接使用`BehaviorSubject`，但是社区推荐使用`.asObservable()`方法。'
- en: Once we have created the Observable named `count$` in `NotificationsService`,
    we inject `NotificationsService` in our components and assign the `count$` Observable
    to a local property of the components. Then, we subscribe to this local property
    (which is an Observable) directly in `NotificationsButtonComponent`'s template
    (`html`) and in `NotificationsManagerComponent`'s template using the `async` pipes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`NotificationsService`中创建了名为`count$`的Observable，我们就在我们的组件中注入`NotificationsService`，并将`count$`
    Observable分配给组件的一个本地属性。然后，我们直接在`NotificationsButtonComponent`的模板（`html`）和`NotificationsManagerComponent`的模板中使用`async`管道订阅这个本地属性（它是一个Observable）。
- en: Then, whenever we need to update the value of the `count$` Observable, we use
    the `setCount` method of `NotificationsService` to update the actual `BehaviorSubject`'s
    value by using the `.next()` method on it. This automatically emits this new value
    via the `count$` Observable and updates the view with the new value in both of
    the components.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每当我们需要更新`count$` Observable的值时，我们使用`NotificationsService`的`setCount`方法来使用`BehaviorSubject`的`.next()`方法更新实际的值。这将通过`count$`
    Observable自动发出新值，并在两个组件中更新视图的新值。
- en: See also
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Subjects from RxJS''s official documentation: [https://www.learnrxjs.io/learn-rxjs/subjects](https://www.learnrxjs.io/learn-rxjs/subjects)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS官方文档中的Subjects：[https://www.learnrxjs.io/learn-rxjs/subjects](https://www.learnrxjs.io/learn-rxjs/subjects)
- en: '`BehaviorSubject` versus `Observable` on Stack Overflow: [https://stackoverflow.com/a/40231605](https://stackoverflow.com/a/40231605)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BehaviorSubject`与`Observable`在Stack Overflow上的比较：[https://stackoverflow.com/a/40231605](https://stackoverflow.com/a/40231605)'
- en: Using setters for intercepting input property changes
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用setter拦截输入属性更改
- en: In this recipe, you will learn about how to intercept changes in an `@Input`
    passed from a parent component and to perform some action on this event. We'll
    intercept the `vName` input passed from the `VersionControlComponent` parent component
    to the `VcLogsComponent` child component. We'll use setters to generate a log
    whenever the value of `vName` changes and will show those logs in the child component.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将学习如何拦截从父组件传递的`@Input`的更改，并对此事件执行一些操作。我们将拦截从`VersionControlComponent`父组件传递给`VcLogsComponent`子组件的`vName`输入。我们将使用setter在`vName`的值更改时生成日志，并在子组件中显示这些日志。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter01.start_here/cc-setters`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的项目位于`chapter01.start_here/cc-setters`中：
- en: Open the project in Visual Studio Code.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`以安装项目的依赖项。
- en: 'Once done, run `ng serve -o`. This should open the app in a new browser tab
    and you should see the app as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。这应该会在新的浏览器选项卡中打开应用程序，您应该看到应用程序如下所示：
- en: '![Figure 1.4 – The cc-setters app running on http://localhost:4200'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4 – cc-setters应用程序在http://localhost:4200上运行'
- en: '](image/Figure_1.04_B15150.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.04_B15150.jpg)'
- en: Figure 1.4 – The cc-setters app running on http://localhost:4200
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – cc-setters应用程序在http://localhost:4200上运行
- en: How to do it…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We''ll first create a logs array in `VcLogsComponent` as follows to store all
    the logs that we''ll display later using our template:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在`VcLogsComponent`中创建一个日志数组，以存储稍后我们将使用模板显示的所有日志：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s create the HTML for where we''ll show the logs. Let''s add the logs
    container and log items using following code to `vc-logs.component.html`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建HTML来显示日志的位置。使用以下代码将日志容器和日志项添加到`vc-logs.component.html`中：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we''ll add a bit of styling for the logs container and log items to be
    shown. After the changes, the view should look as shown in *Figure 1.5*. Update
    the `vc-logs.component.scss` file as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将为要显示的日志容器和日志项添加一些样式。更改后，视图应如*图1.5*所示。更新`vc-logs.component.scss`文件如下：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following screenshot shows the app with logs container styles:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了具有日志容器样式的应用程序：
- en: '![Figure 1.5 – The cc-setters app with logs container styles'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5 – 具有日志容器样式的cc-setters应用程序'
- en: '](image/Figure_1.05_B15150.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.05_B15150.jpg)'
- en: Figure 1.5 – The cc-setters app with logs container styles
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 具有日志容器样式的cc-setters应用程序
- en: 'Now, we''ll convert `@Input()` in `vc-logs.component.ts` to use a getter and
    setter so we can intercept the input changes. For that, we''ll also create an
    internal property named `_vName`. The code should look as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将把`vc-logs.component.ts`中的`@Input()`转换为使用getter和setter，以便我们可以拦截输入更改。为此，我们还将创建一个名为`_vName`的内部属性。代码应如下所示：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With the changes in *step 4*, the app works exactly like before, that is, perfectly.
    Now, let''s modify the setter to create those logs. For the initial value, we''ll
    have a log saying `''initial version is x.x.x''`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过*步骤4*中的更改，应用程序的工作方式与以前完全相同，即完美。现在，让我们修改setter以创建这些日志。对于初始值，我们将有一个日志，说'初始版本是x.x.x'：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, as the last step, for every time we change the version name, we need to
    show a different message saying `''version changed to x.x.x''`. *Figure 1.6* shows
    the final output. For the required changes, we''ll write some further code in
    the `vName` setter as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，作为最后一步，每当我们更改版本名称时，我们需要显示一个不同的消息，说'版本更改为x.x.x'。*图1.6*显示了最终输出。对于所需的更改，我们将在`vName`
    setter中编写一些进一步的代码如下：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following screenshot shows the final output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了最终输出：
- en: '![Figure 1.6 – Final output using the setter'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6 – 使用setter的最终输出'
- en: '](image/Figure_1.06_B15150.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.06_B15150.jpg)'
- en: Figure 1.6 – Final output using the setter
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 使用setter的最终输出
- en: How it works…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Getters and setters are components of a built-in feature of JavaScript. Many
    developers have used them in their projects while using vanilla JavaScript, or
    even TypeScript. Fortunately, Angular's `@Input()`can also use getters and setters
    since they're basically a property of the provided class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Getter和setter是JavaScript的内置功能的组成部分。许多开发人员在使用原始JavaScript或TypeScript时在其项目中使用它们。幸运的是，Angular的`@Input()`也可以使用getter和setter，因为它们基本上是提供的类的属性。
- en: For this recipe, we use a getter and, more specifically, a setter for our input
    so whenever the input changes, we use the setter method to do additional tasks.
    Moreover, we use the setter of the same input in our HTML so we directly show
    the value in the view when updated.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们使用一个getter，更具体地说，是一个setter来处理我们的输入，所以每当输入发生变化时，我们使用setter方法来执行额外的任务。此外，我们在HTML中使用相同输入的setter，所以当更新时，我们直接在视图中显示值。
- en: It is always a good idea to use a private variable/property with getters and
    setters to have a separation of concerns on what the component receives as input
    and what it stores in itself separately.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用私有变量/属性与getter和setter是一个好主意，以便在组件接收输入和在组件本身中存储输入方面有一个关注点的分离。
- en: See also
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[https://angular.io/guide/component-interaction#intercept-input-property-changes-with-a-setter](https://angular.io/guide/component-interaction#intercept-input-property-changes-with-a-setter)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://angular.io/guide/component-interaction#intercept-input-property-changes-with-a-setter](https://angular.io/guide/component-interaction#intercept-input-property-changes-with-a-setter)'
- en: '[https://www.jackfranklin.co.uk/blog/es5-getters-setters](https://www.jackfranklin.co.uk/blog/es5-getters-setters)
    by Jack Franklin'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.jackfranklin.co.uk/blog/es5-getters-setters](https://www.jackfranklin.co.uk/blog/es5-getters-setters)
    by Jack Franklin'
- en: Using ngOnChanges to intercept input property changes
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ngOnChanges`来拦截输入属性的更改
- en: In this recipe, you'll learn how to use `ngOnChanges` to intercept changes using
    the `SimpleChanges` API. We'll listen to a `vName` input passed from the `VersionControlComponent`
    parent component to the `VcLogsComponent` child component.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用`ngOnChanges`来拦截使用`SimpleChanges` API的更改。我们将监听从`VersionControlComponent`父组件传递给`VcLogsComponent`子组件的`vName`输入。
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter01/start_here/cc-ng-on-changes`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的项目位于`chapter01/start_here/cc-ng-on-changes`中：
- en: Open the project in Visual Studio Code.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: 'Once done, run `ng serve -o`. This should open the app in a new browser tab
    and you should see the app as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。这应该会在新的浏览器标签中打开应用程序，您应该会看到应用程序如下所示：
- en: '![Figure 1.7 – The cc-ng-on-changes app running on http://localhost:4200'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.7 - cc-ng-on-changes应用程序在http://localhost:4200上运行'
- en: '](image/Figure_1.07_B15150.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.07_B15150.jpg)'
- en: Figure 1.7 – The cc-ng-on-changes app running on http://localhost:4200
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 - cc-ng-on-changes应用程序在http://localhost:4200上运行
- en: How to do it…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We''ll first create a logs array in `VcLogsComponent` as follows to store all
    the logs that we''ll display later using our template:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`VcLogsComponent`中创建一个logs数组，以便稍后在模板中显示所有的日志：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s create the HTML for where we''ll show the logs. Let''s add the logs
    container and log items using the following code to `vc-logs.component.html`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个用于显示日志的HTML。让我们使用以下代码在`vc-logs.component.html`中添加日志容器和日志项：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we''ll add a bit of styling for the logs container and log items to be
    shown, in `vc-logs.component.scss`, as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在`vc-logs.component.scss`中添加一些样式，以便显示日志容器和日志项，如下所示：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should see something like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到类似于这样的东西：
- en: '![ Figure 1.8 – The cc-ng-on-changes app with logs container styles'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.8 - cc-ng-on-changes应用程序带有日志容器样式'
- en: '](image/Figure_1.08_B15150.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.08_B15150.jpg)'
- en: Figure 1.8 – The cc-ng-on-changes app with logs container styles
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 - cc-ng-on-changes应用程序带有日志容器样式
- en: 'Now, let''s implement `ngOnChanges` using simple changes in `VcLogsComponent`
    as follows in the `vc-logs.component.ts` file:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`vc-logs.component.ts`文件中实现`VcLogsComponent`中的`ngOnChanges`，使用简单的更改如下：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We now can add a log for the initial value of the `vName` input saying `''initial
    version is x.x.x''`. We do this by checking whether it is the initial value using
    the `.isFirstChange()` method as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以为`vName`输入的初始值添加一个日志，内容为`'initial version is x.x.x'`。我们通过使用`.isFirstChange()`方法来检查是否为初始值来实现这一点，如下所示：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s handle the case where we update the version after the initial value
    was assigned. For that, we''ll add another log that says `''version changed to
    x.x.x''` using an `else` condition, as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们处理在分配初始值后更新版本的情况。为此，我们将添加另一个日志，使用`else`条件，内容为`'version changed to x.x.x'`，如下所示：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: '`ngOnChanges` is one of the many life cycle hooks Angular provides out of the
    box. It triggers even before the `ngOnInit` hook. So, you get the *initial values*
    in the first call and the *updated values* later on. Whenever any of the inputs
    change, the `ngOnChanges` callback is triggered with `SimpleChanges` and you can
    get the previous value, the current value, and a Boolean representing whether
    this is the first change to the input (that is, the initial value). When we update
    the value of the `vName` input in the parent, `ngOnChanges` gets called with the
    updated value. Then, based on the situation, we add an appropriate log into our
    `logs` array and display it on the UI.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnChanges`是Angular提供的许多生命周期钩子之一。它甚至在`ngOnInit`钩子之前触发。因此，您在第一次调用时获得*初始值*，稍后获得*更新后的值*。每当任何输入发生更改时，都会使用`SimpleChanges`触发`ngOnChanges`回调，并且您可以获取先前的值、当前的值以及表示这是否是输入的第一次更改的布尔值（即初始值）。当我们在父级更新`vName`输入的值时，`ngOnChanges`会使用更新后的值进行调用。然后，根据情况，我们将适当的日志添加到我们的`logs`数组中，并在UI上显示它。'
- en: See also
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Angular life cycle hooks: [https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular生命周期钩子：[https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks)
- en: 'Using change detection hooks with `ngOnChanges`: [https://angular.io/guide/lifecycle-hooks#using-change-detection-hooks](https://angular.io/guide/lifecycle-hooks#using-change-detection-hooks)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ngOnChanges`的变更检测钩子：[https://angular.io/guide/lifecycle-hooks#using-change-detection-hooks](https://angular.io/guide/lifecycle-hooks#using-change-detection-hooks)
- en: '`SimpleChanges` API reference: [https://angular.io/api/core/SimpleChanges](https://angular.io/api/core/SimpleChanges)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleChanges` API参考：[https://angular.io/api/core/SimpleChanges](https://angular.io/api/core/SimpleChanges)'
- en: Accessing a child component in the parent template via template variables
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过模板变量在父模板中访问子组件
- en: In this recipe, you'll learn how to use **Angular template reference variables**
    to access a child component into a parent component's template. You'll start with
    an app having `AppComponent` as the parent component and `GalleryComponent` as
    the child component. You'll then create a template variable for the child component
    in the parent's template to access it and perform some actions in the component
    class.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用**Angular模板引用变量**来访问父组件模板中的子组件。您将从一个具有`AppComponent`作为父组件和`GalleryComponent`作为子组件的应用程序开始。然后，您将在父模板中为子组件创建一个模板变量，以便访问它并在组件类中执行一些操作。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter01/start_here/cc-template-vars`
    inside the cloned repository:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的项目位于克隆存储库内的`chapter01/start_here/cc-template-vars`中：
- en: Open the project in Visual Studio Code.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`以安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see something
    like the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器选项卡中打开应用程序，并且您应该看到类似以下内容的东西：
- en: '![Figure 1.9 – The cc-template-vars app running on http://localhost:4200'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.9 - 在http://localhost:4200上运行的cc-template-vars应用程序的运行情况]'
- en: '](image/Figure_1.09_B15150.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.09_B15150.jpg)'
- en: Figure 1.9 – The cc-template-vars app running on http://localhost:4200
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 - 运行在http://localhost:4200上的cc-template-vars应用程序
- en: Click the buttons at the top to see the respective console logs.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部的按钮以查看各自的控制台日志。
- en: How to do it…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll start with creating a template variable named `#gallery`, on the `<app-gallery>`
    component in the `app.component.html` file:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从在`app.component.html`文件中的`<app-gallery>`组件上创建一个名为`#gallery`的模板变量开始：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we modify the `addNewPicture()` and `removeFirstPicture()` methods in
    `app.component.ts` to accept a parameter named `gallery`, so that they can accept
    the template variable from `app.component.html` when we click the buttons. The
    code should look as follows:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们修改`app.component.ts`中的`addNewPicture()`和`removeFirstPicture()`方法，以接受一个名为`gallery`的参数，这样当我们点击按钮时，它们可以接受来自`app.component.html`的模板变量。代码应该如下所示：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s pass the `#gallery` template variable from `app.component.html`
    to the click handlers for both buttons as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将`app.component.html`中的`#gallery`模板变量传递给两个按钮的点击处理程序，如下所示：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can now implement the code for adding a new picture. For this, we''ll access
    `GalleryComponent`''s `generateImage()` method and add a new item to the `pictures`
    array as the first element. The code is as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以实现添加新图片的代码。为此，我们将访问`GalleryComponent`的`generateImage()`方法，并将一个新项添加到`pictures`数组中作为第一个元素。代码如下：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For removing the first item from the array, we''ll use the array''s `shift`
    method on the `pictures` array in the `GalleryComponent` class to remove the first
    item as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从数组中删除第一个项目，我们将在`GalleryComponent`类中的`pictures`数组上使用数组的`shift`方法来删除第一个项目，如下所示：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A template reference variable is often a reference to a DOM element within
    a template. It can also refer to a directive (which contains a component), an
    element, `TemplateRef`, or a web component (source: [https://angular.io/guide/template-reference-variables](https://angular.io/guide/template-reference-variables)).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引用变量通常是模板中的DOM元素的引用。它也可以引用指令（其中包含一个组件）、元素、`TemplateRef`或Web组件（来源：[https://angular.io/guide/template-reference-variables](https://angular.io/guide/template-reference-variables)）。
- en: In essence, we can refer to our `<app-gallery>` component, which behind the
    scenes is a directive in Angular. Once we have the variable in our template, we
    pass the reference to the functions in our component as function arguments. Then,
    we can access the properties and the methods of `GalleryComponent` from there.
    You can see that we are able to add and remove items from the `pictures` array
    that resides in `GalleryComponent` directly from `AppComponent`, which is the
    parent component in this entire flow.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们可以引用我们的`<app-gallery>`组件，它在Angular中是一个指令。一旦我们在模板中有了这个变量，我们将引用传递给我们组件中的函数作为函数参数。然后，我们可以从那里访问`GalleryComponent`的属性和方法。您可以看到，我们能够直接从`AppComponent`中添加和删除`GalleryComponent`中的`pictures`数组中的项目，而`AppComponent`是整个流程中的父组件。
- en: See also
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Angular template variables: [https://angular.io/guide/template-reference-variables](https://angular.io/guide/template-reference-variables)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular模板变量：[https://angular.io/guide/template-reference-variables](https://angular.io/guide/template-reference-variables)
- en: 'Angular template statements: [https://angular.io/guide/template-statements](https://angular.io/guide/template-statements)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular模板语句：[https://angular.io/guide/template-statements](https://angular.io/guide/template-statements)
- en: Accessing a child component in a parent component class using ViewChild
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ViewChild在父组件类中访问子组件
- en: In this recipe, you'll learn how to use the `ViewChild` decorator to access
    a child component in a parent component's class. You'll start with an app that
    has `AppComponent` as the parent component and `GalleryComponent` as the child
    component. You'll then create a `ViewChild` for the child component in the parent's
    component class to access it and perform some actions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用`ViewChild`装饰器来访问父组件类中的子组件。您将从一个具有`AppComponent`作为父组件和`GalleryComponent`作为子组件的应用程序开始。然后，您将在父组件类中为子组件创建一个`ViewChild`来访问它并执行一些操作。
- en: Getting ready
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter01/start_here/cc-view-child`
    inside the cloned repository:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的项目位于克隆存储库内的`chapter01/start_here/cc-view-child`中：
- en: Open the project in Visual Studio Code.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
    Once done, run `ng serve -o`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。完成后，运行`ng serve -o`。
- en: This should open the app in a new browser tab and you should see something like
    the following:![Figure 1.10 – The cc-view-child app running on http://localhost:4200
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在新的浏览器标签中打开应用程序，您应该会看到类似以下内容的内容：![图1.10 - 在http://localhost:4200上运行的cc-view-child应用程序
- en: '](image/Figure_1.10_B15150.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.10_B15150.jpg)'
- en: Figure 1.10 – The cc-view-child app running on http://localhost:4200
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 - 在http://localhost:4200上运行的cc-view-child应用程序
- en: Click the buttons at the top to see the respective console logs.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部的按钮查看相应的控制台日志。
- en: How to do it…
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We''ll start with importing `GalleryComponent` into our `app.component.ts`
    file so we can create a `ViewChild` for it:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从将`GalleryComponent`导入到我们的`app.component.ts`文件开始，以便我们可以为其创建一个`ViewChild`：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we''ll create the `ViewChild` for `GalleryComponent` using the `ViewChild()`
    decorator, as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用`ViewChild()`装饰器为`GalleryComponent`创建`ViewChild`，如下所示：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we''ll implement the logic for adding a new picture. For that, in the
    `addNewPicture` method inside `AppComponent`, we''ll use the `gallery` prop we
    created in *step 2*. This is to access the `pictures` array from the child component.
    Once done, we will add a new picture to the top of that array using the `generateImage`
    method of `GalleryComponent`, as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将实现添加新图片的逻辑。为此，在`AppComponent`内的`addNewPicture`方法中，我们将使用*步骤2*中创建的`gallery`属性。这是为了访问子组件中的`pictures`数组。完成后，我们将使用`GalleryComponent`的`generateImage`方法将新图片添加到该数组的顶部，如下所示：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To handle removing pictures, we''ll add the logic to the `removeFirstPicture`
    method inside the `AppComponent` class. We''ll do this using the view child as
    well. We''ll simply use the `Array.prototype.shift` method on the `pictures` array
    to remove the first element, as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理删除图片，我们将在`AppComponent`类内的`removeFirstPicture`方法中添加逻辑。我们也将使用视图子组件。我们将简单地在`pictures`数组上使用`Array.prototype.shift`方法来删除第一个元素，如下所示：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works…
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`ViewChild()` is basically a decorator that the `@angular/core` package provides
    out of the box. It configures a **view query** for the Angular change detector.
    The change detector tries to find the first element matching the query and assigns
    it to the property associated with the `ViewChild()` decorator. In our recipe,
    we create a view child by providing `GalleryComponent` as the query parameter,
    that is, `ViewChild(GalleryComponent)`. This allows the Angular change detector
    to find the `<app-gallery>` element inside the `app.component.html` template,
    and then it assigns it to the `gallery` property within the `AppComponent` class.
    It is important to define the gallery property''s type as `GalleryComponent` so
    we can easily use that in the component later with all the TypeScript magic.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewChild()` 基本上是 `@angular/core` 包提供的装饰器。它为 Angular 变更检测器配置了一个**视图查询**。变更检测器尝试找到与查询匹配的第一个元素，并将其分配给与
    `ViewChild()` 装饰器关联的属性。在我们的示例中，我们通过将 `GalleryComponent` 作为查询参数来创建一个视图子元素，即 `ViewChild(GalleryComponent)`。这允许
    Angular 变更检测器在 `app.component.html` 模板中找到 `<app-gallery>` 元素，然后将其分配给 `AppComponent`
    类中的 `gallery` 属性。重要的是将 gallery 属性的类型定义为 `GalleryComponent`，这样我们稍后可以在组件中轻松使用 TypeScript
    魔法。'
- en: Important note
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The view query is executed after the `ngOnInit` life cycle hook and before the
    `ngAfterViewInit` hook.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 视图查询在 `ngOnInit` 生命周期钩子之后和 `ngAfterViewInit` 钩子之前执行。
- en: See also
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Angular `ViewChild`: [https://angular.io/api/core/ViewChild](https://angular.io/api/core/ViewChild)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular `ViewChild`：[https://angular.io/api/core/ViewChild](https://angular.io/api/core/ViewChild)
- en: 'Array''s shift method: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的 shift 方法：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)
- en: Creating your first dynamic component in Angular
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Angular 中创建您的第一个动态组件
- en: In this recipe, you'll learn how to create **dynamic components** in Angular,
    which are created dynamically on-demand based on different conditions. Why? Because
    you might have several complex conditions and you want to load a particular component
    based on that, instead of just putting every possible component in your template.
    We'll be using the `ComponentFactoryResolver` service, the `ViewChild()` decorator,
    and the `ViewContainerRef` service to achieve the dynamic loading. I'm excited,
    and so are you!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何在 Angular 中创建**动态组件**，这些组件根据不同的条件动态创建。为什么？因为您可能有几个复杂的条件，并且您希望根据这些条件加载特定的组件，而不是只将每个可能的组件放在模板中。我们将使用
    `ComponentFactoryResolver` 服务、`ViewChild()` 装饰器和 `ViewContainerRef` 服务来实现动态加载。我很兴奋，你也是！
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The project that we are going to work with resides in `chapter01/start_here/ng-dynamic-components`
    inside the cloned repository:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的项目位于克隆存储库中的 `chapter01/start_here/ng-dynamic-components` 中。
- en: Open the project in Visual Studio Code.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see something
    like the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器选项卡中打开应用程序，您应该看到类似以下内容：
- en: '![Figure 1.11 – The ng-dynamic-components app running on http://localhost:4200'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.11 - ng-dynamic-components 应用程序在 http://localhost:4200 上运行'
- en: '](image/Figure_1.11_B15150.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.11_B15150.jpg)'
- en: Figure 1.11 – The ng-dynamic-components app running on http://localhost:4200
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 - ng-dynamic-components 应用程序在 http://localhost:4200 上运行
- en: Click the buttons at the top to see the respective console logs.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部的按钮以查看相应的控制台日志。
- en: How to do it…
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'First of all, let''s remove the elements with the `[ngSwitch]` and `*ngSwitchCase`
    directives from our `social-card.component.html` file and replace them with a
    simple `div` with a template variable named `#vrf`. We''ll use this `div` as a
    container. The code should look as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们从我们的`social-card.component.html`文件中删除带有`[ngSwitch]`和`*ngSwitchCase`指令的元素，并将它们替换为一个简单的带有模板变量命名为`#vrf`的`div`。我们将使用这个`div`作为容器。代码应该如下所示：
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we''ll add the `ComponentFactoryResolver` service to `social-card.component.ts`
    as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`social-card.component.ts`中添加`ComponentFactoryResolver`服务，如下所示：
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we create a `ViewChild` for `ViewContainerRef` in the same file, so that
    we can refer to the `#vrf` div from the template, as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在同一个文件中为`ViewContainerRef`创建一个`ViewChild`，这样我们就可以从模板中引用`#vrf` div，如下所示：
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To create the components dynamically, we need to listen to the changes to the
    type input. So, whenever it changes, we load the appropriate component dynamically.
    For this, we''ll implement the `ngOnChanges` hook in `SocialCardComponent` and
    log the changes on the console for now. Once implemented, you should see the logs
    on the console upon tapping the Facebook or Twitter buttons:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了动态创建组件，我们需要监听类型输入的变化。所以，每当它发生变化时，我们就动态加载适当的组件。为此，我们将在`SocialCardComponent`中实现`ngOnChanges`钩子，并暂时在控制台上记录更改。一旦实现，您应该在点击Facebook或Twitter按钮时在控制台上看到日志。
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we''ll create a method in `SocialCardComponent` called `loadDynamicComponent`
    that accepts the type of social card, that is, `SocialCardType`, and decides which
    component to load dynamically. We''ll also create a variable named `component`
    inside the method to select which component is to be loaded. This should look
    as follows:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`SocialCardComponent`中创建一个名为`loadDynamicComponent`的方法，该方法接受社交卡的类型，即`SocialCardType`，并决定动态加载哪个组件。我们还将在方法内部创建一个名为`component`的变量，以选择要加载的组件。代码应该如下所示：
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now that we know which component is to be dynamically loaded, let''s use `componentFactoryResolver`
    to resolve the component and then to create the component inside `ViewContainerRef`
    (`vrf`), as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道要动态加载哪个组件，让我们使用`componentFactoryResolver`来解析组件，然后在`ViewContainerRef`(`vrf`)中创建组件，如下所示：
- en: '[PRE50]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: With the preceding change, we're almost there. When you tap either the Facebook
    or Twitter button for the first time, you should see the appropriate component
    being dynamically created.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的更改，我们已经接近成功了。当您第一次点击Facebook或Twitter按钮时，您应该看到适当的组件被动态创建。
- en: But… if you tap either of those buttons again, you'll see the component being
    added to the view as an additional element.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 但是…如果你再次点击其中任何一个按钮，你会看到组件被添加到视图中作为一个额外的元素。
- en: 'Upon inspecting, it might look something like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 检查后，它可能看起来像这样：
- en: '![Figure 1.12 – Preview of multiple elements being added to ViewContainerRef'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.12 - 预览多个元素被添加到ViewContainerRef'
- en: '](image/Figure_1.12_B15150.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.12_B15150.jpg)'
- en: Figure 1.12 – Preview of multiple elements being added to ViewContainerRef
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 - 预览多个元素被添加到ViewContainerRef
- en: 'Read in the *How it works…* section why this happens. But to fix it, we just
    perform a `clear()` on `ViewContainerRef` before we create the dynamic component,
    as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读*它是如何工作的…*部分，了解为什么会发生这种情况。但要解决这个问题，我们只需在创建动态组件之前在`ViewContainerRef`上执行`clear()`，如下所示：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works…
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`ComponentFactoryResolver` is an Angular service that allows you to resolve
    components dynamically at runtime. In our recipe, we use the `resolveComponentFactory`
    method, which accepts a **Component** and returns a `ComponentFactory`. We can
    always use the `create` method of `ComponentFactory` to create instances of the
    component. But in this recipe, we''re using `ViewContainerRef`''s `createComponent`
    method, which accepts `ComponentFactory` as an input. It then uses `ComponentFactory`
    behind the scenes to generate the component and then to add it to the attached
    `ViewContainerRef`. Every time you create a component and attach it to `ViewContainerRef`,
    it''ll add a new component to the existing list of elements. For our recipe, we
    only needed to show one component at a time, that is, either `FBCardComponent`
    or `TwitterCardComponent`. So that only a single element exists in `ViewContainerRef`,
    we used the `clear()` method on it before adding an element.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComponentFactoryResolver`是一个Angular服务，允许您在运行时动态解析组件。在我们的示例中，我们使用`resolveComponentFactory`方法，该方法接受一个**组件**并返回一个`ComponentFactory`。我们可以始终使用`ComponentFactory`的`create`方法来创建组件的实例。但在这个示例中，我们使用了`ViewContainerRef`的`createComponent`方法，该方法接受`ComponentFactory`作为输入。然后它在后台使用`ComponentFactory`来生成组件，然后将其添加到附加的`ViewContainerRef`中。每次您创建一个组件并将其附加到`ViewContainerRef`时，它都会将新组件添加到现有元素列表中。对于我们的示例，我们只需要一次显示一个组件，即`FBCardComponent`或`TwitterCardComponent`。因此，在添加元素之前，我们在`ViewContainerRef`上使用了`clear()`方法，以便只存在单个元素。'
- en: See also
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The `resolveComponentFactory` method: [https://angular.io/api/core/ComponentFactoryResolver#resolvecomponentfactory](https://angular.io/api/core/ComponentFactoryResolver#resolvecomponentfactory)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resolveComponentFactory`方法：[https://angular.io/api/core/ComponentFactoryResolver#resolvecomponentfactory](https://angular.io/api/core/ComponentFactoryResolver#resolvecomponentfactory)'
- en: 'Angular''s documentation on the dynamic component loader: [https://angular.io/guide/dynamic-component-loader](https://angular.io/guide/dynamic-component-loader)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular关于动态组件加载器的文档：[https://angular.io/guide/dynamic-component-loader](https://angular.io/guide/dynamic-component-loader)
- en: '`ViewContainerRef` docs: [https://angular.io/api/core/ViewContainerRef](https://angular.io/api/core/ViewContainerRef)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewContainerRef`文档：[https://angular.io/api/core/ViewContainerRef](https://angular.io/api/core/ViewContainerRef)'
- en: 'Loading Components Dynamically in Angular 9 with IVY: [https://labs.thisdot.co/blog/loading-components-dynamically-in-angular-9-with-ivy](https://labs.thisdot.co/blog/loading-components-dynamically-in-angular-9-with-ivy)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular 9中使用IVY动态加载组件：[https://labs.thisdot.co/blog/loading-components-dynamically-in-angular-9-with-ivy](https://labs.thisdot.co/blog/loading-components-dynamically-in-angular-9-with-ivy)
