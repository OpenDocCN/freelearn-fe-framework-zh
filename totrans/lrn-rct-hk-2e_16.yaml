- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Migrating from React Class Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从React类组件迁移
- en: In the previous chapter, we learned how to build our own Hooks by extracting
    custom Hooks from existing code. Then, we used our custom Hooks in the blog app.
    Finally, we learned how to write tests for Hooks, using the React Testing Library,
    and wrote tests for our custom Hooks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何通过从现有代码中提取自定义钩子来构建自己的钩子。然后，我们在博客应用中使用了我们的自定义钩子。最后，我们学习了如何使用React测试库为钩子编写测试，并为我们的自定义钩子编写了测试。
- en: In this chapter, we are going to start by implementing a todo app using React
    class components. Then, we are going to learn how to migrate an existing React
    class component application to Hooks. Seeing the differences between Hooks and
    class components in practice will deepen our understanding of the trade-offs of
    using either solution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先通过实现一个待办事项应用来使用React类组件。然后，我们将学习如何将现有的React类组件应用迁移到钩子。通过实际比较钩子和类组件之间的差异，我们将加深对使用这两种解决方案权衡的理解。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Handling state with React class components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React类组件处理状态
- en: Migrating from React class components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从React类组件迁移
- en: Trade-offs of React class components vs React Hooks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React类组件与React Hooks的权衡
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A fairly recent version of Node.js should already be installed. The Node Package
    Manager (`npm`) also needs to be installed (it should come with Node.js). For
    more information on how to install Node.js, please check out their official website:
    [https://nodejs.org/](https://nodejs.org/).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经安装了相当新的Node.js版本。Node包管理器（`npm`）也需要安装（它应该与Node.js一起安装）。有关如何安装Node.js的更多信息，请访问他们的官方网站：[https://nodejs.org/](https://nodejs.org/)
- en: 'We are going to use **Visual Studio Code** (**VS Code**) for the guides in
    this book, but everything should work similarly in any other editor. For more
    information on how to install VS Code, please refer to their official website:
    [https://code.visualstudio.com](https://code.visualstudio.com)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的指南中使用**Visual Studio Code**（**VS Code**），但任何其他编辑器都应该以类似的方式工作。有关如何安装VS
    Code的更多信息，请参阅他们的官方网站：[https://code.visualstudio.com](https://code.visualstudio.com)
- en: 'In this book, we use the following versions:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用以下版本：
- en: Node.js v22.14.0
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js v22.14.0
- en: '`npm` v10.9.2'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm` v10.9.2'
- en: Visual Studio Code v1.97.2
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code v1.97.2
- en: The versions mentioned in the preceding list are the ones used in the book.
    While installing a newer version should not be an issue, please note that certain
    steps might work differently on a newer version. If you are having an issue with
    the code and steps provided in this book, please try using the mentioned versions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前面列表中提到的版本是本书中使用的版本。虽然安装较新版本可能不会出现问题，但请注意，某些步骤在较新版本上可能工作方式不同。如果您在使用本书中提供的代码和步骤时遇到问题，请尝试使用提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter13)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码：[https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter13)
- en: It is highly recommended that you write the code on your own. Do not simply
    run the code examples that are provided with the book. It is important to write
    the code yourself to be able to learn and understand it properly. However, if
    you run into any issues, you can always refer to the code example.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您自己编写代码。不要简单地运行书中提供的代码示例。自己编写代码对于正确学习和理解代码非常重要。然而，如果您遇到任何问题，您始终可以参考代码示例。
- en: Handling state with React class components
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React类组件处理状态
- en: Before we start migrating from class components to Hooks, we are going to create
    a small todo list app using class components. Afterward, we are going to turn
    these class components into function components using Hooks. Finally, we are going
    to compare the two solutions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从类组件迁移到钩子之前，我们将创建一个使用类组件的小型待办事项应用。之后，我们将使用钩子将这些类组件转换为函数组件。最后，我们将比较这两种解决方案。
- en: Designing the app structure
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计应用结构
- en: 'As we did before with the blog app, we are going to start by thinking about
    the basic structure of our todo app. Here, we are going to need the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的博客应用中所做的那样，我们将首先思考我们的待办事项应用的基本结构。在这里，我们需要以下内容：
- en: A header
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标题
- en: A way to add new todo items
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种添加新待办事项的方法
- en: A way to show all todo items in a list
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种在列表中显示所有待办事项的方法
- en: A filter for the todo items
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 待办事项的过滤器
- en: 'It is always a good idea to start with a mock-up. So let’s begin:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 总是先从原型开始是一个好主意。所以让我们开始：
- en: 'Based on the previous list of structural elements, start by drawing a mock-up
    of an interface for our todo app:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据之前的结构元素列表，开始绘制我们的待办事项应用界面的原型：
- en: '![Figure 13.1 – Mock-up of our todo app](img/B31327_13_01.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – 我们的待办事项应用的原型](img/B31327_13_01.png)'
- en: Figure 13.1 – Mock-up of our todo app
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 我们的待办事项应用的原型
- en: 'Next, map out the simple components by drawing around the UI elements and giving
    them a name, in a similar way to how we did it with the blog app:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过围绕UI元素绘制并给它们命名来绘制简单的组件，类似于我们在博客应用中做的那样：
- en: '![Figure 13.2 – Mapping out simple components in our app mock-up](img/B31327_13_02.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 在我们的应用原型中绘制简单组件](img/B31327_13_02.png)'
- en: Figure 13.2 – Mapping out simple components in our app mock-up
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 在我们的应用原型中绘制简单组件
- en: 'Now, map out the container components, which group together the simple components:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，绘制容器组件，它们将简单的组件组合在一起：
- en: '![Figure 13.3 – Mapping out container components in our app mock-up](img/B31327_13_03.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 在我们的应用原型中绘制容器组件](img/B31327_13_03.png)'
- en: Figure 13.3 – Mapping out container components in our app mock-up
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 在我们的应用原型中绘制容器组件
- en: 'As we can see, we are going to need the following components:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们需要以下组件：
- en: '`App`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App`'
- en: '`Header`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Header`'
- en: '`AddTodo`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddTodo`'
- en: '`TodoList`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoList`'
- en: '`TodoItem`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoItem`'
- en: '`TodoFilter` (+ `TodoFilterItem`)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoFilter` (+ `TodoFilterItem`)'
- en: The `TodoList` component makes use of a `TodoItem` component, which is used
    to show an item, with a checkbox to complete and a button to remove it. The `TodoFilter`
    component internally uses a `TodoFilterItem` component to show the various filters.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoList`组件使用了`TodoItem`组件，用于显示一个项目，包括一个复选框来完成它和一个按钮来移除它。`TodoFilter`组件内部使用`TodoFilterItem`组件来显示各种过滤器。'
- en: Initializing the project
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化项目
- en: 'We are going to use the barebones Vite app from [*Chapter 1*](Chapter_01.xhtml#_idTextAnchor016)*,
    Introducing React and React Hooks* to create a new project. Let’s initialize the
    project now:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自[*第1章*](Chapter_01.xhtml#_idTextAnchor016)*，介绍React和React Hooks的裸骨Vite应用来创建一个新的项目。现在让我们初始化项目：
- en: 'Copy the `Chapter01_3` folder to a new `Chapter13_1` folder, as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Chapter01_3`文件夹复制到一个新的`Chapter13_1`文件夹中，如下所示：
- en: '[PRE0]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open the new `Chapter13_1` folder in VS Code.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开新的`Chapter13_1`文件夹。
- en: '*Delete* the current `src/App.jsx` file, as we are going to create a new one
    in the next step.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除*当前的`src/App.jsx`文件，因为我们将在下一步创建一个新的文件。'
- en: With our project initialized, we can start defining the app structure.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目初始化后，我们可以开始定义应用结构。
- en: Defining the app structure
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义应用结构
- en: 'We already know what the basic structure of our app is going to be like from
    the mock-ups, so let’s start by defining the `App` component:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从原型中知道了应用的基本结构，所以让我们首先定义`App`组件：
- en: Create a new `src/App.jsx` file.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/App.jsx`文件。
- en: 'Inside it, import `React`, and all the container components of our app:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，导入`React`以及我们应用的所有容器组件：
- en: '[PRE1]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, define the `App` component as a class component. In a class component,
    we need to define a `render` method to render our component:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`App`组件定义为类组件。在类组件中，我们需要定义一个`render`方法来渲染我们的组件：
- en: '[PRE2]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The App component defines the basic structure of our app. It will consist of
    a header, a way to add new todo items, a list of todo items, and a filter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件定义了我们的应用的基本结构。它将包括一个标题、添加新待办事项的方式、待办事项列表和一个过滤器。'
- en: Defining the components
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义组件
- en: 'Now, we are going to define the following components as static components:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将以下组件定义为静态组件：
- en: '`Header`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Header`'
- en: '`AddTodo`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddTodo`'
- en: '`TodoList`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoList`'
- en: '`TodoItem`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoItem`'
- en: '`TodoFilter`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoFilter`'
- en: Later in this chapter, we are going to add dynamic functionality to them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将向它们添加动态功能。
- en: Defining the Header component
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义Header组件
- en: 'We are going to start with the `Header` component, as it is the most simple
    out of all the components:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最简单的组件`Header`开始，因为它是最简单的：
- en: Create a new `src/Header.jsx` file.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/Header.jsx`文件。
- en: In this project, we decided to put all components directly in the `src/` folder,
    as there are only a handful of components anyway.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们决定将所有组件直接放在`src/`文件夹中，因为组件数量很少。
- en: 'Inside the newly created file, import `React`, and define the class component
    with a `render` method:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的文件中，导入`React`，并使用`render`方法定义类组件：
- en: '[PRE3]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Defining the AddTodo component
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义AddTodo组件
- en: 'Next, we are going to define the `AddTodo` component, which renders an `input`
    field and a button:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义`AddTodo`组件，它将渲染一个输入字段和一个按钮：
- en: Create a new `src/AddTodo.jsx` file.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/AddTodo.jsx`文件。
- en: 'Inside it, import `React` and define the class component:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，导入`React`并定义类组件：
- en: '[PRE4]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the `render` method, we return a form that contains an input field and a
    submit button:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render`方法中，我们返回一个包含输入字段和提交按钮的表单：
- en: '[PRE5]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Defining the TodoList component
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义TodoList组件
- en: Now, we define the `TodoList` component, which is going to make use of the `TodoItem`
    component (we will create that one in the next step). For now, we are going to
    statically define the data for two todo items in an array and use it to render
    `TodoItem` components.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义`TodoList`组件，它将使用`TodoItem`组件（我们将在下一步创建它）。现在，我们将在一个数组中静态定义两个待办事项的数据，并使用它来渲染`TodoItem`组件。
- en: 'Let’s start defining the `TodoList` component:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始定义`TodoList`组件：
- en: Create a new `src/TodoList.jsx` file.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/TodoList.jsx`文件。
- en: 'Inside it, import `React` and the `TodoItem` component:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，导入`React`和`TodoItem`组件：
- en: '[PRE6]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, define the class component:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义类组件：
- en: '[PRE7]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `render` method, we statically define two todo items:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render`方法中，我们静态地定义了两个待办事项：
- en: '[PRE8]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we are going to render the items using the `map` function:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用`map`函数渲染项目：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We define the `key` property last, in order to avoid overwriting it with the
    spreading of the `item` object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后定义`key`属性，以避免在`item`对象展开时覆盖它。
- en: Defining the TodoItem component
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义TodoItem组件
- en: 'After defining the `TodoList` component, we are now going to define the `TodoItem`
    component, in order to render single items. Let’s start defining the `TodoItem`
    component:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`TodoList`组件之后，我们现在将定义`TodoItem`组件，以便渲染单个项目。让我们开始定义`TodoItem`组件：
- en: Create a new `src/TodoItem.jsx` file.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/TodoItem.jsx`文件。
- en: 'Inside it, import `React` and define the class component:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，导入`React`并定义类组件：
- en: '[PRE10]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we are going to use destructuring to get the `title` and `completed` props:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用解构来获取`title`和`completed`属性：
- en: '[PRE11]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we are going to render a checkbox, the title and a button to delete
    the item:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将渲染一个复选框、标题和一个删除项目的按钮：
- en: '[PRE12]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Defining the TodoFilter component
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义TodoFilter组件
- en: 'Finally, we are going to define the `TodoFilter` component. In the same file,
    we are also going to define the `TodoFilterItem` component, as they are tightly
    coupled to each other. So, let’s start implementing these components:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将定义`TodoFilter`组件。在同一个文件中，我们还将定义`TodoFilterItem`组件，因为它们紧密相关。所以，让我们开始实现这些组件：
- en: Create a new `src/TodoFilter.jsx` file.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/TodoFilter.jsx`文件。
- en: 'Inside it, import `React` and define a `TodoFilterItem` class component:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，导入`React`并定义一个`TodoFilterItem`类组件：
- en: '[PRE13]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We use destructuring to get the `name` prop:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用解构来获取`name`属性：
- en: '[PRE14]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we return a button to select the filter:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们返回一个按钮来选择过滤器：
- en: '[PRE15]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we define the actual `TodoFilter` component, which is going to render
    three `TodoFilterItem` components:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义实际的`TodoFilter`组件，它将渲染三个`TodoFilterItem`组件：
- en: '[PRE16]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we finished implementing all static components, we can start the app.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了所有静态组件，我们可以开始启动应用。
- en: Starting the app
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动应用
- en: 'To start the app, run the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动应用，运行以下命令：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Open the URL in a browser and you will see that the app looks just like our
    mock-up!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开URL，你会看到应用看起来就像我们的模拟图一样！
- en: However, the app is completely static, and when we click on anything, nothing
    happens. In the next step, we are going to make our app dynamic.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，应用是完全静态的，当我们点击任何东西时，什么都不会发生。在下一步中，我们将使我们的应用动态化。
- en: Implementing dynamic code
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现动态代码
- en: Now that we have defined all of the static components, our app should look just
    like the mock-up. The next step is to implement dynamic code using React state,
    life cycle, and handler functions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了所有静态组件，我们的应用应该看起来就像模拟图。下一步是实现使用React状态、生命周期和处理器函数的动态代码。
- en: 'In this section, we are going to:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将要：
- en: Define a mock API
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模拟API
- en: Define the `StateContext`
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`StateContext`
- en: Make the `App` component dynamic
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使`App`组件动态化
- en: Make the `AddTodo` component dynamic
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使`AddTodo`组件动态化
- en: Make the `TodoList` component dynamic
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使`TodoList`组件动态化
- en: Make the `TodoItem` component dynamic
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使`TodoItem`组件动态化
- en: Make the `TodoFilter` component dynamic
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使`TodoFilter`组件动态化
- en: Let’s get started.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Defining a mock API
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义模拟API
- en: First of all, we are going to define an API that will fetch todos. In our case,
    we are simply going to return an array of todo items, after a short delay, to
    simulate a network request, which usually takes some time to resolve.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个API来获取待办事项。在我们的例子中，我们将在短暂的延迟后返回一个待办事项数组，以模拟网络请求，这通常需要一些时间来解决。
- en: 'Let’s start implementing the mock API now:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始实现模拟API：
- en: Create a new `src/api.js` file.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/api.js`文件。
- en: 'Inside it, define and export a function that returns items after a short delay:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，定义并导出一个函数，该函数在短暂的延迟后返回项目：
- en: '[PRE18]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here we are using the Promise API to resolve with an array of mock items after
    waiting for 100ms to simulate a real API request.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用Promise API在等待100ms后解析一个包含模拟项目的数组，以模拟真实的API请求。
- en: Next, we are going to define a context that will keep our current list of todos.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个上下文，它将保持我们当前的待办事项列表。
- en: Defining the StateContext
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义状态上下文
- en: 'We are now going to define the context that will keep the current state of
    our todo app:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将定义一个上下文，它将保持我们待办应用的当前状态：
- en: Create a new `src/StateContext.js` file.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/StateContext.js`文件。
- en: 'Inside it, import the `createContext` function from React:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，从React导入`createContext`函数：
- en: '[PRE19]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, define and export a context that contains an empty array:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义并导出一个包含空数组的上下文：
- en: '[PRE20]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we have a context where we can store our array of todo items, let’s
    move on to making the components dynamic.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以存储我们的待办事项数组的上下文，让我们继续使组件动态化。
- en: Making the App component dynamic
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使App组件动态化
- en: 'We are going to start by making the `App` component dynamic, adding functionality
    to fetch, add, toggle, filter, and remove todo items. To do this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使`App`组件动态化，添加获取、添加、切换、过滤和删除待办事项的功能。为此：
- en: 'Edit `src/App.jsx` and import the `StateContext` and the `fetchTodos` function:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.jsx`并导入`StateContext`和`fetchTodos`函数：
- en: '[PRE21]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we are going to modify our `App` class code, adding a `constructor` to
    it, which will set the initial state:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将修改我们的`App`类代码，向其中添加一个`constructor`，它将设置初始状态：
- en: '[PRE22]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this constructor, we first need to call `super` to make sure that the parent
    class (`React.Component`) constructor gets called and the component gets initialized
    properly:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个构造函数中，我们首先需要调用`super`以确保父类（`React.Component`）的构造函数被调用，并且组件被正确初始化：
- en: '[PRE23]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we can set the initial state with `this.state`. Initially, there are no
    todo items, and the filter is set to `all`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`this.state`设置初始状态。最初，没有待办事项，过滤器设置为`all`：
- en: '[PRE24]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we define the `componentDidMount` lifecycle method, which is going to
    load todo items when the component first renders:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了`componentDidMount`生命周期方法，该方法将在组件首次渲染时加载待办事项：
- en: '[PRE25]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we are going to define the `loadTodos` method, which in our case, is
    simply going to set the state, as we are not going to connect this simple app
    to a backend. We are also going to call `this.filterTodos()` to update the `filteredTodos`
    array after fetching:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义`loadTodos`方法，在我们的例子中，它将简单地设置状态，因为我们不会将这个简单的应用连接到后端。我们还将调用`this.filterTodos()`来更新`filteredTodos`数组：
- en: '[PRE26]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We will define the `filterTodos` method later in this section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节稍后定义`filterTodos`方法。
- en: 'Next, we define the `addTodo` method, which creates a new item and adds it
    to the array:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了`addTodo`方法，该方法创建一个新项目并将其添加到数组中：
- en: '[PRE27]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To keep things simple, we are just using `Date.now()` to generate a unique id
    for each todo item.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了保持简单，我们只是使用`Date.now()`为每个待办事项生成一个唯一的ID。
- en: 'We now define a `toggleTodo` method, which uses the `map` function to find
    and modify a certain todo item:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在定义一个`toggleTodo`方法，它使用`map`函数查找并修改特定的待办事项：
- en: '[PRE28]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, define the `removeTodo` method, which uses the `filter` function to find
    and remove a certain todo item:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义`removeTodo`方法，它使用`filter`函数查找并删除特定的待办事项：
- en: '[PRE29]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, define a method to apply different filters to todo items, such as `active`,
    `completed` and `all`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个方法来应用不同的过滤器到待办事项，例如`active`、`completed`和`all`：
- en: '[PRE30]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can define the `filterTodos` method, which is going to call the `applyFilter`
    method and update the `filteredTodos` and the `filter` state:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义`filterTodos`方法，它将调用`applyFilter`方法并更新`filteredTodos`和`filter`状态：
- en: '[PRE31]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The **nullish coalescing** (`??`) operator is used to fall back to a different
    value when the value on the left hand side is `undefined` or `null`. Unlike the
    `||` operator, the `??` operator only triggers for `undefined`/`null` values,
    not for falsy values like `0`, `''`, or `false`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**空合并** (`??`) 运算符用于在左侧值是 `undefined` 或 `null` 时回退到不同的值。与 `||` 运算符不同，`??` 运算符仅针对
    `undefined`/`null` 值触发，而不是针对 `0`、`''''` 或 `false` 这样的假值。'
- en: We are using `filterTodos` to re-filter todos after adding/removing, as well
    as changing the filter. To allow for both functionalities to work properly, we
    need to check if the filter argument `filterArg` was passed. If not, we fall back
    to the current `filter` value from the `state` object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `filterTodos` 在添加/删除后以及更改过滤器时重新过滤待办事项。为了使这两种功能都能正常工作，我们需要检查是否传入了过滤器参数 `filterArg`。如果没有，我们将回退到
    `state` 对象中的当前 `filter` 值。
- en: 'Then, we adjust the `render` method and use the state to provide a value for
    the `StateContext`. We also pass certain methods down to the components:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调整 `render` 方法并使用状态为 `StateContext` 提供一个值。我们还向下传递某些方法到组件：
- en: '[PRE32]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we need to re-bind `this` to the class, so that we can pass the methods
    to our components without the `this` context changing. Adjust the `constructor`
    method by rebinding the `this` context of all methods, as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要重新绑定 `this` 到类，这样我们就可以在不改变 `this` 上下文的情况下将方法传递给我们的组件。通过以下方式调整 `constructor`
    方法，重新绑定所有方法中的 `this` 上下文：
- en: '[PRE33]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, the `App` component can dynamically fetch, add, toggle, remove and filter
    todo items. As we can see, when we use class components, we need to re-bind the
    `this` context of the handler functions to the class. Otherwise, we would get
    an error when we call the methods, because their `this` context is not bound to
    the class anymore and thus they cannot call methods such as `this.setState`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`App` 组件可以动态地获取、添加、切换、删除和过滤待办事项。正如我们所看到的，当我们使用类组件时，我们需要重新绑定处理函数的 `this` 上下文到类。否则，当我们调用方法时，会因为它们的
    `this` 上下文不再绑定到类而引发错误，因此它们无法调用如 `this.setState` 这样的方法。
- en: Making the AddTodo component dynamic
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使 `AddTodo` 组件动态化
- en: 'After making the `App` component dynamic, it is time to make all of our other
    components dynamic, too. We are going to start from the top, with the `AddTodo`
    component:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在使 `App` 组件动态化之后，现在是时候使我们的所有其他组件也动态化了。我们将从顶部开始，以 `AddTodo` 组件为例：
- en: 'Edit `src/AddTodo.jsx` and define a `constructor`, which sets the initial state
    for the input field:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/AddTodo.jsx` 并定义一个 `constructor`，它为输入字段设置初始状态：
- en: '[PRE34]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, define a method for handling changes in the input field:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个处理输入字段变化的方法：
- en: '[PRE35]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, define a method to handle submission of the form:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个处理表单提交的方法：
- en: '[PRE36]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we can assign the input value, as well as the input and submit handlers,
    to the relevant components. Additionally, we’ll disable the button when the input
    field is empty:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以将输入值以及输入和提交处理程序分配给相关组件。此外，当输入字段为空时，我们将禁用按钮：
- en: '[PRE37]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we need to adjust the constructor by re-binding the `this` context
    for all of the handler methods, as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要通过重新绑定所有处理方法中的 `this` 上下文来调整构造函数，如下所示：
- en: '[PRE38]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, the `AddTodo` component will show a disabled button as long as no text
    is entered. Once we enter some text and click the button, it will trigger the
    `addTodo` method from the `App` component.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只要没有输入文本，`AddTodo` 组件将显示一个禁用的按钮。一旦我们输入一些文本并点击按钮，它将触发 `App` 组件的 `addTodo`
    方法。
- en: Making the TodoList component dynamic
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使 `TodoList` 组件动态化
- en: 'The next component in our todo app is the `TodoList` component. Here, we just
    need to get the todo items from the `StateContext`. To do this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的待办事项应用中的下一个组件是 `TodoList` 组件。在这里，我们只需要从 `StateContext` 获取待办事项。为此：
- en: 'Edit `src/TodoList.jsx` and import the `StateContext`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/TodoList.jsx` 并导入 `StateContext`：
- en: '[PRE39]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, we set the `contextType` to the `StateContext`, which will allow us to
    use the context via `this.context`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将 `contextType` 设置为 `StateContext`，这将允许我们通过 `this.context` 使用上下文：
- en: '[PRE40]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With class components, if you want to use multiple contexts, you have to use
    the `StateContext.Consumer` component, as follows:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用类组件时，如果您想使用多个上下文，您必须使用 `StateContext.Consumer` 组件，如下所示：
- en: '[PRE41]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can imagine, using multiple contexts like this will result in a very
    deep component tree, and the code will be hard to read and refactor.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所想象，使用多个上下文将导致非常深的组件树，代码将难以阅读和重构。
- en: 'Now we can get the items from `this.context`, instead of statically defining
    them:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从 `this.context` 获取项目，而不是静态地定义它们：
- en: '[PRE42]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we pass all props down to the `TodoItem` component, so that we can
    use the `removeTodo` and `toggleTodo` methods there:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将所有props传递给`TodoItem`组件，这样我们就可以在那里使用`removeTodo`和`toggleTodo`方法：
- en: '[PRE43]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now the `TodoList` component gets the items from the `StateContext` instead
    of statically defining them. Next, let’s move on to making the `TodoItem` component
    dynamic.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`TodoList`组件从`StateContext`获取项目，而不是静态定义它们。接下来，让我们继续使`TodoItem`组件动态化。
- en: Making the TodoItem component dynamic
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使TodoItem组件动态化
- en: 'Now that we have passed on the `removeTodo` and `toggleTodo` methods as props
    to the `TodoItem` component, we can implement these features there and make the
    `TodoItem` component dynamic too:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将`removeTodo`和`toggleTodo`方法作为props传递给`TodoItem`组件，我们可以在那里实现这些功能，并使`TodoItem`组件也动态化：
- en: 'Edit `src/TodoItem.jsx` and define handler methods for the `toggleTodo` and
    `removeTodo` functions:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/TodoItem.jsx`，并为`toggleTodo`和`removeTodo`函数定义处理方法：
- en: '[PRE44]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, we assign the handler functions to the checkbox and button, respectively:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将处理函数分别分配给复选框和按钮：
- en: '[PRE45]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, we need to re-bind the `this` context for the handler methods. Define
    a new `constructor` method, as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要重新绑定处理方法的`this`上下文。定义一个新的`constructor`方法，如下所示：
- en: '[PRE46]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now the `TodoItem` component properly triggers the toggle and remove methods.
    Next, we are going to make the `TodoFilter` component dynamic.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`TodoItem`组件正确触发了切换和删除方法。接下来，我们将使`TodoFilter`组件动态化。
- en: Making the TodoFilter component dynamic
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使TodoFilter组件动态化
- en: 'Lastly, we are going to use the `filterTodos` method to dynamically filter
    our todo item list:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用`filterTodos`方法动态过滤待办事项列表：
- en: 'Edit `src/TodoFilter.jsx` and, in the `TodoFilter` class component, pass all
    props down to the `TodoFilterItem` component:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/TodoFilter.jsx`，在`TodoFilter`类组件中，将所有props传递给`TodoFilterItem`组件：
- en: '[PRE47]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the same file, add a `handleFilter` method to the `TodoFilterItem` class
    component:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，为`TodoFilterItem`类组件添加一个`handleFilter`方法：
- en: '[PRE48]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, get the `filter` prop, disable the button with the currently selected
    filter, and call `this.handleFilter` when the button is clicked:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，获取`filter`属性，禁用具有当前选定过滤器的按钮，并在按钮被点击时调用`this.handleFilter`：
- en: '[PRE49]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we define a `constructor` method for the `TodoFilterItem` class component
    and re-bind the `this` context of the handler function:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为`TodoFilterItem`类组件定义一个`constructor`方法，并重新绑定处理函数的`this`上下文：
- en: '[PRE50]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now the `TodoFilter` component triggers the filter handler function to change
    the filter. Our whole app is dynamic now, and we can use all of its functionalities!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`TodoFilter`组件触发过滤处理函数来更改过滤器。我们的整个应用现在是动态的，我们可以使用其所有功能！
- en: Starting the app
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动应用
- en: 'At this point, we have finished making all components dynamic and can start
    the app, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使所有组件动态化，可以开始应用，如下所示：
- en: '[PRE51]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Open the URL in a browser, try adding/toggling/removing/filtering todos, and
    you will see that everything works as expected!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开URL，尝试添加/切换/删除/过滤待办事项，你会看到一切按预期工作！
- en: '![Figure 13.4 – Showing only completed items in our todo app](img/B31327_13_04.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 在我们的待办事项应用中仅显示已完成的项目](img/B31327_13_04.png)'
- en: Figure 13.4 – Showing only completed items in our todo app
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 在我们的待办事项应用中仅显示已完成的项目
- en: '**Example code**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter13/Chapter13_1`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码可以在`Chapter13/Chapter13_1`文件夹中找到。请检查文件夹内的`README.md`文件，以获取设置和运行示例的说明。
- en: Now that our app works well with React class components, let’s use it to learn
    how to migrate an existing app to React Hooks.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用React类组件使我们的应用运行良好，让我们用它来学习如何将现有应用迁移到React Hooks。
- en: Migrating from React class components
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从React类组件迁移
- en: After setting up our example project with React class components, we are now
    going to migrate this project to React Hooks. We are going to show how to migrate
    side effects, such as fetching todos when the component mounts, as well as migrating
    the state management to a Hook based solution.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用React类组件设置好我们的示例项目后，我们现在将迁移此项目到React Hooks。我们将展示如何迁移副作用，例如组件挂载时获取待办事项，以及将状态管理迁移到基于Hook的解决方案。
- en: 'In this section, we are going to migrate the following components:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将迁移以下组件：
- en: '`TodoItem`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoItem`'
- en: '`TodoList`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoList`'
- en: '`TodoFilterItem`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoFilterItem`'
- en: '`TodoFilter`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoFilter`'
- en: '`AddTodo`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddTodo`'
- en: '`App`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App`'
- en: 'Before we do that, please create a new folder for the migrated project, as
    follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，请创建一个新的文件夹用于迁移项目，具体如下：
- en: 'Copy the `Chapter13_1` folder to a new `Chapter13_2` folder, as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Chapter13_1` 文件夹复制到新的 `Chapter13_2` 文件夹中，具体操作如下：
- en: '[PRE52]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Open the new `Chapter13_2` folder in VS Code.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的 `Chapter13_2` 文件夹。
- en: Now, we can get started migrating the components.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始迁移组件。
- en: Migrating the TodoItem component
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移 TodoItem 组件
- en: One of the simplest components to migrate is the `TodoItem` component. It does
    not use any state or side effects, so we can simply convert it to a function component.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的组件之一要迁移的是 `TodoItem` 组件。它不使用任何状态或副作用，因此我们可以简单地将其转换为函数组件。
- en: 'Let’s start migrating the `TodoItem` component now:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始迁移 `TodoItem` 组件：
- en: Edit `src/TodoItem.jsx` and *delete* all of the existing code.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/TodoItem.jsx` 并*删除*所有现有的代码。
- en: 'Now, we define a function component which accepts `title`, `completed`, `id`,
    `toggleTodo` and `removeTodo` props:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义一个接受 `title`、`completed`、`id`、`toggleTodo` 和 `removeTodo` 属性的函数组件：
- en: '[PRE53]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, we define two handler functions to toggle and remove todo items:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义两个处理函数来切换和删除待办事项：
- en: '[PRE54]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, we render the component:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们渲染组件：
- en: '[PRE55]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Try to keep your function components small, and combine them by creating new
    function components that use other function components (this pattern is called
    **composition**). It is always a good idea to have many small components, rather
    than one large component. They are much easier to maintain, reuse, and refactor.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量保持你的函数组件小巧，并通过创建使用其他函数组件的新函数组件（这种模式称为**组合**）来组合它们。拥有许多小组件总是一个好主意，而不是一个大组件。它们更容易维护、重用和重构。
- en: As you can see, function components do not require us to re-bind `this`, or
    to define constructors at all. Also, we do not need to destructure from `this.props`
    multiple times in multiple places. We can simply destructure all props in the
    function definition.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，函数组件不需要我们重新绑定 `this`，或者根本不需要定义构造函数。此外，我们不需要在多个地方多次从 `this.props` 中解构。我们可以在函数定义中简单地解构所有
    props。
- en: If you run the app now, you will see that it still works. React actually lets
    you combine function components with class components, so there is no need to
    migrate the whole codebase at once, you can migrate certain parts at a time. React
    class components can even render function components that use Hooks. The only
    limitation is that we cannot use Hooks in class components. Therefore, we need
    to migrate a whole component at a time.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你会看到它仍然可以工作。React 实际上允许你将函数组件与类组件组合，因此不需要一次性迁移整个代码库，你可以分批迁移某些部分。React
    类组件甚至可以渲染使用 Hooks 的函数组件。唯一的限制是我们不能在类组件中使用 Hooks。因此，我们需要一次迁移一个组件。
- en: Now, let’s move on to migrating the `TodoList` component.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续迁移 `TodoList` 组件。
- en: Migrating the TodoList component
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移 TodoList 组件
- en: The `TodoList` component renders multiple `TodoItem` components. Here, we used
    a context, which means that we can now use a Context Hook.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoList` 组件渲染多个 `TodoItem` 组件。在这里，我们使用了上下文，这意味着我们现在可以使用 Context Hook。'
- en: 'Let’s migrate the `TodoList` component now:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们迁移 `TodoList` 组件：
- en: Edit `src/TodoList.jsx` and *delete* all of the existing code.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/TodoList.jsx` 并*删除*所有现有的代码。
- en: 'Import the following:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下内容：
- en: '[PRE56]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Define a function component. In this case, we do not destructure the props,
    but simply get the whole object:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数组件。在这种情况下，我们不需要解构 props，而是简单地获取整个对象：
- en: '[PRE57]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, define the Context Hook:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义 Context Hook：
- en: '[PRE58]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, return the list of rendered items:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回渲染项的列表：
- en: '[PRE59]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As we can see, using contexts with Hooks is much more straightforward. We can
    simply call a function (the Context Hook), and use the return value. No magical
    assignment of `this.context`!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用 Hooks 与上下文一起使用要简单得多。我们只需调用一个函数（Context Hook），并使用返回值。没有神奇的 `this.context`
    赋值！
- en: Next, let’s migrate the TodoFilter component.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们迁移 TodoFilter 组件。
- en: Migrating the TodoFilter component
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移 TodoFilter 组件
- en: 'The `TodoFilter` component does not use any Hooks. However, we are going to
    replace the `TodoFilterItem` and `TodoFilter` class components with two function
    components – one for `TodoFilterItem`, and one for the `TodoFilter` component:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoFilter` 组件没有使用任何 Hooks。然而，我们将用两个函数组件替换 `TodoFilterItem` 和 `TodoFilter`
    类组件——一个用于 `TodoFilterItem`，另一个用于 `TodoFilter` 组件：'
- en: Edit `src/TodoFilter.jsx` and *delete* all of the existing code.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/TodoFilter.jsx` 并*删除*所有现有的代码。
- en: 'Define the `TodoFilterItem` component, as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `TodoFilterItem` 组件，具体如下：
- en: '[PRE60]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, define the `TodoFilter` component, as follows:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义 `TodoFilter` 组件，如下所示：
- en: '[PRE61]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As we can see, the `TodoFilter` component statically renders three `TodoFilterItem`
    components, which are used to toggle the filter between showing `all`, `active`
    or `completed` todo items. Next, let’s migrate the `AddTodo` component.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`TodoFilter` 组件静态渲染了三个 `TodoFilterItem` 组件，这些组件用于在显示 `所有`、`活动` 或 `完成`
    待办事项之间切换过滤。接下来，让我们迁移 `AddTodo` 组件。
- en: Migrating the AddTodo component
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移 AddTodo 组件
- en: For the `AddTodo` component, we are going to use a State Hook to handle the
    input field state.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `AddTodo` 组件，我们将使用 State Hook 来处理输入字段状态。
- en: 'Let’s migrate the `AddTodo` component now:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们迁移 `AddTodo` 组件：
- en: Edit `src/AddTodo.jsx` and *delete* all of the existing code.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/AddTodo.jsx` 并 *删除* 所有的现有代码。
- en: 'Import the `useState` function:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `useState` 函数：
- en: '[PRE62]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Define the `AddTodo` component, which accepts an `addTodo` function as prop:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `AddTodo` 组件，该组件接受一个 `addTodo` 函数作为属性：
- en: '[PRE63]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, define a State Hook for the input field state:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个用于输入字段状态的 State Hook：
- en: '[PRE64]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, define the handler functions:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义处理函数：
- en: '[PRE65]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, render the input field and button:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，渲染输入字段和按钮：
- en: '[PRE66]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As we can see, using the State Hook makes state management much simpler. We
    can define a separate value and setter function for each state value, instead
    of having to deal with a single `state` object. Additionally, we do not need to
    destructure from `this.state` all the time. As a result, our code is much more
    clean and concise.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用 State Hook 使得状态管理变得更加简单。我们可以为每个状态值定义一个单独的值和设置函数，而不是必须处理一个单一的 `state`
    对象。此外，我们不必始终从 `this.state` 中解构。因此，我们的代码更加整洁和简洁。
- en: Now, let’s move on to migrating the App component.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续迁移 App 组件。
- en: Migrating the state management and App component
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移状态管理和 App 组件
- en: At last, all that is left to do is migrate the `App` component. Then, our whole
    todo app will be migrated to React Hooks. Here, we are going to use a Reducer
    Hook to manage the state, an Effect Hook to fetch todos when the component mounts,
    and a Memo Hook to store the filtered todos list.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，剩下要做的就是迁移 `App` 组件。然后，我们的整个待办事项应用将迁移到 React Hooks。在这里，我们将使用 Reducer Hook
    来管理状态，使用 Effect Hook 在组件挂载时获取待办事项，并使用 Memo Hook 存储过滤后的待办事项列表。
- en: 'In this section we are going to:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将：
- en: Define the actions
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义动作
- en: Define the reducers
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义计算器
- en: Migrate the `App` component
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移 App 组件
- en: Let’s get started.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Defining the actions
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义动作
- en: 'Our app is going to accept five actions, let’s first take a moment to think
    about what they will look like:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用将接受五个动作，让我们先花点时间想想它们会是什么样子：
- en: '`LOAD_TODOS`: To load a new list of todo items'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOAD_TODOS`：用于加载新的待办事项列表'
- en: '[PRE67]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '`ADD_TODO`: To insert a new todo item'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD_TODO`：用于插入一个新的待办事项'
- en: '[PRE68]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`TOGGLE_TODO`: To toggle the completed value of a todo item'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TOGGLE_TODO`：用于切换待办事项的完成值'
- en: '[PRE69]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`REMOVE_TODO`: To remove a todo item'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REMOVE_TODO`：用于删除待办事项'
- en: '[PRE70]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`FILTER_TODOS`: To filter todo items'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILTER_TODOS`：用于过滤待办事项'
- en: '[PRE71]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Defining the reducers
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义计算器
- en: 'Now we are going to define the reducers for our state. We are going to need
    one app reducer and two sub-reducers: one for todos and one for the filter.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将定义我们状态的计算器。我们需要一个应用计算器和两个子计算器：一个用于待办事项，一个用于过滤。
- en: Defining the filter reducer
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义过滤计算器
- en: 'We are going to start by defining the reducer for the `filter` value:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义用于 `filter` 值的计算器：
- en: Create a new `src/reducers.js` file.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/reducers.js` 文件。
- en: 'In this file, define a function for the `filterReducer`, which is going to
    handle the `FILTER_TODOS` action and set the filter value accordingly:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，定义一个用于 `filterReducer` 的函数，该函数将处理 `FILTER_TODOS` 动作并相应地设置过滤值：
- en: '[PRE72]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Next, let’s move on to the `todosReducer` function.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续到 `todosReducer` 函数。
- en: Defining the todos reducer
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义 todos 减法器
- en: 'Now, we are going to define the `todosReducer` function for the todo items.
    Here, we are going to handle the `LOAD_TODOS`, `ADD_TODO`, `TOGGLE_TODO`, and
    `REMOVE_TODO` actions:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义用于待办事项的 `todosReducer` 函数。在这里，我们将处理 `LOAD_TODOS`、`ADD_TODO`、`TOGGLE_TODO`
    和 `REMOVE_TODO` 动作：
- en: 'Edit `src/reducers.js` and define a new function, which is going to handle
    these actions:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/reducers.js` 并定义一个新的函数，该函数将处理这些动作：
- en: '[PRE73]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'For the `LOAD_TODOS` action, we simply replace the current state with the new
    `todos` array:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `LOAD_TODOS` 动作，我们只需用新的 `todos` 数组替换当前状态：
- en: '[PRE74]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'For the `ADD_TODO` action, we are going to insert a new item at the beginning
    of the current state array:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `ADD_TODO` 动作，我们将在新状态数组中插入一个新的条目：
- en: '[PRE75]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'For the `TOGGLE_TODO` action, we are going to use the `map` function to update
    a single todo item:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'For the `REMOVE_TODO` action, we are going to use the `filter` function to
    remove a single todo item:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'By default (for all other actions), we simply return the current state:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Now we just need to define the `appReducer`, which will combine the other two
    reducers into one.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Defining the app reducer
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To handle our todo app state in one Reducer Hook, we are going to combine the
    two reducers we created into a single `appReducer` function. To do that:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/reducers.js` and define and export a new function for the app reducer:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In this function, we return an object with the values from the other reducers.
    We simply pass the sub-state and action to the other reducers:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Now that we have defined a reducer to manage the app state, we can start migrating
    the `App` component.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the App component
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s get started migrating the `App` component now:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Edit `src/App.jsx` and *delete* all of the existing code.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the following:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'First, we define the function component, which is not going to accept any props:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, we define a Reducer Hook using the `appReducer` function:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Let’s also destructure the `state` object to make it easier for us to access
    later:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Then, we implement the filter mechanism using a Memo Hook. This is one of the
    few cases where using the Memo Hook is actually necessary. Otherwise, our component
    would re-render too often, causing an infinite loop. We can use the Memo Hook
    to ensure that a change to `filteredTodos` is only triggered when the `todos`
    or `filter` state changes, as follows:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, we define an Effect Hook, which is going to fetch todos from our mock
    API and then dispatch a `LOAD_TODOS` action:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The function inside an Effect Hook needs to be synchronous, so we are using
    a workaround to get the async/await construct to work here. When not caring about
    waiting for an async function to complete, it is best practice to prefix the function
    call with `void` to show that we intentionally did not `await` it.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define various functions that are going to dispatch actions and change
    the state of our app:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Finally, we render all the components that are needed for our todo app:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now that our app is fully migrated, we can start the dev server and verify
    that everything still works:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: As we can see, using a Reducer Hook to handle complex state changes makes our
    code much more concise and easier to maintain. Our app is now fully migrated to
    Hooks, and it still works exactly the same way as before!
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Another possibility to further refactor and improve the code would be to store
    the state and dispatch function in a context, and then define custom Hooks for
    handling the various functions of our todo app. However, in this example, we wanted
    to keep it as close to the original class component code as possible, so any further
    refactoring is left as an exercise for the reader.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '**Example code**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this section can be found in the `Chapter13/Chapter13_2`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s wrap up the book by discussing the trade-offs of using React class
    components vs React Hooks.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Trade-offs of React class components vs React Hooks
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have finished our migration from class components to Hooks, let
    us revise and sum up what we have learned.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Function components with Hooks are easier to understand and test, since they
    are simply JavaScript functions instead of complex React constructs. We were also
    able to refactor the state-changing logic into a separate `reducers.js` file,
    thus decoupling it from the `App` component, and making it easier to refactor
    and test. We can safely say that separating concerns between app logic and components
    significantly improved the maintainability of our project.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s recap the advantages we gained by refactoring our app. With function
    components and Hooks, the following points do not need to be taken into consideration
    anymore:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: No need to deal with constructors.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No confusing `this` context (`this` re-binding).
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need to destructure the same values over and over again.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No magic when dealing with contexts, props, and state.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need to define `componentDidMount` and `componentDidUpdate` if we want to
    re-fetch data when the props change.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, function components have the following advantages:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Encourage making small and simple components.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are easier to refactor.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are easier to test.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Require less code.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are easier to understand for beginners.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are more declarative.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Server Components (RSCs) can only be function components.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, class components can be fine in the following situations:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: When sticking to certain conventions.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using arrow functions to avoid `this` re-binding.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possibly easier to understand for the team, because of existing knowledge.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many projects still use classes. For dependencies, this is not such a problem,
    as they can still be easily used in function components. However, in legacy codebases,
    you may still need to work with class components.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, it is a matter of preference, but Hooks do have many advantages
    over classes! If you are starting a new project, definitely go for Hooks. If you
    are working on an existing project, consider whether it might make sense to refactor
    certain components to Hook-based components in order to make them simpler.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: However, you should not immediately port all your projects to Hooks, as refactoring
    can always introduce new bugs. The best way to adopt Hooks is to slowly but surely
    replace old class components with Hook-based function components when appropriate.
    For example, if you are already refactoring a component, you can refactor it to
    use Hooks!
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first built a todo app using React class components. We
    started by designing the app structure, then implemented static components, and
    finally, we made them dynamic. Next, we learned how to migrate an existing project
    using class components, to function components using Hooks. Finally, we learned
    about the trade-offs of class components, when class components or Hooks should
    be used, and how one should go about migrating an existing project to Hooks.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen in practice how React class components differ to function components
    with Hooks. Hooks make our code much more concise and easier to read and maintain.
    We have also learned that we should gradually migrate our components from class
    components to function components with Hooks—there is no need to immediately migrate
    the whole application.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: This chapter marks the end of this book. In this book, we started out with a
    motivation to use Hooks. We learned that there are common problems in React apps,
    which could not be easily solved without Hooks. Then, we created our first component
    using Hooks, and compared it to the class-based solution. Next, we learned about
    the State Hook, which is the most ubiquitous of them all. We also learned about
    solving common problems with Hooks, such as conditional Hooks, and Hooks in loops.
    We gained a deep understanding of how Hooks work internally and what their limitations
    are.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: After learning about the State Hook in depth, we developed a small blog app
    using Hooks. We then learned about Reducer Hooks, Effect Hooks, and Context Hooks,
    in order to be able to implement more features in our app. Next, we learned how
    to use TanStack Query Hooks and React Suspense for data fetching. Then, we used
    Hooks to handle forms. Next, we used React Router to implement routes in our blog
    app, and we learned how Hooks can make dynamic routing much easier. We gained
    experience developing a real-world frontend application with Hooks.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about the various built-in Hooks provided by React, even the
    advanced ones. Then, we learned about various Hooks that are provided by the community,
    which make dealing with application state and various use cases much easier. We
    gained an in-depth understanding of all the Hooks that React provides, and where
    to find more Hooks.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Towards the end of the book, we learned about the rules of Hooks, how to create
    our own custom Hooks and how to write tests for them using Vitest. We also learned
    how to migrate an existing class-component based app to a Hook-based solution.
    We thus gained an understanding on how to effectively refactor React applications
    with Hooks.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned about Hooks in depth, you are ready to use them in
    your applications! You have also learned how to migrate existing projects to Hooks,
    so you can start doing that now. I hope you enjoyed learning about React Hooks,
    and that you are looking forward to implementing Hooks in your applications! I
    am sure that using Hooks will make coding much more enjoyable for you, just like
    they did for me.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To recap what we have learned in this chapter, try to answer the following
    questions:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: How are React class components defined?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do we need to call when using a constructor with class components? Why?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we set the initial state with class components?
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we change the state with class components?
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we need to re-bind the `this` context with class component methods?
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we re-bind the `this` context?
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we use React Context with class components?
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What can we replace state management with when migrating to Hooks?
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the trade-offs of using Hooks versus class components?
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When, and how, should an existing project be migrated to Hooks?
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are interested in more information about the concepts that we have learned
    in this chapter, take a look at the following links:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes in JavaScript: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'React class components: [https://www.robinwieruch.de/react-component-types/#react-class-components](https://www.robinwieruch.de/react-component-types/#react-class-components)'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Migrating class components to functions: [https://react.dev/reference/react/Component#migrating-a-simple-component-from-a-class-to-a-function](https://react.dev/reference/react/Component#migrating-a-simple-component-from-a-class-to-a-function)'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/wnXT0](Chapter_13.xhtml)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_%283%29.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
- en: '![](img/New_Packt_Logo1.png)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
- en: '[www.packtpub.com](https://www.packtpub.com)'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe to our online digital library for full access to over 7,000 books
    and videos, as well as industry leading tools to help you plan your personal development
    and advance your career. For more information, please visit our website.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Why subscribe?
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spend less time learning and more time coding with practical eBooks and Videos
    from over 4,000 industry professionals
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve your learning with Skill Plans built especially for you
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a free eBook or video every month
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully searchable for easy access to vital information
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy and paste, print, and bookmark content
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At [www.packtpub.com](https://www.packtpub.com), you can also read a collection
    of free technical articles, sign up for a range of free newsletters, and receive
    exclusive discounts and offers on Packt books and eBooks.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Other Books You May Enjoy
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you enjoyed this book, you may be interested in these other books by Packt:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/9781836202271.jpg)](https://www.packtpub.com/en-us/product/react-key-concepts-9781836202264)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '**React Key Concepts, Second Edition**'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Maximilian Schwarzmüller
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-83620-227-1'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Build modern, user-friendly, and reactive web apps
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create components and utilize props to pass data between them
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle events, perform state updates, and manage conditional content
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add styles dynamically and conditionally for modern user interfaces
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use advanced state management techniques such as React’s Context API
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize React Router to render different pages for different URLs
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand key best practices and optimization opportunities
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about React Server Components and Server Actions
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![](img/9781837637959.jpg)](https://www.packtpub.com/en-us/product/modern-full-stack-react-projects-9781837632756)'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '**Modern Full-Stack React Projects**'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Daniel Bugl
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-83763-795-9'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Implement a backend using Express and MongoDB, and unit-test it with Jest
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy full-stack web apps using Docker, set up CI/CD and end-to-end tests using
    Playwright
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add authentication using JSON Web Tokens (JWT)
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a GraphQL backend and integrate it with a frontend using Apollo Client
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a chat app based on event-driven architecture using Socket.IO
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facilitate Search Engine Optimization (SEO) and implement server-side rendering
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Next.js, an enterprise-ready full-stack framework, with React Server Components
    and Server Actions
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packt is searching for authors like you
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re interested in becoming an author for Packt, please visit [authors.packtpub.com](https://www.authors.packtpub.com)
    and apply today. We have worked with thousands of developers and tech professionals,
    just like you, to help them share their insight with the global tech community.
    You can make a general application, apply for a specific hot topic that we are
    recruiting an author for, or submit your own idea.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Share your thoughts
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you’ve finished *Learn React Hooks*, *Second Edition*, we’d love to hear
    your thoughts! If you purchased the book from Amazon, please [click here to go
    straight to the Amazon review pag](https://packt.link/r/1836209177)e for this
    book and share your feedback or leave a review on the site that you purchased
    it from.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Your review is important to us and the tech community and will help us make
    sure we’re delivering excellent quality content.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
