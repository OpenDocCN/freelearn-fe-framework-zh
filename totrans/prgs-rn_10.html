<html><head></head><body>
		<div id="_idContainer051">
			<h1 id="_idParaDest-157" class="chapter-number"><a id="_idTextAnchor347"/>10</h1>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor348"/>Structuring Large-Scale, Multi-Platform Projects</h1>
			<p><a id="_idTextAnchor349"/>I<a id="_idTextAnchor350"/> wholeheartedly believe that the structure of a software project is one of the key factors in deciding success or failure. This includes the application architecture, as well as the development process and the whole project organization.</p>
			<p>The bigger the project is, the more developers that work on the project, and the longer a project runs, the more important it is to have a good project structure. But small projects can also fail because of a bad structure. So, most of this chapter is also applicable to smaller projects.</p>
			<p>The project structure is especially important when using React Native to develop an application for multiple platforms, not only for iOS and Android. Different platforms have different needs and bring different user expectations. The best example to showcase this is the difference between iOS and Android and the web.</p>
			<p>As already mentioned in <a href="B16694_04.xhtml#_idTextAnchor079"><em class="italic">Chapter 4</em></a>, <em class="italic">Styling, Storage, and Navigation in React Native</em>, the concept of navigation in a mobile app and a web app is completely different. This is something you have to think about when planning the structure of your project.</p>
			<p>The problem with investing in good architecture and a good project structure is that it always creates some overhead in the beginning. The following figure shows the dilemma:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B16694_10_01.jpg" alt="Figure 10.1 – Coding productivity reduces when the project grows over time&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Coding productivity reduces when the project grows over time</p>
			<p>If you don’t invest in your architecture in the beginning, you will start with higher productivity. If you invest in your architecture, you have to think about what should be achieved, in which direction the project could potentially develop, and what usage, team size, and requirements you will have when your project reaches maximum success.</p>
			<p>These considerations take some time, and the implementation and execution of standardized processes may take even more time. It’s always faster to just download a random template and start coding. But as stated before, it will pay off in the end, because with good application architecture and a good project structure, you will end up with software that’s easy to maintain, test, and develop.</p>
			<p>This is why you will learn about the following things in this chapter:</p>
			<ul>
				<li>Setting up an app architecture that works for large-scale enterprise projects</li>
				<li>Using React Native to deploy to different platforms</li>
				<li>Reusing code with your own libraries</li>
			</ul>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor351"/>Technical requirements</h1>
			<p>To be able to run the code in this chapter, you have to set up the following things:</p>
			<ul>
				<li>A working React Native environment (<a href="https://bit.ly/prn-setup-rn">bit.ly/prn-setup-rn</a> – React Native CLI Quickstart).</li>
				<li>You can find the example project in this repository: <a href="https://bit.ly/prn-videoexample">https://bit.ly/prn-videoexample</a>.</li>
				<li>While most of this chapter should also work on Windows, I would recommend working on a Mac.</li>
				<li>This chapter contains some native code. You should have basic knowledge of Java or Kotlin and Objective-C or Swift for that.</li>
			</ul>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor352"/>Setting up an app architecture that works for large-scale enterprise projects</h1>
			<p>When we are talking<a id="_idIndexMarker576"/> about large-scale projects<a id="_idIndexMarker577"/> and how to set up a suitable app architecture, it makes sense to look at what’s different in these large-scale projects compared to small-team or even single-developer projects.</p>
			<p>The following points are the most important ones:</p>
			<ul>
				<li><strong class="bold">The project team is very big</strong>: In large-scale projects, you usually have a big team with lots of developers. Often, these developers are scattered all over the world, which means they work in different time zones, have different first languages, and have completely different cultural backgrounds. That said, it is important to have a clear structure and clear responsibilities.<a id="_idTextAnchor353"/> <a id="_idTextAnchor354"/>Otherwise, your project will fail.</li>
				<li><strong class="bold">Multiple developers will work on the same part of the application</strong>: At the latest stage when a deadline is approaching and a feature has to be finished, multiple developers will work on the same feature and the same part of the application. This means you should think about how to structure your code so that this is possible without having conflicts all the time.</li>
				<li><strong class="bold">Every error will be found by users</strong>: In small projects with only a few users, it’s likely that a lot of errors will never be found. In large-scale applications with a lot of users, it is nearly impossible that errors will remain unrevealed. This means you have to put in a lot more effort to find the errors yourself before releasing your application to the public.</li>
				<li><strong class="bold">The code has to be tested programmatically</strong>: The larger the project is, and the longer a project runs, the more important it is to programmatically test your code. At some point, it is impossible to handle all testing manually. This means you must have an app architecture that supports this automated testing very well.</li>
				<li><strong class="bold">The code base will become very large</strong>: As the term large-scale project already says, the project<a id="_idIndexMarker578"/> and its code base will become<a id="_idIndexMarker579"/> very large. This means you must provide a structure that makes it as easy as possible for new developers to understand what’s going on in the project.</li>
			</ul>
			<p>With these points in mind, we’ll try to find some architectural approaches to support all of this.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor355"/>Adapting our example project structure</h2>
			<p>The most important thing when the project<a id="_idIndexMarker580"/> grows is decomposition. This means you should try to split your components into small, meaningful segments wherever possible.</p>
			<p>When we look at the project structure of our example project, we have already done a good job of decomposing our application, and the architecture we chose works fine for our use case. It already contains some things I would recommend keeping, even in large-scale projects. These are the following:</p>
			<ul>
				<li><strong class="bold">Using services</strong>: Every API, SDK, or third-party connector should be wrapped in your own service. That enables you to change SDKs or even services and partners with minimal effort.</li>
				<li><strong class="bold">The separation between components and views</strong>: Reusable components and navigable views should be kept in separate folders. This makes it easier for new developers to find the views they are working on.</li>
			</ul>
			<p>However, this approach also brings some problems with it, especially when the code base grows and multiple developers work on it:</p>
			<ul>
				<li>Components and views are hard to test programmatically</li>
				<li>The component directory will grow really fast and become really big</li>
				<li>Single features will be hard to find and are scattered over the whole code base</li>
				<li>The code base as a whole will get quite confusing</li>
				<li>Multiple developers will have to touch the same files at the same time a lot</li>
			</ul>
			<p>So, we’ll make some adaptations<a id="_idIndexMarker581"/> to our approach. First, we’ll take care of the component level. So far, we write our component with its business logic, UI, style, and types in one file. This will change now. We’ll split our components into the following:</p>
			<ul>
				<li><strong class="source-inline">index.tsx</strong>: The <strong class="source-inline">index</strong> file contains the business logic of the component such as data fetching, as well as the connection to the global application state. It only renders the following <strong class="source-inline">.view</strong> component.</li>
				<li><strong class="source-inline">&lt;component&gt;.view.tsx</strong>: The <strong class="source-inline">view</strong> file contains the UI. It doesn’t hold its own state nor does it connect directly to the global application state. It only renders the props it gets from the <strong class="source-inline">index</strong> file.</li>
				<li><strong class="source-inline">&lt;component&gt;.styles.tsx</strong>: The <strong class="source-inline">styles</strong> file contains the React Native StyleSheet or the styled-components, depending on which approach you chose.</li>
				<li><strong class="source-inline">&lt;component&gt;.types.tsx</strong>: The <strong class="source-inline">types</strong> file provides the data type for props and the state of the <strong class="source-inline">index</strong> and <strong class="source-inline">view</strong> files.</li>
			</ul>
			<p>With this separation, we enable two things. First, it is much easier to have one developer work on the business logic and one on the UI, without creating merge conflicts or other problems. Second, our components now have much better support for automated testing.</p>
			<p>We can use any component<a id="_idIndexMarker582"/> testing framework to render and test the views without having to mock our global state or our component state. And in addition to that, it’s much easier to integrate tools such as Storybook with this approach.</p>
			<p>To see that approach in action, you can have a look at the GitHub repository, choose the <strong class="source-inline">chapter-10-split-home-view</strong> tag, and check out the <strong class="source-inline">views/home</strong> folder.</p>
			<p class="callout-heading">Hint</p>
			<p class="callout">To ensure that everyone sticks to this pattern and to make it simpler to create new views and components, you can use file generators. These are small scripts that use a template and typically a component name to create the structure you want to have. You can see an example in the GitHub repository. Choose the <strong class="source-inline">chapter-10-generator</strong> tag and have a look at the <strong class="source-inline">util</strong> folder. You can use the generator with <strong class="source-inline">npm run generate &lt;name&gt;</strong> to generate a new view.</p>
			<p>After this change on the component level, we’ll take a step back and look at the whole project again. The second change I would recommend when your project grows is to group your views and components by features. This makes it much easier to understand the whole project structure and navigate through the code.</p>
			<p>I must admit that this depends on personal preferences and some people also like the clear separation between components and views even in large-scale projects, but I prefer the feature approach. This approach works as shown in the following figure:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B16694_10_02.jpg" alt="Figure 10.2 – A React Native feature-grouped architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – A React Native feature-grouped architecture</p>
			<p>This approach groups the application by features. It also has a component folder, which contains very basic general components such as buttons, lists, and avatars – basically, things that are used in every feature of your app to provide a consistent user experience. But every feature also has its own component folder where you can put components that you created only for this feature. There is also a modification of this approach, where you put multiple views in one feature.</p>
			<p>From my personal experience, I can say that this feature approach makes the code base very clearly structured, and it makes it easier to find what you are searching for. On the other hand, you’ll always have components where you are unsure whether you have to put them into the general components or not.</p>
			<p>In the end, you’ll have to find your own approach to how you want to structure your application. But in this section, you learned about the most important things you have to pay attention to in order to create a structure that works even when your project scales.</p>
			<p>Now that you have learned<a id="_idIndexMarker583"/> how to structure a React Native project in general, we’ll go a step further and focus on going multi-platform.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor356"/>Using React Native to deploy to different platforms</h1>
			<p>In this section, you’ll learn how<a id="_idIndexMarker584"/> to set up your React Native project to be able to support multiple platforms. Since it is the most common use case, we’ll focus a lot on the web here, but the tips and approaches of these sections are also applicable to other platforms such as desktops and TVs.</p>
			<p>When creating an application for multiple platforms, there are always two goals. First, you want to support as many platform-specific features as possible and want to give users the look and feel they are used to on this platform. Second, you try to have as much shared code as possible because this makes it easier to maintain and develop your application.</p>
			<p>At first sight, these goals seem to be concurrent but there are intelligent ways to get the best of both worlds. Let’s start with the simplest approach.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor357"/>Using react-native-web to create a clone for web</h2>
			<p>When creating your application<a id="_idIndexMarker585"/> with React Native, you can use a library<a id="_idIndexMarker586"/> called <strong class="source-inline">react-native-web</strong> to run your React Native app on the web.</p>
			<p>Before we start, you have to understand what <strong class="source-inline">react-native-web</strong> does. Basically, it maps all React Native components to HTML components. For example, a <strong class="source-inline">&lt;View/&gt;</strong> component will get <strong class="source-inline">&lt;div/&gt;</strong>. It also maps the native API calls of React Native to use the browser APIs wherever available. This means you’ll get a plain React application for the web.</p>
			<p>While <strong class="source-inline">react-native-web</strong> is a great library, it is not that easy to get started with it because you have to set up a separate build process to use it. This build process will create a standalone React web application. Like every React web application, it needs a bundler to create optimized browser-readable JavaScript code. A very popular solution is Webpack, which we will use for our web app as well. Also, every web application needs an entry point. In most cases, this is an <strong class="source-inline">index.html</strong> file, which then loads the JavaScript bundle that contains the React application. So, we’ll have to add this to our project.</p>
			<p>The whole process of setting up web support is described in a very detailed manner in the <strong class="source-inline">react-native-web</strong> documentation (which you can see here: https://bit.ly/prn-rn-web), but at the time of writing, this documentation is missing TypeScript support.</p>
			<p>So, I’ll describe the most important<a id="_idIndexMarker587"/> thing while we set up basic web support<a id="_idIndexMarker588"/> for our example application. You can find the complete working setup in the GitHub repository when choosing the <strong class="source-inline">chapter-10-web</strong> tag.</p>
			<h3>Installing react-native-web</h3>
			<p>We’ll start<a id="_idIndexMarker589"/> with adding <strong class="source-inline">react-native-web</strong> and <strong class="source-inline">react-dom</strong> to our project. Please use the correct version of <strong class="source-inline">react-dom</strong>. Since we are using React 17 in our React Native app, we’ll have to use <strong class="source-inline">react-dom@17</strong>. These libraries are necessary to create the React app. The installation can be done via <strong class="source-inline">npm</strong>:</p>
			<p class="source-code">npm install react-dom@17 react-native-web</p>
			<p>Otherwise, it can be don<a id="_idTextAnchor358"/>e<a id="_idTextAnchor359"/> via <strong class="source-inline">yarn</strong>:</p>
			<p class="source-code">yarn add react-dom@17 react-native-web</p>
			<p>Now that we have installed <strong class="source-inline">react-native-web</strong>, we’ll need to handle the build process and the development environment for the web.</p>
			<h3>Installing webpack</h3>
			<p>To do so, we’ll add Webpack, the corresponding<a id="_idIndexMarker590"/> CLI, and a Webpack extension called <strong class="source-inline">webpack-dev-server</strong>. This extension provides a built-in development server that supports live reloading while you develop your application.</p>
			<p>The installation of these <strong class="source-inline">npm</strong> libraries can be done with the following <a id="_idTextAnchor360"/><strong class="source-inline">n<a id="_idTextAnchor361"/>pm</strong> command:</p>
			<p class="source-code">npm install –saveDev webpack webpack-cli webpack-dev-server</p>
			<p>Otherwise, you can use a <strong class="source-inline">y<a id="_idTextAnchor362"/>a<a id="_idTextAnchor363"/>rn</strong> command:</p>
			<p class="source-code">yarn add --dev webpack webpack-cli webpack-dev-server</p>
			<p>In addition to this basic Webpack setup, we’ll also install two loaders. Loaders are a core concept of Webpack. They enable you to preprocess files and decide how they should be used in your bundle. We’ll make use of the following loaders:</p>
			<ul>
				<li><strong class="source-inline">ts-loader</strong>: This is a loader that preprocesses our TypeScript files and converts them to browser-readable JavaScript</li>
				<li><strong class="source-inline">file-loader</strong>: This loader copies our asset binaries such as images in our final bundle</li>
			</ul>
			<p>The last thing we need<a id="_idIndexMarker591"/> for our web build process to work is <strong class="source-inline">html-webpack-plugin</strong>. This plugin creates our entry point. It writes an <strong class="source-inline">index.html</strong> by loading an HTML template and adding the created JavaScript bundle.</p>
			<p>These additions can be installed with the following <strong class="source-inline">npm</strong> command:</p>
			<p class="source-code">npm install –saveDev file-loader ts-loader html-webpack-plugin</p>
			<p>Otherwise, install with the following <strong class="source-inline">yarn</strong> command:</p>
			<p class="source-code">yarn add --dev file-loader ts-loader html-webpack-plugin</p>
			<p>Now that we have installed all tools, we have to configure our project.</p>
			<h3>Configuring the React Native project to work for web</h3>
			<p>First, let’s create a JavaScript<a id="_idIndexMarker592"/> entry point for our application. To do so, we’ll create <strong class="source-inline">index.web.js</strong> in the root folder of the application. This contains the following code.</p>
			<pre class="source-code">
AppRegistry.registerComponent(appNam<a id="_idTextAnchor364"/>e<a id="_idTextAnchor365"/>, () =&gt; App);
AppRegistry.runApplication(appName, {
  initialProps: {},
  rootTag: document.getElementById('movie-root'),
});</pre>
			<p>We use React Native <strong class="source-inline">AppRegistry</strong> to load our <strong class="source-inline">&lt;App /&gt;</strong> component via the <strong class="source-inline">registerComponent</strong> function and then run our application with <strong class="source-inline">runApplication</strong>.</p>
			<p><strong class="source-inline">runApplication</strong> needs an HTML node as <strong class="source-inline">rootTag</strong> for the web. This HTML node will be replaced with the React application during <strong class="source-inline">runApplication</strong>. In our case, we’ll get the element with the <strong class="source-inline">movie-root</strong> ID from the HTML document.</p>
			<p>Next, we’ll create a <strong class="source-inline">web/</strong> folder in the <strong class="source-inline">root</strong> folder of our project. In this folder, we’ll put an <strong class="source-inline">index.html</strong> template<a id="_idIndexMarker593"/> with the following content (please refer to the GitHub repository for the complete file):</p>
			<pre class="source-code">
  &lt;head&gt;
    &lt;title&gt;
      Movie Application
    &lt;/title&gt;
    &lt;style&gt;
        html, body { height: 100%; }
        body { overflow: hidden; }
        #movie-root { display:flex; height:100%; }
      &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="movie-root"&gt;&lt;/div&gt;
  &lt;/body&gt;</pre>
			<p>In the head of the document, we define a title and some styles. The styles are important for the <strong class="source-inline">react-native-web</strong> application to show. The body only contains an empty <strong class="source-inline">&lt;div /&gt;</strong> with the <strong class="source-inline">#movie-root</strong> ID. This is the container we use in our JavaScript entry point.</p>
			<p>Next, we’ll have to configure our Webpack builder. To do so, please create <strong class="source-inline">webpack.config.js</strong> in the <strong class="source-inline">web/</strong> folder. The following code snippet shows the most important configurations. For the complete file, please look at the GitHub repository:</p>
			<pre class="source-code">
const rootDir = path.join(__dirname, '..');
module.exports = {
  entry: {
    app: path.join(rootDir, './index.web.ts'),
  },
  output: {
    path: path.resolve(rootDir, 'dist'),
    filename: 'app-[hash].bundle.js',
  },
  module: {
    rules: [{
        test: /\.(tsx|ts|jsx|js)$/,
        exclude: /node_modules/,
        loader: 'ts-loader'
 }]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.join(__dirname, './index.html'),
    })
  ],
  resolve: {
    extensions: [
      '.web.tsx',<a id="_idTextAnchor366"/>'<a id="_idTextAnchor367"/>.web.ts','.tsx','.ts','.js'
    ],
    alias: Object.assign({
      'react-native$': 'react-native-web',
    }),
  },
};</pre>
			<p>Let’s work through this configuration<a id="_idIndexMarker594"/> from top to bottom. First, we defined our JavaScript entry point. Here, we put the <strong class="source-inline">index.web.js</strong> file we just created. Then, we defined our output. In this case, it’s the <strong class="source-inline">dist/</strong> directory and a JS bundle with a hash value in the name to ensure that we have new filenames with every new build to prevent browser caching issues.</p>
			<p>In the <strong class="source-inline">module</strong> section, we can define rules for which loaders should be used to preprocess which files. We use a Regex to test the filenames against and define loaders for all matching files. In this example, we use <strong class="source-inline">ts-loader</strong> for all files that include <strong class="source-inline">.tsx</strong>, <strong class="source-inline">.ts</strong>, <strong class="source-inline">.jsx</strong>, or <strong class="source-inline">.js</strong>, except everything in the <strong class="source-inline">node_modules</strong> folder.</p>
			<p>In the next section of the file, we defined which plugins we’ll use. In our case, it’s only <strong class="source-inline">HTMLWebpackPlugin</strong> to create our entry point <strong class="source-inline">index.html</strong> from our template HTML file. The last part of the <strong class="source-inline">config</strong> file is the <strong class="source-inline">resolve</strong> section. Here is where the magic of the transformation of a React Native to a plain React web application is happening.</p>
			<p>By creating the <strong class="source-inline">react-native-web</strong> alias for <strong class="source-inline">react-native<a id="_idTextAnchor368"/></strong>,<a id="_idTextAnchor369"/> we replace all occurrences of <strong class="source-inline">react-native</strong> with <strong class="source-inline">react-native-web</strong>. This means all imports that were fetched from <strong class="source-inline">react-native</strong> are now fetched from <strong class="source-inline">react-native-web</strong>.</p>
			<p>Now that our build process for the web application works, we’ll have to make some small adaptations in our TypeScript setup:</p>
			<pre class="source-code">
"lib": ["es2017", "dom"],
"jsx": "react",
"noEmit": false,</pre>
			<p>We added <strong class="source-inline">dom</strong> to the <strong class="source-inline">lib</strong> section, changed the <strong class="source-inline">jsx</strong> mode to <strong class="source-inline">react</strong>, and switched <strong class="source-inline">noEmit</strong> from <strong class="source-inline">true</strong> to <strong class="source-inline">false</strong>. This is necessary to create the files in a way that Webpack can handle. With this step, the setup is complete.</p>
			<h3>Running the React Native code as a React app in the browser</h3>
			<p>Now, we can start<a id="_idIndexMarker595"/> our React Native app as a React web application in <strong class="source-inline">dev</strong> mode from the command line. You can do so with the following command:</p>
			<p class="source-code">cd web &amp;&amp; webpack-dev-server</p>
			<p>The following screenshot shows our example movie app running in the browser:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B16694_10_03.jpg" alt="Figure 10.3 – Our example movie app running in the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Our example movie app running in the browser</p>
			<p><em class="italic">Figure 10.3</em> shows the UI of the example movie app running in the browser. It works perfectly fine, running on the same code base as the native app. When you inspect the HTML with the browser’s inspection tools, you’ll see that all React Native components were transformed into HTML components.</p>
			<p>As a final step of this section and to make development and creating production builds easier, we add two commands to the <strong class="source-inline">scripts</strong> section of <strong class="source-inline">package.json</strong>:</p>
			<pre class="source-code">
"start:web": "cd web &amp;&amp; webpack-dev-server",
"build:web": "cd web &amp;&amp; webpack",</pre>
			<p>The first line is the command we just used to start our application in <strong class="source-inline">dev</strong> mode. The second line is to build the application in production mode for deployment. This writes the complete bundle to the <strong class="source-inline">dist</strong> folder, as we defined in <strong class="source-inline">webpack.config.js</strong>.</p>
			<p>In this subsection, you learned<a id="_idIndexMarker596"/> how to create a clone of your React Native app for the web. While this may work in some cases, most of the time, this isn’t enough. User expectations between web and mobile are different in most areas and you also may want to use different libraries for web and mobile that don’t support the other platform. A very easy solution for differentiating between different platforms is to make use of file endings.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor370"/>Working with .native and .web file endings</h2>
			<p>As described in the previous<a id="_idIndexMarker597"/> subsection, we have two completely different build processes<a id="_idIndexMarker598"/> for web and native apps. While we configured our Webpack bundler to support <strong class="source-inline">.web.ts</strong> or <strong class="source-inline">.web.tsx</strong> files, the native Metro bundler supports <strong class="source-inline">.native.ts</strong> or <strong class="source-inline">.native.tsx</strong> files out of the box. This means that we can write platform-specific code by simply creating two versions of a file:</p>
			<ul>
				<li><strong class="source-inline">App.tsx</strong> and <strong class="source-inline">App.native.tsx</strong> would result in our web application using <strong class="source-inline">App.tsx</strong> and our native application using <strong class="source-inline">App.native.tsx</strong></li>
				<li><strong class="source-inline">App.tsx</strong> and <strong class="source-inline">App.web.tsx</strong> would result in our web application using <strong class="source-inline">App.web.tsx</strong> and our native application using <strong class="source-inline">App.tsx</strong></li>
			</ul>
			<p>This approach can be used to share most of the code but make platform-specific versions of components. It can also be used to define different navigation stacks for the different platforms or use different navigation libraries by creating platform-specific <strong class="source-inline">App.tsx</strong> files.</p>
			<p>All in all, this approach is quite powerful but has some limits. For example, you’ll have to use the same versions of libraries you share between the platforms because both platforms share one <strong class="source-inline">package.json</strong> file. If you want to go one step further, you could either work with multiple packages in a <strong class="source-inline">monorepo</strong> or create your own libraries from the code you want to share, which you then import into different platform-specific projects.</p>
			<p>Let’s have a look at the <strong class="source-inline">monorepo</strong> approach first.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor371"/>Working with multiple packages in a monorepo</h2>
			<p>For structuring your multi-platform React Native app as a <strong class="source-inline">monorepo</strong>, I recommend <a id="_idIndexMarker599"/>using <strong class="source-inline">yarn</strong> workspaces. This is a way to set up multiple JavaScript packages in a single repository. <strong class="source-inline">yarn</strong> optimizes the libraries in terms of versions and storage. It also allows the packages to be linked together, which is the main reason why we are using it here.</p>
			<p>For more information on <strong class="source-inline">yarn</strong> workspaces, you<a id="_idIndexMarker600"/> can have a look at the official documentation (<a href="https://bit.ly/prn-yarn-workspaces">https://bit.ly/prn-yarn-workspaces</a>). The following figure shows the structure of a multi-platform <strong class="source-inline">monorepo</strong> with <strong class="source-inline">yarn</strong> workspaces:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B16694_10_04.jpg" alt="Figure 10.4 – A multi-platform React Native monorepo based on workspaces&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – A multi-platform React Native monorepo based on workspaces</p>
			<p>You have the <strong class="bold">Shared Code</strong> package (often also called <strong class="bold">App</strong>), which can contain most<a id="_idIndexMarker601"/> parts of your application such as views, store, services, and components. This package isn’t started directly and has no native or web entry point. Then, you have one package for every platform.</p>
			<p>Each of these packages has its own <strong class="source-inline">package.json</strong> file and can define its own libraries and versions. This setup even allows you to use different versions of the same library on different platforms, as long as your shared code supports all of them.</p>
			<p>The platform-specific packages contain the entry points, and I would also recommend putting platform-specific things such as navigation and the general application structure (layer stack or navigation tree) here. This makes it possible to not only create a clone of the same application for every platform but also to use very different approaches.</p>
			<p>You could, for example, have a completely different layer stack on the web and mobile. This makes total sense because most of the time there are completely different needs for the different platforms. Some things you need on the web you don’t even want to have on your mobile app and vice versa.</p>
			<p>And there is another advantage of this package approach. There are a lot of frameworks based on React that perform a lot of web-specific optimizations such as supporting<a id="_idIndexMarker602"/> server-side rendering, adding browser history support to routing, or extensive web bundle optimizations. The most<a id="_idIndexMarker603"/> popular frameworks of this kind are <strong class="bold">Next.js</strong> and <strong class="bold">Gatsby</strong>. With this setup, you can use them<a id="_idIndexMarker604"/> for the web.</p>
			<p>If you want to start with this <strong class="source-inline">monorepo</strong> setup, I can recommend an excellent template that you can find here: <a href="https://bit.ly/prn-rn-universal-monorepo">https://bit.ly/prn-rn-universal-monorepo</a>. This template not only supports mobile and the web but also a couple of other frameworks and platforms such as Next.js, Electron, desktop, and even browser extensions. There is also a good description that guides you through<a id="_idIndexMarker605"/> the setup process, which you can find here: <a href="https://bit.ly/prn-rn-anywhere">https://bit.ly/prn-rn-anywhere</a>.</p>
			<p>With this approach, we created different packages for different platforms for the first time. In this scenario, we only used a single repository, because that makes development quite easy. We just have to clone the repository, install the dependencies, and we are ready to go.</p>
			<p>I really like this approach, but when the code base and the team grow a lot, it definitely makes sense to go one step further. To create a clearer separation of the different parts of the application with clear responsibilities, you can split the application into different projects. This means you will create your own libraries.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor372"/>Reusing code with your own libraries</h1>
			<p>There are many good reasons to create your own library<a id="_idIndexMarker606"/>. Sharing code between different<a id="_idIndexMarker607"/> projects for different platforms is definitely one of them. But with your own library, you can also achieve the following things:</p>
			<ul>
				<li><strong class="bold">Ensure consistent design in all your applications</strong>: When you are working in a company<a id="_idIndexMarker608"/> that provides multiple applications, it’s a good idea to create a UI library that provides UI components for all these applications. This ensures a consistent design system.</li>
				<li><strong class="bold">Simplify backend connection</strong>: You can extract your services to a library, which can then be used<a id="_idIndexMarker609"/> in all your projects. This ensures a unified backend connection layer.</li>
				<li><strong class="bold">Define responsibilities</strong>: Every library can be maintained<a id="_idIndexMarker610"/> by its own maintainer or team. With this library approach, you can define clear responsibilities.</li>
				<li><strong class="bold">Provide additional functionality</strong>: You can also write your own library to provide native functionality<a id="_idIndexMarker611"/> that isn’t available in the way you need it from any community module. In this case, I would always recommend providing this functionality in the form of its own library (and making it available to the community if possible).</li>
			</ul>
			<p class="callout-heading">Notice</p>
			<p class="callout">Most of the community modules out there started because someone had a problem that hadn’t been solved. If you are in a position to be able to solve a problem with a new library or module, I would highly recommend sharing it with the community. Even if you don’t want to do it for altruistic reasons, it can be a very good thing. Often, you can find others that share the same challenges and you can create a better solution together.</p>
			<p>Creating our own library<a id="_idIndexMarker612"/> can be quite challenging. You can find a lot of tutorials <a id="_idIndexMarker613"/>and blog posts online on how to create the perfect setup for your own library. Some of them are good – some of them are bad. But instead of using one of them, I recommend a wrapper of tools called <strong class="source-inline">react-native-builder-bob</strong>.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor373"/>Using react-native-builder-bob to write, maintain, and publish our own libraries</h2>
			<p>This tool makes<a id="_idIndexMarker614"/> the process<a id="_idIndexMarker615"/> of writing, maintaining, and publishing<a id="_idIndexMarker616"/> your own<a id="_idIndexMarker617"/> library very<a id="_idIndexMarker618"/> easy. It is created <a id="_idIndexMarker619"/>and maintained by a company called <strong class="bold">Callstack</strong>, which is very active in the React Native community<a id="_idIndexMarker620"/> and even contributes to the core of React Native.</p>
			<p>They use <strong class="source-inline">react-native-builder-bob</strong> for their own libraries and a lot of the most popular libraries also do.</p>
			<p>You can start creating your own library with <strong class="source-inline">react-native-builder-bob</strong> preconfigured using this simple command:</p>
			<p class="source-code">npx create-react-native-library &lt;your-library-name&gt;</p>
			<p>This command<a id="_idIndexMarker621"/> will start the setup process and guide<a id="_idIndexMarker622"/> you through it with<a id="_idIndexMarker623"/> a couple of questions. The following<a id="_idIndexMarker624"/> screenshot shows<a id="_idIndexMarker625"/> this process:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B16694_10_05.jpg" alt="Figure 10.5 – Creating your own library with create-react-native-library&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Creating your own library with create-react-native-library</p>
			<p>After answering questions about the author and the package, which are needed to create the <strong class="source-inline">package.json</strong>, <strong class="source-inline">create-react-native-library</strong> will ask you what type of library you want to develop.</p>
			<p>You can choose between the following options:</p>
			<ul>
				<li><strong class="bold">Native module/Native view</strong>: You should choose this if your module contains native code. These<a id="_idIndexMarker626"/> options use the current bridge architecture to communicate between JavaScript and native.</li>
				<li><strong class="bold">JavaScript library</strong>: You should choose this if your module<a id="_idIndexMarker627"/> does not contain any native code. Most use cases such as simple UI libraries, service SDKs, and state providers fall in this category. Also, this is the correct type when you use other libraries that contain native code but your own library is a JavaScript-only library.</li>
				<li><strong class="bold">Turbo module</strong>: At the time of writing, this type<a id="_idIndexMarker628"/> is in the experimental phase. This creates a native module based on the new React Native architecture (see the <em class="italic">Introducing the new React Native architecture</em> section from <a href="B16694_03.xhtml#_idTextAnchor061"><em class="italic">Chapter 3</em></a>, <em class="italic">Hello React Native</em>).</li>
			</ul>
			<p>We’ll start by creating<a id="_idIndexMarker629"/> a JavaScript-only library. Imagine<a id="_idIndexMarker630"/> that we created<a id="_idIndexMarker631"/> our example application as one of many<a id="_idIndexMarker632"/> applications for a huge corporation. Because<a id="_idIndexMarker633"/> the management likes<a id="_idIndexMarker634"/> the design, they want all future applications to be able to stick to our design system. Therefore, we want to provide our <strong class="source-inline">StyleConstants</strong> file in our own library as the first step in setting up our corporate design system.</p>
			<h3>Creating a JavaScript-only library</h3>
			<p>To start our own<a id="_idIndexMarker635"/> JavaScript-only library, we’ll choose <strong class="bold">JavaScript library</strong> from the <strong class="source-inline">create-react-native-library</strong> dropdown. <strong class="source-inline">create-react-native-library</strong> creates our library with a set of preconfigured tools, predefined scripts, a simple multiply function as the source, and even an example application to showcase the library. If you want to see a working example, you can have a look at the GitHub repository here: <a href="https://bit.ly/prn-repo-styles-library">https://bit.ly/prn-repo-styles-library</a>.</p>
			<p>When we check the <strong class="source-inline">root</strong> folder of our newly created library, we’ll find a lot of files we already know from our application. There is a <strong class="source-inline">babel.config.js</strong> file to define how Babel should transform our code, a <strong class="source-inline">package.json</strong> file, which contains information about the package, as well as all dependencies and scripts, and there is a <strong class="source-inline">tsconfig.json</strong> file, which contains all the information for the TypeScript compiler.</p>
			<p>Next, we’ll have a deeper<a id="_idIndexMarker636"/> look at <strong class="source-inline">package.json</strong>. Besides all the predefined information and configuration, I want to point out two important things. The first one is the information about where to find which parts of our library. This is what you see in the following code snippet:</p>
			<pre class="source-code">
  "main": "lib/commonjs/index",
  "types": "lib/typescript/index.d.ts",
  "source": "src/index",</pre>
			<p>While we are creating our library in TypeScript, it will be compiled to pre-ES6 JavaScript by <strong class="source-inline">react-native-builder-bob</strong>, so that it will work in every React Native project, no matter what stack it is using (TypeScript, Flow, Plain JS, or Expo). This means the code of our library ships in different ways. That’s what’s defined in the following properties:</p>
			<ul>
				<li><strong class="source-inline">main</strong>: This is the main entry point of your library. When you import anything from your library, this is the path where your project will look for exports.</li>
				<li><strong class="source-inline">types</strong>: Since we are using TypeScript <strong class="source-inline">react-native-builder-bob</strong> creates types for our code so that everyone who uses typed JavaScript can work with the types we created.</li>
				<li><strong class="source-inline">source</strong>: This is where the uncompiled source code can be found.</li>
			</ul>
			<p>While we are only working in the <strong class="source-inline">source</strong> directory, the projects that use our library will only work with <strong class="source-inline">main</strong> and <strong class="source-inline">types</strong>.</p>
			<p>The second thing I want you to have a look at is the <strong class="source-inline">scripts</strong> section, above all the following scripts.</p>
			<pre class="source-code">
  "scripts": {
    "prepare": "bob build",
    "release": "release-it",
  },</pre>
			<p>These scripts are the most essential part of this library setup. With the <strong class="source-inline">prepare</strong> script, you can run the <strong class="source-inline">build</strong> command of <strong class="source-inline">react-native-builder-bob</strong>. It will compile your library and provide the entry points you have just learned about.</p>
			<p>The <strong class="source-inline">release</strong> script<a id="_idIndexMarker637"/> will use the <strong class="source-inline">release-it</strong> library to create a new release of your library. This initiates a guided process that will do the following things:</p>
			<ul>
				<li>Update the library version</li>
				<li>Create a changelog</li>
				<li>Publish your library to <strong class="source-inline">npm</strong></li>
				<li>Commit the library version update to <strong class="source-inline">git</strong></li>
				<li>Add a <strong class="source-inline">git</strong> tag</li>
				<li>Push the changes to the remote repository</li>
				<li>Create a release on GitHub</li>
			</ul>
			<p>This script is very useful because it forces you to stick to best practices in terms of releasing and tagging your library.</p>
			<p>Now that you know how the library project is structured, let’s use this library to publish our styles. Since we already collected all our style information in our <strong class="source-inline">StyleConstants</strong> file, this is simple.</p>
			<p>Go to the <strong class="source-inline">src/index.tsx</strong> file of the library project and paste the contents of the <strong class="source-inline">StyleConstants.ts</strong> file. Next, commit the changes and build and publish the library with the following command:</p>
			<p class="source-code">npm run prepare &amp;&amp; npm run release</p>
			<p class="callout-heading">Notice</p>
			<p class="callout">You need to create<a id="_idIndexMarker638"/> a free account at <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> and log in from the command line with <strong class="source-inline">npm login</strong> to be able to publish your library.</p>
			<p>After you publish your library package, you can install it in your project. You can use the regular <strong class="source-inline">npm</strong> command:</p>
			<p class="source-code">npm install &lt;your-library-name&gt;</p>
			<p>Alternatively, you can use the <strong class="source-inline">yarn</strong> command:</p>
			<p class="source-code">yarn add &lt;your-library-name&gt;</p>
			<p>Now that you are able to access your styles via your library, you can delete your <strong class="source-inline">StyleConstants.ts</strong> file and replace all imports with your library. The following figure shows the change for <strong class="source-inline">Home.styles.tsx</strong>:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B16694_10_06.jpg" alt="Figure 10.6 – Importing a change from a local file to a library&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Importing a change from a local file to a library</p>
			<p>As you can see, the imports stay the same, only the <strong class="source-inline">from</strong> path changes to the library. You have to do this in all files where you used <strong class="source-inline">StyleConstants</strong>.</p>
			<p>As you learned<a id="_idIndexMarker639"/> in this subsection, the process of creating your own library is quite complex, but it gets a lot easier when you work with the right tools. But since our example was a JavaScript-only library, it was the easiest type of React Native library. It gets more complex when adding native code to your library.</p>
			<h3>Understanding the difference between native libraries</h3>
			<p>As you already know, React Native<a id="_idIndexMarker640"/> has a JavaScript part and a native part. This means we can make use of native platform-specific code when we want to. This not only works with app projects but also with libraries. Native code is written in platform-specific languages such as Kotlin or Java for Android or Swift or Objective-C for iOS.</p>
			<p>But it isn’t only the language that differs from platform to platform. The process of how the application manages its third-party packages and how to build and deploy is completely different.</p>
			<p>Android uses Gradle to fetch packages and build your app. For iOS, there are multiple package managers but React Native relies heavily on CocoaPods. The build is done via Xcode.</p>
			<p>This means when you are adding native code to your library, you not only have to deliver and import your JavaScript code but you also have to provide the native code and add it to the native build process that gets included in the native bundle.</p>
			<p>With this setup, your native code also gets included in your library bundle. To be able to write native code, you have to choose <strong class="source-inline">Native Module</strong> when creating your library with <strong class="source-inline">create-react-native-library</strong>. This will create two additional folders (<strong class="source-inline">android</strong> and <strong class="source-inline">ios</strong>) that contain the native code, as well as the configuration files for the native build process.</p>
			<p>For Android, this is a <strong class="source-inline">build.gradle</strong> file, which can be found in the <strong class="source-inline">android</strong> folder. For iOS, this is a <strong class="source-inline">.podspec</strong> file, which can be found in the <strong class="source-inline">root</strong> folder of the library.</p>
			<p>All these files are created for you, so you shouldn’t need to change them. When installing your library with native code, React Native autolinking will take care of everything for you on Android. On iOS, you’ll have to run <strong class="source-inline">npx pod-install</strong> to include the native part of your library in the native project.</p>
			<p>Now that you are able to create pure JavaScript libraries and libraries with native code, we’ll take another look at how to provide them. We used the public <strong class="source-inline">npm</strong> registry to host our library as a public package.</p>
			<p>While I really like the approach<a id="_idIndexMarker641"/> of sharing everything with the community, you may have the requirement to keep your libraries private, especially when they are important parts of corporate applications. The next subsection will show you how to only provide access to your libraries to selected people.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor374"/>Setting access restrictions on libraries</h2>
			<p>There are some ways<a id="_idIndexMarker642"/> to share your library only<a id="_idIndexMarker643"/> with selected people. These two are the most common ones:</p>
			<ul>
				<li><strong class="bold">Use a paid npmjs.com plan</strong>: You can define permissions<a id="_idIndexMarker644"/> on your packages when using a paid <a href="https://npmjs.com">npmjs.com</a> plan. This means that only people you explicitly allow will have access to your package.</li>
				<li><strong class="bold">Import your packages directly from the repository</strong>: You don’t need to use <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> to import your packages. You<a id="_idIndexMarker645"/> can also import packages directly<a id="_idIndexMarker646"/> from your repository. This would look as follows in your <strong class="source-inline">package.json</strong>:<p class="source-code">"prn-video-example-styles": "git+https://github.com/alexkuttig/video-example-styles"</p></li>
				<li>You could even specify tags, branches, or commits your package should be fetched from by adding a <strong class="source-inline">#</strong> symbol followed by the tag name, branch name, or commit hash.</li>
			</ul>
			<p>Again, I would highly recommend<a id="_idIndexMarker647"/> publishing your modules and not keeping<a id="_idIndexMarker648"/> them private wherever possible. This community with thousands of well-maintained public packages is one of the main reasons why React Native is so successful. So, giving something back to the community is always a good idea.</p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor375"/>Summary</h1>
			<p>In this chapter, you learned how to structure large-scale or multi-platform products. You are now able to create a project structure that works for large-scale and long-running projects.</p>
			<p>You also created a clone of your example React Native mobile app on the web and understood why this isn’t always the best idea. You then learned how to create multi-platform applications that meet user expectations while keeping a high percentage of shared code.</p>
			<p>In the last section of this chapter, you learned how to create, release, and maintain your own libraries, what the difference between JavaScript-only libraries and libraries with native code is, and how to only publish these libraries to selected people.</p>
			<p>After focusing on creating a good structure for the code base itself, in the next chapter, we’ll focus on how to implement well-working processes and how to support these processes with <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) tools.</p>
		</div>
		<div>
			<div id="_idContainer052">
			</div>
		</div>
	</body></html>