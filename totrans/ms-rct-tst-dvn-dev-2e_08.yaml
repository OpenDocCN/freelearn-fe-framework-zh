- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an Application Component
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The components you’ve built so far have been built in isolation: they don’t
    fit together, and there’s no workflow for the user to follow when they load the
    application. Up to this point, we’ve been manually testing our components by swapping
    them in and out of our index file, `src/index.js`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll tie all those components into a functioning system by
    creating a root application component, `App`, that displays each of these components
    in turn.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'You have now seen almost all the TDD techniques you’ll need for test-driving
    React applications. This chapter covers one final technique: testing callback
    props.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Formulating a plan
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using state to control the active view
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driving callback props
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making use of callback values
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have learned how to use mocks to test the
    root component of your application, and you’ll have a working application that
    ties together all the components you’ve worked on in *Part 1* of this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter08)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Formulating a plan
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into the code for the `App` component, let’s do a little up-front
    design so that we know what we’re building.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows all the components you’ve built and how `App` will
    connect them:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – The component hierarchy ](img/Figure_8.01_B18423.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – The component hierarchy
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it’ll work:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: When the user first loads the app, they will see a list of today’s appointments
    using the `AppointmentsDayView` component, which will have its appointment data
    populated by its container `AppointmentsDayViewLoader` component.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the screen, the user will see a button labeled `AppointmentsDayView`
    disappear and `CustomerForm` appear.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the form is filled out and the submit button is clicked, the user is shown
    `AppointmentForm` and can add a new appointment for that customer.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once they’ve added the appointment, they’ll be taken back to `AppointmentsDayView`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This first step is shown in the following screenshot. Here, you can see the
    new button in the top-left corner. The `App` component will render this button
    and then orchestrate this workflow:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 –  The app showing the new button in the top-left corner ](img/Figure_8.02_B18423.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The app showing the new button in the top-left corner
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very simple workflow that supports just a single use case: adding
    a new customer and an appointment at the same time. Later in this book, we’ll
    add support for creating appointments for existing customers.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’re ready to build the new `App` component.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Using state to control the active view
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll start building a new `App` component, in the usual way.
    First, we’ll display an `AppointmentsDayViewLoader` component. Because this child
    component makes a network request when mounted, we’ll mock it out. Then, we’ll
    add a button inside a `menu` element, at the top of the page. When this button
    is clicked, we switch out the `AppointmentsDayViewLoader` component for a `CustomerForm`
    component.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: We will introduce a state variable named `view` that defines which component
    is currently displayed. Initially, it will be set to `dayView`. When the button
    is clicked, it will change to `addCustomer`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The JSX constructs will initially use a ternary to switch between these two
    views. Later, we’ll add a third value called `addAppointment`. When we do that,
    we’ll “upgrade” our ternary expression to a `switch` statement.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, follow these steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `test/App.test.js`, with the following imports for the new
    `App` component:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, import `AppointmentsDayViewLoader` and mock its implementation:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let’s add our first test, which checks that `AppointmentsDayViewLoader`
    has been rendered:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Make that pass by adding the following code to a new file, `src/App.js`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For the second test, we’ll add a menu to the top of the page. For this, we’ll
    need the element matcher, so add that to your test suite imports:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the second test:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To make that pass, change the `App` component so that it includes a `menu`
    element above the loader component:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we want to display a button in the menu that, when clicked, will switch
    to `CustomerForm`. Add the following test, which asserts that the button appears
    on the page, using a CSS selector to find the rendered button element. This uses
    the `:first-of-type` pseudoclass to ensure we find the first button (later in
    this book, we’ll add a second button to the menu):'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To make that pass, change the menu in the `App` component to the following:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For the next test, we must check that clicking the button renders `CustomerForm`.
    We must also mock this component out. To do that, we’ll need the component that’s
    been imported into the test suite. Add the following line to `test/App.test.js`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Just below that, add the following mock definition, which is our standard mock
    definition:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Why mock a component that has no effects on mount?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: This component already has a test suite so that we can use a test double and
    verify the right props to avoid re-testing functionality we’ve tested elsewhere.
    For example, the `CustomerForm` test suite has a test to check that the submit
    button calls the `onSave` prop with the saved customer object. So, rather than
    extending the test surface area of `App` so that it includes that submit functionality,
    we can mock out the component and call `onSave` directly instead. We’ll do that
    in the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'To click the button, we’ll need our click helper. Bring that in now:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, add the test. This introduces a helper function, `beginAddingCustomerAndAppointment`,
    which finds the button and clicks it. We’ll pull that out now because we’ll be
    using it in most of the remaining tests:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Making this pass involves adding a component state to track that we’ve clicked
    the button. In `src/App.js`, import the two hooks we’ll need, `useState` and `useCallback`,
    and import `CustomerForm` too:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `App` component, define the new view state variable and initialize it
    to the `dayView` string, which we’ll use to represent `AppointmentsDayViewLoader`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Just below that, add a new callback named `transitionToAddCustomer`, which
    we’ll attach to the button’s `onClick` handler in the next step. This callback
    updates the view state variable so that it points to the second page, which we’ll
    call `addCustomer`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Plug that into the `onClick` prop of the button:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, all that’s left is to modify our JSX to ensure the `CustomerForm` component
    is rendered when the `view` state variable is set to `addCustomer`. Notice how
    the test doesn’t force us to hide `AppointmentsDayViewLoader`. That will come
    in a later test. For now, we just need the simplest code that will make our test
    pass. Update your JSX, as shown here:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Testing for the presence of a new component
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, this *isn’t* the simplest way to make the test pass. We could
    make it pass by *always* rendering a `CustomerForm` component, regardless of the
    value of `view`. Then, we’d need to triangulate with a second test that proves
    the component is not initially rendered. I’m skipping this step for brevity, but
    feel free to add it in if you prefer.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to ensure that we pass an `original` prop to `CustomerForm`. In this
    workflow, we’re creating a new customer so that we can give it a blank customer
    object, just like the one we used in the `CustomerForm` test suite. Add the following
    test below it. We’ll define `blankCustomer` in the next step:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a new file, `test/builders/customer.js`, and add a definition for `blankCustomer`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Import that new definition into your `App` test suite:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Value builders versus function builders
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: We’ve defined `blankCustomer` as a constant value, rather than a function. We
    can do this because all the code we’ve written treats variables as immutable objects.
    If that wasn’t the case, we may prefer to use a function, `blankCustomer()`, that
    generates new values each time it is called. That way, we can be sure that one
    test doesn’t accidentally modify the setup for any subsequent tests.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make that test pass. First, define `blankCustomer` at the top of `src/App.js`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using builder functions in both production and test code
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: You now have the same `blankCustomer` definition in both your production and
    test code. This kind of duplication is usually okay, especially since the object
    is so simple. But for non-trivial builder functions, you should consider test-driving
    the implementation and then making good use of it within your test suite.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, simply reference that value by setting it as an `original` prop of `CustomerForm`.
    After making this change, your test should be passing:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, add the following test to hide `AppointmentsDayViewLoader` when a customer
    is being added:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To make that pass, we need to move `AppointmentsDayViewLoader` into the ternary
    expression, in place of the null:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s hide the button bar, too:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To solve this, we need to lift the ternary out of the JSX entirely, as shown
    in the following code. This is messy, but we’ll improve its implementation in
    the next section:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With that, you have implemented the initial step in the workflow – that is changing
    the screen from an `AppointmentsDayViewLoader` component to a `CustomerForm` component.
    You did this by changing the `view` state variable from `dayView` to `addCustomer`.
    For the next step, we’ll use the `onSave` prop of `CustomerForm` to alert us when
    it’s time to update `view` to `addAppointment`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Test-driving callback props
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll introduce a new extension function, `propsOf`, that reaches
    into a mocked child component and returns the props that were passed to it. We’ll
    use this to get hold of the `onSave` callback prop value and invoke it from our
    test, mimicking what would happen if the real `CustomerForm` had been submitted.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth revisiting why this is something we’d like to do. Reaching into a
    component and calling the prop directly seems complicated. However, the alternative
    is *more* complicated and *more* brittle.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'The test we want to write next is the one that asserts that the `AppointmentFormLoader`
    component is shown after `CustomerForm` has been submitted and a new customer
    has been saved:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, imagine that we wanted to test this without a mocked `CustomerForm`. We
    would need to fill in the real `CustomerForm` form fields and hit the submit button.
    That may seem reasonable, but we’d be increasing the surface area of our `App`
    test suite to include the `CustomerForm` component. Any changes to the `CustomerForm`
    component would require not only the `CustomerForm` tests to be updated but also
    now the `App` tests. This is the exact scenario we’ll see in [*Chapter 9*](B18423_09.xhtml#_idTextAnchor159),
    *Form Validation*, when we update `CustomerForm` so that it includes field validation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: By mocking the child component, we can reduce the surface area and reduce the
    likelihood of breaking tests when child components change.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Mocked components require care
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Even with mocked components, our parent component test suite can still be affected
    by child component changes. This can happen if the meaning of the props changes.
    For example, if we updated the `onSave` prop on `CustomerForm` to return a different
    value, we’d need to update the `App` tests to reflect that.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we’ve got to do. First, we must define a `propsOf` function in
    our extensions module. Then, we must write tests that mimic the submission of
    a `CustomerForm` component and transfer the user to an `AppointmentFormLoader`
    component. We’ll do that by introducing a new `addAppointment` value for the view
    state variable. Follow these steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'In `test/reactTestExtensions.js`, add the following definition of `propsOf`.
    It looks up the last call to the mocked component and returns its props:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Back in `test/App.test.js`, update the extensions import so that it includes
    `propsOf`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You also need to import the `act` function from React’s test utils. Our test
    will wrap its invocation of the callback prop to ensure that any setters are run
    before the call returns:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There’s one more import to add – the import for `AppointmentFormLoader`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Just below that, define its mock using the standard component mock definition:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We’re almost ready for our test. First, though, let’s define a helper function,
    `saveCustomer`. This is the key part of the code that invokes the prop. Note that
    this sets a default customer object of `exampleCustomer`. We’ll use this default
    value to avoid having to specify the customer in each test where the value doesn’t
    matter:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using act within the test suite
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first occasion that we’ve willingly left a reference to act within
    our test suite. In every other use case, we managed to hide calls to `act` within
    our extensions module. Unfortunately, that’s just not possible here – at least,
    it’s not possible with the way we wrote `propsOf`. An alternative approach would
    be to write an extension function named `invokeProp` that takes the name of a
    prop and invokes it for us:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '`invokeProp(CustomerForm, "onSave", customer);`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The downside of this approach is that you’ve now downgraded `onSave` from an
    object property to a string. So, we’ll ignore this approach for now and just live
    with `act` usage in our test suite.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write our test. We want to assert that `AppointmentsFormLoader` is displayed
    once `CustomerForm` has been submitted:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Making this pass will involve adding a new value to the view state variable,
    `addAppointment`. With this third value, the ternary expression is no longer fit
    for purpose because it can only handle two possible values of view. So, before
    we continue making this pass, let’s refactor that ternary so that it uses a `switch`
    statement. Skip the test you just wrote using `it.skip`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the return statement of your component with the following:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Once you’ve verified that your tests still pass, un-skip your latest test by
    changing `it.skip` back to `it`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The component should update the view to `addAppointment` whenever the `onSave`
    prop of `CustomerForm` is called. Let’s do that with a new callback handler. Add
    the following code just below the definition of `transitionToAddCustomer`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Modify the `CustomerForm` render expression so that it takes this as a prop:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Hook up the new `addAppointment` value by adding the following `case` statement
    to the switch. After making this change, your test should be passing:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For the next test, we need to pass a value for the `original` prop, this time
    to `AppointmentFormLoader`. Note the double use of `expect.objectContaining`.
    This is necessary because our appointment is not going to be a simple blank appointment
    object. This time, the appointment will have a customer ID passed to it. That
    customer ID is the ID of the customer we’ve just added – we’ll write a test for
    that next:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We need a builder function, just like with `blankCustomer`. Create a new file,
    `test/builders/appointment.js`, and add the following definition:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Update the test code to import that:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, create the same thing in `src/App.js`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, you can make the test pass by setting the `original` prop, as shown
    here:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We’re almost done with the display of `AppointmentFormLoader`, but not quite:
    we still need to take the customer ID we receive from the `onSave` callback and
    pass it into `AppointmentFormLoader`, by way of the `original` prop value, so
    that `AppointmentForm` knows which customer we’re creating an appointment for.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Making use of callback values
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll introduce a new state variable, `customer`, that will
    be set when `CustomerForm` receives the `onSave` callback. After that, we’ll do
    the final transition in our workflow, from `addAppointment` back to `dayView`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we’ll check that the new customer ID is passed to `AppointmentFormLoader`.
    Remember in the previous section how we gave `saveCustomer` a customer parameter?
    We’ll make use of that in this test:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For this to work, we’ll need to add a state variable for the customer. Add
    the following at the top of the `App` component:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we built the `onSave` prop of `CustomerForm` back in [*Chapter 6*](B18423_06.xhtml#_idTextAnchor099),
    *Exploring Test Doubles*, we passed it the updated customer object. Update the
    `transitiontoAddAppointment` handler so that it takes this parameter value and
    saves it using the `setCustomer` setter:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Pass that through to `AppointmentFormLoader` by creating a new `original` object
    value that merges the customer ID into `blankAppointment`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It’s time for the final test for this component. We complete the user workflow
    by asserting that once the appointment is saved, the view updates back to `dayView`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Define a new function to set the state back to `dayView`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Pass this function to `AppointmentsFormLoader` to ensure it’s called when the
    appointment is saved. After this, your tests should be complete and passing:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We’re done!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all that’s left is to update `src/index.js` to render the `App` component.
    Then, you can manually test this to check out your handiwork:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To run the application, use the `npm run serve` command. For more information
    see the *Technical requirements* section in [*Chapter 6*](B18423_06.xhtml#_idTextAnchor099)*,
    Exploring Test Doubles*, or consult the `README.md` file in the repository.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行应用程序，请使用`npm run serve`命令。有关更多信息，请参阅[*第6章*](B18423_06.xhtml#_idTextAnchor099)*，探索测试替身*部分中的*技术要求*部分，或查阅存储库中的`README.md`文件。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the final TDD technique for you to learn – mocked component
    callback props. You learned how to get a reference to a component callback using
    the `propsOf` extension, as well as how to use a state variable to manage the
    transitions between different parts of a workflow.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了你将要学习的最终TDD技术——模拟组件回调属性。你学习了如何使用`propsOf`扩展获取组件回调的引用，以及如何使用状态变量来管理工作流程不同部分之间的转换。
- en: You will have noticed how *all* the child components in `App` were mocked out.
    This is often the case with top-level components, where each child component is
    a relatively complex, self-contained unit.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到`App`中的所有子组件都被模拟了。这种情况通常发生在顶级组件中，其中每个子组件都是一个相对复杂、自包含的单元。
- en: In the next part of this book, we’ll apply everything we’ve learned to more
    complex scenarios. We’ll start by introducing field validation into our `CustomerForm`
    component.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一部分，我们将把所学的一切应用到更复杂的场景中。我们将首先将字段验证引入到我们的`CustomerForm`组件中。
- en: Exercises
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The following are some exercises for you to try out:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些供你尝试的练习：
- en: Update your `CustomerForm` and `AppointmentForm` tests to use the new builders
    you’ve created.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的`CustomerForm`和`AppointmentForm`测试，以使用你创建的新构建器。
- en: Add a test to `AppointmentForm` that ensures that the customer ID is submitted
    when the form is submitted.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`AppointmentForm`添加一个测试，确保在表单提交时提交客户ID。
- en: Part 2 – Building Application Features
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分 – 构建应用程序功能
- en: 'This part builds on the basic techniques you’ve learned in *Part 1* by applying
    them to real-world problems that you’ll encounter in your work, and introduces
    libraries that many React developers use: React Router, Redux, and Relay (GraphQL).
    The goal is to show you how the TDD workflow can be used even for large applications.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分基于你在*第1部分*中学到的基本技术，通过将它们应用于你在工作中会遇到的真实世界问题来应用它们，并介绍了许多React开发者使用的库：React
    Router、Redux和Relay（GraphQL）。目标是向你展示TDD工作流程甚至可以用于大型应用程序。
- en: 'This part includes the following chapters:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 9*](B18423_09.xhtml#_idTextAnchor159), *Form Validation*'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18423_09.xhtml#_idTextAnchor159)，*表单验证*'
- en: '[*Chapter 10*](B18423_10.xhtml#_idTextAnchor183), *Filtering and Searching
    Data*'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18423_10.xhtml#_idTextAnchor183)，*过滤和搜索数据*'
- en: '[*Chapter 11*](B18423_11.xhtml#_idTextAnchor207), *Test-Driving React Router*'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18423_11.xhtml#_idTextAnchor207)，*测试驱动React Router*'
- en: '[*Chapter 12*](B18423_12.xhtml#_idTextAnchor231), *Test-Driving Redux*'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18423_12.xhtml#_idTextAnchor231)，*测试驱动Redux*'
- en: '[*Chapter 13*](B18423_13.xhtml#_idTextAnchor258), *Test-Driving GraphQL*'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18423_13.xhtml#_idTextAnchor258)，*测试驱动GraphQL*'
