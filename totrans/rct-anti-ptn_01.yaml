- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing React Anti-Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book dives deep into the realm of React anti-patterns. An anti-pattern
    is not necessarily a technical error – the code often functions properly at first
    – but although it may initially seem correct, as the code base expands, these
    anti-patterns can become problematic.
  prefs: []
  type: TYPE_NORMAL
- en: As we navigate through the book, we’ll scrutinize code samples that might not
    embody best practices; some could be intricate to decipher, and others, tough
    to modify or extend. While certain pieces of code may suffice for smaller tasks,
    they falter when scaled up. Moreover, we’ll venture into time-tested patterns
    and principles from the expansive software world, seamlessly weaving them into
    our frontend discourse.
  prefs: []
  type: TYPE_NORMAL
- en: I aim for practicality. The code illustrations originate either from past projects
    or commonplace domains such as a shopping cart and a user profile component, minimizing
    your need to decipher domain jargon. For a holistic view, the concluding chapters
    showcase detailed, end-to-end examples, furnishing a more organized and immersive
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, in this introductory chapter, we’ll address the intricacies of
    constructing advanced React applications, highlighting how state management and
    asynchronous operations can obfuscate code clarity. We’ll enumerate prevalent
    anti-patterns and offer a glimpse into the remedial strategies detailed later
    in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difficulty of building UIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the state management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring “unhappy paths”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring common anti-patterns in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A GitHub repository has been created to host all the code we discuss in the
    book. For this chapter, you can find the code at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch1](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch1).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difficulty of building UIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unless you’re building a straightforward, document-like web page — for example,
    a basic article without advanced UI elements such as search boxes or modals —
    the built-in languages offered by web browsers are generally insufficient. *Figure
    1**.1* shows an example of a website using **HTML** (**HyperText** **Markup Language**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: A simple HTML document website](img/B21103_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: A simple HTML document website'
  prefs: []
  type: TYPE_NORMAL
- en: However nowadays, most applications are more complicated and contain more elements
    than what this language was originally designed for.
  prefs: []
  type: TYPE_NORMAL
- en: The disparity between the language of the web and the UI experiences that people
    encounter daily is substantial. Whether it’s a ticket booking platform, a project
    management tool, or an image gallery, modern web UIs are intricate and native
    web languages don’t readily support them. You can go the extra mile to “simulate”
    UI components such as accordions, toggle switches, or interactive cards, but fundamentally,
    you’re still working with what amounts to a document, not a genuine UI component.
  prefs: []
  type: TYPE_NORMAL
- en: In an ideal world, building a UI would resemble working with a visual UI designer.
    Tools such as C++ Builder or Delphi, or more modern alternatives such as Figma,
    let you drag and drop components onto a canvas that then renders seamlessly on
    any screen. This isn’t the case with web development. For instance, to create
    a custom search input, you’ll need to wrap it in additional elements, fine-tune
    colors, adjust padding and fonts, and perhaps add an icon for user guidance. Creating
    an auto-suggestion list that appears right under the search box, matching its
    width exactly, is often far more labor-intensive than one might initially think.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 1**.2*, a web page can be super complicated and look nothing
    like a document on the surface, although the building blocks of the page are still
    pure HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: Jira issue view](img/B21103_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Jira issue view'
  prefs: []
  type: TYPE_NORMAL
- en: This screenshot shows the issue view of Jira, a popular web-based project management
    tool used to track, prioritize, and coordinate tasks and projects. An issue view
    contains many details such as the issue’s title, description, attachments, comments,
    and linked issues. It also contains many elements a user can interact with, such
    as an **Assign to me** button, the ability to change the priority of the issue,
    add a comment, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: For such a UI, you might expect there to be a navigator component, a drop-down
    list, an accordion, and so on. And seemingly, they are there, as labeled in *Figure
    1**.2*. But they are not actually components. Instead, developers have worked
    hard to *simulate* these with HTML, CSS, and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve glanced over the language mismatch issue in web UI development,
    it might be helpful to delve into what’s under the surface – the different states
    we need to manage in frontend applications. This will provide a taste of the challenges
    that lie ahead and shed light on why introducing patterns is a key step toward
    addressing them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the state management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing the state in modern frontend development is a complex task. Nearly
    every application has to retrieve data from a remote server via a network – we
    can call this data **remote states**. Remote state originates from an external
    source, typically a backend server or API. This is in contrast to local state,
    which is generated and managed entirely within the frontend application itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many dark sides of remote states, making the frontend development
    difficult if you don’t pay close attention to them. Here, I’ll just list a few
    obvious considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Asynchronous nature*: Fetching data from a remote source is usually an asynchronous
    operation. This adds complexity in terms of timing, especially when you have to
    synchronize multiple pieces of remote data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Error handling*: Connections to remote sources might fail or the server might
    return errors. Properly managing these scenarios for a smooth user experience
    can be challenging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Loading states*: While waiting for data to arrive from a remote source, the
    application needs to handle “loading” states effectively. This usually involves
    showing loading indicators or fallback UIs (when the requesting component isn’t
    available, we use a default one temporarily).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Consistency*: Keeping the frontend state in sync with the backend can be difficult,
    especially in real-time applications or those that involve multiple users altering
    the same piece of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Caching*: Storing some remote state locally can improve performance but bring
    its own challenges, such as invalidation and staleness. In other words, if the
    remote data is altered by others, we need a mechanism to receive updates or perform
    a refetch to update our local state, which introduces a lot of complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Updates and optimistic UI*: When a user makes a change, you can update the
    UI optimistically assuming the server call will succeed. But if it doesn’t, you’ll
    need a way to roll back those changes in your frontend state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And those are only some of the challenges of remote states.
  prefs: []
  type: TYPE_NORMAL
- en: When the data is stored and accessible immediately in the frontend, you basically
    think in a linear way. This means you access and manipulate data in a straightforward
    sequence, one operation following another, leading to a clear and direct flow
    of logic. This way of thinking aligns well with the synchronous nature of the
    code, making the development process intuitive and easier to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s compare how much more code we’ll need for rendering static data with remote
    data. Think about a famous quotes application that displays a list of quotes on
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To render the passed-in quotes list, you can map the data into JSX elements,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We’re using `index` as the key here, which is fine for static quotes. However,
    it’s generally best to avoid this practice. Using indices can lead to rendering
    issues in dynamic lists in real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the quotes are from a remote server, the code will turn into something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this React component, we use `useState` to create a quotes state variable,
    initially set as an empty array. The `useEffect` Hook fetches quotes from a remote
    server when the component mounts. It then updates the quotes state with the fetched
    data. Finally, the component renders a list of quotes, iterating through the `quotes`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry, there’s no need to sweat about the details for now; we’ll delve
    into them in the next chapter on React essentials.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code example shows the ideal scenario, but in reality, asynchronous
    calls come with their own challenges. We have to think about what to display while
    data is being fetched and how to handle various error scenarios, such as network
    issues or resource unavailability. These added complexities can make the code
    lengthier and more difficult to grasp.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, while fetching data, we temporarily transition into a loading
    state, and should anything go awry, we shift to an error state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The code uses `useState` to manage three pieces of state: `quotes` for storing
    the quotes, `isLoading` for tracking the loading status, and `error` for any fetch
    errors.'
  prefs: []
  type: TYPE_NORMAL
- en: The `useEffect` Hook triggers the fetch operation. If the fetch is successful,
    the quotes are displayed and `isLoading` is set to `false`. If an error occurs,
    an error message is displayed and `isLoading` is again set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can observe, the portion of the component dedicated to actual rendering
    is quite small (i.e., the JSX code inside `return`). In contrast, managing the
    state consumes nearly two-thirds of the function’s body.
  prefs: []
  type: TYPE_NORMAL
- en: 'But that’s just one aspect of the state management. There’s also the matter
    of managing local state, which means the state only needs to be maintained inside
    a component. For example, as demonstrated in *Figure 1**.3*, an accordion component
    needs to track whether it’s expanded or collapsed – when you click the triangle
    on the header, it toggles the list panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: An expandable section](img/B21103_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: An expandable section'
  prefs: []
  type: TYPE_NORMAL
- en: Using a third-party state management library such as Redux or MobX can be beneficial
    when your application reaches a level of complexity that makes state tracking
    difficult. However, using a third-party state management library isn’t without
    its caveats (learning curve, best practices in a particular library, migration
    efforts, etc.) and should be considered carefully. That’s why many developers
    are leaning toward using React’s built-in Context API for state management.
  prefs: []
  type: TYPE_NORMAL
- en: Another significant complexity in modern frontend applications that often goes
    unnoticed by many developers, yet is akin to an iceberg that warrants closer attention,
    is “unhappy paths.” Let’s look at these next.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring “unhappy paths”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to UI development, our primary focus is often on the “happy path”
    – the optimal user journey where everything goes as planned. However, neglecting
    the “unhappy paths” can make your UI far more complicated than you might initially
    think. Here are some scenarios that could lead to unhappy paths and consequently
    complicate your UI development efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Errors thrown from other components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you’re using a third-party component or even another team’s component
    within your application. If that component throws an error, it could potentially
    break your UI or lead to unexpected behaviors that you have to account for. This
    can involve adding conditional logic or error boundaries to handle these errors
    gracefully, making your UI more complex than initially anticipated.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in a `MenuItem` component that renders an item’s data, let’s see
    what happens when we try accessing something that doesn’t exist in the passed-in
    prop `item` (in this case, we’re looking for the aptly named `item.something.doesnt.exist`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `MenuItem` component receives an `item` object and an `onItemClick` function
    as props. It displays the item’s name and description, as well as including an
    `onItemClick` function is called with the item as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code attempts to access a non-existing property, `item.something.doesnt.exist`,
    which will cause a runtime error. As demonstrated in *Figure 1**.4*, the application
    stopped working after the backend service returned some unexpected data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: A component-thrown exception during render](img/B21103_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: A component-thrown exception during render'
  prefs: []
  type: TYPE_NORMAL
- en: This can cause the whole application to crash if we don’t isolate the error
    into an **error boundary**, as we can see in *Figure 1**.4* – the menus are not
    displayed, but the category and page titles remain functional; the area affected,
    which I’ve outlined with a red dotted line, is where the menus were supposed to
    appear. Error boundaries in React are a feature that allows you to catch JavaScript
    errors that occur in child components, log those errors, and display a fallback
    UI instead of letting the whole app crash. Error boundaries catch errors during
    rendering, in life cycle methods, and in constructors of the whole tree below
    them.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world projects, your UI might depend on various microservices or APIs
    for fetching data. If any of these downstream systems are down, your UI has to
    account for it. You’ll need to design fallbacks, loading indicators, or friendly
    error messages that guide the user on what to do next. Handling these scenarios
    effectively often involves both frontend and backend logic, thus adding another
    layer of complexity to your UI development tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the unexpected user behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No matter how perfectly you design your UI, users will always find ways to use
    your system in manners you didn’t anticipate. Whether they input special characters
    in text fields, try to submit forms too quickly, or use browser extensions that
    interfere with your site, you have to design your UI to handle these edge cases.
    This means implementing additional validation, checks, and safeguards that can
    complicate your UI code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine a basic `Form` component to understand the considerations for
    user input. While this single-field form might require additional logic in the
    `handleChange` method, it’s important to note that most forms typically consist
    of several fields (which means there will be more unexpected user behavior we
    need to consider):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This `Form` component consists of a single text input field that restricts input
    to alphanumeric characters and spaces. It uses a `value` state variable to store
    the input field’s value. The `handleChange` function, triggered on each input
    change, removes any non-alphanumeric characters from the user’s input before updating
    the state with the sanitized value.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and effectively managing these unhappy paths are critical to creating
    a robust, resilient, and user-friendly interface. Not only do they make your application
    more reliable, but they also contribute to a more comprehensive and well-thought-out
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: I believe you should now have a clearer insight into the challenges of building
    modern frontend applications in React. Tackling these hurdles isn’t straightforward,
    particularly since React doesn’t offer a definitive guide on which approach to
    adopt, how to structure your code base, manage states, or ensure code readability
    (and by extension, ease of maintenance in the long run), or how established patterns
    can be of aid, among other concerns. This lack of guidance often leads developers
    to create solutions that might work in the short term but could be riddled with
    anti-patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring common anti-patterns in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within the realm of software development, we often encounter practices and approaches
    that, at first glance, appear to offer a beneficial solution to a particular problem.
    These practices, labeled as **anti-patterns**, may provide immediate relief or
    a seemingly quick fix, but they often hide underlying issues. Over time, reliance
    on these anti-patterns can lead to greater complexities, inefficiencies, or even
    the very issues they were thought to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing and understanding these anti-patterns is crucial for developers,
    as it enables them to anticipate potential pitfalls and steer clear of solutions
    that may be counterproductive in the long run. In the upcoming sections, we’ll
    highlight common anti-patterns accompanied by code examples. We’ll address each
    anti-pattern and outline potential solutions. However, we won’t delve deeply here
    since entire chapters are dedicated to discussing these topics in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Props drilling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In complex React applications, managing state and ensuring that every component
    has access to the data it needs can become challenging. This is often observed
    in the form of **props drilling**, where props are passed from a parent component
    through multiple intermediary components before they reach the child component
    that actually needs them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider a `SearchableList`, `List`, and a `ListItem` hierarchy
    – a `SearchableList` component contains a `List` component, and `List` contains
    multiple instances of `ListItem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this setup, the `onItemClick` prop is drilled from `SearchableList` through
    `List` and finally to `ListItem`. Though the `List` component doesn’t use this
    prop, it has to pass it down to `ListItem`.
  prefs: []
  type: TYPE_NORMAL
- en: This approach can lead to increased complexity and reduced maintainability.
    When multiple props are passed down through various components, understanding
    the flow of data and debugging can become difficult.
  prefs: []
  type: TYPE_NORMAL
- en: A potential solution to avoid props drilling in React is by leveraging the Context
    API. It provides a way to share values (data and functions) between components
    without having to explicitly pass props through every level of the component tree.
  prefs: []
  type: TYPE_NORMAL
- en: In-component data transformation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The component-centric approach in React is all about breaking up tasks and concerns
    into manageable chunks, enhancing maintainability. One recurrent misstep, however,
    is when developers introduce complex data transformation logic directly within
    components.
  prefs: []
  type: TYPE_NORMAL
- en: It’s common, especially when dealing with external APIs or backends, to receive
    data in a shape or format that isn’t ideal for the frontend. Instead of adjusting
    this data at a higher level, or in a utility function, the transformation is defined
    inside the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `UserProfile` function component retrieves and displays a user’s profile
    based on the provided prop `userId`. Once the remote `data` is fetched, it’s transformed
    within the component itself to create a structured user profile. This transformed
    data consists of the user’s full name (a combination of first and last name),
    age, and a formatted address.
  prefs: []
  type: TYPE_NORMAL
- en: 'By directly embedding the transformation, we encounter a few issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lack of clarity*: Combining data fetching, transformation, and rendering tasks
    within a single component makes it harder to pinpoint the component’s exact purpose'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reduced reusability*: Should another component require the same or a similar
    transformation, we’d be duplicating logic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Testing challenges*: Testing this component now requires considering the transformation
    logic, making tests more convoluted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To combat this anti-pattern, it’s advised to separate data transformation from
    the component. This can be achieved using utility functions or custom Hooks, thus
    ensuring a cleaner and more modular design. By externalizing these transformations,
    components remain focused on rendering and business logic stays centralized, making
    for a far more maintainable code base.
  prefs: []
  type: TYPE_NORMAL
- en: Complicated logic in views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The beauty of modern frontend frameworks, including React, is the distinct separation
    of concerns. By design, components should be oblivious to the intricacies of business
    logic, focusing instead on presentation. However, a recurrent pitfall that developers
    encounter is the infusion of business logic within view components. This not only
    disrupts the clean separation but also bloats components and makes them harder
    to test and reuse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a simple example. Imagine a component that is meant to display a list
    of items fetched from an API. Each item has a price, but we want to display items
    above a certain threshold price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `filterExpensiveItems` function, a piece of business logic, resides
    directly within the view component. The component is now tasked with not just
    presenting data but also processing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach can become problematic:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Reusability*: If another component requires a similar filter, the logic would
    need to be duplicated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Testing*: Unit testing becomes more complex as you’re not just testing the
    rendering, but also the business logic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Maintenance*: As the application grows and more logic is added, this component
    can become unwieldy and harder to maintain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To ensure our components remain reusable and easy to maintain, it’s wise to
    embrace the **separation of concerns** principle. This principle states that each
    module or function in software should have responsibility over a single part of
    the application’s functionality. By separating the business logic from the presentation
    layer and adopting a **layered architecture**, we can ensure each part of our
    code handles its own specific responsibility, leading to a more modular and maintainable
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: Lack of tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine building a shopping cart component for an online store. The cart is
    crucial as it handles item additions, removals, and total price calculations.
    As straightforward as it may seem, it embodies various moving parts and logic
    interconnections. Without tests, you leave the door open for future problems,
    such as incorrect pricing, items not being added or removed correctly, or even
    security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this simplistic version of a shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: While this shopping cart’s logic appears straightforward, potential pitfalls
    are lurking. What if an item gets added multiple times erroneously, or prices
    change dynamically, or discounts are applied? Without tests, these scenarios might
    not be evident until a user encounters them, which could be detrimental to the
    business.
  prefs: []
  type: TYPE_NORMAL
- en: Enter `ShoppingCart` component, it means having tests verifying that items are
    correctly added or removed, total calculations are adjusted appropriately, and
    edge cases, such as handling discounts, are managed. Only after these tests are
    in place should the actual component logic be implemented. TDD is more than just
    catching errors early; it champions well-structured, maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: For the `ShoppingCart` component, adopting TDD would necessitate tests ensuring
    items get added or removed as expected, totals are correctly computed, and edge
    cases are tackled seamlessly. This way, as the application grows, the foundational
    TDD tests ensure each modification or addition maintains the application’s integrity
    and correctness.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicated code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s a familiar sight in many code bases – chunks of identical or very similar
    code scattered across different parts of the application. Duplicated code not
    only bloats the code base but also introduces potential points of failure. When
    a bug is detected or an enhancement is needed, every instance of the duplicated
    code may need to be altered, leading to an increased likelihood of introducing
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider two components in which the same filtering logic is repeated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The **DRY** (**don’t repeat yourself**) **principle** comes to the rescue here.
    By centralizing common logic into utility functions or **higher-order components**
    (**HOCs**), the code becomes more maintainable and readable, and less prone to
    errors. For this example, we could abstract the filtering logic and reuse it,
    ensuring a singular source of truth and easier updates.
  prefs: []
  type: TYPE_NORMAL
- en: Long component with too much responsibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React encourages the creation of modular, reusable components. However, as features
    get added, a component can quickly grow in size and responsibility, turning into
    an unwieldy behemoth. A long component that manages various tasks becomes difficult
    to maintain, understand, and test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine an `OrderContainer` component that has a huge prop list that includes
    a lot of different aspects of the responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Such a component violates the `OrderContainer` component and separate the supporting
    logic into other smaller, focused components or utilize Hooks for logic separation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: These listed anti-patterns have different variations, and we’ll discuss the
    solutions correspondingly in the following chapters. Apart from that, there are
    also some more generic design principles and design patterns we’ll discuss in
    the book, as well as some proven engineering practices, such as refactoring and
    TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Unveiling our approach to demolishing anti-patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to addressing prevalent anti-patterns, an arsenal of design patterns
    comes to the fore. Techniques such as **render props**, HOCs, and **Hooks** are
    instrumental in augmenting component capabilities without deviating from their
    primary roles, while leveraging foundational patterns such as layered architecture
    and separation of concerns ensures a streamlined code base, demarcating logic,
    data, and presentation in a coherent manner. Such practices don’t just elevate
    the sustainability of React apps but also lay the groundwork for effective teamwork
    among developers.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, **interface-oriented programming**, at its core, zeroes in on tailoring
    software centered around the interactions occurring between software modules,
    predominantly via interfaces. Such a modus operandi fosters agility, rendering
    software modules not only more coherent but also amenable to alterations. The
    **headless components** paradigm, on the other hand, embodies components that,
    while devoid of direct rendering duties, are entrusted with the management of
    state or logic. These components pass the baton to their consuming counterparts
    for UI rendering, thus championing adaptability and reusability.
  prefs: []
  type: TYPE_NORMAL
- en: By gaining a firm grasp on these design patterns and deploying them judiciously,
    we’re positioned to circumvent prevalent missteps, thereby uplifting the stature
    of our React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Plus, within the coding ecosystem, the twin pillars of TDD and consistent refactoring
    emerge as formidable tools to accentuate code quality. TDD, with its clarion call
    of test-before-code, furnishes an immediate feedback loop for potential discrepancies.
    Hand-in-hand with TDD, the ethos of persistent refactoring ensures that code is
    perpetually optimized and honed. Such methodologies not only set the benchmark
    for code excellence but also instill adaptability to forthcoming changes.
  prefs: []
  type: TYPE_NORMAL
- en: As we navigate the realm of refactoring, it’s pivotal to delve into the essence
    of these techniques, discerning their intricacies and optimal application points.
    Harnessing these refactoring avenues promises to bolster your code’s clarity,
    sustainability, and overarching efficiency. This is something that we’ll be doing
    throughout the book!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the challenges of UI development from its complexities
    to state management issues. We also discussed the common anti-patterns due to
    the nature of its complexity, and briefly introduced our approach that combines
    best practices and effective testing strategies. This sets the foundation for
    more efficient and robust frontend development.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we’ll dive deep into React essentials, giving you the
    tools and knowledge you need to master this powerful library. Stay tuned!
  prefs: []
  type: TYPE_NORMAL
