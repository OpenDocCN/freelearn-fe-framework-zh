- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Structuring Large-Scale, Multi-Platform Projects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化大型、多平台项目
- en: I wholeheartedly believe that the structure of a software project is one of
    the key factors in deciding success or failure. This includes the application
    architecture, as well as the development process and the whole project organization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我坚信，软件项目的结构是决定成功或失败的关键因素之一。这包括应用程序架构、开发过程以及整个项目组织。
- en: The bigger the project is, the more developers that work on the project, and
    the longer a project runs, the more important it is to have a good project structure.
    But small projects can also fail because of a bad structure. So, most of this
    chapter is also applicable to smaller projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 项目越大，参与项目的开发者越多，项目运行时间越长，良好的项目结构就越重要。但小型项目也可能因为结构不良而失败。因此，本章的大部分内容也适用于小型项目。
- en: The project structure is especially important when using React Native to develop
    an application for multiple platforms, not only for iOS and Android. Different
    platforms have different needs and bring different user expectations. The best
    example to showcase this is the difference between iOS and Android and the web.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 React Native 开发适用于多个平台的应用程序时，项目结构尤为重要，不仅限于 iOS 和 Android。不同的平台有不同的需求，并带来不同的用户期望。展示这一点的最佳例子是
    iOS、Android 和网页之间的差异。
- en: As already mentioned in [*Chapter 4*](B16694_04.xhtml#_idTextAnchor079), *Styling,
    Storage, and Navigation in React Native*, the concept of navigation in a mobile
    app and a web app is completely different. This is something you have to think
    about when planning the structure of your project.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如已在[*第 4 章*](B16694_04.xhtml#_idTextAnchor079)中提到的，*React Native 中的样式、存储和导航*，移动应用程序和网页中的导航概念完全不同。在规划项目结构时，您必须考虑这一点。
- en: 'The problem with investing in good architecture and a good project structure
    is that it always creates some overhead in the beginning. The following figure
    shows the dilemma:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在投资良好的架构和良好的项目结构时的问题在于，它总是在一开始就产生一些额外开销。以下图显示了这种困境：
- en: '![Figure 10.1 – Coding productivity reduces when the project grows over time'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.1 – 随着项目随时间增长，编码生产力降低'
- en: '](img/B16694_10_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16694_10_01.jpg)'
- en: Figure 10.1 – Coding productivity reduces when the project grows over time
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 随着项目随时间增长，编码生产力降低
- en: If you don’t invest in your architecture in the beginning, you will start with
    higher productivity. If you invest in your architecture, you have to think about
    what should be achieved, in which direction the project could potentially develop,
    and what usage, team size, and requirements you will have when your project reaches
    maximum success.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在开始时不投资于架构，您将拥有更高的生产力。如果您投资于架构，您必须考虑应该实现什么，项目可能向哪个方向发展，以及当项目达到最大成功时，您将有什么用途、团队规模和要求。
- en: These considerations take some time, and the implementation and execution of
    standardized processes may take even more time. It’s always faster to just download
    a random template and start coding. But as stated before, it will pay off in the
    end, because with good application architecture and a good project structure,
    you will end up with software that’s easy to maintain, test, and develop.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些考虑需要一些时间，实施和执行标准化流程可能需要更多时间。直接下载随机模板并开始编码总是更快。但如前所述，最终会得到回报，因为有了良好的应用程序架构和良好的项目结构，您最终会得到易于维护、测试和开发的软件。
- en: 'This is why you will learn about the following things in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您将在本章中学习以下内容：
- en: Setting up an app architecture that works for large-scale enterprise projects
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置适用于大型企业项目的应用程序架构
- en: Using React Native to deploy to different platforms
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Native 部署到不同的平台
- en: Reusing code with your own libraries
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您自己的库重用代码
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to run the code in this chapter, you have to set up the following
    things:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码，您必须设置以下内容：
- en: A working React Native environment ([bit.ly/prn-setup-rn](https://bit.ly/prn-setup-rn)
    – React Native CLI Quickstart).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 React Native 环境 ([bit.ly/prn-setup-rn](https://bit.ly/prn-setup-rn) –
    React Native CLI 快速入门)。
- en: 'You can find the example project in this repository: [https://bit.ly/prn-videoexample](https://bit.ly/prn-videoexample).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在本存储库中找到示例项目：[https://bit.ly/prn-videoexample](https://bit.ly/prn-videoexample)。
- en: While most of this chapter should also work on Windows, I would recommend working
    on a Mac.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然本章的大部分内容也应该适用于 Windows，但我建议在 Mac 上进行操作。
- en: This chapter contains some native code. You should have basic knowledge of Java
    or Kotlin and Objective-C or Swift for that.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章包含一些原生代码。您应该对Java或Kotlin以及Objective-C或Swift有基本了解。
- en: Setting up an app architecture that works for large-scale enterprise projects
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为大型企业项目设置一个适用的应用架构
- en: When we are talking about large-scale projects and how to set up a suitable
    app architecture, it makes sense to look at what’s different in these large-scale
    projects compared to small-team or even single-developer projects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论大型项目以及如何设置一个合适的应用架构时，看看这些大型项目与小型团队或单个开发者项目相比有什么不同是有意义的。
- en: 'The following points are the most important ones:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最重要的几点：
- en: '**The project team is very big**: In large-scale projects, you usually have
    a big team with lots of developers. Often, these developers are scattered all
    over the world, which means they work in different time zones, have different
    first languages, and have completely different cultural backgrounds. That said,
    it is important to have a clear structure and clear responsibilities. Otherwise,
    your project will fail.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目团队非常大**：在大型项目中，你通常有一个由许多开发者组成的庞大团队。通常，这些开发者遍布世界各地，这意味着他们处于不同的时区，使用不同的第一语言，并且有着完全不同的文化背景。因此，拥有一个清晰的结构和明确的责任是非常重要的。否则，你的项目将会失败。'
- en: '**Multiple developers will work on the same part of the application**: At the
    latest stage when a deadline is approaching and a feature has to be finished,
    multiple developers will work on the same feature and the same part of the application.
    This means you should think about how to structure your code so that this is possible
    without having conflicts all the time.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多个开发者将在应用程序的同一部分工作**：在最后期限即将到来，一个特性必须完成的时候，多个开发者将共同工作在同一个特性和应用程序的同一部分。这意味着你应该考虑如何组织你的代码，以便在没有冲突的情况下实现这一点。'
- en: '**Every error will be found by users**: In small projects with only a few users,
    it’s likely that a lot of errors will never be found. In large-scale applications
    with a lot of users, it is nearly impossible that errors will remain unrevealed.
    This means you have to put in a lot more effort to find the errors yourself before
    releasing your application to the public.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个错误都会被用户发现**：在只有少数用户的较小项目中，很多错误可能永远不会被发现。在拥有大量用户的规模较大的应用程序中，错误几乎不可能保持未被发现。这意味着在将应用程序发布给公众之前，你必须投入更多的努力来自己发现错误。'
- en: '**The code has to be tested programmatically**: The larger the project is,
    and the longer a project runs, the more important it is to programmatically test
    your code. At some point, it is impossible to handle all testing manually. This
    means you must have an app architecture that supports this automated testing very
    well.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码必须通过程序进行测试**：项目越大，运行时间越长，程序化测试你的代码就变得越重要。在某个时候，手动处理所有测试是不可能的。这意味着你必须有一个非常支持这种自动化测试的应用架构。'
- en: '**The code base will become very large**: As the term large-scale project already
    says, the project and its code base will become very large. This means you must
    provide a structure that makes it as easy as possible for new developers to understand
    what’s going on in the project.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码库将变得非常大**：正如“大型项目”这个术语所暗示的，项目和它的代码库将变得非常大。这意味着你必须提供一个结构，使得新开发者尽可能容易地理解项目中的情况。'
- en: With these points in mind, we’ll try to find some architectural approaches to
    support all of this.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些要点的基础上，我们将尝试找到一些支持所有这些的架构方法。
- en: Adapting our example project structure
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适应我们的示例项目结构
- en: The most important thing when the project grows is decomposition. This means
    you should try to split your components into small, meaningful segments wherever
    possible.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目增长时，最重要的就是分解。这意味着你应该尽可能地将你的组件拆分成小而意义明确的片段。
- en: 'When we look at the project structure of our example project, we have already
    done a good job of decomposing our application, and the architecture we chose
    works fine for our use case. It already contains some things I would recommend
    keeping, even in large-scale projects. These are the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看示例项目的项目结构时，我们已经很好地分解了我们的应用程序，并且我们选择的架构对于我们的用例来说效果良好。它已经包含了一些即使在大型项目中我也推荐保留的东西。以下就是这些内容：
- en: '**Using services**: Every API, SDK, or third-party connector should be wrapped
    in your own service. That enables you to change SDKs or even services and partners
    with minimal effort.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用服务**：每个 API、SDK 或第三方连接器都应该被封装在你的服务中。这样，你可以以最小的努力更改 SDK 或服务以及合作伙伴。'
- en: '**The separation between components and views**: Reusable components and navigable
    views should be kept in separate folders. This makes it easier for new developers
    to find the views they are working on.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件和视图的分离**：可重用的组件和可导航的视图应保存在不同的文件夹中。这使得新开发者更容易找到他们正在工作的视图。'
- en: 'However, this approach also brings some problems with it, especially when the
    code base grows and multiple developers work on it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法也带来了一些问题，尤其是在代码库增长且多个开发者共同工作时：
- en: Components and views are hard to test programmatically
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件和视图难以通过程序进行测试
- en: The component directory will grow really fast and become really big
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件目录将迅速增长并变得非常大
- en: Single features will be hard to find and are scattered over the whole code base
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个功能将难以找到，并且散布在整个代码库中
- en: The code base as a whole will get quite confusing
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个代码库将变得相当混乱
- en: Multiple developers will have to touch the same files at the same time a lot
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多开发者将不得不同时触摸相同的文件
- en: 'So, we’ll make some adaptations to our approach. First, we’ll take care of
    the component level. So far, we write our component with its business logic, UI,
    style, and types in one file. This will change now. We’ll split our components
    into the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将对我们的方法进行一些调整。首先，我们将关注组件级别。到目前为止，我们将在一个文件中编写组件的业务逻辑、UI、样式和类型。现在将发生变化。我们将把我们的组件拆分为以下：
- en: '`index.tsx`: The `index` file contains the business logic of the component
    such as data fetching, as well as the connection to the global application state.
    It only renders the following `.view` component.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.tsx`：`index` 文件包含组件的业务逻辑，如数据获取，以及与全局应用程序状态的连接。它只渲染以下 `.view` 组件。'
- en: '`<component>.view.tsx`: The `view` file contains the UI. It doesn’t hold its
    own state nor does it connect directly to the global application state. It only
    renders the props it gets from the `index` file.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<component>.view.tsx`：`view` 文件包含 UI。它不保留自己的状态，也不直接连接到全局应用程序状态。它只渲染从 `index`
    文件获得的属性。'
- en: '`<component>.styles.tsx`: The `styles` file contains the React Native StyleSheet
    or the styled-components, depending on which approach you chose.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<component>.styles.tsx`：`styles` 文件包含 React Native StyleSheet 或 styled-components，具体取决于你选择的方法。'
- en: '`<component>.types.tsx`: The `types` file provides the data type for props
    and the state of the `index` and `view` files.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<component>.types.tsx`：`types` 文件提供了 `index` 和 `view` 文件的属性和状态的数据类型。'
- en: With this separation, we enable two things. First, it is much easier to have
    one developer work on the business logic and one on the UI, without creating merge
    conflicts or other problems. Second, our components now have much better support
    for automated testing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种分离，我们实现了两个目标。首先，一个开发者更容易处理业务逻辑，另一个处理 UI，而不会产生合并冲突或其他问题。其次，我们的组件现在对自动化测试的支持更好。
- en: We can use any component testing framework to render and test the views without
    having to mock our global state or our component state. And in addition to that,
    it’s much easier to integrate tools such as Storybook with this approach.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用任何组件测试框架来渲染和测试视图，而无需模拟我们的全局状态或组件状态。此外，使用这种方法集成工具（如 Storybook）也容易得多。
- en: To see that approach in action, you can have a look at the GitHub repository,
    choose the `chapter-10-split-home-view` tag, and check out the `views/home` folder.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看该方法的实际应用，你可以查看 GitHub 仓库，选择 `chapter-10-split-home-view` 标签，并查看 `views/home`
    文件夹。
- en: Hint
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: To ensure that everyone sticks to this pattern and to make it simpler to create
    new views and components, you can use file generators. These are small scripts
    that use a template and typically a component name to create the structure you
    want to have. You can see an example in the GitHub repository. Choose the `chapter-10-generator`
    tag and have a look at the `util` folder. You can use the generator with `npm
    run generate <name>` to generate a new view.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保每个人都遵循这种模式，并使创建新的视图和组件更简单，你可以使用文件生成器。这些是小脚本，使用模板和通常是一个组件名称来创建你想要的结构。你可以在
    GitHub 仓库中看到一个示例。选择 `chapter-10-generator` 标签，查看 `util` 文件夹。你可以使用生成器通过 `npm run
    generate <name>` 来生成新的视图。
- en: After this change on the component level, we’ll take a step back and look at
    the whole project again. The second change I would recommend when your project
    grows is to group your views and components by features. This makes it much easier
    to understand the whole project structure and navigate through the code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件级别进行此更改后，我们将退后一步，再次审视整个项目。当你项目增长时，我推荐的第二个更改是按功能对视图和组件进行分组。这使得理解整个项目结构并导航代码变得容易得多。
- en: 'I must admit that this depends on personal preferences and some people also
    like the clear separation between components and views even in large-scale projects,
    but I prefer the feature approach. This approach works as shown in the following
    figure:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，这取决于个人偏好，有些人甚至喜欢在大型项目中组件和视图之间清晰的分离，但我更喜欢功能方法。这种方法如图所示：
- en: '![Figure 10.2 – A React Native feature-grouped architecture'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 – React Native特征分组架构]'
- en: '](img/B16694_10_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片/B16694_10_02.jpg]'
- en: Figure 10.2 – A React Native feature-grouped architecture
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – React Native特征分组架构
- en: This approach groups the application by features. It also has a component folder,
    which contains very basic general components such as buttons, lists, and avatars
    – basically, things that are used in every feature of your app to provide a consistent
    user experience. But every feature also has its own component folder where you
    can put components that you created only for this feature. There is also a modification
    of this approach, where you put multiple views in one feature.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法按功能对应用程序进行分组。它还有一个组件文件夹，其中包含非常基本的通用组件，如按钮、列表和头像——基本上，这些是在你的应用程序的每个功能中使用的，以提供一致的用户体验。但每个功能也有自己的组件文件夹，你可以将只为这个功能创建的组件放入其中。还有对这个方法的修改，即将多个视图放在一个功能中。
- en: From my personal experience, I can say that this feature approach makes the
    code base very clearly structured, and it makes it easier to find what you are
    searching for. On the other hand, you’ll always have components where you are
    unsure whether you have to put them into the general components or not.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的个人经验来看，我可以这样说，这种功能方法使代码库结构非常清晰，并且使查找你正在寻找的内容变得更容易。另一方面，你总会遇到一些组件，你不确定是否应该将它们放入通用组件中。
- en: In the end, you’ll have to find your own approach to how you want to structure
    your application. But in this section, you learned about the most important things
    you have to pay attention to in order to create a structure that works even when
    your project scales.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你必须找到自己想如何构建应用程序结构的方法。但在本节中，你学习了为了创建即使在项目扩展时也能正常工作的结构，你必须注意的最重要的事情。
- en: Now that you have learned how to structure a React Native project in general,
    we’ll go a step further and focus on going multi-platform.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何一般性地构建React Native项目，我们将更进一步，专注于多平台开发。
- en: Using React Native to deploy to different platforms
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Native部署到不同平台
- en: In this section, you’ll learn how to set up your React Native project to be
    able to support multiple platforms. Since it is the most common use case, we’ll
    focus a lot on the web here, but the tips and approaches of these sections are
    also applicable to other platforms such as desktops and TVs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何设置你的React Native项目以支持多个平台。由于这是最常见的情况，我们将在这里大量关注Web，但本节中的提示和方法也适用于其他平台，如桌面和电视。
- en: When creating an application for multiple platforms, there are always two goals.
    First, you want to support as many platform-specific features as possible and
    want to give users the look and feel they are used to on this platform. Second,
    you try to have as much shared code as possible because this makes it easier to
    maintain and develop your application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当为多个平台创建应用程序时，始终有两个目标。首先，你希望尽可能支持更多平台特定的功能，并希望为用户提供他们在该平台上习惯的外观和感觉。其次，你试图尽可能多地共享代码，因为这使维护和开发你的应用程序更容易。
- en: At first sight, these goals seem to be concurrent but there are intelligent
    ways to get the best of both worlds. Let’s start with the simplest approach.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，这些目标似乎相互矛盾，但有一些智能的方法可以同时获得两者的最佳效果。让我们从最简单的方法开始。
- en: Using react-native-web to create a clone for web
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用react-native-web创建Web克隆
- en: When creating your application with React Native, you can use a library called
    `react-native-web` to run your React Native app on the web.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用React Native创建应用程序时，你可以使用一个名为`react-native-web`的库来在Web上运行你的React Native应用程序。
- en: Before we start, you have to understand what `react-native-web` does. Basically,
    it maps all React Native components to HTML components. For example, a `<View/>`
    component will get `<div/>`. It also maps the native API calls of React Native
    to use the browser APIs wherever available. This means you’ll get a plain React
    application for the web.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，你必须理解 `react-native-web` 是做什么的。基本上，它将所有 React Native 组件映射到 HTML 组件。例如，一个
    `<View/>` 组件将得到 `<div/>`。它还将 React Native 的原生 API 调用映射到浏览器 API，只要可用。这意味着你将得到一个普通的
    React 网页应用程序。
- en: While `react-native-web` is a great library, it is not that easy to get started
    with it because you have to set up a separate build process to use it. This build
    process will create a standalone React web application. Like every React web application,
    it needs a bundler to create optimized browser-readable JavaScript code. A very
    popular solution is Webpack, which we will use for our web app as well. Also,
    every web application needs an entry point. In most cases, this is an `index.html`
    file, which then loads the JavaScript bundle that contains the React application.
    So, we’ll have to add this to our project.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `react-native-web` 是一个很棒的库，但要开始使用它并不容易，因为您必须设置一个单独的构建过程来使用它。这个构建过程将创建一个独立的
    React 网页应用程序。像每个 React 网页应用程序一样，它需要一个打包器来创建优化的浏览器可读 JavaScript 代码。一个非常流行的解决方案是
    Webpack，我们也将使用它来构建我们的网页应用程序。此外，每个网页应用程序都需要一个入口点。在大多数情况下，这是一个 `index.html` 文件，然后加载包含
    React 应用的 JavaScript 包。因此，我们必须将其添加到我们的项目中。
- en: 'The whole process of setting up web support is described in a very detailed
    manner in the `react-native-web` documentation (which you can see here: https://bit.ly/prn-rn-web),
    but at the time of writing, this documentation is missing TypeScript support.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `react-native-web` 文档中（您可以通过以下链接查看：https://bit.ly/prn-rn-web）以非常详细的方式描述了设置网页支持的全过程，但撰写本文时，该文档缺少
    TypeScript 支持。
- en: So, I’ll describe the most important thing while we set up basic web support
    for our example application. You can find the complete working setup in the GitHub
    repository when choosing the `chapter-10-web` tag.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们在示例应用程序中设置基本的网页支持时，我将描述最重要的内容。您可以在选择 `chapter-10-web` 标签时在 GitHub 仓库中找到完整的完整设置。
- en: Installing react-native-web
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 react-native-web
- en: 'We’ll start with adding `react-native-web` and `react-dom` to our project.
    Please use the correct version of `react-dom`. Since we are using React 17 in
    our React Native app, we’ll have to use `react-dom@17`. These libraries are necessary
    to create the React app. The installation can be done via `npm`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从添加 `react-native-web` 和 `react-dom` 到我们的项目开始。请使用正确的 `react-dom` 版本。由于我们在
    React Native 应用中使用 React 17，因此我们必须使用 `react-dom@17`。这些库是创建 React 应用所必需的。安装可以通过
    `npm` 完成：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Otherwise, it can be done via `yarn`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，可以通过 `yarn` 来完成：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have installed `react-native-web`, we’ll need to handle the build
    process and the development environment for the web.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 `react-native-web`，我们需要处理网页的构建过程和开发环境。
- en: Installing webpack
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 webpack
- en: To do so, we’ll add Webpack, the corresponding CLI, and a Webpack extension
    called `webpack-dev-server`. This extension provides a built-in development server
    that supports live reloading while you develop your application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将添加 Webpack、相应的 CLI 以及一个名为 `webpack-dev-server` 的 Webpack 扩展。这个扩展提供了一个内置的开发服务器，在您开发应用程序时支持实时重新加载。
- en: 'The installation of these `npm` libraries can be done with the following `npm`
    command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `npm` 库的安装可以通过以下 `npm` 命令来完成：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Otherwise, you can use a `yarn` command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你可以使用一个 `yarn` 命令：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In addition to this basic Webpack setup, we’ll also install two loaders. Loaders
    are a core concept of Webpack. They enable you to preprocess files and decide
    how they should be used in your bundle. We’ll make use of the following loaders:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个基本的 Webpack 设置之外，我们还将安装两个加载器。加载器是 Webpack 的一个核心概念。它们使您能够预处理文件并决定它们应该如何在您的包中使用。我们将使用以下加载器：
- en: '`ts-loader`: This is a loader that preprocesses our TypeScript files and converts
    them to browser-readable JavaScript'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ts-loader`：这是一个预处理我们的 TypeScript 文件并将其转换为浏览器可读 JavaScript 的加载器'
- en: '`file-loader`: This loader copies our asset binaries such as images in our
    final bundle'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file-loader`：这个加载器将我们的资产二进制文件（如图像）复制到我们的最终包中'
- en: The last thing we need for our web build process to work is `html-webpack-plugin`.
    This plugin creates our entry point. It writes an `index.html` by loading an HTML
    template and adding the created JavaScript bundle.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的网页构建过程工作的最后一件事是 `html-webpack-plugin`。这个插件创建我们的入口点。它通过加载 HTML 模板并添加创建的
    JavaScript 包来写入 `index.html`。
- en: 'These additions can be installed with the following `npm` command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些添加可以通过以下`npm`命令安装：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Otherwise, install with the following `yarn` command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，使用以下`yarn`命令安装：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have installed all tools, we have to configure our project.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所有工具，我们必须配置我们的项目。
- en: Configuring the React Native project to work for web
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置React Native项目以支持Web
- en: First, let’s create a JavaScript entry point for our application. To do so,
    we’ll create `index.web.js` in the root folder of the application. This contains
    the following code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为我们的应用程序创建一个JavaScript入口点。为此，我们将在应用程序的根目录中创建`index.web.js`。这包含以下代码。
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We use React Native `AppRegistry` to load our `<App />` component via the `registerComponent`
    function and then run our application with `runApplication`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用React Native的`AppRegistry`通过`registerComponent`函数加载我们的`<App />`组件，然后通过`runApplication`运行我们的应用程序。
- en: '`runApplication` needs an HTML node as `rootTag` for the web. This HTML node
    will be replaced with the React application during `runApplication`. In our case,
    we’ll get the element with the `movie-root` ID from the HTML document.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`runApplication`需要一个HTML节点作为`rootTag`来支持Web。这个HTML节点将在`runApplication`期间被React应用程序替换。在我们的例子中，我们将从HTML文档中获取带有`movie-root`
    ID的元素。'
- en: 'Next, we’ll create a `web/` folder in the `root` folder of our project. In
    this folder, we’ll put an `index.html` template with the following content (please
    refer to the GitHub repository for the complete file):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在项目的`root`文件夹中创建一个`web/`文件夹。在这个文件夹中，我们将放置一个包含以下内容的`index.html`模板（请参考GitHub仓库以获取完整文件）：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the head of the document, we define a title and some styles. The styles are
    important for the `react-native-web` application to show. The body only contains
    an empty `<div />` with the `#movie-root` ID. This is the container we use in
    our JavaScript entry point.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档的头部，我们定义了一个标题和一些样式。这些样式对于`react-native-web`应用程序的显示非常重要。主体部分只包含一个空的`<div />`元素，并带有`#movie-root`
    ID。这是我们用于JavaScript入口点的容器。
- en: 'Next, we’ll have to configure our Webpack builder. To do so, please create
    `webpack.config.js` in the `web/` folder. The following code snippet shows the
    most important configurations. For the complete file, please look at the GitHub
    repository:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须配置我们的Webpack构建器。为此，请在`web/`文件夹中创建`webpack.config.js`。以下代码片段显示了最重要的配置。对于完整文件，请查看GitHub仓库：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s work through this configuration from top to bottom. First, we defined
    our JavaScript entry point. Here, we put the `index.web.js` file we just created.
    Then, we defined our output. In this case, it’s the `dist/` directory and a JS
    bundle with a hash value in the name to ensure that we have new filenames with
    every new build to prevent browser caching issues.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头到尾处理这个配置。首先，我们定义了我们的JavaScript入口点。在这里，我们放置了我们刚刚创建的`index.web.js`文件。然后，我们定义了我们的输出。在这种情况下，它是`dist/`目录和一个带有哈希值的JS包，以确保每次构建都有新的文件名，以防止浏览器缓存问题。
- en: In the `module` section, we can define rules for which loaders should be used
    to preprocess which files. We use a Regex to test the filenames against and define
    loaders for all matching files. In this example, we use `ts-loader` for all files
    that include `.tsx`, `.ts`, `.jsx`, or `.js`, except everything in the `node_modules`
    folder.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`module`部分，我们可以定义规则来指定哪些加载器应该用于预处理哪些文件。我们使用正则表达式来测试文件名，并为所有匹配的文件定义加载器。在这个例子中，我们为包含`.tsx`、`.ts`、`.jsx`或`.js`的所有文件使用`ts-loader`，除了`node_modules`文件夹中的所有内容。
- en: In the next section of the file, we defined which plugins we’ll use. In our
    case, it’s only `HTMLWebpackPlugin` to create our entry point `index.html` from
    our template HTML file. The last part of the `config` file is the `resolve` section.
    Here is where the magic of the transformation of a React Native to a plain React
    web application is happening.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的下一部分，我们定义了我们将使用哪些插件。在我们的例子中，只有`HTMLWebpackPlugin`用于从我们的模板HTML文件创建入口点`index.html`。`config`文件的最后一部分是`resolve`部分。在这里，React
    Native到普通React Web应用程序的转换魔法正在发生。
- en: By creating the `react-native-web` alias for `react-native`, we replace all
    occurrences of `react-native` with `react-native-web`. This means all imports
    that were fetched from `react-native` are now fetched from `react-native-web`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为`react-native`创建`react-native-web`别名，我们替换了所有`react-native`的实例，现在它们都来自`react-native-web`。这意味着所有从`react-native`获取的导入现在都来自`react-native-web`。
- en: 'Now that our build process for the web application works, we’ll have to make
    some small adaptations in our TypeScript setup:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们Web应用程序的构建过程已经工作，我们将在我们的TypeScript设置中进行一些小的调整：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We added `dom` to the `lib` section, changed the `jsx` mode to `react`, and
    switched `noEmit` from `true` to `false`. This is necessary to create the files
    in a way that Webpack can handle. With this step, the setup is complete.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`lib`部分添加了`dom`，将`jsx`模式改为`react`，并将`noEmit`从`true`改为`false`。这是为了以Webpack可以处理的方式创建文件。这一步完成后，设置就完成了。
- en: Running the React Native code as a React app in the browser
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在浏览器中以React应用运行React Native代码
- en: 'Now, we can start our React Native app as a React web application in `dev`
    mode from the command line. You can do so with the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从命令行以`dev`模式启动我们的React Native应用作为React Web应用。你可以使用以下命令来完成：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following screenshot shows our example movie app running in the browser:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的示例电影应用在浏览器中的运行情况：
- en: '![Figure 10.3 – Our example movie app running in the browser'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3 – 在浏览器中运行的我们的示例电影应用'
- en: '](img/B16694_10_03.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16694_10_03.jpg)'
- en: Figure 10.3 – Our example movie app running in the browser
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 在浏览器中运行的我们的示例电影应用
- en: '*Figure 10.3* shows the UI of the example movie app running in the browser.
    It works perfectly fine, running on the same code base as the native app. When
    you inspect the HTML with the browser’s inspection tools, you’ll see that all
    React Native components were transformed into HTML components.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.3* 展示了在浏览器中运行的示例电影应用的UI。它运行得非常完美，与原生应用使用相同的代码库。当你使用浏览器的检查工具检查HTML时，你会看到所有的React
    Native组件都被转换成了HTML组件。'
- en: 'As a final step of this section and to make development and creating production
    builds easier, we add two commands to the `scripts` section of `package.json`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的最后一步，为了使开发和创建生产构建更容易，我们在`package.json`的`scripts`部分添加了两个命令：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line is the command we just used to start our application in `dev`
    mode. The second line is to build the application in production mode for deployment.
    This writes the complete bundle to the `dist` folder, as we defined in `webpack.config.js`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是我们刚才用来以`dev`模式启动应用程序的命令。第二行是用来在生产模式下构建应用程序以进行部署的命令。这会将完整的包写入我们在`webpack.config.js`中定义的`dist`文件夹。
- en: In this subsection, you learned how to create a clone of your React Native app
    for the web. While this may work in some cases, most of the time, this isn’t enough.
    User expectations between web and mobile are different in most areas and you also
    may want to use different libraries for web and mobile that don’t support the
    other platform. A very easy solution for differentiating between different platforms
    is to make use of file endings.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，你学习了如何创建你的React Native应用在Web上的克隆。虽然这可能在某些情况下有效，但大多数时候这还不够。Web和移动用户在大多数领域的期望是不同的，你也可能希望使用Web和移动不同的库，这些库不支持其他平台。区分不同平台的一个非常简单的解决方案是利用文件扩展名。
- en: Working with .native and .web file endings
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用.native和.web文件扩展名
- en: 'As described in the previous subsection, we have two completely different build
    processes for web and native apps. While we configured our Webpack bundler to
    support `.web.ts` or `.web.tsx` files, the native Metro bundler supports `.native.ts`
    or `.native.tsx` files out of the box. This means that we can write platform-specific
    code by simply creating two versions of a file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一小节所述，我们对Web和原生应用有两个完全不同的构建过程。虽然我们配置了Webpack打包器以支持`.web.ts`或`.web.tsx`文件，但原生Metro打包器默认支持`.native.ts`或`.native.tsx`文件。这意味着我们可以通过简单地创建文件的两个版本来编写特定平台的代码：
- en: '`App.tsx` and `App.native.tsx` would result in our web application using `App.tsx`
    and our native application using `App.native.tsx`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.tsx`和`App.native.tsx`会导致我们的Web应用使用`App.tsx`，而我们的原生应用使用`App.native.tsx`'
- en: '`App.tsx` and `App.web.tsx` would result in our web application using `App.web.tsx`
    and our native application using `App.tsx`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.tsx`和`App.web.tsx`会导致我们的Web应用使用`App.web.tsx`，而我们的原生应用使用`App.tsx`'
- en: This approach can be used to share most of the code but make platform-specific
    versions of components. It can also be used to define different navigation stacks
    for the different platforms or use different navigation libraries by creating
    platform-specific `App.tsx` files.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以用来共享大部分代码，但为组件创建特定平台的版本。它也可以用来为不同的平台定义不同的导航堆栈，或者通过创建特定平台的`App.tsx`文件来使用不同的导航库。
- en: All in all, this approach is quite powerful but has some limits. For example,
    you’ll have to use the same versions of libraries you share between the platforms
    because both platforms share one `package.json` file. If you want to go one step
    further, you could either work with multiple packages in a `monorepo` or create
    your own libraries from the code you want to share, which you then import into
    different platform-specific projects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这种方法非常强大，但也存在一些限制。例如，你将不得不使用你在不同平台之间共享的库的相同版本，因为这两个平台共享一个`package.json`文件。如果你想更进一步，你可以要么在`monorepo`中处理多个包，要么从你想要共享的代码中创建自己的库，然后将这些库导入到不同的平台特定项目中。
- en: Let’s have a look at the `monorepo` approach first.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看`monorepo`方法。
- en: Working with multiple packages in a monorepo
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在单一代码库中处理多个包
- en: For structuring your multi-platform React Native app as a `monorepo`, I recommend
    using `yarn` workspaces. This is a way to set up multiple JavaScript packages
    in a single repository. `yarn` optimizes the libraries in terms of versions and
    storage. It also allows the packages to be linked together, which is the main
    reason why we are using it here.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将你的多平台React Native应用程序作为`monorepo`进行结构化，我建议使用`yarn`工作空间。这是在单个存储库中设置多个JavaScript包的方法。`yarn`在版本和存储方面优化库。它还允许包之间相互链接，这也是我们在这里使用它的主要原因。
- en: 'For more information on `yarn` workspaces, you can have a look at the official
    documentation ([https://bit.ly/prn-yarn-workspaces](https://bit.ly/prn-yarn-workspaces)).
    The following figure shows the structure of a multi-platform `monorepo` with `yarn`
    workspaces:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于`yarn`工作空间的信息，你可以查看官方文档([https://bit.ly/prn-yarn-workspaces](https://bit.ly/prn-yarn-workspaces))。以下图显示了具有`yarn`工作空间的多平台`monorepo`结构：
- en: '![Figure 10.4 – A multi-platform React Native monorepo based on workspaces'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 – 基于工作空间的多平台React Native单一代码库'
- en: '](img/B16694_10_04.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16694_10_04.jpg)'
- en: Figure 10.4 – A multi-platform React Native monorepo based on workspaces
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 基于工作空间的多平台React Native单一代码库
- en: You have the **Shared Code** package (often also called **App**), which can
    contain most parts of your application such as views, store, services, and components.
    This package isn’t started directly and has no native or web entry point. Then,
    you have one package for every platform.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个**共享代码**包（通常也称为**App**），它可以包含应用程序的大部分内容，如视图、存储、服务和组件。这个包不是直接启动的，也没有本地或Web入口点。然后，你为每个平台有一个包。
- en: Each of these packages has its own `package.json` file and can define its own
    libraries and versions. This setup even allows you to use different versions of
    the same library on different platforms, as long as your shared code supports
    all of them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包中的每一个都有自己的`package.json`文件，可以定义自己的库和版本。这种设置甚至允许你在不同的平台上使用同一库的不同版本，只要你的共享代码支持所有这些版本。
- en: The platform-specific packages contain the entry points, and I would also recommend
    putting platform-specific things such as navigation and the general application
    structure (layer stack or navigation tree) here. This makes it possible to not
    only create a clone of the same application for every platform but also to use
    very different approaches.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 平台特定包包含入口点，我也建议在这里放置平台特定的东西，如导航和一般的应用程序结构（层堆栈或导航树）。这使得不仅能够为每个平台创建相同应用程序的副本，而且还可以使用非常不同的方法。
- en: You could, for example, have a completely different layer stack on the web and
    mobile. This makes total sense because most of the time there are completely different
    needs for the different platforms. Some things you need on the web you don’t even
    want to have on your mobile app and vice versa.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以在Web和移动端有完全不同的层堆栈。这完全合理，因为大多数时候，不同平台的需求是完全不同的。有些你在Web上需要的东西甚至不想在移动应用中拥有，反之亦然。
- en: And there is another advantage of this package approach. There are a lot of
    frameworks based on React that perform a lot of web-specific optimizations such
    as supporting server-side rendering, adding browser history support to routing,
    or extensive web bundle optimizations. The most popular frameworks of this kind
    are **Next.js** and **Gatsby**. With this setup, you can use them for the web.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种包式方法还有另一个优点。基于React的框架有很多，它们执行了许多针对Web的特定优化，例如支持服务器端渲染、将浏览器历史支持添加到路由中，或者进行广泛的Web包优化。这类最受欢迎的框架是**Next.js**和**Gatsby**。使用这种设置，你可以为Web使用它们。
- en: 'If you want to start with this `monorepo` setup, I can recommend an excellent
    template that you can find here: [https://bit.ly/prn-rn-universal-monorepo](https://bit.ly/prn-rn-universal-monorepo).
    This template not only supports mobile and the web but also a couple of other
    frameworks and platforms such as Next.js, Electron, desktop, and even browser
    extensions. There is also a good description that guides you through the setup
    process, which you can find here: [https://bit.ly/prn-rn-anywhere](https://bit.ly/prn-rn-anywhere).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, we created different packages for different platforms for
    the first time. In this scenario, we only used a single repository, because that
    makes development quite easy. We just have to clone the repository, install the
    dependencies, and we are ready to go.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: I really like this approach, but when the code base and the team grow a lot,
    it definitely makes sense to go one step further. To create a clearer separation
    of the different parts of the application with clear responsibilities, you can
    split the application into different projects. This means you will create your
    own libraries.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Reusing code with your own libraries
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many good reasons to create your own library. Sharing code between
    different projects for different platforms is definitely one of them. But with
    your own library, you can also achieve the following things:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '**Ensure consistent design in all your applications**: When you are working
    in a company that provides multiple applications, it’s a good idea to create a
    UI library that provides UI components for all these applications. This ensures
    a consistent design system.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplify backend connection**: You can extract your services to a library,
    which can then be used in all your projects. This ensures a unified backend connection
    layer.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Define responsibilities**: Every library can be maintained by its own maintainer
    or team. With this library approach, you can define clear responsibilities.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provide additional functionality**: You can also write your own library to
    provide native functionality that isn’t available in the way you need it from
    any community module. In this case, I would always recommend providing this functionality
    in the form of its own library (and making it available to the community if possible).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Most of the community modules out there started because someone had a problem
    that hadn’t been solved. If you are in a position to be able to solve a problem
    with a new library or module, I would highly recommend sharing it with the community.
    Even if you don’t want to do it for altruistic reasons, it can be a very good
    thing. Often, you can find others that share the same challenges and you can create
    a better solution together.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Creating our own library can be quite challenging. You can find a lot of tutorials
    and blog posts online on how to create the perfect setup for your own library.
    Some of them are good – some of them are bad. But instead of using one of them,
    I recommend a wrapper of tools called `react-native-builder-bob`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Using react-native-builder-bob to write, maintain, and publish our own libraries
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This tool makes the process of writing, maintaining, and publishing your own
    library very easy. It is created and maintained by a company called **Callstack**,
    which is very active in the React Native community and even contributes to the
    core of React Native.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: They use `react-native-builder-bob` for their own libraries and a lot of the
    most popular libraries also do.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start creating your own library with `react-native-builder-bob` preconfigured
    using this simple command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This command will start the setup process and guide you through it with a couple
    of questions. The following screenshot shows this process:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Creating your own library with create-react-native-library'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16694_10_05.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Creating your own library with create-react-native-library
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: After answering questions about the author and the package, which are needed
    to create the `package.json`, `create-react-native-library` will ask you what
    type of library you want to develop.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'You can choose between the following options:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**Native module/Native view**: You should choose this if your module contains
    native code. These options use the current bridge architecture to communicate
    between JavaScript and native.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JavaScript library**: You should choose this if your module does not contain
    any native code. Most use cases such as simple UI libraries, service SDKs, and
    state providers fall in this category. Also, this is the correct type when you
    use other libraries that contain native code but your own library is a JavaScript-only
    library.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Turbo module**: At the time of writing, this type is in the experimental
    phase. This creates a native module based on the new React Native architecture
    (see the *Introducing the new React Native architecture* section from [*Chapter
    3*](B16694_03.xhtml#_idTextAnchor061), *Hello React Native*).'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll start by creating a JavaScript-only library. Imagine that we created our
    example application as one of many applications for a huge corporation. Because
    the management likes the design, they want all future applications to be able
    to stick to our design system. Therefore, we want to provide our `StyleConstants`
    file in our own library as the first step in setting up our corporate design system.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Creating a JavaScript-only library
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To start our own JavaScript-only library, we’ll choose `create-react-native-library`
    dropdown. `create-react-native-library` creates our library with a set of preconfigured
    tools, predefined scripts, a simple multiply function as the source, and even
    an example application to showcase the library. If you want to see a working example,
    you can have a look at the GitHub repository here: [https://bit.ly/prn-repo-styles-library](https://bit.ly/prn-repo-styles-library).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: When we check the `root` folder of our newly created library, we’ll find a lot
    of files we already know from our application. There is a `babel.config.js` file
    to define how Babel should transform our code, a `package.json` file, which contains
    information about the package, as well as all dependencies and scripts, and there
    is a `tsconfig.json` file, which contains all the information for the TypeScript
    compiler.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll have a deeper look at `package.json`. Besides all the predefined
    information and configuration, I want to point out two important things. The first
    one is the information about where to find which parts of our library. This is
    what you see in the following code snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'While we are creating our library in TypeScript, it will be compiled to pre-ES6
    JavaScript by `react-native-builder-bob`, so that it will work in every React
    Native project, no matter what stack it is using (TypeScript, Flow, Plain JS,
    or Expo). This means the code of our library ships in different ways. That’s what’s
    defined in the following properties:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '`main`: This is the main entry point of your library. When you import anything
    from your library, this is the path where your project will look for exports.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`types`: Since we are using TypeScript `react-native-builder-bob` creates types
    for our code so that everyone who uses typed JavaScript can work with the types
    we created.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source`: This is where the uncompiled source code can be found.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we are only working in the `source` directory, the projects that use our
    library will only work with `main` and `types`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The second thing I want you to have a look at is the `scripts` section, above
    all the following scripts.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These scripts are the most essential part of this library setup. With the `prepare`
    script, you can run the `build` command of `react-native-builder-bob`. It will
    compile your library and provide the entry points you have just learned about.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The `release` script will use the `release-it` library to create a new release
    of your library. This initiates a guided process that will do the following things:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Update the library version
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a changelog
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish your library to `npm`
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commit the library version update to `git`
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `git` tag
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push the changes to the remote repository
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a release on GitHub
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This script is very useful because it forces you to stick to best practices
    in terms of releasing and tagging your library.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how the library project is structured, let’s use this library
    to publish our styles. Since we already collected all our style information in
    our `StyleConstants` file, this is simple.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `src/index.tsx` file of the library project and paste the contents
    of the `StyleConstants.ts` file. Next, commit the changes and build and publish
    the library with the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: You need to create a free account at [https://www.npmjs.com/](https://www.npmjs.com/)
    and log in from the command line with `npm login` to be able to publish your library.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'After you publish your library package, you can install it in your project.
    You can use the regular `npm` command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Alternatively, you can use the `yarn` command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that you are able to access your styles via your library, you can delete
    your `StyleConstants.ts` file and replace all imports with your library. The following
    figure shows the change for `Home.styles.tsx`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Importing a change from a local file to a library'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16694_10_06.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – Importing a change from a local file to a library
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the imports stay the same, only the `from` path changes to the
    library. You have to do this in all files where you used `StyleConstants`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: As you learned in this subsection, the process of creating your own library
    is quite complex, but it gets a lot easier when you work with the right tools.
    But since our example was a JavaScript-only library, it was the easiest type of
    React Native library. It gets more complex when adding native code to your library.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difference between native libraries
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you already know, React Native has a JavaScript part and a native part. This
    means we can make use of native platform-specific code when we want to. This not
    only works with app projects but also with libraries. Native code is written in
    platform-specific languages such as Kotlin or Java for Android or Swift or Objective-C
    for iOS.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: But it isn’t only the language that differs from platform to platform. The process
    of how the application manages its third-party packages and how to build and deploy
    is completely different.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Android uses Gradle to fetch packages and build your app. For iOS, there are
    multiple package managers but React Native relies heavily on CocoaPods. The build
    is done via Xcode.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: This means when you are adding native code to your library, you not only have
    to deliver and import your JavaScript code but you also have to provide the native
    code and add it to the native build process that gets included in the native bundle.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: With this setup, your native code also gets included in your library bundle.
    To be able to write native code, you have to choose `Native Module` when creating
    your library with `create-react-native-library`. This will create two additional
    folders (`android` and `ios`) that contain the native code, as well as the configuration
    files for the native build process.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: For Android, this is a `build.gradle` file, which can be found in the `android`
    folder. For iOS, this is a `.podspec` file, which can be found in the `root` folder
    of the library.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: All these files are created for you, so you shouldn’t need to change them. When
    installing your library with native code, React Native autolinking will take care
    of everything for you on Android. On iOS, you’ll have to run `npx pod-install`
    to include the native part of your library in the native project.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are able to create pure JavaScript libraries and libraries with
    native code, we’ll take another look at how to provide them. We used the public
    `npm` registry to host our library as a public package.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: While I really like the approach of sharing everything with the community, you
    may have the requirement to keep your libraries private, especially when they
    are important parts of corporate applications. The next subsection will show you
    how to only provide access to your libraries to selected people.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Setting access restrictions on libraries
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some ways to share your library only with selected people. These
    two are the most common ones:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '**Use a paid npmjs.com plan**: You can define permissions on your packages
    when using a paid [npmjs.com](https://npmjs.com) plan. This means that only people
    you explicitly allow will have access to your package.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json`:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You could even specify tags, branches, or commits your package should be fetched
    from by adding a `#` symbol followed by the tag name, branch name, or commit hash.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, I would highly recommend publishing your modules and not keeping them
    private wherever possible. This community with thousands of well-maintained public
    packages is one of the main reasons why React Native is so successful. So, giving
    something back to the community is always a good idea.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to structure large-scale or multi-platform
    products. You are now able to create a project structure that works for large-scale
    and long-running projects.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: You also created a clone of your example React Native mobile app on the web
    and understood why this isn’t always the best idea. You then learned how to create
    multi-platform applications that meet user expectations while keeping a high percentage
    of shared code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: In the last section of this chapter, you learned how to create, release, and
    maintain your own libraries, what the difference between JavaScript-only libraries
    and libraries with native code is, and how to only publish these libraries to
    selected people.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: After focusing on creating a good structure for the code base itself, in the
    next chapter, we’ll focus on how to implement well-working processes and how to
    support these processes with **Continuous Integration** (**CI**) tools.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
