<html><head></head><body>
		<div id="_idContainer072">
			<h1 id="_idParaDest-145"><em class="italic"><a id="_idTextAnchor278"/>Chapter 8</em>: Use Ref to Hide Stuff</h1>
			<p>In the previous chapter, we learned how the <em class="italic">React</em> context is designed and how to use a <strong class="source-inline">useContext</strong> hook to make an update for an area. In this chapter, we will introduce another <em class="italic">React</em> entity, a ref. We will learn how to access a <em class="italic">DOM</em> element via a ref and walk through the design and source code behind the <strong class="source-inline">useRef</strong> hook. We will also describe how to work with a persistent value without dispatching an update. In the end, we'll apply refs to a couple of practical problems, such as clicking outside of the menu, avoiding memory leaks, setting up a mule, and locating the current value. And we'll also reveal two bonus topics in the <em class="italic">Appendix</em> section, the callback ref and forward ref.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Accessing <em class="italic">DOM</em> elements</li>
				<li>Understanding <strong class="source-inline">useRef</strong> design</li>
				<li>State without an update</li>
				<li>Test driving <strong class="source-inline">useRef</strong></li>
				<li><strong class="source-inline">useRef</strong> examples</li>
				<li>Questions and answers</li>
				<li>Appendix</li>
			</ul>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor279"/>Accessing DOM elements</h1>
			<p>Before a <a id="_idIndexMarker320"/>modern <em class="italic">UI</em> framework is introduced, to make a change to the screen, we work directly with a <em class="italic">DOM</em> element:</p>
			<p class="source-code"><strong class="bold">&lt;body&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;h1</strong> <strong class="bold">id</strong>="title"<strong class="bold">&gt;&lt;/h1&gt;</strong></p>
			<p class="source-code"><strong class="bold">&lt;/body&gt;</strong></p>
			<p class="source-code"><strong class="bold">&lt;script&gt;</strong></p>
			<p class="source-code">  <strong class="bold">const</strong> el = document.getElementById('#title')</p>
			<p class="source-code">  el.textContent = "Hello World"</p>
			<p class="source-code"><strong class="bold">&lt;/script&gt;</strong></p>
			<p>The preceding <em class="italic">HTML</em> file defines an <strong class="source-inline">h1</strong> element tagged with a specific <strong class="source-inline">id</strong> value. So we can use the <strong class="source-inline">id</strong> value to find the <strong class="source-inline">el</strong> element and make a change to its <strong class="source-inline">textContent</strong>. This is how a <em class="italic">DOM</em> element gets updated: </p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/Figure_8.01_B17963.jpg" alt="Figure 8.1 – HTML displaying the Hello World title&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – HTML displaying the Hello World title</p>
			<p>With<a id="_idIndexMarker321"/> React, we can achieve the preceding functionality by wrapping elements in a component, such as a function component:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [title, setTitle] = useState("")</p>
			<p class="source-code">  useEffect(() <strong class="bold">=&gt;</strong> { setTitle("Hello World") }, [])</p>
			<p class="source-code">  <strong class="bold">return &lt;h1&gt;</strong>{title}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p>The benefits of using the preceding functional approach are that it provides an abstraction on top of the physical <em class="italic">DOM</em> and allows us to focus our development in a localized space. This way, we can safely put our logic and design without worrying that other code might accidentally touch this space. It makes our development more productive. </p>
			<p>This is a good thing, and here's a question. Can we still get hold of the <em class="italic">DOM</em> element using <strong class="source-inline">id</strong> as it used to be? Because the job of <em class="italic">React</em> isn't to reinvent all <em class="italic">DOM</em> functionalities, and sometimes we do need to work with the elements directly:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return &lt;h1</strong> id="title"<strong class="bold">&gt;</strong>{title}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p>In the preceding code, we add <strong class="source-inline">id</strong> to the <strong class="source-inline">h1</strong> element. But we run into some problems quickly. First, the <strong class="source-inline">Title</strong> component is made to be reused. This means we can have multiple <strong class="source-inline">&lt;Title /&gt;</strong> instances on the current screen. Suppose we want to operate on one of them – how do know which instance to find by using <strong class="source-inline">id</strong>?</p>
			<p>Secondly, and<a id="_idIndexMarker322"/> more importantly, say we find the element we want. Since it's wrapped in a component now, <em class="italic">React</em> manages its life cycle, so how do we know the moment when it gets mounted and unmounted precisely? If we're not sure about this, how can we safely operate on it?</p>
			<p>Both problems are tricky but need to be addressed before we can directly work with an element under a component. Let's see how <em class="italic">React</em> solves them<a id="_idTextAnchor280"/>.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor281"/>Attach and de-attach</h2>
			<p>So, when exactly does the element in a component mount and unmount? To answer this question, we need to first look at the element returned from a component closely:</p>
			<p class="source-code">  <strong class="bold">return &lt;h1&gt;</strong>{title}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p>What does the preceding statement return? Is it a <em class="italic">DOM</em> element, as we put in the <em class="italic">HTML</em> file? Though it looks quite like one, the compiler says otherwise:</p>
			<p class="source-code"><strong class="bold">return</strong> createElement('h1', <strong class="bold">null</strong>, title)</p>
			<p>Actually, what the compiler sees is a <em class="italic">JavaScript</em> statement with a <strong class="source-inline">createElement</strong> function returning a <em class="italic">React</em> element. It takes three input arguments, the element type (<strong class="source-inline">h1</strong>), the props (<strong class="source-inline">null</strong>), and the children (<strong class="source-inline">title</strong>), and the returned element is commonly referred to as a<a id="_idIndexMarker323"/> virtual <em class="italic">DOM</em>. If you are interested in learning more about <strong class="source-inline">createElement</strong> usage, check out the <em class="italic">Adopting CSS-in-JS approach</em> section of <a href="B17963_10_Epub.xhtml#_idTextAnchor363"><em class="italic">Chapter 10</em></a>, <em class="italic">Building a Website with React</em>.</p>
			<p>When the first update starts, <em class="italic">React</em> takes this element, reconciles it into a fiber, and appends it to the tree. It then moves on to its children. For all child elements, it reconciles them and appends them as children fibers. This continues until all elements are reconciled into the tree.</p>
			<p>After all the fibers are prepared, <em class="italic">React</em> performs a one-time commit to create all <em class="italic">DOM</em> elements on the screen. So, essentially, the physical <em class="italic">DOM</em> elements aren't created until the full tree is updated in memory. So, only by then, <em class="italic">React</em> hands us the element instance if we ask for it:</p>
			<p class="source-code">  <strong class="bold">return &lt;h1</strong> ref={ref}<strong class="bold">&gt;</strong>Hello World<strong class="bold">&lt;/h1&gt;</strong></p>
			<p>In the preceding code, a <strong class="source-inline">ref</strong> object is passed to the <strong class="source-inline">h1</strong> element as a prop and it behaves as a storage container, asking <em class="italic">React</em> to store the element instance once available. This <strong class="source-inline">ref</strong> container takes a specific format:</p>
			<p class="source-code">  ref = { current: <strong class="bold">null</strong> }</p>
			<p>After the instance of the <em class="italic">DOM</em> element is created, the preceding <strong class="source-inline">ref</strong> is populated in the <strong class="source-inline">commitAttachRef</strong> function <a id="_idIndexMarker324"/>during the <strong class="bold">Commit</strong> phase:</p>
			<p class="source-code"><strong class="bold">function</strong> commitAttachRef(fiber, instance) {</p>
			<p class="source-code">  <strong class="bold">const</strong> ref = fiber.ref</p>
			<p class="source-code">  <strong class="bold">if</strong> (ref !== <strong class="bold">null</strong>) {</p>
			<p class="source-code">    ref.current = instance</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>In the preceding <strong class="source-inline">commitAttachRef</strong> function, when <strong class="source-inline">ref</strong> is provided and initialized, its <strong class="source-inline">current</strong> property gets assigned<a id="_idIndexMarker325"/> from the <em class="italic">DOM</em> instance. This is for the mount. Similarly, when the <em class="italic">DOM</em> element is about to be removed, <strong class="source-inline">current</strong> gets assigned back to <strong class="source-inline">null</strong> in the <strong class="source-inline">commitDetachRef</strong> function during the <strong class="bold">Commit</strong> phase:</p>
			<p class="source-code"><strong class="bold">function</strong> commitDetachRef(fiber) {</p>
			<p class="source-code">  <strong class="bold">var</strong> ref = fiber.ref</p>
			<p class="source-code">  <strong class="bold">if</strong> (ref !== <strong class="bold">null</strong>) {</p>
			<p class="source-code">    ref.current = <strong class="bold">null</strong></p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>With this capability, as long as we provide <strong class="source-inline">ref</strong> to an element, React assigns the element's instance into <strong class="source-inline">ref.current</strong> upon the mount and unmount. We can use <strong class="source-inline">ref.current</strong> to work on the element as it used to be. This is the <em class="italic">React</em> way of accessing <em class="italic">DOM</em> elements.</p>
			<p>There's a subtlety <a id="_idIndexMarker326"/>here. Note that when passing the element's instance over when it's ready, the assignment is done with <strong class="source-inline">ref.current = instance</strong> instead of <strong class="source-inline">ref = instance</strong>. This is because <em class="italic">React</em> designs <strong class="source-inline">ref</strong> as a container to be available during the life cycle of the component. Put simply, the container is always valid, whereas the value under the <strong class="source-inline">current</strong> property can change along the way. </p>
			<p>The <strong class="source-inline">ref</strong> prop we used so far is a ref in an object format, which is the most popular and easy-to-use format. Other than this, <em class="italic">React</em> supports one more format in other situations. If you are interested, you can check out <em class="italic">Appendix A – Callback ref</em> at the end of this chapter.</p>
			<p>Now we know what a <em class="italic">React</em> ref is, let's take a look at how to create one under a function component with a <strong class="source-inline">useRef</strong> <a id="_idTextAnchor282"/>hook.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor283"/>Understanding useRef design</h1>
			<p><em class="italic">React</em> provides a <strong class="source-inline">useRef</strong> hook<a id="_idIndexMarker327"/> to create a ref:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> ref = useRef(<strong class="bold">null</strong>)</p>
			<p class="source-code">  <strong class="bold">return &lt;h1</strong> ref={ref}<strong class="bold">&gt;</strong>Hello World<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">useRef</strong> hook takes an initial value as its only input argument and returns a <strong class="source-inline">ref</strong> object, putting that initial value under the <strong class="source-inline">current</strong> property. </p>
			<p>There's no additional data structure required for <strong class="source-inline">useRef</strong>, other than the basic fiber hook support:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/Figure_8.02_B17963.jpg" alt="Figure 8.2 – useRef design&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – useRef design</p>
			<p>Just like <strong class="source-inline">useState</strong> and <strong class="source-inline">useEffect</strong> uses <strong class="source-inline">state</strong> to store state and the effect, <strong class="source-inline">useRef</strong> uses <strong class="source-inline">state</strong> to <a id="_idIndexMarker328"/>store the ref. Next, let's take a look at how it's implem<a id="_idTextAnchor284"/>ented.</p>
			<p>The <strong class="source-inline">useRef</strong> hook follows a<a id="_idIndexMarker329"/> typical hook setup where it takes a path of either <strong class="source-inline">mountRef</strong> or <strong class="source-inline">updateRef</strong>, depending on whether the fiber is under mount or update via the <strong class="source-inline">isFiberMounting</strong> flag, as explained in <a href="B17963_03_Epub.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>, <em class="italic">Hooking into React</em>:</p>
			<p class="source-code"><strong class="bold">function</strong> useRef(initialValue) {</p>
			<p class="source-code">  <strong class="bold">if</strong> (isFiberMounting) {</p>
			<p class="source-code">    <strong class="bold">return</strong> mountRef(initialValue)</p>
			<p class="source-code">  } <strong class="bold">else</strong> {</p>
			<p class="source-code">    <strong class="bold">return</strong> updateRef()</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>When under mount, it first gets the hook by creating one:</p>
			<p class="source-code"><strong class="bold">function</strong> mountRef(initialValue) {</p>
			<p class="source-code">  <strong class="bold">const</strong> hook = mountHook()</p>
			<p class="source-code">  <strong class="bold">const</strong> ref = { current: initialValue }</p>
			<p class="source-code">  hook.state = ref</p>
			<p class="source-code">  <strong class="bold">return</strong> ref</p>
			<p class="source-code">}</p>
			<p>Before returning the <strong class="source-inline">ref</strong> object, the initial value is stored under the <strong class="source-inline">current</strong> property and <strong class="source-inline">ref</strong> is stored under <strong class="source-inline">state</strong> of the hook.</p>
			<p>After the component is mounted, the next<a id="_idIndexMarker330"/> time it gets updated and arrives at the <strong class="source-inline">useRef</strong> hook, it gets the hook by cloning one:</p>
			<p class="source-code"><strong class="bold">function</strong> updateRef() {</p>
			<p class="source-code">  <strong class="bold">const</strong> hook = updateHook()</p>
			<p class="source-code">  <strong class="bold">return</strong> hook.state</p>
			<p class="source-code">}</p>
			<p>Once we have the hook, we can get <strong class="source-inline">ref</strong> from <strong class="source-inline">state</strong> and return it. Also, note that the hook doesn't accept any input argument after the mount.</p>
			<p>By far, this is the shortest hook implementation we have seen. The following diagram shows the workflow:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/Figure_8.03_B17963.jpg" alt="Figure 8.3 – useRef workflow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – useRef workflow</p>
			<p>In short, the <strong class="source-inline">useRef</strong> hook provides<a id="_idIndexMarker331"/> the basic storage for persisting a ref. A <strong class="source-inline">ref</strong> stored in the hook never gets updated after the mount where the <strong class="source-inline">current</strong> value is initialized. Basically, the <strong class="source-inline">useRef</strong> hook essentially lets us manage the state out of the box. </p>
			<p>If <strong class="source-inline">ref</strong> is wired as a prop to an element, when the element gets mounted or unmounted, its <em class="italic">DOM</em> instance gets updated in the <strong class="source-inline">current</strong> property. </p>
			<p>Now we know the design of the <strong class="source-inline">useRef</strong> hook. If the ref created is used to hold a value, how is it different from the <strong class="source-inline">useState</strong> hook? Since they both can hold a value, let's spend some time comparing them to understand more about the <strong class="source-inline">useR<a id="_idTextAnchor285"/>ef</strong> hook.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor286"/>State without an update</h1>
			<p>The <strong class="source-inline">ref</strong> created<a id="_idIndexMarker332"/> via <strong class="source-inline">useRef</strong> can be used to hold not only a DOM instance but also any value. At any time, we can change its <strong class="source-inline">current</strong> property with a new assignment:</p>
			<p class="source-code">  ref.current = ...</p>
			<p>The assignment can be a <em class="italic">JavaScript</em> expression. What's special about this is that <em class="italic">the ref assignment doesn't do anything more than an assignment</em>. This implies that it does not trigger an update. Let's take a look at how it impacts the UI when we wire it to a user action:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> ref = useRef(<strong class="bold">null</strong>)</p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    ref.current = 'white'</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return </strong>&lt;Child color={ref} onClick={onClick} /&gt;</p>
			<p class="source-code">}</p>
			<p>In the preceding code, an event handler is wired with the <strong class="source-inline">Child</strong> component, and when the user clicks, it assigns a color into <strong class="source-inline">ref.current</strong>. It looks pretty similar to the case using a <strong class="source-inline">useState</strong> hook. If <a id="_idIndexMarker333"/>we were using a <strong class="source-inline">useState</strong> hook, the code would look like the following:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [color, setColor] = useState('')</p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    setColor('white')</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return </strong>&lt;Child color={color} onClick={onClick} /&gt;</p>
			<p class="source-code">}</p>
			<p>When comparing these two cases, we can see that the main difference is the following line:</p>
			<p class="source-code">  // ref version</p>
			<p class="source-code">  ref.current = 'white'</p>
			<p class="source-code">  // state version</p>
			<p class="source-code">  setColor('white')</p>
			<p>In the ref case, it is a plain assignment, whereas in the state case, it dispatches an update to schedule the state change. This means that the state case is a lot more complicated than the ref case. We can even simulate the ref case with a state:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [obj] = useState({ color: '' })</p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    obj.color = 'white'    </p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return </strong>&lt;Child color={obj} onClick={onClick} /&gt;</p>
			<p class="source-code">}</p>
			<p>In the preceding<a id="_idIndexMarker334"/> experiment, we made the state an <strong class="source-inline">obj</strong> with a <strong class="source-inline">color</strong> property. And this <strong class="source-inline">obj</strong> is quite comparable to <strong class="source-inline">ref</strong> from <strong class="source-inline">useRef</strong>, because <strong class="source-inline">obj.color =</strong> is also a plain assignment:</p>
			<p class="source-code">  obj.color = 'white'</p>
			<p>You might wonder, for plain assignments, what happens to the <strong class="source-inline">color</strong> prop wired with either <strong class="source-inline">ref</strong> or <strong class="source-inline">obj</strong>? Interestingly, in both cases, nothing happens. Because with a plain assignment, there's no dispatch to the <strong class="source-inline">Title</strong> component, thus there isn't any update to the <strong class="source-inline">Child</strong> component. Therefore, even though the content gets changed, <em class="italic">React</em> wouldn't respond to that. </p>
			<p>So, essentially, a ref can be taken to hold a value without the update capability. This also explains why the source code of <strong class="source-inline">useRef</strong> is so compact, because it doesn't do much other than returning a persistent value.</p>
			<p>Now that we've gone over the design of a ref and the <strong class="source-inline">useRef</strong> hook, let's take it for a <a id="_idTextAnchor287"/>test drive.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor288"/>Test driving useRef</h1>
			<p>There's always a<a id="_idIndexMarker335"/> chance that <em class="italic">React</em> runs short in terms of controlling the internals of a <em class="italic">DOM</em> element. Say there's an input and a button, as in <em class="italic">Figure 8.4</em>. Upon a button click, we want to manually focus on the input:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/Figure_8.04_B17963.jpg" alt="Figure 8.4 – Focus input&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Focus input</p>
			<p>Normally, if we click the button, it gets focused, and if we click somewhere else, it loses focus. But in this case, after we click the <strong class="bold">Focus</strong> button, we want to focus the input instead of the button so that the user can type right away. </p>
			<p>Let's see how we can apply <strong class="source-inline">useRef</strong> to make this happen:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> ref = useRef()</p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> { </p>
			<p class="source-code">    ref.current.focus()</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;input</strong> ref={ref} <strong class="bold">/&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;button</strong> onClick={onClick}<strong class="bold">&gt;</strong>focus<strong class="bold">&lt;/button&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;/&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>In the preceding example, after <strong class="source-inline">input</strong> is mounted, its instance is stored in <strong class="source-inline">ref.current</strong>. When we click the button, the event handler uses the ref to invoke a native <em class="italic">DOM</em> <strong class="source-inline">focus</strong> method to make the input focused. That's it!</p>
			<p>Though the <strong class="source-inline">ref</strong> object is always valid, the <strong class="source-inline">current</strong> property is not necessarily valid all the time. Before the mount finishes, it can store a <strong class="source-inline">null</strong> value. After the unmount, it can store a <strong class="source-inline">null</strong> value as well. So, to make sure that we don't run into any runtime error, we normally add a check before using it: </p>
			<p class="source-code"><strong class="bold">if</strong> (ref.current) ref.current.focus()</p>
			<p>Sometimes, you see the following short-circuit way:</p>
			<p class="source-code">ref.current &amp;&amp; ref.current.focus()</p>
			<p>It's important to<a id="_idIndexMarker336"/> note that, although we get to use <strong class="source-inline">ref</strong> to control the <em class="italic">DOM</em> element, React wouldn't know the impact of your code. For instance, in our example, <em class="italic">React</em> can't tell whether the input gets focused or not. In order for React to know that, we still need to add a state to keep track of this change:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [focused, setFocused] = useState(<strong class="bold">false</strong>)</p>
			<p class="source-code">  <strong class="bold">const</strong> ref = useRef()</p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    ref.current.focus()</p>
			<p class="source-code">    setFocused(<strong class="bold">true</strong>)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  ...</p>
			<p class="source-code">}</p>
			<p>In a way, getting hold of the raw DOM elements gives us the extra capability to manipulate the element behind R<a id="_idTextAnchor289"/>eact's back.</p>
			<p class="callout-heading">Playground – Focusing Input</p>
			<p class="callout">Feel free to play with this online example at <a href="https://codepen.io/windmaomao/pen/WNZwoje">https://codepen.io/windmaomao/pen/WNZwoje</a></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor290"/>Controlling a child ref</h2>
			<p>Since a ref is basically <a id="_idIndexMarker337"/>an object, it can be passed around as a prop to a child component. Therefore, a passed-in <strong class="source-inline">ref</strong> object can be attached to a DOM element inside a child:</p>
			<p class="source-code"><strong class="bold">const</strong> Child = ({ childRef }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return &lt;input</strong> ref={childRef} <strong class="bold">/&gt;</strong></p>
			<p class="source-code">}</p>
			<p>Utilizing this <strong class="source-inline">childRef</strong>, the <strong class="source-inline">Child</strong> component allows the parent to operate on it:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> ref = useRef()</p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> { </p>
			<p class="source-code">    ref.current.focus()</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;&gt;</strong></p>
			<p class="source-code">      &lt;Child childRef={ref} /&gt;</p>
			<p class="source-code">      <strong class="bold">&lt;button</strong> onClick={onClick}<strong class="bold">&gt;</strong>focus<strong class="bold">&lt;/button&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;/&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>In the preceding code, the <strong class="source-inline">Title</strong> component creates a <strong class="source-inline">ref</strong> object via <strong class="source-inline">useRef</strong> and passes it to <strong class="source-inline">Child</strong> via a <strong class="source-inline">childRef</strong> prop. When <strong class="source-inline">Child</strong> mounts, it populates the <strong class="source-inline">input</strong> instance into <strong class="source-inline">ref.current</strong>. And when we click on the button, it invokes the <strong class="source-inline">focus</strong> method of the input element of <strong class="source-inline">Child</strong>. This allows a parent component to control a <em class="italic">DOM</em> element of <strong class="source-inline">Child</strong>.</p>
			<p>Note that the prop we used is named <strong class="source-inline">childRef</strong> instead of <strong class="source-inline">ref</strong> because <strong class="source-inline">ref</strong> is a reserved prop name to attach a <em class="italic">DOM</em> instance, whereas <strong class="source-inline">childRef</strong> is merely a regular prop to pass in an object. Although both are props, the <strong class="source-inline">ref</strong> prop is a special one. It would be wrong if we mistakenly used <strong class="source-inline">ref</strong> instead of <strong class="source-inline">childRef</strong> in this example:</p>
			<p class="source-code">  &lt;Child ref={ref} /&gt;</p>
			<p>The preceding line would<a id="_idIndexMarker338"/> ask the <strong class="source-inline">Child</strong> function component to assign its instance to <strong class="source-inline">ref</strong>. But a function component cannot have a ref by default. Therefore, avoid using the ref name when passing it around. There's actually a way to attach a ref to a function component with some work; if you are interested, you can find out more in the <em class="italic">Appendix B – Forward ref</em> section at the end of this chapter. </p>
			<p>Now that we have used a ref to control the element in the component, let's take a look at more examples of<a id="_idTextAnchor291"/> using <strong class="source-inline">useRef</strong>.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor292"/>useRef examples</h1>
			<p>A ref is powerful. Because <em class="italic">React</em> makes things very reactive, if we want to either disable this reactiveness or add a tweak to it, the ref gives us the opportunity to do that. In this section, we'll look into more examples of how it can be used to solve interesting prob<a id="_idTextAnchor293"/>lems in <em class="italic">React</em>.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor294"/>Clicking outside the menu</h2>
			<p>Say you have a component, and you<a id="_idIndexMarker339"/> want to know when the user clicks outside of it. This is a very popular feature for a popup menu or a modal. Once the menu is visible, we want to dismiss it when the user clicks anywhere outside of it:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/Figure_8.05_B17963.jpg" alt="Figure 8.5 – Click outside to dismiss&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – Click outside to dismiss</p>
			<p>Let's say we have a <strong class="source-inline">Menu</strong> component <a id="_idIndexMarker340"/>displaying a list of menu items:</p>
			<p class="source-code"><strong class="bold">const</strong> Menu = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [on, setOOn] = useState(<strong class="bold">true</strong>)</p>
			<p class="source-code">  <strong class="bold">if</strong> (!on) <strong class="bold">return</strong> <strong class="bold">null</strong></p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;ul&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;li&gt;</strong>Home<strong class="bold">&lt;/li&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;li&gt;</strong>Price<strong class="bold">&lt;/li&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;li&gt;</strong>Produce<strong class="bold">&lt;/li&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;li&gt;</strong>Support<strong class="bold">&lt;/li&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;li&gt;</strong>About<strong class="bold">&lt;/li&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;/ul&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>In the preceding code, an <strong class="source-inline">on</strong> state is created and set to <strong class="source-inline">true</strong> initially, thus making a list of the menu items visible. But when we click outside of this list, we'd want to set <strong class="source-inline">on</strong> to <strong class="source-inline">false</strong> to hide it. For simplicity, here we define the <strong class="source-inline">on</strong> flag inside the <strong class="source-inline">Menu</strong> component, but in practice, it could be passed from the parent as a prop.</p>
			<p>We know how to find out when the user clicks the <strong class="source-inline">Menu</strong> component using an event handler, but how do we know when the user clicks somewhere outside? Do we need to know the location of all the components on the entire screen? </p>
			<p>This is the place we can <a id="_idIndexMarker341"/>attach a <strong class="source-inline">ref</strong> to the <strong class="source-inline">ul</strong> element:</p>
			<p class="source-code"><strong class="bold">const</strong> Menu = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  const [on, setOn] = useState(true)</p>
			<p class="source-code">  <strong class="bold">const</strong> ref = useRef()</p>
			<p class="source-code">  <strong class="bold">if</strong> (!on) return <strong class="bold">null</strong></p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;ul</strong> ref={ref}<strong class="bold">&gt;</strong> </p>
			<p class="source-code">      ...</p>
			<p class="source-code">    <strong class="bold">&lt;/ul&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>Instead of attaching the click event handler to one element, we can listen to a <strong class="source-inline">mousedown</strong> window event. This way, we are aware of any user click, regardless of whether it's inside or outside the <strong class="source-inline">Menu</strong> component:</p>
			<p class="source-code"><strong class="bold">const</strong> Menu = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  const ref = useRef()</p>
			<p class="source-code">  useEffect(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">const</strong> listener = e <strong class="bold">=&gt;</strong> { ... }</p>
			<p class="source-code">    window.addEventListener('mousedown', listener)</p>
			<p class="source-code">    <strong class="bold">return</strong> () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">      window.removeEventListener('mousedown', listener)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }, [])</p>
			<p class="source-code">  ...</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we registered an event handler for a <strong class="source-inline">mousedown</strong> window event, so with any mouse click, it'll invoke our <strong class="source-inline">listener</strong> function. Upon the unmount, we also make sure that we remove this event handler via a <strong class="source-inline">destroy</strong> function.</p>
			<p>When the <strong class="source-inline">mousedown</strong> handler is fired, we can use <strong class="source-inline">ref</strong> to find out whether the mouse location is contained inside the boundary of the <strong class="source-inline">ul</strong> element:</p>
			<p class="source-code">    <strong class="bold">const</strong> listener = e <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">      <strong class="bold">if</strong> (!ref.current) <strong class="bold">return</strong></p>
			<p class="source-code">      <strong class="bold">if</strong> (!ref.current.contains(e.target)) {</p>
			<p class="source-code">        setOn(<strong class="bold">false</strong>)</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p>In the <a id="_idIndexMarker342"/>preceding <strong class="source-inline">listener</strong> handler, upon each <strong class="source-inline">mousedown</strong> event, we check whether the element has been mounted via <strong class="source-inline">ref.current</strong>, and then we check whether the element under the mouse, via <strong class="source-inline">e.target</strong>, is a child of the <strong class="source-inline">ul</strong> element. If the user clicks any children inside the <strong class="source-inline">ul</strong>, then we know they have clicked inside. And if not, we know the user has clicked outside, and then we can dispatch to set the <strong class="source-inline">on</strong> state to be <strong class="source-inline">false</strong>, thus dismissing the display of the menu.</p>
			<p class="callout-heading">Playground – Click Outside of Menu</p>
			<p class="callout">Feel free to play with this online example at <a href="https://codepen.io/windmaomao/pen/XWaerGm">https://codepen.io/windmaomao/pen/XWaerGm</a>.</p>
			<p>In short, with the help of the ref, we can invoke <strong class="source-inline">contains</strong> functions to find out whether an element is inside<a id="_idTextAnchor295"/> another element.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor296"/>Avoiding memory leaks</h2>
			<p>Historically speaking, a ref was <a id="_idIndexMarker343"/>created to hold a DOM element, but people later found it very effective in addressing tricky problems. One problem is memory leaks, which happen when performing an async action. The thing about an async operation is that the callback function gets invoked later. By the time the callback is handled, there's a chance the component (or any variable associated with the component) is not valid anymore.</p>
			<p>Let's say we fetch an API and display the result as <strong class="source-inline">text</strong>: </p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [text, setText] = useState("")</p>
			<p class="source-code">  useEffect(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    fetch("https://google.com").then(res <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">      setText(res.title)</p>
			<p class="source-code">    })</p>
			<p class="source-code">  }, [])</p>
			<p class="source-code">  <strong class="bold">return &lt;h1&gt;</strong>{text}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p>The preceding code is a common fetch process, but there's a memory leak lurking out there. When it happens, the browser outputs the following message:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/Figure_8.06_B17963.jpg" alt="Figure 8.6 – Memory leak warning message&#13;&#10;"/>
				</div>
			</div>
			<p class="figure"> </p>
			<p class="figure-caption">Figure 8.6 – Memory leak warning message</p>
			<p>Although <em class="italic">React</em> is nice enough to display it as a warning message under development build, it's actually an error, as it says <strong class="bold">indicates a memory leak</strong> in the message. The strange thing about this leak is that most of time, the <em class="italic">UI</em> continues to function even after the message. So, shall we ignore this message? Absolutely not.</p>
			<p>Let's build the crime scene and try to understand what exactly happens under this message:</p>
			<p class="source-code"><strong class="bold">const</strong> App = ({ flag }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">if</strong> (flag) <strong class="bold">return </strong>&lt;Title /&gt;</p>
			<p class="source-code">  <strong class="bold">return</strong> <strong class="bold">null</strong></p>
			<p class="source-code">}</p>
			<p>Say you have an <strong class="source-inline">App</strong> parent component that displays <strong class="source-inline">Title</strong> based on a <strong class="source-inline">flag</strong>. For one update, the <strong class="source-inline">flag</strong> becomes <strong class="source-inline">false</strong>, thus <strong class="source-inline">Title</strong> gets unmounted and the screen turns blank. This is valid business logic, so why is it a problem?</p>
			<p>The problem lies inside the <strong class="source-inline">Title</strong> component instead of <strong class="source-inline">App</strong>. Precisely, when <strong class="source-inline">Title</strong> mounts, the <em class="italic">API</em> fetch starts, but the fetch might not finish soon enough before the unmount. The <strong class="source-inline">flag</strong> and the fetch are two independent things. Therefore, <strong class="source-inline">Title</strong> can have unfinished business after the unmount. Say the time arrives to handle the unfinished business, such as the callback function – what happens to the <strong class="source-inline">setText</strong> statement? Should it raise another update when the component has gone?</p>
			<p>Technically, if the<a id="_idIndexMarker344"/> component is unmounted, it can't be updated anymore. Moreover, every hook is registered under the fiber, and if the fiber has been removed, then nothing registered under it should be accessed anymore. Otherwise, inconsistency would emerge, such as a memory leak.</p>
			<p>So back to our case, when an async call returns after the unmount – this becomes a solid bug that we can't just ignore. This bug happens quite often in situations when a conditional statement makes the code to switch to another branch of update, such as a route switch. Most of the memory leaks are difficult to debug, so we should try to avoid them at all costs.</p>
			<p class="callout-heading">Playground – Memory Leak</p>
			<p class="callout">Feel free to play with this online example at <a href="https://codepen.io/windmaomao/pen/VwzMYNL">https://codepen.io/windmaomao/pen/VwzMYNL</a>.</p>
			<p class="callout">In order to see the memory leak message, you need to open the <strong class="bold">Browser developer</strong> panel and switch to the <strong class="bold">Console</strong> tab.</p>
			<p>To resolve this bug, what we need to do is to carefully guard the content of the callback function, based on whether the <strong class="source-inline">Title</strong> component is still mounted or not:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [text, setText] = useState("")</p>
			<p class="source-code">  <strong class="bold">const</strong> mountedRef = useRef(<strong class="bold">true</strong>)</p>
			<p class="source-code">  useEffect(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    fetch("https://google.com").then(res <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">      <strong class="bold">if</strong> (!mountedRef.current) <strong class="bold">return</strong></p>
			<p class="source-code">      setText(res.title)</p>
			<p class="source-code">    })</p>
			<p class="source-code">    <strong class="bold">return</strong> () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">      mountedRef.current = <strong class="bold">false</strong> </p>
			<p class="source-code">    }</p>
			<p class="source-code">  }, [])</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we<a id="_idIndexMarker345"/> add <strong class="source-inline">mountedRef</strong> to indicate whether <strong class="source-inline">Title</strong> is mounted or not. We initially set it to <strong class="source-inline">true</strong>, because when the component gets updated, we assume it's safe to dispatch more updates. And after the unmount via <strong class="source-inline">useEffect</strong>, we set the <strong class="source-inline">mountedRef</strong> flag to be <strong class="source-inline">false</strong> in the <strong class="source-inline">destroy</strong> function.</p>
			<p>Now, in the callback handler of the fetch, we check if it's still mounted by reading <strong class="source-inline">mountedRef</strong>. And if it's <strong class="source-inline">false</strong>, we cancel the handler operation without moving forward to access any internal method, such as <strong class="source-inline">setText</strong>. This means even when the <em class="italic">API</em> is successful, there's no update to bring this value to the screen anymore.</p>
			<p class="callout-heading">Playground – Avoid Memory Leaks</p>
			<p class="callout">Feel free to play with this online example at <a href="https://codepen.io/windmaomao/pen/wvqraKP">https://codepen.io/windmaomao/pen/wvqraKP</a>.</p>
			<p>You might wonder why we can't use a state instead of a ref for the <strong class="source-inline">mountRef</strong> purpose. Let's say we replace <strong class="source-inline">mountRef</strong> with a <strong class="source-inline">mounted</strong> state:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [mounted, setMounted] = useState(<strong class="bold">true</strong>)</p>
			<p class="source-code">  useEffect(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    <strong class="bold">return</strong> () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">      setMounted(<strong class="bold">false</strong>)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }, [])</p>
			<p class="source-code">}</p>
			<p>Although creative, the preceding code wouldn't work. Because, essentially, you ask to dispatch a new update after the unmount, it's the exact memory leak we want to avoid. In <a href="B17963_05_Epub.xhtml#_idTextAnchor157"><em class="italic">Chapter 5</em></a>, <em class="italic">Use Effect to Handle Side Effects</em>, we learned that the <strong class="source-inline">destroy</strong> function of a passive effect is last called after all DOM elements settle, so by then, we shouldn't be <a id="_idIndexMarker346"/>allowed to access any internal method. </p>
			<p>This example also tells us that a change from a ref is not meant to be reflected in the UI, whereas a state is designed to be in sync with <a id="_idTextAnchor297"/>the UI at all times.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor298"/>Setting up a mule </h2>
			<p>When we design a<a id="_idIndexMarker347"/> web application, we tend not to have a global variable, because we know it's so easy that their usage can lead to some unmanageable side effects. On the other hand, if we have some global information that is valid for the entire site, it's still handy if we want to share it with the rest of the app behind the scenes. So, what kind of compromise can we have in this situation?</p>
			<p>In <a href="B17963_07_Epub.xhtml#_idTextAnchor237"><em class="italic">Chapter 7</em></a>, <em class="italic">Use Context to Cover an Area</em>, we learned to create a context to share info for a site. We can provide the info at the very top of the tree, the <strong class="source-inline">App</strong> component:</p>
			<p class="source-code"><strong class="bold">const</strong> App = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [value, setValue] = useState(0)</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    &lt;AppContext.Provider value={{ value, setValue }}&gt;</p>
			<p class="source-code">      ...</p>
			<p class="source-code">    &lt;/AppContext.Provider&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>A fact of using the state in the <a id="_idIndexMarker348"/>preceding code is that, when changing a value through the <strong class="source-inline">setValue</strong> dispatch function, it causes the whole site to update, which can be a very expensive operation. If we don't need to notify the user of this change, we can use a ref instead:</p>
			<p class="source-code"><strong class="bold">const</strong> App = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> value = useRef({</p>
			<p class="source-code">    count: 1 </p>
			<p class="source-code">  })</p>
			<p class="source-code">  <strong class="bold">const</strong> onIncrement = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">value.current.count++</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    &lt;AppContext.Provider value={value}&gt;</p>
			<p class="source-code">      <strong class="bold">&lt;button</strong> onClick={onIncrement}<strong class="bold">&gt;</strong>+<strong class="bold">&lt;button&gt;</strong></p>
			<p class="source-code">      &lt;Title /&gt;</p>
			<p class="source-code">    &lt;/AppContext.Provider&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>In the preceding code, a ref is created with <strong class="source-inline">useRef</strong> to hold a custom <strong class="source-inline">count</strong> value under the <strong class="source-inline">current</strong> property. We can increment it as used to be with a button click via <strong class="source-inline">onIncrement</strong>. We also add a <strong class="source-inline">Title</strong> component underneath to consume this <strong class="source-inline">count</strong> value:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> { current } = useContext(AppContext)</p>
			<p class="source-code">  <strong class="bold">return</strong> <strong class="bold">&lt;div&gt;</strong>{current.count}<strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code">}</p>
			<p>In the preceding <strong class="source-inline">Title</strong> component, it consumes <strong class="source-inline">current</strong> from <strong class="source-inline">AppContext</strong>, and displays the stored <strong class="source-inline">count</strong> value. With this setup, if you click <strong class="source-inline">onIncrement</strong> in the <strong class="source-inline">App</strong> component, the <strong class="source-inline">number</strong> value always stays at <strong class="source-inline">0</strong>. It seems our <strong class="source-inline">count</strong> is broken.</p>
			<p>To reveal <a id="_idIndexMarker349"/>what's happened, let's add a manual update to the <strong class="source-inline">Title</strong> component with a button:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> { current } = useContext(AppContext)</p>
			<p class="source-code">  <strong class="bold">const</strong> [number, setNumber] = useState(current.count) </p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    setNumber(current.count)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return &lt;button</strong> onClick={onClick}<strong class="bold">&gt;</strong>{number}<strong class="bold">&lt;/button&gt;</strong></p>
			<p class="source-code">}</p>
			<p>In the preceding code, we put the <strong class="source-inline">count</strong> value into a local <strong class="source-inline">number</strong> state, so we can use <strong class="source-inline">setNumber</strong> to make an update. Now, upon clicking <strong class="source-inline">number</strong> via <strong class="source-inline">onClick</strong>, you will see the latest <strong class="source-inline">current.count</strong> value on the screen, as shown in <em class="italic">Figure 8.7</em>:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/Figure_8.07_B17963.jpg" alt="Figure 8.7 – A count state with a separate update&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – A count state <a id="_idTextAnchor299"/>with a separate update</p>
			<p>It's a bit intriguing here to see the process of how the number got displayed on the screen. First, we incremented it, and then we revealed it. Therefore, <strong class="source-inline">current.count</strong> isn't broken; it's just not in sync with the screen.</p>
			<p class="callout-heading">Playground – Mule Context</p>
			<p class="callout">Feel free to play with this online example at <a href="https://codepen.io/windmaomao/pen/YzxrXQN">https://codepen.io/windmaomao/pen/YzxrXQN</a>.</p>
			<p>With a <a id="_idIndexMarker350"/>context like <strong class="source-inline">AppContext</strong>, we can store the value and use it freely decoupled from the display. In a way, the ref context becomes a mule that can move any data (or functionalities) from one component to another one under <em class="italic">React</em>'s nose. Practically, this kind of context is an effective approach when you need to bring in a third-party library that does not necessarily wire with <em class="italic">React</em> that tightly but that you want to be operational along with <em class="italic">React</em>.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor300"/>Locating the current value</h2>
			<p>The <strong class="source-inline">current</strong> property being<a id="_idIndexMarker351"/> current is the unique thing about a ref. The property name <em class="italic">current</em> under the ref is given for a reason because, technically, there's nothing more current than a ref in React.</p>
			<p>When we use a <strong class="source-inline">useState</strong> hook, we want to find out the current updated value of a state. Although we use the same word, current, the state can't be that current in some situations. We will use an example to demonstrate that.</p>
			<p>Let's say we have a button to increment a count, but instead of incrementing it right away, it waits for 3 seconds after the click:</p>
			<p class="source-code"><strong class="bold">function</strong> Title() {</p>
			<p class="source-code">  <strong class="bold">const</strong> [count, setCount] = useState(0)</p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    setTimeout(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">      console.log('clicked', count) ➀</p>
			<p class="source-code">      setCount(count + 1)</p>
			<p class="source-code">    }, 3000)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  console.log('updated', count)     ➁</p>
			<p class="source-code">  <strong class="bold">return &lt;button</strong> onClick={onClick}<strong class="bold">&gt;</strong>+<strong class="bold">&lt;/button&gt;</strong></p>
			<p class="source-code">} </p>
			<p>In the preceding code, <strong class="source-inline">setTimeout</strong> is used in the event handler to deliberately delay the <strong class="source-inline">setCount</strong> function by 3 seconds. What we expect to see is that each click should behave like a delayed click where the <strong class="source-inline">count</strong> value increments to <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, and <strong class="source-inline">3</strong> on the screen 3 seconds later.</p>
			<p>When we run the code, it shows differently, as shown in the next timeline:</p>
			<p class="source-code">|--------------0-0--0----&gt; clicked  ➀</p>
			<p class="source-code">0---------------1-1--1---&gt; updated  ➁</p>
			<p>After we clicked the<a id="_idIndexMarker352"/> buttons three times in a row and waited for 3 seconds, we didn't see <strong class="source-inline">count</strong> incremented to <strong class="source-inline">3</strong> on screen. Instead, we saw it incremented to <strong class="source-inline">1</strong>. Quite surprising?</p>
			<p class="callout-heading">Playground – Where is the Current Value?</p>
			<p class="callout">Feel free to play with this online example at <a href="https://codepen.io/windmaomao/pen/ZEJXbEG">https://codepen.io/windmaomao/pen/ZEJXbEG</a>.</p>
			<p>How could three dispatches end up with one dispatch? Let's debug by adding two more series to the timeline, the <strong class="source-inline">"x"</strong> click and the <strong class="source-inline">"R"</strong> update:</p>
			<p class="source-code">      0.5s     3.5s</p>
			<p class="source-code">|-----x-x--x-------------&gt; click</p>
			<p class="source-code">|--------------0-0--0----&gt; clicked  ➀</p>
			<p class="source-code">R---------------R-R------&gt; update</p>
			<p class="source-code">0---------------1-1------&gt; updated  ➁</p>
			<p>When we clicked the button for the first time (at about <strong class="source-inline">t=0.5s</strong>), what was the <strong class="source-inline">count</strong> value from the event handler? It was <strong class="source-inline">0</strong>, our initial state. Then, when we clicked the button the second time, what was the <strong class="source-inline">count</strong> value from the event handler? You would say, it's got to be <strong class="source-inline">1</strong>, right, since I clicked it? But unfortunately, it wasn't the case.</p>
			<p>Looking at the <strong class="source-inline">"updated"</strong> series, the second update didn't arrive right away after the click. If there was no new update, <strong class="source-inline">count</strong> continued to hold an old state. Since the new update didn't arrive until three seconds later (at about <strong class="source-inline">t=3.5s</strong>), during this period, any event handler would still carry the same <strong class="source-inline">count</strong>. Okay, that explains why the <strong class="source-inline">"clicked"</strong> series printed <strong class="source-inline">0</strong> upon each click. It was almost like all the three clicks performed the same dispatch statement:</p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {    </p>
			<p class="source-code">    setTimeout(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">      setCount(0 + 1)        // count = 0</p>
			<p class="source-code">    }, 3000)</p>
			<p class="source-code">  }</p>
			<p>Essentially, we <a id="_idIndexMarker353"/>dispatched to request a change to <strong class="source-inline">1</strong> three times. In our case, all clicks happened before the second update. This created an out-of-sync moment. This is not a design flaw, since <strong class="source-inline">count</strong> is only designed for pointing to a copy in the current update. Unless it's made of a pointer pointing to the same memory space, it can't be pointing to the current value.</p>
			<p>A common misconception is to refer to <strong class="source-inline">setState</strong> as an assignment. By now, you should see that it's incorrect, since it actually requests an assignment instead of executing the assignment. The request takes time to be handled and executed, and moreover, the assignment can be revoked due to optimization. The fate of this assignment from <strong class="source-inline">setState</strong> isn't crystal clear, whereas in the ref case, the assignment is plain, instant, and can't be missed.</p>
			<p>Let's apply a ref to fix this problem:</p>
			<p class="source-code"><strong class="bold">function</strong> Title() {</p>
			<p class="source-code">  <strong class="bold">const</strong> [count, setCount] = useState(0)</p>
			<p class="source-code">  <strong class="bold">const</strong> ref = useRef(0)</p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    setTimeout(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">      ref.current++</p>
			<p class="source-code">      setCount(ref.current)</p>
			<p class="source-code">      console.log('clicked', ref.current) ➀</p>
			<p class="source-code">    }, 3000)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  console.log('updated', count)    ➁</p>
			<p class="source-code">  ...</p>
			<p class="source-code">} </p>
			<p>We can confirm this via the following timeline sketch:</p>
			<p class="source-code">|-----0.5s-----3.5s------&gt; time</p>
			<p class="source-code">|-----x-x--x-------------&gt; click</p>
			<p class="source-code">|--------------1-2--3----&gt; clicked  ➀</p>
			<p class="source-code">R---------------R-R--R---&gt; update</p>
			<p class="source-code">0---------------1-2--3---&gt; updated  ➁</p>
			<p>Okay, now<a id="_idIndexMarker354"/> everything works after we used a ref to store the number along with the <strong class="source-inline">count</strong> state. The <strong class="source-inline">ref.count++</strong> statement increments the current number and continues to store the updated number. Here, we used both a state and a ref to keep track of a single number. It's overkill, and we do it here to merely demonstrate the solution. In the <em class="italic">useCurrent hook</em> section of <a href="B17963_09_Epub.xhtml#_idTextAnchor314"><em class="italic">Chapter 9</em></a>, <em class="italic">Use Custom Hooks to Reuse Logic</em>, we will refine this approach into something more practical.</p>
			<p class="callout-heading">Playground – Locate the Current Value</p>
			<p class="callout">Feel free to play with this online example at <a href="https://codepen.io/windmaomao/pen/eYEGpJJ">https://codepen.io/windmaomao/pen/eYEGpJJ</a>.</p>
			<p>There's a simpler solution to this problem and it doesn't involve a ref. Remember, a <strong class="source-inline">useState</strong> hook supports another functional format: </p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    setTimeout(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">      setCount(v <strong class="bold">=&gt;</strong> v + 1)</p>
			<p class="source-code">    }, 3000)</p>
			<p class="source-code">  }</p>
			<p>In the preceding code, a functional format setter is used so that we can read out the current state through <strong class="source-inline">v</strong>, because we want to know exactly what the current state is before committing it. The <strong class="source-inline">v =&gt; v + 1</strong> statement becomes essential, and sometimes we can even put some logic inside this function:</p>
			<p class="source-code">      setCount(v <strong class="bold">=&gt; </strong>{ </p>
			<p class="source-code">        // perform some action</p>
			<p class="source-code">        // based on the current v</p>
			<p class="source-code">        <strong class="bold">return</strong> v</p>
			<p class="source-code">      })</p>
			<p>It doesn't seem like the preceding location is the right place to perform other business logic than the value update; however, based on the <strong class="source-inline">useState</strong> design, this actually is the only supported location where you can read the current state consistently. We even returned the current <strong class="source-inline">v</strong> value back, which implies that we only want to get the current value but are not interested in a new update. You can take this as a made-up <strong class="source-inline">getCount</strong> access function for a state.</p>
			<p>All in all, both<a id="_idIndexMarker355"/> solutions reveal the fact that in the current update, the state value can get out of sync with its underlying current value.</p>
			<p>You might have a question at this point – if a ref is that powerful and flexible, why don't we just use it to replace the state? The answer to this question lies in the dilemma that the state that <em class="italic">React</em> wants developers to use is a managed state that takes care of the dispatch upon any state change. However, a ref is a raw state with which the developers still have to manage every other aspect of the <em class="italic">UI</em> update. In a way, if we were using refs for everything, then we would not need to use <em class="italic">React</em> at all because the point of a ref is to hide stuff without catc<a id="_idTextAnchor301"/>hing the engine's attention.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor302"/>Summary</h1>
			<p>In this chapter, we first learned what a <em class="italic">React</em> ref is. We then went over how to access a <em class="italic">DOM</em> element by using a ref and went through the design of the <strong class="source-inline">useRef</strong> hook, and saw how to persist a value without triggering a <em class="italic">UI</em> update. We also gave <strong class="source-inline">useRef</strong> a test drive by walking through an input focus example. In the end, we went through how special it is by showing more examples of its use, including clicking outside of a menu, avoiding memory leaks, setting up a mule, and locating the current value.</p>
			<p>In the next chapter, we will put all the hooks we have learned so far together and see how to finally create your custom hook, tailored<a id="_idTextAnchor303"/> to solve your own problems.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor304"/>Questions and answers</h1>
			<p>Here are some questions and answer<a id="_idTextAnchor305"/>s to refresh your knowledge:</p>
			<ol>
				<li>What is a ref?<p>A <em class="italic">React</em> ref is a container to hold a persistent value. In general, you can use the value as a raw stat<a id="_idTextAnchor306"/>e with no update capability.</p></li>
				<li>What is <strong class="source-inline">useRef</strong>?<p>A <strong class="source-inline">useRef</strong> hook can be used to create a ref in a function component. Once created, it can be used as a persistent container during the <a id="_idTextAnchor307"/>life cycle of the component.</p></li>
				<li>What are the common usages of <strong class="source-inline">useRef</strong>?<p>One major usage of <strong class="source-inline">useRef</strong> is to hold a <em class="italic">DOM</em> instance that can be used to invoke native <em class="italic">DOM</em> functionalities. Another major usage of <strong class="source-inline">useRef</strong> is to sneak behind React to do something without kicking <a id="_idTextAnchor308"/>off the e<a id="_idTextAnchor309"/>ngine accidentally.</p></li>
			</ol>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor310"/>Appendix</h1>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor311"/>Appendix A – Callback ref</h2>
			<p>React comes with two ways of receiving an element instance via the <strong class="source-inline">ref</strong> prop. The easiest one is the one we <a id="_idIndexMarker356"/>introduced, the object format. But there's another one called a callback ref that takes a functional format:</p>
			<p class="source-code"><strong class="bold">function</strong> commitAttachRef(fiber, instance) {</p>
			<p class="source-code">  <strong class="bold">var</strong> ref = fiber.ref;</p>
			<p class="source-code">  <strong class="bold">if</strong> (ref !== <strong class="bold">null</strong>) {</p>
			<p class="source-code">    <strong class="bold">if</strong> (<strong class="bold">typeof</strong> ref === 'function') {</p>
			<p class="source-code">      ref(instance)</p>
			<p class="source-code">    } <strong class="bold">else</strong> {</p>
			<p class="source-code">      ref.current = instance</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Similarly, this functional format is supported when the <em class="italic">DOM</em> element is unmounted:</p>
			<p class="source-code"><strong class="bold">function</strong> commitDetachRef(fiber) {</p>
			<p class="source-code">  <strong class="bold">var</strong> ref = fiber.ref</p>
			<p class="source-code">  <strong class="bold">if</strong> (ref !== <strong class="bold">null</strong>) {</p>
			<p class="source-code">    <strong class="bold">if</strong> (<strong class="bold">typeof</strong> ref === 'function') {</p>
			<p class="source-code">       ref(<strong class="bold">null</strong>)</p>
			<p class="source-code">    } <strong class="bold">else</strong> {</p>
			<p class="source-code">      ref.current = <strong class="bold">null</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>During the DOM attachment or de-attachment, if it finds out the <strong class="source-inline">ref</strong> prop is provided as a functional format, it invokes it and passes the instance to it. Here's the usage:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> ref = useRef()</p>
			<p class="source-code">  <strong class="bold">const</strong> onRef = (instance) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    ref.current = instance</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return &lt;h1</strong> ref={onRef}<strong class="bold">&gt;</strong>...<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p>In the preceding code, an <strong class="source-inline">onRef</strong> function is wired to the <strong class="source-inline">ref</strong> prop. Both ways of setting the ref, either object or callback, are comparable. And the functional way seems to involve more work. So how is this functional format any more useful?</p>
			<p>Although the <strong class="source-inline">ref</strong> object gives <a id="_idIndexMarker357"/>us the assigned <em class="italic">DOM</em> element, it doesn't tell us exactly when the <em class="italic">DOM</em> element is attached or de-attached. So, to capture these moments, we can use a ref callback:</p>
			<p class="source-code">  <strong class="bold">const</strong> ref = useRef()</p>
			<p class="source-code">  <strong class="bold">const</strong> setRef = (r) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">if</strong> (...) {</p>
			<p class="source-code">      ref.current = r</p>
			<p class="source-code">    } <strong class="bold">else</strong> {</p>
			<p class="source-code">      …</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return &lt;h1</strong> ref={setRef}<strong class="bold">&gt;</strong>...<strong class="bold">&lt;/h1&gt;</strong></p>
			<p>In the preceding code, based on a condition, we could decide where we want to store this ref or which ref we want to store. The example only gives a very naïve implementation, but you can see that this provides us more room for custom logic in terms <a id="_idTextAnchor312"/>of managing the DOM instance. </p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor313"/>Appendix B – Forward ref</h2>
			<p>A ref is created to store an<a id="_idIndexMarker358"/> instance of a class, whether the class is a <em class="italic">DOM</em> element or a class component. But not all components are written using a class, such as a function component:</p>
			<p class="source-code"><strong class="bold">function</strong> Title = () {</p>
			<p class="source-code">  <strong class="bold">return</strong> ...</p>
			<p class="source-code">}</p>
			<p class="source-code">// Not valid declaration</p>
			<p class="source-code"><strong class="bold">const</strong> ATitle = <strong class="bold">new</strong> Title()</p>
			<p class="source-code">// Not valid operation</p>
			<p class="source-code">ATitle.doSomething()</p>
			<p>In the preceding code, we have declared <strong class="source-inline">Title</strong> as a function component. But since it's not declared with a class, we do not use <strong class="source-inline">new</strong> to create an instance. Instead, we invoke it via <strong class="source-inline">Title()</strong> at the update. Similarly, because of that, there's no way we can access the internal variables with an instance method such as <strong class="source-inline">ATitle.dosomething()</strong>.</p>
			<p>This is why we mentioned earlier that we can't attach a ref to a function component; by default, it's not what a function component can provide:</p>
			<p class="source-code"><strong class="bold">return </strong>&lt;Title ref={ref} /&gt;</p>
			<p>However, from a practical point of view, it does make sense for the developer to get hold of the <strong class="source-inline">Title</strong> instance and perform some action toward it. So, to address this need and to apply the ref idea consistently to all components, React provides one option called the forward ref:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = React.forwardRef((props, ref) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;h1</strong> ref={ref}<strong class="bold">&gt;</strong></p>
			<p class="source-code">      {props.children}</p>
			<p class="source-code">    <strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">})</p>
			<p>In the preceding setup, by <a id="_idIndexMarker359"/>using a <strong class="source-inline">fowardRef</strong> function provided by <em class="italic">React</em>, we can promote <strong class="source-inline">ref</strong> defined for an <strong class="source-inline">h1</strong> element as the ref of the <strong class="source-inline">Title</strong> component. What does this mean? Let's take a look at one usage:</p>
			<p class="source-code"><strong class="bold">const</strong> App = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> ref = useRef()</p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    ref.current.textContent = "Hello"</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return </strong>&lt;Title ref={ref} /&gt;</p>
			<p class="source-code">}</p>
			<p>In the preceding <strong class="source-inline">App</strong> component, we can now treat <strong class="source-inline">Title</strong> similar to an <strong class="source-inline">h1</strong> element; when we change its content, it literally changes the <strong class="source-inline">h1</strong> text content inside <strong class="source-inline">Title</strong>. Essentially, a ref is passed from the child to the parent. </p>
			<p>A function component, unlike a class component, does not have an instance method in <em class="italic">React</em>, so even when we have a ref now, we need to set up a custom method if we want to support one:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = React.forwardRef((props, ref) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  useImperativeHandler(ref, () <strong class="bold">=&gt;</strong> ({</p>
			<p class="source-code">    go: () <strong class="bold">=&gt;</strong> { ref.current.focus() }</p>
			<p class="source-code">  }))</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;h1</strong> ref={ref}<strong class="bold">&gt;</strong></p>
			<p class="source-code">      {props.children}</p>
			<p class="source-code">    <strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">})</p>
			<p>In the preceding code, React provides a built-in hook called <strong class="source-inline">useImperativeHandle</strong> to allow us to customize the instance value. In this example, we add a <strong class="source-inline">go</strong> custom method for ref:</p>
			<p class="source-code"><strong class="bold">const</strong> App = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> ref = useRef()</p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    ref.current.go()</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return </strong>&lt;Title ref={ref} /&gt;</p>
			<p class="source-code">}</p>
			<p>This way, when we ask the <strong class="source-inline">Title</strong> instance to go, it focuses on the <strong class="source-inline">h1</strong> element. </p>
			<p>So, with <strong class="source-inline">forwardRef</strong> and <strong class="source-inline">useImperativeHandle</strong>, we add a ref to a function component. This provides<a id="_idIndexMarker360"/> more opportunity for the developer to add manual control to the function component. However, we need to understand that a ref passed from the child to the parent originates from a single element, so technically speaking, a ref done this way is still a ref of that element, not a real ref for the function component.</p>
		</div>
	</body></html>