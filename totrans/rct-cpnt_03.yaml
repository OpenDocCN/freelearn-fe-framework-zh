- en: Chapter 3. Saving and Communicating Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created complex component hierarchies. We created
    a list of pages and a way to edit those pages. Yet we stopped short of saving
    and reading any of that data to some kind of storage.
  prefs: []
  type: TYPE_NORMAL
- en: We could, for instance, send an edit through an Ajax request to be saved in
    a database server. In fact, that's what often happens in the applications we use
    these days. They always save our interactions, irrespective of whether we expect
    them to or not.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about local data stores and communicating with
    them. You'll also learn about event-based architecture and how it promotes the
    unidirectional flow of data.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to save data. It's a rich and interesting topic that could
    fill scores of books. I could go so far as to say it is at the core of how businesses
    and applications work.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, how data is communicated can often be different in a maintainable
    application and an unmaintainable application. It's up to us to figure out elegant
    ways of persisting data so that our applications remain maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: We will only explore local storage in this chapter. You'll be able to see your
    stored data beyond page reloads, but nobody else will. You cannot build a practical
    website based on this chapter alone. You will have to wait until we explore React
    on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Validating properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we look at storing data, there is another habit I'd like to share with
    you. The components we created in the last chapter work well together, but our
    aim is to make each component self-contained. We want others to be able to reuse
    our components, but they will encounter problems if they don't know which properties
    our components expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what would happen if we used `PageAdmin` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Faced with this component, and no documentation, it might be tempting to substitute
    a `Backend` object with some other configuration data. This looks reasonable to
    someone unfamiliar with the component. And, without a careful study of all our
    components, we can't expect others to know what those properties should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can protect against this situation by adding property validation. Let''s
    add some validation to `PageEd` `itor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have already imported the `React` object, which exposes a `PropTypes` object.
    This contains some validators. When we specify a few on `PageEditor.propTypes`,
    React checks the types of properties given to the component as it is rendered.
    If we give the incorrect property types or omit required properties, React will
    emit a warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The warnings look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating properties](img/5268_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are many types to choose from, the simple ones being the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`React.PropTypes.array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`React.PropTypes.bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`React.PropTypes.func`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`React.PropTypes.number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`React.PropTypes.object`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`React.PropTypes.string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you need a property to be required (which is likely in most cases) then
    you can add `.isRequired` at the end. Let''s follow this up with validators for
    `PageView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is even simpler, given that `PageView` uses fewer properties than `PageEditor`.
    Also, `Page` is relatively simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to validate properties passed straight through components. For
    instance, `PageEditor` uses `onUpdate`. It's passed through `Page`, but `Page`
    doesn't use it, `PageEditor` does, so that's where we use validators for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, what if we want to validate nested structures or more complex types?
    We can try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We expect the `backend` property to be an instance of the `Backend` class.
    If it is anything else, we return an `Error` describing why the property is invalid.
    We can also use `shape` to validate nested properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The more specific we are about properties, the less chance there is for bad
    properties to break the interface. So, it's good to get in the habit of defining
    them all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Storing cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You must have heard of cookies before. They''re a browser-based storage mechanism
    as old as the Internet, and they are often comically described in movies. Here''s
    how we use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `document.cookie` parameter works as a temporary string store. You can keep
    adding new strings, where the key and value are separated by `=`, and they will
    be stored beyond a page reload, that is, until you reach the limit of how many
    cookies your browser will store per domain. If you set `document.cookie` multiple
    times, multiple cookies will be set.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read the cookies back again, with a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The whole cookie string is read and split using semicolons. Then, each cookie
    is split into equals, leaving the key and value. These are stored in the local
    `cookies` object. Future requests just read the key from the local object. The
    `cookies` object can be inspected at any point to see the cookies that have been
    set.
  prefs: []
  type: TYPE_NORMAL
- en: Try [http://browsercookielimits.squawky.net](http://browsercookielimits.squawky.net)
    to test what your browser can handle. I'm running a modern version of Chrome,
    and I can probably store 180 cookies per domain, totaling 4096 bytes. 4096 bytes
    doesn't sound like a lot...
  prefs: []
  type: TYPE_NORMAL
- en: Cookies aren't typically used for the kinds of data we want to store. We'll
    have to look elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to learn more about how to use cookies, head over to [https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie](https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie).
  prefs: []
  type: TYPE_NORMAL
- en: Using local storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next type of storage we will look at is a relatively recent addition to
    the browser toolset. It''s called *local storage*, and it''s been around for a
    while. You can add items to it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s simpler than cookies to read items from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will persist the data beyond page reloads or the browser closing. You can
    store considerably more data than in cookies (anywhere from 3 MB to 10 MB, by
    default), and the interface is easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how can we use this to store our pages? Let''s abstract local storage a
    bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For once, we're exporting an object instead of a class. This object has a couple
    of methods both of which access `window.localStorage`. It's not ideal to reference
    this directly, but if we use this abstraction everywhere else, then I think it's
    OK.
  prefs: []
  type: TYPE_NORMAL
- en: The `get` method pulls a string value out of local storage and parses it as
    a JSON string. If the value parses to any non-false value, we return it, or else
    we return a default value.
  prefs: []
  type: TYPE_NORMAL
- en: The `set` method encodes a value as JSON, and stores it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can use the following abstraction in the `Backend` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We begin with a constructor that fetches any stored pages from `localStorage`.
    We provide a default empty array in case the `pages` key is missing in `localStorage`.
    We store that in `this.pages` so we can fetch and modify it later.
  prefs: []
  type: TYPE_NORMAL
- en: The `getAll` method is much simpler this time around. All it does is returns
    `this.pages`. The `update` and `delete` methods become more interesting though.
    The `update` method uses the `Array.map` method to apply updates to the affected
    page objects. We have to store the updated `pages` array back in local storage
    so that the changes are persisted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, `delete` modifies the `pages` array (this time with a short function
    syntax) and stores the modified array back in local storage. We have to see local
    storage with some initial data. You can do this in a developer console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you've made these changes, and you refresh the page, you should see the new
    backend code in action!
  prefs: []
  type: TYPE_NORMAL
- en: Using event emitters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, our components have communicated with the backend through method
    calls. That's OK for tiny applications, but when things start to scale, we will
    forget to make some of those method calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at `onUpdate`, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Every time we change the state of a page, we have to fetch an updated list of
    pages from the backend. What if multiple components send updates to the backend?
    How will our `PageAdmin` component know when to fetch a new list of pages?
  prefs: []
  type: TYPE_NORMAL
- en: We can turn to event-based architecture to solve this problem. We've already
    encountered and used events! Recollect what we did when we created the page edit
    form. There, we connected to input events so we could update pages when input
    values changed.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of architecture moves us closer to a unidirectional flow of data.
    We can imagine our entire application like a tree of components, beginning with
    a single root component. When a component needs to update some application's state,
    we don't need to code the state change in relation to where that component is.
    In the past, we may have had to reference specific CSS selectors, or depend on
    the position of sibling elements, when updating state.
  prefs: []
  type: TYPE_NORMAL
- en: When we start to use events, then any component can trigger a change in the
    application. Also, multiple components can trigger the same kind of change. We'll
    explore this idea in more detail in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use that same idea to notify components when the data changes. To begin
    with, we need to download an event emitter class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `Backend` can extend this, providing the event functionality that we are
    after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As each page is updated or deleted, the backend will emit an event on itself.
    This does nothing until we listen for these events in `PageAdmin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now we can remove the numerous calls to `this.setState` and replace them with
    a single event listener in the `constructor`. We are also doing something interesting
    with the `setState` call. It's called *object destructuring*, and it allows `{pages}`
    to become `{"pages":pages}`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can begin to use this backend for many different parts of the interface,
    and they'll all have accurate, real-time data. Open the page up in a few different
    windows and watch them all update at once!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to protect our components from faulty properties.
    We also saw how easy it was to use cookies, although they are limited for what
    we need. Fortunately, we can use local storage and work it into our existing backend
    and components.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored using events to push state changes out to all interested
    components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start prettying up our components. We'll look at
    ways to style and animate them, bringing our interface to life!
  prefs: []
  type: TYPE_NORMAL
