- en: Unit Testing in Angular
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的单元测试
- en: The hard work of the previous chapters has materialized into a working application
    we can be proud of. But how can we ensure a painless maintainability in the future?
    A comprehensive automated testing layer will become our lifeline once our application
    begins to scale up and we have to mitigate the impact of bugs, caused by new functionalities
    colliding with the already existing ones.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章的辛勤工作已经变成了一个我们可以引以为傲的工作应用程序。但是，我们如何确保未来的可维护性？一套全面的自动化测试层将成为我们的生命线，一旦我们的应用程序开始扩展，我们就必须减轻由新功能与已经存在的功能相冲突而引起的错误的影响。
- en: Testing (and more specifically, unit testing) is meant to be carried out by
    the developer as the project is being developed. However, we will cover all the
    intricacies of testing Angular modules in brief in this chapter, now that the
    project is at a mature stage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试（更具体地说，单元测试）应该由开发人员在项目开发过程中进行。然而，在本章中，我们将简要介绍测试Angular模块的所有复杂性，因为项目已经处于成熟阶段。
- en: In this chapter, you will see how to implement testing tools to perform proper
    unit testing of your application classes and components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将看到如何实现测试工具，以对应用程序的类和组件进行适当的单元测试。
- en: 'In this chapter, we will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Look at the importance of testing and, more specifically, unit testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看测试的重要性，更具体地说，单元测试
- en: Build a test spec testing a pipe
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建测试管道的测试规范
- en: Design unit tests for components, with or without dependencies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为具有或不具有依赖项的组件设计单元测试
- en: Put our routes to the test
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对我们的路由进行测试
- en: Implement tests for services, mocking dependencies, and stubs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为服务实现测试，模拟依赖项和存根
- en: Intercept XHR requests and provide mocked responses for refined control
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拦截XHR请求并提供模拟响应以进行精细控制
- en: Discover how to test directives as components with no view
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何测试指令作为没有视图的组件
- en: Introduce other concepts and tools such as Karma, code coverage tools,
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍其他概念和工具，如Karma、代码覆盖工具
- en: and **end-to-end** (**E2E**) testing
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 和端到端（E2E）测试
- en: Why do we need tests?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我们需要测试？
- en: What is a unit test? If you're familiar already with unit testing and test-driven
    development, you can safely skip to the next section. If not, let's say that unit
    tests are part of an engineering philosophy that takes a stand for efficient and
    agile development processes, by adding an additional layer of automated testing
    to the code, before it is developed. The core concept is that each piece of code
    is delivered with its own test, and both pieces of code are built by the developer
    who is working on that code. First, we design the test against the module we want
    to deliver, checking the accuracy of its output and behavior. Since the module
    is still not implemented, the test will fail. Hence, our job is to build the module
    in such a way that it passes its own test.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是单元测试？如果您已经熟悉单元测试和测试驱动开发，可以安全地跳过下一节。如果不熟悉，让我们说单元测试是工程哲学的一部分，它支持高效和敏捷的开发过程，通过在代码开发之前为代码添加一层自动化测试。核心概念是每一段代码都有自己的测试，并且这两段代码都是由正在开发该代码的开发人员构建的。首先，我们设计针对我们要交付的模块的测试，检查其输出和行为的准确性。由于模块还没有实现，测试将失败。因此，我们的工作是以使模块通过自己的测试的方式构建模块。
- en: Unit testing is quite controversial. While there is a common agreement about
    how beneficial test-driven development for ensuring code quality and maintenance
    over time is, not everybody undertakes unit testing in their daily practice. Why
    is that? Well, building tests while we develop our code can feel like a burden
    sometimes, particularly when the test winds up being bigger in size than the piece
    of functionality it aims to test.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是相当有争议的。虽然人们普遍认为测试驱动开发对于确保代码质量和随时间的维护是有益的，但并不是每个人在日常实践中都进行单元测试。为什么呢？嗯，在开发代码的同时构建测试有时可能会感觉像是一种负担，特别是当测试的规模比它旨在测试的功能部分还要大时。
- en: 'However, the arguments favoring testing outnumber the arguments against it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，支持测试的论点比反对它的论点多得多：
- en: Building tests contributes to better code design. Our code must conform to the
    test requirements and not the other way around. In that sense, if we try to test
    an existing piece of code and we find ourselves blocked at some point, chances
    are that the piece of code we aim to test is not well designed and shows off a
    convoluted interface that requires some rethinking. On the other hand, building
    testable modules can help with early detection of side effects on other modules.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建测试有助于更好的代码设计。我们的代码必须符合测试要求，而不是相反。在这种意义上，如果我们试图测试现有的一段代码，并且在某个时候发现自己被阻止了，那么这段代码很可能设计不良，并展示出需要重新思考的复杂接口。另一方面，构建可测试的模块可以帮助早期发现对其他模块的副作用。
- en: Refactoring tested code is the lifeline against introducing bugs in later stages.
    Any development is meant to evolve with time, and on every refactor the risk of
    introducing a bug, that will only pop up in another part of our application, is
    high. Unit tests are a good way to ensure that we catch bugs at an early stage,
    either when introducing new features or when updating existing ones.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构经过测试的代码是防止在后期引入错误的生命线。任何开发都意味着随着时间的推移而发展，每次重构都会引入错误的风险，这些错误可能只会在我们应用程序的另一个部分中出现。单元测试是确保我们在早期捕捉错误的好方法，无论是在引入新功能还是更新现有功能时。
- en: Building tests is a good way to document our code APIs and functionalities.
    And this becomes a priceless resource when someone not acquainted with the code
    base takes over the development endeavor.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建测试是记录我们的代码API和功能的好方法。当一个不熟悉代码库的人接手开发工作时，这将成为无价的资源。
- en: These are only a few arguments, but you can find countless resources on the
    web about the benefits of testing your code. If you do not feel convinced yet,
    give it a try. Otherwise, let's continue with our journey and see the overall
    form of a test.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一些论点，但你可以在网上找到无数关于测试代码好处的资源。如果你还不感到满意，不妨试一试。否则，让我们继续我们的旅程，看看测试的整体形式。
- en: The anatomy of a unit test
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试的解剖结构
- en: There are many different ways to test a piece of code, but in this chapter we
    will look at the anatomy of a test, what it is made up of. The first thing we
    need, for testing any code, is a test framework. The test framework should provide
    utility functions for building test suites, containing one or several test specs
    each. So what are these concepts?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方法来测试一段代码，但在本章中，我们将看看测试的解剖结构，它由什么组成。测试任何代码的第一件事是测试框架。测试框架应该提供用于构建测试套件的实用函数，每个套件包含一个或多个测试规范。那么这些概念是什么呢？
- en: '**Test suite**: A suite creates a logical grouping for a bunch of tests. A
    suite can, for example, be all the tests for a product page.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试套件**：套件为一组测试创建了一个逻辑分组。例如，一个套件可以是产品页面的所有测试。'
- en: '**Test spec**: This is another name for a unit test.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试规范**：这是单元测试的另一个名称。'
- en: 'The following shows what a test file can look like where we are using a test
    suite and placing a number of related tests inside. The chosen framework for this
    is Jasmine. In Jasmine, the `describe()`function helps us to define a test suite.
    The `describe()`method takes a name as the first parameter and a function as the
    second parameter. Inside of the `describe()` function are a number of invocations
    to the `it()`method. The `it()` function is our unit test; it takes the name of
    the test as the first parameter and a function as the second parameter:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了一个测试文件的样子，我们在其中使用了一个测试套件，并放置了许多相关的测试。我们选择的框架是Jasmine。在Jasmine中，`describe()`函数帮助我们定义一个测试套件。`describe()`方法以名称作为第一个参数，以函数作为第二个参数。在`describe()`函数内部有许多对`it()`方法的调用。`it()`函数是我们的单元测试；它以测试名称作为第一个参数，以函数作为第二个参数：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each test spec checks out a specific functionality of the feature described
    in the suite description argument and declares one or several expectations in
    its body. Each expectation takes a value, which we call the expected value, and
    is compared against an actual value by means of a matcher function, which checks
    whether expected and actual values match accordingly. This is what we call an
    assertion, and the test framework will pass or fail the spec depending on the
    result of such assertions. The code is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试规范检查套件描述参数中描述的功能的特定功能，并在其主体中声明一个或多个期望。每个期望都取一个值，我们称之为期望值，并通过匹配器函数与实际值进行比较，该函数检查期望值和实际值是否相匹配。这就是我们所说的断言，测试框架将根据这些断言的结果通过或失败规范。代码如下：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous example, `add(1,1)` will return the actual value that is supposed
    to match the expected value declared in the `toBe()` matcher function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`add(1,1)`将返回实际值，这个值应该与`toBe()`匹配器函数中声明的期望值相匹配。
- en: Worth noting from the previous example is the addition of a second test that
    tests our `subtract()`function. We can clearly see that this test deals with yet
    another mathematical operation, thus it makes sense to group both these tests
    under one suite.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中值得注意的是添加了第二个测试，测试了我们的`subtract()`函数。我们可以清楚地看到，这个测试处理了另一个数学运算，因此将这两个测试分组在一个套件下是有意义的。
- en: 'So far, we have learned about test suites and how to group tests according
    to their function. Furthermore, we have learned about invoking the code you want
    to test and asserting that it does what you think it does. There are, however,
    more concepts to a unit test worth knowing about, namely setup and tear-down functionality.
    A setup functionality is something that sets up your code before the test is run
    usually. It''s a way to keep your code cleaner so you can focus on just invoking
    the code and asserting. A tear-down functionality is the opposite of a setup functionality
    and is dedicated to tearing down what you set up initially; essentially it''s
    a way to clean up after the test. Let''s see how this can look in practice with
    a code example, using the Jasmine framework. In Jasmine, the `beforeEach()`method
    is used for setup functionality; it runs before every unit test. The `afterEach()`
    method is used to run tear-down logic. The code is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了测试套件以及如何根据其功能对测试进行分组。此外，我们已经了解了调用要测试的代码并断言它是否按照你所想的那样做的概念。然而，单元测试还有更多值得了解的概念，即设置和拆卸功能。设置功能是在测试运行之前设置代码的功能。这是一种使代码更清晰的方式，因此您可以专注于调用代码和断言。拆卸功能是设置功能的相反，专门用于拆卸最初设置的内容；本质上，这是一种在测试后进行清理的方式。让我们看看这在实践中是什么样子，使用Jasmine框架的代码示例。在Jasmine中，`beforeEach()`方法用于设置功能；它在每个单元测试之前运行。`afterEach()`方法用于运行拆卸逻辑。代码如下：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can see in the preceding code how the `beforeEach()` function is responsible
    for instantiating the `productService`, which means the test only has to care
    about invoking production code and asserting the outcome. This makes the test
    look cleaner. It should be said, though, in reality, tests tend to have a lot
    of setup going on and having a `beforeEach()`function can really make the tests
    look cleaner; above all, it tends to make it easier to add new tests, which is
    great. What you want at the end of the day is well-tested code; the easier it
    is to write and maintain such code, the better for your software.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的代码中看到`beforeEach()`函数负责实例化`productService`，这意味着测试只需要关心调用生产代码和断言结果。这使得测试看起来更清晰。不过，实际上，测试往往需要进行大量的设置，有一个`beforeEach()`函数可以使测试看起来更清晰；最重要的是，它往往使添加新测试变得更容易，这是很棒的。最终你想要的是经过充分测试的代码；编写和维护这样的代码越容易，对你的软件就越好。
- en: Introduction to testing in Angular
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular中进行测试的介绍
- en: 'In the section *The anatomy of a unit test*, we gained familiarity with unit
    testing and its general concepts, such as test suites, test specs, and assertions.
    Armed with that knowledge, it is now time to venture into unit testing with Angular.
    Before we start writing tests for Angular, though, we will first give an introduction
    to the tooling that exists within the Angular CLI to make unit testing a nice
    experience. When venturing into unit testing in Angular, it''s important to know
    what major parts it consists of. In Angular these are:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在*单元测试的解剖*部分，我们熟悉了单元测试及其一般概念，比如测试套件、测试规范和断言。掌握了这些知识，现在是时候深入了解在Angular中进行单元测试了。不过，在我们开始为Angular编写测试之前，我们将首先介绍Angular
    CLI中存在的工具，以使单元测试成为一种愉快的体验。在Angular中进行单元测试时，了解它由哪些主要部分组成是很重要的。在Angular中，这些部分包括：
- en: Jasmine, the testing framework
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jasmine，测试框架
- en: Angular testing utilities
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular测试工具
- en: Karma, a test runner for running unit tests, among other things
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Karma，一个用于运行单元测试的测试运行器，还有其他功能
- en: Protractor, Angular's framework for E2E testing
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Protractor，Angular的E2E测试框架
- en: Configuration and setting up
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和设置
- en: 'In terms of configuration, when using the Angular CLI, you don''t have to do
    anything to make it work. You can, as soon as you scaffold a project, run your
    first test and it will work. As you venture deeper into unit testing in Angular,
    you will need to be aware of a few concepts that leverage your ability to test
    different constructs, such as components and directives. The Angular CLI is using
    Karma as the test runner. What we need to know about Karma is that it uses a `karma.conf.js`
    file, a configuration file, in which a lot of things are specified, such as:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置方面，当使用Angular CLI时，你不需要做任何事情来使其工作。一旦你搭建一个项目，就可以运行你的第一个测试，它就会工作。当你深入研究Angular中的单元测试时，你需要了解一些概念，这些概念可以提高你测试不同构造的能力，比如组件和指令。Angular
    CLI使用Karma作为测试运行器。关于Karma我们需要知道的是它使用一个`karma.conf.js`文件，一个配置文件，其中指定了很多东西，比如：
- en: The various plugins that enhance your test runner.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强你的测试运行器的各种插件。
- en: Where to find the tests to run?  It should be said that there is usually a files
    property in this file specifying where to find the application and the tests.
    For the Angular CLI, however, this specification is found in another file called
    `src/tscconfig-spec.json`.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在哪里找到要运行的测试？应该说的是，通常在这个文件中有一个files属性，指定了在哪里找到应用程序和测试。然而，对于Angular CLI，这个规范是在另一个名为`src/tscconfig-spec.json`的文件中找到的。
- en: Setup of your selected coverage tool, a tool that measures to what degree your
    tests cover the production code.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你选择的覆盖工具的设置，一个衡量你的测试覆盖生产代码程度的工具。
- en: Reporters, report every executed test in a console window, to a browser, or
    through some other means.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告者，在控制台窗口、浏览器或其他方式中报告每个执行的测试。
- en: 'Browsers to run your tests in: for example, Chrome or PhantomJS.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于运行测试的浏览器：例如，Chrome或PhantomJS。
- en: Using the Angular CLI, you most likely won't need to change or edit this file
    yourself. It is good to know that it exists and what it does for you.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular CLI，您很可能不需要自己更改或编辑此文件。知道它的存在以及它为您做了什么是很好的。
- en: Angular testing utilities
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular测试工具
- en: 'The Angular testing utilities help to create a testing environment that makes
    writing tests for your various constructs really easy. It consists of the `TestBed`
    class and various helper functions, found under the `@angular/core/testing` namespace.
    We will learn what these are and how they can help us to test various constructs
    as this chapter progresses. We will shortly introduce the most commonly used concepts
    so that you are familiar with them as we present them more deeply further on:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Angular测试工具有助于创建一个测试环境，使得为各种构造编写测试变得非常容易。它由`TestBed`类和各种辅助函数组成，位于`@angular/core/testing`命名空间下。随着本章的进行，我们将学习这些是什么以及它们如何帮助我们测试各种构造。我们将很快介绍最常用的概念，以便在我们进一步介绍它们时您对它们有所了解：
- en: The `TestBed`class is the most important concept and creates its own testing
    module. In reality, when you test out a construct to detach it from the module
    it resides in and reattach it to the testing module created by the `TestBed`.
    The `TestBed` class has a `configureTestModule()`helper method that we use to
    set up the test module as needed. The `TestBed` can also instantiate components.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestBed`类是最重要的概念，它创建自己的测试模块。实际上，当您测试一个构造以将其从所在的模块中分离出来并重新连接到`TestBed`创建的测试模块时。`TestBed`类有一个`configureTestModule()`辅助方法，我们用它来设置所需的测试模块。`TestBed`还可以实例化组件。'
- en: '`ComponentFixture`is a class wrapping the component instance. This means that
    it has some functionality on it and it has a member that is the component instance
    itself.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ComponentFixture`是一个包装组件实例的类。这意味着它具有一些功能，并且它有一个成员，即组件实例本身。'
- en: The `DebugElement`, much like the `ComponentFixture`, acts as a wrapper. It,
    however, wraps the DOM element and not the component instance. It's a bit more
    than that though, as it has an injector on it that allows us to access the services
    that have been injected into a component. More on this topic later.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DebugElement`，就像`ComponentFixture`一样，充当包装器。但是，它包装的是DOM元素，而不是组件实例。它还有一个注入器，允许我们访问已注入到组件中的服务。稍后会详细介绍这个主题。'
- en: This was a brief overview to our testing environment, the frameworks and libraries
    used, as well as some important concepts that we will use heavily in the upcoming
    sections.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对我们的测试环境、使用的框架和库以及一些重要概念的简要概述，我们将在接下来的部分中大量使用它们。
- en: Introduction to component testing
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件测试简介
- en: Our usual method of operation for doing anything Angular by now, is to use the Angular
    CLI. Working with tests is no different. The Angular CLI lets us create tests,
    debug them, and run them; it also gives us an understanding of how well our tests
    cover the code and its many scenarios. Let's have a quick look at how we can get
    going with some unit testing using the Angular CLI, and try to understand what
    is given to us by default.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们进行任何Angular操作的通常方法是使用Angular CLI。处理测试也不例外。Angular CLI让我们创建测试，调试它们并运行它们；它还让我们了解我们的测试覆盖了代码及其许多场景的程度。让我们快速看一下如何使用Angular
    CLI进行单元测试，并尝试理解默认情况下给我们的内容。
- en: If you want to code along with this chapter, you can either take an old Angular
    project and add tests to it or create a new standalone project, if you want to
    focus on practice testing only. The choice is yours.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想跟着本章的代码进行编写，可以使用旧的Angular项目并为其添加测试，或者创建一个新的独立项目，如果您只想专注于实践测试。选择权在您。
- en: 'If you opt for creating a new project, then type the following to scaffold
    it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择创建一个新项目，然后键入以下内容进行搭建：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Angular CLI comes with testing already set up, so the only thing we need
    to do is follow in its footsteps and add more tests, but let's first examine what
    we've got and learn some neat commands to make it easier to work with testing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI已经设置好了测试，所以我们需要做的唯一的事情就是跟随它的步伐并添加更多的测试，但让我们首先检查一下我们已经得到了什么，并学习一些很棒的命令，以使测试工作更容易。
- en: 'The first thing we want to do is the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的第一件事是：
- en: Investigate the tests that the Angular CLI has given us
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查Angular CLI给我们的测试
- en: Run the tests
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'By looking in the scaffolded `directory/app`, we see the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看搭建的`directory/app`，我们看到了以下内容：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We see a component being declared, together with a unit test. This means we
    get tests with our components, which is very good news as it saves us a bit of
    typing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一个组件被声明，连同一个单元测试。这意味着我们可以对我们的组件进行测试，这是非常好的消息，因为它节省了我们一些输入。
- en: 'Let''s have a look at the test that was given to us:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下给我们的测试：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That''s a lot of code, but we will break it down. We see the testing setup,
    at the beginning of the file, with three different tests being written. Let''s
    have a look at the setup phase first:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多代码，但我们会逐步分解它。我们看到在文件的开头有测试设置，编写了三个不同的测试。让我们先看一下设置阶段：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we are calling `beforeEach()`, as we normally do in a Jasmine test, to
    run code before each test actually happens. Inside of the `beforeEach()`, we call
    the `TestBed.configureTestingModule()`method, with an object as an argument. The
    object resembles the object that we give the `NgModule` as an argument. This means
    we can take our knowledge of `NgModule` and how to set up Angular modules and
    apply that to how to set up testing modules, because it is really one and the
    same. Looking at the code, we can see that we specify a declarations array with
    the `AppComponent` as an item in that array. For `NgModule`, this means that the `AppComponent`belongs
    to that module. Lastly, we call the `compileComponents()` method and the setup
    is done.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们调用`beforeEach()`，就像我们在Jasmine测试中通常做的那样，以便在每个测试实际发生之前运行代码。在`beforeEach()`中，我们调用`TestBed.configureTestingModule()`方法，带有一个对象作为参数。这个对象类似于我们给`NgModule`作为参数的对象。这意味着我们可以利用我们对`NgModule`以及如何设置Angular模块的知识，并将其应用到如何设置测试模块，因为它实际上是一样的。从代码中可以看出，我们指定了一个包含`AppComponent`的声明数组。对于`NgModule`来说，这意味着`AppComponent`属于该模块。最后，我们调用了`compileComponents()`方法，设置完成。
- en: So what does the `compileComponents()`do? As per its name, it compiles components
    that are configured in the testing module. In the compilation process, it also
    inlines external CSS files as well as external templates. By calling `compileComponents()`,
    we also close down the possibility to further configure the testing module instance.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`compileComponents()`是做什么的呢？根据它的名称，它编译了在测试模块中配置的组件。在编译过程中，它还内联外部CSS文件以及外部模板。通过调用`compileComponents()`，我们也关闭了进一步配置测试模块实例的可能性。
- en: 'The second part of our test files are the tests. Look at the first test:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试文件的第二部分是测试。看一下第一个测试：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We see that we call `TestBed.createComponent(AppComponent)`, this returns an
    object of type `ComponentFixture<AppComponent>`. We are able to interact with
    this object further by calling:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们调用了`TestBed.createComponent(AppComponent)`，这返回一个类型为`ComponentFixture<AppComponent>`的对象。我们可以通过调用这个对象进一步进行交互：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This gives us a component instance, which is what we get when we instantiate
    an object from the following class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一个组件实例，这就是当我们从以下类实例化一个对象时得到的东西：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first test just wants to verify that we are able to create a component and
    the `expect` condition tests just that, that `expect(app)`  is truthy, meaning
    is it declared; and in truth it is.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试只是想验证我们能否创建一个组件，`expect`条件测试的就是这个，即`expect(app)`是真实的，意思是它是否被声明；而事实上它是。
- en: 'For the second test, we actually try to investigate whether our component contains
    the properties and values we think; so the test looks like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个测试，我们实际上是要调查我们的组件是否包含我们认为的属性和值；所以测试看起来像这样：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, this test creates a component but it also calls `fixture.detectChanges`,
    which tells Angular to force change detection. This will make sure that the code
    in the constructor and any `ngInit()`, if it exists, is executed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个测试创建了一个组件，但它也调用了`fixture.detectChanges`，这告诉Angular强制进行变更检测。这将确保构造函数中的代码和任何`ngInit()`（如果存在）都被执行。
- en: 'With a component specification we expect that the `title` property should get
    set when the component is created, like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组件规范，我们期望在创建组件时`title`属性应该被设置，就像这样：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That is exactly what the second test is testing:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是第二个测试正在测试的：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s see how this works by extending our `app.component.ts` with one more
    field:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过在`app.component.ts`中添加一个字段来扩展它的功能：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We added the description field and also initialized it with a value; we will
    test whether this value is set to our property. Therefore, we need to add an extra
    `expect` condition in our test, so the test now looks like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了描述字段，并用一个值进行了初始化；我们将测试这个值是否设置为我们的属性。因此，我们需要在我们的测试中添加额外的`expect`条件，所以测试现在看起来像这样：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, we have an extra `expect` condition and the test passes as
    it should. Don''t take our word for it though; let''s run our test runner using
    a node command. We do that by typing:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们有了额外的`expect`条件，测试通过了，这正是应该的。不过，不要只听我们的话；让我们使用node命令运行我们的测试运行程序。我们通过输入以下内容来做到这一点：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will execute the test runner and it should look something like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行测试运行程序，应该看起来像这样：
- en: '![](assets/c1d52a8b-e0d5-421b-9c89-baf25a27f352.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c1d52a8b-e0d5-421b-9c89-baf25a27f352.png)'
- en: 'This means that we understand how to extend our component and test for it.
    As a bonus, we now also know how to run our tests. Let''s have a look at the third
    test. It is a bit different as it tests the template:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们知道如何扩展我们的组件并对其进行测试。作为奖励，我们现在也知道如何运行我们的测试。让我们看看第三个测试。它有点不同，因为它测试模板：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Instead of talking to `fixture.debugElement.componentInstance`, we now talk
    to `fixture.debugElement.nativeElement`. This will allow us to verify that the
    expected HTML markup is what we think it is. When we have access to the `nativeElement`,
    we can use the `querySelector` and find the elements we defined in our template
    and verify their content.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再与`fixture.debugElement.componentInstance`交谈，而是与`fixture.debugElement.nativeElement`交谈。这将允许我们验证预期的HTML标记是否与我们认为的一样。当我们可以访问`nativeElement`时，我们可以使用`querySelector`并找到我们在模板中定义的元素并验证它们的内容。
- en: 'We''ve gained quite a lot of insight just by looking at the test we were given.
    We now know the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看我们得到的测试，我们获得了很多见解。我们现在知道以下内容：
- en: We set up the test by calling `TestBed.configureTestingModule()` and pass it
    an object that looks like the object we pass to `NgModule`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过调用`TestBed.configureTestingModule()`并传递一个类似于我们传递给`NgModule`的对象来设置测试
- en: We call `TestBed.createComponent(<Component>)` to get a reference to a component
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用`TestBed.createComponent(<Component>)`来获取对组件的引用
- en: We call `debugElement.componentInstance` on our component reference to get to
    the actual component and we can test for the existence and values of properties
    that should exist on our component object
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用`debugElement.componentInstance`来获取到实际的组件，我们可以测试组件对象上应该存在的属性的存在和值
- en: We call `debugElement.nativeElement`to get a reference to the `nativeElement`
    and can now start verifying the resulting HTML
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用`debugElement.nativeElement`来获取对`nativeElement`的引用，现在可以开始验证生成的HTML
- en: We also learned how to run our tests in the browser by typing `npm test`
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还学会了如何通过输入`npm test`在浏览器中运行我们的测试
- en: '`fixture.debugElement.nativeElement`points to the HTML element itself. When
    we use the `querySelector()` method, we are in fact using a method available in
    the Web API; it''s not an Angular method.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`fixture.debugElement.nativeElement`指向HTML元素本身。当我们使用`querySelector()`方法时，实际上使用的是Web
    API中可用的方法；这不是Angular方法。'
- en: Component testing with dependencies
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有依赖关系的组件测试
- en: 'We have learned a lot already, but let''s face it, no component that we build
    will be as simple as the one we wrote in the preceding section. There will almost
    certainly be at least one dependency, looking like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学到了很多，但让我们面对现实，我们构建的任何组件都不会像我们在前面的部分中编写的那样简单。几乎肯定会至少有一个依赖项，看起来像这样：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have different ways of dealing with testing such a situation. One thing
    is clear though: if we are testing the component, then we should not test the
    service as well. This means that when we set up such a test, the dependency should
    not be the real thing. There are different ways of dealing with that when it comes
    to unit testing; no solution is strictly better than the other:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有不同的方法来处理测试这样的情况。不过有一点是清楚的：如果我们正在测试组件，那么我们不应该同时测试服务。这意味着当我们设置这样的测试时，依赖项不应该是真正的东西。在进行单元测试时，处理这种情况有不同的方法；没有一种解决方案比另一种严格更好：
- en: Using a stub means that we tell the dependency injector to inject a stub that
    we provide, instead of the real thing
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存根意味着我们告诉依赖注入器注入我们提供的存根，而不是真正的东西
- en: Injecting the real thing, but attaching a spy, to the method that we call in
    our component
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入真正的东西，但附加一个间谍，调用我们组件中的方法
- en: Regardless of the approach, we ensure that the test is not performing a side
    effect such as talking to a filesystem or attempting to communicate via HTTP;
    we are, using this approach, isolated.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 无论采用何种方法，我们都确保测试不会执行诸如与文件系统交谈或尝试通过HTTP进行通信等副作用；使用这种方法，我们是隔离的。
- en: Using a stub to replace the dependency
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用存根来替换依赖项
- en: 'Using a stub means that we completely replace what was there before. It is
    as simple to do as instructing the `TestBed` in the following way:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存根意味着我们完全替换了以前的东西。指导`TestBed`进行这样的操作就像这样简单：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We define a `providers` array like we do with the `NgModule`, and we give it
    a list item that points out the definition we intend to replace and we give it
    the replacement instead; that is our stub.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像在`NgModule`中那样定义一个`providers`数组，并给它一个指出我们打算替换的定义的列表项，然后给它替换；那就是我们的存根。
- en: 'Let''s now build our `DependencyStub` to look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建我们的`DependencyStub`看起来像这样：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Just like with an `@NgModule`, we are able to override the definition of our
    dependency with our own stub. Imagine our component looks like the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用`@NgModule`一样，我们能够用我们自己的存根覆盖我们的依赖的定义。想象一下我们的组件看起来像下面这样：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here we pass an instance of the dependency in the constructor. With our testing
    module correctly set up, with our stub, we can now write a test that looks like
    this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中传递依赖的一个实例。通过正确设置我们的测试模块，使用我们的存根，我们现在可以编写一个像这样的测试：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The test looks normal, but at the point when the dependency would be called
    in the component code, our stub takes its place and responds instead. Our dependency
    should be overridden, and as you can see, the `expect(app.title).toEqual('stub')`assumes
    the stub will answer, which it does.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 测试看起来正常，但在组件代码中调用依赖项时，我们的存根会代替它并做出响应。我们的依赖应该被覆盖，正如你所看到的，`expect(app.title).toEqual('stub')`假设存根会回答，而它确实会回答。
- en: Spying on the dependency method
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对依赖方法进行间谍监视
- en: 'The previously-mentioned approach, using a stub, is not the only way to isolate
    ourselves in a unit test. We don''t have to replace the entire dependency, only
    the parts that our component is using. Replacing certain parts means that we point
    out specific methods on the dependency and assign a spy to them. A spy is an interesting
    construct; it has the ability to answer what you want it to answer, but you can
    also see how many times it is being called and with what argument/s, so a spy
    gives you a lot more information about what is going on. Let''s have a look at
    how we would set a spy up:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的使用存根的方法并不是在单元测试中隔离自己的唯一方法。我们不必替换整个依赖项，只需替换组件正在使用的部分。替换某些部分意味着我们指出依赖项上的特定方法，并对其进行间谍监视。间谍是一个有趣的构造；它有能力回答你想要的问题，但你也可以看到它被调用了多少次以及使用了什么参数，因此间谍可以为你提供更多关于发生了什么的信息。让我们看看我们如何设置一个间谍：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now as you can see, the actual dependency is injected into the component. After
    that, we grab a reference to the component, our fixture variable. This is followed
    by us using the `TestBed.get('Dependency')`to get hold of the dependency inside
    of the component. At this point, we attach a spy to its `getData()` method through
    the `spyOn( dependency,'getData')` call.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到，实际的依赖项被注入到了组件中。之后，我们获取了组件的引用，即我们的fixture变量。然后，我们使用`TestBed.get('Dependency')`来获取组件内的依赖项。在这一点上，我们通过`spyOn(
    dependency,'getData')`来对其`getData()`方法进行间谍监视。
- en: 'This is not enough, however; we have yet to instruct the spy what to respond
    with when being called. Let us do just that:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这还不够；我们还需要指示间谍在被调用时如何回应。让我们来做到这一点：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can now write our test as usual:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像往常一样编写我们的测试：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This works as expected, and our spy responds as it should. Remember how we
    said that spies were capable of more than just responding with a value, that you
    could also check whether they were invoked and with what? To showcase this, we
    need to improve our tests a little bit and check for this extended functionality,
    like so:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这符合预期，我们的间谍回应得当。还记得我们说过间谍不仅能够回应一个值，还能够检查它们是否被调用以及使用了什么吗？为了展示这一点，我们需要稍微改进我们的测试，并检查这个扩展功能，就像这样：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can also check for the number of times it was called, with `spy.callCount`,
    or whether it was called with some specific arguments: `spy.mostRecentCalls.args` or `spy.toHaveBeenCalledWith('arg1',
    'arg2')`. Remember if you use a spy, make sure it pays for itself by you needing
    to do checks like these; otherwise, you might as well use a stub.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以检查它被调用的次数，使用`spy.callCount`，或者它是否被调用以及具体的参数：`spy.mostRecentCalls.args`或`spy.toHaveBeenCalledWith('arg1',
    'arg2')`。请记住，如果您使用间谍，请确保它通过您需要进行这些检查来支付自己的代价；否则，您可能还不如使用存根。
- en: Spies are a feature of the Jasmine framework, not Angular. The interested reader
    is urged to research this topic further at [http://tobyho.com/2011/12/15/jasmine-spy-cheatsheet/](http://tobyho.com/2011/12/15/jasmine-spy-cheatsheet/).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍是Jasmine框架的一个特性，而不是Angular。建议感兴趣的读者在[http://tobyho.com/2011/12/15/jasmine-spy-cheatsheet/](http://tobyho.com/2011/12/15/jasmine-spy-cheatsheet/)上进一步研究这个主题。
- en: Async services
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步服务
- en: Very few services are nice and well-behaved, in the sense that they are synchronous.
    A lot of the time, your service will be asynchronous and the return from it is
    most likely an observable or a promise. If you are using RxJS with the `Http`service
    or `HttpClient`, it will be an observable, but if using the `fetch`API, it will
    be a promise. These are two good options for dealing with HTTP, but the Angular
    team added the RxJS library to Angular to make your life as a developer easier.
    Ultimately it's up to you, but we recommend going with RxJS.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有服务是良好且行为端正的，就是它们是同步的意义上。大部分时间，您的服务将是异步的，而从中返回的最可能是一个observable或一个promise。如果您正在使用RxJS与`Http`服务或`HttpClient`，它将是一个observable，但如果使用`fetch`API，它将是一个promise。这两种处理HTTP的方法都很好，但Angular团队将RxJS库添加到Angular中，以使开发人员的生活更轻松。最终由您决定，但我们建议使用RxJS。
- en: 'Angular has two constructs ready to tackle the asynchronous scenario when testing:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Angular已经准备好了两种构造来处理测试时的异步场景。
- en: '`async()` and `whenStable()`: This code ensures that any promises are immediately
    resolved; it can look more synchronous though'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async()`和`whenStable()`：这段代码确保任何承诺都会立即解决；尽管看起来更同步'
- en: '`fakeAsync()` and `tick()`: This code does what the async does but it looks
    more synchronous when used'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fakeAsync()`和`tick()`：这段代码做了async的事情，但在使用时看起来更同步'
- en: 'Let''s describe the `async()` and `whenStable()`approaches. Our service has
    now grown up and is doing something asynchronous when we call it like a timeout
    or a HTTP call. Regardless of which, the answer doesn''t reach us straightaway.
    By using `async()` in combination with `whenStable()`, we can, however, ensure
    that any promises are immediately resolved. Imagine our service now looks like
    this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下`async()`和`whenStable()`的方法。当我们调用服务时，我们的服务现在已经成熟并且正在执行一些异步操作，比如超时或HTTP调用。无论如何，答案不会立即传达给我们。然而，通过结合使用`async()`和`whenStable()`，我们可以确保任何承诺都会立即解决。想象一下我们的服务现在是这样的：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We need to change our spy setup to return a promise instead of returning a
    static string, like so:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改我们的spy设置，以返回一个promise而不是返回一个静态字符串，就像这样：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We do need to change inside of our component, like so:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实需要在我们的组件内部进行更改，就像这样：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'At this point, it''s time to update our tests. We need to do two more things.
    We need to tell our test method to use the `async()` function, like so:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，是时候更新我们的测试了。我们需要做两件事。我们需要告诉我们的测试方法使用`async()`函数，就像这样：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We also need to call `fixture.whenStable()` to make sure that the promise will
    have had ample time to resolve, like so:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要调用`fixture.whenStable()`，以确保promise有足够的时间来解决，就像这样：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This version of doing it works as it should, but feels a bit clunky. There
    is another approach using `fakeAsync()` and `tick()`. Essentially, `fakeAsync()` replaces
    the `async()` call and we get rid of `whenStable()`. The big benefit, however,
    is that we no longer need to place our assertion statements inside of the promise''s `then()`callback.
    This gives us synchronous-looking code. Back to `fakeAsync()`, we need to make
    a call to `tick()`, which can only be called within a `fakeAsync()` call , like
    so:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法可以正常工作，但感觉有点笨拙。还有另一种方法，使用`fakeAsync()`和`tick()`。基本上，`fakeAsync()`替换了`async()`调用，我们摆脱了`whenStable()`。然而，最大的好处是我们不再需要将断言语句放在promise的`then()`回调中。这给我们提供了看起来是同步的代码。回到`fakeAsync()`，我们需要调用`tick()`，它只能在`fakeAsync()`调用内部调用，就像这样：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, this looks a lot cleaner; which version you want to use for
    async testing is up to you.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这看起来更清晰；您想要使用哪个版本进行异步测试取决于您。
- en: Testing pipes
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试管道
- en: 'A pipe is basically a class that implements the `PipeTransform` interface,
    thus exposing a `transform()` method that is usually synchronous. Pipes are therefore
    very easy to test. We will begin by testing a simple pipe, creating, as we mentioned,
    a test spec right next to its code unit file. The code is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 管道基本上是实现`PipeTransform`接口的类，因此公开了通常是同步的`transform()`方法。因此，管道非常容易测试。我们将从测试一个简单的管道开始，创建一个测试规范，就像我们提到的，紧挨着它的代码单元文件。代码如下：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our code is very simple; we take a value and add `banana` to it. Writing a
    test for it is equally simple. The only thing we need to do is to import the pipe
    and verify two things:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码非常简单；我们取一个值并添加`banana`。为它编写一个测试同样简单。我们需要做的唯一一件事就是导入管道并验证两件事：
- en: That it has a transform method
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否有一个transform方法
- en: That it produces the expected results
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它产生了预期的结果
- en: 'The following code writes a test for each of the bullet points listed earlier:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码为前面列出的每个要点编写了一个测试：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In our `beforeEach()`method, we set up the fixture by instantiating the pipe
    class. In the first test, we ensure that the `transform()`method exists. This
    is followed by our second test that asserts that the `transform()` method produces
    the expected result.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`beforeEach()`方法中，我们通过实例化管道类来设置fixture。在第一个测试中，我们确保`transform()`方法存在。接着是我们的第二个测试，断言`transform()`方法产生了预期的结果。
- en: Mocking HTTP responses with HttpClientTestingController
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HttpClientTestingController模拟HTTP响应
- en: 'It is super simple to get started with mocking HTTP, once you understand how
    to. Let''s first have a look at the service we mean to test:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了如何开始模拟HTTP，就会变得非常简单。让我们首先看一下我们打算测试的服务：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There are two important players when it comes to testing our service:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试我们的服务时，有两个重要的参与者：
- en: '`HttpTestingController`, we can instruct this class to listen for specific
    URLs and how to respond when it is being called'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpTestingController`，我们可以指示这个类监听特定的URL以及在被调用时如何做出响应'
- en: Our service, this is the service we want to test; the only thing we really want
    to do with it is to invoke it
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们要测试的是我们的服务；我们真正想要做的唯一一件事就是调用它
- en: 'As with all tests, we have a setup phase. Here we need to import the module, `HttpClientTestingModule`,
    that contains our `HttpTestingController`. We also need to tell it to provide
    us with our service, like so:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有测试一样，我们有一个设置阶段。在这里，我们需要导入包含我们的`HttpTestingController`的模块`HttpClientTestingModule`。我们还需要告诉它为我们提供服务，就像这样：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The next step is to set up the test, and by set up we mean that we need to
    get an instance of our service as well as `HttpTestingController`. We also need
    to instruct the latter what type of API calls to expect and give it suitable mock
    data to respond with:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置测试，通过设置我们需要获取我们的服务的实例以及`HttpTestingController`来设置。我们还需要指示后者期望的API调用类型，并提供适当的模拟数据以做出响应：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have provided inline comments for the preceding code snippet, but just to
    describe what happens one more time ,we have three phases to our test:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为前面的代码片段提供了内联注释，但只是为了再次描述发生了什么，我们的测试有三个阶段：
- en: '**Arrange**: This is where we grab an instance of the `JediService`as well
    as an instance of the `HttpTestingController`. We also define our mock data by
    setting the `expected ` variable.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安排**：这是我们获取`JediService`实例以及`HttpTestingController`实例的地方。我们还通过设置`expected`变量来定义我们的模拟数据。'
- en: '**Act**: We carry out the test by calling `jediService.getJedis()`. This is
    an observable so we need to subscribe to its content.'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**行动**：我们通过调用`jediService.getJedis()`来执行测试。这是一个observable，所以我们需要订阅它的内容。'
- en: '**Assert**: We resolve the asynchronous code by calling `flush(expected)` and
    we assert that we get the right data back by carrying out our assertion `expect(actual).toEqual(expected)`.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**断言**：我们通过调用`flush(expected)`来解析异步代码，并断言我们通过进行断言`expect(actual).toEqual(expected)`得到了正确的数据。'
- en: 'As you can see, faking calls to the HTTP is quite easy. Let''s show the entire
    unit test code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，伪造对HTTP的调用非常容易。让我们展示整个单元测试代码：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Input and outputs
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和输出
- en: So far, we have tested components in the sense that we have tested simple properties
    on the component and also how to tackle dependencies, synchronous as well as asynchronous,
    but there is more to a component than that. A component can also have input and
    outputs that should be tested as well. Because our context is Jedis, we know Jedis
    normally have ways to either the light side or the dark side. Imagine that our
    component is used within the context of a Jedi management system; we want to have
    the ability to turn a Jedi dark as well as bring it back to the light side again.
    What we are talking about is, of course, a toggle functionality.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经测试了组件，即我们已经测试了组件上的简单属性以及如何处理依赖项，同步和异步，但组件还有更多内容。组件还可以具有应该进行测试的输入和输出。因为我们的上下文是绝地武士，我们知道绝地武士通常有方法可以转向光明面或黑暗面。想象一下我们的组件在绝地管理系统的上下文中使用；我们希望能够将绝地武士转向黑暗面，也能够将其带回光明面。我们讨论的当然是切换功能。
- en: 'Imagine, therefore, that we have a component that looks like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，想象一下我们有一个看起来像这样的组件：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Testing such a component should be done in two ways:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这样一个组件应该以两种方式进行：
- en: We should verify that our input binding gets correctly set
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该验证我们的输入绑定是否正确设置
- en: We should verify that our output binding triggers properly and that what it
    emits is received
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该验证我们的输出绑定是否正确触发，以及接收到的内容
- en: 'Starting with the `@Input`, a test for it would look like the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从`@Input`开始，对其进行测试如下：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Worth noting here is our call to `fixture.detectChanges()`, this ensures that
    the binding happens in the component.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的是我们对`fixture.detectChanges()`的调用，这确保了绑定发生在组件中。
- en: 'Let''s now have a look at how to test `@Output`. What we need to do is to trigger
    it somehow. We need to click the div defined in our template. To receive the value
    the `switchSide` property emits, we need to subscribe to it, so we need to do
    two things:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来看看如何测试`@Output`。我们需要做的是以某种方式触发它。我们需要点击模板中定义的div。为了接收`switchSide`属性发出的值，我们需要订阅它，所以我们需要做两件事：
- en: Find the `div` element and trigger a click on it
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到`div`元素并触发点击
- en: Subscribe to the emission of the dataand verify that we receive our `jedi` object
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅数据的发射并验证我们是否收到了`jedi`对象
- en: 'As for getting a reference to the div, it is quite easily done, like so:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 至于获取div的引用，可以很容易地完成，如下所示：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For the second part, we need to subscribe to the `switchSide` Observable and
    capture the data, like so:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二部分，我们需要订阅`switchSide` Observable并捕获数据，如下所示：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With this code, we are able to trigger an outputs emit indirectly, through the
    click event and listen to the output, through a subscribe.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段代码，我们能够间接触发输出的发射，通过点击事件监听输出，通过订阅。
- en: Testing routing
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试路由
- en: 'Just like components, routes play an important role in the way our applications
    deliver an efficient user experience. As such, testing routes becomes paramount
    to ensuring a flawless performance. There are different things we can do with
    routing and we need to test for the different scenarios. These scenarios are:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 就像组件一样，路由在我们的应用程序提供高效用户体验方面发挥着重要作用。因此，测试路由变得至关重要，以确保无缝的性能。我们可以对路由进行不同的测试，并且需要针对不同的场景进行测试。这些场景包括：
- en: Ensuring that the navigation targets the right route address
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保导航指向正确的路由地址
- en: Ensuring that the correct parameters are made available so you can fetch the
    correct data for the component, or filter the dataset the component needs
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保正确的参数可用，以便您可以为组件获取正确的数据，或者过滤组件需要的数据集
- en: Ensuring that a certain route ends up loading the intended component
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保某个路由最终加载预期的组件
- en: Testing navigation
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试导航
- en: 'Let''s have a look at the first bullet point. To load a specific route, we
    can call a `navigateToUrl(url)` method on the `Router`class. A good test is to
    ensure that such a method is being called when a certain state happens in a component.
    There could, for example, be a create component page, that after saving should
    navigate back to a list page, or a missing route parameter should lead to us back
    to a home page. There is more than one good reason for programatically navigating
    inside of a component. Let''s look at some code in a component, where such a navigation
    takes place:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一个要点。要加载特定路由，我们可以在`Router`类上调用`navigateToUrl(url)`方法。一个很好的测试是确保当组件中发生某种状态时，会调用这样的方法。例如，可能会有一个创建组件页面，在保存后应该导航回到列表页面，或者缺少路由参数应该导航回到主页。在组件内部进行程序化导航有多个很好的理由。让我们看一些组件中的代码，其中进行这样的导航：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here we can see that invoking the `back()`method will perform a navigation.
    Writing a test for this is quite simple. The test should test whether the `navigateToUrl()`method
    is being called. Our approach will consist of stubbing the router service in combination
    with adding a spy to the `navigateToUrl()`method itself. First off, we define
    a stub and then we instruct our testing module to use the said stub. We also ensure
    that we create an instance of the component so that we may later invoke the `back()` method
    on it,  like so:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到调用`back()`方法将执行导航。为此编写测试非常简单。测试应该测试`navigateToUrl()`方法是否被调用。我们的方法将包括在路由服务中存根化以及在`navigateToUrl()`方法本身上添加一个间谍。首先，我们定义一个存根，然后指示我们的测试模块使用该存根。我们还确保我们创建了组件的一个实例，以便稍后在其上调用`back()`方法，就像这样：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The next thing we need to do is to define our test and inject the router instance.
    Once we have done so, we can set a spy on the `navigateToUrl()` method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是定义我们的测试并注入路由实例。一旦我们这样做了，我们就可以在`navigateToUrl()`方法上设置一个间谍：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now at this point, what we want the test to test for is whether the method
    is called at all. Writing such a test can be seen as defensive. As important as
    it is to test for correctness, it is also important to write tests to make sure
    that another developer, or yourself, doesn''t remove a behavior that should work.
    So let''s add some verification logic that ensures that our spy is being called:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在这一点上，我们希望测试测试的是方法是否被调用。编写这样的测试可以被视为防御性的。和测试正确性一样重要的是，编写测试以确保另一个开发人员，或者你自己，不会删除应该工作的行为。因此，让我们添加一些验证逻辑，以确保我们的间谍被调用：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The entire test is now replacing the original router service for a stub. We
    are attaching a spy to the `navigateByUrl()` method on the stub and we are lastly
    asserting that spy is called as intended, when we invoke the `back()` method on
    the component:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 整个测试现在是用存根替换原始的路由服务。我们在存根上的`navigateByUrl()`方法上附加了一个间谍，最后我们断言该间谍在调用`back()`方法时被调用如预期：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Testing routes by URL
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过URL测试路由
- en: 'So far, we have tested routing by placing a spy on the navigation method and
    in the case with routing parameters, we had to build a mock for an Observable.
    There is another approach, though, and that is to let the routing happen and afterwards
    investigate where we ended up. Let''s say we have the following scenario: we are
    at a list component and want to navigate to a detail component. After navigation
    has taken place, we want to investigate what state we are in. Let us first define
    our list component:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过在导航方法上放置间谍来测试路由，并且在具有路由参数的情况下，我们必须为Observable构建一个模拟。不过，还有另一种方法，那就是让路由发生，然后调查我们最终停留在哪里。假设我们有以下情景：我们在列表组件上，想要导航到详细组件。导航发生后，我们想要调查我们所处的状态。让我们首先定义我们的列表组件：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see, we have a `goToDetail()`method that, if invoked, will navigate
    you to a new route. For this to work, however, we need to have had routing set
    up properly in the module file, like so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个`goToDetail()`方法，如果调用，将会将您导航到一个新的路由。但是，为了使其工作，我们需要在模块文件中正确设置路由，如下所示：
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The important part here is the definition of `appRoutes` and calling`RouterModule.forRoot()` in
    the imports array.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的部分在于`appRoutes`的定义和在导入数组中调用`RouterModule.forRoot()`。
- en: The time has come to define the test for this. We need to interact with a module
    called `RouterTestingModule` and we need to provide that module with the routes
    it should contain. `RouterTestingModule`is a very qualified stub version of the
    routing, so in that sense, there isn't much difference in principle from creating
    your own stub. Look at it this way though, you can create your own stub, but as
    you use more and more advanced functionality, using an advanced stub quickly pays
    off.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是定义此测试的时候了。我们需要与一个名为`RouterTestingModule`的模块进行交互，并且我们需要为该模块提供应该包含的路由。`RouterTestingModule`是一个非常合格的路由存根版本，因此从原则上讲，与创建自己的存根没有太大区别。不过，可以这样看待，您可以创建自己的存根，但随着您使用越来越多的高级功能，使用高级存根很快就会得到回报。
- en: 'We will start off by instructing our `RouterTestingModule` that it should load
    the `DetailComponent` when the `detail/:id`route is being hit. This doesn''t really
    differ from how we would set up the routing from our `root` module. The benefit
    is that we only need to set up the routes we need for our test, rather than every
    single route in the app:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先指示我们的`RouterTestingModule`，当命中`detail/:id`路由时，它应该加载`DetailComponent`。这与我们如何从我们的`root`模块设置路由没有太大区别。好处在于，我们只需要为我们的测试设置我们需要的路由，而不是应用中的每一个路由都需要设置：
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After we have done the setup, we need to grab a copy of the component in our
    test so that we can invoke the method that navigates us away from the list component.
    Your test should look like the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 完成设置后，我们需要在测试中获取组件的副本，以便调用将我们从列表组件导航出去的方法。您的测试应该如下所示：
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The important part here is the invocation of the method that makes us navigate:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的部分是调用使我们导航的方法：
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And the assertion where we verify that our router has indeed changed state:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以及我们验证我们的路由器确实已经改变状态的断言：
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Testing route parameters
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试路由参数
- en: 'You will have some component that does routing and some components that are
    being routed to. Sometimes components that are being routed to have a parameter,
    and typically their route looks something like this: `/jedis/:id`. The component
    then has the mission of digging out the ID parameter and doing a lookup on the
    specific Jedi that matches this ID. So, a call to a service will be made and the
    response should populate  a suitable parameter in our component that we then can
    show in the template. Such a component will typically look like this, in its entirety:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您将拥有一些执行路由的组件和一些被路由到的组件。有时，被路由到的组件会有一个参数，通常它们的路由看起来像这样：`/jedis/:id`。然后，组件的任务是挖出ID参数，并在匹配此ID的具体绝地武士上进行查找。因此，将调用一个服务，并且响应应该填充我们组件中的适当参数，然后我们可以在模板中显示。这样的组件通常看起来像这样：
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Worth highlighting is how we get hold of the parameter in the router. We interact
    with the `ActivatedRouter`instance, that we named as `route` and its`paramMap` property,
    which is an observable, like so:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是我们如何获取路由中的参数。我们与`ActivatedRouter`实例交互，我们将其命名为`route`，以及它的`paramMap`属性，这是一个可观察对象，如下所示：
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: So what do we want to test for? We would like to know that if a certain route
    contains an ID parameter, then our `jedi`property should be properly populated,
    through our service. We don't want to do an actual HTTP call, so our `JediService`will
    need to be mocked somehow and there is another thing complicating it, namely that
    `route.paramMap` will need to be mocked as well and that thing is an observable.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们想要测试什么呢？我们想知道，如果某个路由包含一个ID参数，那么我们的`jedi`属性应该通过我们的服务正确填充。我们不想进行实际的HTTP调用，因此我们的`JediService`需要以某种方式进行模拟，并且还有另一件使事情复杂化的事情，即`route.paramMap`也需要被模拟，而那个东西是一个可观察对象。
- en: 'This means we need a way to create a stub of an observable. This might sound
    a bit daunting but it really isn''t; thanks to a `Subject`, we can make this quite
    easy for ourselves. A `subject` has the nice ability of being something we can
    subscribe to, but we can also pass it values. With that knowledge, let''s start
    to create our `ActivatedRouteStub`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要一种创建可观察对象存根的方法。这可能听起来有点令人生畏，但实际上并不是；多亏了`Subject`，我们可以很容易地做到这一点。`Subject`具有一个很好的能力，即我们可以订阅它，但我们也可以向它传递值。有了这个知识，让我们开始创建我们的`ActivatedRouteStub`：
- en: '[PRE55]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, let''s explain this code, we add the `sendValue()`method so it can pass
    the value we give it to the subject. We expose the `paramMap` property, as an
    observable, so we can listen to the subject when it emits any values. How does
    this correlate to our test though? Well, calling `sendValue` on the stub is something
    we want to do in the setup phase, that is inside of a`beforeEach()`. This is a
    way for us to simulate reaching our component through routing while passing a
    parameter. In the test itself, we want to listen for when a router parameter is
    being sent to us so we can pass it on to our `jediService`. So, let''s start sketching
    on the test. We will build the test in two steps:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们解释一下这段代码，我们添加了`sendValue()`方法，以便它可以将我们给它的值传递给主题。我们公开了`paramMap`属性，作为一个可观察对象，这样我们就可以在主题发出任何值时监听它。但这如何与我们的测试相关呢？嗯，在存储阶段，我们希望在`beforeEach()`内调用存根的`sendValue`。这是我们模拟通过路由到达我们的组件并传递参数的一种方式。在测试本身中，我们希望监听路由参数何时被发送给我们，以便我们可以将其传递给我们的`jediService`。因此，让我们开始勾勒测试。我们将分两步构建测试：
- en: The first step is to support the mocking of the `ActivatedRoute`by passing the
    `ActivatedRouteStub`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是通过传递`ActivatedRouteStub`来支持对`ActivatedRoute`的模拟。
- en: The second step is to set up the mocking of the `jediService`, ensuring that
    all HTTP calls are intercepted, and that we are able to respond with mock data
    when an HTTP call occurs.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是设置`jediService`的模拟，确保拦截所有HTTP调用，并且当发生HTTP调用时我们能够用模拟数据做出响应。
- en: 'For the first step, we set up the test as we have done so far by calling `TestBed.configureTestingModule()`
    and passing it an object. We mentioned that we built a stub for an activated route
    already and we need to make sure that we provide this instead of the real `ActivatedRoute`.
    This looks like the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置测试，就像我们迄今为止所做的那样，调用`TestBed.configureTestingModule()`并传递一个对象。我们提到我们已经为激活的路由构建了一个存根，并且我们需要确保提供这个存根而不是真正的`ActivatedRoute`。代码如下所示：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This means that when our component gets the `ActivatedRoute` dependency injected
    in its constructor, it will instead inject `ActivatedRouteStub`, like so:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们的组件在构造函数中获取`ActivatedRoute`依赖注入时，它将注入`ActivatedRouteStub`，就像这样：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Moving on with our test, we need to do three things:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的测试，我们需要做三件事：
- en: Instantiate the component
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化组件
- en: Feed a route parameter to our `ActivatedRouteStub` so that a routing parameter
    is emitted
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将路由参数传递给我们的`ActivatedRouteStub`，以便发出路由参数
- en: Subscribe to the `ActivatedRouteStub` so we can assert that a parameter is indeed
    emitted
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅`ActivatedRouteStub`，以便我们可以断言参数确实被发出
- en: 'Let''s add these to our test code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些添加到我们的测试代码中：
- en: '[PRE58]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now we have set up the fixture, the component, and our `activatedRouteStub`.
    The next step is to feed the `activatedRouteStub`the actual routing parameter,
    and to set up a `subscribe` of the`activatedRouteStub`so we know when we receive
    a new routing parameter. We do this inside the test itself, instead of the `beforeEach()` method,
    like so:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了fixture、组件和我们的`activatedRouteStub`。下一步是将实际的路由参数传递给`activatedRouteStub`，并设置一个`subscribe`来知道何时接收到新的路由参数。我们在测试本身中执行这个操作，而不是在`beforeEach()`方法中，就像这样：
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'So what does this mean for our component? How much of our component have we
    tested at this stage? Let''s have a look at our `DetailComponent` and highlight
    the code covered by our test so far:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这对我们的组件意味着什么？在这个阶段我们测试了多少我们的组件？让我们看看我们的`DetailComponent`，并突出显示到目前为止我们测试覆盖的代码：
- en: '[PRE60]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As you can see, we have, in the test, covered the mocking of the `activatedRoute`and
    managed to subscribe to it. What is missing on both the component and test is
    to account for there being a call to a service that in turn calls HTTP. Let''s
    start with adding that code to the component, like so:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在测试中，我们已经覆盖了`activatedRoute`的模拟，并成功订阅了它。在组件和测试中都缺少的是要考虑到调用一个调用HTTP的服务。让我们首先将该代码添加到组件中，就像这样：
- en: '[PRE61]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the code, we added the `Jedi` field as well as a call to`this.jediService.getJedi()`.
    We subscribed to the result and assigned the result of the operation to the `Jedi`
    field. Adding testing support for this part is something we have already covered
    in the previous section on mocking the HTTP. It''s good to repeat this, so let''s
    add the necessary code to the unit test, like so:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们添加了`Jedi`字段以及对`this.jediService.getJedi()`的调用。我们订阅了结果，并将操作的结果分配给了`Jedi`字段。为这部分添加测试支持是我们在前面关于模拟HTTP的部分已经涵盖过的。重复这一点是很好的，所以让我们添加必要的代码到单元测试中，就像这样：
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'What we did here is to get a copy of our `JediService` by asking for it from
    the`TestBed.get()`method. Furthermore, we asked for an instance of the   `HttpTestingController`.
    We move on by defining the expected data that we want to respond with, and we
    instruct the instance of the `HttpTestingController` that it should expect a call
    to `/api/jedis/1`, and when that happens then the expected data should be returned.
    So now we have a test that covers both the scenario of testing for the `ActivatedRoute`
    parameters, as well as the HTTP call. The full code of the test looks like the
    following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是通过从`TestBed.get()`方法请求`JediService`的副本。此外，我们要求一个`HttpTestingController`的实例。我们继续定义我们想要响应的预期数据，并指示`HttpTestingController`的实例应该期望调用`/api/jedis/1`，当发生这种情况时，预期的数据应该被返回。所以现在我们有一个测试，涵盖了测试`ActivatedRoute`参数的场景，以及HTTP调用。测试的完整代码如下：
- en: '[PRE63]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: So what have we learned from testing route parameters? It is a bit more cumbersome
    as we need to create our `ActivatedRouteStub`, but all in all, it is quite straightforward.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们从测试路由参数中学到了什么？由于我们需要创建我们的`ActivatedRouteStub`，所以有点麻烦，但总的来说，还是相当简单的。
- en: Testing directives
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试指令
- en: The last leg of our journey into the world of unit testing Angular elements
    will cover directives. Directives will usually be quite straightforward in their
    overall shape, being pretty much components with no view attached. The fact that
    directives usually work with components gives us a very good idea of how to proceed
    when testing them.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试Angular元素之旅的最后一站将涵盖指令。指令通常在整体形状上会相当简单，基本上就是没有附加视图的组件。指令通常与组件一起工作的事实给了我们一个很好的想法，该如何进行测试。
- en: 'A directive can be simple in the sense that it has no external dependencies.
    It looks something like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 指令可以简单地表示为没有外部依赖项。它看起来像这样：
- en: '[PRE64]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Testing is easy, you just need to instantiate an object from the `SomeDirective`class.
    However, it is likely that your directive will have dependencies and in those
    cases, we need to test the directive implicitly through it being attached to the
    component. Let''s have a look at such an example. Let''s first define the directive,
    like so:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 测试很容易，你只需要从`SomeDirective`类中实例化一个对象。然而，你的指令可能会有依赖项，在这种情况下，我们需要通过将其附加到组件来隐式测试指令。让我们看一个例子。让我们首先定义指令，就像这样：
- en: '[PRE65]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'What you see here is a simple directive that shifts the font color to yellow
    if we hover over it. We need to attach it to a component. Let us define an element
    next, like so:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你看到的是一个简单的指令，如果我们悬停在上面，它会将字体颜色变成黄色。我们需要将它附加到一个组件上。让我们接下来定义一个元素，就像这样：
- en: '[PRE66]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here we can see that we added the element as an attribute to the `p`-tag that
    we defined in the components template.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们将元素作为属性添加到组件模板中定义的`p`标签中。
- en: 'Next, let''s go over to our test. We now know how to write tests, and especially
    how to test elements, so the following test code should come as no surprise:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看看我们的测试。我们现在知道如何编写测试，特别是如何测试元素，所以下面的测试代码应该不会让你感到意外：
- en: '[PRE67]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the `beforeEach()`method, we talk to `TestBed` to configure our testing
    module and tell it about the`BananaDirective` as well as the`BananaComponent`,
    with this code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在`beforeEach()`方法中，我们与`TestBed`交谈，配置我们的测试模块，并告诉它关于`BananaDirective`和`BananaComponent`的信息，代码如下：
- en: '[PRE68]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the test itself, we use `TestBed`yet again to create a component. Thereafter,
    we find our element by its CSS class. We find the element so that we are able
    to trigger an event, a `mouseover`. Triggering a `mouseover`event will trigger
    code in the directive that will make the font color yellow. With the event triggered,
    then we are able to assert the element''s font color with this line:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试本身中，我们再次使用`TestBed`来创建一个组件。然后，我们通过CSS类找到我们的元素。我们找到元素以便触发一个事件，即`mouseover`。触发`mouseover`事件将触发指令中的代码，使字体颜色变为黄色。触发事件后，我们可以使用这行代码来断言元素的字体颜色：
- en: '[PRE69]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, this is how simple it can be to test a directive, even if it has dependencies.
    The key takeaway is that if that is the case, you need an element to place the
    directive on, and that you implicitly test the directive through the element.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这就是测试指令的简单方法，即使它有依赖关系。关键是，如果是这种情况，您需要一个元素来放置指令，并且您通过元素隐式测试指令。
- en: The road ahead
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前方的道路
- en: This last test example wraps up our journey into unit testing with Angular,
    but keep in mind that we have barely scratched the surface. Testing web applications
    in general, and Angular applications in particular, poses a myriad of scenarios
    that usually need a specific approach. Remember that if a specific test requires
    a cumbersome and convoluted solution, we are probably facing a good case for a
    module redesign instead.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的测试示例总结了我们对Angular单元测试的探索，但请记住，我们只是触及了皮毛。一般来说，测试Web应用程序，特别是Angular应用程序，会出现许多通常需要特定方法的情况。请记住，如果一个特定的测试需要繁琐和复杂的解决方案，那么我们可能面临着模块重新设计的一个好案例。
- en: Where should we go from here? There are several paths to compound our knowledge
    of web application testing in Angular and enable us to become great testing ninjas.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该从这里走向何方？有几条路径可以增进我们对Angular中Web应用程序测试的知识，并使我们成为优秀的测试忍者。
- en: Introducing code coverage reports in your test stack
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在测试堆栈中引入代码覆盖率报告
- en: How can we know how far our tests go on testing the application? Are we sure
    we are not leaving any piece of code untested and if so, is it relevant? How can
    we detect the pieces of code that fall outside the scope of our current tests
    so we can better assess whether they are worth testing or not?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道我们的测试有多远地测试了应用程序？我们能确定我们没有留下任何未经测试的代码吗？如果有，它是否相关？我们如何检测超出当前测试范围的代码片段，以便更好地评估它们是否值得测试？
- en: These concerns can be easily addressed by introducing code coverage reporting
    in our application tests stack. A code coverage tool aims to track down the scope
    of our unit testing layer and produce an educated report informing you of the
    overall reach of your test specs and what pieces of code still remain uncovered.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可以通过在应用程序测试堆栈中引入代码覆盖率报告来轻松解决。代码覆盖工具旨在跟踪我们单元测试层的范围，并生成一个教育性报告，告诉您测试规范的整体覆盖范围以及仍未覆盖的代码片段。
- en: There are several tools for implementing code coverage analysis in our applications,
    the most popular ones at this time being Blanket ([http://blanketjs.org](http://blanketjs.org))
    and Istanbul ([https://gotwarlost.github.io/istanbul](https://gotwarlost.github.io/istanbul)).
    In both cases, the installation process is pretty quick and easy.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种工具可以在我们的应用程序中实施代码覆盖率分析，目前最流行的是Blanket（[http://blanketjs.org](http://blanketjs.org)）和Istanbul（[https://gotwarlost.github.io/istanbul](https://gotwarlost.github.io/istanbul)）。在这两种情况下，安装过程都非常快速和简单。
- en: Implementing E2E tests
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施端到端测试
- en: In this chapter, we saw how we could test certain parts of the UI by evaluating
    the state of the DOM. This gives us a good idea of how things would look from
    the end user's point of view, but ultimately this is just an educated guess.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何通过评估DOM的状态来测试UI的某些部分。这给了我们一个很好的想法，从最终用户的角度来看事物会是什么样子，但最终这只是一个经过推敲的猜测。
- en: End-to-end (E2E) testing is a methodology for testing web applications using
    an automated agent that will programmatically follow the end user's flow from
    start to finish. Contrary to what unit testing poses, the nuances of the code
    implementation are not relevant here since E2E testing entails testing our application
    from start to finish from the user's endpoint. This approach allows us to test
    the application in an integrated way. While unit testing focuses on the reliability
    of each particular piece of the puzzle, E2E testing assesses the integrity of
    the puzzle as a whole, finding integration issues between components that are
    frequently overlooked by unit tests.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端（E2E）测试是一种测试Web应用程序的方法，使用自动化代理程序，可以按照用户的流程从开始到结束进行程序化测试。与单元测试的要求相反，这里并不关心代码实现的细微差别，因为E2E测试涉及从用户端点开始到结束测试我们的应用程序。这种方法允许我们以集成的方式测试应用程序。而单元测试侧重于每个部分的可靠性，E2E测试评估整体拼图的完整性，发现单元测试经常忽视的组件之间的集成问题。
- en: 'For the previous incarnation of the Angular framework, the Angular team built a
    powerful tool named Protractor ([http://www.protractortest.org/](http://www.protractortest.org/)),
    which is defined as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Angular框架的上一个版本，Angular团队构建了一个强大的工具，名为Protractor（[http://www.protractortest.org/](http://www.protractortest.org/)），其定义如下：
- en: '"An end to end test runner which simulates user interactions that will help
    you verify the health of your Angular application."'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: “端到端测试运行器，模拟用户交互，将帮助您验证Angular应用程序的健康状况。”
- en: The tests syntax will become pretty familiar since it also uses Jasmine for
    putting together test specs. Unfortunately, E2E sits outside the scope of this
    book, but there are several resources you can rely on to expand your knowledge
    on the subject. In that sense, we recommend the book *Angular Test-Driven Development*,
    *Packt Publishing*, which provides broad insights on the use of Protractor to
    create E2E test suites for our Angular applications.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的语法会变得非常熟悉，因为它也使用Jasmine来组织测试规范。不幸的是，E2E超出了本书的范围，但有几个资源可以帮助您扩展对这一主题的了解。在这方面，我们推荐书籍《Angular测试驱动开发》，*Packt
    Publishing*，它提供了关于使用Protractor为我们的Angular应用程序创建E2E测试套件的广泛见解。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We are at the end of our journey, and it's definitely been a long but exciting
    one. In this chapter, you saw the importance of introducing unit testing in our
    Angular applications, the basic shape of a unit test, and the process of setting
    up Jasmine for our tests. You also saw how to code powerful tests for our components,
    directives, pipes, routes, and services. We also discussed new challenges in your
    path for mastering Angular. It is fair to say that there is still a long road
    ahead, and it is definitely an exciting one.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走到了旅程的尽头，这绝对是一个漫长但令人兴奋的旅程。在本章中，您看到了在我们的Angular应用程序中引入单元测试的重要性，单元测试的基本形式，以及为我们的测试设置Jasmine的过程。您还看到了如何为我们的组件、指令、管道、路由和服务编写强大的测试。我们还讨论了在掌握Angular过程中的新挑战。可以说前方仍有很长的道路要走，而且绝对是一个令人兴奋的道路。
- en: The end of this chapter is also the end of this book, but the experience continues
    beyond its boundaries. Angular is still a pretty young framework, and as such,
    all the great things that it will bring to the community are yet to be created.
    Hopefully, you will be one of those creators. If so, please let the authors know.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的结束也意味着这本书的结束，但体验将超越其界限。Angular仍然是一个相当年轻的框架，因此，它将为社区带来的所有伟大事物尚未被创造出来。希望您能成为其中的创造者之一。如果是这样，请让作者知道。
- en: Thanks for taking the time to read this book.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您抽出时间阅读这本书。
