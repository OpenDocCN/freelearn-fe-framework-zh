- en: Chapter 2. Understanding React Native Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might not be familiar with how React for Web works, so we are going to cover
    the fundamentals in this chapter. We will also explain the core principles of
    how React for Web works under the hood. Once you have a solid understanding of
    the basics, we will dive into how React for Web works and the subtle differences
    between mobile and web. By the end of this chapter, you will have the necessary
    skills to start building the example application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Virtual DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing components and JSX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing our first component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Props and state of components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Virtual DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you know how to write a JavaScript function? If you do, that''s great! You''re
    well on your way to understand how React and React Native work under the hood.
    What do we mean exactly? Well, when you research how React works, you''ll eventually
    encounter someone explaining it in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You may say, *Nerd alert! How is this helpful?* Well, it''s saying that your
    UI is a function of your data. To put it in more familiar terms, let''s say that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call the `function` with an array of data, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is not a particularly earth-shattering code; however, you're now rendering
    some content, in this case to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if, all your UI rendering code could be this predictable? It can be! Let''s
    start getting a little more advanced. What if, in addition to our `todos()` function,
    we had a function called `todoItem()`, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'That looks a lot like our original `UI` function, doesn''t it?:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we start composing our `todos()` and `todoItems()`, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can start to get the picture that we can start to render more and more complex
    outputs by composing simple functions.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to start rendering our content to the browser? I'm sure you
    can imagine changing our `todoItem()` to add elements to the DOM using jQuery;
    however, in this case we will start repeating ourselves a lot with many instances
    of `appendChild()` calls and jQuery selectors. If we are really smart, we might
    write a framework to abstract away the DOM manipulations so that we can write
    the code that matters to our application, not just the code that matters to the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: OK, so now let's say that we've magically got a framework that lets us represent
    our UI as a `data` function and we don't have to think about how our content will
    get rendered to the DOM. We can start changing our data over and over and watch
    the DOM update! That sounds great in theory, but when we have dozens of `div`
    elements in a deeply nested hierarchy, the underlying DOM manipulations become
    complex and inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: What if our magic framework had an intermediate representation of the DOM? Let's
    call it Virtual DOM and let's say that instead of making every little change to
    the DOM, we batch the changes together. We can even compare the before and after
    states of the Virtual DOM. Figure out the differences and reduce the number of
    real DOM manipulations that we need to perform. Now we're really on to something!
  prefs: []
  type: TYPE_NORMAL
- en: So we can now express our UI as a function of our data. We don't have to think
    about the underlying DOM manipulation code and our UI is nice and snappy because
    the underlying framework is really smart and reduces the number of DOM manipulations
    it needs to perform. It will be pretty great to have a framework that could do
    that for us, but you know what will be really cool? What if the DOM didn't have
    to be a browser DOM? What if that same abstraction that allows us to write the
    code that matters to our app could be used to, say, update native mobile components?
    Enter React Native.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now here is an interesting problem; we have come across this great framework
    for making fast differences between the Virtual DOM and its native components.
    How do we tell React Native what UI to represent or when to change it? A React
    Native component is a simple, reusable, function-like object that enables us to
    describe the native mobile components we want to render. They will always contain
    properties, state, and a render method. Let's start really simple by creating
    our own component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a new component in React Native will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to import the React Native module. Here, we are using the ES6 import
    statement; it is similar to how the node require module works.
  prefs: []
  type: TYPE_NORMAL
- en: '*Wait a second…* What are these weird XML elements doing in my JavaScript code?
    Facebook has created its own syntactic extension over JavaScript to describe React
    components. Here is the exact same code, but written in ordinary JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While it is possible to write React Native applications only in JavaScript,
    the previous syntax includes many added benefits for the developer.
  prefs: []
  type: TYPE_NORMAL
- en: JSX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JavaScript XML** (**JSX**) is an XML-like extension to the ECMAScript specification.
    It combines the component logic (JavaScript) and markup (DOM or Native UI) into
    a single file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A JSX Element will take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSX specification also defines the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The JSX Elements can be either self-opening `<JSXElement></JSXElement>` or self-closing
    `<JSXElement />`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept attributes as an expression `{}` or string `""` `<Component attr="attribute">`.
    Expressions are JavaScript snippets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The children elements can be text, expressions, or elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What if you have more than one component or a list of components?**'
  prefs: []
  type: TYPE_NORMAL
- en: There can only be a single root element; it means that if you have multiple
    components, you must wrap them in a parent component.
  prefs: []
  type: TYPE_NORMAL
- en: This is cool! We have gone from a deeply nested and imperative JavaScript code
    to a declarative format that describes the exact elements that we want to see
    in our components. There is no separation of concerns since our logic is coupled
    with our markup, making the components easier to debug and test. Since you can
    always include the same component in multiple other components, there is no need
    to duplicate the code anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Note that JSX is only meant to be used as a preprocessor and it is not recommended
    to transpile in your production build. More information on JSX can be found in
    the official React documentation [https://facebook.github.io/react/docs/jsx-in-depth.html](https://facebook.github.io/react/docs/jsx-in-depth.html)
    or in the official JSX Specification [https://facebook.github.io/jsx/](https://facebook.github.io/jsx/).
  prefs: []
  type: TYPE_NORMAL
- en: Back to our first component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few things that we have overlooked in our component. **View** and
    **Text** are two of the many components provided by React Native to build a UI.
    These are not regular components that render in the JavaScript layer, they can
    map directly to their native container parts! The View component maps to `UIView`
    in IOS and `android.view` in Android, while Text is the generic component to display
    text on each platform respectively. **View** and **Text** support various functions,
    such as layouts, styling, and touch handling.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the same static text over and over is not very exciting. Let's extend
    this simple component and add some more functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Props and states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you may be wondering how React Native deals with component manipulation
    and communication as the number of components grows into a component hierarchy.
    A component hierarchy, similar to a tree, starts with a root component and can
    contain many children. React Native provides two methods of data passing; one
    for data-flow down the component hierarchy and another for maintaining internal
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Props
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'How do the components in the same component hierarchy communicate with each
    other? Data is passed down through properties commonly known as **props**. Props
    are considered to be immutable by convention and should never be modified directly.
    To pass a prop into a component, just add a camel-cased attribute to the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Props can be accessed internally in the component through `this.props`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What if I want to pass down a lot of props?**'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to pass an array of props to a component using the ES7 spread
    operator `<HelloComponent {...props} />`.
  prefs: []
  type: TYPE_NORMAL
- en: It is not always necessary to include props with a component, but if you require
    a default value for your props, you can assign the `defaultProps` object to the
    component's class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Validating props
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you are planning to expose your component to the public, it makes sense
    to constrain the ways developers can use it. To enforce that your components are
    being used correctly, the **PropTypes** module can be used to validate any props
    passed in. In the event that a prop does not pass the `propType` validation, a
    warning is shown to the developer in the console. The `PropTypes` cover a wide
    range of JavaScript types and primitives, including nested objects. You can define
    `propTypes` on a component''s class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For more information on `propTypes`, visit the Prop Validation section of React
    Docs [https://facebook.github.io/react/docs/reusable-components.html](https://facebook.github.io/react/docs/reusable-components.html).
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now we can pass in the data, but what if the data changes, then how can
    we display these changes to the user? Components can optionally contain state,
    a mutable and private set of data. State is a great way to keep track of user
    input, asynchronous requests, and events. Let''s update our component with additional
    text when the user interacts with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Touching the `Text` component will trigger the function in its `onPress` prop.
    We are taking advantage of the ES6 arrow syntax to include our functionality in
    line with the text component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the ES6 arrow syntax will automatically bind this to a function. For any
    non-arrow function, if you need access to this then you need to bind the value
    to the function in the props expression `<Text onPress={this.myFunction.bind(this)}>`.
  prefs: []
  type: TYPE_NORMAL
- en: The `setState` function will merge the object you pass into the first argument
    with the current state of the component. Calling `setState` will trigger a new
    render where, instead of being empty, `this.state.appendText` will append **Native!**
    to the value of text, which we originally passed in from props. The final result
    is `"Hello React" + " Native!"` to produce `"Hello React Native!"`.
  prefs: []
  type: TYPE_NORMAL
- en: Never try and modify the value of this state on your own. Directly changing
    the state could result in data loss during the next `setState` call and it will
    not trigger another re-render.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now hopefully, you understand the radical new direction React has taken in achieving
    performance. The Virtual DOM handles all of the DOM manipulations for us behind
    the scenes. At the same time, it uses efficient diffing algorithms to minimize
    the number of calls to the DOM. We have also seen how JSX allows us to express
    our components declaratively and combine our application logic into a single file.
    By using props and state, we can pass the data through components and update them
    dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you can now take the information you learned in this chapter and convince
    your boss to start using React Native right away!
  prefs: []
  type: TYPE_NORMAL
