- en: Appendix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: 1\. Starting Your First Vue Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 开始你的第一个Vue项目
- en: 'Activity 1.01: Building a Dynamic Shopping List App Using Vue.js'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一.01：使用Vue.js构建动态购物清单应用
- en: '**Solution:**'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: To access the code files for this activity, refer to [https://packt.live/35Tkzau](https://packt.live/35Tkzau).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此活动的代码文件，请参阅[https://packt.live/35Tkzau](https://packt.live/35Tkzau)。
- en: Create a new Vue project using the Vue CLI by running the `vue create new-activity-app`
    command. Manually select the features via the command prompts for `dart-sass`,
    `babel`, and `eslint`.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`vue create new-activity-app`命令使用Vue CLI创建一个新的Vue项目。通过命令提示符手动选择`dart-sass`、`babel`和`eslint`功能。
- en: 'Scaffold an input field with a placeholder, `Press enter to add new item`,
    which has a `v-model` bound to a data object called input and a `ref` attribute
    with the value of the input. Bind the *Enter* key to the `addItem` method, which
    will be created in the next step, by using `@keyup.enter` and referencing the
    `addItem` method:'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用占位符“按Enter键添加新项目”创建一个输入字段，并将其`v-model`绑定到名为`input`的数据对象上，同时设置`ref`属性值为`input`。通过使用`@keyup.enter`并引用`addItem`方法，将`Enter`键绑定到`addItem`方法，该方法将在下一步创建：
- en: '[PRE0]'
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Introduce a button with a bound click event to `addItem` and include the corresponding
    method, `addItem()`, in the `methods` object. In the `addItem()` method, push
    the data prop `input` string into `shoppingList` and add a check to ensure the
    `input` prop exists. Optionally, add some styling to your buttons:'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`addItem`上引入一个绑定点击事件的按钮，并在`methods`对象中包含相应的`addItem()`方法。在`addItem()`方法中，将数据属性`input`的字符串推入`shoppingList`，并添加一个检查以确保`input`属性存在。可选地，为你的按钮添加一些样式：
- en: '[PRE1]'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Output the shopping list items in the DOM. When you click the `add item` button,
    it should be added to `shoppingList` and be displayed:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在DOM中输出购物清单项。当你点击“添加项目”按钮时，它应该被添加到`shoppingList`并显示：
- en: '[PRE2]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot displays the shopping list:'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了购物清单：
- en: '![Figure 1.44: The shopping list should be displayed based on user input'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.44：购物清单应根据用户输入显示'
- en: '](img/B15218_01_44.jpg)'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_01_44.jpg](img/B15218_01_44.jpg)'
- en: 'Figure 1.44: The shopping list should be displayed based on user input'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.44：购物清单应根据用户输入显示
- en: 'To match the last requirement to remove items from the list, create a new method
    called `deleteItem`, and allow one argument to be passed in, called `i`. If there
    is an argument passed into the method, filter out that array item and update the
    `shoppingList` prop; otherwise replace the data prop with an empty array:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了满足从列表中删除项目的最后要求，创建一个名为`deleteItem`的新方法，并允许传入一个名为`i`的参数。如果有参数传递到该方法中，过滤出该数组项并更新`shoppingList`属性；如果没有参数传递到该方法中，则用空数组替换数据属性：
- en: '[PRE3]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a `Delete all` button element and bind it to the `deleteItem` method
    using the click event, `@click`:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个“删除所有”按钮元素，并使用点击事件`@click`将其绑定到`deleteItem`方法：
- en: '[PRE4]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add a `remove` button in the list loop, which will delete individual shopping
    list items by passing in the `v-for` prop `i`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表循环中添加一个“删除”按钮，通过传递`v-for`属性`i`来删除单个购物清单项：
- en: '[PRE5]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Figure 1.45* displays the final output with all the details for the shopping
    list before adding the items:'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 1.45* 显示了添加项目之前的购物清单所有详细信息：'
- en: '![Figure 1.45: Final output'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.45：最终输出'
- en: '](img/B15218_01_45.jpg)'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_01_45.jpg](img/B15218_01_45.jpg)'
- en: 'Figure 1.45: Final output'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.45：最终输出
- en: 'The following screenshot displays the output after adding items to the shopping list:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了添加项目到购物清单后的输出：
- en: '![Figure 1.46: Final output with items added to the shopping list'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.46：添加项目到购物清单后的最终输出'
- en: '](img/B15218_01_46.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_01_46.jpg](img/B15218_01_46.jpg)'
- en: 'Figure 1.46: Final output with items added to the shopping list'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.46：添加项目到购物清单后的最终输出
- en: In this activity, you tested your knowledge of Vue by using all the basic functions
    of an **SFC**, such as expressions, loops, two-way binding, and event handling.
    You built a shopping list application that could let users add and delete individual
    list items or clear the total list in one click using Vue methods.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你通过使用**SFC**的所有基本功能来测试你的Vue知识，例如表达式、循环、双向绑定和事件处理。你构建了一个购物清单应用，允许用户使用Vue方法添加和删除单个列表项，或者通过单击一次清除整个列表。
- en: 2\. Working with Data
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 数据处理
- en: 'Activity 2.01: Creating a Blog List Using the Contentful API'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动二.01：使用Contentful API创建博客列表
- en: '**Solution:**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: Perform the following steps to complete the activity.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成活动。
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the code files for this activity, refer to [https://packt.live/33ao1f5](https://packt.live/33ao1f5).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此活动的代码文件，请参阅[https://packt.live/33ao1f5](https://packt.live/33ao1f5)。
- en: 'Create a new Vue project using the Vue CLI `vue create activity` command and
    select the following presets: Babel, SCSS pre-processor (you can choose either
    of the pre-processor), and the prettier formatter.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Vue CLI 的 `vue create activity` 命令创建一个新的 Vue 项目，并选择以下预设：Babel、SCSS 预处理器（您可以选择任一预处理器），以及
    prettier 格式化器。
- en: 'Add a `contentful` dependency:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `contentful` 依赖项：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In `App.vue`, remove the default content and import `contentful` into the component:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `App.vue` 中，移除默认内容并将 `contentful` 导入到组件中：
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add `async` methods to `getPeople` and `getBlogPosts` on the created life cycle,
    and assign the response of the calls to the `authors` and `posts` data props respectively
    in the template:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建生命周期中向 `getPeople` 和 `getBlogPosts` 添加 `async` 方法，并将调用响应分别分配给模板中的 `authors`
    和 `posts` 数据属性：
- en: '[PRE8]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Loop over articles using the `posts` object, and output `publishDate`, `title`,
    `description`, and `image`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `posts` 对象遍历文章，并输出 `publishDate`、`title`、`description` 和 `image`：
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add some `scss` styling to `articles-list`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `articles-list` 添加一些 `scss` 样式：
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use computed props to output the author''s information:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用计算属性输出作者信息：
- en: '[PRE11]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following screenshot displays the author information along with a list
    of their blog posts:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了作者信息以及他们的博客文章列表：
- en: '![Figure 2.16: Expected outcome with Contentful blog posts'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.16：使用 Contentful 博客文章的预期结果'
- en: '](img/B15218_02_16.jpg)'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_02_16.jpg]'
- en: 'Figure 2.16: Expected outcome with Contentful blog posts'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16：使用 Contentful 博客文章的预期结果
- en: In this activity, you built a blog that lists articles from an API source using
    the basic functions of a Vue SFC, using `async` methods to fetch remote data from
    an API, and using computed properties to organize deep nested object structures.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，您使用 Vue SFC 的基本功能构建了一个博客，列出了来自 API 源的文章，使用 `async` 方法从 API 获取远程数据，并使用计算属性组织深层嵌套的对象结构。
- en: 3\. Vue CLI
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. Vue CLI
- en: 'Activity 3.01: Building a Vue Application Using the Vue-UI and the Vuetify
    Component Library'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 3.01：使用 Vue-UI 和 Vuetify 组件库构建 Vue 应用程序
- en: '**Solution:**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: Perform the following steps to complete the activity.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成活动。
- en: Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the code files for this activity, refer to [https://packt.live/35WaCJG](https://packt.live/35WaCJG).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此活动的代码文件，请参阅 [https://packt.live/35WaCJG](https://packt.live/35WaCJG)。
- en: Open a command line, and run `vue create activity-app`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行，运行 `vue create activity-app`。
- en: 'Choose the last selection, `Manually select features`, by pressing the *Down
    arrow key* once and pressing *Enter*:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按一次 *向下箭头键* 并按 *Enter* 键选择最后一个选项，`手动选择功能`：
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Choose `Babel`, `CSS Pre-processors`, and `Linter / Formatter`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Babel`、`CSS 预处理器` 和 `检查器/格式化器`：
- en: '[PRE13]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Choose `Sass/SCSS (with dart-sass)`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Sass/SCSS (with dart-sass)`：
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we will choose `Eslint+ Prettier` to format the code as we proceed:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将选择 `Eslint+ Prettier` 来格式化代码：
- en: '[PRE15]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will then choose the options `Lint on save` and `Lint and fix on commit`
    to pick additional lint features and save them:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将选择选项 `保存时检查` 和 `提交时检查和修复` 以选择额外的检查功能并保存它们：
- en: '[PRE16]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To place the configurations in the dedicated files, we will choose the `In
    dedicated config files` option:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将配置放在专用文件中，我们将选择 `在专用配置文件中` 选项：
- en: '[PRE17]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Skip saving by pressing *Enter*. `npm` packages will automatically be installed.
    You should see the following output in your terminal:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按 *Enter* 键跳过保存。`npm` 包将自动安装。您应该在终端看到以下输出：
- en: '[PRE18]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After the packages are installed, run the `yarn serve` command. Next, go to
    your browser and navigate to `http://localhost:8080`. You should see the output
    as follows:![Figure 3.43: The default Vue project screen'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完包后，运行 `yarn serve` 命令。然后，转到您的浏览器并导航到 `http://localhost:8080`。您应该看到以下输出：![图
    3.43：默认 Vue 项目屏幕
- en: '](img/B15218_03_43.jpg)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_03_43.jpg]'
- en: 'Figure 3.43: The default Vue project screen'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.43：默认 Vue 项目屏幕
- en: Stop the `serve` task, and run `vue ui` in the command line.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止 `serve` 任务，并在命令行中运行 `vue ui`。
- en: Inside the Vue-UI, go to the project selection screen (found at `http://localhost:8000/project/select`).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Vue-UI 内，转到项目选择屏幕（位于 `http://localhost:8000/project/select`）。
- en: 'Click on the `Import` button and navigate to the folder your newly created
    Vue project is stored in. The following screenshot displays what your screen should
    look like:![Figure 3.44: The Vue-UI project manager'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `导入` 按钮，导航到您新创建的 Vue 项目存储的文件夹。以下截图显示了您的屏幕应该看起来像什么：![图 3.44：Vue-UI 项目管理器
- en: '](img/B15218_03_44.jpg)'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_03_44.jpg]'
- en: 'Figure 3.44: The Vue-UI project manager'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.44：Vue-UI 项目管理器
- en: Click on the big green `Import this folder` button.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击大绿色的 `导入此文件夹` 按钮。
- en: From the `Projects` dashboard, navigate to the `Plugins` tab.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Projects` 仪表板导航到 `Plugins` 选项卡。
- en: 'Click on the `+ Add plugin` button. Your screen should look like the following screenshot:![Figure
    3.45: The Vue-UI plugins manager, where you can add, remove,'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `+ 添加插件` 按钮。你的屏幕应该看起来像下面的截图：![图 3.45：Vue-UI 插件管理器，你可以在这里添加、删除、
- en: and modify Vue plugins
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并修改 Vue 插件
- en: '](img/B15218_03_45.jpg)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_03_45.jpg)'
- en: 'Figure 3.45: The Vue-UI plugins manager, where you can add, remove, and modify
    Vue plugins'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.45：Vue-UI 插件管理器，你可以在这里添加、删除和修改 Vue 插件
- en: 'Search for `vuetify` and install `vue-cli-plugin-vuetify`, then choose the
    default configuration settings, as shown in *Figure 3.46*:![Figure 3.46: The App.vue
    default configuration when the Vuetify CLI is installed'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 `vuetify` 并安装 `vue-cli-plugin-vuetify`，然后选择默认配置设置，如图 3.46 所示：![图 3.46：安装
    Vuetify CLI 时 App.vue 的默认配置
- en: '](img/B15218_03_46.jpg)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_03_46.jpg)'
- en: 'Figure 3.46: The App.vue default configuration when the Vuetify CLI is installed'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.46：安装 Vuetify CLI 时 App.vue 的默认配置
- en: 'Navigate to the `Tasks` page and click on `Start Tasks`. When the app initializes,
    click on the `Open App` button. On the localhost URL, you should see a Vuetify
    styled page as follows:![Figure 3.47: What you see in your browser when the Vuetify
    CLI plugin is installed'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `Tasks` 页面并点击 `Start Tasks`。当应用程序初始化时，点击 `Open App` 按钮。在 localhost URL 上，你应该看到一个如下所示的
    Vuetify 风格的页面：![图 3.47：当 Vuetify CLI 插件安装时你在浏览器中看到的内容
- en: '](img/B15218_03_47.jpg)'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_03_47.jpg)'
- en: 'Figure 3.47: What you see in your browser when the Vuetify CLI plugin is installed'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.47：当 Vuetify CLI 插件安装时你在浏览器中看到的内容
- en: Click on the `Select a layout` hyperlink in your Vuetify page layout.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Vuetify 页面布局中的 `Select a layout` 超链接。
- en: 'Click on the code link for the `Baseline` theme (or any other theme that interests
    you) from the options shown in the following screenshot:![Figure 3.48: The Vuetify
    website has multiple premade layouts available'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下截图所示的选项中点击 `Baseline` 主题（或任何其他你感兴趣的主题）的代码链接：![图 3.48：Vuetify 网站提供了多个预制的布局
- en: '](img/B15218_03_48.jpg)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_03_48.jpg)'
- en: 'Figure 3.48: The Vuetify website has multiple premade layouts available'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.48：Vuetify 网站提供了多个预制的布局
- en: 'Copy the contents of the `baseline.vue` file from the Vuetify repo and replace
    your `App.vue` file content with this content. Your `localhost:8080` should reload
    with the new content you copied in and the browser should appear as follows:![Figure
    3.49: The final outcome for the template as seen from your browser'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Vuetify 仓库复制 `baseline.vue` 文件的内容，并用此内容替换你的 `App.vue` 文件内容。你的 `localhost:8080`
    应该会重新加载你复制的内容，浏览器应显示如下：![图 3.49：从浏览器中看到的模板最终结果
- en: '](img/B15218_03_49.jpg)'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_03_49.jpg)'
- en: 'Figure 3.49: The final outcome for the template as seen from your browser'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.49：从浏览器中看到的模板最终结果
- en: By the end of this activity, you saw how to prepare a Vue.js project using the
    Vue-UI, selecting and organizing valuable presets used in the production of enterprise
    Vue applications. You installed and utilized the `Vuetify` framework utilizing
    Vuetify components to create a layout that you could then preview inside your
    browser.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到此活动结束时，你看到了如何使用 Vue-UI 准备 Vue.js 项目，选择和组织用于企业级 Vue 应用程序生产的宝贵预设。你安装并使用了 `Vuetify`
    框架，利用 Vuetify 组件创建了一个布局，然后你可以在浏览器中预览它。
- en: 4\. Nesting Components (Modularity)
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 嵌套组件（模块化）
- en: 'Activity 4.01: A Local Message View with Reusable Components'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 4.01：具有可重用组件的本地消息视图
- en: '**Solution**:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: Perform the following steps to complete the activity.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成活动。
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the code files for this activity, refer to [https://packt.live/36ZxyH8](https://packt.live/36ZxyH8).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此活动的代码文件，请参阅 [https://packt.live/36ZxyH8](https://packt.live/36ZxyH8)。
- en: 'First, we need a way to capture messages from the user:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一种方法来捕获用户的消息：
- en: 'Create a `MessageEditor` component that displays a `textarea`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个显示 `textarea` 的 `MessageEditor` 组件：
- en: '[PRE19]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Adding a reactive instance property can be done using the `data` component method:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `data` 组件方法可以添加一个响应实例属性：
- en: '[PRE20]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On `change` of `textarea`, we will store the state in a `message` reactive
    instance variable that we have set to null in the `data` component method:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `textarea` 发生 `change` 时，我们将状态存储在一个我们已在 `data` 组件方法中设置为 null 的 `message` 响应实例变量中：
- en: '[PRE21]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A `Send` operation should result in the latest content of the `textarea` being
    emitted as the payload of a `send` event:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 `Send` 操作应该导致 `textarea` 的最新内容作为 `send` 事件的负载发出：
- en: '[PRE22]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To display `MessageEditor`, we need to import it, register it in `components`,
    and reference it in the `template` section of `src/App.vue`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示 `MessageEditor`，我们需要导入它，在 `components` 中注册它，并在 `src/App.vue` 的 `template`
    部分引用它：
- en: '[PRE23]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To display messages, we will listen to `send` events using `@send` and add
    each payload to a new `messages` array reactive instance variable:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示消息，我们将使用 `@send` 监听 `send` 事件，并将每个有效负载添加到一个新的 `messages` 数组响应式实例变量中：
- en: '[PRE24]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`MessageFeed` supports being passed through a `messages` array as a `prop`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MessageFeed` 支持通过 `messages` 数组作为 `prop` 传递：'
- en: '[PRE25]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will use `v-for` to iterate through the `messages` array:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `v-for` 来遍历 `messages` 数组：
- en: '[PRE26]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To display the messages that we are storing, we will render `MessageFeed` in
    `App`, binding the `messages` app instance variable as the `messages` prop of
    `MessageFeed`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示我们存储的消息，我们将在 `App` 中渲染 `MessageFeed`，并将 `messages` 应用实例变量绑定为 `MessageFeed`
    的 `messages` 属性：
- en: '[PRE27]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In `MessageEditor`, we will refactor the `send` button click `handler` so that
    we also set `this.message` to `''''` when it''s clicked:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MessageEditor` 中，我们将重构 `send` 按钮点击 `handler`，以便在点击时也将 `this.message` 设置为
    `''`：
- en: '[PRE28]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The expected output is as follows:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 4.34: Message app with Hello World! and Hello JavaScript! sent'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.34：带有已发送的 Hello World! 和 Hello JavaScript! 的消息应用]'
- en: '](img/B15218_04_34.jpg)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_04_34.jpg]'
- en: 'Figure 4.34: Message app with Hello World! and Hello JavaScript! sent'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.34：带有已发送的 Hello World! 和 Hello JavaScript! 的消息应用
- en: With that, we have learned how to use components, props, events, and refs to
    render a chat interface.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学习了如何使用组件、属性、事件和引用来渲染聊天界面。
- en: 5\. Global Component Composition
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 全局组件组合
- en: 'Activity 5.01: Building a Vue.js Application with Plugins and Reusable Components'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 5.01：使用插件和可重用组件构建 Vue.js 应用程序
- en: '**Solution**:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'Perform the following steps to complete the activity:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动的步骤如下：
- en: Note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the code files for this activity, refer to [https://packt.live/35UlWpj](https://packt.live/35UlWpj).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此活动的代码文件，请参阅 [https://packt.live/35UlWpj](https://packt.live/35UlWpj)。
- en: 'Install `axios` into the project:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `axios` 安装到项目中：
- en: '[PRE29]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To inject `axios` as a property on `this` component instances, create a `src/plugins/axios.js`
    plugin file that, on `install`, will mean component instances have an `axios`
    property:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 `axios` 注入为 `this` 组件实例的属性，创建一个 `src/plugins/axios.js` 插件文件，在 `install` 时，这意味着组件实例将有一个
    `axios` 属性：
- en: '[PRE30]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For the plugin to work, import and register it in `src/main.js`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使插件工作，请在 `src/main.js` 中导入并注册它：
- en: '[PRE31]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We also want to inject our API''s `baseUrl` into all our components. We will
    create a plugin inline of the `src/main.js` file to do this:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望将我们的 API 的 `baseUrl` 注入到所有组件中。我们将在 `src/main.js` 文件中创建一个插件来执行此操作：
- en: '[PRE32]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Those familiar with `axios` know we could have injected this URL as the `axios`
    `baseURL`.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 熟悉 `axios` 的人知道我们可以将此 URL 注入为 `axios` 的 `baseURL`。
- en: 'Now, we need to fetch all `todos` from our `src/App.vue`. A good place to do
    this is inside the `mounted` life cycle method:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要从 `src/App.vue` 中获取所有 `todos`。在 `mounted` 生命周期方法中做这件事是个好地方：
- en: '[PRE33]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To display the `todo` list, we will create a `TodoList` functional component
    in `src/components/TodoList.vue`. This will take a `todos` prop, loop through
    the items, and defer rendering of our `todo` under a `todo` scoped slot that binds
    it:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示 `todo` 列表，我们将在 `src/components/TodoList.vue` 中创建一个 `TodoList` 函数式组件。这将接受一个
    `todos` 属性，遍历项目，并在 `todo` 作用域插槽中绑定它以延迟渲染我们的 `todo`：
- en: '[PRE34]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can now use the `TodoList` component to render out the `todos` prop we have
    already fetched in `src/App.vue`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `TodoList` 组件来渲染出我们在 `src/App.vue` 中已经获取的 `todos` 属性：
- en: '[PRE35]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will generate the following output:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![Figure 5.23: Todos loading and titles displaying'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.23：正在加载 Todos 和显示标题]'
- en: '](img/B15218_05_23.jpg)'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_05_23.jpg]'
- en: 'Figure 5.23: Todos loading and titles displaying'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.23：正在加载 Todos 和显示标题]'
- en: Note
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The link to this dataset, which has been exposed as a JSON API, can be found
    at [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/).
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该数据集的链接，已作为 JSON API 公开，可在 [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    找到。
- en: 'Now, let''s create a `TodoEntry` component where we will implement the majority
    of our todo-specific logic. A good practice for components is to have the props
    be very specific to the component''s role. In this case, the properties of the
    `todo` object we will tackle are `id`, `title`, and `completed`, so those should
    be the props that our `TodoEntry` component receives. We will not make `TodoEntry`
    a functional component since we will need a component instance to create HTTP
    requests:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个 `TodoEntry` 组件，我们将在这里实现大部分关于待办事项的逻辑。对于组件来说，一个好的做法是让 props 非常具体于组件的角色。在这种情况下，我们将处理的
    `todo` 对象的属性是 `id`、`title` 和 `completed`，因此这些应该是我们的 `TodoEntry` 组件接收的 props。我们不会将
    `TodoEntry` 制作成函数式组件，因为我们还需要一个组件实例来创建 HTTP 请求：
- en: '[PRE36]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Update `src/App.vue` so that it consumes `TodoEntry` as follows (make sure
    to bind `id`, `title`, and `completed`):'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `src/App.vue` 以使其消费 `TodoEntry` 如下（确保绑定 `id`、`title` 和 `completed`）：
- en: '[PRE37]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will get the following output:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '![Figure 5.24: TodoEntry rendering data that has been fetched from the API'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.24：TodoEntry 渲染从 API 获取的数据'
- en: '](img/B15218_05_24.jpg)'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_05_24.jpg)'
- en: 'Figure 5.24: TodoEntry rendering data that has been fetched from the API'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.24：TodoEntry 渲染从 API 获取的数据
- en: 'Now, we need to add the ability to toggle the `src/components/TodoEntry.vue`.
    We will listen to the `input` change event; on change, we will read the new value
    and send a `PATCH` request to `/todos/{todoId}` with an object containing `completed`
    set to the new value. We will also emit a `completedChange` event in Vue.js so
    that the `App` component can update the data that''s in-memory:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要添加切换 `src/components/TodoEntry.vue` 的功能。我们将监听 `input` 变更事件；在变更时，我们将读取新值，并向
    `/todos/{todoId}` 发送一个包含 `completed` 设置为新值的 `PATCH` 请求。我们还将发出一个 Vue.js 中的 `completedChange`
    事件，以便 `App` 组件可以更新内存中的数据：
- en: '[PRE38]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In `App.vue`, we need to update the relevant `todo` when `completeChange` is
    triggered. Since `completeChange` does not include the ID of our `todo`, we will
    need to read that from the context when we set the `handleCompleteChange` function
    so that it listens to `completeChange`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `App.vue` 中，当触发 `completeChange` 事件时，我们需要更新相关的 `todo`。由于 `completeChange`
    事件不包含我们 `todo` 的 ID，因此在我们设置 `handleCompleteChange` 函数以便它监听 `completeChange` 事件时，我们需要从上下文中读取那个
    ID：
- en: '[PRE39]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'At this stage, we should see the following output:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个阶段，我们应该看到以下输出：
- en: '![Figure 5.25: Our to-do app using JSON placeholder data'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.25：使用 JSON placeholder 数据的待办事项应用'
- en: '](img/B15218_05_25.jpg)'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_05_25.jpg)'
- en: 'Figure 5.25: Our to-do app using JSON placeholder data'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.25：使用 JSON placeholder 数据的待办事项应用
- en: With that, we have learned how to use plugins and reusable components to build
    a `todo` app that consumes `JSONPlaceholder` data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学会了如何使用插件和可重用组件来构建一个消费 `JSONPlaceholder` 数据的 `todo` 应用。
- en: 6\. Routing
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 路由
- en: 'Activity 6.01: Creating a Message SPA with Dynamic, Nested Routing, and Layouts'
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 6.01：创建一个带有动态嵌套路由和布局的消息单页应用
- en: '**Solution:**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'Perform the following steps to complete the activity:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下步骤以完成活动：
- en: Note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the code files for this activity, refer to [https://packt.live/2ISxml7](https://packt.live/2ISxml7).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此活动的代码文件，请参阅 [https://packt.live/2ISxml7](https://packt.live/2ISxml7)。
- en: Create a new `MessageEditor.vue` file in the `src/views/` folder as the main
    component to interact with the user when writing a message. We use `textarea`
    as a message input field and attach the `listener` method `onChange` to the `DOM`
    event change to capture any input change regarding the message typed by the user.
    Also, we add `ref` to keep a pointer record to the rendered HTML `textarea` element
    for modifying our saved messages at a later stage.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/views/` 文件夹中创建一个新的 `MessageEditor.vue` 文件，作为主要组件，用于与用户交互以编写消息。我们使用 `textarea`
    作为消息输入字段，并将 `listener` 方法 `onChange` 绑定到 `DOM` 事件 `change` 上，以捕获用户输入的任何消息更改。此外，我们还添加了
    `ref` 以保持对渲染的 HTML `textarea` 元素的指针记录，以便在稍后阶段修改我们保存的消息。
- en: Besides this, we also attach another `listener` method, `onSendClick`, to the
    `click` event on the `Submit button` to capture the user's confirmation for sending
    the message. The actual logic implementation of both `onChange` and `onSendClick`
    is shown in *Step 3*.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了这个之外，我们还附加了另一个 `listener` 方法 `onSendClick` 到 `提交按钮` 的 `click` 事件上，以捕获用户发送消息的确认。`onChange`
    和 `onSendClick` 的实际逻辑实现显示在 *步骤 3* 中。
- en: 'The `<template>` section should look like the following:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<template>` 部分 应该看起来像以下这样：'
- en: '[PRE40]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And in `script`, in addition to the previous code, we will also receive a `list`
    of messages to update with the new message after submitting, and emit the updated
    list back to the parent:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `script` 中，除了之前的代码外，我们还将接收到一个 `list`，用于在提交新消息后更新，并将更新后的列表发送回父组件：
- en: '[PRE41]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We need to define a parent route as a default route with the `path` of `/`
    and `name` of `messages` in the routes array in `./src/router/index.js`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在 `./src/router/index.js` 中的路由数组中定义一个父路由作为默认路由，其 `path` 为 `/`，`name` 为 `messages`：
- en: '[PRE42]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then add a new route as a nested route called `editor` under the `children`
    property of this route configuration:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在 `children` 属性下添加一个新的路由作为嵌套路由，称为 `editor`：
- en: '[PRE43]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We create a new view component called `MessageList.vue` with `v-for` to render
    the list of messages into the `router-link` component:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的视图组件 `MessageList.vue`，使用 `v-for` 将消息列表渲染到 `router-link` 组件中：
- en: '[PRE44]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And, similarly to *Step 2*, register the `MessageList.vue` component with the
    `children` routes array of the `messages` route:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似于 *步骤 2*，将 `MessageList.vue` 组件注册到 `messages` 路由的 `children` 路由数组中：
- en: '[PRE45]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now our `messages` view needs a UI. We define the `Messages.vue` view with
    the use of `router-link` to allow navigation between `editor` and `list` and a
    `router-view` component for rendering the nested view:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的 `messages` 视图需要一个 UI。我们使用 `router-link` 定义 `Messages.vue` 视图，以允许在 `editor`
    和 `list` 之间进行导航，并使用 `router-view` 组件来渲染嵌套视图：
- en: '[PRE46]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And, of course, we need to receive a `list` of messages from `props`:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，我们需要从 `props` 接收一个 `messages` 的 `list`：
- en: '[PRE47]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Since we don''t have a global state or proper database, we need to mock a global
    list of messages in `./src/router/index.js`:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们没有全局状态或适当的数据库，我们需要在 `./src/router/index.js` 中模拟一个全局消息列表：
- en: '[PRE48]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then pass it as default `props` for the `messages` route, as follows:'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后将它作为默认 `props` 传递给 `messages` 路由，如下所示：
- en: '[PRE49]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In order to catch whether the user is leaving the current editor view, we will
    add a Hook on the `beforeRouteLeave` in-component navigation guard, which will
    allow us to display a warning and abort or continue per the user''s decision.
    This is done within `MessageEditor.vue` file:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了捕捉用户是否正在离开当前编辑视图，我们将在组件内的 `beforeRouteLeave` 导航守卫上添加一个 Hook，这将允许我们显示警告并根据用户的决定中止或继续。这是在
    `MessageEditor.vue` 文件中完成的：
- en: '[PRE50]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Creating `messageLayout.vue` is simple, with a header text, the `content` from
    `props`, and a `Back button`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `messageLayout.vue` 很简单，包括标题文本、来自 `props` 的 `content` 和一个 `返回按钮`：
- en: '[PRE51]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `goBack` logic should be simple: if there is a previous route saved, let''s
    go back one step in the navigation stack with `this.$routes.go(-1)`. Otherwise,
    we will just push the `messages` navigation route to the stack with `this.$router.push({
    name: ''message''})`:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`goBack` 逻辑应该是简单的：如果有保存的前一个路由，我们就使用 `this.$routes.go(-1)` 在导航栈中后退一步。否则，我们将使用
    `this.$router.push({ name: ''message''})` 将 `messages` 导航路由推送到栈中：'
- en: '[PRE52]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: But then we still need to pass the previous route, `this.$route.params.from`,
    from the tracking. It should be done at the route registration.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但然后我们仍然需要从跟踪中传递前一个路由，`this.$route.params.from`，应在路由注册时完成。
- en: We add the `message` route configuration inside `routes`, and we will use the
    `beforeEnter` component guard to save and pass the `from` previous navigation
    route to the `params` of the view.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `routes` 中添加 `message` 路由配置，并使用 `beforeEnter` 组件守卫将 `from` 前一个导航路由保存并传递到视图的
    `params` 中。
- en: 'Also, since it is a dynamic route with the `message/:id` pattern, we need to
    retrieve the content of the message and map that content to the related prop accordingly:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，由于它是一个具有 `message/:id` 模式的动态路由，我们需要检索消息内容并将其映射到相关的 prop 上：
- en: '[PRE53]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finally, to code-split the UI layouts from `Message.vue` and `Messages.vue`,
    in the `./src/layouts` folder, we create both a `default.vue` layout and `messageLayout.vue`
    layout.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了从 `Message.vue` 和 `Messages.vue` 中拆分 UI 布局，在 `./src/layouts` 文件夹中，我们创建了一个
    `default.vue` 布局和一个 `messageLayout.vue` 布局。
- en: 'As we learned in this chapter, in `App.vue`, we will wrap `router-view` with
    a component that renders according to a layout variable. And, certainly, `router-view`
    needs to have a synchronous `layout` property to dynamically change the layout
    according to the current view:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如我们在本章所学，在 `App.vue` 中，我们将使用根据布局变量渲染的组件包裹 `router-view`。当然，`router-view` 需要一个同步的
    `layout` 属性，以便根据当前视图动态更改布局：
- en: '[PRE54]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In `default.vue`, we will simply just have the header text for the `messages`
    section and a `slot`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `default.vue` 中，我们只需为 `messages` 部分添加标题文本和一个 `slot`：
- en: '[PRE55]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In `messageLayout.vue`, we will extract the header text and the button logic
    from `Message.vue`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `messageLayout.vue` 中，我们将从 `Message.vue` 中提取标题文本和按钮逻辑：
- en: '[PRE56]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And the final step is to make sure an `update:layout` event will be triggered
    to update the view layout upon component creation for both `Message.vue` and `Messages.vue`:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一步是确保在组件创建时触发 `update:layout` 事件以更新 `Message.vue` 和 `Messages.vue` 的视图布局：
- en: '[PRE57]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In `Messages.vue`, this will be as follows:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `Messages.vue` 中，这将如下所示：
- en: '[PRE58]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Run the application using the following command:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行应用程序：
- en: '[PRE59]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To ensure you''ve completed the steps correctly, you will need to visit each
    route and ensure the content renders as shown in the corresponding figure. First,
    ensure that the `/list` view renders a message feed as shown in *Figure 6.47*:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了确保您已正确完成步骤，您需要访问每个路由并确保内容渲染与相应的图示一致。首先，确保 `/list` 视图渲染的消息列表如图 6.47 所示：
- en: '![Figure 6.47: The /list view in the Messages app'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.47：Messages 应用中的 /list 视图'
- en: '](img/B15218_06_47.jpg)'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_06_47.jpg)'
- en: 'Figure 6.47: The /list view in the Messages app'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.47：Messages 应用中的 /list 视图
- en: 'Next, ensure that the `/editor` view allows a user to send a new message, as
    shown in *Figure 6.48*:![Figure 6.48: The /editor view in the Messages app'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，确保 `/editor` 视图允许用户发送新消息，如图 6.48 所示：![图 6.48：Messages 应用中的 /editor 视图
- en: '](img/B15218_06_48.jpg)'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_06_48.jpg)'
- en: 'Figure 6.48: The /editor view in the Messages app'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.48：Messages 应用中的 /editor 视图
- en: 'Next, ensure the `/message/:id` dynamic route is working by going to the `/message/0`
    route. You should see message content similar to that shown in *Figure 6.49*:![Figure
    6.49: The /message/0 view in the Message app'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，确保通过访问 `/message/0` 路由来确保 `/message/:id` 动态路由正常工作。你应该会看到类似于图 6.49 所示的消息内容：![图
    6.49：Message 应用中的 /message/0 视图
- en: '](img/B15218_06_49.jpg)'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_06_49.jpg)'
- en: 'Figure 6.49: The /message/0 view in the Message app'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.49：Message 应用中的 /message/0 视图
- en: 'Ensure that when the user is composing a message, if they try to navigate away
    without having a saved message, an alert is triggered, as shown in *Figure 6.50*:![Figure
    6.50: The /editor view when the user tries to navigate away with an unsaved message'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保当用户正在编写消息时，如果他们尝试在没有保存消息的情况下离开，将触发一个警告，如图 6.50 所示：![图 6.50：用户尝试在没有保存消息的情况下离开时的
    /editor 视图
- en: '](img/B15218_06_50.jpg)'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_06_50.jpg)'
- en: 'Figure 6.50: The /editor view when the user tries to navigate away with an
    unsaved message'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.50：用户尝试在没有保存消息的情况下离开时的 /editor 视图
- en: Note
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Our `messages` data is not saved upon refresh, as we don't have global state
    management. We can use `localStorage` to help to save the data while exploring
    the application.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有全局状态管理，我们的 `messages` 数据在刷新时不会保存。我们可以在探索应用程序时使用 `localStorage` 来帮助保存数据。
- en: In this activity, we put together several of the topics covered in this chapter,
    including setting up views, making use of templates and dynamic routes, and the
    use of Hooks to prompt a confirmation alert before the user navigates away with
    unsaved content. These tools can be used for many common SPA use cases and will
    be helpful in your future projects.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，我们将本章涵盖的几个主题组合在一起，包括设置视图、使用模板和动态路由，以及使用 Hooks 在用户在未保存内容的情况下离开前提示确认警告。这些工具可用于许多常见的
    SPA 用例，并将有助于您未来的项目。
- en: 7\. Animations and Transitions
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 动画和过渡
- en: 'Activity 7.01: Building a Messages App with Transition and GSAP'
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动七.01：使用过渡和 GSAP 构建 Messages 应用
- en: '**Solution:**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'Perform the following steps to complete the activity:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成活动：
- en: Note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the code files for this activity, visit [https://packt.live/399tZ3Y](https://packt.live/399tZ3Y).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此活动的代码文件，请访问 [https://packt.live/399tZ3Y](https://packt.live/399tZ3Y)。
- en: We will reuse the code created in *Chapter 6*, *Routing* for the `Message` app
    so we have all the routing setup accordingly.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重用第 6 章中创建的 *路由* 代码，以便为 `Message` 应用设置所有路由。
- en: 'The `template` section of `src/views/MessageEditor.vue` will be as follows:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`src/views/MessageEditor.vue` 的 `template` 部分将如下所示：'
- en: '[PRE60]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, the `script` section of `src/views/MessageEditor.vue` should contain
    logic for both clicking on and leaving the route:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`src/views/MessageEditor.vue` 的 `script` 部分应包含点击和离开路由的逻辑：
- en: '[PRE61]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, we will need our `template` code for `MessageList.vue`. The code will
    be as follows:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要 `MessageList.vue` 的 `template` 代码。代码如下：
- en: '[PRE62]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, we will need a `script` section in our `MessageList.vue` file. To add
    the `script` section, the code will be as follows:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 `MessageList.vue` 文件中添加一个 `script` 部分。要添加 `script` 部分，代码如下：
- en: '[PRE63]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We''ll also create a `style` section in `MessageList.vue` and define the `.flip-move`
    class with the following code:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将在 `MessageList.vue` 中创建一个 `style` 部分，并使用以下代码定义 `.flip-move` 类：
- en: '[PRE64]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`Message.vue` should contain the rendered content inside a `p` element. We''ll
    also define the `content` prop and emit an update signal:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Message.vue` 应该在 `p` 元素内包含渲染的内容。我们还将定义 `content` 属性并发出更新信号：'
- en: '[PRE65]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Ensure your `src/router/index.js` file is the same as the one created in *Activity
    6.01*, *Creating a Message SPA with Dynamic, Nested Routing, and Layouts* in *Chapter
    6*, *Routing*, which can be found at [https://packt.live/2ISxml7](https://packt.live/2ISxml7):'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的 `src/router/index.js` 文件与在 *第6章，路由* 中创建的相同，*创建具有动态嵌套路由和布局的消息SPA*，该章节可在
    [https://packt.live/2ISxml7](https://packt.live/2ISxml7) 找到：
- en: '[PRE66]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We will now wrap `router-view` in the `<template>` section of `App.vue` with
    a `transition` component that has two attributes, `name="fade"` and `mode="out-in"`:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用具有两个属性 `name="fade"` 和 `mode="out-in"` 的 `transition` 组件包裹 `App.vue`
    中的 `<template>` 部分的 `router-view`：
- en: '[PRE67]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In `src/views/Messages.vue`, we will wrap `router-view` with a `transition`
    component. This time, we will use a custom `enter-active-class` transition class
    attribute in addition to the `fade` name:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/views/Messages.vue` 中，我们将使用 `transition` 组件包裹 `router-view`。这次，我们将使用一个自定义的
    `enter-active-class` 过渡类属性，以及 `fade` 名称：
- en: '[PRE68]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Add the `zoom-in` and `fade-enter` animation effects in the `style` section
    of `src/views/Messages.vue`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/views/Messages.vue` 的 `style` 部分中添加 `zoom-in` 和 `fade-enter` 动画效果：
- en: '[PRE69]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add `transition-group` as the wrapper for the list of message links in `src/views/MessageList.vue`,
    with JavaScript hooks for programmatic animation. But we have to specify that
    transition on the initial render of the page, as the list is supposed to animate
    when appearing. We will add the `appear` attribute and bind `enter` to `appear`,
    as well as add the `move-class` flip (an animation to be created later in the
    `style` section):'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/views/MessageList.vue` 中，将 `transition-group` 作为消息链接列表的包装器，并使用 JavaScript
    钩子进行程序化动画。但我们必须指定在页面初始渲染时的过渡，因为列表应该在出现时进行动画。我们将添加 `appear` 属性并将 `enter` 绑定到 `appear`，以及添加
    `move-class` 翻转（将在 `style` 部分稍后创建的动画）：
- en: '[PRE70]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Add GSAP as a dependency and implement the bounce-in effect on the `appear`
    transition event handler (hook) in `src/views/MessageList.vue`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 GSAP 作为依赖项添加，并在 `src/views/MessageList.vue` 中的 `appear` 过渡事件处理程序（钩子）上实现弹跳进入效果：
- en: '[PRE71]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, we need to create the `flip-move` class that we defined in our HTML.
    We''ll do that by adding a `style` section with our new `flip-move` class:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建我们在 HTML 中定义的 `flip-move` 类。我们将通过添加一个包含我们的新 `flip-move` 类的 `style`
    部分来完成此操作：
- en: '[PRE72]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Run the application using the `yarn serve` command and you should see the following
    in your browser at `localhost:8080`:![Figure 7.19: Fade out when navigating from
    message list view to editor view'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `yarn serve` 命令运行应用程序，你应该在浏览器中的 `localhost:8080` 看到以下内容：![图7.19：从消息列表视图导航到编辑视图时淡出
- en: '](img/B15218_07_19.jpg)'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_07_19.jpg)'
- en: 'Figure 7.19: Fade out when navigating from message list view to editor view'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19：从消息列表视图导航到编辑视图时淡出
- en: 'You should now see a fade out when navigating from the message list view to
    the editor view, as shown in *Figure 7.19*, and also a fade out when going from
    the editor view to the list view, as shown in *Figure 7.20*:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该在从消息列表视图导航到编辑视图时看到淡出效果，如 *图7.19* 所示，以及从编辑视图导航到列表视图时的淡出效果，如 *图7.20* 所示：
- en: '![Figure 7.20: Fade out when navigating from editor view to message list view'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.20：从编辑视图导航到消息列表视图时淡出'
- en: '](img/B15218_07_20.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_07_20.jpg)'
- en: 'Figure 7.20: Fade out when navigating from editor view to message list view'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20：从编辑视图导航到消息列表视图时淡出
- en: 'When the messages are in the feed, you should see a bouncing effect during
    the flipping motion, as shown in *Figure 7.21*:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息在动态中时，你应该看到翻转动作期间的弹跳效果，如 *图7.21* 所示：
- en: '![Figure 7.21: Bouncing effect when displaying the message feed in the message
    list view'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.21：在消息列表视图中显示消息动态时的弹跳效果'
- en: '](img/B15218_07_21.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_07_21.jpg)'
- en: 'Figure 7.21: Bouncing effect when displaying the message feed in the message
    list view'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21：在消息列表视图中显示消息动态时的弹跳效果
- en: 'Finally, when clicking on a specific message in the list, it should render
    the content as shown in *Figure 7.22*:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当点击列表中的特定消息时，它应该渲染如 *图7.22* 所示的内容：
- en: '![Figure 7.22: Single message view'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.22：单个消息视图'
- en: '](img/B15218_07_22.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_07_22.jpg)'
- en: 'Figure 7.22: Single message view'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22：单个消息视图
- en: In this activity, we put together several different animations and combined
    them with routing to create custom page transitions. We used several different
    animation types to demonstrate the many possibilities animations can provide.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将几个不同的动画组合起来，并与路由结合以创建自定义页面过渡。我们使用了多种不同的动画类型来展示动画可以提供的多种可能性。
- en: 8\. The State of Vue.js State Management
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. Vue.js状态管理的状态
- en: 'Activity 8.01: Adding Email and Phone Number to a Profile Card Generator'
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第8.01节：将邮箱和电话号码添加到个人资料卡片生成器
- en: '**Solution:**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'Perform the following steps to compete the activity:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成活动：
- en: Note
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the code files for this activity, refer to [https://packt.live/3m1swQE](https://packt.live/3m1swQE).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此活动的代码文件，请参阅[https://packt.live/3m1swQE](https://packt.live/3m1swQE)。
- en: 'We can start by adding a new `email` input field and label to `src/components/AppProfileForm`
    for the `Email` field:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从向`src/components/AppProfileForm`添加一个新的`email`输入字段和标签开始，用于`Email`字段：
- en: '[PRE73]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We can then add a new `phone` input field (of type `tel`) and a label to `AppProfileForm`
    for the `Phone Number` field:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在`AppProfileForm`中添加一个新的`phone`输入字段（类型为`tel`）和标签，用于`Phone Number`字段：
- en: '[PRE74]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The new fields look as follows:'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新字段如下所示：
- en: '![Figure 8.35: Application with new Email and Phone Number fields'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.35：包含新邮箱和电话号码字段的示例应用'
- en: '](img/B15218_08_35.jpg)'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_08_35.jpg)'
- en: 'Figure 8.35: Application with new Email and Phone Number fields'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.35：包含新邮箱和电话号码字段的示例应用
- en: 'We can then add the `email` and `phone` fields to the initial state and mutations
    in `src/store.js` so that `organization` gets initialized, set during `profileUpdate`,
    and reset during `profileClear`:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在`src/store.js`中的初始状态和变异中添加`email`和`phone`字段，以便`organization`在初始化时设置，在`profileUpdate`时设置，并在`profileClear`时重置：
- en: '[PRE75]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We need to track `email` in the local state of the `src/components/AppProfileForm.vue`
    component using `v-model` and initialize it in the `data()` function:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`src/components/AppProfileForm.vue`组件的本地状态中使用`v-model`跟踪`email`，并在`data()`函数中初始化它：
- en: '[PRE76]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We need to track `phone` in the local state of the `src/components/AppProfileForm.vue`
    component using `v-model` and initialize it in the `data()` function:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`src/components/AppProfileForm.vue`组件的本地状态中使用`v-model`跟踪`phone`，并在`data()`函数中初始化它：
- en: '[PRE77]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'For the payload of the mutation to contain `email` and `phone`, we''ll need
    to add it to the `$store.commit(''profileUpdate'')` payload. We''ll also want
    to reset it on the form when a component triggers a `profileClear` mutation:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让变异的负载包含`email`和`phone`，我们需要将其添加到`$store.commit('profileUpdate')`的负载中。我们还想在组件触发`profileClear`变异时在表单上重置它：
- en: '[PRE78]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'For `email` to display, we need to render it in `src/components/AppProfileDisplay.vue`
    using a conditional paragraph (to hide the `Email` label when there is no email
    set):'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使`email`显示，我们需要在`src/components/AppProfileDisplay.vue`中使用条件段落（在没有设置邮箱时隐藏`Email`标签）来渲染它：
- en: '[PRE79]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'For `phone` to display, we need to render it in `src/components/AppProfileDisplay.vue`
    using a conditional span (to hide the `Phone Number` label when there is no phone
    set):'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使`phone`显示，我们需要在`src/components/AppProfileDisplay.vue`中使用条件span（在没有设置电话时隐藏`Phone
    Number`标签）来渲染它：
- en: '[PRE80]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The application should look as follows when the form is filled out and submitted:'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当表单填写并提交时，应用应如下所示：
- en: '![Figure 8.36: Application with Email and Phone Number fields'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.36：包含邮箱和电话号码字段的示例应用'
- en: '](img/B15218_08_36.jpg)'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_08_36.jpg)'
- en: 'Figure 8.36: Application with Email and Phone Number fields'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.36：包含邮箱和电话号码字段的示例应用
- en: We have now seen how to add new fields to a Vuex-managed application. Next,
    we will see how to decide whether to put something into global or local state.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何向Vuex管理的应用中添加新字段。接下来，我们将看到如何决定是否将某些内容放入全局或局部状态。
- en: 9\. Working with Vuex – State, Getters, Actions, and Mutations
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 使用Vuex – 状态、获取器、操作和变异
- en: 'Activity 9.01: Creating a Simple Shopping Cart and Price Calculator'
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第9.01节：创建简单的购物车和价格计算器
- en: '**Solution**:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'Perform the following steps to complete the activity:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成活动：
- en: Note
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the code files for this activity, refer to [https://packt.live/2KpvBvQ](https://packt.live/2KpvBvQ).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此活动的代码文件，请参阅[https://packt.live/2KpvBvQ](https://packt.live/2KpvBvQ)。
- en: Create a new Vue application with Vuex support via the CLI.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用CLI创建一个新的具有Vuex支持的Vue应用。
- en: 'Add the products and empty `cart` to the store located in `store/index.js`.
    Note that the product names and prices are arbitrary:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将产品和空`cart`添加到位于`store/index.js`的存储中。请注意，产品名称和价格是任意的：
- en: '[PRE81]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create a new `Products` component (`components/Products.vue`) that iterates
    over each product and includes the name and price for each product. It will also
    include buttons to add or remove items from the cart:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Products` 组件 (`components/Products.vue`)，它遍历每个产品并包括每个产品的名称和价格。它还将包括添加或从购物车中删除项目的按钮：
- en: '[PRE82]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In order for products to be used without prepending `$store`, include `mapState`
    and define its use within the `computed` property of the `Products` component:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在不添加 `$store` 前缀的情况下使用产品，包括 `mapState` 并在 `Products` 组件的 `computed` 属性中定义其使用：
- en: '[PRE83]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next include the methods for adding and removing items from the cart. This
    will simply call the mutations in the store:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来包括添加和从购物车中删除项目的函数。这只会调用存储中的mutations：
- en: '[PRE84]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Define your mutations to handle working with the cart in the `store/index.js`
    file. When adding a new item to the cart, you first need to see if it was previously
    added and if so, simply increment the quantity. When removing items from the cart,
    if the quantity hits 0, the item should be removed completely:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `store/index.js` 文件中定义您的mutations来处理与购物车的工作。当向购物车添加新项目时，您首先需要查看该项目是否之前已添加，如果是，则简单地增加数量。当从购物车中删除项目时，如果数量达到0，则应完全删除该项目：
- en: '[PRE85]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Define a `Cart` component (`components/Cart.vue`) that iterates over the cart
    and shows the quantity of each item:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `Cart` 组件 (`components/Cart.vue`)，它遍历购物车并显示每个项目的数量：
- en: '[PRE86]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'As with the previous component, add `mapState` and alias the cart:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与前面的组件一样，添加 `mapState` 并将购物车别名为：
- en: '[PRE87]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Define the final component, `Checkout` (`components/Checkout.vue`), and have
    it display a property named `cartTotal`. This will be defined via a getter that
    will be created in the store:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义最终的组件 `Checkout` (`components/Checkout.vue`)，并显示一个名为 `cartTotal` 的属性。这将通过在存储中创建的getter来定义：
- en: '[PRE88]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Map the getter in the script block:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本块中映射getter：
- en: '[PRE89]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Add a checkout button. It should only show up when there is a total and should
    run a method named `checkout`:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个结账按钮。它应该只在存在总计时显示，并运行名为 `checkout` 的方法：
- en: '[PRE90]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Define `checkout` to simply alert the user:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `checkout` 以简单地提醒用户：
- en: '[PRE91]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Back in the Vuex store, define the getter for `cartTotal`. It needs to iterate
    over the cart and determine the sum by multiplying price by quantity:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Vuex存储中，定义 `cartTotal` 的getter。它需要遍历购物车并通过将价格乘以数量来确定总和：
- en: '[PRE92]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Use all three components in the main `App.vue` component:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主 `App.vue` 组件中使用所有三个组件：
- en: '[PRE93]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Start your application as you have done before (`npm run serve`) and open the
    URL in your browser. You should get the following output initially, showing an
    empty cart:'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照之前的方式启动您的应用程序 (`npm run serve`) 并在浏览器中打开URL。最初，您应该看到以下输出，显示一个空购物车：
- en: '![Figure 9.9: Initial display of the cart'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.9：购物车的初始显示](img/B15218_09_09.jpg)'
- en: '](img/B15218_09_09.jpg)'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_09_09.jpg)'
- en: 'Figure 9.9: Initial display of the cart'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：购物车的初始显示
- en: 'As you add and remove items, you''ll see the cart and totals update in real
    time:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当您添加和删除项目时，您会看到购物车和总计实时更新：
- en: '![Figure 9.10: The cart with items of multiple quantities added'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.10：添加了多个数量项目的购物车](img/B15218_09_10.jpg)'
- en: '](img/B15218_09_10.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_09_10.jpg)'
- en: 'Figure 9.10: The cart with items of multiple quantities added'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：添加了多个数量项目的购物车
- en: The preceding figure displays the products and their prices, along with a cart
    containing multiple quantities of different products and the final checkout amount.
    You've now got a fully built, albeit simple, e-commerce cart product driven by
    Vue and Vuex.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了产品和它们的价格，以及包含多个不同产品数量的购物车和最终的结账金额。您现在已经构建了一个完整的、尽管简单的、由Vue和Vuex驱动的电子商务购物车产品。
- en: 10\. Working with Vuex – Fetching Remote Data
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 使用Vuex – 获取远程数据
- en: 'Activity 10.01: Using Axios and Vuex with Authentication'
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动10.01：使用Axios和Vuex进行身份验证
- en: '**Solution:**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: Perform the following steps to complete the activity.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动。
- en: Note
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the code files for this activity, refer to [https://packt.live/3kVox6M](https://packt.live/3kVox6M).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此活动的代码文件，请参阅 [https://packt.live/3kVox6M](https://packt.live/3kVox6M)。
- en: 'Use the CLI to scaffold a new application and be sure to enable both Vuex and
    Vue Router. When done, then use `npm` to install `Axios`. Now that you have got
    the app scaffolded, let''s begin building it. First, open `App.vue`, the core
    component in the application, and modify it so that the entire template is the view:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用CLI来构建新的应用程序，并确保启用Vuex和Vue Router。完成后，使用 `npm` 安装 `Axios`。现在您已经构建了应用程序的框架，让我们开始构建它。首先，打开
    `App.vue`，这是应用程序的核心组件，并修改它，使整个模板成为视图：
- en: '[PRE94]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'By default, the CLI will scaffold two `views`: `Home` and `About`. We are going
    to change `About` to be the view that displays cats, but for now, open `Home.vue`
    and add the login form. Use a button to run a method to perform the (fake) login:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，CLI 会生成两个 `views`：`Home` 和 `About`。我们将把 `About` 改成显示猫的视图，但现在打开 `Home.vue`
    并添加登录表单。使用按钮运行一个方法来执行（假的）登录：
- en: '[PRE95]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Add the `data` for the login form and a `handler` for the login button. This
    will then fire off a dispatch to the store. On a successful login (and it will
    always be successful), `$router.replace` is used to navigate to the next page.
    This is done instead of `$router.go` so that the user cannot hit their back button
    to return to the login form:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加登录表单的 `data` 和登录按钮的 `handler`。这将触发对存储的 dispatch。在成功的登录（它总是会成功）后，使用 `$router.replace`
    来导航到下一页。这样做是为了代替 `$router.go`，这样用户就不能通过点击后退按钮返回到登录表单：
- en: '[PRE96]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now let''s build the `Cats` component in `views/Cats.vue`. This will simply
    iterate over the cats from the store and dispatch a call to the store to load
    them:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在 `views/Cats.vue` 中构建 `Cats` 组件。这个组件将简单地遍历存储中的猫，并对存储进行调用以加载它们：
- en: '[PRE97]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now build the Vuex store by editing `store/index.js`. Begin by importing Vuex
    and defining constants for the two endpoints. Remember that we are *faking* a
    real API here, so the endpoints just return static JSON:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过编辑 `store/index.js` 来构建 Vuex 存储。首先导入 Vuex 并定义两个端点的常量。记住，我们在这里是*模拟*一个真实的
    API，所以端点只是返回静态的 JSON：
- en: '[PRE98]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The store needs to keep two things: the authentication `token` and `cats`.
    Set up the `state` and define `mutations` for them:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储需要保留两样东西：认证 `token` 和 `cats`。设置 `state` 并为它们定义 `mutations`：
- en: '[PRE99]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now add the `actions`. The login action stores the result as a `token` and
    the `cats` action passes the `token` as an `authorization` header:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加 `actions`。登录 `action` 将结果存储为 `token`，而 `cats` `action` 将 `token` 作为 `authorization`
    标头传递：
- en: '[PRE100]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The final piece of the application is the router, and there is a pretty interesting
    aspect to it. Think about the `cats` page. What happens if a user goes to that
    page first? With no token, the call to the endpoint will fail to return valid
    data. (Again, in a *real* server, that is.) Luckily, Vue Router provides a very
    simple way to handle this—route guards. Make use of `beforeEnter` to handle this
    call in the `cats` route. Edit your `router/index.js` file to look like the following
    code:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序的最后一部分是路由器，它有一个相当有趣的特点。想想 `cats` 页面。如果用户首先访问该页面会发生什么？没有 `token`，对端点的调用将无法返回有效数据。（再次，在一个*真实*的服务器上是这样。）幸运的是，Vue
    Router 提供了一种非常简单的方式来处理这种情况——路由守卫。在 `cats` 路由中利用 `beforeEnter` 来处理这个调用。编辑你的 `router/index.js`
    文件，使其看起来像以下代码：
- en: '[PRE101]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Start the application with `npm run serve`, copy the URL to your browser, and
    you should get the following output initially:![Figure 10.8: Initial login screen'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm run serve` 启动应用程序，将 URL 复制到浏览器中，你应该会看到以下输出：![图 10.8：初始登录屏幕
- en: '](img/B15218_10_08.jpg)'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_10_08.jpg](img/B15218_10_08.jpg)'
- en: 'Figure 10.8: Initial login screen'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8：初始登录屏幕
- en: 'After logging in, you will see the data displayed as in the following screenshot:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，你会看到以下截图所示的数据显示：
- en: '![Figure 10.9: Successfully displaying the data after login'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.9：登录成功后成功显示数据'
- en: '](img/B15218_10_09.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_10_09.jpg](img/B15218_10_09.jpg)'
- en: 'Figure 10.9: Successfully displaying the data after login'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9：登录成功后成功显示数据
- en: In this activity, you have seen what an authentication system would look like
    when using Vuex and `Axios`. While the backend was fake, the code used here could
    easily be connected to a real authentication system.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你看到了使用 Vuex 和 `Axios` 时认证系统会是什么样子。虽然后端是假的，但这里使用的代码可以很容易地连接到一个真实的认证系统。
- en: 11\. Working with Vuex – Organizing Larger Stores
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11. 使用 Vuex – 组织更大的存储
- en: 'Activity 11.01: Simplifying a Vuex Store'
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 11.01：简化 Vuex 存储
- en: '**Solution:**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: Perform the following steps to complete the activity.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成活动。
- en: Note
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the initial code file for this activity, visit [https://packt.live/3kaqBHH](https://packt.live/3kaqBHH).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此活动的初始代码文件，请访问 [https://packt.live/3kaqBHH](https://packt.live/3kaqBHH)。
- en: 'Begin by creating a new file, `src/store/state.js`, that will store the state
    values for everything but the `cat` object:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个新文件，`src/store/state.js`，它将存储除了 `cat` 对象之外的所有状态值：
- en: '[PRE102]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Make a new file, `src/store/getters.js`, and move the getter for `desiredPet`
    into it:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，`src/store/getters.js`，并将 `desiredPet` 的 getter 移入其中：
- en: '[PRE103]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Next, make `src/store/mutations.js` and copy over the `mutations` not related
    to the cat name:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建 `src/store/mutations.js` 并复制与猫名称无关的 `mutations`：
- en: '[PRE104]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Update the store (`src/store/index.js`) file to import the new files:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新存储文件 (`src/store/index.js`) 以导入新文件：
- en: '[PRE105]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Edit the existing `state`, `mutations`, and `getters` block to use the included values:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑现有的 `state`、`mutations` 和 `getters` 块以使用包含的值：
- en: '[PRE106]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now move the cat-related values into the `modules` block of the store. Create
    a `state`, `getters`, and `mutations` block and move all the values over, updating
    them to refer to the state values, not `state.cat`:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将猫相关值移动到存储的 `modules` 块中。创建一个 `state`、`getters` 和 `mutations` 块，并将所有值移动过来，更新它们以引用状态值，而不是
    `state.cat`：
- en: '[PRE107]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Run the application and confirm that the `App.vue` component continues to work
    as it did before.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并确认 `App.vue` 组件继续按预期工作。
- en: 'Your output will be as follows:'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的输出将如下所示：
- en: '![Figure 11.4: Final output of the activity'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 11.4：活动的最终输出'
- en: '](img/B15218_11_04.jpg)'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_11_04.jpg)'
- en: 'Figure 11.4: Final output of the activity'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：活动的最终输出
- en: You now have a Vuex store modified to be more approachable, easier to edit,
    and simpler to debug in the future. To access the solution for this activity,
    visit [https://packt.live/3l4Lg0x](https://packt.live/3l4Lg0x).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Vuex 存储已被修改得更加易于接近、编辑和未来调试。要访问此活动的解决方案，请访问 [https://packt.live/3l4Lg0x](https://packt.live/3l4Lg0x)。
- en: 12\. Unit Testing
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12. 单元测试
- en: 'Activity 12.01: Adding a Simple Search by Title Page with Tests'
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 12.01：添加带有测试的简单标题搜索页面
- en: '**Solution:**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'Perform the following steps to complete the activity:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成活动：
- en: Note
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the code files for this activity, refer to [https://packt.live/2UVF28c](https://packt.live/2UVF28c).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此活动的代码文件，请参阅 [https://packt.live/2UVF28c](https://packt.live/2UVF28c)。
- en: 'Create the search form with an input and a button in a new file in `src/components/SearchForm.vue`:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/components/SearchForm.vue` 的新文件中创建一个带有输入和按钮的搜索表单：
- en: '[PRE108]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We''ll now get the form to display by importing, registering, and rendering
    it in `src/App.vue`:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过导入、注册并在 `src/App.vue` 中渲染来使表单显示：
- en: '[PRE109]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'We''re now ready to add a snapshot test for the search form. In `__tests__/SearchForm.test.js`,
    we should add `SearchForm should match expected HTML`:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备好为搜索表单添加快照测试。在 `__tests__/SearchForm.test.js` 中，我们应该添加 `SearchForm should
    match expected HTML`：
- en: '[PRE110]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We want to track the contents of the search form input using `v-model` to two-way
    bind the `searchTerm` instance variable and the contents of the input:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望使用 `v-model` 跟踪搜索表单输入的内容，以双向绑定 `searchTerm` 实例变量和输入内容：
- en: '[PRE111]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: When the search form is submitted, we'll need to update the URL with the right
    parameter. This can be done with `this.$router.push()`. We will store the search
    in a `q` query parameter.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提交搜索表单时，我们需要使用 `this.$router.push()` 更新 URL 中的正确参数。这可以通过 `q` 查询参数存储搜索来完成。
- en: '[PRE112]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We will want to reflect the state of the `q` query parameter in the search
    form input. Read `q` from `this.$route.query` and set it as the initial value
    for the `searchTerm` data field in the `SearchForm` component state:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望将搜索表单中的 `q` 查询参数的状态反映在搜索表单输入中。从 `this.$route.query` 中读取 `q` 并将其设置为 `SearchForm`
    组件状态中 `searchTerm` 数据字段的初始值：
- en: '[PRE113]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Next, we''ll want to filter the posts passed to `PostList` on the home page.
    We''ll use `this.$route.query.q` in a computed property that filters posts by
    their title. This new computed property will then be used instead of `posts` in
    `src/App.vue`:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将想要过滤传递给主页上 `PostList` 的帖子。我们将使用 `this.$route.query.q` 在一个计算属性中过滤按标题排序的帖子。这个新的计算属性将随后用于替代
    `src/App.vue` 中的 `posts`：
- en: '[PRE114]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Next, we should add a test that changes the search query parameter and check
    that the app shows the right result. To do this, we can import `src/App.vue`,
    `src/store.js`, and `src/router.js`, and render the app with the store and the
    router. We can then update the search field contents by using the fact that the
    placeholder for the field is `Search`. Finally, we can submit the form by clicking
    the element where `test id` is `Search` (which is the `search` button):'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们应该添加一个测试，更改搜索查询参数并检查应用程序显示正确的结果。为此，我们可以导入 `src/App.vue`、`src/store.js`
    和 `src/router.js`，并使用存储和路由渲染应用程序。然后，我们可以通过使用字段的占位符为 `Search` 来更新搜索字段的内容。最后，我们可以通过点击具有
    `test id` 为 `Search` 的元素来提交表单（这是搜索按钮）：
- en: '[PRE115]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'We are now in a state where we have passing tests. The following screenshot
    shows this:'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在处于一个通过测试的状态。以下截图显示了这一点：
- en: '![Figure 12.29: Passing tests for routing'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 12.29：路由测试通过'
- en: '](img/B15218_12_29.jpg)'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_12_29.jpg)'
- en: 'Figure 12.29: Passing tests for routing'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.29：路由测试通过
- en: 'We have also got an application that is able to filter by search term, as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还得到了一个能够按搜索词过滤的应用程序，如下所示：
- en: '![Figure 12.30: Searching for "react" filters posts relevant to that search
    term'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.30：搜索“react”过滤与该搜索词相关的帖子]'
- en: '](img/B15218_12_30.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_12_30.jpg]'
- en: 'Figure 12.30: Searching for "react" filters posts relevant to that search term'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.30：搜索“react”过滤与该搜索词相关的帖子
- en: We've seen how to create and test a Vue.js application with multiple pages,
    Vuex, and a slew of components.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建和测试具有多个页面、Vuex和一系列组件的Vue.js应用程序。
- en: 13\. End-to-End Testing
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. 端到端测试
- en: 'Activity 13.01: Adding the Ability to Set a User''s Email and Tests'
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第13.01节：添加设置用户电子邮件和测试的功能
- en: '**Solution:**'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'Perform the following steps to complete the activity:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成活动：
- en: Note
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the code files for this activity, refer to [https://packt.live/2IZP4To](https://packt.live/2IZP4To).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此活动的代码文件，请参阅[https://packt.live/2IZP4To](https://packt.live/2IZP4To)。
- en: 'In order to keep track of the email, we''ll set it as a piece of reactive state
    in `data()` and add an email type input to the page, which will be two-way bound
    to `email` using `v-model`. We also add a label and the corresponding markup.
    Note that we''ll have a `data-test-id` attribute on the email input set to `"email-input"`:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了跟踪电子邮件，我们将在`data()`中将它设置为一个响应式状态，并在页面上添加一个电子邮件类型输入，它将使用`v-model`与`email`双向绑定。我们还添加了一个标签和相应的标记。请注意，我们将在电子邮件输入上设置一个`data-test-id`属性，设置为`"email-input"`：
- en: '[PRE116]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'We''ll now add a `beforeEach` hook to set up the Cypress mock server and stub
    out the `GET` comments (list) request. The comments list request should be aliased
    as `getComments`:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加一个`beforeEach`钩子来设置Cypress模拟服务器并模拟`GET`评论（列表）请求。评论列表请求应该被别名为`getComments`：
- en: '[PRE117]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'We''ll add our first test that checks whether typing into the email input works
    correctly. We''ll go to the app, type an email, and check that what we typed is
    now the input value:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加第一个测试，检查将文本输入到电子邮件输入框是否正确工作。我们将进入应用程序，输入电子邮件，并检查我们输入的内容现在是否是输入值：
- en: '[PRE118]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'When run using the Cypress UI, we get the following passing test:'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用Cypress UI运行时，我们得到以下通过测试：
- en: '![Figure 13.24: Cypress running "enter-email" tests, with the email input test'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图13.24：Cypress运行“enter-email”测试，带有电子邮件输入测试]'
- en: '](img/B15218_13_24.jpg)'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_13_24.jpg]'
- en: 'Figure 13.24: Cypress running "enter-email" tests, with the email input test'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.24：Cypress运行“enter-email”测试，带有电子邮件输入测试
- en: 'The `email` property existing is a pre-requisite to adding comments, so we''ll
    disable the `add new comment` button while `email` is empty (`!email`). We''ll
    bind to the `disabled` attribute and toggle some classes based on whether or not
    the `email` field is populated:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`email`属性的存在是添加评论的先决条件，因此当`email`为空时（`!email`），我们将禁用`添加新评论`按钮。我们将绑定到`disabled`属性并根据`email`字段是否填充切换一些类：'
- en: '[PRE119]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'With this new `disable add new comment button while email is empty` functionality,
    we should add a new E2E test. We''ll load up the page and on initial load, we''ll
    check that the `email` input is empty and that the `new comment` button is disabled.
    We''ll then type an email into the email input field and check that the `new comment`
    button is now *not* disabled, which means it is enabled:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个新的`当电子邮件为空时禁用添加新评论按钮`功能，我们应该添加一个新的端到端测试。我们将加载页面，并在初始加载时检查`email`输入框为空，并且`新评论`按钮被禁用。然后我们将在电子邮件输入框中输入电子邮件，并检查`新评论`按钮现在*不是*禁用的，这意味着它已被启用：
- en: '[PRE120]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The output from the test run after the updates is as follows:'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更新后的测试运行输出如下：
- en: '![Figure 13.25: Cypress running "enter-email" tests, with the disabled'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图13.25：Cypress运行“enter-email”测试，带有禁用的]'
- en: add comment button test
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加评论按钮测试
- en: '](img/B15218_13_25.jpg)'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_13_25.jpg]'
- en: 'Figure 13.25: Cypress running "enter-email" tests, with the disabled add comment
    button test'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.25：Cypress运行“enter-email”测试，带有禁用的添加评论按钮测试
- en: 'Now that we''ve got a way to capture the email, we should pass it to the backend
    API when making the POST comments call (that is, when submitting a new comment).
    In order to do this, we should modify the spot in `methods.submitNewComment` where
    `email` is hardcoded as `evan@vuejs.org`:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了捕获电子邮件的方法，我们应该在提交新评论的POST调用（即提交新评论时）将其传递给后端API。为了做到这一点，我们应该修改`methods.submitNewComment`中`email`被硬编码为`evan@vuejs.org`的位置：
- en: '[PRE121]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Now that we''re using the email that''s been input by the user, we should write
    an E2E test to check that it''s being sent. We''ll stub out the `POST` request,
    alias it to `newComment`, and send back an arbitrary value. We can then visit
    the page, fill out the email input, open the comment editor, fill that out, and
    submit it. We''ll then wait on the `newComment` request and assert on the request
    body that the body and email are as they were when we completed them:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们正在使用用户输入的电子邮件，我们应该编写一个端到端测试来检查它是否被发送。我们将模拟 `POST` 请求，将其别名为 `newComment`，并返回一个任意值。然后我们可以访问页面，填写电子邮件输入，打开评论编辑器，填写内容，并提交。然后我们将等待
    `newComment` 请求，并断言请求体中的内容和电子邮件与我们完成时相同：
- en: '[PRE122]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'When run using the Cypress UI, we get the following test run output:'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用 Cypress UI 运行时，我们得到以下测试运行输出：
- en: '![Figure 13.26: Cypress running "enter-email" tests, with the email input test'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.26：Cypress 运行 "enter-email" 测试，包含电子邮件输入测试'
- en: '](img/B15218_13_26.jpg)'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_13_26.jpg)'
- en: 'Figure 13.26: Cypress running "enter-email" tests, with the email input test'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.26：Cypress 运行 "enter-email" 测试，包含电子邮件输入测试
- en: We've now seen how to effectively build and test (with an E2E test) a Vue.js
    application with Cypress.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何有效地使用 Cypress 构建和测试（使用端到端测试）Vue.js 应用程序。
- en: 14\. Deploying Your Code to the Web
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. 将您的代码部署到网络
- en: 'Activity 14.01: Adding CI/CD with GitLab to a Book Search App and Deploying
    to Amazon S3 and CloudFront'
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 14.01：将 GitLab CI/CD 添加到图书搜索应用程序并部署到 Amazon S3 和 CloudFront
- en: '**Solution**'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Perform the following steps to complete the activity:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成活动：
- en: Note
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the code files for this activity, refer to [https://packt.live/36ZecBT](https://packt.live/36ZecBT).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此活动的代码文件，请参阅 [https://packt.live/36ZecBT](https://packt.live/36ZecBT)。
- en: To start, we'll want to run a production build locally. We can use the regular
    command used to build all Vue CLI projects for production. We'll also want to
    check that the relevant assets (JavaScript, CSS, and HTML) are generated correctly.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们希望在本地运行一个生产构建。我们可以使用用于构建所有 Vue CLI 项目的常规命令。我们还想检查相关的资产（JavaScript、CSS 和
    HTML）是否正确生成。
- en: 'The production build command is `npm run build`, as seen in the following screenshot:'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生产构建命令是 `npm run build`，如下截图所示：
- en: '![Figure 14.65: The npm run build output for the initial book-search Vue CLI
    project'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.65：初始 book-search Vue CLI 项目的 npm run build 输出'
- en: '](img/B15218_14_65.jpg)'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_65.jpg)'
- en: 'Figure 14.65: The npm run build output for the initial book-search Vue CLI
    project'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.65：初始 book-search Vue CLI 项目的 npm run build 输出
- en: 'The `npm run build` command builds a `dist` directory with contents as in the
    following screenshot. It contains `CSS`, `JavaScript`, and `HTML` assets, as well
    as `sourcemaps` (`.js.map` files) and `favicon`:'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`npm run build` 命令构建一个包含以下内容的 `dist` 目录，如下截图所示。它包含 `CSS`、`JavaScript` 和 `HTML`
    资产，以及 `sourcemaps`（`.js.map` 文件）和 `favicon`：'
- en: '![Figure 14.66: Sample contents of the dist folder (generated using the tree
    command)'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.66：使用 tree 命令生成的 dist 文件夹的示例内容'
- en: after a Vue CLI production build run
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Vue CLI 生产构建运行之后
- en: '](img/B15218_14_66.jpg)'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_66.jpg)'
- en: 'Figure 14.66: Sample contents of the dist folder (generated using the tree
    command) after a Vue CLI production build run'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.66：Vue CLI 生产构建运行后 dist 文件夹的示例内容（使用 tree 命令生成）
- en: 'In order to run GitLab CI/CD, we will need a `.gitlab-ci.yml` file. We will
    add a job to`.gitlab-ci.yml` in which we run an install of the packages followed
    by the production build in a Node.js LTS Docker container, at the `build` stage.
    We''ll also make sure to cache the output of the production build:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行 GitLab CI/CD，我们需要一个 `.gitlab-ci.yml` 文件。我们将在 `.gitlab-ci.yml` 中添加一个作业，在
    `build` 阶段运行 Node.js LTS Docker 容器中的包安装和生产构建。我们还将确保缓存生产构建的输出：
- en: '[PRE123]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Once we use `git add .gitlab-ci.yml` and commit and push the changes, we should
    see the following GitLab CI/CD pipeline run, which includes the `build` job in
    the running state:'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们使用 `git add .gitlab-ci.yml` 并提交和推送更改，我们应该看到以下 GitLab CI/CD 管道运行，其中包含运行状态下的
    `build` 作业：
- en: '![Figure 14.67: The GitLab CI/CD pipeline with the build job running'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.67：构建作业正在运行的 GitLab CI/CD 管道'
- en: '](img/B15218_14_67.jpg)'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_67.jpg)'
- en: 'Figure 14.67: The GitLab CI/CD pipeline with the build job running'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.67：正在运行的 GitLab CI/CD 管道，构建作业正在运行
- en: 'The following screenshot displays the GitLab CI/CD pipeline with the `build`
    job completed successfully:'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了 GitLab CI/CD 管道，`build` 作业已成功完成：
- en: '![Figure 14.68: The GitLab CI/CD pipeline with the build job passed'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.68：构建作业通过后的 GitLab CI/CD 管道'
- en: '](img/B15218_14_68.jpg)'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_68.jpg)'
- en: 'Figure 14.68: The GitLab CI/CD pipeline with the build job passed'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.68：GitLab CI/CD 管道，构建任务已通过
- en: 'Next, we will want to add a code quality job to the `test` stage on GitLab
    CI/CD (by updating `.gitlab-ci.yml`). We''ll call the job `lint` and it will run
    an install of the dependencies as well as linting through the Vue CLI:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望在 GitLab CI/CD 的 `test` 阶段添加一个代码质量任务（通过更新 `.gitlab-ci.yml`）。我们将该任务命名为
    `lint`，它将运行依赖项的安装以及通过 Vue CLI 进行代码检查：
- en: '[PRE124]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Once we use `git add .gitlab-ci.yml` and commit and push the changes, we should
    see the following GitLab CI/CD pipeline run, which includes the `lint` job in
    the running state:'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们使用 `git add .gitlab-ci.yml` 并提交和推送更改，我们应该看到以下 GitLab CI/CD 管道运行，其中包含运行状态下的
    `lint` 任务：
- en: '![Figure 14.69: The GitLab CI/CD pipeline with the lint job running'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.69：GitLab CI/CD 管道，lint 任务正在运行'
- en: '](img/B15218_14_69.jpg)'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_69.jpg)'
- en: 'Figure 14.69: The GitLab CI/CD pipeline with the lint job running'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.69：GitLab CI/CD 管道，lint 任务正在运行
- en: 'The following screenshot displays the GitLab CI/CD pipeline with the `lint`
    job completed successfully:'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了 GitLab CI/CD 管道，`lint` 任务成功完成：
- en: '![Figure 14.70: The GitLab CI/CD pipeline with the lint job passed'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.70：GitLab CI/CD 管道，lint 任务已通过'
- en: '](img/B15218_14_70.jpg)'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_70.jpg)'
- en: 'Figure 14.70: The GitLab CI/CD pipeline with the lint job passed'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.70：GitLab CI/CD 管道，lint 任务已通过
- en: In order to deploy our application, we'll need to create a `vue-workshop-book-search`
    S3 bucket with public access enabled using the S3 console.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了部署我们的应用程序，我们需要使用 S3 控制台创建一个启用公共访问的 `vue-workshop-book-search` S3 存储桶。
- en: 'The S3 bucket creation page should look as shown in the following screenshots:'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: S3 存储桶创建页面应如图下截图所示：
- en: '![Figure 14.71: The S3 bucket creation page with vue-workshop-book-search'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.71：S3 存储桶创建页面，输入 `vue-workshop-book-search`'
- en: entered as the bucket name
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入作为存储桶名称
- en: '](img/B15218_14_71.jpg)'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_71.jpg)'
- en: 'Figure 14.71: The S3 bucket creation page with vue-workshop-book-search entered
    as the bucket name'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.71：S3 存储桶创建页面，输入 `vue-workshop-book-search` 作为存储桶名称
- en: '*Figure 14.72* displays the S3 bucket creation page with the public access
    and disclaimer information:'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 14.72* 显示了 S3 存储桶创建页面，具有公共访问权限和免责声明信息：'
- en: '![Figure 14.72: The S3 bucket creation page with public access enabled'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.72：S3 存储桶创建页面，启用公共访问'
- en: and the relevant disclaimer accepted
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并接受相关免责声明
- en: '](img/B15218_14_72.jpg)'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_72.jpg)'
- en: 'Figure 14.72: The S3 bucket creation page with public access enabled and the
    relevant disclaimer accepted'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.72：S3 存储桶创建页面，启用公共访问并接受相关免责声明
- en: To access the S3 bucket contents over the web, we'll also need to configure
    it for web hosting. We can configure the web hosting property through the S3 console.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要通过网页访问 S3 存储桶内容，我们还需要将其配置为 Web 服务器。我们可以通过 S3 控制台配置 Web 服务器属性。
- en: 'It should be configured as follows, with the index and error page set to `index.html`:'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应按以下方式配置，将索引和错误页面设置为 `index.html`：
- en: '![Figure 14.73: The S3 bucket properties page with web hosting enabled and
    configured with the index and error page set to index.html'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.73：S3 存储桶属性页面，已启用 Web 服务器并配置了索引和错误页面为 index.html'
- en: '](img/B15218_14_73.jpg)'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_73.jpg)'
- en: 'Figure 14.73: The S3 bucket properties page with web hosting enabled and configured
    with the index and error page set to index.html'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.73：S3 存储桶属性页面，已启用 Web 服务器并配置了索引和错误页面为 index.html
- en: 'For GitLab CI/CD to be able to create and update files on S3, we''ll need to
    add the relevant AWS secrets to our GitLab repo CI/CD settings. The secrets are
    found in the AWS management console at the `Username` dropdown | `My Security
    Credentials` | `Access keys` (access key ID and secret access key) | `Create New
    Access Key` (or pick a key to reuse). The following screenshot displays the `CI/CD
    Settings` page:![Figure 14.74: The GitLab CI/CD Settings page with the Variables
    section open'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让 GitLab CI/CD 能够在 S3 上创建和更新文件，我们需要将相关的 AWS 密钥添加到我们的 GitLab 仓库 CI/CD 设置中。这些密钥可以在
    AWS 管理控制台的 `用户名` 下拉菜单 | `我的安全凭证` | `访问密钥`（访问密钥 ID 和秘密访问密钥）| `创建新访问密钥`（或选择一个密钥进行重用）。以下截图显示了
    `CI/CD 设置` 页面：![图 14.74：GitLab CI/CD 设置页面，变量部分已打开
- en: '](img/B15218_14_74.jpg)'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_74.jpg)'
- en: 'Figure 14.74: The GitLab CI/CD Settings page with the Variables section open'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.74：GitLab CI/CD 设置页面，变量部分已打开
- en: 'Once the `Expand` button is clicked for the `Variables` section, we add the
    relevant AWS environment variables: `AWS_ACCESS_KEY_ID`, `AWS_DEFAULT_REGION`,
    and `AWS_SECRET_ACCESS_KEY`. The `Variables` section will then look as follows:'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦点击`变量`部分的`展开`按钮，我们添加相关的AWS环境变量：`AWS_ACCESS_KEY_ID`、`AWS_DEFAULT_REGION`和`AWS_SECRET_ACCESS_KEY`。然后`变量`部分将如下所示：
- en: '![Figure 14.75: The GitLab CI/CD Settings page with the required AWS environment'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图14.75：带有所需AWS环境变量的GitLab CI/CD设置页面'
- en: variables added (with values masked)
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加了变量（值被屏蔽）
- en: '](img/B15218_14_75.jpg)'
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_75.jpg)'
- en: 'Figure 14.75: The GitLab CI/CD Settings page with the required AWS environment
    variables added (with values masked)'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.75：带有所需AWS环境变量（值被屏蔽）的GitLab CI/CD设置页面
- en: 'Next, we will want to add a `deploy` job to the `deploy` stage on GitLab CI/CD
    (by updating `.gitlab-ci.yml`). We will call the job `deploy`; it will need to
    download the `awscli` `pip` package (Python package manager), which means the
    Docker image that makes the most sense is `python:latest`. The `deploy` job will
    load the built production build from cache, install `awscli` with `pip`, and run
    `aws s3 sync <build_directory> s3://<s3-bucket-name> --acl=public-read`:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望在GitLab CI/CD的`deploy`阶段添加一个`deploy`作业（通过更新`.gitlab-ci.yml`）。我们将作业命名为`deploy`；它需要下载`awscli`
    `pip`包（Python包管理器），这意味着最有意义的Docker镜像就是`python:latest`。`deploy`作业将从缓存中加载构建的生产版本，使用`pip`安装`awscli`，并运行`aws
    s3 sync <build_directory> s3://<s3-bucket-name> --acl=public-read`：
- en: '[PRE125]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Once we use `git add .gitlab-ci.yml` and commit and push the changes, we should
    see the following GitLab CI/CD pipeline run, which includes the `deploy` job in
    the running state:'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们使用`git add .gitlab-ci.yml`提交并推送更改，我们应该看到以下GitLab CI/CD管道运行，其中包含运行状态下的`deploy`作业：
- en: '![Figure 14.76: The GitLab CI/CD pipeline with the deploy job running'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图14.76：正在运行的GitLab CI/CD管道中的deploy作业'
- en: '](img/B15218_14_76.jpg)'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_76.jpg)'
- en: 'Figure 14.76: The GitLab CI/CD pipeline with the deploy job running'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.76：正在运行的GitLab CI/CD管道中的deploy作业
- en: '*Figure 14.77* displays the GitLab CI/CD pipeline with the `deploy` job completed successfully:'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图14.77*显示了成功完成的`deploy`作业的GitLab CI/CD管道：'
- en: '![Figure 14.77: The GitLab CI/CD pipeline with the deploy job passed'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图14.77：通过通过的`deploy`作业的GitLab CI/CD管道'
- en: '](img/B15218_14_77.jpg)'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_77.jpg)'
- en: 'Figure 14.77: The GitLab CI/CD pipeline with the deploy job passed'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.77：通过通过的`deploy`作业的GitLab CI/CD管道
- en: 'Once the pipeline completes, our application should be available through the
    S3 web endpoint, as in the following screenshot:'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦管道完成，我们的应用程序应该可以通过S3网络端点访问，如下面的截图所示：
- en: '![Figure 14.78: Book search accessed through the S3 web endpoint URL'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图14.78：通过S3网络端点URL访问的图书搜索'
- en: '](img/B15218_14_78.jpg)'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_78.jpg)'
- en: 'Figure 14.78: Book search accessed through the S3 web endpoint URL'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.78：通过S3网络端点URL访问的图书搜索
- en: 'Finally, we''ll create a CloudFront distribution that acts as a CDN for the
    S3 web endpoint. We''ll want to set `origin` to the origin of our S3 bucket''s
    web endpoint and also make sure that we''ve enabled `Redirect HTTP to HTTPS`:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个充当S3网络端点CDN的CloudFront分发。我们希望将`origin`设置为S3存储桶网络端点的源，并确保我们已启用`将HTTP重定向到HTTPS`：
- en: '![Figure 14.79: The CloudFront Distribution creation page with the origin'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图14.79：带有源域名的CloudFront分发创建页面'
- en: domain set to the S3 bucket
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 域设置为S3存储桶
- en: '](img/B15218_14_79.jpg)'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_14_79.jpg)'
- en: 'Figure 14.79: The CloudFront Distribution creation page with the origin domain
    set to the S3 bucket'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.79：将源域名设置为S3存储桶的CloudFront分发创建页面
- en: 'Once the CloudFront distribution is deployed, our application should be accessible
    through the CloudFront distribution''s domain, as shown in the following screenshot:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦CloudFront分发部署完成，我们的应用程序应该可以通过CloudFront分发的域名访问，如下面的截图所示：
- en: '![Figure 14.80: Book search accessed through the CloudFront domain,'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.80：通过CloudFront域名访问的图书搜索，'
- en: displaying results for a harry potter query
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 显示harry potter查询的结果
- en: '](img/B15218_14_80.jpg)'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_80.jpg)'
- en: 'Figure 14.80: Book search accessed through the CloudFront domain, displaying
    results for a harry potter query'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.80：通过CloudFront域名访问的图书搜索，显示harry potter查询的结果
- en: With that, we've used GitLab CI/CD to add CI/CD to an existing Vue CLI project.
    We then deployed it to S3 using CloudFront as our CDN.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用GitLab CI/CD，我们已将CI/CD添加到现有的Vue CLI项目中。然后我们使用CloudFront作为我们的CDN将其部署到S3。
