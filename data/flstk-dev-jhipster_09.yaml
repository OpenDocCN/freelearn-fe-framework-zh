- en: Building Microservices with JHipster
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JHipster构建微服务
- en: Now, it's time to build a full-fledged microservices stack. So far, we have
    generated, developed, and deployed a monolithic application using JHipster, and
    in the previous chapter, we saw the benefits offered by a microservice stack.
    In this chapter, we will look at how to build microservices with JHipster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候构建一个完整的微服务堆栈了。到目前为止，我们已经使用JHipster生成了、开发了和部署了一个单体应用程序，在前一章中，我们看到了微服务堆栈提供的优势。在这一章中，我们将探讨如何使用JHipster构建微服务。
- en: We will start by converting our monolithic store application into a microservice
    gateway application. Next, we will add a new functionality to our e-commerce shop
    as a separate microservice application. We will then see how these applications
    communicate with each other and work as a single application for our end users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将我们的单体商店应用程序转换为微服务网关应用程序。接下来，我们将作为独立的微服务应用程序向我们的电子商务商店添加新的功能。然后我们将看到这些应用程序如何相互通信，并作为一个单一的应用程序为我们的最终用户提供服务。
- en: 'In this chapter, we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将：
- en: 'Generate a Gateway application:'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成网关应用程序：
- en: Run through the generated code
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查生成的代码
- en: See a brief introduction to JWT
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要介绍JWT
- en: 'Generate a microservice application:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成微服务应用程序：
- en: Invoice service
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发票服务
- en: Notification service
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知服务
- en: Application architecture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序架构
- en: We built an online e-commerce shop using JHipster in [Chapter 3](3c863445-9d8d-4cd3-b14e-5331593913e3.xhtml),
    *Building Monolithic Web Applications* with JHipster. It was built as a monolith
    since the scope was small and it was an easier choice to start with. Let's say
    that our e-commerce store has grown tremendously in terms of users and scope,
    resulting in a more demanding situation. The team is finding it difficult to roll
    out features faster with the monolithic architecture, and would like to have more
    control over individual parts of the application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第3章中使用了JHipster构建了一个在线电子商务商店，标题为*使用JHipster构建单体Web应用程序*。[第3章](3c863445-9d8d-4cd3-b14e-5331593913e3.xhtml)。由于范围较小，这是一个更容易的选择。假设我们的电子商务商店在用户和范围方面增长巨大，导致了一种更加苛刻的情况。团队发现很难以单体架构快速推出功能，并希望对应用程序的各个部分有更多的控制。
- en: One of the solutions to this problem would be to adopt a microservice architecture.
    The application was created using JHipster; the option to move to microservices
    is much easier to accomplish. JHipster follows the **proxy microservice pattern**
    in which there is an aggregator/proxy in front of the services, which acts as
    the gateway for the end users. In much simpler terms, JHipster creates a gateway
    (which handles all the user requests) and the individual services that talk via
    the gateway to the users.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是采用微服务架构。该应用程序是使用JHipster创建的；迁移到微服务的选项更容易实现。JHipster遵循**代理微服务模式**，其中在服务前面有一个聚合器/代理，它作为最终用户的网关。用更简单的话说，JHipster创建了一个网关（处理所有用户请求）和通过网关与用户通信的各个服务。
- en: This said, we need to have a gateway service, along with one or a few microservice
    applications that can run alone.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们需要有一个网关服务，以及一个或几个可以独立运行的微服务应用程序。
- en: Our customers are facing some issues regarding invoicing, since it is taking
    longer for the system to respond. Customers are also complaining that they are
    not receiving notifications so they can track their orders. To solve this, we
    will remove the invoice service from our monolithic application and make it a
    separate service, and then create a separate **Notification Service** that will
    take care of the notifications. For the former, we will stick with the same SQL
    database. For the latter, we will use the NoSQL database.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户在发票方面遇到了一些问题，因为系统响应时间变长了。客户还抱怨他们没有收到通知，无法跟踪他们的订单。为了解决这个问题，我们将从我们的单体应用程序中移除发票服务，并使其成为一个独立的服务，然后创建一个独立的**通知服务**来处理通知。对于前者，我们将继续使用相同的SQL数据库。对于后者，我们将使用NoSQL数据库。
- en: 'Let''s have a look at the application architecture that we are going to generate:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们将要生成的应用程序架构：
- en: '![](img/6a4c466f-edc1-453a-9658-6cc03e7fe770.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a4c466f-edc1-453a-9658-6cc03e7fe770.png)'
- en: Gateway application generation
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网关应用程序生成
- en: We will start by converting the monolithic application that we have generated
    into a microservice gateway application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将我们生成的单体应用程序转换为微服务网关应用程序。
- en: Even though microservices are made up of different services inside, for end
    users it should be a single, unified product. There are a lot of services that
    are designed to work in a lot of different ways, but there should be a single
    entry point for users. Thus, we need a gateway application, since they form the
    frontend of your application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管微服务由内部的不同服务组成，但对于最终用户来说，它应该是一个单一、统一的产品。有许多服务被设计成以多种不同的方式工作，但应该有一个单一的入口点供用户使用。因此，我们需要一个网关应用程序，因为它们构成了应用程序的前端。
- en: Segregate the internal contracts and services from external users. We may have
    application-level internal services that we shouldn't expose to external users,
    so these can be masked away. This also adds another level of security to the application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将内部合约和服务与外部用户分离。我们可能有一些应用级别的内部服务，我们不应该将其暴露给外部用户，因此这些可以被隐藏起来。这也为应用程序增加了另一个安全层。
- en: Easier to mock services for testing help validate the services independently
    in integration testing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 更容易模拟服务进行测试，有助于在集成测试中独立验证服务。
- en: Converting a monolithic application to a microservice gateway
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将单体应用转换为微服务网关
- en: We already have our monolithic application generated, as well as our entities.
    As a part of monolithic application generation, we have already selected some
    options via JHipster CLI. We will stick to the same options (the database, authentication
    type, package name, i18n, and so on) when we generate the microservice gateway
    application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经生成了我们的单体应用程序以及我们的实体。作为单体应用程序生成的一部分，我们已经通过JHipster CLI选择了一些选项。当我们生成微服务网关应用程序时，我们将坚持相同的选项（数据库、认证类型、包名、i18n等）。
- en: 'Note: We will see how the customizations that we applied in the monolithic
    app can be applied to the gateway later.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们将在稍后看到如何在单体应用中应用我们应用的定制化。
- en: It's coding time now, so let's start building a gateway application using JHipster
    CLI.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是编码时间了，让我们使用JHipster CLI开始构建网关应用程序。
- en: The first step here is to convert the monolithic app into a microservice gateway
    application with almost the same configuration that we used when we created a
    monolithic application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一步是将单体应用转换为具有几乎相同配置的微服务网关应用，就像我们创建单体应用时使用的配置一样。
- en: 'Let''s move to the Terminal (Command Prompt, if you are using Windows) now,
    and start by navigating to the folder where we created the monolithic application.
    Once you''re in the folder, create a new Git branch so that we can do a clean
    merge back to master once we are done:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到终端（如果使用Windows，则为命令提示符），首先导航到我们创建单体应用的文件夹。一旦进入文件夹，创建一个新的Git分支，这样我们就可以在完成后干净地合并回master分支：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, open the `.yo-rc.json` file in your favorite text editor or IDE and change
    the following value:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开您最喜欢的文本编辑器或IDE中的`.yo-rc.json`文件，并更改以下值：
- en: '![](img/c58dc656-48af-47ab-8020-75c30440f768.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c58dc656-48af-47ab-8020-75c30440f768.png)'
- en: In order to make the monolith into a microservice gateway application, we can
    just change the preceding values in the `.yo-rc.json` file. We have added the
    service discovery type to Eureka since for monolithic applications, it is not
    mandatory to have service discovery.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将单体应用转换为微服务网关应用，我们只需更改`.yo-rc.json`文件中的前述值。由于对于单体应用来说，服务发现不是强制性的，我们已经将服务发现类型添加到Eureka中。
- en: Also, obviously, the next change is to change the application type from monolith
    to gateway.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，下一个更改是将应用程序类型从单体更改为网关。
- en: Application generation
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序生成
- en: 'Now, let''s run the `jhipster` command to generate the application:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行`jhipster`命令来生成应用程序：
- en: '![](img/e157b3a8-ae89-494b-bae6-9ab95f4d9f7a.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e157b3a8-ae89-494b-bae6-9ab95f4d9f7a.png)'
- en: JHipster then asks whether you want to overwrite the conflicting files or use
    your existing ones, as well as a few other options. Users can use any one of the
    desired options.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster会询问您是否想要覆盖冲突的文件或使用您现有的文件，以及一些其他选项。用户可以使用任何想要的选项。
- en: Right now, we will choose option `a`. It will overwrite all of the other files,
    including the highlighted file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将选择选项`a`。它将覆盖所有其他文件，包括高亮显示的文件。
- en: This prompt is extremely useful if you have a lot of custom code written on
    your application. You can choose the appropriate option to get the desired result.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在应用程序上编写了大量自定义代码，此提示将非常有用。您可以选择适当的选项以获得所需的结果。
- en: '![](img/7a386280-9640-4fd0-84c8-8487b2d4bb17.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a386280-9640-4fd0-84c8-8487b2d4bb17.png)'
- en: This will overwrite all the customizations we did in our monolithic application.
    We can easily bring them back into this branch by cherry picking the required
    changes from our master branch using GIT. You can follow a similar approach to
    the one we saw in [Chapter 5](63e6ed92-1616-40b7-86b8-1b3332fcbfb7.xhtml), *Customization
    and Further Development*, for that. Once all changes are applied, we can merge
    this branch back into the master. You will have to do the same for entity files
    as well in [Chapter 10](28229d3b-052f-436e-9dc9-322727b9be4a.xhtml), *Working
    with Microservices*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将覆盖我们在单体应用程序中做的所有自定义设置。我们可以通过使用 GIT 从我们的 master 分支中 cherry pick 所需的更改，轻松地将它们带回这个分支。你可以遵循我们在第
    5 章 [Customization and Further Development](63e6ed92-1616-40b7-86b8-1b3332fcbfb7.xhtml)
    中看到的类似方法。一旦所有更改都应用了，我们就可以将这个分支合并回 master。你还需要在 [第 10 章](28229d3b-052f-436e-9dc9-322727b9be4a.xhtml)
    *Working with Microservices* 中对实体文件做同样的操作。
- en: Generating a new Gateway
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成新的网关
- en: If you do not want to convert the existing monolith and want to start fresh,
    then follow these steps.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想转换现有的单体应用程序并希望从头开始，请遵循以下步骤。
- en: In the Terminal, navigate to the `e-commerce-app` folder and create a new folder
    called `app-gateway`,  change the directory to `app-gateway`, and run the `jhipster` command.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，导航到 `e-commerce-app` 文件夹，创建一个名为 `app-gateway` 的新文件夹，然后切换到 `app-gateway`
    目录，并运行 `jhipster` 命令。
- en: 'So, obviously, the first question is, Which *type* of application would we
    like to create? We will select the Microservice gateway (third option) and then
    click *Enter*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，显然，第一个问题是，我们想创建哪种 *类型* 的应用程序？我们将选择微服务网关（第三个选项），然后按 *Enter*：
- en: '![](img/bfa5cc5a-e486-4c5d-b189-0ce4693d240c.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bfa5cc5a-e486-4c5d-b189-0ce4693d240c.png)'
- en: 'Then, we will enter the base name of our application. We will use the name
    `store`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将输入我们应用程序的基本名称。我们将使用名称 `store`：
- en: '![](img/1ffbf974-3a76-47c8-b4b4-a9bb4122d43b.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ffbf974-3a76-47c8-b4b4-a9bb4122d43b.png)'
- en: 'Since we are working with microservices, there is a high risk of having port
    conflicts. In order to avoid them, JHipster will ask you to select a port for
    each microservice application (both gateway and application). By default, we will
    have `8080` as the port, but we can change the port as necessary. For now, we
    will use the default port since the gateway will run on `8080`, similar to what
    our monolithic application had:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用微服务，存在很高的端口冲突风险。为了避免这些冲突，JHipster 将要求你为每个微服务应用程序（包括网关和应用程序）选择一个端口。默认情况下，我们将使用
    `8080` 作为端口，但我们可以根据需要更改端口。现在，我们将使用默认端口，因为网关将在 `8080` 上运行，类似于我们的单体应用程序：
- en: '![](img/7d85a3d1-a89a-4e9b-8f5f-ced6207d3cc6.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d85a3d1-a89a-4e9b-8f5f-ced6207d3cc6.png)'
- en: 'Then, we enter the package name for our application. We will use the default
    name that is available, which is `com.mycompany.store`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们输入我们应用程序的包名。我们将使用可用的默认名称，即 `com.mycompany.store`：
- en: '![](img/d47aabf3-4b7b-48b1-bed7-e98a36b075b1.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d47aabf3-4b7b-48b1-bed7-e98a36b075b1.png)'
- en: For the next question, JHipster will ask you to configure the registry service.
    We will select the necessary registry service to configure, monitor, and scale
    our microservices and gateway application. We can either choose to use the JHipster
    registry or Consul. This is also optional; we don't need to choose any registry
    service here. We can then select No service discovery.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个问题，JHipster 将要求你配置注册服务。我们将选择要配置、监控和扩展我们的微服务和网关应用程序所需的注册服务。我们可以选择使用 JHipster
    注册或 Consul。这也是可选的；我们在这里不需要选择任何注册服务。然后我们可以选择无服务发现。
- en: When you select No service discovery, the microservice URLs are hardcoded in
    the property files.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择无服务发现时，微服务 URL 将硬编码在属性文件中。
- en: '![](img/804d5adf-7774-4922-bdcf-2509505072f5.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/804d5adf-7774-4922-bdcf-2509505072f5.png)'
- en: For the next question, JHipster will ask you to select the authentication type.
    JHipster provides three options for the authentication type, which are JWT, OAuth2,
    and UAA server-based. JWT is stateless, while the UAA runs on a different server
    (and application altogether). OAuth2, on the other hand, will provide authorization
    tokens, while the authorization is done on the third-party system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个问题，JHipster 将要求你选择认证类型。JHipster 提供了三种认证类型的选项，分别是 JWT、OAuth2 和基于 UAA 服务器的。JWT
    是无状态的，而 UAA 在不同的服务器（和应用程序）上运行。另一方面，OAuth2 将提供授权令牌，而授权是在第三方系统上完成的。
- en: JHipster does provide an option to create a UAA server application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 提供了一个创建 UAA 服务器应用程序的选项。
- en: We will look at JWT in more detail shortly. For now, we will select JWT authentication.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后更详细地了解 JWT。现在，我们将选择 JWT 认证。
- en: '![](img/443b3149-1253-4a02-aa27-54bb51cbb2b2.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/443b3149-1253-4a02-aa27-54bb51cbb2b2.png)'
- en: 'We will select the database type next. We have an option to select either SQL
    and NoSQL. In terms of NoSQL, we can choose MongoDB or Cassandra. We will select
    the SQL database:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择数据库类型。我们有选项选择SQL和NoSQL。在NoSQL方面，我们可以选择MongoDB或Cassandra。我们将选择SQL数据库：
- en: '![](img/84c34984-58bb-4d75-a980-1dda176da298.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/84c34984-58bb-4d75-a980-1dda176da298.png)'
- en: Then, we will select the database that we will be using for production and development.
    JHipster provides an option to use a different database for your production and
    development environment. This really helps to kick-start application development
    faster and easier.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择我们将用于生产和开发的数据库。JHipster提供了一个选项，可以在生产和开发环境中使用不同的数据库。这确实有助于更快、更轻松地启动应用程序开发。
- en: 'We will select a MySQL database for production:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择MySQL数据库用于生产：
- en: '![](img/aeb5da7b-b329-4619-aac0-b210a80dcff4.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aeb5da7b-b329-4619-aac0-b210a80dcff4.png)'
- en: 'Then, we will select H2 with disk-based persistence for development:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择基于磁盘持久性的H2用于开发：
- en: '![](img/e7d52a14-8a6e-4e02-9308-16911416e47d.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7d52a14-8a6e-4e02-9308-16911416e47d.png)'
- en: 'Following the databases, we will select yes for the second level hibernate
    cache:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择数据库之后，我们将为第二级Hibernate缓存选择“是”：
- en: '![](img/2b6f1490-0960-4328-ba4d-38618a10e329.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b6f1490-0960-4328-ba4d-38618a10e329.png)'
- en: 'Then, we will select Gradle for building the backend. We have an option to
    select Gradle for the backend development:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择Gradle用于构建后端。我们有选项选择Gradle用于后端开发：
- en: '![](img/a48dce56-58d2-4880-b47e-8d93dc072e52.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a48dce56-58d2-4880-b47e-8d93dc072e52.png)'
- en: 'Then, we can select any other additional technologies that we need to use.
    JHipster provides an option to select Elasticsearch, using Hazelcast for clustered
    applications, WebSockets, and Swagger Codegen for API-based development and Kafka-based
    asynchronous messaging. We will select WebSockets here, similar to what we used
    in our monolithic store:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以选择我们需要的任何其他附加技术。JHipster提供了一个选项来选择Elasticsearch、使用Hazelcast进行集群应用程序、WebSocket和Swagger
    Codegen用于基于API的开发以及基于Kafka的异步消息传递。我们将在此选择WebSocket，类似于我们在单体存储中使用的：
- en: '![](img/d69c4e3c-e728-47eb-a145-37edc6a2c490.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d69c4e3c-e728-47eb-a145-37edc6a2c490.png)'
- en: 'Since our gateway application needs a user interface, for the next question
    we can choose the framework that we need to use for the client. We will select
    `Angular 5` for this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的网关应用程序需要一个用户界面，对于下一个问题，我们可以选择我们需要的客户端框架。我们将选择`Angular 5`：
- en: '![](img/419cca66-7b4e-449d-9c6b-76a92e9b7be8.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/419cca66-7b4e-449d-9c6b-76a92e9b7be8.png)'
- en: 'Then, we will select whether we need to use a SASS-based preprocessor for the
    CSS. We will use SASS here, so we will select y:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择是否需要使用基于SASS的预处理器用于CSS。我们将在此使用SASS，因此我们将选择y：
- en: '![](img/352fdcac-4156-4c4c-a5ae-71e47f12cd1d.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/352fdcac-4156-4c4c-a5ae-71e47f12cd1d.png)'
- en: 'Then, we will select whether we need to enable internationalization support.
    We will select yes for this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择是否需要启用国际化支持。我们将为此选择“是”：
- en: '![](img/0fc1836a-ec40-47ce-a0fd-bd32b0218efc.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0fc1836a-ec40-47ce-a0fd-bd32b0218efc.png)'
- en: 'Then, we will choose English as our native language:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择英语作为我们的母语：
- en: '![](img/c5173b16-8f5f-4751-a6e1-6eee2d2e5b3a.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5173b16-8f5f-4751-a6e1-6eee2d2e5b3a.png)'
- en: 'Then, choose any other additional languages:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择任何其他附加语言：
- en: '![](img/166821e5-0441-48ac-99fa-6571be79b2f2.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/166821e5-0441-48ac-99fa-6571be79b2f2.png)'
- en: 'Then, select any other testing frameworks, such as Gatling, Cucumber, and/or
    Protractor, since this is required. We will select Protractor as the testing tool:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择任何其他测试框架，例如Gatling、Cucumber和/或Protractor，因为这是必需的。我们将选择Protractor作为测试工具：
- en: '![](img/9732311a-69d6-4d73-961d-51b0660747fc.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9732311a-69d6-4d73-961d-51b0660747fc.png)'
- en: 'Finally, JHipster asks us to install any other generators from the marketplace;
    we will select no here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，JHipster要求我们安装来自市场的任何其他生成器；我们将在此选择“否”：
- en: '![](img/d93c0cd7-4a57-4c2b-b0a4-69e9472ef74e.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d93c0cd7-4a57-4c2b-b0a4-69e9472ef74e.png)'
- en: 'This will create all the necessary files and install the frontend dependencies
    using Yarn:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建所有必要的文件并使用Yarn安装前端依赖项：
- en: '![](img/6135ec47-8d4a-4998-b5d6-4ae12bb2c9b0.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6135ec47-8d4a-4998-b5d6-4ae12bb2c9b0.png)'
- en: 'Now, our gateway application is generated. JHipster will automatically commit
    the generated files to Git; if you wish to do this step yourself, you can do so
    by passing the `skip-git` flag during execution, for example, `jhipster --skip-git`,
    and executing the steps manually as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的网关应用程序已生成。JHipster 将自动将生成的文件提交到 Git；如果您希望手动执行此步骤，可以在执行期间传递 `skip-git`
    标志，例如，`jhipster --skip-git`，然后手动执行以下步骤：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Gateway configuration
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网关配置
- en: 'The gateway application is generated in a similar fashion to the monolithic
    application, except for configurations related to Zuul proxy, Eureka Client, and
    Hystrix:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 网关应用程序的生成方式与单体应用程序类似，但涉及 Zuul 代理、Eureka 客户端和 Hystrix 的配置：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have selected the JHipster registry for our registry service. This will
    be a standalone registry server which other microservice applications and gateways
    will register itself:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的注册表服务选择了 JHipster 注册表。这将是一个独立的注册服务器，其他微服务应用程序和网关将自动注册自己：
- en: '`@EnableDiscoveryClient` is added to Spring Boot''s main class, which will
    enable the Netflix Discovery Client. The microservice applications and gateways need
    to register themselves to the registry service. It uses Spring Cloud''s discovery
    client abstraction to interrogate its own host and port, and then adds them to
    the registry server.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableDiscoveryClient` 添加到 Spring Boot 的主类中，这将启用 Netflix Discovery 客户端。微服务应用程序和网关需要将自己注册到注册表服务。它使用
    Spring Cloud 的发现客户端抽象来查询其自己的主机和端口，然后将它们添加到注册服务器。'
- en: Zuul, on the other hand, is the gatekeeper. This helps route the authorized
    requests to the respective endpoints, limits the requests per route, and relays
    the necessary tokens to the microservice application.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，Zuul 是门卫。这有助于将授权请求路由到相应的端点，限制每个路由的请求，并将必要的令牌中继到微服务应用程序。
- en: '`@EnableZuulProxy` helps the microservice gateway application route the requests
    to the applicable microservice application based on the configurations provided
    in the `application.yml`:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableZuulProxy` 帮助微服务网关应用程序根据 `application.yml` 中提供的配置将请求路由到相应的微服务应用程序：'
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the gateway app, we have specified the aforementioned settings  for Zuul
    configuration. The maximum number of total connections that a proxy can hold open
    is kept at `1000`. The maximum number of route connections that a proxy can hold
    open is kept at `100`. Semaphore is kept to a maximum of `500`. (Semaphore is
    like a counter that is used for synchronization between threads and processes.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在网关应用程序中，我们已经指定了上述 Zuul 配置设置。一个代理可以保持打开的最大总连接数保持在 `1000`。一个代理可以保持打开的最大路由连接数保持在
    `100`。信号量保持在最大 `500`。 （信号量类似于一个用于线程和进程之间同步的计数器。）
- en: 'Access to the backend microservice endpoint is controlled by `AccessControlFilter`,
    which will check whether the request is authorized, and is allowed to request
    the endpoint:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 后端微服务端点的访问由 `AccessControlFilter` 控制，该过滤器将检查请求是否已授权，并允许请求端点：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Zuul, as a gatekeeper, also acts as a rate limiter. A rate-limiting filter
    is added to the generated application, which limits the number of HTTP calls that
    are made per client. This is enabled conditionally with:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Zuul 作为门卫，还充当速率限制器。在生成的应用程序中添加了一个速率限制过滤器，该过滤器限制了每个客户端发出的 HTTP 调用次数。这可以通过以下条件启用：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`SwaggerBasePathRewritingFilter` is also used, which will help to rewrite the
    microservice Swagger URL base path:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwaggerBasePathRewritingFilter` 也被使用，这将有助于重写微服务 Swagger URL 基础路径：'
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A `TokenRelayFilter` is added to remove the authorization from Zuul''s ignore
    list. This will help to propagate the generated authorization token:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个 `TokenRelayFilter` 以从 Zuul 的忽略列表中移除授权。这将有助于传播生成的授权令牌：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Each application should have a Eureka client that helps load balance the requests
    among the services, as well as sending health information to the Eureka Server
    or registries. The Eureka client is configured in `application-dev.yml` as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都应该有一个 Eureka 客户端，该客户端帮助在服务之间进行请求负载均衡，并将健康信息发送到 Eureka 服务器或注册表。Eureka
    客户端在 `application-dev.yml` 中配置如下：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have chosen to enable health checks and have the interval to register and
    replicate be within `10` seconds, as well as instances where we define the lease
    renewal interval and expiration duration.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择启用健康检查，并将注册和复制的间隔设置为 `10` 秒，以及我们定义的租约更新间隔和过期持续时间。
- en: 'We will configure timeout in Hystrix, beyond which the server is considered
    to be closed:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Hystrix 中配置超时，超过这个时间服务器将被认为是关闭的：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the server does not respond within `10` seconds, then the server is considered
    dead and is registered in the registry service. This makes sure no subsequent
    requests are sent to that server until the server is made active.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器在`10`秒内没有响应，则认为服务器已死亡，并在注册服务中注册。这确保了在服务器变为活动状态之前不会向该服务器发送后续请求。
- en: JWT authentication
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JWT身份验证
- en: We need to transfer information between microserves securely. The requests must
    be verified and signed digitally, where the applications verify the authenticity
    of the requests and respond to them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在微服务之间安全地传输信息。请求必须经过验证并数字签名，应用程序验证请求的真实性并对其进行响应。
- en: We need to have a compact way to handle this information in the REST or HTTP
    world, since the information is required to be sent with each request. JWT is
    here to help. JWT is basically JSON web tokens in an open web standard that helps
    to securely transfer information between parties (applications). JWT will be signed
    using a secret, based on the HMAC algorithm, or with a public/private key. They
    are compact and self-contained.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在REST或HTTP世界中以紧凑的方式处理这些信息，因为信息需要与每个请求一起发送。JWT正是为此而来。JWT基本上是开放网络标准中的JSON
    Web Tokens，有助于在各方（应用程序）之间安全地传输信息。JWT将使用秘密、基于HMAC算法或使用公钥/私钥进行签名。它们是紧凑且自包含的。
- en: For advanced uses, we need to add Bouncy Castle ([librarieshttps://en.wikipedia.org/wiki/Bouncy_Castle_(cryptography)](https://en.wikipedia.org/wiki/Bouncy_Castle_(cryptography))).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级用途，我们需要添加Bouncy Castle（[库](https://en.wikipedia.org/wiki/Bouncy_Castle_(cryptography))）。
- en: '**Compact**: They are small and can be sent to each request.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**紧凑型**：它们很小，可以发送到每个请求。'
- en: '**Self-contained**: The payload contains all the necessary details about the
    user, which prevents us from querying the database for user authentication.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**自包含**：有效载荷包含有关用户的全部必要细节，这防止我们查询数据库进行用户身份验证。'
- en: 'JWT consists of the header, payload, and signature. They are base64 encoded
    strings, separated by `.` (a period):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JWT由头部、有效载荷和签名组成。它们是base64编码的字符串，由`.`（点）分隔：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How JWT works
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JWT是如何工作的
- en: 'When a user logs in to the system, a token is generated based on the payload
    (that is, the user information and secret key). The generated token is stored
    locally. For all future requests, this token is added to the request and the application
    will validate the token before responding to the request:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录系统时，会根据有效载荷（即用户信息和秘密密钥）生成一个令牌。生成的令牌将存储在本地。对于所有未来的请求，此令牌将添加到请求中，应用程序将在响应请求之前验证令牌：
- en: '![](img/06f4754b-3f61-4656-ba67-e7feac2d7197.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06f4754b-3f61-4656-ba67-e7feac2d7197.jpg)'
- en: 'The token will be in this format:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌的格式如下：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In JHipster, we use **JJWT** (**Java-based JSON Web Tokens**) from Okta. This
    is a simplified builder pattern-based library used to generate and sign the token
    as a producer, and parse and validate the token as a consumer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在JHipster中，我们使用来自Okta的**JJWT**（**基于Java的JSON Web Tokens**）。这是一个基于简化构建者模式的库，用于生成和签名令牌作为生产者，以及解析和验证令牌作为消费者。
- en: '**Creating the token**:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建令牌**：'
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Validating the token**:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证令牌**：'
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So far, we have created a gateway application, which will serve as a single
    point of entry for our application and services. Now, we will generate a microservice
    application using JHipster.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个网关应用程序，它将作为我们应用程序和服务的单一入口点。现在，我们将使用JHipster生成一个微服务应用程序。
- en: Microservice applications are *the* services. We will construct two sample services
    in this book and discuss the features that JHipster offers, one with the SQL database
    (MySQL) and the other with the NoSQL database (MongoDB). These services are individual
    and loosely coupled.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应用程序是**服务**。在这本书中，我们将构建两个示例服务，并讨论JHipster提供的特点，一个使用SQL数据库（MySQL），另一个使用NoSQL数据库（MongoDB）。这些服务是独立的，并且松散耦合。
- en: With JHipster, you can build microservice applications serving as REST endpoints.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JHipster，你可以构建作为REST端点的微服务应用程序。
- en: Microservice application -  Invoice Service with MySQL database
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务应用程序 - 带有MySQL数据库的发票服务
- en: We can take the invoice service from our monolithic application, separate it,
    and make them separate microservice applications. Let's name it `Invoice Service`.
    This service is responsible for creating and tracking invoices.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从我们的单体应用程序中提取发票服务，将其分离，并使其成为独立的微服务应用程序。让我们称它为`Invoice Service`。此服务负责创建和跟踪发票。
- en: Application generation
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序生成
- en: First, let's see how we can generate a microservices application. In the `e-commerce-app`
    folder, create a new folder where you will keep the microservices application.
    Let's name the folder `invoice`. Go into the directory and start creating the
    application by typing `jhipster`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们如何生成一个微服务应用程序。在 `e-commerce-app` 文件夹中，创建一个新的文件夹，用于存放微服务应用程序。让我们将文件夹命名为
    `invoice`。进入目录，通过输入 `jhipster` 开始创建应用程序：
- en: 'The first question we are asked is to select the type of application we would
    like to create. We have to choose Microservice application and then click *Enter*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是我们被要求选择我们希望创建的应用程序类型。我们必须选择微服务应用程序，然后点击 *Enter*：
- en: '![](img/4e17b905-7db2-486e-bcbb-3b66de4aee72.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e17b905-7db2-486e-bcbb-3b66de4aee72.png)'
- en: 'Then, you need to give a base name to your application. We will go with the
    default application name, `invoice` (by default, JHipster selects a folder name
    the same as the application name):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要为您的应用程序提供一个基本名称。我们将使用默认的应用程序名称，`invoice`（默认情况下，JHipster 选择与应用程序名称相同的文件夹名称）：
- en: '![](img/9fd3d888-bb65-4f1c-8584-cc23c1f133ab.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9fd3d888-bb65-4f1c-8584-cc23c1f133ab.png)'
- en: 'Then, we will select the default port in which the application has to run.
    By default, JHipster prompts `8081` as the default port for microservices, since
    we use `8080` for the gateway application:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择应用程序必须运行的默认端口。默认情况下，JHipster 提示 `8081` 作为微服务的默认端口，因为我们使用 `8080` 作为网关应用程序：
- en: '![](img/8017b65a-03b6-4170-8285-9eba66127c9f.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8017b65a-03b6-4170-8285-9eba66127c9f.png)'
- en: 'Then, we will select the default package name:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择默认的包名：
- en: '![](img/46ad4bf4-8b4d-49b7-8efc-5ae201772ab8.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/46ad4bf4-8b4d-49b7-8efc-5ae201772ab8.png)'
- en: 'Since we have selected JHipster Registry for the gateway application, we will
    select the same here. Similarly, if we selected Consul for the gateway application,
    then we can select Consul. We can even choose to have no registry and then add
    any custom registry there:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已选择 JHipster Registry 作为网关应用程序，因此在这里我们将选择相同的选项。同样，如果我们选择了 Consul 作为网关应用程序，那么我们也可以选择
    Consul。我们甚至可以选择不使用注册表，然后添加任何自定义注册表：
- en: '![](img/c801cc1d-6ed1-4fc2-abaa-eb2a625a2efc.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c801cc1d-6ed1-4fc2-abaa-eb2a625a2efc.png)'
- en: 'Then, JHipster asks for the type of authentication that we would like to use.
    We will select JWT authentication, the same as we have selected for the gateway
    application:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，JHipster 会询问我们希望使用的身份验证类型。我们将选择 JWT 身份验证，与网关应用程序中选择的相同：
- en: '![](img/0edeebcc-c85f-4b4c-a6f3-1d7a16cd319b.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0edeebcc-c85f-4b4c-a6f3-1d7a16cd319b.png)'
- en: 'Then, select the type of database that we need to have. As highlighted, the
    invoice service will have the SQL database. We will select the SQL option. JHipster
    provides an option to opt out of the database itself. When No database is selected,
    the application is generated with no database connection:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择我们需要使用的数据库类型。如突出所示，发票服务将使用 SQL 数据库。我们将选择 SQL 选项。JHipster 提供了一个选项来选择不使用数据库本身。当未选择数据库时，应用程序将生成不带数据库连接：
- en: '![](img/c9bac2b4-739a-42ba-a709-0a6e3677a425.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c9bac2b4-739a-42ba-a709-0a6e3677a425.png)'
- en: 'We will select the production database as MySQL:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择生产数据库为 MySQL：
- en: '![](img/38ca070e-3f68-4f09-b85a-c3d79ffb1eb5.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/38ca070e-3f68-4f09-b85a-c3d79ffb1eb5.png)'
- en: 'We will then select the development database as H2 with disk-based persistence:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择开发数据库为 H2，并使用基于磁盘的持久性：
- en: '![](img/8d9676cd-e413-4466-860e-d0f631aeef24.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d9676cd-e413-4466-860e-d0f631aeef24.png)'
- en: Then, we will select HazelCast cache as the Spring cache abstraction. Hazelcast
    provides a shared cache among all sessions. It is possible to hold the persistent
    data across the cluster or at the JVM level. We can have different modes available,
    with single or multiple nodes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择 HazelCast 缓存作为 Spring 缓存抽象。Hazelcast 为所有会话提供共享缓存。可以在集群或 JVM 层面上保持持久数据。我们可以有不同的模式可供选择，包括单节点或多节点。
- en: 'Ehcache is a local cache and it is useful for storing information in a single
    node. Infinispan and HazelCast are capable of creating a cluster and sharing information
    among multiple nodes, with HazelCast using a distributed cache, each of them connected
    together. On the other hand, Inifinispan is a hybrid cache:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Ehcache 是一个本地缓存，它适用于在单个节点中存储信息。Infinispan 和 HazelCast 能够创建集群并在多个节点之间共享信息，其中
    HazelCast 使用分布式缓存，每个节点相互连接。另一方面，Infinispan 是一个混合缓存：
- en: '![](img/0835f7db-0939-4f5c-9af0-d9e5e23d9e3c.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0835f7db-0939-4f5c-9af0-d9e5e23d9e3c.png)'
- en: 'Then, we will choose Hibernate 2nd level cache:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择 Hibernate 2 级缓存：
- en: '![](img/34d9625d-60b7-49dc-9915-5b3bf5adf143.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34d9625d-60b7-49dc-9915-5b3bf5adf143.png)'
- en: 'We will select Gradle for the build tool:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择 Gradle 作为构建工具：
- en: '![](img/4f3a071c-bb09-4dbe-bfca-97b757a55100.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4f3a071c-bb09-4dbe-bfca-97b757a55100.png)'
- en: 'Then, JHipster asks whether we have any other technologies that we would like
    to add. We will not select anything here and go with the default option:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，JHipster 会询问我们是否还有其他技术想要添加。我们这里不会选择任何内容，并使用默认选项：
- en: '![](img/79e8b6a6-5547-431e-a07b-0c6f758d6aab.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/79e8b6a6-5547-431e-a07b-0c6f758d6aab.png)'
- en: 'Then, we will opt to have **internationalization** (**i18n**):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择**国际化**（**i18n**）：
- en: '![](img/8de93a2f-1f4e-4ff9-ae80-4d674117f23b.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8de93a2f-1f4e-4ff9-ae80-4d674117f23b.png)'
- en: 'And then, we will select English as the default option:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择默认选项为英语：
- en: '![](img/cee1b70b-d3d7-4908-9ad1-3077b6a6c761.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cee1b70b-d3d7-4908-9ad1-3077b6a6c761.png)'
- en: 'And select the additional languages that we need:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 选择我们需要的附加语言：
- en: '![](img/590fd2e0-1caf-4c0c-a854-252000be3ad4.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/590fd2e0-1caf-4c0c-a854-252000be3ad4.png)'
- en: 'Then, select any other testing frameworks that we would like to add to Gatling
    or Cucumber. Note that since it will not generate a frontend application, options
    such as Protractor are not listed:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择我们想要添加到 Gatling 或 Cucumber 的任何其他测试框架。请注意，由于它不会生成前端应用程序，因此选项如 Protractor
    未列出：
- en: '![](img/d055b131-1c63-4e08-84e4-613406808f4b.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d055b131-1c63-4e08-84e4-613406808f4b.png)'
- en: 'Finally, we will select any other generators that we need to install from the
    JHipster marketplace. Currently, we will not select any other generators (default
    option):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将从 JHipster 市场中选择我们需要的任何其他生成器进行安装。目前，我们将不会选择任何其他生成器（默认选项）：
- en: '![](img/d8a4d1f5-1b1a-48ff-aceb-3c8860351241.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8a4d1f5-1b1a-48ff-aceb-3c8860351241.png)'
- en: 'Then, the server application is generated:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，生成服务器应用程序：
- en: '![](img/8d34b1df-4ba3-4ec6-bb2f-c67a21fcb26b.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d34b1df-4ba3-4ec6-bb2f-c67a21fcb26b.png)'
- en: 'Our microservice application is generated. JHipster will automatically commit
    the generated files to Git. If you wish to do this step yourself, you can do so
    by passing the `skip-git` flag during execution, for example, `jhipster --skip-git`,
    and executing the steps manually as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已生成微服务应用程序。JHipster 将自动将生成的文件提交到 Git。如果您希望手动执行此步骤，可以在执行期间传递 `skip-git` 标志，例如，`jhipster
    --skip-git`，然后手动执行以下步骤：
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Microservice configuration
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务配置
- en: The application that is generated will not feature any frontend. Again, the
    invoice service is a Spring Boot-based application. The security features are
    configured in `MicroserviceSecurityConfiguration.java`*.*
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的应用程序将不包含任何前端。再次强调，发票服务是基于 Spring Boot 的应用程序。安全功能在 `MicroserviceSecurityConfiguration.java`*.*
    中配置。
- en: 'Ignore all the frontend related requests, so whenever a user tries to reach
    any frontend-related resources such as HTML, CSS, and JS, the request will be
    ignored by the invoice service:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略所有与前端相关的请求，因此当用户尝试访问任何与前端相关的资源，如 HTML、CSS 和 JS 时，请求将由发票服务忽略：
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since the services are independent, they can be deployed and run on another
    server with a different IP address. This requires us to disable **CSRF** (**Cross
    Site Request Forgery**) by default. We will also enable the STATELESS session
    policy in session management. This makes our application unable to create or maintain
    any sessions. Every request is authenticated and authorized based on the token.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务是独立的，它们可以部署并运行在具有不同 IP 地址的另一个服务器上。这要求我们默认禁用 **CSRF**（**跨站请求伪造**）。我们还将启用会话管理中的无状态会话策略。这使得我们的应用程序无法创建或维护任何会话。每个请求都是基于令牌进行认证和授权的。
- en: We will also use the STATELESS session policy in session management. This is
    the strictest session policy available. This will not allow our application to
    generate a session, and so our requests have to have the (time-bound) tokens attached
    to each and every request. This enhances the security of our services. Their stateless
    constraint is another advantage of using REST APIs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用会话管理中的无状态会话策略。这是最严格的会话策略。这不会允许我们的应用程序生成会话，因此我们的请求必须附有每个请求的（时间限制）令牌。这增强了我们服务的安全性。它们的无状态约束是使用
    REST API 的另一个优点。
- en: For more options and information on session policies, please look at the following
    documentation:  [https://docs.spring.io/autorepo/docs/spring-security/4.2.3.RELEASE/apidocs/org/springframework/security/config/http/SessionCreationPolicy.html](https://docs.spring.io/autorepo/docs/spring-security/4.2.3.RELEASE/apidocs/org/springframework/security/config/http/SessionCreationPolicy.html).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 关于会话策略的更多选项和信息，请参阅以下文档：[https://docs.spring.io/autorepo/docs/spring-security/4.2.3.RELEASE/apidocs/org/springframework/security/config/http/SessionCreationPolicy.html](https://docs.spring.io/autorepo/docs/spring-security/4.2.3.RELEASE/apidocs/org/springframework/security/config/http/SessionCreationPolicy.html)。
- en: 'Then, all API-related requests and Swagger resources should be allowed once
    the request is authorized (based on the JWT token):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦请求被授权（基于JWT令牌），就应该允许所有与API相关的请求和Swagger资源：
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: On the resource side, in `bootstrap.yml`, we have defined the registry-related
    information.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源方面，在`bootstrap.yml`中，我们已定义了与注册表相关的信息。
- en: 'Our current microservice application uses the JHipster registry as the registry
    service in order to register and deregister their existence in a heartbeat. We
    need to provide the password of our registry service with which the application
    can connect to the registry service:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的微服务应用程序使用JHipster注册表作为注册表服务，以便在心跳中注册和注销其存在。我们需要提供注册表服务的密码，以便应用程序可以连接到注册表服务：
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Also, the name of the Spring Boot service and the default Spring Cloud Config
    parameters are enabled in the `bootstrap.yml`. We have also added the URI that
    we have to connect in order to fetch the configuration of the registry service:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Spring Boot服务的名称和默认的Spring Cloud Config参数已在`bootstrap.yml`中启用。我们还添加了必须连接以获取注册表服务配置的URI：
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Similar to the gateway, the rest of the service-related configurations are done
    in the `application.yml` file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与网关类似，其余的服务相关配置都是在`application.yml`文件中完成的。
- en: 'The Eureka configuration is exactly the same as in the gateway application.
    All the generated applications will have a similar Eureka configuration:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka配置与网关应用程序中的配置完全相同。所有生成的应用程序都将具有类似的Eureka配置：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The database and JPA configurations are made:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库和JPA配置如下：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The rest of the configurations remain similar to what was generated in the gateway
    application, and they can be tweaked or customized based on your requirements.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的配置与网关应用程序中生成的配置相似，可以根据您的需求进行调整或定制。
- en: Now, we can boot up the application alongside the gateway application and registry
    service. Since the application tries to connect to the registry service first,
    if there is no registry service available at the specified location, then the
    application will not know where to connect and whom to respond to.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以与应用程序和注册表服务一起启动应用程序。由于应用程序首先尝试连接到注册表服务，如果指定的位置没有可用的注册表服务，则应用程序将不知道连接何处以及响应谁。
- en: Thus, the invoice service is generated. Now, we can generate a notification
    service with NoSQL as the backend database.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，发票服务已生成。现在，我们可以使用NoSQL作为后端数据库生成通知服务。
- en: Microservice application - notification service with NoSQL database
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务应用程序 - 使用NoSQL数据库的通知服务
- en: For an e-commerce website, it is really essential that orders are tracked and
    users are notified at the right moment. We will create a notification service
    which will notify users whenever their order status changes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电子商务网站来说，订单的跟踪和用户在正确的时间收到通知是非常关键的。我们将创建一个通知服务，该服务将在用户的订单状态发生变化时通知用户。
- en: Application generation
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序生成
- en: Let's generate our second microservice application (notification service) in
    the `e-commerce-app` folder. Create a new folder where you will keep the microservices
    application. Let's name the folder `notification`. Go into the directory and start
    creating the application by running `jhipster`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`e-commerce-app`文件夹中生成我们的第二个微服务应用程序（通知服务）。在将微服务应用程序保存在的新文件夹中创建一个新文件夹。让我们将文件夹命名为`notification`。进入目录，通过运行`jhipster`开始创建应用程序。
- en: 'The first question we are asked is to select the type of application we would
    like to create. We have to choose Microservice application and then click *Enter*:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被问到的第一个问题是选择我们想要创建的应用程序类型。我们必须选择微服务应用程序，然后点击*Enter*：
- en: '![](img/178c818e-593f-495b-9e30-6c70f754d4c1.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/178c818e-593f-495b-9e30-6c70f754d4c1.png)'
- en: 'Then, we will select the default application name, `notification`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择默认的应用程序名称，`notification`：
- en: '![](img/54fbf7a7-c148-41ba-8002-1be2d6173916.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54fbf7a7-c148-41ba-8002-1be2d6173916.png)'
- en: 'Then, we will select the port for the application. Since we have selected `8080`
    for the monolithic application and `8081` for the invoice service, we will use
    port `8082` for the notification service:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择应用程序的端口号。由于我们已将 `8080` 用于单体应用程序和 `8081` 用于发票服务，因此我们将使用端口号 `8082` 用于通知服务：
- en: '![](img/1ac1b9cd-bb3e-41d8-b3d2-1265b8987630.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ac1b9cd-bb3e-41d8-b3d2-1265b8987630.png)'
- en: 'For the next three questions, we will use the same options as we did previously:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的三个问题，我们将使用之前相同的选项：
- en: '![](img/d475c013-8d0b-43fc-91f5-c874a3d462c6.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d475c013-8d0b-43fc-91f5-c874a3d462c6.png)'
- en: 'Then, we will select MongoDB as the database. After selecting MongoDB, JHipster
    will now ask for the different types of database you would like to use for the
    development and production servers. We will use MongoDB as both the development
    and production database:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择 MongoDB 作为数据库。在选择了 MongoDB 之后，JHipster 现在将询问您希望用于开发和生产服务器的不同类型的数据库。我们将使用
    MongoDB 作为开发和生产数据库：
- en: '![](img/ccad6fc7-b2c4-454d-bd26-75100bde78b0.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ccad6fc7-b2c4-454d-bd26-75100bde78b0.png)'
- en: 'For the remaining questions, we will select options that are similar to what
    we chose for the invoice service:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于剩余的问题，我们将选择与我们在发票服务中选择的选项类似的选项：
- en: '![](img/546e532b-012d-4490-851d-0b35940b89e0.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/546e532b-012d-4490-851d-0b35940b89e0.png)'
- en: 'The server is generated successfully:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器已成功生成：
- en: '![](img/290c5027-31e8-4cc1-a49d-003da91c9138.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/290c5027-31e8-4cc1-a49d-003da91c9138.png)'
- en: 'Our microservice application is generated. JHipster will automatically commit
    the generated files to Git. If you wish to do this step yourself, you can do so
    by passing the `skip-git` flag during execution, for example, `jhipster --skip-git`,
    and executing the steps manually as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的微服务应用程序已生成。JHipster 将自动将生成的文件提交到 Git。如果您希望手动执行此步骤，可以在执行期间传递 `skip-git` 标志，例如，`jhipster
    --skip-git`，然后按照以下步骤手动执行：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Microservice configuration
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务配置
- en: 'The application is finally generated, since we have selected similar options
    for both microservices. The code generated will be similar, except for the database
    configuration:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为两个微服务选择了类似选项，应用程序最终生成。生成的代码将类似，但数据库配置除外：
- en: '![](img/75ed1cc5-10a4-4410-b82b-17934bb4a4b8.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/75ed1cc5-10a4-4410-b82b-17934bb4a4b8.png)'
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Well, we have generated a gateway application and two microservice applications
    in this chapter. We have shown you how easy it is to generate a microservice bundle
    with JHipster. Now, before we run our application, we need to kick-start our registry
    server.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，在本章中，我们已经生成了一个网关应用程序和两个微服务应用程序。我们已经向您展示了使用 JHipster 生成微服务包是多么容易。现在，在我们运行应用程序之前，我们需要启动我们的注册服务器。
- en: In the next chapter, we will kick-start the registry server, and we will also
    see how to add entities to our new services.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将启动注册服务器，我们还将了解如何将实体添加到我们的新服务中。
