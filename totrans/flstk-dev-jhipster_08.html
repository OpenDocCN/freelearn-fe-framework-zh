<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Introduction to Microservice Server-Side Technologies</h1>
                </header>
            
            <article>
                
<p>Wasn't it easy to develop a production-ready monolithic application with JHipster? So far, we have created an application from scratch, added a few entities with JDL Studio, and then deployed it to the production environment along with tests. We have also added a continuous integration and continuous delivery pipeline. Wasn't the experience faster, easier, and better than coding everything from scratch?</p>
<p>So what's next? Yes, you guessed it right—<strong>microservices</strong>!</p>
<p>Microservices is the buzzword everywhere these days. Many companies out there are trying to solve their problems with microservices. We already saw an overview of the benefits of microservices in <a href="498dbd6d-b882-4551-92dd-97cdde4b62ac.xhtml">Chapter 1</a>, <em>Introduction to Modern Web Application Development</em>.</p>
<p>In this chapter, we will look at the following:</p>
<ul>
<li>Benefits of microservices over monoliths</li>
<li>Components that we need for building a complete microservices architecture</li>
</ul>
<p>In this chapter, we will see how the monolithic application we created earlier can be converted into a microservice application. </p>
<p>After that, we will see how easy it is to create a microservice architecture using the options JHipster provides.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservice applications versus monoliths</h1>
                </header>
            
            <article>
                
<p>The benefits of microservice architectures can be better understood by comparing them with monolithic architectures.</p>
<div class="packt_quote packt_tip packt_infobox">The benefits of microservices over monoliths are phenomenal when they are designed and deployed correctly.</div>
<p>It is not as simple as splitting a monolithic application based on structure, component, or functionality and then deploying them as individual services. This will not work out. Converting a monolithic application or even a monolithic design into microservices needs a clear vision of the product. It includes knowledge of what part of the project will change and what part will be consistent. We must have low-level details, such as which entities we should group together and those that can be separated. </p>
<p>This clearly illustrates the need for an ever-evolving model. It is much easier to split the technologies used in the application, but not the interdependent models or the business logic of the application. So it is essential to place the project's primary focus on core domain and its logic.</p>
<p>Microservices should be independent. They will fail when a component is tightly coupled with another. The trickiest part is identifying and segregating the components.</p>
<p>When we have done that, it offers the following benefits over monolithic applications.</p>
<p>The monolithic code is a single unit. Thus, all parts of the application share the same memory. For a bigger system, we need to have a bigger infrastructure. When the application grows, we need to scale the infrastructure as needed. The scaling of an already bigger infrastructure is always a difficult and costlier task for operations. </p>
<p>Even though they have all the necessary code to handle anything in the product at a single place (no need to worry about latency or availability), it is difficult to handle the resources that it consumes to run and it is definitely not scalable. If any one part of the application fails, then the whole product will be impacted. When any one thread or query of the product clings on to the memory, then the impact will be seen by millions of our customers.</p>
<p>Microservices, on the other hand, require less memory to run since we are splitting the application into smaller components, which in turn reduces the infrastructure's cost. For example, it is cheaper to run 10 2GB instances (costs ~<span>$</span>170 per month on AWS) than running a single 16 GB instance (costs ~<span>$</span>570 per month on AWS). Each component runs in its own environment, which makes microservices much more developer-friendly and cloud-native. <span>Similarly, microservices also increase the throughput across services. A memory intensive operation on one service will not affect any other service.</span></p>
<p>Monolithic architecture, over a period of time, will remove the agility of a team, which will delay the application rollout. This means people will tend to invest more time to find a workaround to fix a problem when a new feature is added, or something in the existing feature breaks. The monolithic architecture will bring a greater amount of inefficiency that in turn increases the technical debt.</p>
<p>Microservices, on the other hand, reduce the technical debt in terms of architecture since everything is reduced to individual components. Teams tend to be more agile and they will find handling changes easier.</p>
<div class="packt_quote packt_tip">The less code there is, the fewer bugs there are, meaning less pain and a shorter time to fix.</div>
<p>Monolithic applications are more time consuming to work with. Imagine there is a big monolithic application and you have to reverse an <em>if condition</em> in your service layer. After changing the code, it has to be built, which usually takes a few minutes, and then you must test the entire application, which will reduce the team's performance.</p>
<p>You can reboot or reload an application in seconds for a microservice architecture. When you have to reverse an <em>if condition</em>, you need not wait for minutes to build and deploy the application to test, you can do it in seconds. This will decrease the time it takes to do mundane tasks.</p>
<div class="packt_quote packt_tip">Faster iterations/releases and decreased downtime are the key things to increase user engagement and user retention, which in turn results in better revenue.</div>
<p>A human mind (unless you are superhuman) can handle only a limited amount of information. So cognitively, microservices help people to reduce the clutter and focus on the functionality. This enables better productivity and faster rollouts.</p>
<p>Embracing microservices will:</p>
<ul>
<li>Maximize productivity</li>
<li>Improve agility</li>
<li>Improve customer experience</li>
<li>Speed up development/unit testing (if designed properly)</li>
<li>Improve revenue</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building blocks of a microservice architecture</h1>
                </header>
            
            <article>
                
<p>Running a microservice architecture requires a lot of components/features and involves a lot of advanced concepts. For the sake of understanding these concepts, imagine we have a microservice-based application for our e-commerce shopping website. This includes the following services:</p>
<ul>
<li>Pricing services: Responsible for giving us the price of the product based on demand</li>
<li>Demand services: Responsible for calculating the demand for the product based on the sales and stocks left</li>
<li>Inventory services: Responsible for tracking the quantity left in the inventory</li>
<li>Many other services</li>
</ul>
<p>Some of the concepts we will see in this section are:</p>
<ul>
<li>Service registry</li>
<li>Service discovery</li>
<li>Health check</li>
<li>Dynamic routing and resiliency</li>
<li>Security (authentication and authorization)</li>
<li>Fault tolerance and failover</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service registry</h1>
                </header>
            
            <article>
                
<p>Microservices are independent, but many use cases will need them to be interdependent. This means for some services to work properly they need data from another service, which in turn may or may not depend on other services or sources.</p>
<p>For example, our pricing service will directly depend on the demand service, which in turn depends on the inventory service. But these three services are completely independent, that is they can be deployed on any host, port, or location and scaled at will.</p>
<p>If the pricing service wants to communicate with the demand service, it has to know the exact location to which it can send requests to get the required information. Similarly, the demand service should know about the inventory service's details in order to communicate.</p>
<p>So we need a service registry that registers all other services and their locations. All services should register themselves to this registry service when the service is started and deregister itself when the service goes down.</p>
<div class="packt_quote packt_infobox">The service registry should act as a database of services, recording all the available instances and their details.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service discovery</h1>
                </header>
            
            <article>
                
<p>The service registry has details of the services available. But in order to find out where the required service is and which services to connect, we need to have service discovery.</p>
<p>When the pricing service wants to communicate with the demand service, it needs to know the network location of the demand service. In the case of traditional architecture, this is a fixed physical address but in the microservices world, this is a dynamic address that is assigned and updated dynamically.</p>
<p>The pricing service (client) will have to locate the demand service in the service registry and determine the location and then load balance the request o the available demand service. The demand service, in turn, will respond to the request of the requested client (pricing service).</p>
<p>Service discovery is used to discover the exact service to which the client should connect to, in order to get the necessary details. </p>
<div class="packt_quote packt_infobox">Service discovery helps the API gateway to discover the right endpoint for a request.</div>
<p>They will also have a load balancer, which regulates the traffic and ensures the high availability of the services.</p>
<p>Based on the location where load balancing happens, the service discovery is classified into:</p>
<ul>
<li><strong>Client-side discovery pattern</strong></li>
</ul>
<p style="padding-left: 60px">The load balancing will happen on the client service side. The client service will determine where to send the request and the logic of load balancing will be in the client service. For example, Netflix Eureka (<a href="https://github.com/Netflix/eureka">https://github.com/Netflix/eureka</a>) is a service registry. It provides endpoints to register and discover the services.</p>
<p style="padding-left: 60px">When the pricing service wants to invoke the demand service, it will connect to the service registry and then find the available services. Then, based on the load balancing logic configured, the pricing service (client) will determine which demand service to request.</p>
<p style="padding-left: 60px">The services will then do an intelligent and application-specific load balancing. On the downside, this adds an extra layer of load balancing in every service, which is an overhead:</p>
<ul>
<li><strong>Server-side discovery pattern</strong></li>
</ul>
<p style="padding-left: 60px">The pricing service will request the load balancer to connect to the demand service. Then, the load balancer will connect to the service registry to determine the available instance, and then route the request based on the load balancing configured.</p>
<p class="mce-root" style="padding-left: 60px">For example, in Kubernetes, each pod will have its own server or proxy. All the requests are sent through this proxy (which has a dedicated IP and port associated with it).</p>
<p style="padding-left: 60px">The load balancing logic is moved away from the service and isolated into a separate service. On the downside, it requires yet another highly available service to handle the requests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Health check</h1>
                </header>
            
            <article>
                
<p>In the microservices world, instances can start, change, update, and stop at random. They can also scale up and down based on their traffic and other settings. This requires a health check service that will constantly monitor the availability of the services.</p>
<p>Services can send their status periodically to this health check service, and this keeps a track of the health of the services. When a service goes down, the health check service will stop getting the heartbeat from the service. Then, the health check service will mark the service down and cascade the information to the service registry. Similarly, when the service resumes, the heartbeat is sent to the health check service. Upon receiving a few positive heartbeats, the service is marked UP and then the information is sent to the service registry.</p>
<p>The health check service can check for health in two ways:</p>
<ul>
<li><strong>Push configuration</strong>: All the services will send their heartbeat periodically to the health check service</li>
<li><strong>Pull configuration</strong>: A single health check service instance will query for the availability of the systems periodically</li>
</ul>
<p>This also requires a <strong>high availability system</strong>. All the services should connect to this service to share their heartbeat and this has to connect to the service registry to tell them whether a service is available or not.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dynamic routing and resiliency</h1>
                </header>
            
            <article>
                
<p>The health check services will track the health of available services and send details to the service registry about the health of services.</p>
<div class="packt_quote packt_infobox">Based on this, services should intelligently route requests to healthy instances and shut down the traffic to unhealthy instances.</div>
<p>Since the services dynamically change their location (address /port), every time a client wants to connect to the service, it should first check for the availability of the services from the service registry. Every connection to the client will also need to have a timeout added to it, beyond which the request has to be served or it has to be retried (configured) to another instance. This way we can minimize the <em>cascading failure</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Security</h1>
                </header>
            
            <article>
                
<p>When a client invokes the available service, we need to validate the request. In order to prevent unwanted requests from piling up, we should have an additional layer of <strong>security</strong>. The requests from the client should be authenticated and authorized to call the other service, to prevent unauthorized calls to the service. The service should, in turn, decrypt the request, understand whether it is valid or invalid, and do the rest.</p>
<p>In order to provide secure microservices, it should have the following characteristics:</p>
<ul>
<li>Confidentiality: Allow only the authorized clients to access and consume the information.</li>
<li>Integrity: Can guarantee the integrity of the information that it receives from the client and ensure that it is not modified by a third-party (for example, when a gateway and a service is talking to each other, no party can tamper with or alter the messages that are sent between them. This a classic man-in-the-middle attack).  </li>
<li>Availability: A secure API service should be highly available.</li>
<li>Reliability: Should handle the requests and process them reliably.</li>
</ul>
<div class="packt_infobox">For more information on MITM, or man-in-the-middle attacks check, the following link: <a href="https://www.owasp.org/index.php/Man-in-the-middle_attack">https://www.owasp.org/index.php/Man-in-the-middle_attack.</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fault tolerance and failover</h1>
                </header>
            
            <article>
                
<p>In a microservice architecture, there might be many reasons for a fault. It is important to handle faults or failovers gracefully, as follows:</p>
<ul>
<li>When the request takes a long time to complete, have a predetermined timeout instead of waiting for the service to respond.</li>
<li>When the request fails, identify the server, notify the service registry, and stop connecting to the server. This way, we can prevent other requests from going to that server.</li>
<li>Shut down the service when it is not responding and start a new service to make sure services are working as expected.</li>
</ul>
<p>This can be achieved using the following:</p>
<ul>
<li><strong>Fault tolerance</strong> libraries, which prevent cascading failures by isolating the remote instance and services that are not responding or taking a longer time than in the SLA to respond. This prevents other services from calling the failed or unhealthy instances.</li>
<li><strong>Distributed tracing system</strong> libraries help to trace the timing and latency of the service or system, and highlight any discrepancies with the agreed SLA. They also help you to understand where the performance bottleneck is so that you can act on this.</li>
</ul>
<p>JHipster provides options to fulfill many of the preceding concepts. The most important of them are as follows:</p>
<ul>
<li>JHipster Registry</li>
<li>HashiCorp Consul</li>
<li>JHipster Gateway</li>
<li>JHipster console</li>
<li>Prometheus</li>
<li>JHipster UAA server</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JHipster Registry</h1>
                </header>
            
            <article>
                
<p>JHipster provides JHipster Registry (<a href="http://www.jhipster.tech/jhipster-registry/">http://www.jhipster.tech/jhipster-registry/</a>) as the default <strong>service registry</strong>. The JHipster Registry is a runtime application that all microservice applications register with and get their configuration from. It also provides additional features such as monitoring and health check dashboards.</p>
<p>JHipster Registry is made up of the following:</p>
<ul>
<li>Netflix Eureka server</li>
<li>Spring cloud config server</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Netflix Eureka server</h1>
                </header>
            
            <article>
                
<p>Eureka (<a href="https://github.com/Netflix/eureka">https://github.com/Netflix/eureka</a>) consists of the following:</p>
<ul>
<li>The Eureka server</li>
</ul>
<p>Eureka is a REST-based service. It is used for locating services for load balancing and failover middle tiers. </p>
<p>Eureka servers help to load balance among the instances. They are more useful in a cloud-based environment where the availability is intermittent. On the other hand, traditional load balancers help in load balancing the traffic between known and fixed instances.</p>
<ul>
<li>The Eureka client</li>
</ul>
<p>Eureka provides a Eureka client, which makes the interaction between servers seamless. It is a Java-based client.</p>
<p>Eureka acts as a <strong>middle tier</strong> <em>load balancer</em> that helps to load balance the host of a middle-tier services. They provide a simple round robin-based load balancing by default. The load balancing algorithm can be customized as needed with a wrapper.</p>
<p>They cannot provide sticky sessions. They also fit perfectly for client-based load balancing scenarios (as seen earlier).</p>
<p>Eureka has no restriction on the communication technology. We can use anything, such as Thrift, HTTP, or any RPC mechanisms, for communication.</p>
<p>Imagine our application is in different AWS Availability Zones. We register a Eureka cluster in each of the zones that holds information about available services in that region only and start the Eureka server in each zone to handle zone failures.</p>
<p>All the services will register themselves to the Eureka server and send their heartbeats. When the client no longer sends a heartbeat, the service is taken out of the registry itself and the information is passed across the Eureka nodes in the cluster. Then, any client from any zone will look up the registry information to locate it and then make any remote calls. Also, we need to ensure that Eureka clusters between regions do not communicate with each other.</p>
<p>Eureka prefers availability over consistency. That is when the services are connected to the Eureka server and it shares the complete configuration between the services. This enables services to run even when the Eureka server goes down. In production, we have to run Eureka in a high availability cluster for better consistency.</p>
<p>Eureka also has the ability to add or remove the servers on the fly. This makes it the right choice for service registry and service discovery.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring cloud config server</h1>
                </header>
            
            <article>
                
<p>In a microservice architecture, the services are dynamic in nature. They will go down and come up based on traffic or any other configuration. Due to this dynamic nature, there should be a separate, <em>highly available</em> server that holds the essential configuration details that all the servers need to know.</p>
<p>For example, our pricing service will need to know where the registry service is and how it has to communicate to the registry service. The registry service, on the other hand, should be highly available. If for any reason the server has to go down, we will spin up a new server. The pricing service needs to communicate with the config service <span>in order to find out about the registry service</span>. On the other hand, when the registry service is changed, it has to communicate the changes to the config server, which will then cascade the information to all the necessary services.</p>
<p>Spring cloud config server (<a href="https://github.com/spring-cloud/spring-cloud-config">https://github.com/spring-cloud/spring-cloud-config</a>) provides server and client-side support for external configuration.</p>
<p>With the cloud config server, we have a central place to manage all our external properties across all environments. The concept is similar to Spring-based environment property source abstractions on both client and server. They fit for any application running in any language.</p>
<p>They are also helpful for carrying the configuration data between various (development/test/production) environments and help to migrate much easier.</p>
<p>Spring config server has a HTTP, resource-based API for external configuration. They will encrypt and decrypt property values. They bind to the config server and initialize a Spring environment with remote property sources. The configuration can be stored in a Git repository or in a file system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HashiCorp Consul</h1>
                </header>
            
            <article>
                
<p>Consul (<a href="https://www.consul.io/">https://www.consul.io/</a>) is primarily a service discovery client from Hashicorp. It focuses on consistency. Consul is completely written in Go.</p>
<p>This means it will have a lower memory footprint. Added to that, we can also use Consul with services written in any programming language.</p>
<p>The main advantages of using Consul are as follows:</p>
<ul>
<li>It has a lower memory footprint</li>
<li>It can be used with services that are written in any programming language</li>
<li>It focuses on consistency rather than availability </li>
</ul>
<p>Consul also provides service discovery, failure detection, multi-data center configuration, and storage.</p>
<div class="packt_quote packt_infobox">This is an alternative option to JHipster Registry. There is an option to choose between JHipster Registry and Consul during application creation.</div>
<p>Eureka (JHipster Registry) requires each application to use its APIs for registering and discovering themselves. It focuses on availability over consistency. It supports only applications or services written in Spring Boot.</p>
<p>On the other hand, Consul runs as an agent in the services, and checks the health information and a few other extra operations listed previously.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service discovery</h1>
                </header>
            
            <article>
                
<p>Consul can provide a service and other clients can use Consul to discover the providers of a given service. Using either DNS or HTTP, applications can easily find the services that they depend on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Health discovery</h1>
                </header>
            
            <article>
                
<p>Consul clients can provide any number of health checks, either associated with a given service or with the local node. This information can be used by a health check service to monitor services' health, and it is in turn used to discover the service components and route traffic away from unhealthy hosts and towards the healthy hosts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">K/V store</h1>
                </header>
            
            <article>
                
<p><span>Consul has an easy-to-use HTTP API that makes it simple for a</span>pplications to use Consul's key/value store for dynamically configuring services, electing the leader when the current leader goes down, and segregating containers based on features. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple data centers</h1>
                </header>
            
            <article>
                
<p>Consul supports multiple data centers out of the box. This means you do not have to worry about building additional layers of abstraction to grow to multiple regions.</p>
<p>Consul should be a distributed and highly available service. Every node that provides services to Consul runs a consul agent, which is mainly responsible for health checking. These agents will then talk with one or more Consul servers, which collect and add this information. These servers will also elect a leader among themselves.</p>
<p>Thus, Consul serves as a service registry, service discovery, health check, and K/V store.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JHipster Gateway</h1>
                </header>
            
            <article>
                
<p>In a microservice architecture, we need an entry point to access all the running services. So we need a service that acts as a gateway. This will proxy or route clients' requests to the respective services. In JHipster, we provide JHipster Gateway for that.</p>
<div class="packt_infobox">JHipster Gateway is a microservice application that can be generated. It integrates Netflix Zuul and Hystrix in order to provide routing, filtering, security, circuit breaking, and so on.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Netflix Zuul</h1>
                </header>
            
            <article>
                
<p>In a microservice architecture, Zuul is a front door for all the requests (gatekeeper). It acts as an edge service application. Zuul is built to enable <em>dynamic routing, monitoring, resiliency, and security </em>among the services. It also has the ability to dynamically route requests as needed.</p>
<div class="packt_infobox"><span>Trivia: In </span><em>Ghostbusters</em><span>, Zuul is the gatekeeper.</span></div>
<p>Zuul works based on different types of filter that enable us to quickly and nimbly apply functionality to our edge service.</p>
<p>These filters help us to perform the following functions:</p>
<ul>
<li>Authentication and security: To identify each resource's authentication requirements and to reject requests that do not satisfy the requirements</li>
<li>Insights and monitoring: To track data and statistics at the edge and to give an insight into the production application</li>
<li>Dynamic routing: To dynamically route requests to different backend clusters as needed based on health and other factors<span> </span></li>
<li>Multi-regional resiliency (AWS): To route requests across AWS regions in order to diversify our Elastic Load Balancer usage and move our edge closer to our members </li>
</ul>
<div class="packt_infobox">For even more information on Zuul, please check <a href="https://github.com/Netflix/zuul/wiki">https://github.com/Netflix/zuul/wiki.</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hystrix</h1>
                </header>
            
            <article>
                
<p>Hystrix (<a href="https://github.com/Netflix/Hystrix">https://github.com/Netflix/Hystrix</a>) is a latency and fault tolerance library designed to isolate points of access to remote systems, services, and third-party libraries, stop cascading failures; and enable resilience in complex distributed systems where failure is inevitable.</p>
<p>Hystrix is designed to do the following:</p>
<ul>
<li>Stop failure cascades in a complex distributed system</li>
<li>Protect the system from the failures of dependencies over the network</li>
<li>Control the latency of the system</li>
<li>Recover rapidly and fail faster to prevent cascading</li>
<li>Fall back and gracefully degrade when possible</li>
<li>Enable near-real-time monitoring, alerting, and operational control</li>
</ul>
<p>Applications in complex distributed architectures have a lot of dependencies, each of which will inevitably fail at some point. If the host application is not isolated from these external failures, it risks being taken down with them. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JHipster Console</h1>
                </header>
            
            <article>
                
<p>The JHipster Console (<a href="https://github.com/jhipster/jhipster-console">https://github.com/jhipster/jhipster-console</a>) is a monitoring solution for microservices built using the ELK stack. It comes bundled with preset dashboards and configuration. It is provided as a runtime component in the form of a Docker image.</p>
<div class="packt_quote packt_infobox">The ELK Stack is made up of Elasticsearch, Logstash, and Kibana.</div>
<p>Logstash can be used to normalize the data (usually from logs) and then Elasticsearch is used to process the same data faster. Finally, Kibana is used to visualize the data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Elasticsearch</h1>
                </header>
            
            <article>
                
<p>Elasticsearch is a widely used search engine in data analytics. It helps you to extract data really fast from data haystacks. It also helps to provide real-time analytics and data extraction. It is highly scalable, available, and multi-tenanted.</p>
<p>It also provides full text-based searches saved as a document. These documents, in turn, will be updated and modified based on any changes to the data. This, in turn, will provide a faster search and analyze the data. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logstash</h1>
                </header>
            
            <article>
                
<p>Logstash (<a href="https://www.elastic.co/products/logstash">https://www.elastic.co/products/logstash</a>) will take the logs, process them, and convert them into output. They can read any type of logs, such as system logs, error logs, and app logs. They are the <strong>heavy working</strong> component of this stack, which helps to store, query, and analyze the logs.</p>
<p>They act as a pipeline for event processing and are capable of processing huge amounts of data with the filters and, along with Elasticsearch, deliver results really fast. JHipster makes sure that the logs are in the correct format so that they can be grouped and visualized in the correct way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kibana</h1>
                </header>
            
            <article>
                
<p>Kibana (<a href="https://www.elastic.co/products/kibana">https://www.elastic.co/products/kibana</a>) forms the frontend of the ELK stack. It is used for data visualization. It is merely a log data dashboard. It is helpful in visualizing the trends and patterns in data that are otherwise tedious to read and interpret. It also provides an option to share/save, which makes visualization of the data more useful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Zipkin</h1>
                </header>
            
            <article>
                
<p>Zipkin (<a href="https://zipkin.io/">https://zipkin.io/</a>) is a distributed tracing system. Microservice architecture always has latency problems, and a system is needed to troubleshoot the latency problem. Zipkin helps to solve the problem by collecting timing data. Zipkin also helps to search the data.</p>
<p>All registered services will report timing data to Zipkin. Zipkin creates a dependency diagram based on the received traced requests for each of the applications or services. Then, it can be used to analyze, spot an application that takes a long time to resolve, and fix it as needed.</p>
<p>When a request is made, the trace instrumentation will record tags, add the trace headers to the request, and finally record the timestamp. Then, the request is sent to the original destination and the response is sent back to the trace instrumentation, which then records the duration and shares the result with the Zipkin collector, which is responsible for storing the information.</p>
<p>By default, JHipster will generate the application with Zipkin disabled, but this can be enabled in the application-<kbd>&lt;env&gt;.yml</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Prometheus</h1>
                </header>
            
            <article>
                
<p>In a microservice architecture, we need to monitor our services continuously and any issues should cause alerts immediately. We need a separate service that will continuously monitor and alert us whenever something weird happens. </p>
<p>Prometheus consists of the following:</p>
<ul>
<li>Prometheus server, which is responsible for scraping and storing the time series data</li>
<li>Libraries to instrument the application code</li>
<li>A push gateway for supporting short-lived jobs</li>
<li>An exporter to Grafana to visualize data</li>
<li>An alert manager</li>
<li>Other support tools</li>
</ul>
<div class="packt_tip"><span>Prometheus is an alternative to JHipster console. It provides monitoring and alerting support. This requires running a Prometheus server separately for more information. To get started with Prometheus, visit </span><a href="https://prometheus.io/">https://prometheus.io/.</a></div>
<p>It provides multi-dimensional data models, which are time series and are identified by metric name and key-value pair. It has a flexible dynamic query language. It supports pulling time series out of the box and pushing time series via an intermediary gateway. It has multiple modes of graphing and dashboard support.</p>
<p>It is helpful in finding out problems when there is an outage. Since it is autonomous and does not depend on any remote services, the data is sufficient for finding where the infrastructure is broken.</p>
<p>It is helpful in recording the time series data and monitoring either via machine or highly dynamic Service Oriented Architecture.</p>
<p>Some things to consider when choosing Prometheus over JHipster Console are as follows:</p>
<ul>
<li><span>Prometheus is very good at exploiting the metrics of your application and will not monitor logs or traces. JHipster console, on the other hand, uses the ELK stack and monitors the logs, traces, and metrics of your application.</span></li>
<li><span>Prometheus can be used to query a huge amount of </span>time series<span> data. ELK on JHipster console is much more versatile in terms of tracking and searching the metrics and logs.</span></li>
<li>JHipster console uses Kibana to visualize the data while Prometheus uses Grafana (<a href="https://grafana.com/">https://grafana.com/</a>) to visualize the metrics.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JHipster UAA server</h1>
                </header>
            
            <article>
                
<p>JHipster user accounting and authorizing (UAA) services are merely an OAuth2 server that can be used for <em>centralized identity management</em>. In order to access the protected resource and also to avoid unwanted access to the APIs, there has to be an authorization server that authorizes the request and provides access to the resource. </p>
<p>OAuth2 is an authorization framework that provides access to the request based on tokens. Clients request access to a service; if the user is authorized, the application receives an authorization grant. After receiving the grant, the client requests a token from the authorization server. Once the token is received, the client will then request the resource server gets the necessary information.</p>
<p>JHipster supports both standard LDAP protocols and is invoked via JSON APIs.</p>
<div class="packt_quote packt_infobox">JHipster UAA is a user accounting and authorizing service for securing JHipster microservices using the OAuth2 authorization protocol.</div>
<p>JHipster UAA is a JHipster generated application consisting of user and role management. It also has a full-fledged OAuth2 authorization server. This is flexible and completely customizable.</p>
<p>Security is essential in a microservice architecture. The following are the basic requirements for securing microservices.</p>
<p>They should be authenticated in one place. Users should experience the entire experience as a single unit. Once the end user logs in to the application, they should be able to access whatever they have access to. They should hold session-related information throughout the time they are logged in to the system.</p>
<p>The security service should be stateless. Irrespective of the service, the security service should be capable of providing authentication for requests.</p>
<p>They also need to have the ability to provide authentication to machines and users. They should be able to distinguish them and trace them. Their function should be authorizing the incoming request rather than identifying the end user.</p>
<p>Since the underlying services are scalable, security services should also have the ability to scale up and down based on requirements.</p>
<p>They should, of course, be safe from attacks. Any known vulnerability should be fixed and updated as and when required.</p>
<p>The previous requirements were satisfied by using the OAuth2 protocol.</p>
<p>JHipster UAA is a centralized server that helps to authenticate and authorize users. They also have session-related information and the role-based access control with the help of a user and role management that is available inside the system. </p>
<p>The OAuth2 protocol, in general, provides the token for authenticating based on the details provided, which makes them stateless and able to authenticate a request from any source.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>So far, we have seen the benefits of a microservice architecture over monolithic applications, and the components that we need to run a microservice application such as JHipster Registry, Consul, Zuul, Zipkin, the ELK stack, Hystrix, Prometheus, and the JHipster UAA server. In our next chapter, we will see how to build microservices using JHipster. We will also learn how we can choose the previous components and how easy it is to set them up with JHipster. </p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>