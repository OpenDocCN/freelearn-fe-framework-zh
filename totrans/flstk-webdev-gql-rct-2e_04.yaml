- en: '*Chapter 3*: Connecting to the Database'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*：连接到数据库'
- en: Our backend and frontend can communicate, create new posts, and respond with
    a list of all posts while using fake data. The next step on our list will be to
    use a database, such as a SQL server, to serve as data storage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的后端和前端可以使用假数据来通信、创建新帖子，并响应所有帖子的列表。我们列表中的下一步将是使用数据库，如 SQL 服务器，作为数据存储。
- en: We want our backend to persist data to our SQL database by using Sequelize.
    Our Apollo Server should use this data for queries and mutations, as needed. For
    this to happen, we must implement database models for our GraphQL entities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用 Sequelize 将后端数据持久化到我们的 SQL 数据库。我们的 Apollo 服务器应根据需要使用这些数据来进行查询和突变。为了实现这一点，我们必须为我们的
    GraphQL 实体实现数据库模型。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using databases in GraphQL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GraphQL 中使用数据库
- en: Using Sequelize in Node.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Node.js 中使用 Sequelize
- en: Writing database models
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写数据库模型
- en: Seeding data with Sequelize
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Sequelize 种植数据
- en: Using Apollo with Sequelize
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Apollo 与 Sequelize
- en: Performing database migrations with Sequelize
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Sequelize 执行数据库迁移
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter03).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下 GitHub 仓库中找到：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter03)。
- en: Using databases in GraphQL
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 GraphQL 中使用数据库
- en: '**GraphQL** is a protocol for sending and receiving data. **Apollo** is one
    of the many libraries that you can use to implement that protocol. Neither GraphQL
    (in its specifications) nor Apollo works directly on the data layer. Where the
    data that you put into your response comes from, and where the data that you send
    with your request is saved, are up to the developer to decide.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**GraphQL** 是一种用于发送和接收数据的协议。**Apollo** 是您可以使用来实现该协议的许多库之一。无论是 GraphQL（在其规范中）还是
    Apollo，都不会直接在数据层上工作。您放入响应中的数据来源，以及您随请求发送的数据保存位置，由开发者决定。'
- en: This logic indicates that the database and the services that you use do not
    matter to Apollo, so long as the data that you respond with matches the GraphQL
    schema.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这条逻辑表明，数据库和您使用的服务对 Apollo 来说并不重要，只要您响应的数据与 GraphQL 模式相匹配。
- en: As we are living in the Node.js ecosystem in this project and book, it would
    be fitting to use MongoDB. MongoDB offers a great client library for Node.js and
    uses JavaScript as its native choice of language for interactions and querying.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目和书中，我们生活在 Node.js 生态系统之中，因此使用 MongoDB 是非常合适的。MongoDB 为 Node.js 提供了一个出色的客户端库，并且使用
    JavaScript 作为其与交互和查询的原生语言选择。
- en: The general alternative to a database system such as MongoDB is a typical MySQL
    server with proven stability and global usage. One case that I encounter frequently
    involves systems and applications relying on older code bases and databases that
    need upgrades. A great way to accomplish this is to get an over-layering API level
    with GraphQL. In this scenario, the GraphQL server receives all requests and,
    one by one, you can replace the existing code bases that the GraphQL server relies
    on. In these cases, it is helpful that GraphQL is database agnostic.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 这样的数据库系统的通用替代品是一个典型的 MySQL 服务器，它具有经过验证的稳定性和全球使用率。我经常遇到的一个案例是系统和应用程序依赖于较旧的代码库和数据库，需要进行升级。实现这一点的绝佳方法是获取一个
    GraphQL API 层的叠加。在这种情况下，GraphQL 服务器接收所有请求，并且逐个替换 GraphQL 服务器所依赖的现有代码库。在这些情况下，GraphQL
    的数据库无关性非常有帮助。
- en: In this book, we will use SQL via Sequelize to see this feature in a real-world
    use case. For future purposes, it will also help you to handle problems with existing
    SQL-based systems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将通过 Sequelize 使用 SQL 来查看现实世界用例中的此功能。为了未来的目的，这还将帮助您处理现有基于 SQL 的系统的问题。
- en: Installing MySQL for development
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为开发安装 MySQL
- en: MySQL is an excellent starting point for getting on track in a developmental
    career. It is also well suited for local development on your machine since the
    setup is easy.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 是在开发职业生涯中起步的绝佳起点。它也非常适合在您的机器上进行本地开发，因为设置简单。
- en: How to set up MySQL on your machine depends on your operating system. As we
    mentioned in [*Chapter 1*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017), *Preparing
    Your Development Environment*, we are assuming that you are using a Debian-based
    system. For this, you can use the following instructions. If you already have
    a working setup for MySQL or Apache, these commands may not work, or may not be
    required in the first place.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的机器上设置 MySQL 的方法取决于您的操作系统。正如我们在 [*第 1 章*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017)
    中提到的，*准备您的开发环境*，我们假设您正在使用基于 Debian 的系统。为此，您可以使用以下说明。如果您已经为 MySQL 或 Apache 设置了工作环境，这些命令可能不起作用，或者可能根本不需要。
- en: '**Tip**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: For other operating systems, there are great prebuilt packages. I recommend
    that all Windows users use XAMPP and that Mac users use MAMP. These offer an easy
    installation process for what we did manually on Linux. They also implement MySQL,
    Apache, and PHP, including phpMyAdmin.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他操作系统，有优秀的预构建软件包。我建议所有 Windows 用户使用 XAMPP，Mac 用户使用 MAMP。这些提供了在 Linux 上手动执行的操作的简单安装过程。它们还实现了
    MySQL、Apache 和 PHP，包括 phpMyAdmin。
- en: '**Important Note**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Do not follow these instructions when setting up a real SQL server for public
    and production use. A professional setup includes many security features to protect
    you against attacks. This installation should only be used in development, on
    your local machine.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置用于公共和生产的真实 SQL 服务器时，不要遵循这些说明。专业的设置包括许多安全功能来保护您免受攻击。此安装仅应在开发环境中，在您的本地机器上使用。
- en: 'Execute the following steps to get MySQL running:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以启动 MySQL：
- en: 'First, you should always install all the updates available for your system:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您应该始终安装系统上可用的所有更新：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We want to install MySQL and a GUI to see what we have inside our database.
    The most common GUI for a MySQL server is phpMyAdmin. For this, you need to install
    a web server and PHP. We are going to install Apache as our web server.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们希望安装 MySQL 和一个 GUI 来查看我们数据库内部的内容。MySQL 服务器最常用的 GUI 是 phpMyAdmin。为此，您需要安装一个
    Web 服务器和 PHP。我们将安装 Apache 作为我们的 Web 服务器。
- en: Important Note
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: If, at any point in the process, you receive an error stating that the package
    could not be found, ensure that your system is Debian-based. The installation
    process can differ on other systems. You can easily search for the matching package
    for your system on the internet.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在过程中任何时刻收到一个错误，表明找不到该软件包，请确保您的系统是基于 Debian 的。在其他系统上的安装过程可能会有所不同。您可以在互联网上轻松搜索适合您系统的匹配软件包。
- en: 'Install all the necessary dependencies with the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装所有必要的依赖项：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After the installation, you will need to run the MySQL setup in the root shell.
    You will have to enter the root password for this. Alternatively, you can run
    `sudo -i`:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，您需要在 root shell 中运行 MySQL 设置。您将需要输入 root 密码。或者，您可以运行 `sudo -i`：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, you can execute the MySQL installation command; follow the steps as prompted:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以执行 MySQL 安装命令；按照提示步骤进行操作：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can ignore most of these steps and security settings but be careful when
    you are asked for the root password of your MySQL instance.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以忽略这些步骤中的大部分以及安全设置，但在被要求输入您的 MySQL 实例的 root 密码时要小心。
- en: 'We must create a separate user for development aside from the root user. You
    are discouraged from using the root user at all. Log into our MySQL server with
    the root user to accomplish this:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须为开发创建一个与 root 用户分开的单独用户。我们不鼓励您使用 root 用户。使用 root 用户登录我们的 MySQL 服务器以完成此操作：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, run the following SQL command.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行以下 SQL 命令。
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can install phpMyAdmin since our MySQL server has been set up. You will
    be asked for a web server when executing the following command. Select `apache2`
    with the spacebar and navigate to **ok** by hitting the *Tab* key. When you're
    asked for it, select the automatic setup method for phpMyAdmin. You should not
    do this manually.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的 MySQL 服务器已经设置，您可以安装 phpMyAdmin。在执行以下命令时，您将被要求选择 Web 服务器。使用空格键选择 `apache2`，然后按
    *Tab* 键导航到 **ok**。当被要求时，选择 phpMyAdmin 的自动设置方法。您不应手动进行此操作。
- en: 'Furthermore, phpMyAdmin will want you to enter a password. I recommend that
    you choose the same password that you chose for the root user:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，phpMyAdmin 将要求您输入密码。我建议您选择与 root 用户相同的密码：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After the installation, we will need to set up Apache to serve phpMyAdmin.
    The following `ln` command creates a symbolic link in the root folder of the Apache
    public `HTML` folder. Apache will now serve phpMyAdmin:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，我们需要设置Apache以服务phpMyAdmin。以下`ln`命令在Apache公共`HTML`文件夹的根目录中创建了一个符号链接。现在，Apache将服务phpMyAdmin：
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we can visit phpMyAdmin under `http://localhost/phpmyadmin` and log in
    with the newly created user. This should look as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`http://localhost/phpmyadmin`下访问phpMyAdmin，并使用新创建的用户登录。这应该看起来如下所示：
- en: '![Figure 3.1 – phpMyAdmin'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – phpMyAdmin'
- en: '](img/Figure_3.01_B17337.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.01_B17337.jpg)'
- en: Figure 3.1 – phpMyAdmin
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – phpMyAdmin
- en: With that, we have installed the database for our development environment.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式，我们已经为我们的开发环境安装了数据库。
- en: phpMyAdmin chooses the language according to your environment, so it might differ
    slightly from what's shown in the preceding screenshot.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: phpMyAdmin会根据您的环境选择语言，因此它可能与前一个截图显示的略有不同。
- en: Creating a database in MySQL
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在MySQL中创建数据库
- en: Before we start implementing our backend, we need to add a new database that
    we can use.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现后端之前，我们需要添加一个新的数据库，我们可以使用它。
- en: You are free to do this via the command line or phpMyAdmin. As we have just
    installed phpMyAdmin, we are going to use it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过命令行或phpMyAdmin来做这件事。因为我们刚刚安装了phpMyAdmin，我们将使用它。
- en: 'You can run raw SQL commands in the **SQL** tab of phpMyAdmin. The corresponding
    command to create a new database is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在phpMyAdmin的**SQL**标签页中运行原始SQL命令。创建新数据库的相应命令如下：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Otherwise, you can follow the next set of steps to use the graphical method.
    In the left-hand panel, click on the **New** button.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您可以按照下一组步骤使用图形方法。在左侧面板中，点击**新建**按钮。
- en: 'You will be presented with a screen like the following. It will show all the
    databases, including their collation of your MySQL server:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个如下所示的屏幕。它将显示所有数据库，包括它们的MySQL服务器的校对：
- en: '![Figure 3.2 – phpMyAdmin databases'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – phpMyAdmin数据库'
- en: '](img/Figure_3.02_B17337.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.02_B17337.jpg)'
- en: Figure 3.2 – phpMyAdmin databases
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – phpMyAdmin数据库
- en: Enter a database name, such as `graphbook_dev`, and then choose the `uft8_general_ci`
    collation. After doing so, click on **Create**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个数据库名称，例如`graphbook_dev`，然后选择`utf8_general_ci`校对。完成这些操作后，点击**创建**。
- en: You will see a page that says **No tables found in database**, which is correct.
    This will change later, when we have implemented our database models, such as
    posts and users.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个页面，上面写着**数据库中未找到表**，这是正确的。在我们实现了数据库模型，如帖子（posts）和用户（users）之后，这将会改变。
- en: In the next chapter, we will start to set up Sequelize in Node.js and connect
    it to our SQL server.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始设置Sequelize在Node.js中的配置，并将其连接到我们的SQL服务器。
- en: Integrating Sequelize into our Node.js stack
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Sequelize集成到我们的Node.js堆栈中
- en: We have just set up a MySQL database, and we want to use it inside of our Node.js
    backend. There are many libraries to connect to and query your MySQL database.
    We are going to use Sequelize in this book.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚设置了一个MySQL数据库，我们想在我们的Node.js后端中使用它。有许多库可以连接和查询您的MySQL数据库。在这本书中，我们将使用Sequelize。
- en: Alternative Object–Relational Mappers (ORMs)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 替代对象关系映射器（ORM）
- en: Alternatives include Waterline ORM and js-data, which offer the same functionalities
    as Sequelize. What is great about these is that they not only offer SQL dialects,
    but also feature database adapters for MongoDB, Redis, and more. So, if you need
    an alternative, check them out.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 替代方案包括Waterline ORM和js-data，它们提供了与Sequelize相同的功能。这些方案的好处是，它们不仅提供SQL方言，还提供了MongoDB、Redis等数据库适配器。因此，如果您需要替代方案，请查看它们。
- en: Sequelize is an ORM for Node.js. It supports the PostgreSQL, MySQL, SQLite,
    and MSSQL standards.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize是Node.js的ORM。它支持PostgreSQL、MySQL、SQLite和MSSQL标准。
- en: 'Install Sequelize in your project via `npm`. We will also install a second
    package, called `mysql2`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`npm`在您的项目中安装Sequelize。我们还将安装第二个包，称为`mysql2`：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `mysql2` package allows Sequelize to speak with our MySQL server.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql2`包允许Sequelize与我们的MySQL服务器通信。'
- en: Sequelize is just a wrapper around the various libraries for the different database
    systems. It offers great features for intuitive model usage, as well as functions
    for creating and updating database structures and inserting development data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize是围绕不同数据库系统的各种库的包装器。它提供了直观模型使用的出色功能，以及创建和更新数据库结构以及插入开发数据的函数。
- en: Typically, you would run `npx sequelize-cli init` before starting with the database
    connection or models, but I prefer a more custom approach. From my point of view,
    this is a bit cleaner. This approach is also why we are setting up the database
    connection in an extra file and are not relying on boilerplate code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会在开始数据库连接或模型之前运行`npx sequelize-cli init`，但我更喜欢一种更定制的方法。从我的角度来看，这要干净一些。这也是我们为什么在额外的文件中设置数据库连接而不是依赖模板代码的原因。
- en: Setting Up Sequelize Traditionally
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 传统设置Sequelize
- en: You can look at the official tutorial in the Sequelize documentation if you
    want to see how it would usually be done. The approach that we are taking and
    the one from the tutorial do not differ too much, but it is always good to see
    another way of doing things. The documentation can be found at [https://sequelize.org/master/manual/migrations.html](https://sequelize.org/master/manual/migrations.html).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看通常是如何做的，可以查看Sequelize文档中的官方教程。我们采取的方法和教程中的方法差异不大，但总是看到另一种做事的方式是好的。文档可以在[https://sequelize.org/master/manual/migrations.html](https://sequelize.org/master/manual/migrations.html)找到。
- en: Let's start by setting Sequelize up in our backend.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在后台设置Sequelize开始。
- en: Connecting to a database with Sequelize
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Sequelize连接到数据库
- en: 'The first step is to initialize the connection from Sequelize to our MySQL
    server. To do this, we will create a new folder and file, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是初始化Sequelize到我们的MySQL服务器的连接。为此，我们将创建一个新的文件夹和文件，如下所示：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside the `index.js` database, we will establish a connection to our database
    with Sequelize. Internally, Sequelize relies on the `mysql2` package, but we do
    not use it ourselves, which is very convenient:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.js`数据库内部，我们将使用Sequelize与我们的数据库建立连接。内部，Sequelize依赖于`mysql2`包，但我们自己并不使用它，这非常方便：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, we load Sequelize from `node_modules` and then create an instance
    of it. The following properties are important for Sequelize:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们从`node_modules`加载Sequelize，然后创建其实例。以下属性对Sequelize很重要：
- en: We pass the database name as the first parameter, which we just created.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将数据库名称作为第一个参数传递，这是我们刚刚创建的。
- en: The second and third parameters are the credentials of our `devuser`. Replace
    them with the username and password that you entered for your database. `devuser`
    has permission to access all the databases in our MySQL server. This makes development
    a lot easier.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个和第三个参数是我们`devuser`的凭证。用您为数据库输入的用户名和密码替换它们。`devuser`有权访问我们MySQL服务器中的所有数据库，这使得开发变得容易得多。
- en: The fourth parameter is a general options object that can hold many more properties.
    The preceding object is an example configuration.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数是一个通用选项对象，可以包含更多属性。前面的对象是一个示例配置。
- en: The `host` option of our MySQL database is our local machine alias, `localhost`.
    If this is not the case, you can also specify the IP or URL of the MySQL server.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们MySQL数据库的`host`选项是我们的本地机器别名，`localhost`。如果不是这种情况，您也可以指定MySQL服务器的IP或URL。
- en: '`dialect` is, of course, `mysql`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，`dialect`是`mysql`。
- en: With the `pool` option, you tell Sequelize the configuration for every database
    connection. The preceding configuration allows for a minimum of zero connections,
    which means that Sequelize should not maintain one connection, but should create
    a new one whenever it is needed. The maximum number of connections is five. This
    option also relates to the number of replica sets that your database system has.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pool`选项，您告诉Sequelize每个数据库连接的配置。前面的配置允许最小连接数为零，这意味着Sequelize不应该维护一个连接，而应该在其需要时创建一个新的连接。最大连接数为五个。此选项还与您的数据库系统拥有的副本集数量相关。
- en: The `idle` field of the `pool` option specifies how long a connection can be
    unused before it gets closed and removed from the pool of active connections.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`pool`选项中的`idle`字段指定了连接在关闭并被从活动连接池中移除之前可以多久未被使用。'
- en: When trying to establish a new connection to our MySQL server, the timeout before
    the connection is aborted is defined by the `acquire` option. In cases in which
    a connection cannot be created, this option helps stop your server from freezing.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当尝试建立到我们的MySQL服务器的新的连接时，如果连接被中止，`acquire`选项定义了超时时间。在无法创建连接的情况下，此选项有助于防止您的服务器冻结。
- en: Executing the preceding code will instantiate Sequelize and will successfully
    create a connection to our MySQL server. Going further, we need to handle multiple
    databases for every environment that our application can run in, from development
    to production. You will see that in the next section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码将实例化Sequelize并成功创建到我们的MySQL服务器的连接。进一步来说，我们需要为我们的应用程序可以运行的每个环境（从开发到生产）处理多个数据库。你将在下一节中看到这一点。
- en: Using a configuration file with Sequelize
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Sequelize配置文件
- en: The previous setup for our database connection with Sequelize is fine, but it
    is not made for later deployment. The best option is to have a separate configuration
    file that is read and used according to the environment that the server is running
    in.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用Sequelize进行数据库连接的设置是可行的，但它并不是为后续部署而设计的。最佳选择是有一个独立的配置文件，该文件根据服务器运行的环境进行读取和使用。
- en: 'For this, create a new `index.js` file inside a separate folder (called `config`),
    next to the `database` folder:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，在`database`文件夹旁边（称为`config`）的单独文件夹中创建一个新的`index.js`文件：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Your sample configuration should look like the following code if you have followed
    the instructions for creating a MySQL database. The only thing that we did here
    was copy our current configuration into a new object indexed with the `development`
    or `production` environment:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循了创建MySQL数据库的说明，你的样本配置应该如下代码所示。我们在这里所做的唯一一件事是将我们的当前配置复制到一个新的对象中，该对象以`development`或`production`环境为索引：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Sequelize expects a `config.json` file inside this folder by default, but this
    setup will allow us to take on a more custom approach in later chapters. The `development`
    environment directly stores the credentials for your database, whereas the `production`
    configuration uses environment variables to fill them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize默认期望在这个文件夹中有一个`config.json`文件，但这个设置将允许我们在后面的章节中采用更定制的方法。`development`环境直接存储数据库的凭证，而`production`配置使用环境变量来填充它们。
- en: We can remove the configuration that we hardcoded earlier and replace the contents
    of our `database/index.js` file to require our `configFile` instead.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以移除之前硬编码的配置，并将我们的`database/index.js`文件的内容替换为要求使用`configFile`。
- en: 'This should look as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来如下：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we are using the `NODE_ENV` environment variable to get
    the environment that the server is running in. We read the `config` file and pass
    the correct configuration to the Sequelize instance. The environment variable
    will allow us to switch to a new environment, such as `production`, later in this
    book.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`NODE_ENV`环境变量来获取服务器正在运行的环境。我们读取`config`文件并将正确的配置传递给Sequelize实例。环境变量将允许我们在本书的稍后部分切换到新的环境，例如`production`。
- en: The Sequelize instance is then exported for use throughout our application.
    We use a special `db` object for this. You will see why we are doing this later.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Sequelize实例被导出以供我们整个应用程序使用。我们使用一个特殊的`db`对象来做这件事。你将在稍后看到我们为什么要这样做。
- en: Next, you will learn how to generate and write models and migrations for all
    the entities that our application will have.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何为应用程序将拥有的所有实体生成和编写模型和迁移。
- en: Writing database models
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写数据库模型
- en: After creating a connection to our MySQL server via Sequelize, we want to use
    it. However, our database is missing a table or structure that we can query or
    manipulate. Creating those is the next thing that we need to do.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Sequelize创建到我们的MySQL服务器的连接后，我们希望使用它。然而，我们的数据库缺少一个我们可以查询或操作的表或结构。创建这些是我们接下来需要做的事情。
- en: 'Currently, we have two GraphQL entities: `User` and `Post`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有两个GraphQL实体：`User`和`Post`。
- en: Sequelize lets us create a database schema for each of our GraphQL entities.
    The schema is validated when we insert or update rows in our database. We already
    wrote a schema for GraphQL in the `schema.js` file, which is used by Apollo Server,
    but we need to create a second one for our database. The field types, as well
    as the fields themselves, can vary between the database and the GraphQL schema.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize允许我们为我们的每个GraphQL实体创建数据库模式。当我们在数据库中插入或更新行时，该模式会被验证。我们已经在`schema.js`文件中为GraphQL编写了一个模式，该文件由Apollo
    Server使用，但我们需要为我们的数据库创建第二个模式。字段类型以及字段本身可能在数据库和GraphQL模式之间有所不同。
- en: GraphQL schemas can have more fields than our database model, or vice versa.
    Perhaps you do not want to export all the data from your database through the
    API, or maybe you want to generate data for your GraphQL API on the fly when you're
    requesting data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL模式可能比我们的数据库模型有更多的字段，或者相反。也许你不想通过API导出数据库中的所有数据，或者当你请求数据时，可能想动态地为你的GraphQL
    API生成数据。
- en: 'Let''s create the first model for our posts. Create two new folders (one called
    `models` and another called `migrations`) next to the `database` folder:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的帖子创建第一个模型。在`database`文件夹旁边创建两个新文件夹（一个叫`models`，另一个叫`migrations`）：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Creating each model in a separate file is much cleaner than having one big file
    for all the models.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个模型分别放在单独的文件中，比所有模型放在一个大文件中要干净得多。
- en: Your first database model
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的第一个数据库模型
- en: 'We will use the Sequelize CLI to generate our first database model. Install
    it globally with the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Sequelize CLI生成我们的第一个数据库模型。使用以下命令全局安装它：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This gives you the ability to run the `sequelize` command inside your Terminal.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你能够在终端中运行`sequelize`命令。
- en: 'The Sequelize CLI allows us to generate the model automatically. This can be
    done by running the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize CLI允许我们自动生成模型。这可以通过运行以下命令来完成：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Sequelize expects us to run the command in the folder where we have run `sequelize
    init` by default. Our file structure is different because we have two layers with
    `src/server`. For this reason, we specify the path manually with the first two
    parameters; that is, `--models-path` and `--migrations-path`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize期望我们在运行`sequelize init`的默认文件夹中运行命令。由于我们的文件结构不同，因为我们有两个`src/server`层，所以我们手动指定路径，即前两个参数；即`--models-path`和`--migrations-path`。
- en: The `--name` parameter gives our model a name under which it can be used. The
    `--attributes` option specifies the fields that the model should include.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`--name`参数为我们的模型提供了一个名称，该名称可以用于使用。`--attributes`选项指定模型应包含的字段。'
- en: Tip
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you are customizing your setup, you may want to know about other options
    that the CLI offers. You can view the manual for every command easily by appending
    `--help` as an option: `sequelize model:generate --help`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在自定义你的设置，你可能想了解CLI提供的其他选项。你可以通过添加`--help`选项轻松查看每个命令的说明：`sequelize model:generate
    --help`。
- en: This command creates a `post.js` model file in your `models` folder and a database
    migration file, named `XXXXXXXXXXXXXX-create-post.js`, in your `migrations` folder.
    The `X` icons indicate the timestamp when you're generating the files with the
    CLI. You will see how migrations work in the next section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令会在你的`models`文件夹中创建一个`post.js`模型文件，并在你的`migrations`文件夹中创建一个名为`XXXXXXXXXXXXXX-create-post.js`的数据库迁移文件。`X`图标表示你使用CLI生成文件时的日期和时间戳。你将在下一节中看到迁移是如何工作的。
- en: 'The following model file was created for us:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们为我们创建的模型文件：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we are creating the `Post` class and extending the `Model` class from
    Sequelize. Then, we are using the `init` function of Sequelize to create a database
    model:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建`Post`类，并从Sequelize扩展`Model`类。然后，我们使用Sequelize的`init`函数创建数据库模型：
- en: The first parameter is the model attributes.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是模型属性。
- en: The second parameter is an `option` object, where the `sequelize` connection
    instance and model name are passed.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是一个`option`对象，其中包含了`sequelize`连接实例和模型名称。
- en: Model Customization
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模型定制
- en: There are many more options that Sequelize offers us to customize our database
    models. If you want to look up which options are available, you can find them
    at [https://sequelize.org/master/manual/model-basics.html](https://sequelize.org/master/manual/model-basics.html).
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Sequelize为我们提供了许多其他选项来定制我们的数据库模型。如果你想查找哪些选项可用，可以在[https://sequelize.org/master/manual/model-basics.html](https://sequelize.org/master/manual/model-basics.html)找到它们。
- en: A `post` object has the `id`, `text`, and `user` properties. The user will be
    a separate model, as shown in the GraphQL schema. Consequently, we only need to
    configure `id` and `text` as columns of a post.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`post`对象具有`id`、`text`和`user`属性。用户将是一个单独的模型，如GraphQL模式所示。因此，我们只需要将`id`和`text`配置为帖子的列。
- en: '`id` is the key that uniquely identifies a data record from our database. We
    do not specify this when running the `model:generate` command because it is generated
    by MySQL automatically.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`是我们数据库中唯一标识数据记录的键。在运行`model:generate`命令时，我们不指定它，因为MySQL会自动生成。'
- en: The `text` column is just a MySQL `TEXT` field that allows us to write long
    posts. Alternatively, there are other MySQL field types, with `MEDIUMTEXT`, `LONGTEXT`,
    and `BLOB`, which could save more characters. A regular `TEXT` column should be
    fine for our use case.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`text` 列只是一个允许我们写入长帖子的 MySQL `TEXT` 字段。作为替代，还有其他 MySQL 字段类型，如 `MEDIUMTEXT`、`LONGTEXT`
    和 `BLOB`，可以保存更多字符。对于我们的用例，一个常规的 `TEXT` 列应该就足够了。'
- en: The Sequelize CLI created a model file, exporting a function that, after execution,
    returns the real database model. You will soon see why this is a great way of
    initializing our models.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize CLI 创建了一个模型文件，导出一个函数，执行后返回实际的数据库模型。你很快就会看到为什么这是一种初始化我们模型的好方法。
- en: Let's take a look at the migration file that is also created by the CLI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 CLI 也创建的迁移文件。
- en: Your first database migration
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的第一个数据库迁移
- en: So far, MySQL has not known anything about our plan to save posts inside of
    it. Our database tables and columns need to be created, hence why the migration
    file was created.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，MySQL 还不知道我们在其中保存帖子计划。我们的数据库表和列需要被创建，这就是为什么需要创建迁移文件。
- en: 'A migration file has multiple advantages, such as the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件具有多个优点，如下所示：
- en: Migrations allow us to track database changes through our regular version control
    system, such as Git or SVN. Every change to our database structure should be covered
    in a migration file.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移使我们能够通过常规版本控制系统（如 Git 或 SVN）跟踪数据库更改。我们数据库结构的每次更改都应该包含在迁移文件中。
- en: Migration files enable us to write updates that automatically apply database
    changes for new versions of our application.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移文件使我们能够编写更新，这些更新可以自动应用于我们应用程序的新版本中的数据库更改。
- en: 'Our first migration file creates a `Posts` table and adds all the required
    columns, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个迁移文件创建了一个 `Posts` 表，并添加了所有必需的列，如下所示：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By convention, the model name is pluralized in migrations, but it is singular
    inside model definitions. Our table names are also pluralized. Sequelize offers
    options to change this.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，迁移中的模型名称是复数形式，但在模型定义中是单数形式。我们的表名也是复数形式。Sequelize 提供了更改此设置的选择。
- en: 'A migration has two properties, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移有两个属性，如下所示：
- en: The `up` property states what should be done when running the migration.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`up` 属性说明了在运行迁移时应执行的内容。'
- en: The `down` property states what is run when undoing a migration.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`down` 属性说明了在撤销迁移时执行的内容。'
- en: As we mentioned previously, the `id` and `text` columns are created, as well
    as two additional `datetime` columns, to save the creation and update time.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，创建了 `id` 和 `text` 列，以及两个额外的 `datetime` 列，用于保存创建和更新时间。
- en: The `id` field has set `autoIncrement` and `primaryKey` to `true`. `id` will
    count upward, from one to nearly infinite, for each post in our table. This `id`
    uniquely identifies posts for us. Passing `allowNull` with `false` disables this
    feature so that we can insert a row with an empty field value.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` 字段已将 `autoIncrement` 和 `primaryKey` 设置为 `true`。`id` 将为表中每个帖子向上计数，从一几乎无限大。这个
    `id` 为我们唯一标识帖子。通过将 `allowNull` 设置为 `false`，禁用了此功能，这样我们就可以插入一个空字段值的行。'
- en: 'To execute this migration, we will use the Sequelize CLI again, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此迁移，我们将再次使用 Sequelize CLI，如下所示：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Look inside of phpMyAdmin. Here, you will find the new table, called `posts`.
    The structure of the table should look as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 phpMyAdmin 中查看。在这里，你会找到名为 `posts` 的新表。表的结构应该如下所示：
- en: '![Figure 3.3 – Posts table structure'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.3 – Posts table structure]'
- en: '](img/Figure_3.03_B17337.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.03_B17337.jpg]'
- en: Figure 3.3 – Posts table structure
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.3 – Posts table structure
- en: All the columns were created as we desired.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所有列都按照我们的期望创建。
- en: Furthermore, two additional fields – `createdAt` and `updatedAt` – were created.
    These two fields tell us when a row was either created or updated. The fields
    were created by Sequelize automatically. If you do not want this, you can set
    the `timestamps` property in the model to `false`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还创建了两个额外的字段 – `createdAt` 和 `updatedAt`。这两个字段告诉我们行是何时被创建或更新的。这些字段是由 Sequelize
    自动创建的。如果你不希望这样，可以将模型中的 `timestamps` 属性设置为 `false`。
- en: 'Every time you use Sequelize and its migration feature, you will have an additional
    table called `sequelizemeta`. The contents of the table should look as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用 Sequelize 和其迁移功能时，你将有一个名为 `sequelizemeta` 的额外表。该表的内容应该如下所示：
- en: '![Figure 3.4 – Migrations table'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.4 – Migrations table]'
- en: '](img/Figure_3.04_B17337.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.04_B17337.jpg]'
- en: Figure 3.4 – Migrations table
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.4 – Migrations table]'
- en: Sequelize saves every migration that has been executed. If we add more fields
    in development or a news release cycle, we can write a migration that runs all
    the table-altering statements for us as an update. Sequelize skips all the migrations
    that are saved inside the meta table.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 保存了所有已执行的迁移。如果我们开发或新发布周期中添加了更多字段，我们可以编写一个迁移来为我们运行所有表更改语句作为更新。Sequelize
    跳过了保存在元表中的所有迁移。
- en: One major step is to bind our model to Sequelize. This process can be automated
    by running `sequelize init`, but understanding it will teach us way more than
    relying on premade boilerplate commands.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一个主要步骤是将我们的模型绑定到 Sequelize。这个过程可以通过运行 `sequelize init` 自动化，但理解它将教会我们比依赖预制的样板命令多得多的东西。
- en: Importing models with Sequelize
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Sequelize 导入模型
- en: We want to import all the database models at once, in a central file. Our database
    connection instantiator will then rely on this file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望一次性导入所有数据库模型到一个中央文件。然后，我们的数据库连接生成器将依赖于这个文件。
- en: 'Create an `index.js` file in the `models` folder and use the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `models` 文件夹中创建一个 `index.js` 文件，并使用以下代码：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding logic will also be generated when running `sequelize init`, but
    this way, the database connection is set up in a separate file from loading the
    models. Usually, this would happen in just one file when using the Sequelize boilerplate
    code. Furthermore, we have introduced some webpack-specific configurations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行 `sequelize init` 时，前面的逻辑也会生成，但这样，数据库连接是在一个单独的文件中设置的，而不是在加载模型时。通常，当使用 Sequelize
    样板代码时，这会在一个文件中完成。此外，我们还引入了一些 webpack 特定的配置。
- en: 'To summarize what happens in the preceding code, we search for all the files
    ending with `.js` in the same folder as the current file and load them all with
    the `require.context` statement. In development, we must execute the `babel-plugin-require-context-hook/register`
    Hook to load the `require.context` function at the top. This package must be installed
    with `npm`, with the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面代码中发生的事情，我们搜索与当前文件相同的文件夹中所有以 `.js` 结尾的文件，并使用 `require.context` 语句加载它们。在开发中，我们必须执行
    `babel-plugin-require-context-hook/register` 钩子来在顶部加载 `require.context` 函数。此包必须使用
    `npm` 安装，以下命令：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We need to load the Babel plugin at the start of our development server, so,
    open the `package.json` file and edit the `server` script, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在开发服务器的开始时加载 Babel 插件，因此，打开 `package.json` 文件并编辑 `server` 脚本，如下所示：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When the plugin is loaded and we run the `require('babel-plugin-require-context-hook/register')()`
    function, the `require.context` method becomes available for us. Make sure that
    you set the `NODE_ENV` variable to `development`; otherwise, this won't work.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当插件加载并运行 `require('babel-plugin-require-context-hook/register')()` 函数时，`require.context`
    方法对我们可用。确保您将 `NODE_ENV` 变量设置为 `development`；否则，这不会工作。
- en: In production, the `require.context` function is included in the generated bundle
    of webpack.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，`require.context` 函数包含在 webpack 生成的包中。
- en: 'The loaded model files export a function with the following two parameters:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 加载的模型文件导出一个具有以下两个参数的函数：
- en: Our Sequelize instance, after creating a connection to our database
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建与我们的数据库连接后，我们的 Sequelize 实例
- en: The `sequelize` class itself, including the data types it offers, such as integer
    or text
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sequelize` 类本身，包括它提供的各种数据类型，如整数或文本'
- en: Running the exported functions imports the actual Sequelize model. Once all
    the models have been imported, we loop through them and check whether they have
    a function called `associate`. If this is the case, we execute the `associate`
    function and, through that, we establish relationships between multiple models.
    Currently, we have not set up an association, but that will change later in this
    chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 运行导出的函数导入实际的 Sequelize 模型。一旦所有模型都已导入，我们就遍历它们并检查它们是否有一个名为 `associate` 的函数。如果是这样，我们执行
    `associate` 函数，并通过这种方式在多个模型之间建立关系。目前，我们还没有设置关联，但这一点将在本章的后面改变。
- en: 'Now, we want to use our models. Go back to the `index.js` database file and
    import all the models through the aggregated `index.js` file that we just created:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要使用我们的模型。回到 `index.js` 数据库文件，并通过我们刚刚创建的聚合 `index.js` 文件导入所有模型：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Before exporting the `db` object at the end of the file, we need to run the
    `models` wrapper to read all model `.js` files. We pass our Sequelize instance
    as a parameter, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾导出 `db` 对象之前，我们需要运行 `models` 包装器来读取所有模型 `.js` 文件。我们按照以下方式传递我们的 Sequelize
    实例作为参数：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The new database object in the preceding command has `sequelize` and `models`
    as properties. Under `models`, you can find the `Post` model and every new model
    that we are going to add later.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令中的新数据库对象有 `sequelize` 和 `models` 属性。在 `models` 下，你可以找到 `Post` 模型以及我们稍后将要添加的每个新模型。
- en: The database `index.js` file is ready and can now be used. You should import
    this file only once because it can get messy when you're creating multiple instances
    of Sequelize. The pool functionality won't work correctly, and we will end up
    with more connections than the maximum of five that we specified earlier.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的 `index.js` 文件已经准备好，现在可以使用了。你应该只导入这个文件一次，因为当你创建多个 Sequelize 实例时，这可能会变得混乱。池功能将无法正常工作，我们最终会拥有比我们之前指定的五个最大连接数更多的连接。
- en: 'We must create the global database instance in the `index.js` file of the root
    server folder. Add the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在根服务器文件夹的 `index.js` 文件中创建全局数据库实例。添加以下代码：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We require the `database` folder and the `index.js` file inside this folder.
    Loading the file instantiates the Sequelize object, including all the database
    models.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入 `database` 文件夹以及该文件夹内的 `index.js` 文件。加载该文件将实例化 Sequelize 对象，包括所有数据库模型。
- en: Going forward, we want to query some data from our database via the GraphQL
    API that we implemented in [*Chapter 2*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032),
    *Setting Up GraphQL with Express.js*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们想要通过我们在 [*第 2 章*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032) 中实现的
    GraphQL API 查询数据库中的某些数据，*使用 Express.js 设置 GraphQL*。
- en: Seeding data with Sequelize
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sequelize 种植数据
- en: We should fill the empty `Posts` table with our fake data. To accomplish this,
    we will use Sequelize's feature for seeding data to our database.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该用我们的假数据填充空的 `Posts` 表。为了完成这个任务，我们将使用 Sequelize 的数据种植功能来向数据库中种植数据。
- en: 'Create a new folder called `seeders`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `seeders` 的新文件夹：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we can run our next Sequelize CLI command to generate a boilerplate file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行下一个 Sequelize CLI 命令来生成一个模板文件：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Seeders are great for importing test data into a database for development.
    Our `seed` file has the timestamp and the words `fake-posts` in the name, and
    should look as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 种子非常适合将测试数据导入数据库进行开发。我们的 `seed` 文件有时间和 `fake-posts` 这两个词，应该看起来如下：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As shown in the preceding code snippet, nothing is done here. It is just an
    empty boilerplate file. We need to edit this file to create the fake posts that
    we already had in our backend. This file looks like our migration from the previous
    section. Replace the contents of the file with the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，这里没有做任何事情。它只是一个空的模板文件。我们需要编辑这个文件来创建我们已经在后端拥有的假帖子。这个文件看起来就像我们上一节中的迁移。将文件内容替换为以下代码：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `up` migration, we are bulk inserting two posts through `queryInterface`
    and its `bulkInsert` command. For this, we will pass an array of posts, excluding
    the `id` property and the associated user. This `id` is created automatically,
    and the user is saved in a separate table later. `queryInterface` of Sequelize
    is the general interface that Sequelize uses to talk to all databases.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `up` 迁移中，我们通过 `queryInterface` 和它的 `bulkInsert` 命令批量插入两个帖子。为此，我们将传递一个帖子数组，不包括
    `id` 属性和关联的用户。这个 `id` 将自动创建，用户稍后保存在单独的表中。Sequelize 的 `queryInterface` 是 Sequelize
    用来与所有数据库通信的通用接口。
- en: In our seed file, we need to add the `createdAt` and `updatedAt` fields since
    Sequelize does not set up default values for the timestamp columns in MySQL. In
    reality, Sequelize takes care of the default values of those fields by itself,
    but not when seeding data. If you do not provide these values, the seed will fail,
    because `NULL` is not allowed for `createdAt` and `updatedAt`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的种子文件中，我们需要添加 `createdAt` 和 `updatedAt` 字段，因为 Sequelize 不会为 MySQL 中的时间戳列设置默认值。实际上，Sequelize
    会自己处理这些字段的默认值，但在种植数据时不会。如果你不提供这些值，种子将失败，因为 `createdAt` 和 `updatedAt` 不允许为 `NULL`。
- en: The `down` migration bulk deletes all the rows in the table since this is the
    apparent reverse action of the `up` migration.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`down` 迁移会批量删除表中的所有行，因为这显然是 `up` 迁移的逆操作。'
- en: 'Execute all the seeds from the `seeders` folder with the following command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令执行 `seeders` 文件夹中的所有种子：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Sequelize does not check or save whether a seed has been run already, as we
    are doing it with the preceding command. This means that you can run seeds multiple
    times if you want to.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 不会检查或保存是否已经运行了种子，因为我们使用前述命令进行操作。这意味着如果你想的话，可以多次运行种子。
- en: 'The following screenshot shows a filled-in `Posts` table:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了填充后的 `Posts` 表：
- en: '![Figure 3.5 – The Posts table with seed data'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 带有种子数据的帖子表'
- en: '](img/Figure_3.05_B17337.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.05_B17337.jpg)'
- en: Figure 3.5 – The Posts table with seed data
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 带有种子数据的帖子表
- en: The demo posts are now inside our database.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 示例帖子现在在我们的数据库中。
- en: We will cover how to use Sequelize with our Apollo Server, as well as how to
    add the relationship between the user and their posts, in the next section.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍如何使用 Sequelize 与我们的 Apollo Server，以及如何添加用户与其帖子之间的关系。
- en: Using Sequelize with GraphQL
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sequelize 与 GraphQL
- en: The database object is initialized upon starting the server within the root
    `index.js` file. We pass it from this global location down to the spots where
    we rely on the database. This way, we do not import the database file repeatedly
    but have a single instance that handles all the database queries for us.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库对象在根目录下的 `index.js` 文件启动服务器时初始化。我们从全局位置将其传递到依赖数据库的位置。这样，我们不需要重复导入数据库文件，而有一个单独的实例为我们处理所有数据库查询。
- en: The services that we want to publicize through the GraphQL API need access to
    our MySQL database. The first step is to implement the posts in our GraphQL API.
    It should respond with the fake posts from the database we just inserted.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要通过 GraphQL API 公布的服务需要访问我们的 MySQL 数据库。第一步是在我们的 GraphQL API 中实现帖子。它应该响应我们刚刚插入的数据库中的假帖子。
- en: Global database instance
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全球数据库实例
- en: 'To pass the database down to our GraphQL resolvers, we must create a new object
    in the server `index.js` file:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据库传递到我们的 GraphQL 解析器中，我们必须在服务器 `index.js` 文件中创建一个新的对象：
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we created a `utils` object directly under the `import` statement of the
    `database` folder.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 `database` 文件夹的 `import` 语句下直接创建了一个 `utils` 对象。
- en: The `utils` object holds all the utilities that our services might need access
    to. This can be anything from third-party tools to our MySQL server, or any other
    database, as shown in the preceding code.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`utils` 对象包含了我们的服务可能需要访问的所有实用工具。这可以是从第三方工具到我们的 MySQL 服务器，或任何其他数据库，如前述代码所示。'
- en: 'Replace the line where we import the `services` folder, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 替换导入 `services` 文件夹的行，如下所示：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code might look weird to you, but what we are doing here is executing
    the function that is the result of the `import` statement and passing the `utils`
    object as a parameter. We must do this in two separate lines since the `import`
    syntax does not allow it in just one line; so, we must first import the function
    that's been exported from the `services` folder into a separate variable.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码可能看起来有些奇怪，但我们在这里执行的是 `import` 语句的结果函数，并将 `utils` 对象作为参数传递。由于 `import` 语法不允许在一行中完成，我们必须在两行中执行此操作；因此，我们必须首先将
    `services` 文件夹中导出的函数导入到一个单独的变量中。
- en: So far, the return value of the `import` statement has been a simple object.
    We have to change this so that it matches our requirements.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`import` 语句的返回值是一个简单的对象。我们必须将其更改以匹配我们的要求。
- en: 'To do this, go to the services `index.js` file and change the contents of the
    file, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请转到 `services` 文件夹中的 `index.js` 文件，并按照以下方式更改文件内容：
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We surrounded the preceding `services` object with a function, which was then
    exported. That function accepts only one parameter, which is our `utils` object.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将前述 `services` 对象包围在一个函数中，然后导出该函数。该函数只接受一个参数，即我们的 `utils` 对象。
- en: That object is then given to a new function, called `graphql`. Every service
    that we are going to use has to be a function that accepts this parameter. This
    allows us to hand over any property that we want to the deepest point in our application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个对象被传递给一个新的函数，称为 `graphql`。我们将要使用的每个服务都必须是一个接受此参数的函数。这允许我们将任何我们想要的属性传递到我们应用程序的最深处。
- en: When executing the preceding exported function, the result is the regular `services`
    object we used previously. We only wrapped it inside a function to pass the `utils`
    object.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前述导出函数时，结果是之前使用的常规 `services` 对象。我们只是将其包裹在一个函数中，以传递 `utils` 对象。
- en: The `graphql` import that we are doing needs to accept the `utils` object.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在执行的 `graphql` 导入需要接受 `utils` 对象。
- en: 'Open the `index.js` file from the `graphql` folder and replace everything but
    the `require` statements at the top with the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `graphql` 文件夹中的 `index.js` 文件，并将除顶部的 `require` 语句之外的所有内容替换为以下代码：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Again, we have surrounded everything with a function that accepts the `utils`
    object. The aim of all this is to have access to the database within our GraphQL
    resolvers, which are given to `ApolloServer`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们用接受 `utils` 对象的函数包围了一切。所有这些的目的都是为了在我们的 GraphQL 解析器中访问数据库，这些解析器被传递给 `ApolloServer`。
- en: To accomplish this, we are using the `Resolvers.call` function from JavaScript.
    This function allows us to set the owner object of the exported `Resolvers` function.
    What we are saying here is that the scope of `Resolvers` is the `utils` object.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们使用了 JavaScript 的 `Resolvers.call` 函数。这个函数允许我们设置导出的 `Resolvers` 函数的所有者对象。我们在这里所说的就是，`Resolvers`
    的作用域是 `utils` 对象。
- en: So, within the `Resolvers` function, accessing this now gives us the `utils`
    object as the scope. At the moment, `Resolvers` is just a simple object, but because
    we used the `call` method, we must also return a function from the `resolvers.js`
    file.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `Resolvers` 函数中，现在访问 `this` 给我们的是 `utils` 对象作为作用域。目前，`Resolvers` 只是一个简单的对象，但因为我们使用了
    `call` 方法，所以我们还必须从 `resolvers.js` 文件中返回一个函数。
- en: 'Surround the `resolvers` object in this file with a function and return the
    `resolvers` object from inside the function:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，将 `resolvers` 对象包裹在一个函数中，并从函数内部返回 `resolvers` 对象：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We cannot use the arrow syntax, as we did previously. ES6 arrow syntax would
    automatically take a scope, but we want the `call` function to take over here.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用之前使用的箭头语法。ES6 箭头语法会自动获取作用域，但我们要让 `call` 函数在这里接管。
- en: An alternative way of doing this would be to hand over the `utils` object as
    a parameter. I think the way that we have chosen to do things is a bit cleaner,
    but handle it as you like.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将 `utils` 对象作为参数传递。我认为我们选择的方法稍微干净一些，但你可以按你喜欢的方式处理。
- en: Running the first database query
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行第一次数据库查询
- en: 'Now, we can start to use the database. Add the following code to the top of
    the `export default function resolver` statement:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始使用数据库了。将以下代码添加到 `export default function resolver` 语句的顶部：
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `this` keyword is the owner of the current method and holds the `db` object,
    as stated previously. We extracted the database models from the `db` object that
    we built in the previous section.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`this` 关键字是当前方法的拥有者，它包含 `db` 对象。我们从上一节中构建的 `db` 对象中提取了数据库模型。
- en: The good thing about models is that you do not need to write raw queries against
    the database. You have already told Sequelize which fields and tables it can use
    by creating a model. At this point, you can use Sequelize's methods to run queries
    against the database within your resolvers.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的优点在于你不需要直接对数据库编写原始查询。通过创建模型，你已经告诉 Sequelize 可以使用哪些字段和表。在这个阶段，你可以使用 Sequelize
    的方法在你的解析器中运行数据库查询。
- en: 'We can query all the posts through the Sequelize model, instead of returning
    the fake posts from before. Replace the `posts` property within `RootQuery` with
    the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 Sequelize 模型查询所有帖子，而不是返回之前的假帖子。将 `RootQuery` 中的 `posts` 属性替换为以下代码：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code, we searched for and selected all the posts that we have
    in our database. We used the Sequelize `findAll` method and returned the result
    of it. The return value will be a JavaScript promise, which automatically gets
    resolved once the database has finished collecting the data.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们搜索并选择了我们数据库中所有的帖子。我们使用了 Sequelize 的 `findAll` 方法，并返回了它的结果。返回值将是一个
    JavaScript promise，一旦数据库收集完数据，它就会自动解决。
- en: A typical news feed, such as on Twitter or Facebook, orders the posts according
    to the creation date. That way, you have the newest posts at the top and the oldest
    at the bottom. Sequelize expects an array of arrays as a parameter of the order
    property that we pass as the first parameter to the `findAll` method. The results
    are ordered by their creation date.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的新闻源，如 Twitter 或 Facebook，会根据创建日期对帖子进行排序。这样，最新的帖子在顶部，最旧的帖子在底部。Sequelize
    期望我们将作为 `findAll` 方法的第一个参数传递的排序属性的参数为一个数组数组。结果将按创建日期排序。
- en: Important Note
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There are many other methods that Sequelize offers. You can query for just one
    entity, count them, find them, create them if they are not found, and much more.
    You can look up the methods that Sequelize provides at [https://sequelize.org/master/manual/model-querying-basics.html](https://sequelize.org/master/manual/model-querying-basics.html).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize提供了许多其他方法。您可以查询单个实体，计数它们，找到它们，如果未找到则创建它们，等等。您可以在[https://sequelize.org/master/manual/model-querying-basics.html](https://sequelize.org/master/manual/model-querying-basics.html)查找Sequelize提供的方法。
- en: 'You can start the server with `npm run server` and execute the GraphQL posts
    query from [*Chapter 2*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032), *Setting
    Up GraphQL with Express.js*, again. The output will look as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `npm run server` 启动服务器，并再次从 [*第2章*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032)，*使用Express.js设置GraphQL*，执行GraphQL帖子查询。输出将如下所示：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `id` and `text` fields look fine, but the `user` object is `null`. This
    happened because we did not define a user model or declare a relationship between
    the user and the post model. We will change this in the next section.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` 和 `text` 字段看起来很好，但 `user` 对象是 `null`。这是因为我们没有定义用户模型或声明用户与帖子模型之间的关系。我们将在下一节中更改这一点。'
- en: One-to-one relationships in Sequelize
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sequelize中的一对一关系
- en: We need to associate each post with a user, to fill in the gap that we created
    in our GraphQL response. A post must have an author. It would not make sense to
    have a post without an associated user.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将每个帖子与一个用户关联起来，以填补我们在GraphQL响应中创建的空白。帖子必须有一个作者。没有关联用户的帖子是没有意义的。
- en: 'First, we will generate a `User` model and migration. We will use the Sequelize
    CLI again, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将生成一个 `User` 模型和迁移。我们将再次使用Sequelize CLI，如下所示：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The migration file creates the `Users` table and adds the `avatar` and `username`
    columns. A data row looks like a post in our fake data, but it also includes an
    autogenerated ID and two timestamps, as you saw previously.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件创建了 `Users` 表并添加了 `avatar` 和 `username` 列。数据行看起来像我们假数据中的帖子，但它还包括一个自动生成的ID和两个时间戳，就像您之前看到的那样。
- en: The relationship of the users to their specific posts is still missing as we
    have only created the model and migration file. We still have to add the relationship
    between posts and users. This will be covered in the next section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只创建了模型和迁移文件，用户与其特定帖子之间的关系仍然缺失。我们仍然需要添加帖子与用户之间的关系。这将在下一节中介绍。
- en: What every post needs is an extra field called `userId`. This column acts as
    the foreign key to reference a unique user. Then, we can join the user that's
    related to each post.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 每个帖子都需要一个额外的字段，称为 `userId`。此列作为外键，用于引用一个唯一的用户。然后，我们可以连接与每个帖子相关的用户。
- en: Note
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: MySQL offers great documentation for people that are not used to foreign key
    constraints. If you are one of them, you should read up on this topic at [https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html](https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL为不习惯使用外键约束的人提供了很好的文档。如果您是其中之一，您应该阅读有关此主题的内容，请参阅[https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html](https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html)。
- en: Updating the table structure with migrations
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用迁移更新表结构
- en: We have to write a third migration, adding the `userId` column to our `Post`
    table, but also including it in our database `Post` model.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须编写第三个迁移，将 `userId` 列添加到我们的 `Post` 表中，并将其包括在我们的数据库 `Post` 模型中。
- en: 'Generating a boilerplate migration file is very easy with the Sequelize CLI:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Sequelize CLI生成模板迁移文件非常容易：
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can directly replace the content of the generated migration file, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接替换生成的迁移文件的内容，如下所示：
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This migration is a bit more complex, and I will explain it on a step-by-step
    basis:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此迁移稍微复杂一些，我将分步骤解释：
- en: In the `up` migration, we are using `queryInterface` to add the `userId` column
    to the `Posts` table.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `up` 迁移中，我们使用 `queryInterface` 将 `userId` 列添加到 `Posts` 表中。
- en: Next, we are adding a foreign key constraint with the `addConstraint` function.
    This constraint represents the relationship between both the user and the post
    entities. The relationship is saved in the `userId` column of the `Post` table.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `addConstraint` 函数添加外键约束。此约束表示用户和帖子实体之间的关系。这种关系存储在 `Post` 表的 `userId`
    列中。
- en: I experienced some issues when running the migrations without using `Promise.all`,
    which ensures that all the promises in the array are resolved. Returning only
    the array did not run both the `addColumn` and `addConstraint` methods.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我在没有使用 `Promise.all` 运行迁移时遇到了一些问题，`Promise.all` 确保数组中的所有承诺都得到解决。只返回数组并没有运行
    `addColumn` 和 `addConstraint` 方法。
- en: The preceding `addConstraint` function receives the `foreign key` string as
    a `type`, which says that the data type is the same as the corresponding column
    in the `Users` table. We want to give our constraint the custom name `fk_user_id`
    to identify it later.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的 `addConstraint` 函数接收一个 `foreign key` 字符串作为 `type`，这意味着数据类型与 `Users` 表中相应的列相同。我们希望给我们的约束起一个自定义名称
    `fk_user_id`，以便以后识别。
- en: Then, we are specifying the `references` field for the `userId` column. Sequelize
    requires a table, which is the `Users` table, and the field that our foreign key
    relates to, which is the `id` column of the `User` table. This is everything that
    is required to get a working database relationship.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们正在指定 `userId` 列的 `references` 字段。Sequelize 需要一个表，即 `Users` 表，以及我们的外键关联的字段，即
    `User` 表的 `id` 列。这些都是建立有效数据库关系所需的一切。
- en: Furthermore, we are changing the `onUpdate` and `onDelete` constraints to `cascade`.
    What this means is that, when a user either gets deleted or has their user ID
    updated, the change is reflected in the user's posts. Deleting a user results
    in deleting all the posts of a user, while updating a user's ID updates the ID
    on all the user's posts. We do not need to handle all this in our application
    code, which would be inefficient.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还将 `onUpdate` 和 `onDelete` 约束更改为 `cascade`。这意味着，当用户被删除或其用户 ID 更新时，这种变化会反映在用户的帖子中。删除用户会导致删除该用户的所有帖子，而更新用户的
    ID 会更新所有用户帖子的 ID。我们不需要在应用程序代码中处理所有这些，这将是不高效的。
- en: Note
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: There is a lot more about this topic in the Sequelize documentation. If you
    want to read up on this, you can find more information at [https://sequelize.org/master/manual/query-interface.html](https://sequelize.org/master/manual/query-interface.html).
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Sequelize 文档中关于这个主题有更多内容。如果你想了解更多，可以在 [https://sequelize.org/master/manual/query-interface.html](https://sequelize.org/master/manual/query-interface.html)
    找到更多信息。
- en: 'Rerun the migration to see what changes occurred:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行迁移以查看发生了什么变化：
- en: '[PRE43]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The benefit of running migrations through Sequelize is that it goes through
    all the possible migrations from the `migrations` folder. It excludes those that
    are already saved inside the `SequelizeMeta` table, and then chronologically runs
    the migrations that are left. Sequelize can do this because the timestamp is included
    in every migration's filename.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Sequelize 运行迁移的好处是它会遍历 `migrations` 文件夹中所有可能的迁移。它排除了那些已经保存在 `SequelizeMeta`
    表中的迁移，然后按时间顺序运行剩余的迁移。Sequelize 可以这样做，因为每个迁移的文件名中都包含了时间戳。
- en: After running the migration, there should be a `Users` table, and the `userId`
    column should have been added to the `Posts` table.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 运行迁移后，应该会有一个 `Users` 表，并且 `userId` 列已经被添加到 `Posts` 表中。
- en: 'Take a look at the relationship view of the `Posts` table in phpMyAdmin. You
    can find it under the **Structure** view, by clicking on **Relation view**:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在 phpMyAdmin 中查看 `Posts` 表的关系视图。你可以在 **结构** 视图中找到它，通过点击 **关系视图**：
- en: '![Figure 3.6 – MySQL foreign keys'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – MySQL 外键'
- en: '](img/Figure_3.06_B17337.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.06_B17337.jpg)'
- en: Figure 3.6 – MySQL foreign keys
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – MySQL 外键
- en: As you can see, we have our foreign key constraint. The correct name was taken,
    as well as the cascade option.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有了外键约束。正确地取了名字，以及级联选项。
- en: 'If you receive an error when running migrations, you can easily undo them,
    as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行迁移时收到错误，你可以轻松地撤销它们，如下所示：
- en: '[PRE44]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This command undoes the most recent migrations. Always be conscious of what
    you do here. Keep a backup if you are unsure whether everything works correctly.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会撤销最近的迁移。始终要意识到你在做什么。如果你不确定一切是否正常工作，请保留备份。
- en: 'You can also revert all migrations at once, or only revert to one specific
    migration so that you can go back to a specific timestamp:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以一次性撤销所有迁移，或者只撤销到特定的迁移，这样你可以回到特定的日期和时间戳：
- en: '[PRE45]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Leave out the `--to` parameter to undo all migrations.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 省略 `--to` 参数以撤销所有迁移。
- en: With that, we have established the database relationship, but Sequelize must
    know about the relationship too. You will learn how this is done in the next section.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就建立了数据库关系，但 Sequelize 也必须知道这个关系。你将在下一节中学习如何做到这一点。
- en: Model associations in Sequelize
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sequelize 中的模型关联
- en: Now that we have the relationship configured with the foreign key, it needs
    to be configured inside our Sequelize model.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过外键配置了关系，它需要在我们的 Sequelize 模型内部进行配置。
- en: 'Go back to the `Post` model file and replace the `associate` function with
    the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `Post` 模型文件，并用以下代码替换 `associate` 函数：
- en: '[PRE46]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `associate` function gets evaluated inside our aggregating `index.js` file,
    where all the model files are imported.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`associate` 函数在聚合的 `index.js` 文件中被评估，该文件中导入了所有模型文件。'
- en: We are using the `belongsTo` function here, which tells Sequelize that every
    post belongs to exactly one user. Sequelize gives us a new function on the `Post`
    model, called `getUser`, to retrieve the associated user. This naming is done
    by convention, as you can see. Sequelize does all this automatically.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的是 `belongsTo` 函数，它告诉 Sequelize 每个帖子恰好属于一个用户。Sequelize 在 `Post` 模型上为我们提供了一个新函数，称为
    `getUser`，用于检索关联的用户。这种命名是按照惯例进行的，正如你所看到的。Sequelize 会自动完成所有这些操作。
- en: 'Do not forget to add `userId` as a queryable field to the `Post` model itself,
    as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将 `userId` 作为可查询字段添加到 `Post` 模型本身，如下所示：
- en: '[PRE47]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `User` model needs to implement the reverse association too. Add the following
    code to the `User` model file:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 模型也需要实现反向关联。将以下代码添加到 `User` 模型文件中：'
- en: '[PRE48]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `hasMany` function means the exact opposite of the `belongsTo` function.
    Every user can have multiple posts associated in the `Post` table. It can be anything,
    from zero to multiple posts.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasMany` 函数与 `belongsTo` 函数正好相反。每个用户都可以在 `Post` 表中关联多个帖子。这可以是零个或多个帖子。'
- en: You can compare the new data layout with the preceding one. Up to this point,
    we had the posts and users inside one big array of objects. Now, we have split
    every object into two tables. Both tables connect through the foreign key. This
    is required every time we run the GraphQL query to get all the posts, including
    their authors.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将新的数据布局与前面的布局进行比较。到目前为止，我们有一个包含帖子和用户的对象大数组。现在，我们将每个对象拆分为两个表。两个表通过外键连接。每次运行
    GraphQL 查询以获取所有帖子及其作者时，都需要这样做。
- en: 'So, we must extend our current `resolvers.js` file. Add the `Post` property
    to the `resolvers` object, as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须扩展我们当前的 `resolvers.js` 文件。将 `Post` 属性添加到 `resolvers` 对象中，如下所示：
- en: '[PRE49]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`RootQuery` and `RootMutation` were the two main properties that we''ve had
    so far. `RootQuery` is the starting point where all GraphQL queries begin.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`RootQuery` 和 `RootMutation` 是我们迄今为止拥有的两个主要属性。`RootQuery` 是所有 GraphQL 查询的起点。'
- en: With the old demo posts, we were able to directly return a valid and complete
    response, since everything that we needed was in there already. Now, a second
    query, or a `JOIN`, is being executed to collect all the necessary data for a
    complete response.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧的演示帖子中，我们能够直接返回一个有效且完整的响应，因为我们需要的所有东西都在那里。现在，需要执行第二个查询或 `JOIN` 来收集完整响应所需的所有必要数据。
- en: The `Post` entity is introduced to our `resolvers`, where we can define functions
    for every property of our GraphQL schema. Only the user is missing in our response;
    the rest is there. That is why we have added the `user` function to the resolvers.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post` 实体被引入到我们的 `resolvers` 中，我们可以为 GraphQL 模式中的每个属性定义函数。响应中只缺少用户；其余都在那里。这就是为什么我们向解析器中添加了
    `user` 函数。'
- en: The first parameter of the function is the `post` model instance that we are
    returning inside the `RootQuery` resolver.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第一个参数是我们返回到 `RootQuery` 解析器中的 `post` 模型实例。
- en: Then, we are using the `getUser` function that Sequelize gave us. Executing
    the `getUser` function runs the correct MySQL `SELECT` query to get the correct
    user from the `Users` table. It does not run a real MySQL `JOIN`; it only queries
    the user in a separate MySQL command. Later, in the *Chats and messages in GraphQL*
    section, you will learn about another way to run a `JOIN` directly, which is more
    efficient.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 Sequelize 给我们的 `getUser` 函数。执行 `getUser` 函数将运行正确的 MySQL `SELECT` 查询，从
    `Users` 表中获取正确的用户。它不会运行实际的 MySQL `JOIN`；它只在一个单独的 MySQL 命令中查询用户。稍后，在 *GraphQL 中的聊天和消息*
    部分，你将了解另一种直接运行 `JOIN` 的方法，这更有效率。
- en: However, if you query for all the posts via the GraphQL API, the user will still
    be `null`. We have not added any users to the database yet, so let's insert them
    next.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你通过 GraphQL API 查询所有帖子，用户仍然会是 `null`。我们还没有向数据库中添加任何用户，所以让我们接下来插入它们。
- en: Seeding foreign key data
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外键数据初始化
- en: 'The challenge of adding users is that we have already introduced a foreign
    key constraint to the database. You can follow these instructions to learn how
    to get it working:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 添加用户的挑战是我们已经向数据库中引入了外键约束。你可以按照以下说明来学习如何使其工作：
- en: 'First, we must use the Sequelize CLI to generate an empty `seeders` file, as
    follows:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须使用 Sequelize CLI 生成一个空的 `seeders` 文件，如下所示：
- en: '[PRE50]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Fill in the following code to insert the fake users:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写以下代码以插入假用户：
- en: '[PRE51]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The preceding code looks like the `seeders` file for the posts, but instead,
    we are now inserting users with the correct fields. Every user receives an auto-incremented
    ID by our MySQL server when inserting a user.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码看起来像是帖子 `seeders` 文件，但相反，我们现在正在使用正确的字段插入用户。每次插入用户时，我们的 MySQL 服务器都会为每个用户分配一个自动递增的
    ID。
- en: 'We must maintain the relationships that have been configured in our database.
    Adjust the `posts` seed file to reflect this and replace the `up` migration so
    that the correct user IDs are inserted for every post:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须维护我们在数据库中配置的关系。调整 `posts` 种子文件以反映这一点，并替换 `up` 迁移，以便为每个帖子插入正确的用户 ID：
- en: '[PRE52]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we are using a raw MySQL query to get all the users and their IDs to insert
    them with our posts. This ensures that we have a valid foreign key relationship
    that MySQL allows us to insert.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用原始 MySQL 查询来获取所有用户及其 ID，以便我们可以与我们的帖子一起插入它们。这确保了我们有一个有效的、MySQL 允许我们插入的外键关系。
- en: The posts we have currently stored in our table do not receive a `userId`, and
    we do not want to write a separate migration or seed to fix those posts.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前存储在表中的帖子没有接收 `userId`，我们不想为这些帖子编写单独的迁移或种子来修复它们。
- en: 'There are two options here. You can either manually truncate the tables through
    phpMyAdmin and SQL statements, or you can use the Sequelize CLI. It is easier
    to use the CLI, but the result will be the same either way. The following command
    will undo all the seeds:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两种选择。你可以手动通过 phpMyAdmin 和 SQL 语句截断表，或者你可以使用 Sequelize CLI。使用 CLI 更容易，但无论如何结果都是一样的。以下命令将撤销所有种子：
- en: '[PRE53]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When undoing seeds, the tables are not truncated, so the `autoIncrement` index
    is not set back to one; instead, it stays at the current index. Reverting seeds
    multiple times raises the user's or post's ID, which stops the seeds from working.
    We have fixed this by using the raw MySQL query that retrieves the current user
    IDs before inserting the posts.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在撤销种子时，表不会被截断，因此 `autoIncrement` 索引不会重置为 1；相反，它保持在当前索引。多次撤销种子会提高用户或帖子的 ID，这会阻止种子工作。我们通过使用在插入帖子之前检索当前用户
    ID 的原始 MySQL 查询来解决这个问题。
- en: 'We have one problem before running our seeders again: we created the `users`
    seed file after the `post` seeders file. This means that the posts are inserted
    before the users exist, because of the timestamps of the files. Generally, this
    is not a problem, but since we have introduced a foreign key constraint, we are
    not able to insert posts with a `userId` when the underlying user does not exist
    in our database. MySQL forbids this. Simply adjust the timestamp of the fake user
    seed file so that it''s before the post seed file''s timestamp, or vice versa.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在再次运行种子之前，我们遇到了一个问题：我们在 `post` 种子文件之后创建了 `users` 种子文件。这意味着帖子是在用户存在之前插入的，因为文件的时序。通常这不会是问题，但因为我们已经引入了外键约束，所以我们不能在底层用户不存在于我们的数据库中时插入带有
    `userId` 的帖子。MySQL 禁止这样做。只需调整假用户种子文件的时序，使其早于帖子种子文件的时序，或者反之亦然。
- en: 'After renaming the files, run all the seeds with the following command again:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在重命名文件后，再次运行所有种子，使用以下命令：
- en: '[PRE54]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you take a look inside your database, you should see a filled `Posts` table,
    including `userId`. The `Users` table should look as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看你的数据库，你应该会看到一个填充的 `Posts` 表，包括 `userId`。`Users` 表应如下所示：
- en: '![Figure 3.7 – The Users table'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 用户表'
- en: '](img/Figure_3.07_B17337.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.07_B17337.jpg)'
- en: Figure 3.7 – The Users table
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 用户表
- en: Now, you can rerun the GraphQL query, and you should see a working association
    between the users and their posts because the `user` field is filled in.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以重新运行 GraphQL 查询，你应该会看到用户和他们的帖子之间存在一个正常的工作关联，因为 `user` 字段已被填充。
- en: So far, we have achieved a lot as we can serve data from our database through
    the GraphQL API by matching its schema.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经取得了很多成就，因为我们可以通过匹配其模式通过 GraphQL API 从我们的数据库中提供数据。
- en: Note
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are some ways to automate this process, through additional npm packages.
    There is a package that automates the process of creating a GraphQL schema from
    your database models for you. As always, you are more flexible when you do not
    rely on pre-configured packages. You can find the package at [https://www.npmjs.com/package/graphql-tools-sequelize](https://www.npmjs.com/package/graphql-tools-sequelize).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法可以自动化这个过程，通过额外的npm包。有一个包可以自动为您从数据库模型创建GraphQL模式。一如既往，当您不依赖于预配置的包时，您将更加灵活。您可以在[https://www.npmjs.com/package/graphql-tools-sequelize](https://www.npmjs.com/package/graphql-tools-sequelize)找到这个包。
- en: Mutating data with Sequelize
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sequelize突变数据
- en: 'Requesting data from our database via the GraphQL API works. Now comes the
    tough part: adding a new post to the `Posts` table.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 通过GraphQL API从我们的数据库请求数据是有效的。现在是困难的部分：将新帖子添加到`Posts`表中。
- en: 'Before we start, we must extract the new database model from the `db` object
    at the top of the exported function in our `resolvers.js` file:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们必须从我们的`resolvers.js`文件中导出函数顶部的`db`对象中提取新的数据库模型：
- en: '[PRE55]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Currently, we have no authentication to identify the user that is creating the
    post. We will fake this step until the authentication is implemented [*Chapter
    6*](B17337_06_Final_ASB_ePub.xhtml#_idTextAnchor141), *Authentication with Apollo
    and React*.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们还没有身份验证来识别创建帖子的用户。我们将伪造这一步，直到身份验证被实现 [*第6章*](B17337_06_Final_ASB_ePub.xhtml#_idTextAnchor141)，*使用Apollo和React进行身份验证*。
- en: 'We have to edit the GraphQL resolvers to add the new post. Replace the old
    `addPost` function with the new one, as shown in the following code snippet:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须编辑GraphQL解析器以添加新帖子。将旧的`addPost`函数替换为新的，如下代码片段所示：
- en: '[PRE56]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As always, the preceding mutation returns a promise. This promise is resolved
    when the deepest query has been executed successfully. The execution order is
    as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 总是如此，前面的突变返回一个承诺。这个承诺在最深层的查询成功执行后解决。执行顺序如下：
- en: We retrieve all the users from the database through the `User.findAll` method.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过`User.findAll`方法从数据库中检索所有用户。
- en: We insert the post into our database with the `create` function from Sequelize.
    The only property that we pass is the `post` object from the original request,
    which only holds the text of the post. MySQL autogenerates the `id` property of
    the post.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用Sequelize的`create`函数将帖子插入到我们的数据库中。我们传递的唯一属性是从原始请求中的`post`对象，它只包含帖子的文本。MySQL自动生成帖子的`id`属性。
- en: Note
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Sequelize also offers a `build` function, which initializes the model instance
    for us. In this case, we would have to run the `save` method to insert the model
    manually. The `create` function does this for us all at once.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Sequelize还提供了一个`build`函数，它可以为我们初始化模型实例。在这种情况下，我们必须运行`save`方法来手动插入模型。`create`函数为我们一次性完成所有这些。
- en: The post has been created, but `userId` has not been set.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 帖子已创建，但`userId`尚未设置。
- en: You could also directly add the user ID to the `Post.create` function. The problem
    here is that we would not establish the model associations, even though this is
    reflected in the database. If we return the created post model without explicitly
    using `setUser` on the model instance, we cannot use the `getUser` function, which
    is used to return the user for the mutation's response.
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以直接将用户ID添加到`Post.create`函数中。问题在于，即使这在数据库中有所反映，我们也不会建立模型关联。如果我们不显式使用`setUser`在模型实例上返回创建的帖子模型，我们就无法使用`getUser`函数，该函数用于返回突变响应的用户。
- en: So, to fix this problem, we must run the `create` function, resolve the promise,
    and then run `setUser` separately. As a parameter of `setUser`, we statically
    take the ID of the first user from the `users` array.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，为了解决这个问题，我们必须运行`create`函数，解决承诺，然后单独运行`setUser`。作为`setUser`的参数，我们静态地取`users`数组中的第一个用户的ID。
- en: We resolve the promise of the `setUser` function by using an array surrounded
    by `Promise.all`. This allows us to add further Sequelize methods later. For example,
    you could add a category to each post, too.
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们通过使用包围在`Promise.all`中的数组来解决`setUser`函数的承诺。这允许我们稍后添加更多的Sequelize方法。例如，您也可以为每个帖子添加一个类别。
- en: Once we have set `userId` correctly, the returned value is the newly created
    post model instance.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们正确设置了`userId`，返回的值是新建的帖子模型实例。
- en: 'Everything is set now. To test our API, we are going to use Postman again.
    We need to change the `addPost` request. `userInput`, which we added previously,
    is not needed anymore, because the backend statically chooses the first user out
    of our database. You can send the following request body:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都已就绪。为了测试我们的 API，我们将再次使用 Postman。我们需要更改 `addPost` 请求。之前添加的 `userInput` 现在不再需要，因为后端静态地选择数据库中的第一个用户。你可以发送以下请求体：
- en: '[PRE57]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Your GraphQL schema must reflect this change, so remove `userInput` from there,
    too:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 GraphQL 模式必须反映这一变化，因此也要从那里删除 `userInput`：
- en: '[PRE58]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Running the `addPost` GraphQL mutation now adds a post to the `Posts` table,
    as shown in the following screenshot:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 `addPost` GraphQL 演变现在会将帖子添加到 `Posts` 表中，如下截图所示：
- en: '![Figure 3.8 – Post inserted into the database table'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.8 – 已插入数据库表的帖子'
- en: '](img/Figure_3.08_B17337.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.08_B17337.jpg)'
- en: Figure 3.8 – Post inserted into the database table
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 帖子已插入数据库表
- en: As we are not using the demo `posts` array anymore, you can remove it from the
    `resolvers.js` file.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再使用演示 `posts` 数组，你可以将其从 `resolvers.js` 文件中删除。
- en: With that, we have rebuilt the example from the previous chapter, but we are
    using a database in our backend. To extend our application, we are going to add
    two new entities called `Chat` and `Message`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就重新构建了前一章的示例，但我们使用的是后端数据库。为了扩展我们的应用程序，我们将添加两个新的实体，分别称为 `Chat` 和 `Message`。
- en: Many-to-many relationships
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多对多关系
- en: Facebook provides users with various ways to interact. Currently, we only have
    the opportunity to request and insert posts. As is the case with Facebook, we
    want to have chats with our friends and colleagues. We will introduce two new
    entities to cover this.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook 为用户提供各种互动方式。目前，我们只有请求和插入帖子的机会。正如在 Facebook 上一样，我们想要与我们的朋友和同事进行聊天。我们将引入两个新的实体来覆盖这一点。
- en: The first entity is called `Chat`, while the second entity is called `Message`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个实体称为 `Chat`，第二个实体称为 `Message`。
- en: Before we start the implementation, we need to lay out a detailed plan of what
    those entities will enable us to do.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实施之前，我们需要制定一个详细的计划，说明这些实体将使我们能够做什么。
- en: A user can have multiple chats, and a chat can belong to multiple users. This
    relationship allows us to have group chats with multiple users, as well as private
    chats between only two users. A message belongs to one user, but every message
    also belongs to one chat.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用户可以有多个聊天，一个聊天也可以属于多个用户。这种关系使我们能够与多个用户进行群聊，以及仅限于两个用户之间的私密聊天。一条消息属于一个用户，但每条消息也属于一个聊天。
- en: Model and migrations
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型和迁移
- en: When transferring this into real code, we must generate the `Chat` model. The
    problem here is that we have a many-to-many relationship between users and chats.
    In MySQL, this kind of relationship requires a table to store the relationships
    between all the entities separately.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在将其转换为实际代码时，我们必须生成 `Chat` 模型。这里的问题是用户和聊天之间存在多对多关系。在 MySQL 中，这种关系需要一个表来分别存储所有实体之间的关系。
- en: These tables are called `user_chats`. The user's ID and the chat's ID are associated
    with each other inside this table. If a user participates in multiple chats, they
    will have multiple rows in this table, with different chat IDs.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表称为 `user_chats`。用户的 ID 和聊天的 ID 在这个表中相互关联。如果一个用户参与多个聊天，他们将在表中有多行，具有不同的聊天 ID。
- en: Chat model
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聊天模型
- en: 'Let''s start by creating the `Chat` model and migration. A chat itself does
    not store any data; we use it for grouping specific users'' messages:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建 `Chat` 模型和迁移。聊天本身不存储任何数据；我们用它来分组特定用户的消息：
- en: '[PRE59]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Generate the migration for our association table, as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 生成我们的关联表的迁移，如下所示：
- en: '[PRE60]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Adjust the `users_chats` migration that''s generated by the Sequelize CLI.
    We specify the user and chat IDs as attributes for our relationship. References
    inside a migration automatically create foreign key constraints for us. The migration
    file should look as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 调整由 Sequelize CLI 生成的 `users_chats` 迁移。我们指定用户和聊天 ID 作为我们关系的属性。迁移内部的自引用会自动为我们创建外键约束。迁移文件应如下所示：
- en: '[PRE61]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: A separate model file for the association table is not needed because we can
    rely on this table in the models where the association is required. The `id` column
    could be left out because the row can only be identified by the user and chat
    ID.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关联表不需要单独的模型文件，因为我们可以在需要关联的模型中依赖这个表。`id` 列可以省略，因为行只能由用户和聊天 ID 来识别。
- en: 'Associate the `User` model with the `Chat` model via the new relationship table
    in the `User` model, as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 通过新的关系表在`User`模型中将`User`模型与`Chat`模型关联起来，如下所示：
- en: '[PRE62]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Do the same for the `Chat` model, as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Chat`模型也做同样的操作，如下所示：
- en: '[PRE63]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `through` property tells Sequelize that the two models are related via the
    `users_chats` table. Normally, when you are not using Sequelize and are trying
    to select all users and chats merged in raw SQL, you need to maintain this association
    manually and join the three tables on your own. Sequelize's querying and association
    capabilities are so complex, so this is all done for you.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`through`属性告诉Sequelize这两个模型通过`users_chats`表相关联。通常，当你不使用Sequelize并且尝试使用原始SQL选择所有合并的用户和聊天时，你需要手动维护这种关联并自己连接三个表。Sequelize的查询和关联能力非常复杂，所以这一切都为你做好了。'
- en: 'Rerun the migrations to let the changes take effect:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行迁移以使更改生效：
- en: '[PRE64]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The following screenshot shows what your database should look like now:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了你的数据库现在应该看起来是什么样子：
- en: '![Figure 3.9 – Database structure'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.9 – Database structure]'
- en: '](img/Figure_3.09_B17337.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.09_B17337.jpg]'
- en: Figure 3.9 – Database structure
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.9 – Database structure]'
- en: 'You should see two foreign key constraints in the relationship view of the
    `users_chats` table. The naming is done automatically:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在`users_chats`表的关系视图中看到两个外键约束。命名是自动完成的：
- en: '![Figure 3.10 – Foreign keys for the users_chats table'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.10 – Foreign keys for the users_chats table]'
- en: '](img/Figure_3.10_B17337.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.10_B17337.jpg]'
- en: Figure 3.10 – Foreign keys for the users_chats table
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – `users_chats`表的外键
- en: This setup was the tough part. Next up is the message entity, which is a simple
    one-to-one relationship. One message belongs to one user and one chat.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置是难点。接下来是消息实体，这是一个简单的一对一关系。一条消息属于一个用户和一个聊天。
- en: Message model
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息模型
- en: A message is much like a post, except that it can only be read inside a chat
    and is not public to everyone.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 一条消息就像一个帖子，只不过它只能在聊天中读取，不对所有人公开。
- en: 'Generate the model and migration file with the CLI, as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CLI生成模型和迁移文件，如下所示：
- en: '[PRE65]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Add the missing references to the created migration file by replacing the following
    properties:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 通过替换以下属性，将缺失的引用添加到创建的迁移文件中：
- en: '[PRE66]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now, we can run the migrations again to create the `Messages` table using the
    `sequelize db:migrate` Terminal command.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以再次运行迁移来创建`Messages`表，使用`sequelize db:migrate`终端命令。
- en: 'The references also apply to our model file, where we need to use Sequelize''s
    `belongsTo` function to get all those convenient model methods for our resolvers.
    Replace the `associate` function of the `Message` model with the following code:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这些引用也适用于我们的模型文件，在那里我们需要使用Sequelize的`belongsTo`函数来获取所有那些方便的模型方法供我们的解析器使用。将`Message`模型的`associate`函数替换为以下代码：
- en: '[PRE67]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the preceding code, we defined that every message is related to exactly one
    user and chat.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了每条消息都与恰好一个用户和一个聊天相关联。
- en: 'On the other hand, we must also associate the `Chat` model with the messages.
    Add the following code to the `associate` function of the `Chat` model:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们还必须将`Chat`模型与消息关联起来。将以下代码添加到`Chat`模型的`associate`函数中：
- en: '[PRE68]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The next step is to adjust our GraphQL API to provide chats and messages.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是调整我们的GraphQL API以提供聊天和消息。
- en: Chats and messages in GraphQL
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL中的聊天和消息
- en: 'So far, we have introduced some new entities with messages and chats. Let''s
    include those in our Apollo schema. In the following code, you can see an excerpt
    of the changed entities, fields, and parameters of our GraphQL schema:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经引入了一些带有消息和聊天的新的实体。让我们将这些包括到我们的Apollo模式中。在以下代码中，你可以看到我们GraphQL模式中更改的实体、字段和参数的摘录：
- en: '[PRE69]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Take a look at the following short changelog of our GraphQL schema:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们GraphQL模式的以下简短变更日志：
- en: The `User` type received an `id` field, thanks to our database.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User`类型由于我们的数据库而获得了`id`字段。'
- en: The `Message` type is entirely new. It has a text field like a typical message,
    and user and chat fields, which are requested from the referenced tables in the
    database model.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message`类型完全是新的。它有一个文本字段，就像典型的消息一样，还有用户和聊天字段，这些字段是从数据库模型中引用的表中请求的。'
- en: The `Chat` type is also new. A chat contains a list of messages that are returned
    as an array. These can be queried through the chat ID, which is saved in the message
    table. Furthermore, a chat has an unspecified number of users. The relationships
    between users and chats are saved in our separate **join table**. The interesting
    thing here is that our schema does not know anything about this table; it is just
    for our internal use to save the data appropriately in our MySQL server.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chat`类型也是新的。一个聊天包含一个消息列表，这些消息作为数组返回。这些可以通过聊天ID进行查询，该ID保存在消息表中。此外，一个聊天有一个未指定的用户数量。用户和聊天之间的关系保存在我们单独的**连接表**中。这里有趣的是，我们的模式对此表一无所知；它只是用于我们内部适当保存数据在我们的MySQL服务器上。'
- en: I have also added a new `RootQuery`, called `chats`. This query returns all
    the user's chats.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我还添加了一个新的`RootQuery`，称为`chats`。此查询返回所有用户的聊天。
- en: 'These factors should be implemented in our resolvers too. Our resolvers should
    look as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这些因素也应该在我们的解析器中实现。我们的解析器应该如下所示：
- en: '[PRE70]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s go through the changes one by one:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个查看这些更改：
- en: We added the `Message` property to our resolvers.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在我们的解析器中添加了`Message`属性。
- en: We added the `Chat` property to the `resolvers` object. There, we run the `getMessages`
    and `getUsers` functions, to retrieve all the joined data. All the messages are
    sorted by the ID in ascending order (to show the latest message at the bottom
    of a chat window, for example).
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`resolvers`对象中添加了`Chat`属性。在那里，我们运行`getMessages`和`getUsers`函数，以检索所有关联的数据。所有消息都是按ID升序排序的（例如，以在聊天窗口底部显示最新消息）。
- en: 'I added the new `RootQuery`, called `chats`, to return all the fields, as in
    our schema:'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我添加了一个新的`RootQuery`，称为`chats`，以返回所有字段，如我们的模式所示：
- en: a) Until we get a working authentication, we will statically use the first user
    when querying for all chats.
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 在我们得到有效的身份验证之前，我们将静态使用第一个用户来查询所有聊天。
- en: b) We are using the `findAll` method of Sequelize and joining the users of any
    returned chat. For this, we use the `include` property of Sequelize on the `User`
    model within the `findAll` method. It runs a MySQL `JOIN`, not a second `SELECT`
    query.
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 我们正在使用Sequelize的`findAll`方法并连接任何返回的聊天中的用户。为此，我们在`findAll`方法中的`User`模型上使用Sequelize的`include`属性。它运行一个MySQL
    `JOIN`，而不是第二个`SELECT`查询。
- en: c) Setting the `include` statement to `required` runs an `INNER JOIN`, not a
    `LEFT OUTER JOIN`, by default. Any chat that does not match the condition in the
    `through` property is excluded. In our example, the condition is that the user
    ID must match.
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 将`include`语句设置为`required`会默认运行一个`INNER JOIN`，而不是`LEFT OUTER JOIN`。任何不匹配`through`属性中条件的聊天将被排除。在我们的例子中，条件是用户ID必须匹配。
- en: d) Lastly, we join all the available messages for each chat in the same way,
    without any condition.
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 最后，我们以相同的方式连接每个聊天中所有可用的消息，没有任何条件。
- en: 'We must use the new models here. We should not forget to extract them from
    the `db.models` object inside the `resolver` function. It must look as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在这里使用新的模型。我们不应该忘记在`resolver`函数内部从`db.models`对象中提取它们。它必须如下所示：
- en: '[PRE71]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You can send this GraphQL request to test the changes:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以发送这个GraphQL请求来测试更改：
- en: '[PRE72]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The response should give us an empty `chats` array, as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 响应应该给我们一个空的`chats`数组，如下所示：
- en: '[PRE73]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This empty array was returned because we do not have any chats or messages in
    our database. You will learn how to fill it with data in the next section.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这个空数组被返回，因为我们数据库中没有聊天或消息。你将在下一节中学习如何用数据填充它。
- en: Seeding many-to-many data
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 种植多对多数据
- en: Testing our implementation requires data to be in our database. We have three
    new tables, so we will create three new seeders to get some test data to work
    with.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们的实现需要数据在我们的数据库中。我们有三个新的表，因此我们将创建三个新的种子文件来获取一些测试数据来工作。
- en: 'Let''s start with the chats, as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从聊天开始，如下所示：
- en: '[PRE74]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, replace the new seeder file with the following code. Running the following
    code creates a chat in our database. We do not need more than two timestamps because
    the chat ID is generated automatically:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用以下代码替换新的种子文件。运行以下代码会在我们的数据库中创建一个聊天。我们不需要超过两个时间戳，因为聊天ID是自动生成的：
- en: '[PRE75]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, we must insert the relationship between two users and the new chat. We
    can do this by creating two entries in the `users_chats` table where we reference
    them. Now, generate the boilerplate seed file, as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须插入两个用户和新的聊天之间的关系。我们可以通过在`users_chats`表中创建两个条目来实现，其中引用它们。现在，生成以下模板种子文件：
- en: '[PRE76]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Our seed should look much like the previous ones, as follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的种子应该看起来与之前的类似，如下所示：
- en: '[PRE77]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Inside the `up` migration, we resolve all the users and chats using `Promise.all`.
    This ensures that, when the promise is resolved, all the chats and users are available
    at the same time. To test the chat functionality, we choose the first chat and
    the first two users that are returned from the database. We take their IDs and
    save them in our `users_chats` table. Those two users should be able to talk to
    each other through this one chat later.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `up` 迁移中，我们使用 `Promise.all` 解决所有用户和聊天。这确保了当承诺解决时，所有聊天和用户同时可用。为了测试聊天功能，我们选择数据库返回的第一个聊天和前两个用户。我们取他们的
    ID 并将它们保存到我们的 `users_chats` 表中。这两个用户应该能够通过这个聊天互相交谈。
- en: 'The last table without any data in it is the `Messages` table. Generate the
    seed file, as follows:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个没有任何数据的表是 `Messages` 表。按照以下方式生成种子文件：
- en: '[PRE78]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Again, replace the generated boilerplate code, as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，按照以下方式替换生成的样板代码：
- en: '[PRE79]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Now, all the seed files should be ready. It makes sense to empty all the tables
    before running the seeds so that you can work with clean data. I like to delete
    all the tables in the database from time to time and rerun all the migrations
    and seeds to test them from zero. Whether or not you are doing this, you should
    at least be able to run the new seed.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有种子文件都应该准备好了。在运行种子之前清空所有表是有意义的，这样你就可以使用干净的数据。我喜欢不时地删除数据库中的所有表，并重新运行所有迁移和种子来从零开始测试它们。无论你是否这样做，你至少应该能够运行新的种子。
- en: 'Try to run the GraphQL `chats` query again. It should look as follows:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试再次运行 GraphQL 的 `chats` 查询。它应该看起来如下所示：
- en: '[PRE80]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Great! Now, we can request all the chats that a user participates in and get
    all the referenced users and their messages.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，我们可以请求用户参与的所有聊天，并获取所有引用的用户及其消息。
- en: 'Now, we also want to do this for only one chat. Follow these steps:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们也想为单个聊天做同样的事情。按照以下步骤操作：
- en: 'Add a `RootQuery` chat that takes a `chatId` as a parameter:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个接受 `chatId` 参数的 `RootQuery` 聊天：
- en: '[PRE81]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: With this implementation, we have the problem that all the users can send a
    query to our Apollo Server and, in return, get the complete chat history, even
    if they are not referenced in the chat. We will not be able to fix this until
    we implement authentication later in [*Chapter 6*](B17337_06_Final_ASB_ePub.xhtml#_idTextAnchor141),
    *Authentication with Apollo and React*.
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种实现中，我们遇到的问题是所有用户都可以向我们的 Apollo 服务器发送查询，并作为回报，获取完整的聊天历史，即使他们没有被引用在聊天中。我们只有在稍后实现身份验证后才能解决这个问题，如[*第
    6 章*](B17337_06_Final_ASB_ePub.xhtml#_idTextAnchor141)中所述，*使用 Apollo 和 React 进行身份验证*。
- en: 'Add the new query to the GraphQL schema, under `RootQuery`:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的查询添加到 GraphQL 模式中的 `RootQuery` 下：
- en: '[PRE82]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Send the GraphQL request to test the implementation, as follows:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式发送 GraphQL 请求以测试实现：
- en: '[PRE83]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Here, we are sending this query, including `chatId` as a parameter. To pass
    a parameter, you must define it in the query with its GraphQL data type. Then,
    you can set it in the specific GraphQL query that you are executing, which is
    the `chat` query. Lastly, you must insert the parameter's value into the `variables`
    field of the GraphQL request.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们发送这个查询，包括 `chatId` 作为参数。要传递参数，你必须在查询中定义它及其 GraphQL 数据类型。然后，你可以在你正在执行的特定
    GraphQL 查询中设置它，即 `chat` 查询。最后，你必须将参数的值插入到 GraphQL 请求的 `variables` 字段中。
- en: You may remember the response from the last time. The new response will look
    much like a result of the `chats` query, but instead of an array of chats, we
    will just have one `chat` object.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得上次的响应。新的响应将看起来与 `chats` 查询的结果非常相似，但我们将只有一个 `chat` 对象，而不是聊天数组。
- en: 'We are missing a major feature: sending new messages or creating a new chat.
    We will create the corresponding schema, and the resolvers for it, in the next
    section.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们缺少一个主要功能：发送新消息或创建新的聊天。我们将在下一节创建相应的模式及其解析器。
- en: Creating a new chat
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的聊天
- en: New users want to chat with their friends, so creating a new chat is essential.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 新用户希望与他们的朋友聊天，因此创建一个新的聊天是必不可少的。
- en: 'The best way to do this is to accept a list of user IDs so that we can allow
    group chats too. Do this as follows:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是接受用户 ID 的列表，这样我们也可以允许群聊。按照以下方式操作：
- en: 'Add the `addChat` function to `RootMutation` in the `resolvers.js` file, as
    follows:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `resolvers.js` 文件中添加 `addChat` 函数到 `RootMutation`，如下所示：
- en: '[PRE84]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Sequelize added the `setUsers` function to the chat model instance. It was added
    because of the associations using the `belongsToMany` method in the chat model.
    There, we can directly provide an array of user IDs that should be associated
    with the new chat, through the `users_chats` table.
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Sequelize 为聊天模型实例添加了 `setUsers` 函数。这是由于在聊天模型中使用 `belongsToMany` 方法建立关联而添加的。在那里，我们可以直接提供一个用户
    ID 数组，这些用户 ID 应与新的聊天相关联，通过 `users_chats` 表。
- en: 'Change the schema so that you can run the GraphQL mutation. We must add the
    new input type and mutation, as follows:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改模式以便运行 GraphQL 变异体。我们必须添加新的输入类型和变异体，如下所示：
- en: '[PRE85]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Test the new GraphQL `addChat` mutation as your request body:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试新的 GraphQL `addChat` 变异体，将以下内容作为请求体：
- en: '[PRE86]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: You can verify that everything worked by checking the users that were returned
    inside the `chat` object.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过检查 `chat` 对象中返回的用户来验证一切是否正常工作。
- en: Creating a new message
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新消息
- en: 'We can use the `addPost` mutation as our basis and extend it. The result accepts
    a `chatId` and uses the first user from our database. Later, the authentication
    will be the source of the user ID:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `addPost` 变异体作为基础并对其进行扩展。结果接受一个 `chatId` 并使用我们数据库中的第一个用户。稍后，认证将成为用户 ID
    的来源：
- en: 'Add the `addMessage` function to `RootMutation` in the `resolvers.js` file,
    as follows:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `addMessage` 函数添加到 `resolvers.js` 文件中的 `RootMutation`，如下所示：
- en: '[PRE87]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Then, add the new mutation to your GraphQL schema. We also have a new input
    type for our messages:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将新的变异体添加到你的 GraphQL 模式。我们还有一个新的消息输入类型：
- en: '[PRE88]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You can send the request in the same way as the `addPost` request:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以像发送 `addPost` 请求一样发送请求：
- en: '[PRE89]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now, everything is set. The client can now request all posts, chats, and messages.
    Furthermore, users can create new posts, create new chat rooms, and send chat
    messages.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切都已经设置好了。客户端现在可以请求所有帖子、聊天和消息。此外，用户可以创建新的帖子、创建新的聊天室，并发送聊天消息。
- en: Summary
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Our goal in this chapter was to create a working backend with a database as
    storage, which we have achieved pretty well. We can add further entities and migrate
    and seed them with Sequelize. Migrating our database changes won't be a problem
    for us when it comes to going into production.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是创建一个具有数据库作为存储的工作后端，我们做得相当不错。我们可以添加更多实体，并使用 Sequelize 进行迁移和初始化。当涉及到进入生产环境时，迁移我们的数据库更改对我们来说不会是问题。
- en: In this chapter, we also covered what Sequelize automates for us when using
    its models, and how great it works in coordination with our Apollo Server.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还介绍了 Sequelize 在使用其模型时为我们自动执行的操作，以及它与我们的 Apollo 服务器协同工作的出色表现。
- en: In the next chapter, we will focus on how to use the Apollo React Client library
    with our backend, as well as the database behind it.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点介绍如何使用 Apollo React 客户端库与我们的后端以及其背后的数据库。
