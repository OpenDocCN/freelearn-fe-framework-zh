- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Common Pitfalls to avoid when Building Microfrontends
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建微前端时需要避免的常见陷阱
- en: We’ve come a long way! We’ve learned how to build microfrontends, how to deploy
    them to the native cloud, and how to manage them in production.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走了很长的路！我们已经学会了如何构建微前端，如何将它们部署到原生云，以及如何在生产中管理它们。
- en: As we start working with microfrontends, we will make mistakes, but we will
    learn from them and eventually build our own set of best practices, discovering
    what works best for our use cases. However, it is always a smart thing to learn
    from others’ mistakes as well. In this chapter, we will cover some of the pitfalls
    earlier teams faced when working with microfrontends.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用微前端时，我们将会犯错误，但我们会从错误中学习，并最终建立我们自己的最佳实践集，发现对我们用例最有效的方法。然而，从他人的错误中学习始终是一个明智的选择。在本章中，我们将介绍早期团队在处理微前端时遇到的一些陷阱。
- en: 'We will teach you about some common pitfalls and how to avoid them, which are
    as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将教你一些常见的陷阱以及如何避免它们，如下所述：
- en: Not making your microapps too small
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要让你的微应用太小
- en: Avoiding the overuse of common shared code/libraries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免过度使用常见的共享代码/库
- en: Avoiding multiple frameworks within a microfrontend
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在微前端中使用多个框架
- en: The inability to deploy individual micro apps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法部署单个微应用
- en: Excessively relying on state
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度依赖状态
- en: Avoiding build-time compilation to assemble Microfrontends
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在构建时编译来组装微前端
- en: Avoiding packing your micro apps into NPM packages
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将微应用打包到NPM包中
- en: By the end of this chapter, you will have learned about the various pitfalls
    developers fall into when transitioning from single-page apps to microfrontends.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解到开发者从单页应用过渡到微前端时可能会陷入的各种陷阱。
- en: Don’t make your micro apps too small
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要让你的微应用太小
- en: We touched upon this at the start of the book, but it’s important to stress
    it again. Way too many developers think that, in a microfrontend architecture,
    the micro apps need to be really small. This is not true, as creating very small
    microapps greatly increases the complexity and maintenance headaches, without
    achieving any benefits.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书的开头提到了这一点，但重要的是再次强调。太多的开发者认为，在微前端架构中，微应用需要非常小。这并不正确，因为创建非常小的微应用会大大增加复杂性和维护难题，而不会带来任何好处。
- en: 'In trying to identify what the right size is for your micro app, we’ve seen
    it helps if we take into consideration the following points:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试确定你的微应用合适的尺寸时，我们发现考虑以下因素是有帮助的：
- en: Is it the largest possible micro app that can independently exist?
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是否是可以独立存在的可能最大的微应用？
- en: Is it the largest possible micro app that’s owned by a single agile scrum team?
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是否是单个敏捷Scrum团队拥有的可能最大的微应用？
- en: Does this app undergo changes and updates that are at a pace different from
    the rest of the application?
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个应用是否经历了与其他应用不同步的速度的变化和更新？
- en: Another point to consider is thinking in terms of domains, based on domain-driven
    design principles, to determine what business features a given micro app should
    support or not support.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个需要考虑的点是基于领域驱动设计原则，从领域角度思考，以确定一个特定的微应用应该支持或不应支持哪些业务功能。
- en: If your answer to all the preceding questions is yes, then the micro app is
    the right size. If the answer is no to any one of the preceding questions, then
    either we haven’t broken down our micro apps in the right way or microfrontends
    may not be the right architectural choice.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对所有前面的问题的回答都是肯定的，那么微应用的尺寸是合适的。如果对任何一个问题的回答是否定的，那么要么是我们没有正确地分解微应用，要么是微前端可能不是正确的架构选择。
- en: Another guide to help identify the right size for your app is to look at the
    atomic design pattern ([https://bradfrost.com/blog/post/atomic-web-design/](https://bradfrost.com/blog/post/atomic-web-design/)),
    which defines how components are structured in an application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个帮助确定应用合适尺寸的指南是查看原子设计模式（[https://bradfrost.com/blog/post/atomic-web-design/](https://bradfrost.com/blog/post/atomic-web-design/)），它定义了组件在应用中的结构。
- en: '![Figure 10.1 – Organisms and templates can be converted to micro apps](img/Figure_10.01_B18987.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 生命体和模板可以被转换为微应用](img/Figure_10.01_B18987.jpg)'
- en: Figure 10.1 – Organisms and templates can be converted to micro apps
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 生命体和模板可以被转换为微应用
- en: If you look at the atomic design pattern in *Figure 10**.1*, the ideal level
    to break down your app into micro apps would be either at the organism level or
    the template level; anything other than that would be either too small or too
    big.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看*图10.1*中的原子设计模式，将您的应用程序分解成微应用的理想级别将是生物体级别或模板级别；其他任何级别都可能是太小或太大。
- en: Breaking down the application into the right-sized micro app is key to building
    a performant and scalable microfrontend architecture, and investing more time
    in getting this right will pay high dividends as we move forward.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分解成适当大小的微应用是构建高性能和可扩展的微前端架构的关键，而且投入更多时间来确保这一点，随着我们向前发展，将会带来巨大的回报。
- en: Avoiding the overuse of Shared Component Code
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免过度使用共享组件代码
- en: When it comes to building microservices or microfrontends, team independence
    is the highest priority. Anything that makes a team dependent on another team
    should be strongly discouraged.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到构建微服务或微前端时，团队独立性是最高的优先级。任何使一个团队依赖另一个团队的事情都应该被强烈反对。
- en: In our experience as software developers, we’ve always come across principles
    such as **reusability**, **Do not Repeat Yourself** (**DRY**), and so on. In fact
    most senior developers are constantly looking how do they create common utilities,
    helpers shared components, and so on, to help the teams be more productive.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们作为软件开发者的经验中，我们始终会遇到诸如**可重用性**、**不要重复自己**（**DRY**）等原则。事实上，大多数高级开发者都在不断寻找如何创建通用工具、辅助共享组件等，以帮助团队提高生产力。
- en: However, when it comes to the world of microservices and microfrontends, overuse
    of these shared libraries can lead to what is called “dependency hell” or a “distributed
    monolith,” which is the worst of both worlds.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当涉及到微服务和微前端的世界时，过度使用这些共享库可能导致所谓的“依赖地狱”或“分布式单体”，这是两种情况的糟糕结合。
- en: This is bad for microfrontends because using shared libraries or code immediately
    takes away the independence of teams, as now two or more teams are dependent on
    updates or bug fixes to be made for this shared library, in order for them to
    be able to proceed further.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这对微前端来说很不利，因为使用共享库或代码立即剥夺了团队的独立性，因为现在两个或更多团队需要依赖对这个共享库的更新或错误修复，才能继续前进。
- en: As more and more teams start using a shared library, it tends to start getting
    bulkier, as it now needs to accommodate the use cases of the different teams.
    There is also a constant risk that changes or updates to this shared code may
    break the functionality of one or more teams.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越多的团队开始使用共享库，它往往会变得越来越大，因为它现在需要适应不同团队的使用案例。此外，还存在一个持续的风险，即对这个共享代码的更改或更新可能会破坏一个或多个团队的功能。
- en: Hence, when it comes to microfrontends, we need to be strict about not falling
    into this trap. As a rule of thumb, we should avoid creating any business or application
    logic as shared common code. One item that can ideally be shared between micro-apps
    is the UI component library because we want to ensure that all micro apps have
    a consistent look and feel. Another item that can be put into a shared library
    is any other low-level utility function that doesn’t contain any business logic.
    Some examples of these would be an HTTP client, an error-handling utility, or
    other utilities to format dates or manipulate strings.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当涉及到微前端时，我们需要严格避免陷入这个陷阱。作为一个经验法则，我们应该避免创建任何业务或应用程序逻辑作为共享通用代码。一个理想上可以在微应用之间共享的项目是UI组件库，因为我们希望确保所有微应用都有一致的外观和感觉。另一个可以放入共享库的项目是任何不包含业务逻辑的低级实用函数。这些示例包括HTTP客户端、错误处理实用工具或其他用于格式化日期或操作字符串的实用工具。
- en: Remember that with monorepos, it’s a lot easier to “find and replace” than to
    deal with the challenges of a distributed monolith.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在单仓库中，与处理分布式单体的挑战相比，“查找和替换”要容易得多。
- en: While initially the whole idea of prioritizing team independence over code reuse
    may sound like an anti-pattern and not a smart thing to do, speaking from experience,
    this is the second most important point to keep in mind when you want your teams
    to move fast and frequently deploy code to production.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最初将团队独立性优先于代码重用的整个想法可能听起来像是一种反模式，并不是一个明智的做法，但从经验来看，这是您希望团队快速行动并频繁将代码部署到生产环境时需要牢记的第二个重要点。
- en: Avoiding using multiple frameworks in your microfrontend
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免在微前端中使用多个框架
- en: 'One of the benefits of microfrontends is that, technically, it’s possible to
    have each app built using a different framework. However, just because it’s possible
    doesn’t mean you have to. There are numerous drawbacks to using multiple frameworks
    within a single microfrontend:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端的一个好处是，从技术上讲，每个应用都可以使用不同的框架构建。然而，尽管这是可能的，但这并不意味着你必须这样做。在单个微前端中使用多个框架存在许多缺点：
- en: The cognitive overload for team members as they potentially switch from one
    team to the other over time is very high.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着团队成员可能随着时间的推移从一个团队切换到另一个团队，认知负荷非常高。
- en: Since every framework comes with its own JavaScript bundle, and since every
    framework will have a different set of NPM modules that the team uses, the amount
    of JavaScript code transferred to the user’s devices will be high. Therefore,
    we will not be able to take full advantage of browser caching or service worker
    caching, since each app uses its own bundle.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个框架都附带自己的JavaScript包，并且每个框架都将使用不同的NPM模块集，因此传输到用户设备上的JavaScript代码量将很高。因此，我们无法充分利用浏览器缓存或服务工作者缓存，因为每个应用都使用自己的包。
- en: Different frameworks will have different performance challenges and issues,
    and each team will have to deal with them individually and not be able to use
    the collective knowledge within the broader team.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的框架将面临不同的性能挑战和问题，每个团队都必须单独处理这些问题，而无法利用更广泛团队中的集体知识。
- en: Having said that, it is fine to have multiple frameworks or multiple versions
    of them for a short transitional phase when you evaluate a new framework or incrementally
    upgrade to a newer version. Overall, though, having multiple frameworks as an
    architecture principle should be avoided.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在评估新框架或逐步升级到新版本时，拥有多个框架或它们的多个版本作为短暂的过渡阶段是可以接受的。总的来说，将多个框架作为架构原则应该避免。
- en: An inability to deploy an individual micro app
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无法部署单个微应用
- en: One of the primary reasons to adopt a microfrontend architecture is to allow
    certain parts of an application to be independently updated without impacting
    the rest of it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 采用微前端架构的一个主要原因是允许应用程序的某些部分独立更新，而不会影响其余部分。
- en: This obviously means that we need the ability to build and deploy each micro
    app independently. If your DevOps build and release pipeline can’t do this, then
    it’s better to go with **Single-Page Application** (**SPA**) architecture.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然意味着我们需要有能力独立构建和部署每个微应用。如果你的DevOps构建和发布管道无法做到这一点，那么选择**单页应用**（**SPA**）架构会更好。
- en: In the past, many DevOps tools weren’t sophisticated enough to work with monorepos
    or microfrontends; however, most of the latest tools are better equipped to detect
    which folders have changed and only trigger the necessary app builds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，许多DevOps工具还不够成熟，无法与monorepos或microfrontends协同工作；然而，大多数最新的工具都配备了更好的功能，能够检测哪些文件夹已更改，并且只触发必要的应用构建。
- en: Hence, when working on a microfrontend architecture, it is critical that you’ve
    thought it through and through, including how it will be deployed, as this will
    impact the choice of tools you select for the DevOps pipeline or the monorepo.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你在微前端架构上工作时，至关重要的是你必须彻底思考，包括它的部署方式，因为这会影响你为DevOps管道或monorepo选择的工具。
- en: For example, if your DevOps pipelines can be conditionally triggered based on
    which micro app has changed, then you are free to choose any monorepo tool.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的DevOps管道可以根据哪个微应用已更改进行条件触发，那么你可以自由选择任何monorepo工具。
- en: However, if your DevOps pipeline is unable to detect changes, or if you are
    limited to a single pipeline for all your microfrontends, then going with a mono
    repo tool such as Nx, which has built-in change detection, would be more suitable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的DevOps管道无法检测到更改，或者你被限制为为所有微前端使用单个管道，那么选择具有内置更改检测功能的单仓库工具，如Nx，将更为合适。
- en: Excessively relying on state
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过度依赖状态
- en: With the advent of React, state management became a thing, and with it rose
    the popularity of tools such as Redux that advocated a single central data store
    to manage state. Over time, developers seem to have become obsessed with state
    management, relying far too much on these state management libraries. When developers
    make the shift from SPAs to microfrontends, they continue their obsession with
    state and spend a lot of time trying to persist state, making it work across different
    micro apps. With SPAs and also microfrontends, it is important to sparingly use
    these application-level states. When working with microfrontends, we encourage
    exploring concepts around Pub/Sub or an event emitter approach to sharing data
    between different micro apps. Alternatively, look at native browser data stores,
    such as session storage, IndexedDB, or local storage to manage persistent state,
    or if none of these is an option, then explore lightweight state management libraries
    such as Zustand or React’s Context API.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 React 的出现，状态管理成为了一件事，随之而来的是像 Redux 这样的工具的流行，这些工具提倡使用单一中央数据存储来管理状态。随着时间的推移，开发者似乎对状态管理变得着迷，过度依赖这些状态管理库。当开发者从
    SPA 转向微前端时，他们继续对状态着迷，花费大量时间尝试持久化状态，使其在不同的微应用之间工作。在 SPA 和微前端中，重要的是要谨慎使用这些应用级状态。在处理微前端时，我们鼓励探索
    Pub/Sub 或事件发射器方法等概念，以在不同的微应用之间共享数据。或者，可以考虑使用原生的浏览器数据存储，如会话存储、IndexedDB 或本地存储来管理持久状态，或者如果这些都不适用，那么可以探索轻量级的状态管理库，如
    Zustand 或 React 的 Context API。
- en: As you may have realized by now, when building microfrontends, there is a fair
    bit of unlearning and relearning involved, especially if you have been building
    SPAs for a while. The use of state management in microfrontends is something that
    needs to be understood and is also the most difficult change that some developers
    occasionally have to deal with, especially those who have got used to excessively
    relying on state.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在可能已经意识到的，在构建微前端时，涉及相当多的重新学习和学习，尤其是如果您已经构建了很长时间的 SPA。在微前端中使用状态管理是需要理解和掌握的，也是一些开发者偶尔必须应对的最困难的变化，尤其是那些习惯了过度依赖状态的开发者。
- en: Avoiding build-time compilation to assemble Microfrontends
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免在构建时间编译以组装微前端
- en: There is a current trend in the frontend community to move as many tasks as
    possible to the build time phase of application compilation, rather than the runtime.
    Good examples of these are static site generation, where the HTML pages are generated
    at build time, or **Ahead of Time** (**AoT**) compilation in Angular, which improves
    the overall performance of an application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前端社区中目前有一个趋势，即将尽可能多的任务移动到应用程序编译的构建时间阶段，而不是运行时。这些例子包括静态站点生成，其中 HTML 页面是在构建时生成的，或者在
    Angular 中的**提前编译**（**AoT**），这可以提高应用程序的整体性能。
- en: While, in general, build-time compilation is a good practice, reducing the load
    on the browser and JavaScript engines during the runtime phase, it doesn’t help
    when assembling the microfrontend. This is because every time any microfrontend
    changes, you need to rebuild the assembly layer as well, defeating the principle
    of independent micro app deployments.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然，总的来说，构建时间编译是一种良好的实践，可以在运行时阶段减少浏览器和 JavaScript 引擎的负载，但在组装微前端时并没有帮助。这是因为每次任何微前端发生变化时，都需要重新构建组装层，这违背了独立微应用部署的原则。
- en: We can choose to have individual micro apps do more work during build time (e.g.,
    generate static pages), but the assembling of micro apps or module federation
    should always be done on the server or at runtime.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择让单个微应用在构建时间做更多的工作（例如，生成静态页面），但微应用或模块联邦的组装始终应该在服务器或运行时进行。
- en: This is another key point to keep in mind to ensure we don’t blindly follow
    “popular trends.” It is important to always remember what the key principles of
    your architecture pattern are and that you’ve thought through your pattern, end
    to end and all the way to how it will be deployed into production.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是需要记住的另一个关键点，以确保我们不会盲目跟随“流行趋势”。始终记住您架构模式的关键原则，并且您已经全面思考了您的模式，从端到端，一直到它如何部署到生产环境。
- en: Avoiding packing your micro apps into NPM packages
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免将微应用打包进 NPM 包
- en: Another common trend within the SPA world is to convert any sharable modules
    into NPM packages for easier distribution and then import them into other apps.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在单页应用（SPA）的世界中，另一个常见的趋势是将任何可共享的模块转换为 NPM 包，以便更容易地分发，然后将其导入到其他应用中。
- en: In our experience, we have seen a few teams package and version their micro
    apps into NPM modules before importing them into the host or assembly app. We
    strongly discourage this practice for the primary reason that every time a new
    version of a micro app is published as an npm module, all the hosts using that
    micro app will need to update their `package.json` files and rebuild and redeploy
    their apps, defeating the primary principle of independent deployments. We covered
    this in a bit of detail in [*Chapter 2*](B18987_02.xhtml#_idTextAnchor029), *Key
    Principles and Components of Microfrontends*, in the *Prefer runtime* *integrations*
    section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，我们见过一些团队在将微应用程序打包和版本化为NPM模块后，再将其导入到宿主或组装应用程序中。我们强烈反对这种做法，主要原因在于每次发布一个新的微应用程序版本作为npm模块时，所有使用该微应用程序的宿主都需要更新他们的`package.json`文件，并重新构建和重新部署他们的应用程序，这违背了独立部署的基本原则。我们已在[*第二章*](B18987_02.xhtml#_idTextAnchor029)“微前端的关键原则和组件”中的“*偏好运行时*集成”部分对此进行了详细说明。
- en: Summary
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With this, we come to the end of this chapter. Being a relatively new architecture
    pattern, the concepts and best practices around microfrontends are constantly
    evolving.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就来到了本章的结尾。作为一个相对较新的架构模式，微前端的概念和最佳实践正在不断演变。
- en: In this chapter, we saw some of the common pitfalls that teams have fallen into
    while building microfrontends – namely, things such as not being able to identify
    the right level at which to break down an app into a micro app, overuse of state
    management libraries, using multiple frameworks within a micro app, the inability
    to individually deploy a micro app, overuse of shared common code, and ending
    up with a build-time integration. Hopefully, this chapter will prevent you from
    repeating the same mistakes your peers have made in the past.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了一些团队在构建微前端时常见的陷阱——例如，无法确定将应用程序拆分为微应用程序的正确层级，过度使用状态管理库，在微应用程序中使用多个框架，无法单独部署微应用程序，过度使用共享通用代码，以及最终导致构建时集成。希望本章能帮助你避免重蹈覆辙，你的同行在过去犯过的错误。
- en: Another important point to remember is to understand the reasoning behind these
    best practices, looking at them through the lens of your specific use case. Follow
    the best practices that apply to your use case and tweak the ones that don’t quite
    fit it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要记住的重要点是理解这些最佳实践背后的原因，通过你具体用例的视角来看待它们。遵循适用于你用例的最佳实践，并调整那些不太适合的实践。
- en: As the famous saying goes, “*The answer to every architecture question is…*
    *it depends.*”
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如那句著名的话所说，“*对于每一个架构问题，答案都是…* *视具体情况而定*”
- en: In the next chapter, we will look at some of the emerging trends in the world
    of microfrontends that you should keep an eye on.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨微前端世界中的一些新兴趋势，这些趋势是你应该关注的。
