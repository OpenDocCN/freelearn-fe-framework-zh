<html><head></head><body>
  <div id="_idContainer358">
    <h1 class="chapterNumber">7</h1>
    <h1 class="chapterTitle" id="_idParaDest-222">Creating a Router-First Line-of-Business App</h1>
    <p class="normal"><strong class="bold">Line-of-Business</strong> (<strong class="bold">LOB</strong>) applications are the bread and butter of the software development world. As defined on Wikipedia, LOB is a general term that refers to a product or a set of related products that serve a particular customer transaction, or business need. LOB apps present an excellent opportunity to demonstrate a variety of features and functionality, without getting into the contorted or specialized scenarios that large enterprise applications usually need to address.</p>
    <p class="normal">The Pareto principle, also known as the 80-20 rule, states that we can accomplish 80% of our goals with 20% of the overall effort. We will be applying the 80-20 rule to the design and architecture of our LOB app. Given the common use cases LOB apps cover, they are, in a sense, perfect for the 80-20 learning experience. With only 20% of the effort, you can learn about 80% of the things you will need to deliver high-quality experiences to your users.</p>
    <p class="normal">LOB apps have a curious property to them. If you end up building a semi-useful app, the demand for it grows, uncontrollably, and you quickly become the victim of your success. It's challenging to balance the architectural needs of a project; you want to avoid potentially devastating under-engineering and, on the flip side, also avoid costly over-engineering for an app that will never need it.</p>
    <p class="normal">In this chapter, I'm going to introduce you to router-first architecture, the 80-20 design solution to address the challenges of delivering a modern web application in an incremental and iterative manner. </p>
    <p class="normal">As you read in <em class="italics">Chapter 1</em>, <em class="italics">Introduction to Angular and Its Concepts</em>, software architecture doesn't stay static. It's essential to experiment with new ideas by using coding-katas, proofs-of-concept apps, and reference projects, to get better at creating more flexible architectures.</p>
    <p class="normal">In this and the remaining chapters of the book, we'll set up a new application with rich features that can meet the demands of an LOB application with a scalable architecture and engineering best practices that will help you start small and be able to grow your solution quickly if there's demand. We will follow the Router-first design pattern, relying on reusable components to create a grocery store LOB named LemonMart. We'll discuss the idea of designing around major data entities, and the importance of completing high-level mock-ups for your application before you start to implement various conditional navigation elements, which may change significantly during the design phase.</p>
    <p class="normal">In this chapter, you will learn to do the following:</p>
    <ul>
      <li class="list">Apply the 80-20 solution to software development</li>
      <li class="list">Learn how to build router-first apps</li>
      <li class="list">Begin your creation of the LemonMart app you'll expand over the remainder of this book</li>
      <li class="list">Create effective branding, as well as custom and material iconography</li>
      <li class="list">Achieve sub-second first-paint with lazy loading</li>
      <li class="list">Create a walking skeleton</li>
      <li class="list">Reduce repetition using a common testing module</li>
      <li class="list">Design around major data entities</li>
      <li class="list">Recognize the importance of high-level UX design</li>
    </ul>
    <p class="normal">The most up-to-date versions of the sample code for the book are on GitHub at the following linked repository. The repository contains the final and completed state of the code. You can verify your progress at the end of this chapter by looking for the end-of-chapter snapshot of code under the <code class="Code-In-Text--PACKT-">projects</code> folder.</p>
    <p class="normal"><em class="italics">For Chapter 7</em>:</p>
    <ol>
      <li class="list">Clone the repo <a href="https://github.com/duluca/lemon-mart "><span class="url">https://github.com/duluca/lemon-mart</span></a></li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">npm install</code> on the root folder to install dependencies</li>
      <li class="list">The code sample for this chapter is under the sub-folder:
        <pre class="programlisting"><code class="hljs">projects/ch7
</code></pre>
      </li>
      <li class="list">To run the Angular app for this chapter, execute:
        <pre class="programlisting"><code class="hljs nginx"><span class="hljs-attribute">npx</span> ng serve ch7
</code></pre>
      </li>
      <li class="list">To run Angular unit tests for this chapter, execute:
        <pre class="programlisting"><code class="hljs bash">npx ng <span class="hljs-built_in">test</span> ch7 --watch=<span class="hljs-literal">false</span>
</code></pre>
      </li>
      <li class="list">To run Angular e2e tests for this chapter, execute:
        <pre class="programlisting"><code class="hljs nginx"><span class="hljs-attribute">npx</span> ng e2e ch7
</code></pre>
      </li>
      <li class="list" value="7">To build a production-ready Angular app for this chapter, execute:
        <pre class="programlisting"><code class="hljs ada">npx ng build ch7 <span class="hljs-comment">--prod</span>
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p>Note that the <code class="Code-In-Text--PACKT-">dist/ch7</code> folder at the root of the repository will contain the compiled result.</p>
    </div>
    <div class="note">
      <p class="Information-Box--PACKT-">Beware that the source code in the book or on GitHub may not always match the code generated by the Angular CLI. There may also be slight differences in implementation between the code in the book and what's on GitHub, because the ecosystem is ever-evolving. It is natural for the sample code to change over time.</p>
      <p class="Information-Box--PACKT-">Also, on GitHub, expect to find corrections, fixes to support newer versions of libraries, or side-by-side implementations of multiple techniques for you to observe. You are only expected to implement the ideal solution recommended in the book. If you find errors or have questions, please create an issue or submit a pull request on GitHub for the benefit of all readers.</p>
    </div>
    <div class="packt_tip">
      <p>You may read more about updating Angular in <em class="italics">Appendix C</em>, <em class="italics">Keeping Angular and Tools Evergreen</em>. You can find this appendix online from <a href="https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen."><span class="url">https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf</span></a> or at <a href="https://expertlysimple.io/stay-evergreen"><span class="url">https://expertlysimple.io/stay-evergreen</span></a>.</p>
    </div>
    <p class="normal">Let's start by covering the philosophy behind the design and architecture of our apps.</p>
    <h1 class="title" id="_idParaDest-223">The 80-20 solution</h1>
    <p class="normal">Whether we develop apps at home, for passion projects, or at the office, for work, we must remain <a id="_idIndexMarker601"/>mindful of our purpose: to deliver value. If we don't deliver value with our passion projects, then we won't feel fulfilled or happy. If we fail to deliver value at work, we may not get paid.</p>
    <p class="normal">Delivering a modern web application is difficult. There are numerous challenges that we need to overcome to be successful:</p>
    <ul>
      <li class="list">Deliver iteratively and incrementally</li>
      <li class="list">Be scalable</li>
      <li class="list">Serve dozens of screen and input types</li>
      <li class="list">Be usable</li>
      <li class="list">Be accessible</li>
      <li class="list">Manage a team</li>
      <li class="list">Groom a prioritized backlog</li>
      <li class="list">Ensure acceptance criteria are clear, concise, and concrete</li>
    </ul>
    <p class="normal">If you've ever led a project or tried to implement and deliver a project on your own, you'll have realized that there's just never enough time and resources to cover the wide variety of stakeholder, team, and technical needs on any given project. Remember that the Pareto principle, also known as the 80-20 rule, implies that we can accomplish 80% of our goals with 20% of the overall effort.</p>
    <p class="normal">If we apply <a id="_idIndexMarker602"/>the 80-20 rule to our work, we can maximize our output, quality, and happiness. Line-of-business applications are the bread and butter of our industry. Applying the 80-20 rule, we can surmise that most of us are likely to earn most of our income by delivering such applications. Therefore, we should keep our engineering overhead to a minimum, and reduce the delivery risk of our project. By limiting experimentation in production code, we create a predictable environment for our team members, and only introduce changes that we had a chance to vet in proof-of-concept or small apps.</p>
    <p class="normal">Our 80-20 strategy, combined with discipline, can help us deliver the same project in the same time with more features and better quality. By treating our careers as marathons and not a series of sprints, you can find yourself in a position of delivering high-quality solutions, project after project, without feeling burned out.</p>
    <h2 class="title" id="_idParaDest-224">Understanding Line-of-Business apps</h2>
    <p class="normal">Line-of-business <a id="_idIndexMarker603"/>applications are, according to Wikipedia, a "set of critical computer applications perceived as vital to running an enterprise." LOB apps are what most developers end up developing, even though we may think we develop small apps or large enterprise apps. Consider the following illustration, which demonstrates the kinds of apps we might develop, placed on an axis relative to their size and scope:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_01.png"/></figure>
    <p class="packt_figref">Figure 7.1: Relative size and scope of four kinds of apps</p>
    <p class="normal">From my <a id="_idIndexMarker604"/>perspective, we think about four kinds of apps when we begin developing software: </p>
    <ul>
      <li class="list">Small apps</li>
      <li class="list">LOB apps</li>
      <li class="list">Large enterprise apps</li>
      <li class="list">Billion user scale apps</li>
    </ul>
    <p class="normal">Billion user scale apps are completely niche implementations that rarely have needs that align with the vast majority of apps that are out there. For this reason, we must classify these apps as outliers.</p>
    <p class="normal">Small apps start small. Architecturally, they're likely to be initially under-engineered. As you add features and team members to work on a small app, at some point, you're going to run into trouble. As your team size and feature set grow, or the overall complexity of the app increases, the architectural needs of the application grow exponentially. </p>
    <p class="normal">Once you cross the inflection point of the amount of complexity your architecture can bear, you're left with a costly reengineering effort to get back on track. See the following graph, illustrating this idea:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_02.png"/></figure>
    <p class="packt_figref">Figure 7.2: Architectural journey of a small app</p>
    <p class="normal">The area under <a id="_idIndexMarker605"/>the feature line represents under-engineering, which introduces risk to your project. The area above the feature line shows the required engineering overhead to support the features needed. In comparison, large enterprise apps start with a massive over-engineering effort, as shown in the following diagram:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_03.png"/></figure>
    <p class="packt_figref">Figure 7.3: Architectural journey of a large enterprise app</p>
    <p class="normal">As time goes on and the overall complexity of the system increases, large enterprise apps can also face a similar inflection point, where the original architecture can become inadequate. With careful planning and management, you can avoid trouble and protect the significant <a id="_idIndexMarker606"/>initial investment made. Such large enterprise apps require hundreds of developers, with multiple levels of managers and architects, to execute successfully. Similar to billion-user scale apps, these apps can also have niche architectural needs. In between the small apps and the large enterprise apps that we develop lie LOB apps.</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_04.png"/></figure>
    <p class="packt_figref">Figure 7.4: Dynamic nature of software evolution</p>
    <p class="normal">As shown in the preceding diagram, small apps can grow and morph into LOB apps, and large enterprise apps can become under-utilized as users ignore the features that they never need, but keep the app to serve a singular purpose as a LOB app. In either case, despite our best efforts, we ultimately end up delivering an inefficient solution for the problem we're solving. None of us have a crystal ball to see the future, and planning and engineering can only do so much for us in an unpredictable business setting; we need to rely on the 80-20 rule to come up with an architecture that is flexible to change, but adequate to meet most business requirements.</p>
    <p class="normal">Router-first architecture aims to maintain optimal architectural overhead, so that in the rush to deliver all required features, costly re-engineering or late-stage crunch can be avoided. Let's see how.</p>
    <h2 class="title" id="_idParaDest-225">Disciplined and balanced approach</h2>
    <p class="normal">We covered <a id="_idIndexMarker607"/>the <em class="italics">what</em> of software development, but we must also consider the <em class="italics">why</em>, <em class="italics">when</em>, <em class="italics">where</em>, and <em class="italics">who</em>, before we can get to the <em class="italics">how</em>. When we develop apps for learning or passion projects, we usually end up under-engineering our projects. If your passion project somehow becomes an overnight success, then it becomes costly to maintain or keep adding features to your app. In this case, you're likely to face a choice to either bear the cost of ongoing maintenance, or rewrite your application.</p>
    <p class="normal">When we develop apps for work, we tend to be more conservative, and we're likely to over-engineer our solution. However, if you only code for work, then you're likely to experiment in production-bound code. It is dangerous to experiment in a codebase with other team members. You may be introducing a new pattern, without your team understanding the consequences of your choices. You're also less likely to be aware of mid-to long-term risks or benefits of the technologies you are introducing.</p>
    <p class="normal">Reckless experimentation can also have a severe negative impact on your team members. In a team <a id="_idIndexMarker608"/>of senior and experienced software engineers, you can likely get away with experimenting in a moving car. However, we are likely to have team members of varying backgrounds and learning styles on our teams. Some of us have computer science degrees, some of us are lone wolves, and some of us depend a bit too much on Stack Overflow. Some of us work at companies that are great at supporting professional growth, but some of us work at places that won't even give you a day to learn something new. So, when we are experimenting, we must consider our environment; otherwise we can cause our colleagues to work overtime or feel helpless and frustrated.</p>
    <p class="normal">With a disciplined and balanced approach, we can reduce the number of bugs delivered, avoid costly rework, and work with a group of people who are all moving in the same direction. We also need the right architecture, tools, and patterns/practices to deliver successfully. In summary, our approach must consider:</p>
    <ul>
      <li class="list">The size of our app</li>
      <li class="list">The reason we are developing the app</li>
      <li class="list">The skill level of developers</li>
      <li class="list">Iterative and incremental delivery</li>
      <li class="list">Constant forward flow of features</li>
      <li class="list">All the cloud things</li>
    </ul>
    <p class="normal">Ideally, we need to maintain optimal engineering overhead. Our architecture should support our short-term needs while being extensible, so we can pivot in different directions if our mid-or long-term needs change without having to rewrite large swaths of code. Consider the following diagram, in contrast to the ones about small and large enterprise apps in the previous section:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_05.png"/></figure>
    <p class="packt_figref">Figure 7.5: Ideal architectural journey of a LOB app</p>
    <p class="normal">Router-first <a id="_idIndexMarker609"/>architecture aims to help you find the balance in the engineering overhead, feature delivery, and flexibility of your codebase. However, you must bring the discipline yourself.</p>
    <div class="note">
      <p class="Information-Box--PACKT-"><img alt="" src="../Images/B14094_07_003.png"/> or Shu Ha Ri is a concept that can help bring discipline to your work. It is a way of thinking that instructs you first to master the basics without worrying about the underlying theory, then master the theory, and finally be able to adapt what you mastered to your needs. However, if you skip steps 1 or 2, you are going to find yourself adapting the wrong thing in the wrong way.</p>
    </div>
    <p class="normal">Having covered the <em class="italics">what</em>, <em class="italics">why</em>, <em class="italics">when</em>, <em class="italics">where</em>, and <em class="italics">who</em>, let's jump into the <em class="italics">how</em> in the next section.</p>
    <h1 class="title" id="_idParaDest-226">Router-first architecture</h1>
    <p class="normal">Router-first <a id="_idIndexMarker610"/>architecture is a way to:</p>
    <ul>
      <li class="list"><strong class="bold">Enforce</strong> high-level thinking</li>
      <li class="list"><strong class="bold">Ensure</strong> consensus on features, <em class="italics">before</em> you start coding</li>
      <li class="list"><strong class="bold">Plan</strong> for your codebase/team to grow</li>
      <li class="list"><strong class="bold">Introduce</strong> little engineering overhead</li>
    </ul>
    <p class="normal">There are seven steps to implementing router-first architecture:</p>
    <ol>
      <li class="list" value="1">Develop a roadmap and scope (<em class="italics">Chapter 7</em>)</li>
      <li class="list">Design with lazy loading in mind (<em class="italics">Chapter 7</em>)</li>
      <li class="list">Implement a walking-skeleton navigation experience (<em class="italics">Chapter 7</em>)</li>
      <li class="list">Achieve a stateless, data-driven design (<em class="italics">Chapters 7</em> and <em class="italics">10</em>)</li>
      <li class="list">Enforce a decoupled component architecture (<em class="italics">Chapters 8</em>, <em class="italics">11</em>, and <em class="italics">12</em>)</li>
      <li class="list">Differentiate between user controls and components (<em class="italics">Chapter 11</em>)</li>
      <li class="list">Maximize code reuse with TypeScript and ES features (<em class="italics">Chapters 8</em>, <em class="italics">10</em>, <em class="italics">11</em>, and <em class="italics">12</em>)</li>
    </ol>
    <p class="normal">Each step <a id="_idIndexMarker611"/>will be covered in more detail in this and coming chapters, as noted previously. Before we go over these steps at a high level, let's first cover feature modules in Angular, which are an important fundamental technical concept.</p>
    <h2 class="title" id="_idParaDest-227">Feature modules</h2>
    <p class="normal">In <em class="italics">Chapter 1</em>, <em class="italics">Introduction to Angular and Its Concepts</em>, we covered Angular's architecture at a high level and introduced the concepts of lazy loading and routing. Feature modules are a key <a id="_idIndexMarker612"/>component in implementing lazy loading. There are two kinds of modules, the root module and feature modules. Modules are implemented by the class <code class="Code-In-Text--PACKT-">NgModule</code>. An <code class="Code-In-Text--PACKT-">NgModule</code> contains all the necessary metadata to render components and inject services. A component without a module doesn't do much.</p>
    <p class="normal">An Angular application is defined by an <code class="Code-In-Text--PACKT-">NgModule</code> that sits at the root of the application. This is called the root module. The root module is responsible for rendering what appears in the <code class="Code-In-Text--PACKT-">&lt;app-root&gt;</code> element in your <code class="Code-In-Text--PACKT-">index.html</code> file. Locate the root module in the following diagram:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_06.png"/></figure>
    <p class="packt_figref">Figure 7.6: Major architectural components of Angular</p>
    <p class="normal">An NgModule can contain many other NgModules. An Angular app only has one root module, so by definition every other NgModule becomes a feature module. In the preceding diagram, you can see that you <a id="_idIndexMarker613"/>can organize a group of components (<strong class="bold">Cmp</strong>) and services (<strong class="bold">Svc</strong>) into feature modules. Grouping functionality <a id="_idIndexMarker614"/>into modules allows us to organize our code into chunks, which can be separated from the initial payload of our application.</p>
    <p class="normal">This idea of <a id="_idIndexMarker615"/>root and feature modules represents a parent/child relationship, which is a concept that extends to other functionality and frameworks. For example, note that the preceding diagram injects a root router into the root module. A root router can have child routes. Child routes can be configured to load feature modules. Similarly, NgRx has root and feature module-level stores to organize the state data of your application.</p>
    <div class="packt_tip">
      <p>For all intents and purposes, any mention of a sub-module, child module, or a feature module in this book refers to the same thing: a module that is not the root module.</p>
    </div>
    <p class="normal">Feature modules and child routes allows for a separation of concerns between major components of your application. Two teams can work on two different modules without interfering with each other. This separation means that any dependency required by a feature module must be explicitly added to the imports, declarations, or providers of that module. This can seem repetitive and annoying, when sharing code between modules, but it is a necessary evil.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">In Angular, by default, services are singletons – one instance per module. Before importing a service that's already imported to the root module into a feature module, consider if this is truly the desired behavior. A service that is provided in the root module is available to be imported in a feature module without needing to be provided again. Providing a service in the root and feature modules will result in having multiple instances of that service in memory, which breaks your expectation that, by default, services are singletons. In <em class="italics">Chapter 8</em>, <em class="italics">Designing Authentication and Authorization</em>, you will see this in action when we implement the <code class="Code-In-Text--PACKT-">AuthService</code>.</p>
    </div>
    <p class="normal">With the introduction of the Ivy rendering engine in Angular 9, the road is paved to create self-describing components. Self-describing components do not need an NgModule to be useful. With future versions of Angular it will be possible to implement simple apps without the whole ceremony (read: boilerplate code) of modules.</p>
    <p class="normal">Now, let's go <a id="_idIndexMarker616"/>over the seven steps of router-first architecture at a high level.</p>
    <h2 class="title" id="_idParaDest-228">Developing a roadmap and scope</h2>
    <p class="normal">Developing a roadmap and establishing the scope of your project early on is critical to getting the <a id="_idIndexMarker617"/>high-level architecture right. Creating a backlog, wireframes, mock-ups and interactive prototypes will help you define <a id="_idIndexMarker618"/>the map before getting on the road and capture the vision concretely. It is important to remember to bring tools only when necessary. Don't start with Photoshop, when a piece of paper and a pencil will do. If stakeholders and team members understand what is being developed, then it will be possible to deliver your solution iteratively and incrementally. However, don't fall into the perfection trap. Save the tweaking and furniture rearranging for after the fundamentals are in place and agreed upon.</p>
    <div class="packt_tip">
      <p>Document every artifact you create. Later in the chapter we cover how you can leverage GitHub Wikis to store your artifacts.</p>
    </div>
    <p class="normal">Later in this chapter, we will go over how to develop a roadmap and a technique to define your scope, building on the roadmap building techniques covered in <em class="italics">Chapter 3</em>, <em class="italics">Creating a Basic Angular App</em>.</p>
    <h2 class="title" id="_idParaDest-229">Designing with lazy loading in mind</h2>
    <p class="normal">First-paint <a id="_idIndexMarker619"/>matters, a lot! According to Google Analytics data gathered by the Angular Team in 2018, 53% of mobile users abandoned a website when load times exceeded 3 seconds. During the same time period most websites were consumed on mobile devices, around 70%+ in the US and 90%+ in China. As we covered in <em class="italics">Chapter 5</em>, <em class="italics">Delivering High-Quality UX with Material</em>, UI libraries and static assets can add significant size to your application. Given that most content is consumed on mobile, it's very important to defer the loading of non-critical assets.</p>
    <p class="normal">We defer loading of assets by divvying up the parts of our Angular application into feature modules. This way Angular can load only the assets that are necessary to render the current screen and dynamically download further resources as they are needed. A good way to divide your application into feature modules is by defining the various user roles your application may use. User roles normally indicate the job function of a user, such as a manager or data-entry specialist. In technical terms, they can be thought of as a group of actions that a particular class of user is allowed to execute. After all, a data-entry specialist won't ever see most of the screens that a manager can, so why deliver those assets to those users and slow down their experience?</p>
    <p class="normal">Lazy loading <a id="_idIndexMarker620"/>is critical in creating a scalable application architecture, allowing you to deliver high-quality and efficient products. Lazy loading is a low-hanging fruit that we will tackle as a baseline design goal. It can be costly to implement lazy loading after the fact.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Starting with Angular 9, it is possible to lazy load individual components. Angular 9's Ivy rendering engine enables self-describing and standalone components. Components that do not require all the bootstrapping that an Angular application requires have the potential to revolutionize and simplify how we design applications. However, it is not yet feasible to design apps this way. Expect future versions of Angular to introduce public APIs that make it easy to use the new features, reducing the need to carefully design feature modules early on.</p>
    </div>
    <p class="normal">Later in this chapter, you will learn about how to implement lazy loading using feature modules.</p>
    <h2 class="title" id="_idParaDest-230">Implementing a walking-skeleton</h2>
    <p class="normal">Configuring lazy loading can be tricky, which is why it is essential to nail down a walking-skeleton <a id="_idIndexMarker621"/>navigation experience early on. Implementing a clickable version of your app will help you gather feedback from users early on. That way, you'll be able to work out fundamental workflow and integration issues quickly. Additionally, you'll be able to establish a concrete representation of the scope of your current development effort. Developers and stakeholders alike will be able to better visualize how the end product will look. </p>
    <p class="normal">A walking-skeleton also sets the stage for multiple teams to work in tandem. Multiple people can start developing different feature modules or components at the same time, without worrying about how the puzzle pieces are going to come together later on. By the end of this chapter, you will have completed implementing the walking-skeleton of the sample app LemonMart.</p>
    <h2 class="title" id="_idParaDest-231">Achieve a stateless, data-driven design</h2>
    <p class="normal">As highlighted in <em class="italics">Chapter 10</em>, <em class="italics">RESTful APIs and Full-Stack Implementation</em>, stateless design <a id="_idIndexMarker622"/>in full-stack architecture is critical to implementing a maintainable application. As covered in <em class="italics">Chapter 1</em>, <em class="italics">Introduction to Angular and Its Concepts</em>, and later in <em class="italics">Chapter 12</em>, <em class="italics">Recipes – Master/Detail, Data Tables, and NgRx</em>, the flux pattern and NgRx make it possible to achieve an immutable state for your application. However, the flux pattern is likely to be overkill for most applications. NgRx itself leverages a lot of the core technologies present in RxJS.</p>
    <p class="normal">We are going to use RxJS and the reactive programming paradigm to implement a minimal, stateless, and data-driven pattern for our application. Identifying major data entities, such as invoices or people, that your users will work with is going to help you avoid over-engineering your application. Designing around major data entities will inform API design early on, and help define <code class="Code-In-Text--PACKT-">BehaviorSubject</code> data anchors that you will use to achieve a stateless, data-driven design. That design will, in turn, ensure a decoupled component architecture, as detailed in <em class="italics">Chapter 6</em>, <em class="italics">Forms, Observables, and Subjects</em>.</p>
    <p class="normal">By defining observable data anchors, you can ensure that data across various components will be kept in sync. By writing functional reactive code, leveraging RxJS features, and not storing state in components, we can implement immutable data streams.</p>
    <p class="normal">We will cover how to design the data models for your application in <em class="italics">Chapter 10</em>, <em class="italics">RESTful APIs and Full-Stack Implementation</em>, and will continue using these models in the following chapters.</p>
    <h2 class="title" id="_idParaDest-232">Enforce a decoupled component architecture</h2>
    <p class="normal">As we discussed in <em class="italics">Chapter 1</em>, <em class="italics">Introduction to Angular and Its Concepts</em>, decoupling components <a id="_idIndexMarker623"/>of your architecture is critical in ensuring a maintainable codebase. In Angular, you can decouple components by leveraging <code class="Code-In-Text--PACKT-">@Input</code> and <code class="Code-In-Text--PACKT-">@Output</code> bindings and Router orchestration.</p>
    <p class="normal">Bindings will help you maintain a simple hierarchy of components, and avoid using dynamic templates in situations where static designs are more effective, such as the creation of multi-page forms.</p>
    <p class="normal">Router outlets and auxiliary paths allow you to compose your view using the router. Resolvers can help load data by consuming router parameters. Auth guards can help control access to various modules and components. Using router links, you can dynamically customize elements that a user will see in an immutable and predictable way, similar to the way we designed and developed data anchors in the previous step.</p>
    <p class="normal">If you ensure every component is responsible for loading its own data, then you can compose <a id="_idIndexMarker624"/>components via URLs. However, overusing the router can in itself become an anti-pattern. If a parent component logically owns a child component, then the effort to decouple them will be wasted.</p>
    <p class="normal">In <em class="italics">Chapter 6</em>, <em class="italics">Forms, Observables, and Subjects</em>, you learned how to enable component interactions using <code class="Code-In-Text--PACKT-">BehaviorSubject</code>. In <em class="italics">Chapter 11</em>, <em class="italics">Recipes – Reusability, Routing, and Caching</em>, you will learn how to implement <code class="Code-In-Text--PACKT-">@Input</code> and <code class="Code-In-Text--PACKT-">@Output</code> bindings and in the upcoming chapters you will learn about how to implement router features.</p>
    <h2 class="title" id="_idParaDest-233">Differentiate between user controls and components</h2>
    <p class="normal">Another important idea is differentiating user controls from components. A user control is like <a id="_idIndexMarker625"/>a custom date input, or a custom star rater. It is often highly interactive and dynamic code that ends up being highly coupled, convoluted, and complicated code. Such controls may use Angular features no one has ever heard of before, which are most likely not covered in this book.</p>
    <p class="normal">A component is more like a form with fields, which may contain simple date inputs or a star rater. Because forms encapsulate business functionality, their code must be easy to read and understand. Your code should stick to Angular basics, so the code is stable and easy to maintain, like most of the code that is presented in this book.</p>
    <p class="normal">By differentiating between user controls and components you can make better decisions when deciding what kind of code you want to make reusable. Creating reusable code is costly. If you create the right reusable code, you can save time and resources. If you create the wrong reusable code, then you can waste a lot of time and resources.</p>
    <p class="normal">Wire-framing allows you to identify reusable elements early on. User controls will help keep user interaction code separate from business logic. Well-crafted component reuse will enable you to encapsulate domain-specific behavior, and share it later.</p>
    <p class="normal">It's important to identify self-contained user controls that encapsulate unique behaviors that you wish to create for your app. User controls will likely be created as directives or components that have data-binding properties and tightly coupled controller logic and templates.</p>
    <p class="normal">Components, on the other hand, leverage router life cycle events to parse parameters and perform CRUD operations on data. Identifying these component reuses early on will result <a id="_idIndexMarker626"/>in creating more flexible components that can be reused in multiple contexts (as orchestrated by the router), maximizing code reuse.</p>
    <p class="normal">We will cover how to create reusable components and user controls in <em class="italics">Chapter 11</em>, <em class="italics">Recipes – Reusability, Routing, and Caching</em>.</p>
    <h2 class="title" id="_idParaDest-234">Maximize code reuse with TypeScript and ES</h2>
    <p class="normal">It's essential to remember the underlying features of the language you work with before you <a id="_idIndexMarker627"/>consider the features offered by Angular, RxJS, and all the libraries you use. There are decades of software <a id="_idIndexMarker628"/>engineering fundamentals that you can leverage to write readable and maintainable code.</p>
    <p class="normal">First and foremost is the DRY principle. It stands for don't repeat yourself. So, don't copy-paste code. Don't just change a variable or two. Proactively refactor your code to make your functions stateless and reusable. In a few words: don't repeat yourself, don't repeat yourself, and don't repeat yourself.</p>
    <p class="normal">Leverage object-oriented design. Move behavior to classes; if your person has a <code class="Code-In-Text--PACKT-">fullName</code> property, don't re-implement the same logic in a dozen different places, but implement it once in the <code class="Code-In-Text--PACKT-">person</code> class. This means you will need to become familiar with hydration, also known as injecting a JSON object into a newly instantiated class, and serialization using <code class="Code-In-Text--PACKT-">toJSON</code>. It is important not to abuse OOP. You should still remain stateless, and functional, by avoiding storing state in class parameters.</p>
    <div class="packt_tip">
      <p>You can truly unleash the power of OO design by leveraging generics, inheritance, and abstract classes.</p>
    </div>
    <p class="normal">TypeScript introduces the concept of interfaces to JavaScript. Interfaces are a concept mostly reserved for statically typed languages. An interface represents an abstract notion of what an object can do, without specifying any implementation details. Furthermore, an interface can be used to document the shape of data. For example, you can write a partial interface of a third-party API to document the fields you're interested in consuming. When other developers read your code, they have an inherent understanding of the structure of the data they're consuming, without having to read documentation on another website. </p>
    <p class="normal">Interfaces also allow you to morph the shape of your data in a well-defined manner. So, you can <a id="_idIndexMarker629"/>write a transform function to transform the shape of external data into internal data. TypeScript will catch any errors you may make. Taking this concept further, you can also use interfaces to flatten data. If the data you receive has a multi-entity relational structure, you can flatten the relationship to decouple the design of the data from your UI code.</p>
    <div class="packt_tip">
      <p>Don't overly flatten your data. Arrays and simple shapes for common objects are okay, such as a name object or commonly used domain-specific object.</p>
    </div>
    <p class="normal">You <a id="_idIndexMarker630"/>should also avoid string literals in your code. Writing business logic where you compare <code class="Code-In-Text--PACKT-">'apples' !== 'Oranges'</code> results in unmaintainable code. You should leverage <code class="Code-In-Text--PACKT-">enums</code> in TypeScript, so your code isn't subject to the spelling mistakes of coders or changing business requirements. So <code class="Code-In-Text--PACKT-">'oranges' === Fruit.Organes</code>.</p>
    <p class="normal">Beyond TypeScript and ECMAScript, Angular also offers helpful functions for you to reuse logic. Angular validators, pipes, route resolvers, and route guards all allow you to share code across components and templates.</p>
    <p class="normal">The following chapters will demonstrate the aforementioned concepts:</p>
    <ul>
      <li class="list"><em class="italics">Chapter 8</em>, <em class="italics">Designing Authentication and Authorization</em></li>
      <li class="list"><em class="italics">Chapter 10</em>, <em class="italics">RESTful APIs and Full-Stack Implementation</em></li>
      <li class="list"><em class="italics">Chapter 11</em>, <em class="italics">Recipes – Reusability, Routing, and Caching</em></li>
      <li class="list"><em class="italics">Chapter 12</em>, <em class="italics">Recipes – Master/Detail, Data Tables, and NgRx</em></li>
    </ul>
    <p class="normal">Next, let's start by creating, LemonMart™, a fully featured line-of-business app that you can use as a template to kickstart your next professional project. LemonMart is a robust and realistic project that can support feature growth and different backend implementations, and it comes with a complete and configurable authentication and authorization solution out of the box.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Since its introduction, LemonMart has served more than 160,000 lemons to over 14,000 developers. Zesty! <span class="mediaobject"><img alt="" src="../Images/B14094_07_001.png"/></span></p>
    </div>
    <p class="normal">You can always clone the finished project from GitHub, <a href="https://www.github.com/duluca/lemon-mart"><span class="url">https://www.github.com/duluca/lemon-mart</span></a>, whenever you need it. Let's jump right into it.</p>
    <h1 class="title" id="_idParaDest-235">Creating LemonMart</h1>
    <p class="normal">LemonMart will be a mid-sized line-of-business application with over 90 code files. We will start <a id="_idIndexMarker631"/>our journey by creating a new Angular app, with routing and Angular Material configured from the get-go.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">It is presumed that you have installed all the requisite software mentioned in <em class="italics">Chapter 2</em>, <em class="italics">Setting Up Your Development Environment</em>. If you have not, execute the following commands for your OS to configure your environment.</p>
      <p class="Information-Box--PACKT-">On Windows PowerShell, execute:</p>
      <pre class="programlisting"><code class="hljs arduino">PS&gt; Install-Script -Name <span class="hljs-built_in">setup</span>-windows-dev-env
PS&gt; <span class="hljs-built_in">setup</span>-windows-dev-env.ps1
</code></pre>
      <p class="Information-Box--PACKT-">On macOS Terminal, execute:</p>
      <pre class="programlisting"><code class="hljs elixir"><span class="hljs-variable">$&gt;</span> bash &lt;(wget -O - <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/git.io/</span>JvHi1)
</code></pre>
      <p class="Information-Box--PACKT-">For more information refer to <a href="https://github.com/duluca/web-dev-environment-setup"><span class="url">https://github.com/duluca/web-dev-environment-setup</span></a>.</p>
    </div>
    <h2 class="title" id="_idParaDest-236">Creating a router-first app</h2>
    <p class="normal">With the <a id="_idIndexMarker632"/>router-first approach, we want to enable routing early on in our application:</p>
    <ol>
      <li class="list" value="1">You can create the new application, with routing already configured, by executing this command.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Ensure that <code class="Code-In-Text--PACKT-">@angular/cli</code> is not installed globally, or you may run into errors:</p>
        <pre class="programlisting"><code class="hljs livecodeserver">$ npx @angular/cli <span class="hljs-built_in">new</span> lemon-mart <span class="hljs-comment">--routing --strict</span>
(Select CSS <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> stylesheet <span class="hljs-built_in">format</span> ) 
</code></pre>
        <div class="packt_tip">
          <p>Starting with Angular 9, you may use <code class="Code-In-Text--PACKT-">--strict</code> to turn on TypeScript features like <code class="Code-In-Text--PACKT-">noImplicitAny</code>, <code class="Code-In-Text--PACKT-">noImplicitReturns</code>, <code class="Code-In-Text--PACKT-">noFallthroughCasesInSwitch</code>, and <code class="Code-In-Text--PACKT-">strictNullChecks</code>. These options will decrease the chances of making coding mistakes, but result in more verbose code. In my opinion, that is a good thing, and this option is highly recommended for production-bound applications.</p>
        </div>
      </li>
      <li class="list">A new <code class="Code-In-Text--PACKT-">AppRoutingModule</code> file has been created for us:
        <pre class="programlisting"><code class="hljs livescript"><strong>src/app/app-routing.modules.ts</strong>
<span class="hljs-keyword">import</span> { NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { Routes, RouterModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>; 
<span class="hljs-keyword">const</span> routes: Routes = [];
@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppRoutingModule</span> { }</span>
</code></pre>
        <p class="normal">We will be <a id="_idIndexMarker633"/>defining routes inside the routes array. Note that the routes array is passed in to be configured as the root routes for the application; the default root route is <code class="Code-In-Text--PACKT-">/</code>.</p>
        <div class="packt_tip">
          <p>When configuring your <code class="Code-In-Text--PACKT-">RouterModule</code>, you can pass in additional options to customize the default behavior of the Router, such as when you attempt to load a route that you're already on. Normally, if the route you're attempting to navigate to is the same as the current one, the router wouldn't take any action. However, if you wanted the router to refresh the page, you would customize the default behavior of the router, such as with <code class="Code-In-Text--PACKT-">RouterModule.forRoot(routes, { onSameUrlNavigation: 'reload' })</code>. With this setting in place, if you navigate to the same URL that you are on, you will force a reload of the current component.</p>
        </div>
      </li>
      <li class="list">Finally, <code class="Code-In-Text--PACKT-">AppRoutingModule</code> is registered with <code class="Code-In-Text--PACKT-">AppModule</code>, as shown:
        <pre class="programlisting"><code class="hljs coffeescript"><strong>src/app/app.<span class="hljs-built_in">module</span>.ts</strong>
...
<span class="hljs-keyword">import</span> { AppRoutingModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app-routing.module'</span>;
@NgModule({ 
  ... 
  imports: [ AppRoutingModule, ... ], 
  ...
})
</code></pre>
      </li>
    </ol>
    <h2 class="title" id="_idParaDest-237">Configuring Angular and VS Code</h2>
    <p class="normal">To quickly <a id="_idIndexMarker634"/>apply configuration steps covered in <em class="italics">Chapters 2-6</em> run <a id="_idIndexMarker635"/>the following commands:</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The following scripts do not require you to use VS Code. If you wish to use another IDE like WebStorm, the <code class="Code-In-Text--PACKT-">npm</code> scripts that are configured will run equally well.</p>
    </div>
    <ol>
      <li class="list" value="1">Install the Angular VS Code task:
        <pre class="programlisting"><code class="hljs ada">npm i -g mrm-<span class="hljs-keyword">task</span>-angular-vscode
</code></pre>
      </li>
      <li class="list">Apply the Angular VS Code configuration:
        <pre class="programlisting"><code class="hljs ebnf"><span class="hljs-attribute">npx mrm angular-vscode</span>
</code></pre>
      </li>
      <li class="list">Install the npm Scripts for the Docker task:
        <pre class="programlisting"><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -g mrm-task-<span class="hljs-built_in">npm</span>-docker
</code></pre>
      </li>
      <li class="list" value="4">Apply the npm Scripts for the Docker configuration:
        <pre class="programlisting"><code class="hljs coffeescript">npx mrm <span class="hljs-built_in">npm</span>-docker
</code></pre>
      </li>
      <li class="list">Implement an npm script to build your application in production mode named <code class="Code-In-Text--PACKT-">build:prod</code>
        <pre class="programlisting"><code class="hljs jboss-cli"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">...</span>,
  <span class="hljs-string">"build:prod"</span>: <span class="hljs-string">"ng build --prod"</span>,
}
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p>These settings are continually tweaked to adapt to the ever-evolving landscape of extensions, plug-ins, Angular, and VS Code. Always make sure to install a fresh version of the task by re-running the <code class="Code-In-Text--PACKT-">install</code> command to get the latest version. Alternatively, you can use the Angular Evergreen extension for VS Code, to run the configuration commands with one click.</p>
    </div>
    <div class="note">
      <p class="Information-Box--PACKT-">Note that if the preceding configuration scripts fail to execute, then the following npm scripts will also fail. In this case, you have two options: revert your changes and ignore these scripts, or manually implement these scripts as covered in earlier chapters (or as demonstrated on GitHub).</p>
    </div>
    <ol>
      <li class="list" value="6">Execute <code class="Code-In-Text--PACKT-">npm run style:fix</code></li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">npm run lint:fix</code></li>
      <li class="list" value="8">Execute <code class="Code-In-Text--PACKT-">npm start</code> and ensure you're running on <code class="Code-In-Text--PACKT-">http://localhost:5000</code>, instead of the default port <code class="Code-In-Text--PACKT-">4200</code></li>
    </ol>
    <p class="normal">Refer to <em class="italics">Chapter 2</em>, <em class="italics">Setting Up Your Development Environment</em>, for further configuration details.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">You may optionally setup npm Scripts for AWS ECS, which is used in <em class="italics">Chapter 13</em>, <em class="italics">Highly Available Cloud Infrastructure on AWS</em>, by using <code class="Code-In-Text--PACKT-">mrm-task-npm-aws</code>.</p>
    </div>
    <p class="normal">For more <a id="_idIndexMarker636"/>information <a id="_idIndexMarker637"/>on the mrm tasks refer to:</p>
    <ul>
      <li class="list"><a href="https://github.com/expertly-simple/mrm-task-angular-vscode"><span class="url">https://github.com/expertly-simple/mrm-task-angular-vscode</span></a></li>
      <li class="list"><a href="https://github.com/expertly-simple/mrm-task-npm-docker"><span class="url">https://github.com/expertly-simple/mrm-task-npm-docker</span></a></li>
      <li class="list"><a href="https://github.com/expertly-simple/mrm-task-npm-aws"><span class="url">https://github.com/expertly-simple/mrm-task-npm-aws</span></a></li>
    </ul>
    <h2 class="title" id="_idParaDest-238">Configuring Material and Styles</h2>
    <p class="normal">We will also <a id="_idIndexMarker638"/>need to set up Angular Material and configure a theme to use, as covered in <em class="italics">Chapter 5</em>, <em class="italics">Delivering High-Quality UX with Material</em>:</p>
    <ol>
      <li class="list" value="1">Install Angular Material:
        <pre class="programlisting"><code class="hljs llvm">$ npx ng <span class="hljs-keyword">add</span> <span class="hljs-title">@angular</span>/material
(<span class="hljs-keyword">select</span> Custom, No <span class="hljs-keyword">to</span> <span class="hljs-keyword">global</span> typography, Yes <span class="hljs-keyword">to</span> browser animations)
$ npm i <span class="hljs-title">@angular</span>/flex-layout 
$ npx ng g m material --flat -m app
</code></pre>
      </li>
      <li class="list">In <code class="Code-In-Text--PACKT-">material.module.ts</code>, define a <code class="Code-In-Text--PACKT-">const</code> <code class="Code-In-Text--PACKT-">modules</code> array and export <code class="Code-In-Text--PACKT-">MatButtonModule</code>, <code class="Code-In-Text--PACKT-">MatToolbarModule</code>, and <code class="Code-In-Text--PACKT-">MatIconModule</code>, removing <code class="Code-In-Text--PACKT-">CommonModule</code></li>
      <li class="list">In <code class="Code-In-Text--PACKT-">app.modules.ts</code>, import <code class="Code-In-Text--PACKT-">FlexLayoutModule</code> so Angular Flex Layout can be activated</li>
      <li class="list">Append common CSS to <code class="Code-In-Text--PACKT-">styles.css</code> as shown in the following code:
        <pre class="programlisting"><code class="hljs stylus"><strong>src/styles<span class="hljs-selector-class">.css</span></strong>
<span class="hljs-selector-tag">html</span>,
<span class="hljs-selector-tag">body</span> { 
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>; 
}
<span class="hljs-selector-tag">body</span> { 
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">font-family</span>: Roboto, <span class="hljs-string">"Helvetica Neue"</span>, sans-serif; 
}
<span class="hljs-selector-class">.margin-top</span> { 
  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">16px</span>;
}
<span class="hljs-selector-class">.horizontal-padding</span> { 
  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">16px</span>;
  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">16px</span>;
}
<span class="hljs-selector-class">.flex-spacer</span> {
  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">1</span> auto;
}
</code></pre>
      </li>
      <li class="list" value="5">Update your application's title in <code class="Code-In-Text--PACKT-">index.html</code></li>
    </ol>
    <p class="normal">Refer to <em class="italics">Chapter 5</em>, <em class="italics">Delivering High-Quality UX with Material</em>, for further configuration details.</p>
    <p class="normal">We will <a id="_idIndexMarker639"/>apply custom branding to the app later in this chapter. Next, let's start designing our line-of-business application.</p>
    <h2 class="title" id="_idParaDest-239">Designing LemonMart</h2>
    <p class="normal">It is important to build a rudimentary roadmap to follow, from the database to the frontend, while also avoiding over-engineering. This initial design phase is critical to the long-term health <a id="_idIndexMarker640"/>and success of your project, where any existing silos between teams must be broken down and an overall technical vision well understood by all members of the team. This is easier said than done, and there are volumes of books written on the topic.</p>
    <p class="normal">In engineering, there's no one right answer to a problem, so it is important to remember that no one person can ever have all the answers, nor a crystal-clear vision. It is important that technical and non-technical leaders create a safe space with opportunities for open discussion and experimentation as part of the culture. The humility and empathy that comes along with being able to court such uncertainty as a team is as important as any single team member's technical capability. Every team member must be comfortable with checking their egos at the door because our collective goal will be to grow and evolve an application to ever-changing requirements during the development cycle. You will know that you have succeeded if individual parts of the software you created are easily replaceable by anyone.</p>
    <p class="normal">So, let's start by developing a roadmap and identifying the scope of our application. For this, we will be defining user roles and then building a site map, to create a vision of how our app might work.</p>
    <h3 class="title" id="_idParaDest-240">Identifying user roles</h3>
    <p class="normal">The first <a id="_idIndexMarker641"/>step of our design will be to think about who is using the application and why.</p>
    <p class="normal">We envision four user states, or roles, for LemonMart:</p>
    <ul>
      <li class="list">Authenticated; any authenticated user would have access to their profile </li>
      <li class="list">Cashier, whose sole role is to check out customers</li>
      <li class="list">Clerk, whose sole role is to perform inventory-related functions</li>
      <li class="list">Manager, who can perform all actions a cashier and a clerk can perform but also have access to administrative functions</li>
    </ul>
    <p class="normal">With this in mind, we can start to create a high-level design for our app.</p>
    <h3 class="title" id="_idParaDest-241">Identifying high-level modules with a site map</h3>
    <p class="normal">Develop <a id="_idIndexMarker642"/>a high-level site map of your application, as shown:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_07.png"/></figure>
    <p class="packt_figref">Figure 7.7: Landing pages for users</p>
    <div class="packt_tip">
      <p>I used MockFlow.com's <a id="_idIndexMarker643"/>SiteMap tool to create the site map shown: <a href="https://sitemap.mockflow.com"><span class="url">https://sitemap.mockflow.com</span></a>.</p>
    </div>
    <p class="normal">Upon first examination, three high-level modules emerge as lazy-loading candidates:</p>
    <ol>
      <li class="list" value="1"><strong class="bold">Point of Sale (POS)</strong></li>
      <li class="list"><strong class="bold">Inventory</strong></li>
      <li class="list" value="3"><strong class="bold">Manager</strong></li>
    </ol>
    <p class="normal">The Cashier will only have access to the <strong class="bold">POS</strong> module and component. The Clerk will only have access to the <strong class="bold">Inventory</strong> module, which will include additional screens for the <strong class="bold">Stock Entry</strong>, <strong class="bold">Products</strong>, and <strong class="bold">Categories</strong> management components:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_08.png"/></figure>
    <p class="packt_figref">Figure 7.8: Inventory pages</p>
    <p class="normal">Finally, the <strong class="bold">Manager</strong> will be able to access all three modules with the <strong class="bold">Manager</strong> module, including <a id="_idIndexMarker644"/>user management and receipt lookup components:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_09.png"/></figure>
    <p class="packt_figref">Figure 7.9: Manager pages</p>
    <p class="normal">There'll be great benefits from enabling lazy loading for all three modules; since Cashiers and Clerks will never use components belonging to other user roles, there's no reason to send those bytes down to their devices. This means as the <strong class="bold">Manager</strong> module gains more advanced reporting features, or new roles are added to the application, the <strong class="bold">POS</strong> module <a id="_idIndexMarker645"/>will be unaffected <a id="_idIndexMarker646"/>by the bandwidth and memory impact of an otherwise growing application.</p>
    <p class="normal">This means fewer support calls, and consistent performance on the same hardware for a much longer period of time.</p>
    <h1 class="title" id="_idParaDest-242">Generating router-enabled modules</h1>
    <p class="normal">Now that we have our high-level components defined as <strong class="bold">Manager</strong>, <strong class="bold">Inventory</strong>, and <strong class="bold">POS</strong>, we can <a id="_idIndexMarker647"/>define them as modules. These modules will be different from the ones you've created so far, for routing and Angular Material. We can create the user profile as a component on the app module; however, note that user profile will only ever be used for already-authenticated users, so it makes sense to define a fourth module only meant for authenticated users in general. This way, you will ensure that your app's first payload remains as minimal as possible. In addition, we will create a Home component to contain the landing experience for our app so that we can keep implementation details out of <code class="Code-In-Text--PACKT-">app.component</code>:</p>
    <ol>
      <li class="list" value="1">Generate <code class="Code-In-Text--PACKT-">manager</code>, <code class="Code-In-Text--PACKT-">inventory</code>, <code class="Code-In-Text--PACKT-">pos</code>, and <code class="Code-In-Text--PACKT-">user</code> modules, specifying their target module and routing capabilities:
        <pre class="programlisting"><code class="hljs routeros">$ npx ng g m manager -m app --routing
$ npx ng g m inventory -m app --routing
$ npx ng g m pos -m app --routing
$ npx ng g m<span class="hljs-built_in"> user </span>-m app --routing
</code></pre>
        <div class="packt_tip">
          <p>As discussed in <em class="italics">Chapter 2</em>, <em class="italics">Setting Up Your Development Environment</em>, if you have configured <code class="Code-In-Text--PACKT-">npx</code> to automatically recognize <code class="Code-In-Text--PACKT-">ng</code> as a command, you can save some more keystrokes because you won't have to append <code class="Code-In-Text--PACKT-">npx</code> to your commands every time. Do not globally install <code class="Code-In-Text--PACKT-">@angular/cli</code>.</p>
          <p class="Tip-Within-Bullet--PACKT-">Note the abbreviated command structure, where <code class="Code-In-Text--PACKT-">ng generate module manager</code> becomes <code class="Code-In-Text--PACKT-">ng g m manager</code>, and similarly, <code class="Code-In-Text--PACKT-">--module</code> becomes <code class="Code-In-Text--PACKT-">-m</code>.</p>
        </div>
      </li>
      <li class="list">Verify that you don't have CLI errors.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note that using <code class="Code-In-Text--PACKT-">npx</code> on Windows may throw an error such as <code class="Code-In-Text--PACKT-">Path must be a string. Received undefined</code>. This error doesn't seem to have any effect on the successful operation of the command, which is why it is critical to always inspect what the CLI tool generated.</p>
      </li>
      <li class="list">Verify that the folder and the files are created:
        <pre class="programlisting"><code class="hljs stylus"><strong>/src/app</strong>
│   app-routing<span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span>
│   app<span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.css</span>
│   app<span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.html</span>
│   app<span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.spec</span><span class="hljs-selector-class">.ts</span>
│   app<span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.ts</span>
│   app<span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span>
│   material<span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span>
├───inventory
│      inventory-routing<span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span>
│      inventory<span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span>
├───manager
│      manager-routing<span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span>
│      manager<span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span>
├───pos
│      pos-routing<span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span>
│      pos<span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span>
└───user
│      user-routing<span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span>
│      user<span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span>
</code></pre>
      </li>
      <li class="list" value="4">Examine how <code class="Code-In-Text--PACKT-">ManagerModule</code> has been wired.</li>
    </ol>
    <p class="normal">A feature <a id="_idIndexMarker648"/>module implements an <code class="Code-In-Text--PACKT-">@NgModule</code> similar to <code class="Code-In-Text--PACKT-">app.module</code>. The biggest difference is that a feature module does not implement the <code class="Code-In-Text--PACKT-">bootstrap</code> property, which is required for your root module to initialize your Angular app:</p>
    <pre class="programlisting"><code class="hljs coffeescript"><strong>src/app/manager/manager.<span class="hljs-built_in">module</span>.ts</strong>
<span class="hljs-keyword">import</span> { NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { CommonModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common'</span>
<span class="hljs-keyword">import</span> { ManagerRoutingModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./manager-routing.module'</span>
@NgModule({
  imports: [CommonModule, ManagerRoutingModule],
  declarations: [],
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManagerModule</span> {}</span>
</code></pre>
    <p class="normal">Since we have specified the <code class="Code-In-Text--PACKT-">-m</code> option, the module has been imported into <code class="Code-In-Text--PACKT-">app.module</code>:</p>
    <pre class="programlisting"><code class="hljs lasso"><strong>src/app/app.module.ts</strong>
<span class="hljs-params">...</span>
<span class="hljs-keyword">import</span> { ManagerModule } from <span class="hljs-string">'./manager/manager.module'</span>
<span class="hljs-params">...</span>
@NgModule({ 
  <span class="hljs-params">...</span> 
  imports: <span class="hljs-meta">[</span><span class="hljs-params">...</span>, ManagerModule<span class="hljs-meta">]</span>, 
  ...
}) 
</code></pre>
    <p class="normal">In addition, because we also specified the <code class="Code-In-Text--PACKT-">--routing</code> option, a routing module has been <a id="_idIndexMarker649"/>created and imported into <code class="Code-In-Text--PACKT-">ManagerModule</code>:</p>
    <pre class="programlisting"><code class="hljs livescript"><strong>src/app/manager/manager-routing.<span class="hljs-built_in">module</span>.ts</strong>
<span class="hljs-keyword">import</span> { NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { Routes, RouterModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>
<span class="hljs-keyword">const</span> routes: Routes = []
@NgModule({
  imports: [RouterModule.forChild(routes)], 
  exports: [RouterModule],
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManagerRoutingModule</span> {}</span>
</code></pre>
    <p class="normal">Note that <code class="Code-In-Text--PACKT-">RouterModule</code> is being configured using <code class="Code-In-Text--PACKT-">forChild</code>, as opposed to <code class="Code-In-Text--PACKT-">forRoot</code>, which was the case for the <code class="Code-In-Text--PACKT-">AppRouting</code> module. This way, the router understands the proper relationship between routes defined in different modules' contexts and can correctly prepend <code class="Code-In-Text--PACKT-">/manager</code> to all child routes in this example.</p>
    <div class="packt_tip">
      <p>The CLI doesn't respect your <code class="Code-In-Text--PACKT-">tslint.json</code> settings. If you have correctly configured your VS Code environment with Prettier, your code styling preferences will be applied as you work on each file or globally when you run the <code class="Code-In-Text--PACKT-">prettier</code> command.</p>
    </div>
    <p class="normal">Be sure to run your <code class="Code-In-Text--PACKT-">style:fix</code> and <code class="Code-In-Text--PACKT-">lint:fix</code> commands before moving on. Now, let's design how the landing page for LemonMart will look and work.</p>
    <h2 class="title" id="_idParaDest-243">Designing the home route</h2>
    <p class="normal">Consider <a id="_idIndexMarker650"/>the following mock-up as the <a id="_idIndexMarker651"/>landing experience for LemonMart:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_10.png"/></figure>
    <p class="packt_figref">Figure 7.10: LemonMart landing experience</p>
    <p class="normal">Unlike the <code class="Code-In-Text--PACKT-">LocalCastWeather</code> app, we don't want all this markup to be in the <code class="Code-In-Text--PACKT-">App</code> component. The <code class="Code-In-Text--PACKT-">App</code> component is the root element of your entire application; therefore, it should only contain elements that will persistently appear throughout your application. In the following annotated mock-up, the toolbar marked as <strong class="bold">1</strong> will be persistent throughout the app.</p>
    <p class="normal">The area marked as <strong class="bold">2</strong> will house the <code class="Code-In-Text--PACKT-">home</code> component, which itself will contain a login user control, marked as <strong class="bold">3</strong>:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_11.png"/></figure>
    <p class="packt_figref">Figure 7.11: LemonMart layout structure</p>
    <p class="normal">It's best <a id="_idIndexMarker652"/>practice to create your default or landing component as a separate element in Angular. This helps reduce the amount of code that must be loaded and logic executed in every page, but it also results in a more flexible architecture when utilizing the router.</p>
    <p class="normal">Generate the <code class="Code-In-Text--PACKT-">home</code> component with inline template and styles:</p>
    <pre class="programlisting"><code class="hljs arduino">$ npx ng g c <span class="hljs-built_in">home</span> -m app --<span class="hljs-keyword">inline</span>-<span class="hljs-keyword">template</span> --<span class="hljs-keyword">inline</span>-style
</code></pre>
    <div class="packt_tip">
      <p>Note that <a id="_idIndexMarker653"/>a component with an inline template and a style is also referred to as a <strong class="bold">Single File Component</strong> or an <strong class="bold">SFC</strong>.</p>
    </div>
    <p class="normal">Now, you are ready to configure the router.</p>
    <h3 class="title" id="_idParaDest-244">Setting up default routes</h3>
    <p class="normal">Let's get <a id="_idIndexMarker654"/>started with setting up a simple route for LemonMart. We need to set up the <code class="Code-In-Text--PACKT-">/</code> route (also known as the empty route) and the <code class="Code-In-Text--PACKT-">/home</code> routes to display the <code class="Code-In-Text--PACKT-">HomeComponent</code>. We also need a wildcard route to capture all undefined routes and display a <code class="Code-In-Text--PACKT-">PageNotFoundComponent</code>, which also needs to be created:</p>
    <ol>
      <li class="list" value="1">Configure your <code class="Code-In-Text--PACKT-">home</code> route:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>app-routing.module.ts</strong>
...
<strong><span class="hljs-keyword">import</span> { HomeComponent } from <span class="hljs-string">'./home/home.component'</span></strong>
const <span class="hljs-string">routes:</span> Routes = [
<strong>  { <span class="hljs-string">path:</span> <span class="hljs-string">''</span>, <span class="hljs-string">redirectTo:</span> <span class="hljs-string">'/home'</span>, <span class="hljs-string">pathMatch:</span> <span class="hljs-string">'full'</span> },</strong>
<strong>  { <span class="hljs-string">path:</span> <span class="hljs-string">'home'</span>, <span class="hljs-string">component:</span> HomeComponent },</strong>
]
...
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">We first define a path for <code class="Code-In-Text--PACKT-">'home'</code> and inform the router to render <code class="Code-In-Text--PACKT-">HomeComponent</code> by setting the <code class="Code-In-Text--PACKT-">component</code> property. Then, we set the default path of the application <code class="Code-In-Text--PACKT-">''</code> to be redirected to <code class="Code-In-Text--PACKT-">'/home'</code>. By setting the <code class="Code-In-Text--PACKT-">pathMatch</code> property, we always ensure that this very specific instance of the <code class="Code-In-Text--PACKT-">home</code> route will be rendered as the landing experience.</p>
      </li>
      <li class="list">Create a <code class="Code-In-Text--PACKT-">pageNotFound</code> component with an inline template</li>
      <li class="list">Configure <a id="_idIndexMarker655"/>a wildcard route for <code class="Code-In-Text--PACKT-">PageNotFoundComponent</code>:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>app-routing.module.ts</strong>
<strong><span class="hljs-keyword">import</span> { </strong>
<strong>  PageNotFoundComponent </strong>
<strong>} from <span class="hljs-string">'./page-not-found/page-not-found.component'</span> </strong>
...
const <span class="hljs-string">routes:</span> Routes = [
  ...
    <strong>{ <span class="hljs-string">path:</span> <span class="hljs-string">'**'</span>, <span class="hljs-string">component:</span> PageNotFoundComponent },</strong>
  ]
...
</code></pre>
      </li>
    </ol>
    <p class="normal">This way, any route that is not matched will be directed to the <code class="Code-In-Text--PACKT-">PageNotFoundComponent</code>.</p>
    <h3 class="title" id="_idParaDest-245">RouterLink</h3>
    <p class="normal">When a <a id="_idIndexMarker656"/>user lands on the <code class="Code-In-Text--PACKT-">PageNotFoundComponent</code>, we would like them to be redirected to the <code class="Code-In-Text--PACKT-">HomeComponent</code> using the <code class="Code-In-Text--PACKT-">routerLink</code> direction:</p>
    <ol>
      <li class="list" value="1">On <code class="Code-In-Text--PACKT-">PageNotFoundComponent</code>, replace the inline template to link back to <code class="Code-In-Text--PACKT-">home</code> using <code class="Code-In-Text--PACKT-">routerLink</code>:
        <pre class="programlisting"><code class="hljs routeros"><strong>src/app/page-not-found/page-not-found.component.ts</strong>
<span class="hljs-built_in">..</span>.
  template: `
<strong>    &lt;p&gt;</strong>
<strong>      This<span class="hljs-built_in"> page </span>doesn<span class="hljs-string">'t exist. Go back to</span></strong><span class="hljs-string">
</span><strong><span class="hljs-string">      &lt;a routerLink="/home"&gt;home&lt;/a&gt;.</span></strong><span class="hljs-string">
</span><strong><span class="hljs-string">    &lt;/p&gt;</span></strong><span class="hljs-string">
  `,
...
</span></code></pre>
      </li>
    </ol>
    <div class="note">
      <p class="Information-Box--PACKT-">This navigation can also be done via an <code class="Code-In-Text--PACKT-">&lt;a href&gt;</code> tag implementation; however, in more dynamic and complicated navigation scenarios, you will lose features such as automatic active link tracking or dynamic link generation.</p>
    </div>
    <p class="normal">The Angular <a id="_idIndexMarker657"/>bootstrap process will ensure that <code class="Code-In-Text--PACKT-">AppComponent</code> is inside the <code class="Code-In-Text--PACKT-">&lt;app-root&gt;</code> element in your <code class="Code-In-Text--PACKT-">index.html</code>. However, we must manually define where we would like <code class="Code-In-Text--PACKT-">HomeComponent</code> to render, to finalize the router configuration.</p>
    <h3 class="title" id="_idParaDest-246">Router outlet</h3>
    <p class="normal"><code class="Code-In-Text--PACKT-">AppComponent</code> is considered a <a id="_idIndexMarker658"/>root element for the root router defined in <code class="Code-In-Text--PACKT-">app-routing.module</code>, which allows us to define outlets within this root element to dynamically load any content we wish using the <code class="Code-In-Text--PACKT-">&lt;router-outlet&gt;</code> element:</p>
    <ol>
      <li class="list" value="1">Configure <code class="Code-In-Text--PACKT-">AppComponent</code> to use inline template and styles, deleting any existing content in the html and css files</li>
      <li class="list">Add the toolbar for your application</li>
      <li class="list">Add the name of your application as a button link so that it takes the user to the home page when clicked on</li>
      <li class="list">Add <code class="Code-In-Text--PACKT-">&lt;router-outlet&gt;</code> for the content to render:
        <pre class="programlisting"><code class="hljs xml"><strong>src/app/app.component.ts</strong>
...
template: `
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-toolbar</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-button</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/home"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>LemonMart<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">mat-toolbar</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span>
`,
</code></pre>
      </li>
    </ol>
    <p class="normal">Now, the contents of <code class="Code-In-Text--PACKT-">home</code> will render inside <code class="Code-In-Text--PACKT-">&lt;router-outlet&gt;</code>.</p>
    <h1 class="title" id="_idParaDest-247">Branding, customization, and Material icons</h1>
    <p class="normal">In order to <a id="_idIndexMarker659"/>construct an attractive and intuitive toolbar, we must introduce <a id="_idIndexMarker660"/>some iconography and branding to the app so that the users can easily navigate through the app with the help of familiar icons.</p>
    <h2 class="title" id="_idParaDest-248">Branding</h2>
    <p class="normal">In terms <a id="_idIndexMarker661"/>of branding, you should ensure that your web app has a custom color palette and integrates with desktop and mobile browser features to bring forward your app's name and iconography.</p>
    <h2 class="title" id="_idParaDest-249">Color palette</h2>
    <p class="normal">Pick a color palette <a id="_idIndexMarker662"/>using the Material Color tool, as discussed in <em class="italics">Chapter 5</em>, <em class="italics">Delivering High-Quality UX with Material</em>. Here's the one I picked for LemonMart:</p>
    <p class="normal"><a href="https://material.io/resources/color/#!/?view.left=0&amp;view.right=0&amp;primary.color=2E7D32&amp;secondary.color=C6FF00"><span class="url">https://material.io/resources/color/#!/?view.left=0&amp;view.right=0&amp;primary.color=2E7D32&amp;secondary.color=C6FF00</span></a>.</p>
    <ol>
      <li class="list" value="1">Rename <code class="Code-In-Text--PACKT-">custom-theme.scss</code> to <code class="Code-In-Text--PACKT-">lemonmart-theme.scss</code></li>
      <li class="list">Update <code class="Code-In-Text--PACKT-">angular.json</code> with the new theme file name
        <pre class="programlisting"><code class="hljs jboss-cli"><strong>angular.json</strong>
<span class="hljs-string">"apps"</span>: [ {
  <span class="hljs-string">...</span> 
  <span class="hljs-string">"styles"</span>: [ 
    <span class="hljs-string">"src/lemonmart-theme.scss"</span>, 
    <span class="hljs-string">"src/styles.css"</span> 
  ],
  <span class="hljs-string">...</span>
}] 
</code></pre>
      </li>
      <li class="list" value="3">Configure your custom theme with the chosen color palette</li>
    </ol>
    <div class="packt_tip">
      <p>You can also <a id="_idIndexMarker663"/>grab LemonMart-related assets from GitHub at <a href="https://github.com/duluca/lemon-mart"><span class="url">https://github.com/duluca/lemon-mart</span></a>.</p>
    </div>
    <p class="normal">For the Local Weather app, we replaced the <code class="Code-In-Text--PACKT-">favicon.ico</code> file to brand our app in the browser. While this would've been enough ten years ago, today's devices vary wildly, and each platform can leverage optimized assets to better represent your web app within their operating systems. Next, let's implement a more robust favicon.</p>
    <h2 class="title" id="_idParaDest-250">Implementing browser manifest and icons</h2>
    <p class="normal">You need to ensure that the browser shows the correct title text and icon in a <strong class="bold">Browser</strong> tab. Further, a manifest file should be created that implements specific icons for various mobile <a id="_idIndexMarker664"/>operating systems, so that if a user pins your website, a desirable icon is displayed similar to other app icons on a phone. This will ensure that if a user favorites or pins your web app on their mobile device's home screen, they'll get a native-looking app icon:</p>
    <ol>
      <li class="list" value="1">Create or obtain an SVG version of your website's logo from a designer or a site like <a href="https://www.flaticon.com "><span class="url">https://www.flaticon.com</span></a></li>
      <li class="list">In this case, I will be using the likeness of the Eureka Lemon:<figure class="mediaobject"><img alt="" src="../Images/B14094_07_12.png"/></figure>
        <p class="packt_figref">Figure 7.12: LemonMart's signature logo</p>
        <div class="packt_tip">
          <p class="Tip-Within-Bullet--PACKT-">When using images you find on the internet, pay attention to applicable copyrights. In this case, I have purchased a license to be able to publish this lemon logo, but you may grab your own copy at the following URL, given that you provide the required attribution to the author of the image: <a href="https://www.flaticon.com/free-icon/lemon_605070"><span class="url">https://www.flaticon.com/free-icon/lemon_605070</span></a>.</p>
        </div>
      </li>
      <li class="list">Generate the <code class="Code-In-Text--PACKT-">favicon.ico</code> and manifest files using a tool such as <a href="https://realfavicongenerator.net "><span class="url">https://realfavicongenerator.net</span></a></li>
      <li class="list">Adjust settings for iOS, Android, Windows Metro, and macOS Safari to your liking</li>
      <li class="list">Ensure that you set a version number, as favicons can be notorious with caching; a random version number will ensure that users always get the latest version</li>
      <li class="list">Download and extract the generated <code class="Code-In-Text--PACKT-">favicons.zip</code> file into your <code class="Code-In-Text--PACKT-">src</code> folder</li>
      <li class="list">Edit the <code class="Code-In-Text--PACKT-">angular.json</code> file to include the new assets in your app:
        <pre class="programlisting"><code class="hljs jboss-cli"><strong>angular.json</strong>
<span class="hljs-string">"apps"</span>: [
  {
  <span class="hljs-string">...</span>
    <span class="hljs-string">"assets"</span>: [
      <span class="hljs-string">"src/assets"</span>,
      <span class="hljs-string">"src/favicon.ico"</span>,
      <span class="hljs-string">"src/android-chrome-192x192.png"</span>,
      <span class="hljs-string">"src/favicon-16x16.png"</span>,
      <span class="hljs-string">"src/mstile-310x150.png"</span>,
      <span class="hljs-string">"src/android-chrome-512x512.png"</span>,
      <span class="hljs-string">"src/favicon-32x32.png"</span>,
      <span class="hljs-string">"src/mstile-310x310.png"</span>,
      <span class="hljs-string">"src/apple-touch-icon.png"</span>,
      <span class="hljs-string">"src/manifest.json"</span>,
      <span class="hljs-string">"src/mstile-70x70.png"</span>,
      <span class="hljs-string">"src/browserconfig.xml"</span>,
      <span class="hljs-string">"src/mstile-144x144.png"</span>,
      <span class="hljs-string">"src/safari-pinned-tab.svg"</span>,
      <span class="hljs-string">"src/mstile-150x150.png"</span>
    ]
</code></pre>
      </li>
      <li class="list">Insert the <a id="_idIndexMarker665"/>generated code in the <code class="Code-In-Text--PACKT-">&lt;head&gt;</code> section of your <code class="Code-In-Text--PACKT-">index.html</code>:
        <pre class="programlisting"><code class="hljs routeros"><strong>src/index.html</strong>
&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"apple-touch-icon"</span> <span class="hljs-attribute">sizes</span>=<span class="hljs-string">"180x180"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"/apple-touch- icon.png?v=rMlKOnvxlK"</span>&gt;
&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">"image/png"</span> <span class="hljs-attribute">sizes</span>=<span class="hljs-string">"32x32"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"/favicon-32x32.png?v=rMlKOnvxlK"</span>&gt;
&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">"image/png"</span> <span class="hljs-attribute">sizes</span>=<span class="hljs-string">"16x16"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"/favicon-16x16.png?v=rMlKOnvxlK"</span>&gt;
&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"manifest"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"/manifest.json?v=rMlKOnvxlK"</span>&gt;
&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"mask-icon"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"/safari-pinned-tab.svg?v=rMlKOnvxlK"</span> <span class="hljs-attribute">color</span>=<span class="hljs-string">"#b3ad2d"</span>&gt;
&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">"shortcut icon"</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">"/favicon.ico?v=rMlKOnvxlK"</span>&gt;
&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">"theme-color"</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">"#ffffff"</span>&gt;
</code></pre>
      
      <div class="packt_tip">
        <p>Please put the preceding HTML after your favicon declaration, but before your style imports. The order does matter. Browsers load data top down. You want your application's icon to be parsed before the user has to wait for CSS files to be downloaded.</p>
      </div></li>
      <li class="list" value="9">Ensure that your new favicon displays correctly</li>
    </ol>
    <p class="normal">Once your basic branding work has been completed, consider if you'd like to establish a more unique look and feel with theming.</p>
    <h2 class="title" id="_idParaDest-251">Custom themes</h2>
    <p class="normal">You may <a id="_idIndexMarker666"/>further customize Material's look and feel, to achieve a unique experience for your app, by leveraging tools listed on <a href="https://material.io/tools"><span class="url">https://material.io/tools</span></a> and some other tools that I have discovered, which are listed as follows:</p>
    <ul>
      <li class="list">Material Theme Editor (retired as of March 2020) is a plugin for the popular design app Sketch on macOS to create a theme that is more than skin deep. An alternative tool is yet to be announced, but you can find resources you can continue to use in the meantime on the blog post linked at <a href="https://material.io/tools/theme-editor"><span class="url">https://material.io/tools/theme-editor</span></a></li>
      <li class="list">Material Theme <a id="_idIndexMarker667"/>Builder is an alternative to build custom themes that work in the browser on Glitch.com at <a href="https://material-theme-builder.glitch.me "><span class="url">https://material-theme-builder.glitch.me</span></a></li>
      <li class="list">Material <a id="_idIndexMarker668"/>Design Theme Palette Generator will generate the necessary code to define your custom color palette to create truly unique themes at <a href="http://mcg.mbitson.com "><span class="url">http://mcg.mbitson.com</span></a></li>
      <li class="list">Color Blender <a id="_idIndexMarker669"/>helps with finding midway points between two colors, which is useful when defining in-between colors for the color swatches, located at <a href="https://meyerweb.com/eric/tools/color-blend "><span class="url">https://meyerweb.com/eric/tools/color-blend</span></a></li>
    </ul>
    <p class="normal">There is a wealth of information on <a href="https://material.io"><span class="url">https://material.io</span></a> on the in-depth philosophy behind Material design, with great sections on things like the color system, <a href="https://material.io/design/color/the-color-system.html"><span class="url">https://material.io/design/color/the-color-system.html</span></a>, which dives deep into selecting the right color palette for your brand and other topics such as creating a dark theme for your app.</p>
    <p class="normal">It is very important to distinguish your brand from other apps or your competitors. Creating a high-quality custom theme will be a time-consuming process; however, the benefits of creating a great first impression with your users are considerable.</p>
    <p class="normal">Next, we will show you how you can add custom icons to your Angular apps.</p>
    <h2 class="title" id="_idParaDest-252">Custom icons</h2>
    <p class="normal">Now, let's add <a id="_idIndexMarker670"/>your custom branding inside your Angular app. You will need the svg icon you used to create your favicon:</p>
    <ol>
      <li class="list" value="1">Place the image under <code class="Code-In-Text--PACKT-">src/assets/img/icons</code>, named <code class="Code-In-Text--PACKT-">lemon.svg</code></li>
      <li class="list">In <code class="Code-In-Text--PACKT-">app.module.ts</code>, import <code class="Code-In-Text--PACKT-">HttpClientModule</code> to <code class="Code-In-Text--PACKT-">AppComponent</code> so that the <code class="Code-In-Text--PACKT-">.svg</code> file can be requested over HTTP</li>
      <li class="list">Update <code class="Code-In-Text--PACKT-">AppComponent</code> to register the new svg file as an icon:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/app.component.ts</strong>
<strong><span class="hljs-keyword">import</span> { MatIconRegistry } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/icon'</span></strong>
<strong><span class="hljs-keyword">import</span> { DomSanitizer } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span></strong>
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent {
<strong>  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"> </span></strong><span class="hljs-params">
</span><strong><span class="hljs-params">    iconRegistry: MatIconRegistry, </span></strong><span class="hljs-params">
</span><strong><span class="hljs-params">    sanitizer: DomSanitizer</span></strong><span class="hljs-params">
</span><strong><span class="hljs-params">  </span>) { </strong>
<strong>    iconRegistry.addSvgIcon(</strong>
<strong>      <span class="hljs-string">'lemon'</span>,</strong>
<strong>      sanitizer.bypassSecurityTrustResourceUrl(</strong>
<strong>        <span class="hljs-string">'assets/img/icons/ lemon.svg'</span></strong>
<strong>      ) </strong>
<strong>    )</strong>
  } 
}
</code></pre>
      </li>
      <li class="list">Add the <a id="_idIndexMarker671"/>icon to the toolbar:
        <pre class="programlisting"><code class="hljs xml"><strong>src/app/app.component.ts</strong>
template: ` 
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-toolbar</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>&gt;</span> 
<strong>    <span class="hljs-tag">&lt;<span class="hljs-name">mat-icon</span> <span class="hljs-attr">svgIcon</span>=<span class="hljs-string">"lemon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-icon</span>&gt;</span> </strong>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-button</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/home"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>LemonMart<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> 
  <span class="hljs-tag">&lt;/<span class="hljs-name">mat-toolbar</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span> 
`, 
</code></pre>
      </li>
    </ol>
    <p class="normal">Now let's add the remaining icons for menu, user profile, and logout.</p>
    <h2 class="title" id="_idParaDest-253">Material icons</h2>
    <p class="normal">Angular Material works out of the box with the Material Design icon font, which is automatically imported into <a id="_idIndexMarker672"/>your app as a web font in your <code class="Code-In-Text--PACKT-">index.html</code>. It is possible to self-host the font; however, if you go down that path, you don't get the benefit if the user's browser has already cached the font from when they visited another website, which could save the speed and latency of downloading a 42-56 KB file in the process. The complete <a id="_idIndexMarker673"/>list of icons can be found at <a href="https://material.io/icons/"><span class="url">https://material.io/icons/</span></a>.</p>
    <p class="normal">Now let's update the toolbar with some icons and set up the home page with a minimal template for a fake login button:</p>
    <ol>
      <li class="list" value="1">Ensure that the Material icons <code class="Code-In-Text--PACKT-">&lt;link&gt;</code> tag has been added to <code class="Code-In-Text--PACKT-">index.html</code>:
        <pre class="programlisting"><code class="hljs xml"><strong>src/index.html</strong>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  ...
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://fonts.googleapis.com/icon?family=Material+Icons"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
</code></pre>
        <div class="packt_tip">
          <p>Instructions on <a id="_idIndexMarker674"/>how to self-host can be found under the <strong class="bold">Self Hosting</strong> section at <a href="http://google.github.io/material-design-icons/#getting-icons"><span class="url">http://google.github.io/material-design-icons/#getting-icons</span></a>.</p>
        </div>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Once configured, working with Material icons is easy.</p>
      </li>
      <li class="list">On <code class="Code-In-Text--PACKT-">AppComponent</code>, update the <a id="_idIndexMarker675"/>toolbar to place a <strong class="screen-text">Menu</strong> button to the left of the title.</li>
      <li class="list">Add the <code class="Code-In-Text--PACKT-">fxFlex</code> directive so that the remaining icons are right aligned.</li>
      <li class="list">Add user profile and logout icons:
        <pre class="programlisting"><code class="hljs xml"><strong>src/app/app.component.ts</strong>
template: `
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-toolbar</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>&gt;</span>
    <span class="hljs-tag">&lt;</span><strong><span class="hljs-tag"><span class="hljs-name">button</span> <span class="hljs-attr">mat-icon-button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mat-icon</span>&gt;</span>menu<span class="hljs-tag">&lt;/<span class="hljs-name">mat-icon</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></strong>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-icon</span> <span class="hljs-attr">svgIcon</span>=<span class="hljs-string">"lemon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-icon</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-button</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/home"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>LemonMart<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <strong><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"flex-spacer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></strong>
<strong>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">mat-icon-button</span>&gt;</span></strong>
<strong>      <span class="hljs-tag">&lt;<span class="hljs-name">mat-icon</span>&gt;</span>account_circle<span class="hljs-tag">&lt;/<span class="hljs-name">mat-icon</span>&gt;</span></strong>
<strong>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></strong>
<strong>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">mat-icon-button</span>&gt;</span></strong>
<strong>      <span class="hljs-tag">&lt;<span class="hljs-name">mat-icon</span>&gt;</span>lock_open<span class="hljs-tag">&lt;/<span class="hljs-name">mat-icon</span>&gt;</span></strong>
<strong>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></strong>
  <span class="hljs-tag">&lt;/<span class="hljs-name">mat-toolbar</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span>
`,
</code></pre>
      </li>
      <li class="list">On <code class="Code-In-Text--PACKT-">HomeComponent</code>, add a minimal template for a login experience, replacing any existing content:
        <pre class="programlisting"><code class="hljs stylus"><strong>src/app/home/home<span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.ts</span></strong>
  styles: [`
    <span class="hljs-selector-tag">div</span>[fxLayout] {<span class="hljs-attribute">margin-top</span>: <span class="hljs-number">32px</span>;}
  `],
  template: `
    &lt;<span class="hljs-selector-tag">div</span> fxLayout=<span class="hljs-string">"column"</span> fxLayoutAlign=<span class="hljs-string">"center center"</span>&gt;
      &lt;<span class="hljs-selector-tag">span</span> class=<span class="hljs-string">"mat-display-2"</span>&gt;Hello, Limoncu!&lt;/span&gt;
      &lt;<span class="hljs-selector-tag">button</span> mat-raised-<span class="hljs-selector-tag">button</span> <span class="hljs-attribute">color</span>=<span class="hljs-string">"primary"</span>&gt;Login&lt;/button&gt;
    &lt;/div&gt;
  `
</code></pre>
      </li>
    </ol>
    <p class="normal">Your app <a id="_idIndexMarker676"/>should look similar to this screenshot:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_13.png"/></figure>
    <p class="packt_figref">Figure 7.13: LemonMart with minimal login</p>
    <p class="normal">There's still some work to be done, in terms of implementing and showing/hiding the menu, profile, and logout icons, given the user's authentication status. We will cover this functionality in <em class="italics">Chapter 8</em>, <em class="italics">Designing Authentication and Authorization</em>.</p>
    <div class="packt_tip">
      <p>In order to debug the router, get a visualization of your routers, and tightly integrate Chrome debugging features using Angular Augury, see <em class="italics">Appendix A,</em> <em class="italics">Debugging Angular</em>.</p>
    </div>
    <p class="normal">Now that you've set up basic routing for your app, we can move on to setting up lazily loaded modules with subcomponents. If you're not familiar with troubleshooting and debugging Angular, please refer to the <em class="italics">Appendix A</em><em class="italics">, Debugging Angular</em>, before moving forward.</p>
    <h1 class="title" id="_idParaDest-254">Feature modules with lazy loading</h1>
    <p class="normal">There are two ways resources are loaded: eagerly or lazily. When the browser loads up the <code class="Code-In-Text--PACKT-">index.html</code> for your app, it starts processing it top to bottom. First the <code class="Code-In-Text--PACKT-">&lt;head&gt;</code> element is processed, then the <code class="Code-In-Text--PACKT-">&lt;body&gt;</code>. For example, the CSS resources we defined in the <code class="Code-In-Text--PACKT-">&lt;head&gt;</code> of our app will be downloaded before our app is rendered, because our Angular app is defined as a <code class="Code-In-Text--PACKT-">&lt;script&gt;</code> in the <code class="Code-In-Text--PACKT-">&lt;body&gt;</code> of the HTML file.</p>
    <p class="normal">When you <a id="_idIndexMarker677"/>use the command <code class="Code-In-Text--PACKT-">ng build</code>, Angular leverages the webpack module bundler to combine all the JavaScript, HTML, and CSS into minified <a id="_idIndexMarker678"/>and optimized JavaScript bundles. </p>
    <p class="normal">If you don't leverage lazy loading in Angular, the entire contents of your app will be eagerly loaded. The user won't see the first screen of your app until all screens are downloaded and loaded.</p>
    <p class="normal">Lazy loading allows the Angular build process, working in tandem with webpack, to separate your web application into different JavaScript files called chunks. We can enable this chunking by separating out portions of the application into feature modules. Feature modules and their dependencies can be bundled into separate chunks. Remember that the root module and its dependencies will always be in the first chunk that is downloaded. So, by chunking our application's JavaScript bundle size, we keep the size of the initial chunk at a minimum. With a minimal first chunk, no matter how big your application grows, the time to first meaningful paint remains constant. Otherwise, your app would take longer and longer to download and render as you add more features and functionality to it. Lazy loading is critical to achieving a scalable application architecture.</p>
    <p class="normal">Consider the following graphic to determine which routes are eagerly loaded and which ones are lazily loaded:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_14.png"/></figure>
    <p class="packt_figref">Figure 7.14: Angular router eager vs lazy loading</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">rootRouter</code> defines three routes: <code class="Code-In-Text--PACKT-">a</code>, <code class="Code-In-Text--PACKT-">b</code>, and <code class="Code-In-Text--PACKT-">c</code>. <code class="Code-In-Text--PACKT-">/master</code> and <code class="Code-In-Text--PACKT-">/detail</code> represent named router outlets, which are covered in <em class="italics">Chapter 12</em>, <em class="italics">Recipes – Master/Detail, Data Tables, and NgRx</em>. Route <code class="Code-In-Text--PACKT-">a</code> is the <a id="_idIndexMarker679"/>default route for the app. Routes <code class="Code-In-Text--PACKT-">a</code> and <code class="Code-In-Text--PACKT-">c</code> are connected to the <code class="Code-In-Text--PACKT-">rootRouter</code> with a solid line, whereas route <code class="Code-In-Text--PACKT-">b</code> is connected using a dashed line. In this context, route <code class="Code-In-Text--PACKT-">b</code> is configured as a lazy-loaded route. This means <a id="_idIndexMarker680"/>that route <code class="Code-In-Text--PACKT-">b</code> will dynamically load a feature module, called <strong class="bold">BModule</strong>, that contains its <code class="Code-In-Text--PACKT-">childRouter</code>. This <code class="Code-In-Text--PACKT-">childRouter</code> can define any number of components, even reusing route names that were reused elsewhere. In this case, <code class="Code-In-Text--PACKT-">b</code> defines three additional routes: <code class="Code-In-Text--PACKT-">d</code>, <code class="Code-In-Text--PACKT-">e</code>, and <code class="Code-In-Text--PACKT-">f</code>. </p>
    <p class="normal">Consider the <a id="_idIndexMarker681"/>example router definition for the <code class="Code-In-Text--PACKT-">rootRouter</code>:</p>
    <pre class="programlisting"><code class="hljs groovy"><strong>rootRouter example</strong>
const <span class="hljs-string">routes:</span> Routes = [
  { <span class="hljs-string">path:</span> <span class="hljs-string">''</span>, <span class="hljs-string">redirectTo:</span> <span class="hljs-string">'/a'</span>, <span class="hljs-string">pathMatch:</span> <span class="hljs-string">'full'</span> },
  {
<span class="hljs-symbol">    path:</span> <span class="hljs-string">'a'</span>,
<span class="hljs-symbol">    component:</span> AComponent,
<span class="hljs-symbol">    children:</span> [
      { <span class="hljs-string">path:</span> <span class="hljs-string">''</span>, <span class="hljs-string">component:</span> MasterComponent, <span class="hljs-string">outlet:</span> <span class="hljs-string">'master'</span> },
      { <span class="hljs-string">path:</span> <span class="hljs-string">''</span>, <span class="hljs-string">component:</span> DetailComponent, <span class="hljs-string">outlet:</span> <span class="hljs-string">'detail'</span> },
    ],
  },
  {
<span class="hljs-symbol">    path:</span> <span class="hljs-string">'b'</span>,
<span class="hljs-symbol">    loadChildren:</span> 
      () =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">'./b/b.module'</span>)
        .then((module) =&gt; module.BModule), 
<span class="hljs-symbol">    canLoad:</span> [AuthGuard],
  },
  { <span class="hljs-string">path:</span> <span class="hljs-string">'c'</span>, <span class="hljs-string">component:</span> CComponent },
  { <span class="hljs-string">path:</span> <span class="hljs-string">'**'</span>, <span class="hljs-string">component:</span> PageNotFoundComponent },
]
</code></pre>
    <p class="normal">Note that <a id="_idIndexMarker682"/>the definitions for routes <code class="Code-In-Text--PACKT-">d</code>, <code class="Code-In-Text--PACKT-">e</code>, and <code class="Code-In-Text--PACKT-">f</code> do not exist in the <code class="Code-In-Text--PACKT-">rootRouter</code>. See the example router definition for the <code class="Code-In-Text--PACKT-">childRouter</code>: </p>
    <pre class="programlisting"><code class="hljs groovy"><strong>childRouter example</strong>
const <span class="hljs-string">routes:</span> Routes = [
  { <span class="hljs-string">path:</span> <span class="hljs-string">''</span>, <span class="hljs-string">redirectTo:</span> <span class="hljs-string">'/b/d'</span>, <span class="hljs-string">pathMatch:</span> <span class="hljs-string">'full'</span> },
  { <span class="hljs-string">path:</span> <span class="hljs-string">'d'</span>, <span class="hljs-string">component:</span> DComponent },
  { <span class="hljs-string">path:</span> <span class="hljs-string">'e'</span>, <span class="hljs-string">component:</span> EComponent },
  { <span class="hljs-string">path:</span> <span class="hljs-string">'f'</span>, <span class="hljs-string">component:</span> FComponent },
]
</code></pre>
    <p class="normal">As you can see the routes defined in the <code class="Code-In-Text--PACKT-">childRouter</code> are independent of the ones defined in the <code class="Code-In-Text--PACKT-">rootRouter</code>. Child routes exist in a hierarchy, where <code class="Code-In-Text--PACKT-">/b</code> is the parent path. To navigate to the <code class="Code-In-Text--PACKT-">DComponent</code>, you must use the path <code class="Code-In-Text--PACKT-">/b/d</code>, whereas, to navigate to <code class="Code-In-Text--PACKT-">CComponent</code>, you can just use <code class="Code-In-Text--PACKT-">/c</code>.</p>
    <p class="normal">Given this <a id="_idIndexMarker683"/>example configuration, every component defined in the <code class="Code-In-Text--PACKT-">rootRouter</code> and their dependencies would be in the first chunk of our app, and thus eagerly loaded. The first chunk would include the components <code class="Code-In-Text--PACKT-">A</code>, <code class="Code-In-Text--PACKT-">Master</code>, <code class="Code-In-Text--PACKT-">Detail</code>, <code class="Code-In-Text--PACKT-">C</code>, and <code class="Code-In-Text--PACKT-">PageNotFound</code>. The second chunk would contain the components <code class="Code-In-Text--PACKT-">D</code>, <code class="Code-In-Text--PACKT-">E</code>, and <code class="Code-In-Text--PACKT-">F</code>. This second chunk would not be downloaded or loaded until the user navigated to a path starting with <code class="Code-In-Text--PACKT-">/b</code>; thus, it's lazily loaded.</p>
    <div class="packt_tip">
      <p>In the book I only cover the well-established method of lazily loaded feature modules. Check out <a id="_idIndexMarker684"/>John Papa's blog post on creating lazily loading components at <a href="https://johnpapa.net/angular-9-lazy-loading-components/"><span class="url">https://johnpapa.net/angular-9-lazy-loading-components/</span></a>.</p>
    </div>
    <p class="normal">We will now go over how to set up a feature module with components and routes. We will also use Augury to observe the effects of our various router configurations.</p>
    <h2 class="title" id="_idParaDest-255">Configuring feature modules with components and routes</h2>
    <p class="normal">The manager <a id="_idIndexMarker685"/>module needs a landing page, as shown in this mock-up:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_15.png"/></figure>
    <p class="packt_figref">Figure 7.15: Manager's dashboard</p>
    <p class="normal">Let's start by creating the home screen for the <code class="Code-In-Text--PACKT-">ManagerModule</code>:</p>
    <ol>
      <li class="list" value="1">Create the <code class="Code-In-Text--PACKT-">ManagerHome</code> component:
        <pre class="programlisting"><code class="hljs elixir"><span class="hljs-variable">$ </span>npx ng g c manager/managerHome -m manager -s -t
</code></pre>
        <div class="packt_tip">
          <p>In order to create the new component under the <code class="Code-In-Text--PACKT-">manager</code> folder, we must prefix <code class="Code-In-Text--PACKT-">manager/</code> in front of the component name. In addition, we specify that the component should be imported and declared with the <code class="Code-In-Text--PACKT-">ManagerModule</code>. Since this is another landing page, it is unlikely to be complicated enough to require separate HTML and CSS files. You can use <code class="Code-In-Text--PACKT-">--inline-style</code> (alias <code class="Code-In-Text--PACKT-">-s</code>) and/or <code class="Code-In-Text--PACKT-">--inline-template</code> (alias <code class="Code-In-Text--PACKT-">-t</code>) to avoid creating additional files.</p>
        </div>
      </li>
      <li class="list">Verify that your folder structure looks as follows:
        <pre class="programlisting"><code class="hljs stylus">/src
├───app
│ │
│ ├───manager
│ │ │ manager-routing<span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span>
│ │ │ manager<span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span>
│ │ │
│ │ └───manager-home
│ │ │ │ manager-home<span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.spec</span><span class="hljs-selector-class">.ts</span>
│ │ │ │ manager-home<span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.ts</span>
</code></pre>
      </li>
      <li class="list" value="3">Configure the <code class="Code-In-Text--PACKT-">ManagerHome</code> component's route with <code class="Code-In-Text--PACKT-">manager-routing.module</code>, similar to how we configured the <code class="Code-In-Text--PACKT-">Home</code> component with <code class="Code-In-Text--PACKT-">app-route.module</code>:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>manager/manager-routing.module.ts</strong>
<span class="hljs-keyword">import</span> { 
  ManagerHomeComponent 
} from <span class="hljs-string">'./manager-home/manager-home.component'</span> 
const <span class="hljs-string">routes:</span> Routes = [ 
  { <span class="hljs-string">path:</span> <span class="hljs-string">''</span>, <span class="hljs-string">redirectTo:</span> <span class="hljs-string">'/manager/home'</span>, <span class="hljs-string">pathMatch:</span> <span class="hljs-string">'full'</span> }, 
  { <span class="hljs-string">path:</span> <span class="hljs-string">'home'</span>, <span class="hljs-string">component:</span> ManagerHomeComponent }, 
] 
</code></pre>
      </li>
    </ol>
    <p class="normal">Note that <code class="Code-In-Text--PACKT-">http://localhost:5000/manager</code> doesn't actually resolve to a component yet, because <a id="_idIndexMarker686"/>our Angular app isn't aware that <code class="Code-In-Text--PACKT-">ManagerModule</code> exists. Let's first try the brute-force, eager-loading approach to import <code class="Code-In-Text--PACKT-">ManagerModule</code> and register the manager route with our app.</p>
    <h2 class="title" id="_idParaDest-256">Eager loading</h2>
    <p class="normal">Let's start <a id="_idIndexMarker687"/>by eagerly loading the <code class="Code-In-Text--PACKT-">ManagerModule</code>, so we can see how importing and registering routes in the root module doesn't result in a scalable solution:</p>
    <ol>
      <li class="list" value="1">Import the <code class="Code-In-Text--PACKT-">ManagerModule</code> in <code class="Code-In-Text--PACKT-">app.module.ts</code>:
        <pre class="programlisting"><code class="hljs coffeescript"><strong>src/app/app.<span class="hljs-built_in">module</span>.ts</strong>
<span class="hljs-keyword">import</span> { ManagerModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./manager/manager.module'</span> 
...
@NgModule({ 
  imports: [..., ManagerModule],
  ...
}) 
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">You will note that <code class="Code-In-Text--PACKT-">http://localhost:5000/manager</code> still doesn't render its <code class="Code-In-Text--PACKT-">home</code> component.</p>
      </li>
      <li class="list">Use <strong class="screen-text">Augury</strong> to debug the router state, as shown:<figure class="mediaobject"><img alt="" src="../Images/B14094_07_16.png"/></figure>
        <p class="packt_figref">Figure 7.16: Router tree with eager loading</p>
        <div class="packt_tip">
          <p>Note that at the time of publishing, Augury's support for the Ivy rendering engine is not great. In order to <a id="_idIndexMarker688"/>reliably view the <strong class="bold">Router Tree</strong> tab, you need to disable Ivy. You can do so by adding the following setting to the <code class="Code-In-Text--PACKT-">tsconfig.app.json</code> file in your project:</p>
          <pre class="programlisting"><code class="hljs yaml">  <span class="hljs-attr">"angularCompilerOptions":</span> <span class="hljs-string">{</span>
    <span class="hljs-attr">"enableIvy":</span> <span class="hljs-literal">false</span>
  <span class="hljs-string">}</span>
</code></pre>
          <p>You will need to restart your Angular app and reload Augury for changes to take effect. However, getting the pretty diagram is not worth accidentally shipping your app with Ivy disabled. Be careful with this one!</p>
        </div>
      </li>
      <li class="list">It seems <a id="_idIndexMarker689"/>as if the <code class="Code-In-Text--PACKT-">/manager</code> path is correctly registered and pointed at the correct component, <code class="Code-In-Text--PACKT-">ManagerHomeComponent</code>. The issue here is that the <code class="Code-In-Text--PACKT-">rootRouter</code> configured in <code class="Code-In-Text--PACKT-">app-routing.module</code> isn't aware of the <code class="Code-In-Text--PACKT-">/manager</code> path, so the <code class="Code-In-Text--PACKT-">**</code> path is taking precedence and rendering the <code class="Code-In-Text--PACKT-">PageNotFoundComponent</code> instead.</li>
      <li class="list">Implement <a id="_idIndexMarker690"/>the <code class="Code-In-Text--PACKT-">'manager'</code> path in <code class="Code-In-Text--PACKT-">app-routing.module.ts</code> and assign <code class="Code-In-Text--PACKT-">ManagerHomeComponent</code> to it, so we can see what happens:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>app-routing.module.ts</strong>
<strong><span class="hljs-keyword">import</span> { </strong>
<strong>  ManagerHomeComponent </strong>
<strong>} from <span class="hljs-string">'./manager/manager-home/ manager-home.component'</span> </strong>
...
const <span class="hljs-string">routes:</span> Routes = [
  ...
  <strong>{ <span class="hljs-string">path:</span> <span class="hljs-string">'manager'</span>, <span class="hljs-string">component:</span> ManagerHomeComponent },</strong>
  { <span class="hljs-string">path:</span> <span class="hljs-string">'**'</span>, <span class="hljs-string">component:</span> PageNotFoundComponent },
]
</code></pre>
        <figure class="mediaobject"><img alt="" src="../Images/B14094_07_17.png"/></figure>
        <p class="packt_figref">Figure 7.17: Manager home renders with duplicate path registration</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">As shown in the image above, <code class="Code-In-Text--PACKT-">http://localhost:5000/manager</code> renders correctly, by displaying manager-home works! However, when you debug the router state through Augury, note that the <code class="Code-In-Text--PACKT-">ManagerHomeComponent</code> is registered twice. This is because both the <code class="Code-In-Text--PACKT-">rootRouter</code> and the <code class="Code-In-Text--PACKT-">childRouter</code> registrations are being picked up. To avoid this issue, we would have to centralize all path creation in the <code class="Code-In-Text--PACKT-">rootRouter</code> and not use child routers.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Centralizing all paths in the <code class="Code-In-Text--PACKT-">rootRouter</code> doesn't scale well, because it forces all developers to maintain a single master file to import and configure every module. It is ripe for merge conflicts and frustrating exchanges between team members. As a file grows larger, the chances of introducing a bug increase exponentially, where the same route could unintentionally be registered multiple times.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">It is possible to engineer a solution to divide up the modules into multiple files. Instead of the standard <code class="Code-In-Text--PACKT-">*-routing.module</code>, you could implement a new routes array in <code class="Code-In-Text--PACKT-">ManagerModule</code> and import it to the <code class="Code-In-Text--PACKT-">rootRouter</code>. Let's fix the duplicate registration issue. </p>
      </li>
      <li class="list">In <code class="Code-In-Text--PACKT-">manager.module.ts</code>, remove <code class="Code-In-Text--PACKT-">ManagerRoutingModule</code> from the imports array.</li>
      <li class="list">In <code class="Code-In-Text--PACKT-">manager.module.ts</code>, implement a <code class="Code-In-Text--PACKT-">Routes</code> array and set an empty path for the component <code class="Code-In-Text--PACKT-">ManagerHomeComponent</code> as shown:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>manager/manager.module.ts</strong>
<span class="hljs-keyword">import</span> { Routes } from <span class="hljs-string">'@angular/router'</span>
export const <span class="hljs-string">managerModuleRoutes:</span> Routes = [
  { <span class="hljs-string">path:</span> <span class="hljs-string">''</span>, <span class="hljs-string">component:</span> ManagerHomeComponent }
]
</code></pre>
      </li>
      <li class="list">In <code class="Code-In-Text--PACKT-">app-routing.module.ts</code>, import the <a id="_idIndexMarker691"/>array you just created and assign it to the <code class="Code-In-Text--PACKT-">children</code> property of the <code class="Code-In-Text--PACKT-">'manager'</code> path:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>app-routing.module.ts</strong>
<span class="hljs-keyword">import</span> { <strong>managerModuleRoutes</strong> } from <span class="hljs-string">'./manager/manager.module'</span>
...
{ <span class="hljs-string">path:</span> <span class="hljs-string">'manager'</span>, <span class="hljs-string">children:</span> <strong>managerModuleRoutes</strong> },
</code></pre>
        <div class="packt_tip">
          <p>Don't forget to remove the <code class="Code-In-Text--PACKT-">component</code> property and the import for <code class="Code-In-Text--PACKT-">ManagerHomeModule</code>.</p>
        </div>
      </li>
    </ol>
    <p class="normal">Let's inspect the <strong class="screen-text">Router Tree</strong> on Augury again to see if we resolved the duplicate registration issue:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_18.png"/></figure>
    <p class="packt_figref">Figure 7.18: Router Tree with children routes</p>
    <p class="normal">The provided solution works. There are no duplicate registrations, because we stopped using the <code class="Code-In-Text--PACKT-">childRouters</code> in <code class="Code-In-Text--PACKT-">manager-routing.module.ts</code>. In addition, we maintained some <a id="_idIndexMarker692"/>separation of concerns, by not importing <code class="Code-In-Text--PACKT-">ManagerHomeComponent</code> outside of <code class="Code-In-Text--PACKT-">ManagerModule</code>, resulting in a more scalable solution. However, as the app grows, we must still register all modules with <code class="Code-In-Text--PACKT-">app.module.ts</code>. As a result, feature modules are still tightly coupled to the root module in potentially unpredictable ways. Further, this code can't be chunked, because the feature module is directly imported in <code class="Code-In-Text--PACKT-">app.module.ts</code>, so the TypeScript compiler sees it as a required dependency.</p>
    <p class="normal">Next, let's transform our configuration into a lazily loading one.</p>
    <h2 class="title" id="_idParaDest-257">Lazy loading</h2>
    <p class="normal">Now that you understand how eager loading of modules works, you will be able to better understand <a id="_idIndexMarker693"/>the code we are about to write, which may otherwise seem like black magic, and magical (also known as misunderstood) code always leads to spaghetti architectures.</p>
    <p class="normal">We will now evolve the eager loading solution to be a lazy loading one. In order to load routes from a different module, we know we can't simply import them, otherwise they will be eagerly loaded. The answer lies in configuring a route using the <code class="Code-In-Text--PACKT-">loadChildren</code> attribute with an inline import statement informing the router how to load a feature module in <code class="Code-In-Text--PACKT-">app-routing.module.ts</code>:</p>
    <ol>
      <li class="list" value="1">Ensure that any module you intend to lazy load is not imported in <code class="Code-In-Text--PACKT-">app.module.ts</code>, so remove the <code class="Code-In-Text--PACKT-">ManagerModule</code> from the <code class="Code-In-Text--PACKT-">imports</code>.</li>
      <li class="list">Remove the <code class="Code-In-Text--PACKT-">Routes</code> array added to <code class="Code-In-Text--PACKT-">ManagerModule</code>.</li>
      <li class="list">Add back the <code class="Code-In-Text--PACKT-">ManagerRoutingModule</code> to <code class="Code-In-Text--PACKT-">imports</code> in <code class="Code-In-Text--PACKT-">ManagerModule</code>.</li>
      <li class="list">In <code class="Code-In-Text--PACKT-">app-routing.module.ts</code>, implement or update the <code class="Code-In-Text--PACKT-">'manager'</code> path with the <code class="Code-In-Text--PACKT-">loadChildren</code> attribute:
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/app-routing.<span class="hljs-keyword">module</span>.ts</strong>
import { NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { RouterModule, Routes } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>
<span class="hljs-keyword">import</span> { HomeComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./home/home.component'</span>
<span class="hljs-keyword">import</span> { PageNotFoundComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./page-not-found/page-not-found.component'</span>
... 
  <span class="hljs-keyword">const</span> routes: Routes = [ 
    ..., 
    { 
      path: <span class="hljs-string">'manager'</span>, 
      loadChildren: 
        <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./manager/manager.module'</span>)
          . then(<span class="hljs-function"><span class="hljs-params">m</span>=&gt;</span> m.ManagerModule), 
    }, 
    { path: <span class="hljs-string">'**'</span>, component: PageNotFoundComponent }, 
  ] 
... 
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Lazy loading is achieved via a clever trick that avoids using an import statement at the file level. A function delegate is set to the <code class="Code-In-Text--PACKT-">loadChildren</code> property, which contains an inline import statement defining the location of the feature module file, such as <code class="Code-In-Text--PACKT-">./manager/manager.module</code>, allowing us to refer to <code class="Code-In-Text--PACKT-">ManagerModule</code> in a type-safe manner without actually fully loading it. The inline import statement can be interpreted during the build process to create a separate JavaScript chunk that can be downloaded only when needed. <code class="Code-In-Text--PACKT-">ManagerModule</code> then acts as if its own Angular app and manages all its children dependencies and routes.</p>
      </li>
      <li class="list">Update <a id="_idIndexMarker694"/>the <code class="Code-In-Text--PACKT-">manager-routing.module</code> routes, considering that <code class="Code-In-Text--PACKT-">manager</code> is now their root route:
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>manager/manager-routing.module.ts</strong>
const <span class="hljs-string">routes:</span> Routes = [
  { <span class="hljs-string">path:</span> <span class="hljs-string">''</span>, <span class="hljs-string">redirectTo:</span> <span class="hljs-string">'/manager/home'</span>, <span class="hljs-string">pathMatch:</span> <span class="hljs-string">'full'</span> },
  { <span class="hljs-string">path:</span> <span class="hljs-string">'home'</span>, <span class="hljs-string">component:</span> ManagerHomeComponent },
]
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">We can now update the route for <code class="Code-In-Text--PACKT-">ManagerHomeComponent</code> to a more meaningful <code class="Code-In-Text--PACKT-">'home'</code> path. This path won't clash with the one found in <code class="Code-In-Text--PACKT-">app-routing.module</code>, because in this context, <code class="Code-In-Text--PACKT-">'home'</code> resolves to <code class="Code-In-Text--PACKT-">'manager/home'</code> and, similarly, where <code class="Code-In-Text--PACKT-">path</code> is empty, the URL will look like <code class="Code-In-Text--PACKT-">http://localhost:5000/manager</code>.</p>
      </li>
      <li class="list">Restart your <code class="Code-In-Text--PACKT-">ng serve</code> or <code class="Code-In-Text--PACKT-">npm start</code> command, so Angular can chunk the app properly.</li>
      <li class="list">Navigate to <code class="Code-In-Text--PACKT-">http://localhost:5000/manager</code>.</li>
      <li class="list">Confirm <a id="_idIndexMarker695"/>that lazy loading is working by looking at Augury, as follows:
      <figure class="mediaobject"><img alt="" src="../Images/B14094_07_19.png"/></figure>
      <p class="packt_figref">Figure 7.19: Router tree with lazy loading</p></li>
    </ol>
    <div class="packt_tip">
      <p>The root node for <code class="Code-In-Text--PACKT-">ManagerHomeComponent</code> is now named <strong class="bold">manager [Lazy]</strong>.</p>
    </div>
    <p class="normal">We have successfully set up a feature module with lazy loading. Next, let's implement the walking skeleton for LemonMart.</p>
    <h1 class="title" id="_idParaDest-258">Completing the walking skeleton</h1>
    <p class="normal">Using the site map we created for LemonMart earlier in the chapter, we need to complete <a id="_idIndexMarker696"/>the walking skeleton navigation experience for the app. In order to create this experience, we will need to create some buttons to link all modules and components together. We will go at this module by module.</p>
    <p class="normal">Before we start, update the login button on the <code class="Code-In-Text--PACKT-">HomeComponent</code> to navigate to the <code class="Code-In-Text--PACKT-">'manager'</code> path using the <code class="Code-In-Text--PACKT-">routerLink</code> attribute and rename the button:</p>
    <pre class="programlisting"><code class="hljs stylus"><strong>src/app/home/home<span class="hljs-selector-class">.component</span><span class="hljs-selector-class">.ts</span></strong>
  ...
  &lt;<span class="hljs-selector-tag">button</span> mat-raised-<span class="hljs-selector-tag">button</span> <span class="hljs-attribute">color</span>=<span class="hljs-string">"primary"</span> <strong>routerLink=<span class="hljs-string">"/manager"</span></strong>&gt;
    <strong>Login as Manager</strong>
  &lt;/button&gt;
  ...
</code></pre>
    <p class="normal">Now, we can navigate to the <code class="Code-In-Text--PACKT-">ManagerHome</code> component by clicking on the <strong class="screen-text">Login</strong> button.</p>
    <h2 class="title" id="_idParaDest-259">The manager module</h2>
    <p class="normal">Since we already enabled lazy loading for <code class="Code-In-Text--PACKT-">ManagerModule</code>, let's go ahead and complete the rest of <a id="_idIndexMarker697"/>the navigational elements for it.</p>
    <p class="normal">In the current setup, <code class="Code-In-Text--PACKT-">ManagerHomeComponent</code> renders in the <code class="Code-In-Text--PACKT-">&lt;router-outlet&gt;</code> defined in <code class="Code-In-Text--PACKT-">AppComponent</code>'s template, so when the user navigates from <code class="Code-In-Text--PACKT-">HomeComponent</code> to <code class="Code-In-Text--PACKT-">ManagerHomeComponent</code>, the toolbar implemented in <code class="Code-In-Text--PACKT-">AppComponent</code> remains in place. See the following mock-up for <strong class="bold">Manager's Dashboard</strong>:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_20.png"/></figure>
    <p class="packt_figref">Figure 7.20: App-wide and feature module toolbars</p>
    <p class="normal">The app-wide toolbar remains in place no matter where we navigate to. You can imagine that we can implement a similar toolbar for the feature module that persists throughout <code class="Code-In-Text--PACKT-">ManagerModule</code>. So, the <a id="_idIndexMarker698"/>navigational buttons <strong class="bold">User Management</strong> and <strong class="bold">Receipt Look-up</strong> would <a id="_idIndexMarker699"/>always be visible. This allows us to create a consistent UX for navigating subpages across modules.</p>
    <p class="normal">To implement a secondary toolbar, we need to replicate the parent-child relationship between <code class="Code-In-Text--PACKT-">AppComponent</code> and <code class="Code-In-Text--PACKT-">HomeComponent</code>, where the parent implements the toolbar and a <code class="Code-In-Text--PACKT-">&lt;router-outlet&gt;</code> so that children elements can be rendered in there:</p>
    <ol>
      <li class="list" value="1">Start by creating the base <code class="Code-In-Text--PACKT-">manager</code> component:
        <pre class="programlisting"><code class="hljs ada">$ npx ng g c manager/manager -m manager <span class="hljs-comment">--flat -s -t</span>
</code></pre>
        <div class="packt_tip">
          <p>The <code class="Code-In-Text--PACKT-">--flat</code> option skips directory creation and places the component directly under the <code class="Code-In-Text--PACKT-">manager</code> folder, just like <code class="Code-In-Text--PACKT-">app.component</code> residing directly under the <code class="Code-In-Text--PACKT-">app</code> folder.</p>
        </div>
      </li>
      <li class="list">In <code class="Code-In-Text--PACKT-">ManagerComponent</code>, implement a navigational toolbar with <code class="Code-In-Text--PACKT-">activeLink</code> tracking:
        <pre class="programlisting"><code class="hljs xml"><strong>src/app/manager/manager.component.ts</strong>
styles: [
  `
    div[fxLayout] {
      margin-top: 32px;
    }
  `, 
  `
    .active-link {
      font-weight: bold;
      border-bottom: 2px solid #005005;
    }
  `,
],
template: `
<span class="hljs-tag">&lt;<span class="hljs-name">mat-toolbar</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"accent"</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-button</span> 
    <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/manager/home"</span> 
    <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active-link"</span>
   &gt;</span>
      Manager's Dashboard
  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-button</span> 
    <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/manager/users"</span> 
    <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active-link"</span>
  &gt;</span>
    User Management
  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-button</span> 
     <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/manager/receipts"</span> 
     <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active-link"</span>
   &gt;</span>
     Receipt Lookup
   <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-toolbar</span>&gt;</span> 
<span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span>
`
</code></pre>
        <div class="note">
          <p class="Information-Box--PACKT-">It must be noted that feature modules don't automatically have access to services or components created in parent modules. This is an important default behavior to preserve a decoupled architecture. However, there are certain cases where it is desirable to share some amount of code. In this case, <code class="Code-In-Text--PACKT-">mat-toolbar</code> needs to be reimported. Since the <code class="Code-In-Text--PACKT-">MatToolbarModule</code> is already loaded in <code class="Code-In-Text--PACKT-">src/app/material.module.ts</code>, we can just import this module into <code class="Code-In-Text--PACKT-">manager.module.ts</code> and there will not be a performance or memory penalty for doing so.</p>
        </div>
      </li>
      <li class="list">Ensure <code class="Code-In-Text--PACKT-">ManagerComponent</code> is <a id="_idIndexMarker700"/>declared and <code class="Code-In-Text--PACKT-">MaterialModule</code> is imported in <code class="Code-In-Text--PACKT-">ManagerModule</code>:
        <pre class="programlisting"><code class="hljs clean"><strong>src/app/manager/manager.<span class="hljs-keyword">module</span>.ts</strong>
<span class="hljs-keyword">import</span> { MaterialModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'../material.module'</span> 
<span class="hljs-keyword">import</span> { ManagerComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./manager.component'</span>
...
declarations: [..., <strong>ManagerComponent</strong>],
imports: [..., <strong>MaterialModule</strong>], 
</code></pre>
      </li>
      <li class="list">Create components for the subpages:
        <pre class="programlisting"><code class="hljs elixir"><span class="hljs-variable">$ </span>npx ng g c manager/userManagement -m manager
<span class="hljs-variable">$ </span>npx ng g c manager/receiptLookup -m manager
</code></pre>
      </li>
      <li class="list" value="5">Create the parent-children routing. We know that we need the following routes to be able to navigate to our subpages, as follows:
        <pre class="programlisting"><code class="hljs css"><strong><span class="hljs-selector-tag">example</span></strong>
{ <span class="hljs-attribute">path</span>: <span class="hljs-string">''</span>, redirectTo: <span class="hljs-string">'/manager/home'</span>, pathMatch: <span class="hljs-string">'full'</span> },
{ <span class="hljs-attribute">path</span>: <span class="hljs-string">'home'</span>, component: ManagerHomeComponent },
{ <span class="hljs-attribute">path</span>: <span class="hljs-string">'users'</span>, component: UserManagementComponent },
{ <span class="hljs-attribute">path</span>: <span class="hljs-string">'receipts'</span>, component: ReceiptLookupComponent },
</code></pre>
      </li>
    </ol>
    <p class="normal">In order to target the <code class="Code-In-Text--PACKT-">&lt;router-outlet&gt;</code> defined in <code class="Code-In-Text--PACKT-">ManagerComponent</code>, we need to create a <a id="_idIndexMarker701"/>parent route first and then specify routes for the subpages:</p>
    <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>manager/manager-routing.module.ts</strong>
...
<span class="hljs-keyword">import</span> { NgModule } from <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { RouterModule, Routes } from <span class="hljs-string">'@angular/router'</span>
<span class="hljs-keyword">import</span> { ManagerHomeComponent } from <span class="hljs-string">'./manager-home/manager-home.component'</span>
<span class="hljs-keyword">import</span> { ManagerComponent } from <span class="hljs-string">'./manager.component'</span>
<span class="hljs-keyword">import</span> { ReceiptLookupComponent } from <span class="hljs-string">'./receipt-lookup/receipt-lookup.component'</span>
<span class="hljs-keyword">import</span> { UserManagementComponent } from <span class="hljs-string">'./user-management/user-management.component'</span> 
const <span class="hljs-string">routes:</span> Routes = [
  {
<span class="hljs-symbol">    path:</span> <span class="hljs-string">''</span>, 
<span class="hljs-symbol">    component:</span> ManagerComponent, 
<span class="hljs-symbol">    children:</span> [
      { <span class="hljs-string">path:</span> <span class="hljs-string">''</span>, <span class="hljs-string">redirectTo:</span> <span class="hljs-string">'/manager/home'</span>, <span class="hljs-string">pathMatch:</span> <span class="hljs-string">'full'</span> },
      { <span class="hljs-string">path:</span> <span class="hljs-string">'home'</span>, <span class="hljs-string">component:</span> ManagerHomeComponent },
      { <span class="hljs-string">path:</span> <span class="hljs-string">'users'</span>, <span class="hljs-string">component:</span> UserManagementComponent },
      { <span class="hljs-string">path:</span> <span class="hljs-string">'receipts'</span>, <span class="hljs-string">component:</span> ReceiptLookupComponent },
    ],
  },
]
</code></pre>
    <p class="normal">You should now be able to navigate through the app. When you click on the <strong class="screen-text">Login as Manager</strong> button, you will be taken to the page shown here. The clickable targets are highlighted, as shown:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_21.png"/></figure>
    <p class="packt_figref">Figure 7.21: Manager's Dashboard with all router links highlighted</p>
    <p class="normal">If you click on <strong class="screen-text">LemonMart</strong>, you will be taken to the home page. If you click on <strong class="screen-text">Manager's Dashboard</strong>, <strong class="screen-text">User Management</strong>, or <strong class="screen-text">Receipt Lookup</strong>, you will be navigated to the <a id="_idIndexMarker702"/>corresponding subpage, while the active link will be bold and underlined on the toolbar.</p>
    <h2 class="title" id="_idParaDest-260">User module</h2>
    <p class="normal">Upon login, users will be able to access their profiles and view a list of actions they can access in the <a id="_idIndexMarker703"/>LemonMart app through a side navigation menu. In <em class="italics">Chapter 8</em>, <em class="italics">Designing Authentication and Authorization</em>, when we implement authentication and authorization, we will be receiving the role of the user from the server. Based on the role of the user, we will be able to automatically navigate or limit the options users can see. We will implement these components in this module so that they will only be loaded once a user is logged in. For the purpose of completing the walking skeleton, we will ignore authentication-related concerns:</p>
    <ol>
      <li class="list" value="1">Create the necessary components:
        <pre class="programlisting"><code class="hljs routeros">$ npx ng g c user<span class="hljs-built_in">/profile </span>-m<span class="hljs-built_in"> user
</span>$ npx ng g c user/logout -m<span class="hljs-built_in"> user </span>-t -s
$ npx ng g c user/navigationMenu -m<span class="hljs-built_in"> user </span>-t -s
</code></pre>
      </li>
      <li class="list">Implement routing.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Start with implementing the lazy loading in <code class="Code-In-Text--PACKT-">app-routing.module.ts</code>:</p>
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/app-routing.<span class="hljs-keyword">module</span>.ts</strong>
... 
{ 
  path: <span class="hljs-string">'user'</span>, 
  loadChildren: 
    <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./user/user.module'</span>)
      .then(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.UserModule), 
},  
</code></pre>
        <div class="packt_tip">
          <p>Ensure <a id="_idIndexMarker704"/>that the <code class="Code-In-Text--PACKT-">PageNotFoundComponent</code> route is always the last route in <code class="Code-In-Text--PACKT-">app-routing.module</code>.</p>
        </div>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Now implement the child routes in <code class="Code-In-Text--PACKT-">user-routing.module.ts</code>:</p>
        <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>user/user-routing.module.ts</strong>
...
const <span class="hljs-string">routes:</span> Routes = [
  { <span class="hljs-string">path:</span> <span class="hljs-string">'profile'</span>, <span class="hljs-string">component:</span> ProfileComponent },
  { <span class="hljs-string">path:</span> <span class="hljs-string">'logout'</span>, <span class="hljs-string">component:</span> LogoutComponent },
]
</code></pre>
        <div class="note">
          <p class="Information-Box--PACKT-">We are implementing routing for <code class="Code-In-Text--PACKT-">NavigationMenuComponent</code>, because it'll be directly used as an HTML element. In addition, since <code class="Code-In-Text--PACKT-">UserModule</code> doesn't have a landing page, there's no default path defined.</p>
        </div>
      </li>
      <li class="list">In <code class="Code-In-Text--PACKT-">AppComponent</code>, wire up the user and logout icons:
        <pre class="programlisting"><code class="hljs stata"><strong>src/<span class="hljs-keyword">app</span>/<span class="hljs-keyword">app</span>.component.ts</strong>
... 
&lt;<span class="hljs-keyword">mat</span>-toolbar&gt; 
  ... 
  &lt;button 
<strong>    <span class="hljs-keyword">mat</span>-mini-fab routerLink=<span class="hljs-string">"/user/profile"</span> </strong>
<strong>    matTooltip=<span class="hljs-string">"Profile"</span> aria-<span class="hljs-keyword">label</span>=<span class="hljs-string">"User Profile"</span></strong>
  &gt; 
    &lt;<span class="hljs-keyword">mat</span>-icon&gt;account_circle&lt;/<span class="hljs-keyword">mat</span>-icon&gt; 
  &lt;/button&gt; 
  &lt;button 
<strong>     <span class="hljs-keyword">mat</span>-mini-fab routerLink=<span class="hljs-string">"/user/logout"</span> </strong>
<strong>     matTooltip=<span class="hljs-string">"Logout"</span> aria-<span class="hljs-keyword">label</span>=<span class="hljs-string">"Logout"</span></strong>
  &gt; 
    &lt;<span class="hljs-keyword">mat</span>-icon&gt;lock_open&lt;/<span class="hljs-keyword">mat</span>-icon&gt; 
  &lt;/button&gt; 
&lt;/<span class="hljs-keyword">mat</span>-toolbar&gt; 
</code></pre>
        <div class="note">
          <p class="Information-Box--PACKT-">Icon buttons can be cryptic, so it's a good idea to add tooltips to them. In order for tooltips to work, switch from the <code class="Code-In-Text--PACKT-">mat-icon-button</code> directive to the <code class="Code-In-Text--PACKT-">mat-mini-fab</code> directive and ensure that you import <code class="Code-In-Text--PACKT-">MatTooltipModule</code> in <code class="Code-In-Text--PACKT-">material.module.ts</code>. In addition, ensure that you add <code class="Code-In-Text--PACKT-">aria-label</code> for icon-only buttons so that users with disabilities relying on screen readers can still navigate your web application.</p>
        </div>
      </li>
      <li class="list">Ensure that the app works.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">You'll note that the two buttons are too close to each other, as follows:</p>
        <figure class="mediaobject"><img alt="" src="../Images/B14094_07_22.png"/></figure>
        <p class="packt_figref">Figure 7.22: Toolbar with icons</p>
      </li>
      <li class="list">You can fix the <a id="_idIndexMarker705"/>icon layout issue by adding <code class="Code-In-Text--PACKT-">fxLayoutGap="8px"</code> to <code class="Code-In-Text--PACKT-">&lt;mat-toolbar&gt;</code>; however, now the lemon logo is too far apart from the app name, as shown:</li>
    </ol>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_23.png"/></figure>
    <p class="packt_figref">Figure 7.23: Toolbar with padded icons</p>
    <ol>
      <li class="list" value="6">The logo layout issue can be fixed by merging the icon and the button:
        <pre class="programlisting"><code class="hljs xml"><strong>src/app/app.component.ts</strong>
...
<span class="hljs-tag">&lt;<span class="hljs-name">mat-toolbar</span>&gt;</span>
  ...
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-icon-button</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/home"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-icon</span> <span class="hljs-attr">svgIcon</span>=<span class="hljs-string">"lemon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-icon</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mat-h2"</span>&gt;</span>LemonMart<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
  ...
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-toolbar</span>&gt;</span>
</code></pre>
      </li>
    </ol>
    <p class="normal">As shown in the following screenshot, the grouping fixes the layout issue:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_24.png"/></figure>
    <p class="packt_figref">Figure 7.24: Toolbar with grouped and padded elements</p>
    <p class="normal">This is more <a id="_idIndexMarker706"/>desirable from a UX perspective also; now users can go back to the home page by clicking on the lemon as well.</p>
    <h2 class="title" id="_idParaDest-261">POS and inventory modules</h2>
    <p class="normal">Our walking <a id="_idIndexMarker707"/>skeleton presumes the role of the manager. To be able to access <a id="_idIndexMarker708"/>all components we are about to create, we need to enable the manager to be able to access POS and inventory modules.</p>
    <p class="normal">Update <code class="Code-In-Text--PACKT-">ManagerComponent</code> with two new buttons:</p>
    <pre class="programlisting"><code class="hljs stata"><strong>src/<span class="hljs-keyword">app</span>/manager/manager.component.ts</strong>
&lt;<span class="hljs-keyword">mat</span>-toolbar color=<span class="hljs-string">"accent"</span> <strong>fxLayoutGap=<span class="hljs-string">"8px"</span></strong>&gt; 
<strong>  ... </strong>
<strong>  &lt;span <span class="hljs-keyword">class</span>=<span class="hljs-string">"flex-spacer"</span>&gt;&lt;/span&gt; </strong>
<strong>  &lt;button </strong>
<strong>    <span class="hljs-keyword">mat</span>-mini-fab routerLink=<span class="hljs-string">"/inventory"</span> </strong>
<strong>    matTooltip=<span class="hljs-string">"Inventory"</span> aria-<span class="hljs-keyword">label</span>=<span class="hljs-string">"Inventory"</span></strong>
<strong>  &gt; </strong>
<strong>    &lt;<span class="hljs-keyword">mat</span>-icon&gt;<span class="hljs-keyword">list</span>&lt;/<span class="hljs-keyword">mat</span>-icon&gt; </strong>
<strong>  &lt;/button&gt; </strong>
<strong>  &lt;button </strong>
<strong>    <span class="hljs-keyword">mat</span>-mini-fab routerLink=<span class="hljs-string">"/pos"</span> </strong>
<strong>    matTooltip=<span class="hljs-string">"POS"</span> aria-<span class="hljs-keyword">label</span>=<span class="hljs-string">"POS"</span></strong>
<strong>  &gt; </strong>
<strong>    &lt;<span class="hljs-keyword">mat</span>-icon&gt;shopping_cart&lt;/<span class="hljs-keyword">mat</span>-icon&gt; </strong>
<strong>  &lt;/button&gt; </strong>
&lt;/<span class="hljs-keyword">mat</span>-toolbar&gt; 
</code></pre>
    <p class="normal">Note that these router links will navigate us out of the realm of the <code class="Code-In-Text--PACKT-">ManagerModule</code>, so it is normal for the manager-specific secondary toolbar to disappear.</p>
    <p class="normal">Now, it'll be up to you to implement the last two remaining modules. For the two new modules, I provide high-level steps and refer you to a previous module you can model the new one on. If you get stuck refer to the <code class="Code-In-Text--PACKT-">projects/ch7</code> folder on the GitHub project at <a href="https://github.com/duluca/lemon-mart"><span class="url">https://github.com/duluca/lemon-mart</span></a>.</p>
    <h3 class="title" id="_idParaDest-262">POS module</h3>
    <p class="normal"><code class="Code-In-Text--PACKT-">PosModule</code> is very <a id="_idIndexMarker709"/>similar to the <code class="Code-In-Text--PACKT-">UserModule</code>, except that <code class="Code-In-Text--PACKT-">PosModule</code> was a default path. The <code class="Code-In-Text--PACKT-">PosComponent</code> will be the default component. This has the potential to be a complicated component with some subcomponents, so don't use inline templates or styles:</p>
    <ol>
      <li class="list" value="1">Create the <code class="Code-In-Text--PACKT-">PosComponent</code></li>
      <li class="list">Register <code class="Code-In-Text--PACKT-">PosComponent</code> as the default path</li>
      <li class="list">Configure lazy loading for <code class="Code-In-Text--PACKT-">PosModule</code></li>
      <li class="list" value="4">Ensure that the app works</li>
    </ol>
    <p class="normal">Now let's implement the inventory module.</p>
    <h3 class="title" id="_idParaDest-263">Inventory module</h3>
    <p class="normal"><code class="Code-In-Text--PACKT-">InventoryModule</code> is very <a id="_idIndexMarker710"/>similar to <code class="Code-In-Text--PACKT-">ManagerModule</code>, as shown:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_25.png"/></figure>
    <p class="packt_figref">Figure 7.25: Inventory Dashboard mock-up</p>
    <ol>
      <li class="list" value="1">Create a base <code class="Code-In-Text--PACKT-">Inventory</code> component</li>
      <li class="list">Register the <code class="Code-In-Text--PACKT-">MaterialModule</code></li>
      <li class="list">Create <strong class="screen-text">Inventory Home</strong>, <strong class="screen-text">Stock Entry</strong>, <strong class="screen-text">Products</strong>, and <strong class="screen-text">Categories</strong> components</li>
      <li class="list">Configure parent-children routes in <code class="Code-In-Text--PACKT-">inventory-routing.module.ts</code></li>
      <li class="list">Configure lazy loading for <code class="Code-In-Text--PACKT-">InventoryModule</code></li>
      <li class="list">Implement a secondary toolbar for internal <code class="Code-In-Text--PACKT-">InventoryModule</code> navigation in <code class="Code-In-Text--PACKT-">InventoryComponent</code></li>
      <li class="list" value="7">Ensure that the app works, as shown:</li>
    </ol>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_26.png"/></figure>
    <p class="packt_figref">Figure 7.26: LemonMart Inventory Dashboard</p>
    <p class="normal">Now that the <a id="_idIndexMarker711"/>walking skeleton of the app is completed, it is important to inspect the router tree to ensure that lazy loading has been configured correctly and modules aren't unintentionally being eagerly loaded.</p>
    <h2 class="title" id="_idParaDest-264">Inspect the router tree</h2>
    <p class="normal">Navigate to <a id="_idIndexMarker712"/>the base route of the app and use Augury to inspect the router tree, as illustrated:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_27.png"/></figure>
    <p class="packt_figref">Figure 7.27: Router tree with lazy loading</p>
    <p class="normal">Everything but the initially <a id="_idIndexMarker713"/>required components should be denoted with the <strong class="bold">[Lazy]</strong> attribute. If, for some reason, routes are not denoted with <strong class="bold">[Lazy]</strong>, chances are that they are mistakenly being imported in <code class="Code-In-Text--PACKT-">app.module.ts</code> or some other component.</p>
    <div class="packt_tip">
      <p>In your router tree, you may notice that <code class="Code-In-Text--PACKT-">ProfileComponent</code> and <code class="Code-In-Text--PACKT-">LogoutComponent</code> are eagerly loaded, whereas the <code class="Code-In-Text--PACKT-">UserModule</code> is correctly labeled as <strong class="bold">[Lazy]</strong>. Even multiple visual inspections through the tooling and the codebase may leave you searching for the culprit. However, if you run a global search for <code class="Code-In-Text--PACKT-">UserModule</code>, you'll quickly discover that it was being imported into <code class="Code-In-Text--PACKT-">app.module.ts</code>. When running CLI commands, your module may inadvertently get re-imported into <code class="Code-In-Text--PACKT-">app.module.ts</code>, so keep an eye out for this!</p>
    </div>
    <p class="normal">To be on the safe side, inspect your <code class="Code-In-Text--PACKT-">app.module.ts</code> file and be sure to remove any import statements for modules or components that are not at the root level. Your file should look <a id="_idIndexMarker714"/>like the following one:</p>
    <pre class="programlisting"><code class="hljs coffeescript"><strong>src/app/app.<span class="hljs-built_in">module</span>.ts</strong>
<span class="hljs-keyword">import</span> { HttpClientModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>
<span class="hljs-keyword">import</span> { NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { FlexLayoutModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/flex-layout'</span>
<span class="hljs-keyword">import</span> { BrowserModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>
<span class="hljs-keyword">import</span> { 
  BrowserAnimationsModule 
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser/ animations'</span>
<span class="hljs-keyword">import</span> { AppRoutingModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app-routing.module'</span>
<span class="hljs-keyword">import</span> { AppComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.component'</span>
<span class="hljs-keyword">import</span> { HomeComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./home/home.component'</span>
<span class="hljs-keyword">import</span> { MaterialModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./material.module'</span>
<span class="hljs-keyword">import</span> { 
  PageNotFoundComponent 
} <span class="hljs-keyword">from</span> <span class="hljs-string">'./page-not-found/page-not-found.component'</span> 
@NgModule({
  declarations: [AppComponent, HomeComponent, PageNotFoundComponent],
  imports: [
    BrowserModule,
    AppRoutingModule,
    BrowserAnimationsModule,
    MaterialModule,
    HttpClientModule,
    FlexLayoutModule,
  ],
  providers: [],
  bootstrap: [AppComponent],
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> {}</span>
</code></pre>
    <div class="packt_tip">
      <p>If you disabled Ivy while debugging your routes with Augury, now's the time to re-enable it.</p>
    </div>
    <p class="normal">It is expected that the reader resolves any testing errors before moving on. Ensure that <code class="Code-In-Text--PACKT-">npm test</code> and <code class="Code-In-Text--PACKT-">npm run e2e</code> execute without errors.</p>
    <h1 class="title" id="_idParaDest-265">Common testing module</h1>
    <p class="normal">Now that we <a id="_idIndexMarker715"/>have a lot of modules to deal with, it becomes tedious to configure the imports and providers for each spec file individually. For this purpose, I recommend creating a common testing module to contain generic configuration that you can reuse across the board.</p>
    <p class="normal">First start <a id="_idIndexMarker716"/>by creating a new <code class="Code-In-Text--PACKT-">.ts</code> file</p>
    <ol>
      <li class="list" value="1">Create <code class="Code-In-Text--PACKT-">common/common.testing.ts</code>.</li>
      <li class="list">Populate it with common testing providers, fakes, and modules.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">I have provided fake implementations of <code class="Code-In-Text--PACKT-">ObservableMedia</code>, <code class="Code-In-Text--PACKT-">MatIconRegistry</code>, and <code class="Code-In-Text--PACKT-">DomSanitizer</code>, along with arrays for <code class="Code-In-Text--PACKT-">commonTestingProviders</code> and <code class="Code-In-Text--PACKT-">commonTestingModules</code>:</p>
        <pre class="programlisting"><code class="hljs typescript"><strong>src/app/common/common.testing.ts</strong>
<span class="hljs-keyword">import</span> { 
  HttpClientTestingModule 
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http/ testing'</span>
<span class="hljs-keyword">import</span> { SecurityContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { MediaChange } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/flex-layout'</span>
<span class="hljs-keyword">import</span> { ReactiveFormsModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>
<span class="hljs-keyword">import</span> { 
  SafeResourceUrl, 
  SafeValue 
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span> 
<span class="hljs-keyword">import</span> { 
  NoopAnimationsModule 
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser/animations'</span> 
<span class="hljs-keyword">import</span> { RouterTestingModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router/testing'</span>
<span class="hljs-keyword">import</span> { Observable, Subscription, of } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>
<span class="hljs-keyword">import</span> { MaterialModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'../material.module'</span>
<span class="hljs-keyword">const</span> FAKE_SVGS = {
  lemon: <span class="hljs-string">'&lt;svg&gt;&lt;path id="lemon" name="lemon"&gt;&lt;/path&gt;&lt;/svg&gt;'</span>,
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MediaObserverFake {
  isActive(query: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }
  asObservable(): Observable&lt;MediaChange&gt; {
    <span class="hljs-keyword">return</span> of({} <span class="hljs-keyword">as</span> MediaChange)
  }
  subscribe(
    next?: <span class="hljs-function">(<span class="hljs-params">value: MediaChange</span>) =&gt;</span> <span class="hljs-built_in">void</span>,
    error?: <span class="hljs-function">(<span class="hljs-params">error: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>,
    complete?: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">void</span>
  ): Subscription {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Subscription()
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MatIconRegistryFake {
  <span class="hljs-comment">// tslint:disable-next-line: variable-name</span>
  _document = <span class="hljs-built_in">document</span>
  addSvgIcon(iconName: <span class="hljs-built_in">string</span>, url: SafeResourceUrl): <span class="hljs-keyword">this</span> {
    <span class="hljs-comment">// this.addSvgIcon('lemon', 'lemon.svg')</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
  }
  getNamedSvgIcon(name: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">namespace</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>): Observable&lt;SVGElement&gt; {
    <span class="hljs-keyword">return</span> of(<span class="hljs-keyword">this</span>._svgElementFromString(FAKE_SVGS.lemon))
  }
  <span class="hljs-keyword">private</span> _svgElementFromString(str: <span class="hljs-built_in">string</span>): SVGElement {
    <span class="hljs-keyword">const</span> div = (<span class="hljs-keyword">this</span>._document || <span class="hljs-built_in">document</span>)
      . createElement(<span class="hljs-string">'DIV'</span>) 
    div.innerHTML = str
    <span class="hljs-keyword">const</span> svg = div.querySelector(<span class="hljs-string">'svg'</span>) <span class="hljs-keyword">as</span> SVGElement
    <span class="hljs-keyword">if</span> (!svg) {
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'&lt;svg&gt; tag not found'</span>)
    }
    <span class="hljs-keyword">return</span> svg
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> DomSanitizerFake {
  bypassSecurityTrustResourceUrl(url: <span class="hljs-built_in">string</span>): SafeResourceUrl {
    <span class="hljs-keyword">return</span> {} <span class="hljs-keyword">as</span> SafeResourceUrl
  }
  sanitize(
    context: SecurityContext, 
    value: SafeValue | <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>): 
      <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> 
  { 
    <span class="hljs-keyword">return</span> value?.toString() || <span class="hljs-literal">null</span>
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> commonTestingProviders: <span class="hljs-built_in">any</span>[] = [
  <span class="hljs-comment">// Intentionally Left Blank!!!</span>
]
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> commonTestingModules: <span class="hljs-built_in">any</span>[] = [
  ReactiveFormsModule,
  MaterialModule,
  NoopAnimationsModule,
  HttpClientTestingModule,
  RouterTestingModule,
]
</code></pre>
      </li>
    </ol>
    <p class="normal">Now let's see <a id="_idIndexMarker717"/>a sample use of this shared configuration file:</p>
    <pre class="programlisting"><code class="hljs groovy"><strong>src<span class="hljs-regexp">/app/</span>app.component.spec.ts</strong>
<span class="hljs-keyword">import</span> { MediaObserver } from <span class="hljs-string">'@angular/flex-layout'</span>
<span class="hljs-keyword">import</span> { MatIconRegistry } from <span class="hljs-string">'@angular/material/icon'</span>
<span class="hljs-keyword">import</span> { DomSanitizer } from <span class="hljs-string">'@angular/platform-browser'</span>
...
<span class="hljs-keyword">import</span> {
  DomSanitizerFake,
  MatIconRegistryFake,
  MediaObserverFake,
  commonTestingModules,
} from <span class="hljs-string">'./common/common.testing'</span>
...
  TestBed.configureTestingModule({
<span class="hljs-symbol">    imports:</span> commonTestingModules,
<span class="hljs-symbol">    providers:</span> commonTestingProviders.concat([
      { <span class="hljs-string">provide:</span> MediaObserver, <span class="hljs-string">useClass:</span> MediaObserverFake },
      { <span class="hljs-string">provide:</span> MatIconRegistry, <span class="hljs-string">useClass:</span> MatIconRegistryFake },
      { <span class="hljs-string">provide:</span> DomSanitizer, <span class="hljs-string">useClass:</span> DomSanitizerFake },
    ]),
<span class="hljs-symbol">    declarations:</span> [AppComponent],
...
</code></pre>
    <p class="normal">Most other modules will just need <code class="Code-In-Text--PACKT-">commonTestingModules</code> to be imported.</p>
    <div class="packt_tip">
      <p>Stop! Did you ensure all your unit tests are passing? To ensure that your tests are always passing implement a CI pipeline in CircleCI, as demonstrated in <em class="italics">Chapter 4</em>, <em class="italics">Automated Testing, CI, and Releasing to Production</em>.</p>
    </div>
    <p class="normal">With your tests <a id="_idIndexMarker718"/>up and running, the walking skeleton for LemonMart is completed. Now, let's look ahead and start thinking about what kinds of data entities we might be working with.</p>
    <h1 class="title" id="_idParaDest-266">Designing around major data entities</h1>
    <p class="normal">The fourth step in router-first architecture is achieving a stateless, data-driven design. To achieve this, it helps a <a id="_idIndexMarker719"/>lot to organize your APIs around major data components. This will roughly match how you consume data in various components in your Angular application. We will start off by defining our major data components <a id="_idIndexMarker720"/>by creating a rough data <strong class="bold">entity relationship diagram</strong> (<strong class="bold">ERD</strong>). In <em class="italics">Chapter 10</em>, <em class="italics">RESTful APIs and Full-Stack Implementation</em>, we will design and implement an API for the user data entity using Swagger.io and Express.js.</p>
    <h2 class="title" id="_idParaDest-267">Defining entities</h2>
    <p class="normal">Let's start by <a id="_idIndexMarker721"/>taking a stab at what kind of entities you would like to store and how these entities might relate to one another.</p>
    <p class="normal">Here's a sample design for LemonMart, created using <a href="http://draw.io"><span class="url">draw.io</span></a>:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_28.png"/></figure>
    <p class="packt_figref">Figure 7.28: ERD for LemonMart</p>
    <div class="note">
      <p class="Information-Box--PACKT-">At this moment, whether your entities are stored in a SQL or NoSQL database is inconsequential. My suggestion is to stick to what you know, but if you're starting from scratch, a NoSQL database like MongoDB will offer the most flexibility as your implementation and requirements evolve.</p>
    </div>
    <p class="normal">Generally speaking, you will <a id="_idIndexMarker722"/>need CRUD APIs for each entity. Considering these data elements, we can also imagine some user interfaces around these CRUD APIs. Let's do that next.</p>
    <h1 class="title" id="_idParaDest-268">High-level UX design</h1>
    <p class="normal">Mock-ups are important in determining what kind of components and user controls we will need <a id="_idIndexMarker723"/>throughout the app. Any user control or component that will be used across components will need to be defined at the root level and others scoped with their own modules.</p>
    <p class="normal">Earlier in this chapter, we identified the sub modules and designed landing pages for them to complete the walking skeleton. Now that we have defined the major data components, we can complete mock-ups for the rest of the app. When designing screens at a high level, keep several things in mind:</p>
    <ul>
      <li class="list">Can a user complete common tasks required for their role with as little navigation as possible?</li>
      <li class="list">Can users readily access all information and functionality of the app through visible elements on the screen?</li>
      <li class="list">Can a user <a id="_idIndexMarker724"/>search for the data they need easily?</li>
      <li class="list">Once a user finds a record of interest, can they drill down into detail records or view related records with ease?</li>
      <li class="list">Is that pop-up alert really necessary? You know users won't read it, right?</li>
    </ul>
    <p class="normal">Keep in mind that there's no one right way to design any user experience, which is why when designing screens, you should always keep modularity and reusability in mind.</p>
    <h2 class="title" id="_idParaDest-269">Creating an artifacts Wiki</h2>
    <p class="normal">As mentioned earlier in the chapter, it is important to document every artifact you create. Wikis offer a <a id="_idIndexMarker725"/>way to create living documentation that can be collaboratively updated or edited. While Slack, Teams, email, and whiteboards offer good collaboration opportunities, their ephemeral nature leaves a lot to be desired. </p>
    <p class="normal">So, as you generate various design artifacts, such as mock-ups or design decisions, take care to post them on a wiki reachable by all team members:</p>
    <ol>
      <li class="list" value="1">On GitHub, switch over to the <strong class="screen-text">Wiki</strong> tab</li>
      <li class="list">You may check out my sample wiki at <a href="https://github.com/duluca/lemon-mart/wiki"><span class="url">https://github.com/duluca/lemon-mart/wiki</span></a>, as shown:
      <figure class="mediaobject"><img alt="" src="../Images/B14094_07_29.png"/></figure>
      <p class="packt_figref">Figure 7.29: GitHub.com LemonMart wiki</p></li>
      <li class="list">When creating a wiki page, ensure that you cross-link between any other documentation available, such as <strong class="screen-text">Readme</strong></li>
      <li class="list">Note that <a id="_idIndexMarker726"/>GitHub shows subpages on the wiki under <strong class="screen-text">Pages</strong></li>
      <li class="list">However, an additional summary is helpful, such as the <strong class="screen-text">Design Artifacts</strong> section, since some people may miss the navigational element on the right</li>
      <li class="list">As you complete mock-ups, post them on the wiki</li>
    </ol>
    <p class="normal">You can see a summary view of the wiki here:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_30.png"/></figure>
    <p class="packt_figref">Figure 7.30: Summary view of LemonMart mock-ups</p>
    <p class="normal">Now that your artifacts are in a centralized place, it is accessible by all team members. They can add, edit, update, or groom the content. This way your wiki becomes useful, living documentation <a id="_idIndexMarker727"/>of the information that your team needs, as opposed to a piece of documentation you feel like you're being forced to create. Raise your hand if you've ever found yourself in that situation!</p>
    <p class="normal"><span class="mediaobject"><img alt="" src="../Images/B14094_07_002.png"/></span></p>
    <p class="normal">Next, integrate your mock-ups into your app, so you can collect early feedback from your stakeholders and test out the flow of your application.</p>
    <h2 class="title" id="_idParaDest-270">Leveraging mock-ups in your app</h2>
    <p class="normal">Place the <a id="_idIndexMarker728"/>mock-ups in the walking skeleton app so that testers can better envision the functionality that is yet to be developed. See an example of this idea in action here:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_07_31.png"/></figure>
    <p class="packt_figref">Figure 7.31: Using mock-ups in the UI to verify flow of app</p>
    <p class="normal">This will also <a id="_idIndexMarker729"/>be helpful when designing and implementing your authentication and authorization workflow. With the mock-ups completed, we can now continue the implementation of LemonMart's authentication and authorization workflow in <em class="italics">Chapter 8</em>, <em class="italics">Designing Authentication and Authorization</em>.</p>
    <h1 class="title" id="_idParaDest-271">Summary</h1>
    <p class="normal">In this chapter, you mastered how to effectively use the Angular CLI to create major Angular components and scaffolds. You became familiar with the 80-20 rule. You created the branding of your app, leveraging custom and built-in Material iconography. You learned how to debug complicated router configurations with Augury. Finally, you began building router-first apps, defining user roles early on, designing with lazy loading in mind, and nailing down a walking-skeleton navigation experience early on. We went over designing around major data entities. We also covered the importance of completing and documenting high-level UX design of our entire app so that we can properly design a great conditional navigation experience.</p>
    <p class="normal">To recap, in order to pull off a router-first implementation, you need to do this:</p>
    <ol>
      <li class="list">Develop a roadmap and scope</li>
      <li class="list">Design with lazy loading in mind</li>
      <li class="list">Implement a walking-skeleton navigation experience</li>
      <li class="list">Achieve a stateless, data-driven design</li>
      <li class="list">Enforce a decoupled component architecture</li>
      <li class="list">Differentiate between user controls and components</li>
      <li class="list">Maximize code reuse with TypeScript and ES6</li>
    </ol>
    <p class="normal">In this chapter, you executed steps 1-3; in the next four chapters, you will execute steps 4-7. In <em class="italics">Chapter 8</em>, <em class="italics">Designing Authentication and Authorization</em>, we will tap into OOP design and inheritance and abstraction, along with a deep dive into security considerations and designing a conditional navigation experience. In <em class="italics">Chapter 10</em>, <em class="italics">RESTful APIs and Full-Stack Implementation</em>, you will see a concrete full-stack implementation using the Minimal MEAN stack. <em class="italics">Chapter 11</em>, <em class="italics">Recipes – Reusability, Routing, and Caching</em>, and <em class="italics">Chapter 12</em>, <em class="italics">Recipes – Master/Detail, Data Tables, and NgRx</em>, we will tie everything together by sticking to a decoupled component architecture, smartly choosing between creating user controls and components, and maximizing code reuse with various TypeScript, RxJS, and Angular coding techniques.</p>
    <h1 class="title" id="_idParaDest-272">Further reading</h1>
    <ul>
      <li class="list"><em class="italics">Ha, Not Ready to Ri: The Shu Ha Ri Approach to Agile Development</em>, Brian Sjoberg, Ken Furlong, July 29, 2015, <a href="https://www.excella.com/insights/ha-not-ready-to-ri-the-shu-ha-ri-approach-to-agile-development"><span class="url">https://www.excella.com/insights/ha-not-ready-to-ri-the-shu-ha-ri-approach-to-agile-development</span></a>.</li>
      <li class="list"><em class="italics">Angular 9: Lazy Loading Components</em>, John Papa, February 16, 2020, <a href="https://johnpapa.net/angular-9-lazy-loading-components/"><span class="url">https://johnpapa.net/angular-9-lazy-loading-components/</span></a>.</li>
      <li class="list">Webpack module bundler, <a href="https://webpack.js.org/"><span class="url">https://webpack.js.org/</span></a>.</li>
    </ul>
    <h1 class="title" id="_idParaDest-273">Questions</h1>
    <p class="normal">Answer the following questions as best as you can to ensure that you've understood the key concepts from this chapter without Googling. Do you need help answering the questions? See <em class="italics">Appendix D</em>, <em class="italics">Self-Assessment Answers</em> online at <a href="https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf"><span class="url">https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf</span></a> or visit <a href="https://expertlysimple.io/angular-self-assessment"><span class="url">https://expertlysimple.io/angular-self-assessment</span></a>.</p>
    <ol>
      <li class="list">What is the Pareto principle?</li>
      <li class="list">What are the main goals of router-first architecture?</li>
      <li class="list">What is the difference between the root module and a feature module?</li>
      <li class="list">What are the benefits of lazy loading?</li>
      <li class="list">Why create a walking skeleton of your application?</li>
    </ol>
  </div>
</body></html>