- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Server-Side Rendering
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: The next step in building React applications is learning how **server-side rendering**
    (**SSR**) works and what benefits it can give us. By implementing SSR, we can
    create **universal applications** that are better for **search engine optimization**
    (**SEO**) and enable knowledge-sharing between the frontend and the backend. They
    can also improve the perceived speed of a web application, which usually leads
    to increased conversions. However, applying SSR to a React application comes at
    a cost, and we should think carefully about whether we need it or not.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 React 应用程序的下一步是学习服务器端渲染（**SSR**）是如何工作的以及它能够给我们带来什么好处。通过实现 SSR，我们可以创建对搜索引擎优化（**SEO**）更有利的**通用应用**，并使前端和后端之间的知识共享成为可能。它们还可以提高网络应用的感知速度，这通常会导致转化率的提高。然而，将
    SSR 应用于 React 应用程序是有代价的，我们应该仔细考虑我们是否真的需要它。
- en: In this chapter, you will see how to set up a server-side-rendered application,
    and by the end of the relevant sections, you will be able to build a universal
    application and understand the pros and cons of the technique.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解如何设置服务器端渲染应用，并在相关章节的末尾，您将能够构建一个通用应用并理解该技术的优缺点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding what a universal application is
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解通用应用是什么
- en: Figuring out the reasons why we may want to enable SSR
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找出我们为什么可能想要启用 SSR 的原因
- en: Creating a simple static server-side-rendered application with React
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React 创建一个简单的静态服务器端渲染应用
- en: Adding data fetching to server-side rendering and understanding concepts such
    as dehydration/hydration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端渲染中添加数据获取，并理解脱水和再水合等概念
- en: Using **Next.js** by Zeit to easily create a React application that runs on
    both the server and the client
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Zeit 的 **Next.js** 轻松创建一个在服务器和客户端上运行的反应式应用
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will require the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，您需要以下内容：
- en: Node.js 19+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 19+
- en: Visual Studio Code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: You can find the code for this chapter in the book’s GitHub repository at [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fouth-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fouth-Edition/tree/main/Chapter12).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的 GitHub 仓库中找到本章的代码：[https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fouth-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fouth-Edition/tree/main/Chapter12)。
- en: Understanding universal applications
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解通用应用
- en: A universal application is an application that can run both on the server side
    and client side with the same code. In this section, we will look at the reasons
    why we should consider making our applications universal, and we will learn how
    React components can be easily rendered on the server side.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通用应用是一种可以在服务器端和客户端以相同代码运行的应用。在本节中，我们将探讨为什么我们应该考虑使我们的应用通用，以及我们将学习 React 组件如何轻松地在服务器端渲染。
- en: When we talk about JavaScript web applications, we usually think of client-side
    code that lives in the browser. The way they usually work is that the server returns
    an empty HTML page with a script tag to load the application. When the application
    is ready, it manipulates the DOM inside the browser to show the UI and interact
    with users. This has been the case for the last few years, and it is still the
    way to go for a huge number of applications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论 JavaScript 网络应用时，我们通常想到的是存在于浏览器中的客户端代码。它们通常的工作方式是服务器返回一个带有 script 标签的空
    HTML 页面，用于加载应用。当应用准备就绪时，它会在浏览器内部操作 DOM 来显示 UI 并与用户交互。这种情况在过去几年中一直如此，并且对于大量应用来说，这仍然是一种可行的方式。
- en: In this book, we have seen how easy it is to create applications using React
    components and how they work within the browser. What we have not seen yet is
    how React can render the same components on the server, giving us a powerful feature
    called SSR.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们已经看到使用 React 组件创建应用是多么容易，以及它们在浏览器中的工作方式。我们还没有看到的是 React 如何在服务器上渲染相同的组件，这为我们提供了一个强大的功能，称为
    SSR。
- en: 'Before going into the details, let’s try to understand what it means to create
    applications that render both on the server and the client. For years, we used
    to have completely different applications for the server and client: for example,
    a Django application to render the views on the server, and some JavaScript frameworks,
    such as Backbone or jQuery, on the client. Those separate apps usually had to
    be maintained by two teams of developers with different skill sets. If you needed
    to share data between the server-side-rendered pages and the client-side application,
    you could inject some variables into a script tag. Using two different languages
    and platforms, there was no way to share common information, such as models or
    views, between the different sides of the application.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，让我们尝试理解创建既在服务器端又在客户端渲染的应用程序意味着什么。多年来，我们通常为服务器和客户端使用完全不同的应用程序：例如，使用 Django
    应用程序在服务器上渲染视图，以及在客户端使用一些 JavaScript 框架，如 Backbone 或 jQuery。这些单独的应用程序通常需要由两个不同技能集的开发团队维护。如果你需要在服务器端渲染的页面和客户端应用程序之间共享数据，你可以在一个脚本标签中注入一些变量。使用两种不同的语言和平台，无法在应用程序的不同部分之间共享常见信息，如模型或视图。
- en: Since Node.js was released in 2009, JavaScript has gained a lot of attention
    and popularity on the server side as well, thanks to web application frameworks
    such as **Express**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Node.js 在 2009 年发布以来，JavaScript 由于像 **Express** 这样的网络应用程序框架，在服务器端也获得了大量的关注和流行。
- en: Using the same language on both sides not only makes it easy for developers
    to reuse their knowledge but also enables different ways of sharing code between
    the server and the client.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在两边使用相同的语言不仅使开发者更容易重用他们的知识，而且还使服务器和客户端之间共享代码的不同方式成为可能。
- en: With React in particular, the concept of isomorphic web applications became
    very popular within the JavaScript community. Writing an **isomorphic application**
    means building an application that looks the same on the server and the client.
    The fact that the same language is used to write the two applications means that
    a big part of the logic can be shared, which opens many possibilities. This makes
    the code base easier to reason about and avoids unnecessary duplication.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是使用 React，同构 Web 应用程序的概念在 JavaScript 社区中变得非常流行。编写一个 **同构应用程序** 意味着构建一个在服务器和客户端看起来都一样的应用程序。使用相同的语言编写这两个应用程序意味着逻辑的大部分可以共享，这开辟了许多可能性。这使得代码库更容易推理，并避免了不必要的重复。
- en: React brings the concept a step forward, giving us a simple API to render our
    components on the server and transparently applying all the logic needed to make
    the page interactive (for example, event handlers) on the browser.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: React 将这一概念推进了一步，为我们提供了一个简单的 API，可以在服务器上渲染我们的组件，并且透明地应用所有使页面交互所需的逻辑（例如，事件处理器）在浏览器上。
- en: 'The term *isomorphic* does not fit in this scenario because, in the case of
    React, the applications are the same, and that is why one of the creators of React
    Router, Michael Jackson, proposed a more meaningful name for this pattern: **universal**.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *isomorphic* 在这个场景中不适用，因为在这种情况下，React 的应用程序是相同的，这就是为什么 React Router 的一个创造者
    Michael Jackson 提出了一个更有意义的名称：**通用**。
- en: Before we delve into the specific reasons for implementing universal server-side
    rendering, let us take a moment to pause and ensure that we possess a solid understanding
    of when and why this feature might be necessary for our application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨实现通用服务器端渲染的具体原因之前，让我们暂停一下，确保我们有一个坚实的理解，即何时以及为什么这个功能可能对我们应用程序来说是必要的。
- en: Reasons for implementing SSR
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 SSR 的原因
- en: SSR is a great feature, but we should not jump into it just for the sake of
    it. We should have a real, solid reason to start using it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SSR 是一个很棒的功能，但我们不应该仅仅为了使用它而盲目地跳进去。我们应该有一个真实、明确的原因来开始使用它。
- en: Adopting SSR without a clear purpose can introduce unwarranted complexities
    and issues into your application. The intricacies of SSR can complicate aspects
    such as managing states, data fetching, and routing, among others. Additionally,
    SSR puts an increased load on the server as it is responsible for rendering HTML
    for each request. If not carefully optimized, this can result in slower response
    times and higher server costs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 没有明确目的的 SSR 可能会引入不必要的复杂性和问题到你的应用程序中。SSR 的复杂性可能会使诸如状态管理、数据获取和路由等方面变得复杂。此外，SSR
    会增加服务器的负载，因为它负责为每个请求渲染 HTML。如果不仔细优化，这可能会导致响应时间变慢和更高的服务器成本。
- en: Moreover, the added complexity that SSR brings to an application can slow down
    the development process, complicate debugging, and require maintenance of specific
    tools and configurations. Furthermore, if your application does not have a significant
    amount of public content, the SEO benefits that often drive the adoption of SSR
    may not be substantial.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，SSR（服务器端渲染）给应用程序带来的额外复杂性可能会减缓开发过程，使调试复杂化，并需要维护特定的工具和配置。此外，如果你的应用程序没有大量的公共内容，SSR通常推动其采用的SEO好处可能并不显著。
- en: In essence, while SSR can offer benefits, it is crucial to implement it with
    a clear understanding of its trade-offs. Carefully assess your application’s needs
    and consider the advantages against the potential disadvantages before deciding
    to adopt SSR.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，虽然SSR可以提供好处，但关键是要清楚地了解其权衡。在决定采用SSR之前，仔细评估应用程序的需求，并权衡其优势与潜在的不利因素。
- en: Implementing SEO
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施SEO
- en: One of the main reasons why we may want to render our applications on the server
    side is SEO. If we serve an empty HTML skeleton to the crawlers of the main search
    engines, they are not able to extract any meaningful information from it. Nowadays,
    Google seems to be able to run JavaScript, but there are some limitations, and
    SEO is often a critical aspect of our businesses.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要在服务器端渲染应用程序的主要原因之一是SEO。如果我们向主要搜索引擎的爬虫提供空的HTML骨架，它们将无法从中提取任何有意义的信息。如今，Google似乎能够运行JavaScript，但有一些限制，SEO通常是我们的业务的关键方面。
- en: 'For years, we used to write two applications: an SSR one for the crawlers,
    and another one to be used on the client side by users. We used to do that because
    SSR applications could not give us the level of interactivity users expect, while
    client-side applications did not get indexed by search engines.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，我们通常编写两个应用程序：一个用于爬虫的SSR应用程序，另一个用于用户在客户端使用。我们之所以这样做，是因为SSR应用程序无法提供用户期望的交互性水平，而客户端应用程序则不会被搜索引擎索引。
- en: Maintaining and supporting two applications is difficult and makes the code
    base less flexible and less prone to changes. Luckily, with React, we can render
    our components on the server side and serve the content of our applications to
    the crawlers in such a way that it is easy for them to understand and index the
    content.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 维护和支持两个应用程序是困难的，这使得代码库变得不那么灵活，也不太容易改变。幸运的是，随着React的出现，我们可以在服务器端渲染我们的组件，并以一种易于爬虫理解和索引内容的方式向爬虫提供我们应用程序的内容。
- en: This is great, not only for SEO but also for social sharing services. Platforms
    such as Facebook or Twitter give us a way of defining the content of the snippets
    that is shown when our pages are shared.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于SEO和社交分享服务来说都是非常好的。例如，Facebook或Twitter等平台为我们提供了一种定义当我们的页面被分享时显示的内容片段的方法。
- en: For example, using Open Graph, we can tell Facebook that, for a particular page,
    we want a certain image to be shown and a particular title to be used as the title
    of the post. It is almost impossible to do that using client-side-only applications
    because the engine that extracts the information from the pages uses the markup
    returned by the server.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用Open Graph，我们可以告诉Facebook，对于特定的页面，我们希望显示特定的图像，并使用特定的标题作为帖子的标题。仅使用客户端应用程序几乎不可能做到这一点，因为从页面中提取信息的引擎使用的是服务器返回的标记。
- en: If our server returns an empty HTML structure for all the URLs, the result is
    that when the pages are shared on social networks, the snippets of our web application
    are empty as well, which affects their virality.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的服务器为所有URL返回空的HTML结构，结果是当页面在社交网络上分享时，我们的Web应用程序的片段也是空的，这影响了它们的传播性。
- en: A common code base
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享的代码库
- en: Utilizing JavaScript on both the client and server sides of an application offers
    numerous benefits. Firstly, it simplifies matters by employing the same language
    across all components. This streamlines the process of maintaining a well-functioning
    system and facilitates knowledge sharing among colleagues within the company.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的客户端和服务器端使用JavaScript提供了许多好处。首先，它通过在所有组件中使用相同的语言来简化问题。这简化了维护一个良好运行的系统的过程，并促进了公司内部同事之间的知识共享。
- en: Moreover, sharing code between the frontend and backend of a website eliminates
    the need for redundant efforts. As a result, this approach generally reduces the
    occurrence of mistakes and issues.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在网站的前端和后端之间共享代码消除了重复工作的需要。因此，这种方法通常减少了错误和问题的发生。
- en: Furthermore, maintaining a single code base is more manageable compared to handling
    two separate ones. Additionally, incorporating JavaScript on the server side enhances
    collaboration between frontend and backend developers. By leveraging the same
    language, they can efficiently reuse code and make prompt decisions, thereby enhancing
    workflow and productivity.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，维护单个代码库比处理两个独立的代码库更容易管理。此外，在服务器端集成JavaScript可以增强前端和后端开发者之间的协作。通过利用相同的语言，他们可以有效地重用代码并迅速做出决策，从而提高工作流程和生产力。
- en: Better performance
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的性能
- en: Last but not least, we all love client-side applications because they are fast
    and responsive, but there is a problem—the bundle has to be loaded and run before
    users can take any action on the application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们都喜欢客户端应用程序，因为它们快速且响应灵敏，但存在一个问题——用户在可以对应用程序采取任何行动之前，必须先加载和运行捆绑包。
- en: This might not be a problem using a modern laptop or a desktop computer with
    a fast internet connection. However, if we load a huge JavaScript bundle using
    a mobile device with a 3G connection, users have to wait for a little while before
    interacting with the application. This is not only bad for the UX in general but
    it also affects conversions. It has been proven by major e-commerce websites that
    a few milliseconds added to the page load can have an enormous impact on revenues.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能在使用现代笔记本电脑或具有快速互联网连接的台式计算机上不是问题。然而，如果我们使用3G连接的移动设备加载一个巨大的JavaScript捆绑包，用户在与应用程序交互之前必须等待一段时间。这不仅对用户体验总体上不利，还影响转化率。大型电子商务网站已经证明，页面加载时增加的几毫秒可能会对收入产生巨大影响。
- en: For example, if we serve our application with an empty HTML page and a script
    tag on the server and we show a spinner to our users until they can click on anything,
    the perception of the speed of the website is significantly affected.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们通过服务器提供我们的应用程序，一个空的HTML页面和一个脚本标签，并且我们向用户显示一个旋转器，直到他们可以点击任何东西，那么网站速度的感知将受到显著影响。
- en: If we render our website on the server side instead and users start seeing some
    of the content as soon as they hit the page, they are more likely to stay, even
    if they have to wait the same amount of time before doing anything for real, because
    the client-side bundle has to be loaded regardless of the SSR.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在服务器端渲染我们的网站，并且用户在点击页面后立即看到一些内容，那么他们更有可能留下来，即使他们必须等待相同的时间才能真正做任何事情，因为客户端捆绑包必须加载，无论是否使用SSR。
- en: This perceived performance is something we can improve greatly using SSR because
    we can output our components on the server and return some information to users
    straight away.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种感知的性能是我们可以通过SSR（服务器端渲染）大幅提升的，因为我们可以在服务器上输出我们的组件，并立即向用户返回一些信息。
- en: Don’t underestimate the complexity of SSR
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要低估SSR的复杂性
- en: Even though React provides an easy API to render components on the server, creating
    a universal application has a cost. So, we should consider carefully before enabling
    it for one of the preceding reasons and check whether our team is ready to support
    and maintain a universal application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管React提供了一个简单的API来在服务器上渲染组件，但创建一个通用应用程序是有成本的。因此，在考虑启用它之前，我们应该仔细考虑上述原因，并检查我们的团队是否准备好支持和维护一个通用应用程序。
- en: SSR can incur additional costs, extending development time and adding complexity.
    It also increases the server load, potentially necessitating costlier infrastructure.
    Operationally, SSR requires a well-maintained server with a complete setup, leading
    to increased operational costs. Additionally, testing may become more time-consuming
    due to the heightened complexity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: SSR可能会产生额外的成本，延长开发时间并增加复杂性。它还增加了服务器负载，可能需要更昂贵的硬件基础设施。在运营方面，SSR需要一个维护良好的服务器和完整的设置，从而导致运营成本增加。此外，由于复杂性增加，测试可能变得更加耗时。
- en: It is crucial to strike a balance between these costs and the potential benefits
    of SSR, such as improved SEO and faster initial page loads.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些成本和SSR（服务器端渲染）的潜在好处之间取得平衡至关重要，例如提高SEO（搜索引擎优化）和加快初始页面加载速度。
- en: As we progress through the upcoming sections, we will discover that rendering
    components is not the sole task involved in creating server-side-rendered applications.
    We must establish and maintain a server with its routes and logic, manage the
    server data flow, and perform various other essential tasks to sustain a fully
    functional universal application. Consider caching content to serve pages more
    efficiently and address other necessary responsibilities.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入即将到来的章节，我们将发现，在创建服务器端渲染应用的过程中，渲染组件并不是唯一需要完成的任务。我们必须建立并维护一个服务器，包括其路由和逻辑，管理服务器数据流，并执行各种其他必要任务，以维持一个完全功能化的通用应用。考虑缓存内容以提高页面服务效率，并处理其他必要的责任。
- en: Therefore, my recommendation is to initially focus on constructing the client-side
    version of your web application. Once it is fully functional and performs well
    on the server, you can then consider incorporating SSR to enhance the user experience.
    It is essential to enable SSR only when genuinely required. For instance, if improving
    your website’s visibility in search engines (SEO) is a priority, that is when
    you should begin contemplating the implementation of SSR.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我的建议是首先专注于构建你Web应用程序的客户端版本。一旦它在服务器上完全功能化并且表现良好，你就可以考虑将SSR纳入其中，以提升用户体验。只有在真正需要时才启用SSR至关重要。例如，如果你的网站在搜索引擎中的可见性（SEO）是一个优先事项，那么你应该开始考虑实施SSR。
- en: If you realize that your application takes a lot of time to load fully and you
    have already done all the optimization (refer to *Chapter 16*, *Improving the
    Performance of Your Applications*, for more on this topic), you can consider using
    SSR to offer a better experience to your users and improve the perceived speed.
    Now that we have learned what SSR is and the benefits of universal applications,
    let’s jump into some basic examples of SSR in our next section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你意识到你的应用程序加载时间很长，并且你已经做了所有的优化（有关此主题的更多信息，请参阅第16章，*提高应用程序的性能*），你可以考虑使用SSR为用户提供更好的体验并提高感知速度。现在我们已经学习了SSR是什么以及通用应用程序的好处，让我们在下一节中跳入一些基本的SSR示例。
- en: Creating a basic example of SSR
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的SSR示例
- en: We will now create a very simple server-side application to look at the steps
    that are needed to build a basic universal setup. It is going to be a minimal
    and simple setup on purpose because the goal here is to show how SSR works rather
    than providing a comprehensive solution or a boilerplate, even though you could
    use the example application as a starting point for a real-world application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个非常简单的服务器端应用程序，以查看构建基本通用设置所需的步骤。故意保持这种最小化和简单的设置，因为这里的目的是展示SSR是如何工作的，而不是提供一个全面的解决方案或模板，尽管你可以将示例应用程序作为实际应用的起点。
- en: This section assumes that readers have a basic understanding of Node.js and
    are familiar with the concepts related to JavaScript build tools, such as **webpack**
    and its loaders.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本节假设读者对Node.js有基本的了解，并且熟悉与JavaScript构建工具相关的概念，例如**webpack**及其加载器。
- en: 'The application will consist of two parts:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将包含两个部分：
- en: On the server side, where we will use Express to create a basic web server and
    serve an HTML page with the server-side-rendered React application.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端，我们将使用Express创建一个基本的Web服务器，并使用服务器端渲染的React应用程序提供HTML页面。
- en: On the client side, where we will render the application, as usual, using `react-dom`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端，我们将像往常一样使用`react-dom`来渲染应用程序。
- en: Configuring our project from scratch with webpack
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从零开始配置我们的项目使用webpack
- en: Both sides of the application will be transpiled with Babel and bundled with
    webpack before being run, which will let us use the full power of ES6 and the
    modules both on Node.js and on the browser.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行之前，应用程序的两侧都将使用Babel进行转译，并使用webpack进行打包，这将使我们能够在Node.js和浏览器上使用ES6的全部功能和模块。
- en: 'Let’s start by creating a new project folder (you can call it `ssr-project`)
    and running the following command to create a new package:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的项目文件夹（你可以称之为`ssr-project`）并运行以下命令来创建一个新的包开始：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once `package.json` is created, it is time to install the dependencies. We
    can start with webpack:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了`package.json`，就是安装依赖的时候了。我们可以从webpack开始：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After this is done, it is time to install `ts-loader` and the presets that
    we need to write an ES6 application using React and TSX:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，就是安装`ts-loader`和我们需要使用React和TSX编写ES6应用程序所需的预设的时候了：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to create the server bundle, we need to install a dependency. Webpack
    allows us to define a set of externals, which are dependencies that we do not
    want to include in the bundle. When generating a build for the server, it is preferable
    not to include all the `Node.js` packages used; instead, we only want to bundle
    our server code. Excluding dependencies from the server bundle offers several
    advantages, including reduced bundle size, faster compilation, and compatibility
    with the Node.js environment. By leveraging the native module system of Node.js,
    the server code can directly access the installed packages without the need for
    bundling. Tools like `webpack-node-externals` assist in defining these dependencies
    as externals in the webpack configuration, resulting in an optimized server bundle
    and a streamlined build process. Let’s proceed with the installation of this tool:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建服务器包，我们需要安装一个依赖项。Webpack 允许我们定义一组 externals，这些是我们不想包含在包中的依赖项。当为服务器生成构建时，最好不包含所有使用的
    `Node.js` 包；相反，我们只想打包我们的服务器代码。从服务器包中排除依赖项提供了几个优点，包括减少包大小、加快编译速度以及与 Node.js 环境的兼容性。通过利用
    Node.js 的原生模块系统，服务器代码可以直接访问已安装的包，而无需打包。像 `webpack-node-externals` 这样的工具有助于在 webpack
    配置中将这些依赖项定义为 externals，从而实现优化的服务器包和简化的构建过程。让我们继续安装这个工具：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Great. It is now time to create an entry in the npm scripts section of `package.json`
    so that we can easily run the `build` command from the terminal:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了。现在是时候在 `package.json` 的 npm 脚本部分创建一个条目，这样我们就可以轻松地从终端运行 `build` 命令了：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, you need to create a `.babelrc` file in your root path:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在你的根路径下创建一个 `.babelrc` 文件：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We now have to create the configuration file, called `webpack.config.js`, to
    tell webpack how we want our files to be bundled.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要创建一个配置文件，称为 `webpack.config.js`，以告诉 webpack 我们希望如何打包我们的文件。
- en: 'Let’s start by importing the library we will use to set our node externals.
    We will also define the configuration for `ts-loader`, which we will use for both
    the client and the server:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入我们将用来设置我们的 node externals 的库。我们还将为 `ts-loader` 定义配置，我们将使用它来为客户端和服务器：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In *Chapter 6*, *Making Your Components Look Beautiful*, we looked at how we
    had to export a configuration object from the configuration file. There is one
    cool feature in webpack that lets us export an array of configurations as well
    so that we can define both client and server configurations in the same place
    and use both in one go.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 6 章*，*让你的组件看起来很漂亮* 中，我们探讨了如何从配置文件中导出一个配置对象。Webpack 有一个很酷的功能，允许我们导出一个配置数组，这样我们就可以在同一个地方定义客户端和服务器配置，并且一次使用两者。
- en: 'The client configuration shown in the following block should be very familiar:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块中显示的客户端配置应该非常熟悉：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are telling webpack that the source code of the client application is inside
    the `src` folder, and we want the output bundle to be generated in the `dist`
    folder.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在告诉 webpack 客户端应用程序的源代码位于 `src` 文件夹中，并且我们希望输出包生成在 `dist` 文件夹中。
- en: 'We also set the module loaders using the previous object we created with `ts-loader`.
    The server configuration is slightly different; we need to define a different
    entry, and add some new nodes, such as `target`, `externals`, and `resolve`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用之前创建的带有 `ts-loader` 的对象设置了模块加载器。服务器配置略有不同；我们需要定义一个不同的入口，并添加一些新节点，例如 `target`、`externals`
    和 `resolve`：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, `entry`, `output`, and `module` are the same, except for the
    filenames.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`entry`、`output` 和 `module` 都是相同的，除了文件名不同。
- en: The new parameters are the target, where we specify the node to tell webpack
    to ignore all the built-in system packages of Node.js, such as `fs`, and `externals`,
    where we use the library we imported earlier to tell webpack to ignore the dependencies.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 新参数是目标，我们指定节点告诉 webpack 忽略 Node.js 的所有内置系统包，例如 `fs`，以及 `externals`，我们使用之前导入的库告诉
    webpack 忽略依赖项。
- en: 'Last but not least, we have to export the configurations as an array:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们必须将配置作为一个数组导出：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The configuration is done. We are now ready to write some code, and we will
    start with the React application, which we are more familiar with.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 配置已完成。我们现在可以编写一些代码了，我们将从我们更熟悉的 React 应用程序开始。
- en: Creating the application
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: Let’s create an `src` folder and an `app.ts` file inside it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 `src` 文件夹，并在其中创建一个 `app.ts` 文件。
- en: 'The `app.ts` file should have the following content:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.ts` 文件应该包含以下内容：'
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Nothing complex here; we import React, create an `App` component, which renders
    the `Hello React` message, and export it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有复杂的内容；我们导入React，创建一个`App`组件，它渲染`Hello React`消息，并将其导出。
- en: 'Let’s now create `client.tsx`, which is responsible for rendering the `App`
    component inside the DOM:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建`client.tsx`，它负责在DOM中渲染`App`组件：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, this should sound familiar, since we import React, ReactDOM, and the
    `App` component we created earlier, and we use ReactDOM to render it in a DOM
    element with the app ID.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这应该听起来很熟悉，因为我们导入了React、ReactDOM以及我们之前创建的`App`组件，并使用ReactDOM在具有应用程序ID的DOM元素中渲染它。
- en: Let’s now move to the server.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到服务器。
- en: 'The first thing to do is to create a `template.ts` file, which exports a function
    that we will use to return the markup of the page that our server will give back
    to the browser:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首件事是创建一个`template.ts`文件，它导出一个函数，我们将使用它来返回服务器将返回给浏览器的页面标记：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It should be pretty straightforward. The function accepts `body`, which we will
    later see contains the React app, and it returns the skeleton of the page.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该相当直接。该函数接受`body`，我们稍后将看到它包含React应用程序，并返回页面的骨架。
- en: It is worth noting that we load the bundle on the client side even if the app
    is rendered on the server side. SSR is only half of the job that React does to
    render our application. We still want our application to be a client-side application,
    with all the features we can use in the browser, such as event handlers, for example.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，即使应用程序在服务器端渲染，我们也会在客户端加载捆绑包。SSR只是React渲染我们的应用程序所做工作的一半。我们仍然希望我们的应用程序是一个客户端应用程序，具有我们可以在浏览器中使用的所有功能，例如事件处理器等。
- en: 'After this, you need to install `express`, `react`, and `react-dom`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要安装`express`、`react`和`react-dom`：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now it is time to create `server.tsx`, which has more dependencies and is worth
    exploring in detail:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建`server.tsx`了，它有更多的依赖项，值得详细探索：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first thing that we import is `express`, the library that allows us to create
    a web server with some routes easily, and which is also able to serve static files.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入的是`express`，这是一个库，它允许我们轻松创建带有一些路由的Web服务器，并且还能够提供静态文件。
- en: Secondly, we import React and ReactDOM to render `App`, which we import as well.
    Notice the `/server` path in the `import` statement of ReactDOM. The last thing
    we import is the template we defined earlier.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们导入React和ReactDOM来渲染`App`，我们也导入它。注意ReactDOM导入语句中的`/server`路径。最后我们导入的是我们之前定义的模板。
- en: 'Now we create an Express application:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个Express应用程序：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We tell the application where our static assets are stored:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉应用程序我们的静态资源存储在哪里：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you may have noticed, the path is the same that we used in the client configuration
    of webpack as the output destination of the client bundle.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，路径与我们用于webpack客户端配置中的客户端包输出目标相同。
- en: 'Then, here comes the logic of SSR with React:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，接下来是使用React的SSR逻辑：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are telling Express that we want to listen to the `/` route, and when it
    gets hit by a client, we render `App` to a string using the ReactDOM library.
    Here comes the magic and simplicity of the SSR of React.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉Express我们想要监听`/`路由，当客户端击中它时，我们使用ReactDOM库将`App`渲染为一个字符串。这就是React SSR的神奇和简单之处。
- en: What `renderToString` does is return a string representation of the DOM elements
    generated by our `App` component, the same tree that it would render in the DOM
    if we were using the ReactDOM `render` method.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderToString`所做的就是返回由我们的`App`组件生成的DOM元素的字符串表示，这与如果使用ReactDOM的`render`方法在DOM中渲染的相同树。'
- en: 'The value of the `body` variable is something like the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`body`变量的值可能如下所示：'
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, it represents what we defined in the `render` method of `App`,
    except for a couple of data attributes that React uses on the client to attach
    the client-side application to the server-side-rendered string.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它代表我们在`App`的`render`方法中定义的内容，除了React在客户端使用的一些数据属性，用于将客户端应用程序附加到服务器端渲染的字符串。
- en: Now that we have the SSR representation of our app, we can use the `template`
    function to apply it to the HTML template and send it back to the browser within
    the Express response.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们应用程序的SSR表示，我们可以使用`template`函数将其应用于HTML模板，并在Express响应中将其发送回浏览器。
- en: 'Last but not least, we have to start the Express application:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们必须启动Express应用程序：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are now ready to go; there are only a few operations left. The first one
    is to define the start script of npm and set it to run the node server:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备就绪；只剩下几个操作。第一个是定义 npm 的启动脚本并将其设置为运行节点服务器：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The scripts are ready, so we can first build the application with the following
    command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本已经准备好了，所以我们可以首先使用以下命令构建应用程序：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the bundles are created, we can run the following command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建捆绑包时，我们可以运行以下命令：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Point the browser to `http://localhost:3000` and see the result.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将浏览器指向`http://localhost:3000`并查看结果。
- en: There are two important things to note here. First, when we use the **View Page
    Source** feature of the browser, we can see the source code of the application
    being rendered and returned from the server, which we would not see if SSR was
    not enabled.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个需要注意的重要事项。首先，当我们使用浏览器的**查看页面源代码**功能时，我们可以看到应用程序被渲染并从服务器返回的源代码，如果我们没有启用
    SSR，我们就看不到这些代码。
- en: Second, if we open DevTools and we have the React extension installed, we can
    see that the `App` component has been booted on the client as well.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，如果我们打开 DevTools 并且安装了 React 扩展，我们可以看到`App`组件已经在客户端启动了。
- en: 'The following screenshot shows the source of the page:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了页面的源代码：
- en: '![Graphical user interface, text, application, website  Description automatically
    generated](img/B18414_12_01.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，网站  自动生成的描述](img/B18414_12_01.png)'
- en: 'Figure 12.1: Source code page'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：源代码页面
- en: Great! Now that you have created your first React application using SSR, let’s
    learn how to fetch data in the next section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你已经使用 SSR 创建了你的第一个 React 应用程序，让我们在下一节学习如何获取数据。
- en: Implementing data fetching
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现数据获取
- en: The example in the previous section should clearly explain how to set up a universal
    application in React. It is pretty straightforward, and the main focus is on getting
    things done. However, in a real-world application, we will likely want to load
    some data instead of a static React component, such as `App` in the example.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的示例应该清楚地解释如何在 React 中设置一个通用应用程序。这相当直接，主要关注的是完成任务。然而，在实际应用中，我们可能更希望加载一些数据，而不是像示例中的`App`这样的静态
    React 组件。
- en: Let’s assume, for example, we want to load Dan Abramov’s gists on the server
    and return the list of items from the Express app we just created.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想在服务器上加载 Dan Abramov 的`gists`，并从我们刚刚创建的 Express 应用程序返回项目列表。
- en: In the data fetching examples in *Chapter 12*, *Managing Data*, we looked at
    how we can use `useEffect` to fire the data loading. That wouldn’t work on the
    server because components do not get mounted on the DOM and the life cycle Hook
    never gets fired.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 12 章*，*管理数据*的数据获取示例中，我们探讨了如何使用`useEffect`来触发数据加载。在服务器上这不会起作用，因为组件不会在 DOM
    上挂载，生命周期 Hook 也永远不会被触发。
- en: Using Hooks that were executed earlier will not work either because the data
    fetching operation is async, while `renderToString` is not. For that reason, we
    have to find a way to load the data beforehand and pass it to the component as
    props.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前执行过的 Hooks 也不会起作用，因为数据获取操作是异步的，而`renderToString`不是。因此，我们必须找到一种方法在之前加载数据，并将其作为
    props 传递给组件。
- en: Let’s look at how we can take the application from the previous section and
    change it a bit to make it load gists during the SSR phase.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将上一节中的应用程序稍作修改，使其在 SSR 阶段加载`gists`。
- en: 'The first thing to do is to change **App.tsx** to accept a list of `gists`
    as `props`, and loop through it in the `render` method to display their descriptions:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首件事是将**App.tsx**修改为接受一个`gists`列表作为`props`，并在`render`方法中遍历它以显示它们的描述：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Applying the concept that we learned in the previous chapter, we define a stateless
    functional component, which receives `gists` as `props` and loops through the
    elements to render a list of items. Now, we have to change the server to retrieve
    `gists` and pass them to the component.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 应用我们在上一章中学到的概念，我们定义一个无状态的函数组件，它接收`gists`作为`props`并遍历元素以渲染项目列表。现在，我们必须更改服务器以检索`gists`并将它们传递给组件。
- en: 'To use the `fetch` API on the server side, we have to install a library called
    `isomorphic-fetch`, which implements the fetch standards. It can be used in Node.js
    and the browser:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要在服务器端使用`fetch` API，我们必须安装一个名为`isomorphic-fetch`的库，该库实现了 fetch 标准。它可以在 Node.js
    和浏览器中使用：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We first import the library into `server.tsx`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将库导入到`server.tsx`中：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The API call that we want to make looks as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要进行的 API 调用如下所示：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, gists are available to be used inside the last `then` function. In our
    case, we want to pass them down to `App`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`gists` 可用于在最后一个 `then` 函数内部使用。在我们的情况下，我们希望将它们传递给 `App`。
- en: 'Therefore, we can change the `/` route as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将 `/` 路由修改如下：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we first fetch `gists`, and then we render `App` as a string, passing
    the property.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先获取 `gists`，然后以字符串的形式渲染 `App`，并传递属性。
- en: Once `App` is rendered and we have its markup, we use the template we used in
    the previous section and return it to the browser.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `App` 被渲染并且我们有了它的标记，我们就使用上一节中使用的模板，并将其返回给浏览器。
- en: 'Run the following command in the console and point the browser to `http://localhost:3000`.
    You should be able to see a `server-side render` list of `gists`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中运行以下命令，并将浏览器指向 `http://localhost:3000`。你应该能够看到一个 `server-side render` 的
    `gists` 列表：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To make sure that the list is rendered from the Express app, you can navigate
    to `view-source:http://localhost:3000` and you will see the markup and the descriptions
    of gists.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保列表是从 Express 应用程序渲染的，你可以导航到 `view-source:http://localhost:3000`，你将看到标记和
    `gists` 的描述。
- en: That is great, and it looks easy, but if we check the DevTools console, we can
    see `Cannot read property 'map' of undefined error`. The reason we see the error
    is that, on the client, we are rendering `App` again, but without passing `gists`
    to it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，看起来也很简单，但如果我们检查 DevTools 控制台，我们可以看到 `Cannot read property 'map' of undefined
    error`。我们看到错误的原因是在客户端，我们再次渲染 `App`，但没有将 `gists` 传递给它。
- en: This could sound counter-intuitive in the beginning because we might think that
    React is smart enough to use `gists` rendered within the server-side string on
    the client. But that is not what happens, so we have to find a way to make `gists`
    available on the client side as well.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这在开始时可能听起来有些反直觉，因为我们可能认为 React 足够智能，可以在客户端使用服务器端字符串中渲染的 `gists`。但这并不是实际情况，因此我们必须找到一种方法，使
    `gists` 也可以在客户端使用。
- en: You may consider that you could execute the fetch again on the client. That
    would work, but it is not optimal because you would end up firing two HTTP calls,
    one on the Express server and one in the browser. If we think about it, we already
    made the call on the server, and we have all the data we need. A typical solution
    to sharing data between the server and the client is dehydrating the data in the
    HTML markup and hydrating it back in the browser.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会考虑在客户端再次执行 `fetch`。这也可以工作，但不是最优的，因为你最终会触发两个 HTTP 请求，一个在 Express 服务器上，一个在浏览器中。如果我们仔细想想，我们已经在服务器上执行了调用，并且我们已经拥有了所有需要的数据。在服务器和客户端之间共享数据的一个典型解决方案是在
    HTML 标记中解冻数据，并在浏览器中重新解冻它。
- en: This seems like a complex concept, but it is not. We will now look at how easy
    it is to implement. The first thing we must do is inject `gists` into the template
    after we have fetched them on the client.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个复杂的概念，但实际上并不复杂。我们现在将看看如何轻松实现。我们必须做的第一件事是在客户端获取 `gists` 之后，将它们注入到模板中。
- en: 'To do this, we have to change the template slightly, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须稍微修改一下模板，如下所示：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `template` function now accepts two parameters—the `body` of the app and
    the collection of `gists`. The first one is inserted into the `app` element, while
    the second is used to define a global `gists` variable attached to the `window`
    object so that we can use it in the client.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`template` 函数现在接受两个参数——应用的 `body` 和 `gists` 集合。第一个参数被插入到 `app` 元素中，而第二个参数用于定义一个全局的
    `gists` 变量，并将其附加到 `window` 对象上，这样我们就可以在客户端使用它。'
- en: 'Inside the Express route (`server.ts`), we just have to change the line where
    we generate the template passing the body, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Express 路由（`server.ts`）内部，我们只需更改生成模板时传递 `body` 的那一行，如下所示：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Last but not least, we have to use gists attached to a window inside **client.tsx**,
    which is pretty easy:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们必须在 `client.tsx` 文件中，使用附加到窗口上的 `gists`，这相当简单：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The hydrate method was introduced in React 16 and works similarly to `render`
    on the client side, irrespective of whether the HTML has server-side-rendered
    markup or not. If there is no markup previously using SSR, then the `hydrate`
    method will fire a warning, which you can silence by using the new `suppressHydrationWarning`
    attribute.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`hydrate` 方法是在 React 16 中引入的，它在客户端与 `render` 方法的工作方式相似，无论 HTML 是否有服务器端渲染的标记。如果没有使用
    SSR 的标记，那么 `hydrate` 方法将触发一个警告，你可以通过使用新的 `suppressHydrationWarning` 属性来忽略这个警告。'
- en: We read `gists` directly, and we pass them to the `App` component that gets
    rendered on the client.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接读取 `gists`，并将它们传递给在客户端渲染的 `App` 组件。
- en: 'Now, run the following command again:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行以下命令：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If we point the browser window to `http://localhost:3000`, the error is gone,
    and if we inspect the `App` component using React DevTools, we can see how the
    client-side `App` component receives the collection of gists.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将浏览器窗口指向`http://localhost:3000`，错误就会消失，如果我们使用React DevTools检查`App`组件，我们可以看到客户端的`App`组件是如何接收gists集合的。
- en: As we have created our first SSR application, let’s now see how we can do this
    more easily by using an SSR framework called Next.js in the next section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经创建了第一个SSR应用程序，那么现在让我们看看如何通过在下一节中使用一个名为Next.js的SSR框架来更容易地做到这一点。
- en: Using Next.js to create a React application
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Next.js创建React应用程序
- en: You have looked at the basics of SSR with React, and you can use the project
    we created as a starting point for a real app. However, you may think that there
    is too much boilerplate and that you are required to know about too many different
    tools to run a simple universal application with React. This is a common feeling
    called **JavaScript fatigue**, as described in the introduction to this book.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了使用React的SSR基础知识，并且可以使用我们创建的项目作为真实应用程序的起点。然而，你可能认为有太多的样板代码，并且需要了解太多不同的工具才能运行一个简单的通用应用程序。这是一种常见的感受，称为**JavaScript疲劳**，正如本书引言中所描述的。
- en: Luckily, Meta developers and other companies in the React community are working
    very hard to improve the DX and make the lives of developers easier. You might
    have used `create-react-app` at this point to try out the examples in the previous
    chapters, and you should understand how it makes it very simple to create React
    applications without requiring developers to learn about many technologies and
    tools.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Meta的开发者和React社区中的其他公司正在非常努力地改进开发体验（DX），使开发者的生活更加轻松。你可能已经使用过`create-react-app`来尝试前几章中的示例，你应该理解它如何使创建React应用程序变得非常简单，而不需要开发者学习许多技术和工具。
- en: Now, `create-react-app` does not support SSR yet, but there’s a company called
    **Vercel** that has created a tool called **Next.js**, which makes it incredibly
    easy to generate universal applications without worrying about configuration files.
    It also reduces the boilerplate a lot.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`create-react-app`还不支持SSR，但有一家公司叫做**Vercel**，它创建了一个名为**Next.js**的工具，这使得生成通用应用程序变得非常容易，无需担心配置文件。它还大大减少了样板代码。
- en: It is important to say that using abstractions is always very good for building
    applications quickly. However, it is crucial to know how the internals work before
    adding too many layers, and that is why we started with the manual process before
    learning Next.js. We have looked at how SSR works and how we can pass the state
    from the server to the client. Now that the base concepts are clear, we can move
    on to a tool that hides a little bit of complexity and makes us write less code
    to achieve the same results.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要说明，使用抽象来快速构建应用程序总是非常好的。然而，在添加太多层之前了解内部工作原理是至关重要的，这就是为什么我们在学习Next.js之前先从手动过程开始。我们已经研究了SSR的工作原理以及如何从服务器将状态传递到客户端。现在，基础概念已经清晰，我们可以继续使用一个稍微隐藏一些复杂性的工具，这样我们就可以用更少的代码实现相同的结果。
- en: We will create the same app where all gists from Dan Abramov are loaded, and
    you will see how clean and simple the code is, thanks to Next.js.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个相同的应用程序，其中加载了Dan Abramov的所有gists，你将看到代码是如何干净且简单的，这要归功于Next.js。
- en: 'First of all, create a new project folder (you can call it `next-project`)
    and run the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的项目文件夹（你可以称它为`next-project`），并运行以下命令：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When this is done, we can install the Next.js library and React:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当这一切完成时，我们可以安装Next.js库和React：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that the project is created, we have to add an npm script to run the binary:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目已经创建，我们必须添加一个npm脚本来运行二进制文件：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Perfect! It is now time to generate our `App` component. Next.js is based on
    conventions, with the most important one being that you can create pages to match
    the browser URLs. The default page is `index`, so we can create a folder called
    `pages` and put an `index.js` file inside it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在是我们生成`App`组件的时候了。Next.js基于约定，其中最重要的一个约定是你可以创建与浏览器URL匹配的页面。默认页面是`index`，因此我们可以创建一个名为`pages`的文件夹，并在其中放置一个`index.js`文件。
- en: 'We start importing the dependencies:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始导入依赖项：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Again, we import `isomorphic-fetch` because we want to be able to use the `fetch`
    function on the server side.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们导入`isomorphic-fetch`，因为我们想能够在服务器端使用`fetch`函数。
- en: 'We then define a component called `App`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义一个名为`App`的组件：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Then we define a static async function, called `getInitialProps`, which is where
    we tell Next.js which data we want to load, both on the server side and on the
    client side. The library will make the object returned from the function available
    as props inside the component.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义一个静态异步函数，称为 `getInitialProps`，这是我们告诉 Next.js 我们想要加载哪些数据，无论是在服务器端还是在客户端。该库将函数返回的对象作为组件内部的
    props 提供。
- en: The `stati`c and `async` keywords applied to a class method mean that the function
    can be accessed outside the instance of the class and that the function yields
    the execution of the `wait` instructions inside its body.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `stati`c 和 `async` 关键字应用于类方法意味着该函数可以在类的实例外部访问，并且该函数在其主体内部产生 `wait` 指令的执行。
- en: These concepts are pretty advanced, and they are not part of the scope of this
    chapter, but if you are interested in them, you should check out the ECMAScript
    proposals ([https://github.com/tc39/proposals](https://github.com/tc39/proposals)).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念相当高级，它们不属于本章的范围，但如果您对它们感兴趣，您应该查看 ECMAScript 提案 ([https://github.com/tc39/proposals](https://github.com/tc39/proposals))。
- en: 'The implementation of the method we just described is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才描述的方法的实现如下：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We are telling the function to fire the `fetch` and wait for the response, then
    we are transforming the response into JSON, which returns a promise. When the
    promise is resolved, we can return the `props` object with `gists`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在告诉函数触发 `fetch` 并等待响应，然后我们将响应转换为 JSON，它返回一个承诺。当承诺解决时，我们可以返回带有 `gists` 的 `props`
    对象。
- en: 'The render of the component looks pretty similar to the preceding one:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的渲染看起来与上一个非常相似：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Before you run the project, you need to configure `tsconfig.json`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行项目之前，您需要配置 `tsconfig.json`：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, open the console and run the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开控制台并运行以下命令：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We will see the following output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下输出：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If we point the browser to that URL, we can see the universal application in
    action. It is really impressive how easy it is to set up a universal application
    with a few lines of code and zero configuration, thanks to Next.js.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将浏览器指向该 URL，我们可以看到通用应用程序的实际运行情况。使用 Next.js 几行代码和零配置设置通用应用程序真是太容易了，这真的很令人印象深刻。
- en: You may also notice that if you edit the application inside your editor, you
    will be able to see the results within the browser instantly without needing to
    refresh the page. That is another feature of Next.js, which enables hot module
    replacement. It is incredibly useful in development mode.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会注意到，如果您在编辑器中编辑应用程序，您将能够立即在浏览器中看到结果，而无需刷新页面。这是 Next.js 的另一个特性，它实现了热模块替换。这在开发模式下非常有用。
- en: 'If you liked this chapter, go and give it a star on GitHub: [https://github.com/zeit/next.js](https://github.com/zeit/next.js).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢这一章，请在 GitHub 上给它点个赞：[https://github.com/zeit/next.js](https://github.com/zeit/next.js)。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The journey through SSR has come to an end. You are now able to create a server-side-rendered
    application with React, and it should be clear why it can be useful for you. SEO
    is certainly one of the main reasons, but social sharing and performance are important
    factors as well. You learned how it is possible to load the data on the server
    and dehydrate it in the HTML template to make it available to the client-side
    application when it boots on the browser.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染的旅程已经结束。现在您可以使用 React 创建服务器端渲染的应用程序，并且应该清楚为什么这对您来说很有用。SEO 当然是主要原因之一，但社交分享和性能也是重要因素。您学习了如何在服务器上加载数据并在
    HTML 模板中使其脱水，以便在浏览器启动时提供给客户端应用程序。
- en: Finally, you looked at how tools such as Next.js can help you reduce the boilerplate
    and hide some of the complexity that setting up a server-side-rendered React application
    usually brings to the code base.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您了解了如何使用 Next.js 等工具来减少样板代码并隐藏设置服务器端渲染的 React 应用程序通常带来的某些复杂性。
- en: In the next chapter, we will talk about how to improve the performance of our
    React applications.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何提高我们的 React 应用程序的性能。
- en: Join our community on Discord
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/React18DesignPatterns4e](https://packt.link/React18DesignPatterns4e)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/React18DesignPatterns4e](https://packt.link/React18DesignPatterns4e)'
- en: '![](img/QR_Code2450023176943770109.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2450023176943770109.png)'
