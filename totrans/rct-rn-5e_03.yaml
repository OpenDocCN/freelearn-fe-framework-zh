- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rendering with JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce you to **JSX**, which is the XML/HTML markup syntax
    that’s embedded in your JavaScript code and used to declare your React components.
    At the lowest level, you’ll use HTML markup to describe the pieces of your UI.
    Building React applications involves organizing these pieces of HTML markup into
    components. In React, creating a component allows you to define custom elements
    that extend beyond basic HTML markup. These custom elements, or components, are
    defined using JSX, which then translates them into standard HTML elements for
    the browser. This ability to create and reuse custom components is a core feature
    of React, enabling more dynamic and complex UIs. This is where React gets interesting
    – having your own JSX tags that can use JavaScript expressions to bring your components
    to life. JSX is the language used to describe UIs built using React.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Your first JSX content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own JSX elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JavaScript expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building fragments of JSX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in the following directory of the accompanying
    GitHub repository: [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter02](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: Your first JSX content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll implement the obligatory `Hello World` JSX application.
    This initial dive is just the beginning – it’s a simple yet effective way to get
    acquainted with the syntax and its capabilities. As we progress, we’ll delve into
    more complex and nuanced examples, demonstrating the power and flexibility of
    JSX in building React applications. We’ll also discuss what makes this syntax
    work well for declarative UI structures.
  prefs: []
  type: TYPE_NORMAL
- en: Hello JSX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Without further ado, here’s your first JSX application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through what’s happening here.
  prefs: []
  type: TYPE_NORMAL
- en: The `render()` function takes JSX as an argument and renders it to the DOM node
    passed to `ReactDOM.createRoot()`.
  prefs: []
  type: TYPE_NORMAL
- en: The actual JSX content in this example renders a paragraph with some bold text
    inside. There’s nothing fancy going on here, so we could have just inserted this
    markup into the DOM directly as a plain string. However, the aim of this example
    is to show the basic steps involved in getting JSX rendered onto the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood, JSX is not directly understood by web browsers and needs to
    be transformed into standard JavaScript code that browsers can execute. This transformation
    is typically done using a tool like **Vite** or **Babel**. When Vite processes
    JSX code, it compiles the JSX down to `React.createElement()` calls. These calls
    create JavaScript objects that represent the virtual DOM elements. For example,
    the JSX expression in the example above is compiled into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first argument to `React.createElement` is the type of the element (such
    as a string like `div` or `p` for DOM elements, or a React component for composite
    components). The second argument is an object containing the props for this element,
    and any subsequent arguments are the children of this element. This transformation
    is done by Vite under the hood, and you never write such code.
  prefs: []
  type: TYPE_NORMAL
- en: These objects created by `React.createElement()`, known as **React elements**,
    describe the structure and properties of a UI component in an object format that
    React can work with. React then uses these objects to construct the actual DOM
    and keep it up to date. This process involves a reconciliation algorithm that
    efficiently updates the DOM to match the React elements. When the state of a component
    changes, React calculates the minimal set of changes required to update the DOM,
    rather than re-rendering the entire component. This makes updates much more efficient
    and is one of the key advantages of using React.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move forward with more in-depth code examples, let’s take a moment
    to reflect on our `Hello World` example. The JSX content was short and simple.
    It was also declarative because it described *what* to render, not *how* to render
    it. Specifically, by looking at the JSX, you can see that this component will
    render a paragraph and some bold text within it. If this were done imperatively,
    there would probably be some more steps involved, and they would probably need
    to be performed in a specific order.
  prefs: []
  type: TYPE_NORMAL
- en: The example we just implemented should give you a feel for what declarative
    React is all about. As we move forward in this chapter and throughout the book,
    the JSX markup will grow more elaborate. However, it’s always going to describe
    what is in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: The `render()` function tells React to take your JSX markup and update the UI
    in the most efficient way possible. This is how React enables you to declare the
    structure of your UI without having to think about carrying out ordered steps
    to update elements on the screen, an approach that often leads to bugs. Out of
    the box, React supports the standard HTML tags that you would find on any HTML
    page, such as `div`, `p`, `h1`, `ul`, `li`, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discovered what JSX is, how it works, and what declarative
    idea it follows, let’s explore how we can render plain HTML markup and what conventions
    we should follow.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of the day, the job of a React component is to render HTML in the
    DOM browser. This is why JSX has support for HTML tags out of the box. In this
    section, we’ll look at some code that renders a few of the available HTML tags.
    Then, we’ll cover some of the conventions that are typically followed in React
    projects when HTML tags are used.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in HTML tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we render JSX, element tags reference React components. Since it would
    be tedious to have to create components for HTML elements, React comes with HTML
    components. We can render any HTML tag in our JSX, and the output will be just
    as we’d expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s try rendering some of these tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Don’t worry about the formatting of the rendered output for this example. We’re
    making sure that we can render arbitrary HTML tags, and they render as expected,
    without any special definitions and imports.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed the surrounding `<div>` tag, grouping together all of the
    other tags as its children. This is because React needs a root element to render.
    Later in the chapter, you’ll learn how to render adjacent elements without wrapping
    them in a parent element.
  prefs: []
  type: TYPE_NORMAL
- en: HTML elements rendered using JSX closely follow regular HTML element syntax,
    with a few subtle differences regarding case-sensitivity and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: HTML tag conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you render HTML tags in JSX markup, the expectation is that you’ll use
    lowercase for the tag name. In fact, capitalizing the name of an HTML tag will
    fail. Tag names are case-sensitive and non-HTML elements are capitalized. This
    way, it’s easy to scan the markup and spot the built-in HTML elements versus everything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pass HTML elements any of their standard properties. When you
    pass them something unexpected, a warning about the unknown property is logged.
    Here’s an example that illustrates these ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When you run this example, it will fail to compile because React doesn’t know
    about the `<Button>` element; it only knows about `<button>`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use any valid HTML tags as JSX tags, as long as you remember that they’re
    case-sensitive and that you need to pass the correct attribute names. In addition
    to simple HTML tags that only have attribute values, you can use more semantic
    HTML tags to describe the structure of your page content.
  prefs: []
  type: TYPE_NORMAL
- en: Describing UI structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSX is capable of describing screen elements in a way that ties them together
    to form a complete UI structure. Let’s look at some JSX markup that declares a
    more elaborate structure than a single paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This JSX markup describes a fairly sophisticated UI structure. Yet, it’s easier
    to read than imperative code because it’s HTML, and HTML is good for concisely
    expressing a hierarchical structure. This is how we want to think of our UI when
    it needs to change – not as an individual element or property but the UI as a
    whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the rendered content looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Describing HTML tag structures using JSX syntax'
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of semantic elements in this markup describing the structure
    of the UI. For example, the `<header>` element describes the top part of the page
    where the title is, and the `<main>` element describes where the main page content
    goes. This type of complex structure makes it clearer for developers to reason
    about. But before we start implementing dynamic JSX markup, let’s create some
    of our own JSX components.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own JSX elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components are the fundamental building blocks of React. In fact, they can be
    thought of as the vocabulary of JSX markup, allowing you to create complex interfaces
    through reusable, encapsulated elements. In this section, we’ll delve into how
    to create your own components and encapsulate HTML markup within them.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We create new JSX elements so that we can encapsulate larger structures. This
    means that instead of having to type out complex markup, you can use your custom
    tag. The React component returns the JSX that goes where the tag is used. Let’s
    look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what the rendered output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: A component rendering encapsulated HTML markup'
  prefs: []
  type: TYPE_NORMAL
- en: This is the first React component that we’ve implemented, so let’s take a moment
    to dissect what’s going on here. We created a function called `MyComponent`, in
    the return statement of which we put our HTML tags. This is how we create a React
    component that is used as a new JSX element. As you can see in the call to `render()`,
    you’re rendering a `<MyComponent>` element.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML that this component encapsulates is returned from the function we created.
    In this case, when the JSX is rendered by `react-dom`, it’s replaced by a `<section>`
    element and everything within it.
  prefs: []
  type: TYPE_NORMAL
- en: When React renders JSX, any custom elements that you use must have their corresponding
    React component within the same scope. In the preceding example, the `MyComponent`
    function was declared in the same scope as the call to `render()`, so everything
    worked as expected. Usually, you’ll import components, adding them to the appropriate
    scope. You’ll see more of this as you progress through the book.
  prefs: []
  type: TYPE_NORMAL
- en: HTML elements such as `<div>` often take nested child elements. Let’s see whether
    we can do the same with JSX elements, which we create by implementing components.
  prefs: []
  type: TYPE_NORMAL
- en: Nested elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using JSX markup is useful for describing UI structures that have parent-child
    relationships. Child elements are created by nesting them within another component:
    the parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a `<li>` tag is only valid as the child of a `<ul>` tag or a `<ol>`
    tag – you’re probably going to make similar nested structures with your own React
    components. For this, you need to use the `children` property. Let’s see how this
    works. Here’s the JSX markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You’re importing two of your own React components: `MySection` and `MyButton`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you look at the JSX markup, you’ll notice that `<MyButton>` is a child
    of `<MySection>`. You’ll also notice that the `MyButton` component accepts text
    as its child, instead of more JSX elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how these components work, starting with `MySection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This component renders a standard `<section>` HTML element, a heading, and then
    `{props.children}`. It’s this last piece that allows components to access nested
    elements or text and render them.
  prefs: []
  type: TYPE_NORMAL
- en: The two braces used in the preceding example are used for JavaScript expressions.
    I’ll touch on more details of the JavaScript expression syntax found in JSX markup
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the `MyButton` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This component uses the exact same pattern as `MySection`; it takes the `{props.children}`
    value and surrounds it with markup. React handles the details for you. In this
    example, the button text is a child of `MyButton`, which is, in turn, a child
    of `MySection`. However, the button text is transparently passed through `MySection`.
    In other words, we didn’t have to write any code in `MySection` to make sure that
    `MyButton` got its text. *Pretty cool, right?* Here’s what the rendered output
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: A button element rendered using child JSX values'
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to build your own React components that introduce new JSX tags
    in your markup. The components that we’ve looked at so far in this chapter have
    been static. That is, once we rendered them, they were never updated. JavaScript
    expressions are the dynamic pieces of JSX that give different output based on
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Using JavaScript expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in the preceding section, JSX has a special syntax that allows you
    to embed JavaScript expressions. Any time React renders JSX content, expressions
    in the markup are evaluated. This feature is at the heart of JSX’s dynamism; it
    enables the content and attributes of your components to change in response to
    different data or state conditions. Each time React renders or re-renders JSX
    content, these embedded expressions are evaluated, allowing the displayed UI to
    reflect current data and state. You’ll also learn how to map collections of data
    to JSX elements.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic property values and text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some HTML property or text values are static, meaning that they don’t change
    as JSX markup is re-rendered. Other values, the values of properties or text,
    are based on data that is found elsewhere in the application. Remember, React
    is just the view layer. Let’s look at an example so that you can get a feel for
    what the JavaScript expression syntax looks like in JSX markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Anything that is a valid JavaScript expression, including nested JSX, can go
    in between the curly braces: `{}`. For properties and text, this is often a variable
    name or object property. Notice, in this example, that the `!enabled` expression
    computes a Boolean value. Here’s what the rendered output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Dynamically changing the property value of a button'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re following along with the downloadable companion code, which I strongly
    recommend doing, try playing around with these values and seeing how the rendered
    HTML changes: [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter02](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter02)'
  prefs: []
  type: TYPE_NORMAL
- en: Primitive JavaScript values are straightforward to use in JSX syntax. Obviously,
    we can use more complex values such as objects and arrays in the JSX, as well
    as functions to handle events. Let’s explore this.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In React, you can easily pass functions to components’ properties to handle
    user interactions such as button clicks, form submissions, and mouse movements.
    This allows you to create interactive and responsive UIs. React provides a convenient
    way to attach event handlers directly to components using a syntax, similar to
    how you would use the `addEventListener` and `removeEventListener` methods in
    traditional JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, let’s consider an example where we want to handle a button-click
    event in a React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we define a function called `handleClick` that will be called
    when the button is clicked. We then attach this function as an event handler to
    the `onClick` property of the `<button>` component. Whenever the button is clicked,
    React will invoke the `handleClick` function.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to using `addEventListener` and `removeEventListener` in traditional
    JavaScript, React abstracts away some of the complexities. With React’s event
    handling, you don’t have to worry about manually attaching and detaching event
    listeners to/from DOM elements. React manages the **event delegation** and provides
    a more **declarative** approach to handling events within components.
  prefs: []
  type: TYPE_NORMAL
- en: React implements event delegation by default to optimize performance. Instead
    of attaching event handlers to each individual element, React attaches a single
    event handler to the root of the application (or a parent component). When an
    event is triggered on a child element, it bubbles up the component tree until
    it reaches the parent with the event handler. React’s synthetic event system then
    determines which component should handle the event based on the target property
    of the event object. This allows React to efficiently manage events without needing
    to attach handlers to every single element.
  prefs: []
  type: TYPE_NORMAL
- en: By using this approach, you can easily pass events to child components, handle
    them in parent components, or even propagate events through multiple levels of
    nested components. This helps in building a modular and reusable component architecture.
    We’ll get to see this in action in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `onClick` event, React supports a wide range of other events,
    such as `onChange`, `onSubmit`, `onMouseOver`, and all standard events. You can
    attach event handlers to various elements like buttons, input fields, checkboxes,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note that React promotes a unidirectional data flow, which means that data flows
    from parent components to child components. To pass data or information from child
    components back to the parent component, you can define callbacks as props and
    invoke them with the necessary data. In the upcoming chapters of this book, we
    will delve deeper into event handling in React and how to create custom callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping collections to elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you need to write JavaScript expressions that change the structure
    of your markup. In the preceding section, you learned how to use JavaScript expression
    syntax to dynamically change the property values of JSX elements. What about when
    you need to add or remove elements based on JavaScript collections?
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, when I refer to a JavaScript collection, I’m referring
    to both plain objects and arrays, or, more generally, anything that’s *iterable*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to dynamically control JSX elements is to map them from a collection.
    Let’s look at an example of how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first collection is an array called `array`, populated with string values.
    Moving down to the JSX markup, you can see the call to `array.map()`, which returns
    a new array. The mapping function actually returns a JSX element (`<li>`), meaning
    that each item in the array is now represented in the markup.
  prefs: []
  type: TYPE_NORMAL
- en: The result of evaluating this expression is an array. Don’t worry – JSX knows
    how to render arrays of elements. For enhanced performance, it is crucial to assign
    a unique `key` prop to each component within the array, enabling React to efficiently
    manage updates during subsequent re-renders.
  prefs: []
  type: TYPE_NORMAL
- en: The object collection uses the same technique, except that you have to call
    `Object.keys()` and then map this array. What’s nice about mapping collections
    to JSX elements on the page is that you can control the structure of React components
    based on the collected data.
  prefs: []
  type: TYPE_NORMAL
- en: This means that you don’t have to rely on imperative logic to control the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the rendered output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_02_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: The result of mapping JavaScript collections to HTML elements'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript expressions bring JSX content to life. React evaluates expressions
    and updates the HTML content based on what has already been rendered and what
    has changed. Understanding how to utilize these expressions is important because
    it’s one of the most common day-to-day activities of any React developer.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to learn how to group together JSX markup without relying on
    HTML tags to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Building fragments of JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fragments are a way to group together chunks of markup without having to add
    unnecessary structure to your page. For example, a common approach is to have
    a React component return content wrapped in a `<div>` element. This element serves
    no real purpose and adds clutter to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example. Here are two versions of a component. One uses a
    wrapper element, and the other uses the new fragment feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The two elements rendered are `<WithoutFragments>` and `<WithFragments>`. Here’s
    what they look like when rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_02_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Fragments help render fewer HTML tags without any visual difference'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s compare the two approaches now.
  prefs: []
  type: TYPE_NORMAL
- en: Using wrapper elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first approach is to wrap sibling elements in `<div>`. Here’s what the
    source looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The essence of this component is the `<h1>` and `<p>` tags. Yet, in order to
    return them from `render()`, you have to wrap them with `<div>`. Indeed, inspecting
    the DOM using your browser dev tools reveals that `<div>` does nothing but add
    another level of structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_02_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Another level of structure in the DOM'
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine an app with lots of these components—that’s a lot of pointless
    elements! Let’s see how to use fragments to avoid unnecessary tags.
  prefs: []
  type: TYPE_NORMAL
- en: Using fragments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at the `WithFragments` component, where we have avoided using
    unnecessary tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Instead of wrapping the component content in `<div>`, the `<>` element is used.
    This is a special type of element that indicates that only its children need to
    be rendered. The `<>` is a shorthand for `React.Fragment component`. If you need
    to pass a key property to the fragment, you can’t use `<>` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the difference compared to the `WithoutFragments` component if
    you inspect the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_02_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Less HTML in the fragment'
  prefs: []
  type: TYPE_NORMAL
- en: With the advent of fragments in JSX markup, we have less HTML rendered on the
    page because we don’t have to use tags such as `<div>` for the sole purpose of
    grouping elements together. Instead, when a component renders a fragment, React
    knows to render the fragment’s child element wherever the component is used.
  prefs: []
  type: TYPE_NORMAL
- en: So fragments enable React components to render only the essential elements;
    no more will elements that serve no purpose appear on the rendered page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the basics of JSX, including its declarative
    structure, which leads to more maintainable code. Then, you wrote some code to
    render some basic HTML and learned about describing complex structures using JSX;
    every React application has at least some structure.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you spent some time learning about extending the vocabulary of JSX markup
    by implementing your own React components, which is how you design your UI as
    a series of smaller pieces and glue them together to form the whole. Then, you
    learned how to bring dynamic content into JSX element properties and how to map
    JavaScript collections to JSX elements, eliminating the need for imperative logic
    to control the UI display. Finally, you learned how to render fragments of JSX
    content, which prevents unnecessary HTML elements from being used.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a feel for what it’s like to render UIs by embedding declarative
    XML in your JavaScript modules, it’s time to move on to the next chapter, where
    we’ll take a deeper look at components, properties, and state.
  prefs: []
  type: TYPE_NORMAL
