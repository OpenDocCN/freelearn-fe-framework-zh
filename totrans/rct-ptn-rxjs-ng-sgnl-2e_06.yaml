- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transforming Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with streams, one of the most frequent use cases you will face
    is the need to transform a stream of certain values into a stream of other values.
    That’s what this chapter is about.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter revolves around adding an autosave feature to our project that
    we will be resolving by transforming streams. We will start by explaining the
    autosave requirement that we will be implementing in the recipe app. Then, we
    will explore the imperative way of implementing this feature. After that, we will
    learn about the declarative pattern for doing it and study the most commonly used
    RxJS transformation operators for this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will delve into the different transformation operators provided
    by RxJS and their respective use cases, enriching our understanding through hands-on
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the autosave requirement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the imperative pattern for the autosave feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the declarative pattern for the autosave feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have a basic understanding of RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: For more details about Reactive forms, please refer to [https://angular.dev/guide/forms/reactive-forms](https://angular.dev/guide/forms/reactive-forms).
  prefs: []
  type: TYPE_NORMAL
- en: For demonstration purposes, we will be using a fake autosave service. Its implementation
    is available in the `recipes-book-api` module in this book’s GitHub repository.
    Note that we won’t be going through the details of this service as the focus is
    not the backend of the project.
  prefs: []
  type: TYPE_NORMAL
- en: The source code of this chapter is available at [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap06](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap06).
  prefs: []
  type: TYPE_NORMAL
- en: Defining the autosave requirement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As described in the *View 2 – The New Recipe interface* section of [*Chapter
    2*](B21180_02.xhtml#_idTextAnchor031), *Walking through Our Application*, the
    user can add a new recipe by clicking on the **New Recipe** menu item. This will
    display the following form to be filled out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The New Recipe form](img/B21180_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The New Recipe form
  prefs: []
  type: TYPE_NORMAL
- en: The standalone component that’s responsible for displaying the `RecipeCreationComponent`
    and is available under `recipes-book-front\src\app\recipe-creation`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we want to implement the autosave behavior, which consists of storing
    the user’s changes in the form automatically. In this example, we will be storing
    the form changes in the backend so that the user can retrieve the last changes
    any time after a disconnection, a timeout, or other problems – this feature improves
    the user experience by preventing data loss.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the requirement, let’s look at the imperative way to
    implement the autosave feature.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the imperative pattern for the autosave feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used Angular Reactive forms to build the `valueChanges` Observable to track
    the `FormControl` changes. This makes our implementation easier since we want
    to listen to the form’s value changes to perform a save on every change.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the HTML code of the `recipe-creation.component.html` file template.
    Then, in `recipe-creation.component.ts`, we can define the form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the Angular `FormBuilder` API to build the reactive form and pass
    to it a JSON object where we define the different fields of the form. This JSON
    object represents our recipe’s data; we’re going to save this later. Every time
    we open the **New Recipe** form, a new empty object will be created.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the first property of this JSON object, `id`, is not going to be displayed
    in the form. We only add it to initialize the new `Recipe` object with a random
    identifier to save the recipe’s data properly in the backend. The `tags` property
    is retrieved from a constant declared in `src/app/core/model/tags.ts` that represents
    the static list of available tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve prepared our form, let’s see how we can implement the autosave
    feature. The first thing that comes to mind is subscribing to the `valueChanges`
    Observable of `recipeForm` in the `ngOninit()` instance of `RecipeCreationComponent`.
    Then, every time the `valueChanges` Observable emits a new form value, we should
    raise a save request to save the most recent value of the form. We can do this
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `saveRecipe` method is then defined and implemented in `RecipeService`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `HTTPClient` API and call the save service in the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backend implementation is not the focus of this book. For that reason, we’ve
    provided a fake implementation of the POST save service in the `recipes-book-api`
    project. Here, the goal is to simulate the call to an HTTP request to save the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to recap, the code for `RecipeCreationComponent` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this code won’t work. You should know by now that the result of `this.service.saveRecipe(<Recipe>formValue)`,
    which calls ``this.http.post<Recipe>(`${BASE_PATH}/recipes`, formValue)``, is
    an Observable, and since Observables are lazy, we should subscribe to `this.service.saveRecipe(<Recipe>formValue)`
    to initiate the HTTP POST request. So, let’s add a `subscribe` value, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have noticed, we called a `subscribe` value inside another `subscribe`,
    something we call a nested subscription. However, this is considered an anti-pattern
    in RxJS and is problematic for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Every time we use `subscribe()`, we open the door to imperative code. As we
    have learned throughout this book, we should avoid this as much as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested subscriptions require careful cleanup; otherwise, we can run into various
    performance problems. In the previous example, we didn’t clean up the subscriptions,
    which means the possibility of serious timing issues arises. If multiple form
    values are emitted by `valueChanges` successively, many save requests will be
    sent in parallel. If the requests take some time to complete, there is no guarantee
    that the backend will process the save requests in order. For instance, we cannot
    ensure that the last valid form value is the one that’s been saved in the backend.
    Consequently, we will end up with data incoherence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we want to do is perform a save request after the previous one is completed.
    Luckily, RxJS includes some interesting operators that fix this for us. So, without
    further ado, in the following section, we’ll learn how to implement this in a
    reactive and declarative way.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the reactive pattern for the autosave feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You remember the golden rule from [*Chapter 5*](B21180_05.xhtml#_idTextAnchor083),
    right? We should think of everything as a stream. So, let’s start by identifying
    our streams.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can think of the save operation as a stream – it is the result of the
    `this.service.saveRecipe(<Recipe>formValue)` method, which calls ``this.http.post<Recipe>(`${BASE_PATH}/recipes`,
    formValue``. We will call it `saveRecipe$`.
  prefs: []
  type: TYPE_NORMAL
- en: The `saveRecipe$` Observable is responsible for saving the data in the backend
    and will initiate the `http` request when subscribed to.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid nesting subscriptions, what we can do in this situation is map or transform
    the form value emitted by the `valueChanges` Observable to the `saveRecipe$` Observable.
    The result is what we call a higher-order Observable.
  prefs: []
  type: TYPE_NORMAL
- en: Not clear? Don’t worry – we will explain this in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order Observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what is a higher-order Observable? A **higher-order Observable** is just
    an Observable like any other, but its values are Observables as well. So, instead
    of emitting simple values such as strings, numbers, or arrays, it emits Observables
    that you can subscribe to separately.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, but when is it useful? You can create a higher-order Observable whenever
    you use data emitted from one Observable to emit another Observable. In our case,
    for every emitted form value from the `valueChanges` Observable, we want to emit
    the `saveRecipe$` Observable. In other words, we want to transform (or map) the
    form value to the `saveRecipe$` Observable. This would create a higher-order Observable
    where each value represents a save request.
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, the `valueChanges` Observable is called the outer Observable,
    and `saveRecipe$` is called the inner Observable. Under the hood, we want to subscribe
    to each `saveRecipe$` Observable that’s emitted and receive the response all in
    one go to avoid nested treatments.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned what higher-order Observables are and when to use them,
    let’s look at higher-order mapping operators.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order mapping operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To transform the outer Observable, we should use higher-order mapping operators.
    The role of these operators is to map each value from an outer Observable to a
    new inner Observable and automatically subscribe and unsubscribe to/from that
    inner Observable.
  prefs: []
  type: TYPE_NORMAL
- en: But what is the difference between regular mapping and higher-order mapping?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, regular mapping involves mapping one value to another value. One of the
    most used basic mapping operators is the `map` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The map operator – marble diagram](img/B21180_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The map operator – marble diagram
  prefs: []
  type: TYPE_NORMAL
- en: As described in this marble diagram, the map operator will transform the values
    of the input stream by multiplying each emitted value by 10\. Here, `x=>10*x`
    is the transformation function.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, higher-order mapping is about mapping one value into an Observable.
  prefs: []
  type: TYPE_NORMAL
- en: RxJS provides several higher-order mapping operators. In the next section, we
    will learn about the `concatMap()` operator – which we will use to implement the
    autosave behavior – before discovering some other commonly used operators.
  prefs: []
  type: TYPE_NORMAL
- en: The concatMap operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`concatMap` is a combination of the concatenation strategy and higher-order
    mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '*concatMap = concat (concatenation) + map (**higher-order mapping)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We looked at the concepts of regular and higher-order mapping in the previous
    section, so let’s look at the following marble diagram to understand the concatenation
    strategy, taking the example of the `concat` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The concat operator – marble diagram](img/B21180_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – The concat operator – marble diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down the marble diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line represents the timeline of the first Observable passed as input
    to the `concat` operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line represents the timeline of the second Observable passed as input
    to the `concat` operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `concat` operator in this example has two inputs. It will subscribe to the
    first Observable but not to the second one. The first Observable will emit the
    values **a** and **b**, which get reflected in the result Observable (the last
    line).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the first Observable completes, and at that moment, the `concat` operator
    subscribes to the second Observable. This is how a sequential process is guaranteed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second Observable will emit the values **x** and **y**, which get reflected
    in the result Observable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the second Observable completes, the output Observable will also complete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you may have noticed, Observable concatenation is all about Observable completion.
    This is the key point. It emits the values of the first Observable, waits for
    it to complete, and then emits the values of the next Observable, and so on, until
    all the Observables complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand the concatenation strategy, we can understand how the
    `concatMap` operator is a mixture of higher-order mapping and Observable concatenation:
    it waits for each inner Observable to complete before processing the next one.
    It’s like a line at a ticket counter, where each customer (Observable) waits for
    their turn to be served before the next one is called.'
  prefs: []
  type: TYPE_NORMAL
- en: Using concatMap for autosaving
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Based on the previous discussion, the `concatMap` operator fits very well with
    our autosave requirement for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We want to take the form value and turn it into a `saveRecipe$` Observable and
    automatically subscribe and unsubscribe from the `saveRecipe$` inner Observable
    – this is what a higher-order mapping operation does.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We only want to perform a save request after the previous one is completed.
    When one HTTP save request is in progress, the other requests that come in the
    meantime should wait for its completion before being called to ensure sequentiality.
    So, we need to concatenate the `saveRecipe$` Observables together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is what our code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down what’s going on:'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the outer Observable, `this.recipeForm.valueChanges`, emits form values.
    For each emitted form value, `concatMap` transforms it into `this.service.saveRecipe(<Recipe>formValue)`,
    which is the `saveRecipe$` Observable – our inner Observable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`concatMap` automatically subscribes to the inner Observable and the HTTP POST
    request will be issued.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another form value might come faster than the time it takes to save the previous
    form value in the backend. In this case, the form value will not be mapped to
    the `saveRecipe$` Observable. Instead, `concatMap` will wait for the previous
    save request to return a response and complete it before transforming the new
    form value to `saveRecipe$`, subscribing to it, and sending a new save request.
    When all inner Observables complete, the result stream completes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we use the `catchError` operator to handle the errors and register a side
    effect with the `tap` operator to log the `Saved successfully` message in the
    backend. You can customize this, of course, and display a message to the end user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To recap, the complete code for `RecipeCreationComponent` will now look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, there’s just one thing left to do: we should subscribe to the `valueChanges$`
    Observable to make all of this work. As usual, we will do this through the async
    pipe in our `RecipeCreationComponent` HTML template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With that, the reactive implementation is complete.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, the first benefit of using `concatMap` is that we no
    longer have nested subscriptions. We also get rid of explicit subscriptions thanks
    to the async pipe. Besides this, all form values are going to be sent to the backend
    sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: When a delay is introduced in the backend save service (which I’ve set up by
    default in the provided implementation of the save recipe service), you’ll notice
    that requests aren’t initiated while another one is still processing. Instead,
    they wait until the current request finishes before being triggered. This is exactly
    what `concatMap` aims to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at the behavior `concatMap` manifests in the Chrome
    DevTools **Network** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The concatMap network requests](img/B21180_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – The concatMap network requests
  prefs: []
  type: TYPE_NORMAL
- en: Here, upon typing a character, a POST save request is sent to the server. When
    trying to input other characters before the initial request, a response is received.
    You’ll notice that requests are not immediately triggered; they are queued and
    executed sequentially once the preceding request is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Our example served as a straightforward illustration of how the `concatMap`
    operator works. However, we could optimize our implementation more to avoid sending
    requests for every character introduced by the user. To do so, we could use the
    `debounceTime(waitingTime)` operator to wait for the user input to stabilize before
    sending the requests. We could also optimize it further by ignoring duplicates
    and making the `distinctUntilChanged()` operator handle invalid values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more details about the `debounceTime` and `distinctUntilChanged` operators,
    refer to [https://rxjs.dev/api/operators/debounceTime](https://rxjs.dev/api/operators/debounceTime)
    and [https://rxjs.dev/api/operators/distinctUntilChanged](https://rxjs.dev/api/operators/distinctUntilChanged),
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Using concatMap for pagination
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Besides autosaving, we can also use `concatMap` for list pagination. In our
    recipe app, we handle the Recipes list pagination on the client side – we retrieve
    all the recipes when loading `RecipesListComponent` by making a `GET` request
    to the `/api/recipes` service, as explained in [*Chapter 3*](B21180_03.xhtml#_idTextAnchor047),
    *Fetching Data* *as Streams*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we were handling a lazy loading mechanism, where we fetch just
    a few items (let’s say 10) when the component loads initially, and then load more
    items as needed when the user clicks the **Next** or **Previous** buttons, as
    shown in the following screenshot, we’d need to adjust our logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Recipes list pagination](img/B21180_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Recipes list pagination
  prefs: []
  type: TYPE_NORMAL
- en: This would involve sending a `GET` HTTP request to fetch the data for the next
    page, using a URL structure such as `GET /api/recipes?page=1&limit=10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In such a scenario, `concatMap` is a very good option to issue a request for
    each emitted “next page” event, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `pageNumberChange$` is a `BehaviorSubject` subject that emits the current
    page number whenever the user clicks on the `concatMap` then triggers subsequent
    HTTP GET requests, sequentially fetching the next page’s list based on the current
    page number and size limit parameters. This sequential handling ensures data integrity
    and systematic pagination flow.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, `concatMap` is the ideal choice when you want to ensure that operations
    are processed sequentially, and that each inner Observable is processed *one at
    a time and in order*. However, when using `concatMap`, it’s important to ensure
    that the inner Observable completes since `concatMap` waits for the completion
    of each inner Observable before subscribing to the next one in the sequence. If
    an inner Observable never completes, `concatMap` will also never subscribe to
    the subsequent Observables in the sequence. This can lead to blocking subsequent
    emissions and potential memory leaks or performance issues if there is a buildup
    of pending Observables. So, never use `concatMap` for endless streams.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that not all higher-order mapping operators follow the
    `concat` strategy. There are other higher-order mapping operators, such as `switch`,
    `merge`, and `exhaust`, that offer different strategies and are useful in many
    situations. We’ll break down those operators and their respective strategies in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The switchMap operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`switchMap` is a combination of the switch and transformation (or mapping)
    strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '*switchMap = switch(switch) + map (**higher-order mapping)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the marble diagram of the `switch` operator to understand the
    switch strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – The switch operator – marble diagram](img/B21180_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – The switch operator – marble diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down what’s happening here (you are not used to seeing those diagonal
    lines, I know!):'
  prefs: []
  type: TYPE_NORMAL
- en: The top line is the higher-order Observable. The higher-order Observable emits
    the first inner Observable (which has the values **a**, **b**, **c**, and **d**).
    The switch operator subscribes to it under the hood.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first inner Observable emits the values **a** and **b**, and they get reflected
    automatically to the resulting Observable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the higher-order Observable emits the second inner Observable (which has
    the values **e**, **f**, and **g**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The switch will unsubscribe from the first inner Observable (**a**-**b**-**c**-**d**)
    and subscribe to the second inner Observable (**e**-**f**-**g**); that’s why the
    values **e**, **f**, and **g** get reflected right after **a** and **b**. As you
    may have noticed, in switching, if a new Observable starts emitting values, then
    the switch will subscribe to the new Observable and unsubscribe from the previous
    one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the `switchMap` operator is a higher-order mapping operator that unsubscribes
    from any prior inner Observable and switches to any new inner Observable. It is
    useful when you want to cancel an operation when a new one is triggered. In other
    words, `switchMap` only focuses on the most recent data, ensuring that only the
    latest updates are processed while canceling any ongoing operations triggered
    by previous data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of `switchMap` as changing TV channels: each time you press a button,
    you switch to a different channel, ignoring whatever was playing before. Similarly,
    `switchMap` lets you dynamically switch to a new Observable stream whenever the
    source emits, discarding any ongoing processing from previous emissions.'
  prefs: []
  type: TYPE_NORMAL
- en: Using switchMap for autosaving
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Going back to our autosave reactive implementation in the Recipe app, if you’re
    interested in saving the most recent form value and want to cancel any ongoing
    save operation if a new one is initiated before the current one finishes, then
    `switchMap` is the operator to use (instead of `concatMap`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned previously, I introduced a slight delay in the backend save service
    to illustrate how ongoing requests are handled when subsequent requests are made
    concurrently. So, when inspecting the network console, you’ll notice the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – The switchMap network requests](img/B21180_06_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – The switchMap network requests
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have two requests: one is marked as **canceled**, while the other
    is **pending**. The pending request is the most recent one, indicating that it
    was initiated while the previous request was still in progress, resulting in the
    cancellation of the prior request. And this is the behavior we aim for.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’re making an HTTP POST request, but we’re only interested
    in the success or failure status and don’t need any other data from the response.
    However, if you’re expecting a response from the POST request to update the UI
    or perform tasks, keep in mind that *only the response from the latest request
    will be propagated*. In such cases, it’s better to use `concatMap` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Using switchMap for autocompletion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, let’s explore another practical scenario of using `switchMap`: autocompleting
    suggestions. This is a very common feature in web applications. In our recipe
    app, we’ll implement an autocomplete dropdown for the `tags` field in `RecipeCreationComponent`.
    Currently, this field is displayed as a radio button with static values retrieved
    from the constant tags defined in `src/app/core/model/tags.ts`. However, we’ll
    transform it into a user-friendly autocomplete dropdown that dynamically fetches
    tag suggestions based on the user’s input.'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a user types a query, we’ll retrieve the corresponding tags from a
    backend service. We have already implemented a service for that in our ready-to-use
    backend – that is, `recipes-book-api`. This service has an endpoint called `/api/tags`,
    accepts some criteria (the user’s typed input) as a query parameter, and returns
    a list of tags that match the provided criteria. The code is available in this
    book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s delve into the implementation details. First and foremost, let’s prepare
    our streams. How many streams do we have? We have two:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A stream, named `searchTerms`, that emits the user’s input, represented by
    a `BehaviorSubject` subject that’s initialized with an empty string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll update this stream whenever the user’s input changes by using an `update`
    method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `searchTerms` stream and the `updateSearchTerm` method will be available
    in `RecipeCreationComponent`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A stream, named `getTags$`, that emits the fetched tags matching the user’s
    input. We’ll define this stream in `RecipesService`, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`getTags$` represents a function that takes a string parameter, `term`, and
    returns an Observable of the `Tag[]` type that issues an HTTP GET request to retrieve
    an array of `Tag` objects matching the provided search term.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We defined the `Tag` type in `\src\app\core\model\tags.ts`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it’s time to use `switchMap`, which will map each value emitted by the
    `searchTerms` stream to the `getTags$` Observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We will define `tagValues$` in `RecipeCreationComponent`. So, overall, `tagValues$`
    issues a search request for every unique user’s input and ensures only the latest
    search results are displayed, discarding previous ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will update the `RecipeCreationComponent` HTML template to modify
    how tags are displayed from a radio button to an autocomplete dropdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we subscribed to `tagValues$` using the async pipe and stored the emitted
    value in a `tags` array. Then, we used the PrimeNG autocomplete component to provide
    suggestions as the user types in the `"Tags"` input field. The autocomplete component
    binds to a form control named `"tags",` receives suggestions from the `tags` array,
    and triggers the `updateSearchTerm` method with the user’s query when the user
    starts typing. `concatMap` will issue a GET request for every unique user’s input
    and ensure only the latest search results are displayed, canceling previous requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that’s it! Here’s an illustration of the implemented behavior. Here, when
    we enter **B** in the search field, we receive **Breakfast** a suggestion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The autocompletion suggestion](img/B21180_06_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – The autocompletion suggestion
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to another operator, `mergeMap`.
  prefs: []
  type: TYPE_NORMAL
- en: The mergeMap operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`mergeMap` is a combination of the merge and transformation (or mapping) strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '*mergeMap = merge(merge) + map (**higher-order mapping)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you understand the concepts of higher-order mapping, let’s understand
    the merging strategy by looking at the following marble diagram, which considers
    the `merge` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – The merge operator – marble diagram](img/B21180_06_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – The merge operator – marble diagram
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `concat`, `merge` will not wait for an Observable to complete before
    subscribing to the next Observable. It subscribes to every inner Observable at
    the same time and then outputs the values to the combined result. As described
    in this marble diagram, the values of the input Observables are reflected in the
    output immediately. The result will only be completed once all the merged Observables
    are completed.
  prefs: []
  type: TYPE_NORMAL
- en: '`mergeMap` is a higher-order mapping operator that processes each inner Observable
    in parallel. It is like multitasking in the kitchen, where you’re simultaneously
    handling different cooking tasks, such as chopping, boiling, and mixing, all at
    once. However, you should only use `mergeMap` if the resulting order doesn’t matter
    because these requests may be processed out of order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we aim to retrieve a list of recipes that match specific tags. For
    every tag, we want to initiate an HTTP request to fetch the recipes corresponding
    to that tag. The order of tag requests is not important; all requests should be
    executed concurrently. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created an Observable named `selectedTags$` from a static array of
    tags. `selectedTags$` emits the tags (array elements) one by one. Whenever a tag
    is emitted by `selectedTags$`, an HTTP request is issued by `this.getRecipesByTag(tagName)`
    to fetch the corresponding recipes. The `mergeMap` operator is used to concurrently
    handle multiple tag requests. When another tag is emitted while the previous request
    is still in progress, the new request is executed concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `mergeAll` operator to flatten the results that were obtained from
    the different inner Observables into a single Observable stream. This ensures
    that the recipes emitted by each inner Observable are merged into a cohesive stream
    of recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `toArray` operator is used to convert all emitted recipes into
    a single array, making it convenient for a list display in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, I previously added a delay to the backend service that returns the recipes
    by tag. Upon opening the console, we’ll find that all the requests were run concurrently,
    even if there are pending ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – mergeMap’s execution](img/B21180_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – mergeMap’s execution
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `mergeMap` to fetch data from multiple sources in parallel
    and combine the results. Imagine that we have multiple Review sources for our
    recipes, and we want to collect them (in this case, the order here is not important).
    Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `getRecipesReviews(recipeId: number)` is a method that fetches reviews
    for a recipe identified by `recipeId` from two different sources (`source1` and
    `source2`) by issuing parallel HTTP GET requests to each source.'
  prefs: []
  type: TYPE_NORMAL
- en: The `from([${BASE_PATH}/source1/reviews, ${BASE_PATH}/source2/reviews])` line
    creates an Observable from an array containing two different endpoints to fetch
    reviews. The `from` operator emits each item of the array as a separate value
    in the Observable sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Then, `mergeMap` is used to raise a GET request to fetch reviews for the specified
    `recipeId` for each endpoint emitted by the `from` operator, ensuring that both
    requests are made concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: With that, let’s move on to the last operator that we will discuss, `exhaustMap`.
  prefs: []
  type: TYPE_NORMAL
- en: The exhaustMap operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`exhaustMap` is a combination of the exhaust and transformation (or mapping)
    strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '*exhaustMap = exhaust(exhaust) + map ()**higher-order mapping*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at this marble diagram to understand the exhaust strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – The exhaust operator – marble diagram](img/B21180_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – The exhaust operator – marble diagram
  prefs: []
  type: TYPE_NORMAL
- en: The top line is a higher-order Observable that produces three inner Observables
    over time. When the first inner Observable (`exhaust` will subscribe to it so
    that the values `exhaust` operator; it will not be subscribed to (this is the
    key part of `exhaust`).
  prefs: []
  type: TYPE_NORMAL
- en: Only when the first inner Observable completes will `exhaust` subscribe to new
    Observables. So, `exhaust` is ready now to treat other Observables. At that point,
    the third inner Observable comes. The switch will subscribe to and the values
    of the third inner Observable, **g**-**h**-**i**, get reflected in the output.
  prefs: []
  type: TYPE_NORMAL
- en: So, `exhaustMap` waits for the completion of the current inner Observable before
    allowing the next Observable to emit values. Once the inner Observable completes,
    `exhaustMap` subscribes to the next Observable in the sequence. It ensures that
    only one inner Observable is active at a time, ignoring any new Observables that
    are emitted while the current one is still ongoing. This is particularly useful
    in scenarios where you want to ignore new events until a previous operation has
    finished, such as handling user clicks on a button, where subsequent clicks are
    ignored until the current operation completes.
  prefs: []
  type: TYPE_NORMAL
- en: It’s similar to how you might handle tasks when you’re busy with something important.
    If someone tries to get your attention with a new task, you might say, “I’m busy
    right now, please don’t disturb me until I finish what I’m doing.” `exhaustMap`
    operates similarly, ensuring that ongoing tasks are completed before considering
    new ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a scenario in our recipe app where users can edit recipe details
    and save their changes through a `exhaustMap` comes in handy here by ignoring
    subsequent save requests until the current save operation completes. Here’s the
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the component responsible for editing the recipe, we defined the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A private `saveClick` subject to track the `saveClick` represents our first
    stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A private `saveRecipe$` Observable that issues an HTTP save request to save
    the recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`saveClick$`, our second stream that listens to `saveClick` emissions and uses
    `exhaustMap` operator to issue a new save request only after the previous one
    is completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `saveRecipe` method. This will be invoked when the `true` to the `saveClick`
    subject.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we must subscribe to `saveClick$` using the async pipe in the HTML
    template and add the click handler to the `saveRecipe` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that only one save request is processed at a time, preventing duplicate
    entries or data corruption. You can test this code in `RecipeCreationComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `exhaustMap` in drag and drop features to ensure that actions
    are only processed when a user’s dragging action has been completed, preventing
    multiple actions from being triggered simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up the operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s summarize all the operators that were mentioned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: If the order is important and you need to process operations in sequence while
    waiting for completion, then `concatMap` is the right choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the order is not important and you need to process operations in parallel
    to enhance performance, `mergeMap` is the best operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to put a cancellation logic to release resources and take always
    the most recent information, then `switchMap` is the way to go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To ignore new Observables while the current one is still ongoing, use `exhaustMap`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All you have to do is pick the right operator based on your specific use case.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we began by illustrating the traditional, imperative approach
    to implementing the autosave feature in our recipe app. However, we soon encountered
    limitations with this method. We highlighted these problems before exploring a
    more reactive pattern to address these challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we delved into higher-order Observables and higher-order mapping operators,
    learning how the `concatMap` operator works and how it can help us implement the
    autosave requirement in the Recipe app reactively.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we expanded our exploration to include other strategies, namely
    the `merge`, `switch`, and `exhaust` higher-order mapping operators. We explained
    their functionality by using practical examples and use cases to gain a deeper
    understanding of these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore another useful reactive pattern that allows
    you to share data between your components. As usual, we will demystify the concepts
    and then learn the reactive way to do it.
  prefs: []
  type: TYPE_NORMAL
