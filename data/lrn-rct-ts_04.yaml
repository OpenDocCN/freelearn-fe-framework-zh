- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Using React Hooks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React 钩子
- en: In this chapter, we will learn about React’s common Hooks and how to use them
    with TypeScript. We will implement the knowledge of all these Hooks in a React
    component that allows a user to adjust a score for a person. We will start by
    exploring the effect Hook and begin to understand use cases where it is useful.
    We will then delve into two state Hooks, `useState` and `useReducer`, understanding
    when it is best to use each one. After that, we will cover the ref Hook and how
    it differs from the state Hook, and then the memo and callback Hooks, looking
    at how they can help performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 React 的常见钩子以及如何使用 TypeScript 使用它们。我们将在一个允许用户调整某人的得分的 React 组件中实现所有这些钩子的知识。我们将从探索
    effect 钩子开始，并开始理解它在哪些用例中是有用的。然后，我们将深入研究两个状态钩子 `useState` 和 `useReducer`，了解何时最好使用每个钩子。之后，我们将介绍
    ref 钩子以及它与状态钩子的区别，然后是 memo 和回调钩子，看看它们如何帮助性能。
- en: 'So, we’ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将涵盖以下主题：
- en: Using the effect Hook
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Effect 钩子
- en: Using state Hooks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态钩子
- en: Using the ref Hook
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ref 钩子
- en: Using the memo Hook
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Memo 钩子
- en: Using the callback Hook
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用回调钩子
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will use the following technologies in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下技术：
- en: '**Browser**: A modern browser such as Google Chrome'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器**：一个现代浏览器，例如 Google Chrome'
- en: '**Node.js** and **npm**: You can install them from [https://nodejs.org/en/download/](https://nodejs.org/en/download/)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js** 和 **npm**：您可以从 [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    安装它们'
- en: '**Visual Studio Code**: You can install it from [https://code.visualstudio.com/](https://code.visualstudio.com/)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：您可以从 [https://code.visualstudio.com/](https://code.visualstudio.com/)
    安装它'
- en: All the code snippets in this chapter can be found online at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有代码片段都可以在网上找到，地址为 [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4)。
- en: Using the effect Hook
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Effect 钩子
- en: In this section, we will learn about the effect Hook and where it is useful.
    We will then create a new React project and a component that makes use of the
    effect Hook.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习 effect 钩子及其用途。然后，我们将创建一个新的 React 项目和一个使用 effect 钩子的组件。
- en: Understanding the effect Hook parameters
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 effect 钩子参数
- en: 'The effect Hook is used for component side effects. A component side effect
    is something executed outside the scope of the component such as a web service
    request. The effect Hook is defined using the `useEffect` function from React.
    `useEffect` contains two parameters:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: effect 钩子用于组件副作用。组件副作用是在组件作用域之外执行的操作，例如网络服务请求。effect 钩子是通过 React 的 `useEffect`
    函数定义的。`useEffect` 包含两个参数：
- en: A function that executes the effect; at a minimum, this function runs each time
    the component is rendered
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行效果的函数；至少，这个函数在组件渲染时运行
- en: An optional array of dependencies that cause the effect function to rerun when
    changed
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的依赖数组，当它改变时会导致效果函数重新运行
- en: 'Here’s an example of the `useEffect` Hook in a component:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个组件中 `useEffect` 钩子的示例：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding effect Hook is passed an effect function called `someEffect`.
    No effect dependencies have been passed, so the effect function is executed each
    time the component renders.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的效果钩子传递了一个名为 `someEffect` 的效果函数。没有传递效果依赖项，所以效果函数在每次组件渲染时都会执行。
- en: 'Often, an anonymous arrow function is used for the effect function. Here’s
    the same example but with an anonymous effect function instead:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，匿名箭头函数用于效果函数。以下是一个使用匿名效果函数的相同示例：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, this version of the code is a little shorter and arguably easier
    to read.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个版本的代码稍微短一些，并且可能更容易阅读。
- en: 'Here’s another example of an effect:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个效果的示例：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This time the effect has a dependency on a `search` prop. So, the `search` prop
    is defined in an array in the effect Hook’s second parameter. The effect function
    will run every time the value of `search` changes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这次效果依赖于一个 `search` 属性。因此，`search` 属性在 effect 钩子的第二个参数中的数组中定义。每当 `search` 的值改变时，效果函数都会运行。
- en: The rules of Hooks
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 钩子的规则
- en: 'There are some rules that all Hooks, including `useEffect`, must obey:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所有钩子都必须遵守一些规则，包括 `useEffect`：
- en: A Hook can only be called at the top level of a function component. So, a Hook
    can’t be called in a loop or in a nested function such as an event handler.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hook 只能在函数组件的顶层被调用。所以，Hook 不能在循环或嵌套函数（如事件处理器）中被调用。
- en: A Hook can’t be called conditionally.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hook 不能有条件地被调用。
- en: A Hook can only be used in function components and not class components.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hook 只能在函数组件中使用，而不能在类组件中使用。
- en: 'The following example is a violation of the rules:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例违反了规则：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is a violation because `useEffect` is called in a handler function rather
    than at the top level. A corrected version is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种违规，因为 `useEffect` 是在处理函数中而不是在顶层被调用的。修正后的版本如下：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`useEffect` has been lifted to the top level and now depends on the `clicked`
    state that is set in the handler function.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 已经提升到顶层，并且现在依赖于在处理函数中设置的 `clicked` 状态。'
- en: 'The following is another example that violates the rules of Hooks:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个违反 Hooks 规则的另一个示例：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The violation is because `useEffect` is called conditionally. If `someProp`
    is falsy, `null` is returned from the component and `useEffect` is never called.
    So, the condition is that `useEffect` is only called when `someProp` is truthy.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 违规是因为 `useEffect` 是有条件地被调用的。如果 `someProp` 是假值，组件会返回 `null`，并且 `useEffect` 从不会被调用。所以，条件是只有当
    `someProp` 是真值时，`useEffect` 才会被调用。
- en: 'A corrected version is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 修正后的版本如下：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`useEffect` has been lifted above the condition. The condition has also been
    put inside the effect function so that its logic is only executed when `someProp`
    is truthy.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 已经提升到条件之上。条件也被放入效果函数中，以便其逻辑仅在 `someProp` 是真值时执行。'
- en: Effect cleanup
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 效果清理
- en: 'An effect can return a function that performs cleanup logic when the component
    is unmounted. Cleanup logic ensures nothing is left that could cause a memory
    leak. Let’s consider the following example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 效果可以返回一个函数，在组件卸载时执行清理逻辑。清理逻辑确保没有留下可能导致内存泄漏的东西。让我们考虑以下示例：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding effect function attaches an event handler to the `document` element.
    The event handler is never detatched though, so multiple event handlers will become
    attached to the `document` element as the effect is rerun. This problem is resolved
    by returning a `cleanup` function that detaches the event handler as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的效果函数将事件处理器附加到 `document` 元素上。尽管事件处理器不会被移除，所以随着效果的重新运行，多个事件处理器将附加到 `document`
    元素上。这个问题通过返回一个 `cleanup` 函数来解决，如下所示：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Often, an anonymous arrow function is used for the cleanup function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，匿名箭头函数被用于清理函数：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: An anonymous arrow function is a little shorter than the named function in the
    previous example.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名箭头函数比上一个例子中的命名函数要短一些。
- en: Next, we will explore a common use case for the effect Hook.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨效果 Hook 的一个常见用例。
- en: Creating the project
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Let’s start by creating a new project in Visual Studio Code using Create React
    App. We learned how to do this in [*Chapter 3*](B19051_03.xhtml#_idTextAnchor072)*,
    Setting Up React and TypeScript* – the steps are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 Visual Studio Code 中使用 Create React App 创建一个新项目开始。我们已经在 [*第 3 章*](B19051_03.xhtml#_idTextAnchor072)*，设置
    React 和 TypeScript* 中学习了如何这样做 – 步骤如下：
- en: 'Open Visual Studio Code in a blank folder of your choice and run the following
    command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你选择的空白文件夹中打开 Visual Studio Code 并运行以下命令：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Create React App will take a minute or so to create the project. The app is
    called `app` in the proceeding command, but feel free to change this.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Create React App 需要一两分钟来创建项目。在后续命令中，应用被命名为 `app`，但你可以随意更改这个名字。
- en: Reopen Visual Studio Code in the `app` folder that has just been created (or
    whatever you called the app).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在刚刚创建的 `app` 文件夹（或你给它起的名字）中重新打开 Visual Studio Code。
- en: 'Install Prettier and its libraries to allow it to work with ESLint. Run the
    following command in the terminal to do this:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Prettier 及其库，以便它能够与 ESLint 一起工作。在终端中运行以下命令来完成此操作：
- en: '[PRE11]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Enable Visual Studio Code to automatically format code as files are saved.
    To do this, create a `.vscode` folder in the project root and create a `settings.json`
    file containing the following:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用 Visual Studio Code 在文件保存时自动格式化代码。为此，在项目根目录中创建一个 `.vscode` 文件夹，并创建一个包含以下内容的
    `settings.json` 文件：
- en: '[PRE12]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Update the ESLint configuration to allow Prettier to manage the styling rules.
    To do this, add the following highlighted line to the `eslintConfig` section in
    `package.json`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 ESLint 配置以允许 Prettier 管理样式规则。为此，将以下高亮行添加到 `package.json` 中的 `eslintConfig`
    部分：
- en: '[PRE16]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the following Prettier configuration in a file called `.prettierrc.json`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个名为 `.prettierrc.json` 的文件中添加以下 Prettier 配置：
- en: '[PRE27]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Remove the following files from the `src` folder, because these aren’t needed
    in this project:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `src` 文件夹中删除以下文件，因为这些文件在这个项目中不是必需的：
- en: '`App.test.tsx`'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.test.tsx`'
- en: '`Logo.svg`'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Logo.svg`'
- en: Open `index.tsx` and save the file without making any changes. This will remove
    any formatting issues.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `index.tsx` 并保存文件，无需进行任何更改。这将消除任何格式问题。
- en: 'Open `App.tsx` and replace the content with the following:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `App.tsx` 并将内容替换为以下内容：
- en: '[PRE35]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Start the app running in development mode by running `npm start` in the terminal.
    The app contains a blank page at the moment. Keep the app running as we explore
    the different Hooks in a React component.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中运行 `npm start` 启动开发模式下的应用程序。目前应用程序包含一个空白页面。在我们探索 React 组件中的不同钩子时，请保持应用程序运行。
- en: That’s the project created. Next, we will use the effect Hook.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是创建的项目。接下来，我们将使用效果钩子。
- en: Fetching data using the effect Hook
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用效果钩子获取数据
- en: 'A common use of the effect Hook is fetching data. Carry out the following steps
    to implement an effect that fetches a person’s name:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 效果钩子的一个常见用途是获取数据。执行以下步骤以实现一个获取人名的效果：
- en: 'Create a function that will simulate a data request. To do this, create a file
    called `getPerson.ts` in the `src` folder and then add the following content to
    this file:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将模拟数据请求的函数。为此，在 `src` 文件夹中创建一个名为 `getPerson.ts` 的文件，然后向该文件添加以下内容：
- en: '[PRE41]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The function asynchronously returns an object, `{ name: "Bob" }`, after a second
    has elapsed.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '函数在经过一秒钟后异步返回一个对象，`{ name: "Bob" }`。'
- en: 'Notice the type annotation for the return type, `Promise<Person>`. The `Promise`
    type represents a JavaScript `Promise`, which is something that will eventually
    be completed. The `Promise` type has a generic argument for the item type that
    is resolved in the promise, which is `Person` in this example. For more information
    on JavaScript promises, see the following link: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意返回类型的类型注解，`Promise<Person>`。`Promise` 类型代表 JavaScript 的 `Promise`，它最终会被完成。`Promise`
    类型有一个泛型参数，用于指定在承诺中解析的项目类型，在这个例子中是 `Person`。有关 JavaScript 承诺的更多信息，请参阅以下链接：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)。
- en: 'Next, we will create a React component that will eventually display a person
    and a score. Create a file called `PersonScore.tsx` in the `src` folder and then
    add the following contents to the file:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个最终将显示人和分数的 React 组件。在 `src` 文件夹中创建一个名为 `PersonScore.tsx` 的文件，然后向该文件添加以下内容：
- en: '[PRE49]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `useEffect` Hook has been imported from React and the `getPerson` function
    we have just created has also been imported. At the moment, the component simply
    returns `null`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 已经从 React 导入了 `useEffect` 钩子以及我们刚刚创建的 `getPerson` 函数。目前，组件仅返回 `null`。
- en: 'Add the following effect above the return statement:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在返回语句上方添加以下效果：
- en: '[PRE54]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The effect calls the `getPerson` function and outputs the returned person to
    the console. The effect is only executed after the component is initially rendered
    because an empty array has been specified as the effect dependencies in its second
    argument.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 效果调用 `getPerson` 函数并将返回的人输出到控制台。由于在第二个参数中指定了一个空数组作为效果依赖项，因此效果仅在组件最初渲染后执行。
- en: 'Open `App.tsx` and render the `PersonScore` component inside the `div` element:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `App.tsx` 并在 `div` 元素内渲染 `PersonScore` 组件：
- en: '[PRE60]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Go to the running app in the browser and go to the `person` object appears
    in the console, which verifies that the effect that fetches the `person` data
    ran properly:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中转到正在运行的应用程序，并查看控制台中出现的 `person` 对象，这验证了获取 `person` 数据的效果已正确运行：
- en: '![Figure 4.1 – The effect output](img/B19051_04_01.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 效果输出](img/B19051_04_01.jpg)'
- en: Figure 4.1 – The effect output
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 效果输出
- en: 'You may also notice that the effect function has been executed twice rather
    than once. This behavior is intentional and only happens in development mode with
    React Strict Mode. This will eventually allow a future React feature to preserve
    the state when sections of the UI are removed. See this blog post from the React
    team for more information on this behavior: https://reactjs.org/blog/2022/03/29/react-v18.html#new-strict-mode-behaviors.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到，`effect` 函数已经执行了两次而不是一次。这种行为是故意的，并且仅在开发模式下的 React Strict Mode 中发生。这最终将允许未来的
    React 功能在移除 UI 的部分时保留状态。有关此行为的更多信息，请参阅 React 团队的这篇博客文章：[https://reactjs.org/blog/2022/03/29/react-v18.html#new-strict-mode-behaviors](https://reactjs.org/blog/2022/03/29/react-v18.html#new-strict-mode-behaviors)。
- en: 'Next, we will refactor how the effect function is called to expose an interesting
    problem. Open `PersonScore.tsx` and change the `useEffect` call to use the `async`/`await`
    syntax:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将重构调用 `effect` 函数的方式，以揭示一个有趣的问题。打开 `PersonScore.tsx` 并将 `useEffect` 调用改为使用
    `async`/`await` 语法：
- en: '[PRE71]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `async`/`await` syntax is an alternative way to write asynchronous code.
    Many developers prefer it because it reads like synchronous code. For more information
    on `async`/`await`, see the following link: [https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#async_and_await](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#async_and_await).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`/`await` 语法是编写异步代码的另一种方式。许多开发者更喜欢它，因为它读起来像同步代码。有关 `async`/`await` 的更多信息，请参阅以下链接：[https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#async_and_await](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#async_and_await)。'
- en: 'The preceding code is arguably more readable, but React raises an error. Look
    in the browser’s console and you’ll see the following error:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以说是更易读，但 React 会抛出一个错误。查看浏览器的控制台，你会看到以下错误：
- en: '![Figure 4.2 – Effect async error](img/B19051_04_02.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – Effect 异步错误](img/B19051_04_02.jpg)'
- en: Figure 4.2 – Effect async error
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – Effect 异步错误
- en: The error is very informative – the `useEffect` Hook doesn’t allow a function
    marked with `async` to be passed into it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误信息非常有用——`useEffect` Hook 不允许将标记为 `async` 的函数传递给它。
- en: 'Next, update the code and use the approach suggested in the error message:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新代码并使用错误消息中建议的方法：
- en: '[PRE75]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: A nested asynchronous function has been defined and immediately called in the
    effect function; this works nicely.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `effect` 函数中定义了一个嵌套的异步函数，并立即调用；这工作得很好。
- en: 'This implementation of the effect is arguably less readable than the initial
    version. So, switch back to that version before continuing to the next section.
    The code is available to copy from the following link: [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section1-Using-the-effect-hook/src/PersonScore.tsx](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section1-Using-the-effect-hook/src/PersonScore.tsx).'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与初始版本相比，这种 `effect` 实现可以说是更不易读。因此，在继续到下一节之前，请切换回那个版本。代码可以从以下链接复制：[https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section1-Using-the-effect-hook/src/PersonScore.tsx](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section1-Using-the-effect-hook/src/PersonScore.tsx)。
- en: 'That completes our exploration of the effect Hook – here’s a recap:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对 `effect Hook` 的探索——以下是总结：
- en: The effect Hook is used to execute component side effects when a component is
    rendered or when certain props or states change.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`effect Hook` 用于在组件渲染时或某些属性或状态发生变化时执行组件副作用。'
- en: A common use case for the effect Hook is fetching data. Another use case is
    where DOM events need to be manually registered.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`effect Hook` 的一个常见用例是获取数据。另一个用例是当需要手动注册 DOM 事件时。'
- en: Any required effect cleanup can be done in a function returned by the effect
    function.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的任何 `effect` 清理工作都可以在 `effect` 函数返回的函数中完成。
- en: Next, we will learn about the two state Hooks in React. Keep the app running
    as we move to the next section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解 React 中的两个状态 Hook。在我们移动到下一节之前，请保持应用程序运行。
- en: Using state Hooks
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用状态 Hook
- en: We have already learned about the `useState` Hook in previous chapters, but
    here we will look at it again and compare it against another state Hook we haven’t
    covered yet, `useReducer`. We will expand the `PersonScore` component we created
    in the last section to explore these state Hooks.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节中学习了 `useState Hook`，但在这里我们将再次探讨它，并将其与另一个我们尚未涉及的 `state Hook` 进行比较，即
    `useReducer`。我们将扩展上一节中创建的 `PersonScore` 组件，以探索这些状态 Hook。
- en: Using useState
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `useState`
- en: 'As a reminder, the `useState` Hook allows state to be defined in a variable.
    The syntax for `useState` is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，`useState` Hook 允许在变量中定义状态。`useState`的语法如下：
- en: '[PRE82]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We will enhance the `PersonScore` component we created in the last section to
    store the person’s name in `state`. We will also have `state` for a score that
    is incremented, decremented, and reset using some buttons in the component. We
    will also add the `loading` state to the component, which will show a loading
    indicator when `true`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将增强上一节中创建的`PersonScore`组件，以便在`state`中存储人的姓名。我们还将为分数添加`state`，该分数可以通过组件中的某些按钮进行增加、减少和重置。我们还将向组件中添加`loading`状态，当`true`时将显示加载指示器。
- en: 'Carry out the following steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Open `PersonScore.tsx` and add `useState` to the React import statement:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PersonScore.tsx`并将`useState`添加到React导入语句中：
- en: '[PRE83]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Add the following state definitions for `name`, `score`, and `loading` at the
    top of the component function, above the `useEffect` call:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件函数顶部，在`useEffect`调用之上添加以下`name`、`score`和`loading`状态定义：
- en: '[PRE84]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `score` state is initialized to `0` and `loading` is initialized to `true`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`score`状态初始化为`0`，`loading`初始化为`true`。'
- en: 'Change the effect function to set the `loading` and `name` state values after
    the person data has been fetched. This should replace the existing `console.log`
    statement:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将效果函数更改为在获取到个人信息后设置`loading`和`name`状态值。这应该替换现有的`console.log`语句：
- en: '[PRE91]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: After the person has been fetched, `loading` is set to `false`, and `name` is
    set to the person’s name.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取到个人信息后，`loading`设置为`false`，`name`设置为人的姓名。
- en: 'Next, add the following `if` statement in between the `useEffect` call and
    the return statement:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`useEffect`调用和返回语句之间添加以下`if`语句：
- en: '[PRE97]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This displays a loading indicator when the `loading` state is `true`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当`loading`状态为`true`时，这将显示加载指示器。
- en: 'Change the component’s return statement from outputting nothing to outputting
    the following:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件的返回语句从输出空内容更改为输出以下内容：
- en: '[PRE102]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The person’s name and score are displayed in a header with **Add**, **Subtract**,
    and **Reset** buttons underneath (don’t worry that the output is unstyled – we
    will learn how to style components in the next chapter):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 人的姓名和分数在一个带有**添加**、**减去**和**重置**按钮的标题中显示（不用担心输出未样式化 – 我们将在下一章学习如何样式化组件）：
- en: '![Figure 4.3 – The PersonScore component after data has been fetched](img/B19051_04_03.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 获取数据后的PersonScore组件](img/B19051_04_03.jpg)'
- en: Figure 4.3 – The PersonScore component after data has been fetched
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 获取数据后的PersonScore组件
- en: 'Update the **Add** button so that it increments the score when clicked:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新**添加**按钮，以便在点击时增加分数：
- en: '[PRE115]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The button click event calls the score state setter to increment the state.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮点击事件调用分数状态设置器以增加状态。
- en: 'There is an alternative method of updating the state values based on their
    previous value. The alternative method uses a parameter in the state setter that
    gives the previous state value, so our example could look as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们的前一个值更新状态值的方法是另一种方法。该方法使用状态设置器中的参数来提供前一个状态值，因此我们的示例可以如下所示：
- en: '[PRE116]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This is arguably a little harder to read, so we’ll stick to our initial method.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点难以阅读，所以我们将继续使用我们的初始方法。
- en: 'Add score state setters to the other buttons as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式为其他按钮添加分数状态设置器：
- en: '[PRE117]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: In the running app, click the different buttons. They should change the score
    as you would expect.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行的应用程序中，点击不同的按钮。它们应该像您预期的那样改变分数。
- en: '![Figure 4.4 – The PersonScore component after the button is clicked](img/B19051_04_04.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 点击按钮后的PersonScore组件](img/B19051_04_04.jpg)'
- en: Figure 4.4 – The PersonScore component after the button is clicked
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 点击按钮后的PersonScore组件
- en: 'Before we finish this exercise, let’s take some time to understand when the
    state values are actually set. Update the effect function to output the state
    values after they are set:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成这个练习之前，让我们花点时间来了解状态值实际上是在何时设置的。更新效果函数以在设置后输出状态值：
- en: '[PRE119]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Perhaps we would expect `false` and `"Bob"` as the output to the console? However,
    `true` and `undefined` are the output to the console. This is because updating
    state values is not immediate – instead, they are batched and updated before the
    next render. So, it isn’t until the next render that `loading` will be `false`,
    and `name` will be `"Bob"`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能期望控制台输出为`false`和`"Bob"`？然而，控制台输出的是`true`和`undefined`。这是因为更新状态值不是立即的 – 相反，它们被批处理并在下一次渲染之前更新。因此，只有在下一次渲染时，`loading`才会变为`false`，`name`才会变为`"Bob"`。
- en: We no longer need the `console.log` statement we added in this step, so remove
    it before continuing.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要在这个步骤中添加的 `console.log` 语句，所以在继续之前将其删除。
- en: Next, we will learn about an alternative React Hook for using state.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习一个用于使用状态的替代 React Hook。
- en: Understanding useReducer
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 useReducer
- en: '`useReducer` is an alternative method of managing state. It uses a **reducer**
    function for state changes, which takes in the current state value and returns
    the new state value.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`useReducer` 是管理状态的一种替代方法。它使用一个 **reducer** 函数来处理状态变化，该函数接收当前状态值并返回新的状态值。'
- en: 'Here is an example of a `useReducer` call:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `useReducer` 调用的示例：
- en: '[PRE126]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: So, `useReducer` takes in a reducer function and the initial state value as
    parameters. It then returns a tuple containing the current state value and a function
    to **dispatch** state changes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`useReducer` 接收一个 reducer 函数和初始状态值作为参数。然后它返回一个包含当前状态值和一个用于 **dispatch** 状态变化的函数的元组。
- en: 'The dispatch function takes in an argument that describes the change. This
    object is called an `dispatch` call is as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: dispatch 函数接收一个描述更改的参数。这个对象被称为 `dispatch` 调用，如下所示：
- en: '[PRE127]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'There is no defined structure for an action, but it is common practice for
    it to contain a property, such as `type`, to specify the type of change. Other
    properties in the action can vary depending on the type of change. Here’s another
    example of a `dispatch` call:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 动作没有定义的结构，但通常包含一个属性，例如 `type`，用于指定更改的类型。动作中的其他属性可能根据更改的类型而变化。以下是一个 `dispatch`
    调用的另一个示例：
- en: '[PRE128]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: This time, the action only needs the type to change the necessary state.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，动作只需要类型来更改必要的状态。
- en: 'Turning our attention to the reducer function, it has parameters for the current
    state value and the action. Here’s an example code snippet of a reducer:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的注意力转向 reducer 函数，它具有当前状态值和动作的参数。以下是一个 reducer 的示例代码片段：
- en: '[PRE129]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The reducer function usually contains a `switch` statement based on the action
    type. Each switch branch makes the required changes to the state and returns the
    updated state. A new state object is created during the state change – the current
    state is never mutated. A mutating state would result in the component not re-rendering.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: reducer 函数通常包含一个基于动作类型的 `switch` 语句。每个 switch 分支对状态进行必要的更改并返回更新后的状态。在状态变化期间会创建一个新的状态对象——当前状态永远不会被修改。修改状态会导致组件不重新渲染。
- en: Note
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE130]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The types for `useReducer` can be explicitly defined in its generic parameter
    as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`useReducer` 的类型可以在其泛型参数中显式定义，如下所示：'
- en: '[PRE131]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '`Reducer` is a standard React type that has generic parameters for the type
    of state and the type of action.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reducer` 是一个标准的 React 类型，它具有泛型参数，用于定义状态和动作的类型。'
- en: So, `useReducer` is more complex than `useState` because state changes go through
    a reducer function that we must implement. This benefits complex state objects
    with related properties or when a state change depends on the previous state value.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`useReducer` 比起 `useState` 更复杂，因为状态变化需要通过我们必须实现的 reducer 函数进行。这对于具有相关属性或状态变化依赖于先前状态值的复杂状态对象来说是有益的。
- en: Next, we will implement state using `useReducer`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `useReducer` 实现状态。
- en: Using useReducer
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 useReducer
- en: 'We will refactor the `PersonScore` component we have been working on to use
    `useReducer` instead of `useState`. To do this, carry out the following steps.
    The code snippets used are available to copy from [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section2-Using-state-hooks/2-Using-useReducer/src/PersonScore.tsx](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section2-Using-state-hooks/2-Using-useReducer/src/PersonScore.tsx):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构我们一直在工作的 `PersonScore` 组件，使用 `useReducer` 而不是 `useState`。为此，执行以下步骤。使用的代码片段可以从
    [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section2-Using-state-hooks/2-Using-useReducer/src/PersonScore.tsx](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section2-Using-state-hooks/2-Using-useReducer/src/PersonScore.tsx)
    复制。
- en: 'Open `PersonScore.tsx` and import `useReducer` instead of `useState` from React:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PersonScore.tsx` 并从 React 中导入 `useReducer` 而不是 `useState`：
- en: '[PRE132]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'We will have the state in a single object, so define a type for the state beneath
    the import statements:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将状态放在一个单独的对象中，所以定义一个类型在导入语句下方：
- en: '[PRE133]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Next, let’s also define types for all the action objects:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们也定义所有动作对象类型：
- en: '[PRE138]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: These action objects represent all the ways in which state can change. The action
    object types are combined using a union type, allowing an action to be any of
    these.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动作对象代表了状态可以改变的所有方式。动作对象类型通过联合类型组合，允许动作是这些中的任何一个。
- en: 'Now, define the following reducer function underneath the type definitions:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在类型定义下方定义以下减法函数：
- en: '[PRE152]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: The reducer function contains a `switch` statement that makes appropriate state
    changes for each type of action.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 减法函数包含一个`switch`语句，为每种类型的操作执行相应的状态变更。
- en: 'Notice the nice IntelliSense when referencing the `state` and `action` parameters:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当引用`state`和`action`参数时的良好IntelliSense：
- en: '![Figure 4.5 – IntelliSense inside the reducer function](img/B19051_04_05.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 减法函数内的IntelliSense](img/B19051_04_05.jpg)'
- en: Figure 4.5 – IntelliSense inside the reducer function
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 减法函数内的IntelliSense
- en: 'Inside the `PersonScore` component, replace the `useState` calls with the following
    `useReducer` call:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PersonScore`组件内部，将`useState`调用替换为以下`useReducer`调用：
- en: '[PRE166]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: The state has been initialized with an `undefined` name, a score of `0`, and
    `loading` set to `true`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 状态已使用`undefined`名称、分数`0`和`loading`设置为`true`初始化。
- en: The current state value has been destructured into `name`, `score`, and `loading`
    variables. If you hover over these destructured state variables, you will see
    that their types have been inferred correctly.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当前状态值已解构为`name`、`score`和`loading`变量。如果你悬停在解构的状态变量上，你会看到它们的类型已经被正确推断。
- en: 'We now need to amend the places in the component that update the state. Start
    with the effect function and dispatch an initialize action after the person has
    been returned:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要修改组件中更新状态的那些地方。从效果函数开始，在返回人员信息后分发初始化操作：
- en: '[PRE174]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Lastly, dispatch the relevant actions in the button click handlers:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在按钮点击处理程序中分发相关操作：
- en: '[PRE179]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: If you try clicking the buttons in the running app, they will correctly update.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你尝试点击运行中的应用程序中的按钮，它们将正确更新。
- en: That completes our exploration of the `useReducer` Hook. It is more useful for
    complex state management situations than `useState`, for example, when the state
    is a complex object with related properties and state changes depend on previous
    state values. The `useState` Hook is more appropriate when the state is based
    on primitive values independent of any other state.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对`useReducer`钩子的探索。它比`useState`更适合复杂的状态管理情况，例如，当状态是一个具有相关属性和状态变更依赖于先前状态值的复杂对象时。当状态基于独立于任何其他状态的原始值时，`useState`钩子更为合适。
- en: We will continue to expand the `PersonScore` component in the following sections.
    Next, we will learn how to move the focus to the **Add** button using the ref
    Hook.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将继续扩展`PersonScore`组件。接下来，我们将学习如何使用`ref`钩子将焦点移动到**添加**按钮。
- en: Using the ref Hook
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ref`钩子
- en: In this section, we will learn about the ref Hook and where it is useful. We
    will then walk through a common use case of the ref Hook by enhancing the `PersonScore`
    component we have been working on.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解`ref`钩子和它的用途。然后，我们将通过增强我们一直在工作的`PersonScore`组件来演示`ref`钩子的一个常见用例。
- en: Understanding the ref Hook
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`ref`钩子
- en: The ref Hook is called `useRef` and it returns a variable whose value is persisted
    for the lifetime of a component. This means that the variable doesn’t lose its
    value when a component re-renders.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref`钩子被称作`useRef`，它返回一个变量，其值在组件的生命周期内保持持久。这意味着当组件重新渲染时，变量不会丢失其值。'
- en: The value returned from the ref Hook is often referred to as a **ref**. The
    ref can be changed without causing a re-render.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ref`钩子返回的值通常被称为**ref**。ref可以更改而不会导致重新渲染。
- en: 'Here’s the syntax for `useRef`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`useRef`的语法：
- en: '[PRE188]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'An initial value can optionally be passed into `useRef`. The type of the ref
    can be explicitly defined in a generic argument for `useRef`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择性地将初始值传递给`useRef`。`ref`的类型可以通过`useRef`的泛型参数显式定义：
- en: '[PRE189]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: The generic argument is useful when no initial value is passed or is `null`.
    This is because TypeScript won’t be able to infer the type correctly.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有传递初始值或初始值为`null`时，泛型参数是有用的。这是因为TypeScript无法正确推断类型。
- en: 'The value of the ref is accessed via its `current` property:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其`current`属性访问`ref`的值：
- en: '[PRE190]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'The value of the ref can be updated via its current property as well:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过其`current`属性更新`ref`的值：
- en: '[PRE191]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'A common use of the `useRef` Hook is to access HTML elements imperatively.
    HTML elements have a `ref` attribute in JSX that can be assigned to a ref. The
    following is an example of this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRef`钩子的一种常见用法是强制访问HTML元素。HTML元素在JSX中有一个`ref`属性，可以被分配给ref。以下是一个示例：'
- en: '[PRE192]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: The ref used here is called `inputRef` and is initially `null`. So, it is explicitly
    given a type of `HTMLInputElement`, which is a standard type for input elements.
    The ref is then assigned to the `ref` attribute on an input element in JSX. All
    the input’s properties and methods are then accessible via the ref’s `current`
    property.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的ref被称为`inputRef`，初始值为`null`。因此，它被明确地赋予了一个类型`HTMLInputElement`，这是输入元素的常规类型。然后，这个ref被分配到JSX中输入元素的`ref`属性上。然后，所有输入的属性和方法都可通过ref的`current`属性访问。
- en: Next, we will use the `useRef` Hook in the `PersonScore` component.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`PersonScore`组件中使用`useRef`钩子。
- en: Using the ref Hook
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ref钩子
- en: 'We will enhance the `PersonScore` component we have been working on to use
    `useRef` to move the focus to the **Add** button. To do this, carry out the following
    steps. All the code snippets used are available at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section3-Using-the-ref-hook/src/PersonScore.tsx](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section3-Using-the-ref-hook/src/PersonScore.tsx):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将增强我们一直在工作的`PersonScore`组件，使用`useRef`将焦点移动到**添加**按钮。为此，执行以下步骤。所有使用的代码片段都可在以下链接中找到：[https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section3-Using-the-ref-hook/src/PersonScore.tsx](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section3-Using-the-ref-hook/src/PersonScore.tsx)：
- en: 'Open `PersonScore.tsx` and import `useRef` from React:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PersonScore.tsx`文件，并从React中导入`useRef`：
- en: '[PRE193]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Create a ref for the `useReducer` statement:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`useReducer`语句创建一个ref：
- en: '[PRE194]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: The ref is named `addButtonRef` and is initially `null`. It is given the standard
    `HTMLButtonElement` type.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ref被命名为`addButtonRef`，初始值为`null`。它被赋予了标准的`HTMLButtonElement`类型。
- en: Note
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the standard HTML elements have corresponding TypeScript types for React.
    Right-click on the `HTMLButtonElement` type and choose **Go to Definition** to
    discover all these types. The React TypeScript types will open containing all
    the HTML element types.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标准HTML元素都有对应React的TypeScript类型。右键点击`HTMLButtonElement`类型并选择**转到定义**，以发现所有这些类型。React
    TypeScript类型将打开，包含所有HTML元素类型。
- en: 'Assign the ref to the `ref` attribute on the **Add** button JSX element:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ref分配给**添加**按钮JSX元素的`ref`属性：
- en: '[PRE197]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Now that we have a reference to the `focus` method to move the focus to it
    when the person’s information has been fetched. Let’s add another effect to do
    this below the existing effect that fetches the person:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了`focus`方法的引用，可以在获取到人员信息后将其移动到焦点上。让我们在获取人员的现有效果下方添加另一个效果来完成此操作：
- en: '[PRE203]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: The effect is executed when the `loading` state is `true`, which will be after
    the person has been fetched.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当`loading`状态为`true`时，效果会被执行，这将在获取到人员信息之后发生。
- en: 'Notice the `?` symbol after the `current` property on the ref. This is the
    `focus` method to be invoked without having to check that `current` is not `null`.
    Visit the following link for more information about optional chaining: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining).'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在ref的`current`属性后面的`?`符号。这是在不需要检查`current`是否为`null`的情况下调用的`focus`方法。有关可选链的更多信息，请访问以下链接：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining)。
- en: 'We could have moved the focus to the **Add** button in the existing effect
    as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在现有的效果中将焦点移动到**添加**按钮上，如下所示：
- en: '[PRE216]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: However, this is mixing the concerns of fetching data, setting state, and setting
    focus to a button. Mixing concerns like this can make components hard to understand
    and change.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种做法将获取数据、设置状态和设置按钮焦点等关注点混合在一起。这种关注点的混合会使组件难以理解和修改。
- en: 'If you refresh the browser containing the running app, you will see a focus
    indicator on the **Add** button:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你刷新包含运行中的应用程序的浏览器，你将在**添加**按钮上看到一个焦点指示器：
- en: '![Figure 4.6 – The focused Add button](img/B19051_04_06.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 焦点的添加按钮](img/B19051_04_06.jpg)'
- en: Figure 4.6 – The focused Add button
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 焦点的添加按钮
- en: If you press the *Enter* key, you will see that the **Add** button is clicked
    and the score incremented. This proves that the **Add** button is focused.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按下*Enter*键，你会看到**添加**按钮被点击并且分数增加。这证明了**添加**按钮是聚焦的。
- en: That completes the enhancement and our exploration of the ref Hook.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了增强和我们对ref Hook的探索。
- en: To recap, the `useRef` Hook creates a mutatable value and doesn’t cause a re-render
    when changed. It is commonly used to access HTML elements in React imperatively.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，`useRef` Hook创建了一个可变的值，并且在变化时不会引起重新渲染。它通常用于在React中以命令式方式访问HTML元素。
- en: Next, we will learn about the memo Hook.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习memo Hook。
- en: Using the memo Hook
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用memo Hook
- en: In this section, we will learn about the memo Hook and where it is useful. We
    will then walk through an example in the `PersonScore` component we have been
    working on.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习memo Hook及其用途。然后，我们将通过我们在`PersonScore`组件中一直在工作的例子进行演示。
- en: Understanding the memo Hook
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解memo Hook
- en: 'The memo Hook creates a memoized value and is beneficial for values that have
    computationally expensive calculations. The Hook is called `useMemo` and the syntax
    is as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: memo Hook创建了一个记忆值，对于有计算成本高昂的计算的值来说是有益的。该Hook被称为`useMemo`，其语法如下：
- en: '[PRE217]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: A function that returns the value to memoize is passed into `useMemo` as the
    first argument. The function in this first argument should perform the expensive
    calculation.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回记忆值的函数作为第一个参数传递给`useMemo`。这个第一个参数应该执行昂贵的计算。
- en: 'The second argument passed to `useMemo` is an array of dependencies. So, if
    the `expensiveCalculation` function has dependencies `a` and `b`, the call will
    be as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`useMemo`的第二个参数是一个依赖项数组。所以，如果`expensiveCalculation`函数有依赖项`a`和`b`，调用将如下所示：
- en: '[PRE218]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: When any dependencies change, the function in the first argument is executed
    again to return a new value to memoize. In the previous example, a new version
    of `memoizedValue` is created every time `a` or `b` changes.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何依赖项发生变化时，第一个参数中的函数会再次执行以返回一个新值进行记忆。在之前的例子中，每当`a`或`b`发生变化时，就会创建一个新的`memoizedValue`版本。
- en: 'The type of the memoized value is inferred but can be explicitly defined in
    a generic parameter on `useMemo`. The following is an example of explicitly defining
    that the memoized value should have a `number` type:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆值的类型是推断出来的，但可以在`useMemo`上的泛型参数中显式定义。以下是一个显式定义记忆值应该具有`number`类型的示例：
- en: '[PRE219]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: Next, we will experiment with `useMemo`.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实验`useMemo`。
- en: Using the memo Hook
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用memo Hook
- en: 'We will use the `PersonScore` component we have been working on to play with
    the `useMemo` Hook. To do so, carry out the following steps. The code snippets
    used are available at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4/Section4-Using-the-memo-hook](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4/Section4-Using-the-memo-hook):'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在`PersonScore`组件中一直在工作的组件来与`useMemo` Hook进行交互。为此，执行以下步骤。使用的代码片段可在[https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4/Section4-Using-the-memo-hook](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4/Section4-Using-the-memo-hook)找到：
- en: 'Open `PersonScore.tsx` and import `useMemo` from React:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PersonScore.tsx`并从React中导入`useMemo`：
- en: '[PRE220]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'Add the following expensive function below the import statements:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入语句下方添加以下昂贵的函数：
- en: '[PRE226]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: The function adds all the numbers between `0` and `10000` and will take a while
    to execute.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数计算从`0`到`10000`之间的所有数字，并且执行需要一段时间。
- en: 'Add a call to the function in the `PersonScore` component beneath the effects:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PersonScore`组件的效果下方添加对函数的调用：
- en: '[PRE234]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'Add the result of the function call to the JSX underneath `name` and `score`:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数调用的结果添加到`name`和`score`下方的JSX中：
- en: '[PRE239]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: Refresh the browser containing the app and click the buttons. If you look in
    the console, you will see that the expensive function is executed every time the
    component is re-rendered after a button click.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新包含应用的浏览器并点击按钮。如果你查看控制台，你会看到在按钮点击后组件重新渲染时，昂贵的函数每次都会执行。
- en: '![Figure 4.7 – The expensive function executed multiple times](img/B19051_04_07.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 执行多次的昂贵函数](img/B19051_04_07.jpg)'
- en: Figure 4.7 – The expensive function executed multiple times
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 执行多次的昂贵函数
- en: Remember that a double render occurs in development mode and React’s Strict
    Mode. So, once a button is clicked, you will see **Executing silly function**
    in the console twice.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在开发模式下，双渲染会发生，React的Strict Mode也是如此。所以，一旦点击按钮，你会在控制台中看到**执行愚蠢函数**两次。
- en: An expensive function executing each time a component is re-rendered can lead
    to performance problems.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 每次组件重新渲染时执行昂贵的函数可能会导致性能问题。
- en: 'Rework the call to `sillyExpensiveFunction` as follows:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对 `sillyExpensiveFunction` 的调用重写如下：
- en: '[PRE246]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: The `useMemo` Hook is used to memoize the value from the function call.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo` Hook 用于记忆化函数调用的值。'
- en: Refresh the browser containing the running app and click the buttons. If you
    look in the console, you will see that the expensive function isn’t executed when
    the buttons are clicked because the memoized value is used instead.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新包含运行中的应用程序的浏览器并点击按钮。如果你查看控制台，你会看到当按钮被点击时，昂贵的函数并没有被执行，因为使用了记忆化的值。
- en: '![Figure 4.8 – The expensive function call memoized](img/B19051_04_08.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 记忆化的昂贵函数调用](img/B19051_04_08.jpg)'
- en: Figure 4.8 – The expensive function call memoized
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 记忆化的昂贵函数调用
- en: That completes our exploration of the `useMemo` Hook. The takeaway from this
    section is that the `useMemo` Hook helps improve the performance of function calls
    by memoizing their results and using the memoized value when the function is re-executed.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对 `useMemo` Hook 的探索。本节的要点是，`useMemo` Hook 通过记忆化函数的结果并在函数重新执行时使用记忆化的值来帮助提高函数调用的性能。
- en: Next, we will look at another Hook that can help performance.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨另一个可以帮助性能的 Hook。
- en: Using the callback Hook
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用回调 Hook
- en: In this section, we will learn about the callback Hook and where it is useful.
    We will then use the Hook in the `PersonScore` component we have been working
    on.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解回调 Hook 以及它的用途。然后，我们将使用这个 Hook 在我们一直在工作的 `PersonScore` 组件中。
- en: Understanding the callback Hook
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解回调 Hook
- en: 'The callback Hook memoizes a function so that it isn’t recreated on each render.
    The Hook is called `useCallback` and the syntax is as follows:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 回调 Hook 记忆化一个函数，以便它在每次渲染时不会被重新创建。这个 Hook 被称为 `useCallback`，其语法如下：
- en: '[PRE250]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'A function that executes the function to memoize is passed into `useCallback`
    as the first argument. The second argument passed to `useCallback` is an array
    of dependencies. So, if the `someFunction` function has dependencies `a` and `b`,
    the call will be as follows:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 将执行要记忆化函数的函数传递给 `useCallback` 作为第一个参数。传递给 `useCallback` 的第二个参数是一个依赖项数组。因此，如果
    `someFunction` 函数有依赖项 `a` 和 `b`，调用将如下所示：
- en: '[PRE251]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: When any dependencies change, the function in the first argument is executed
    again to return a new function to memoize. In the previous example, a new version
    of `memoizedCallback` is created every time `a` or `b` changes.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何依赖项发生变化时，第一个参数中的函数会再次执行，以返回一个新的函数进行记忆化。在先前的例子中，每当 `a` 或 `b` 发生变化时，就会创建一个新的
    `memoizedCallback` 版本。
- en: 'The type of the memoized function is inferred but can be explicitly defined
    in a generic parameter on `useCallback`. Here is an example of explicitly defining
    that the memoized function has no parameters and returns `void`:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化函数的类型是推断出来的，但可以在 `useCallback` 上的泛型参数中显式定义。以下是一个显式定义记忆化函数没有参数并返回 `void` 的例子：
- en: '[PRE252]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: A common use case for `useCallback` is to prevent unnecessary re-renders of
    child components. Before trying `useCallback`, we will take the time to understand
    when a component is re-rendered.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback` 的一个常见用例是防止子组件不必要的重新渲染。在尝试 `useCallback` 之前，我们将花时间了解组件何时会重新渲染。'
- en: Understanding when a component is re-rendered
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解组件何时重新渲染
- en: 'We already understand that a component re-renders when its state changes. Consider
    the following component:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，当组件的状态发生变化时，组件会重新渲染。考虑以下组件：
- en: '[PRE253]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: When `someState` changes, `SomeComponent` will re-render – for example, when
    the button is clicked. In addition, `ChildComponent` and `AnotherChildComponent`
    will re-render when `someState` changes. This is because a component is re-rendered
    when its parent is re-rendered.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `someState` 发生变化时，`SomeComponent` 将会重新渲染——例如，当按钮被点击时。此外，当 `someState` 发生变化时，`ChildComponent`
    和 `AnotherChildComponent` 也会重新渲染。这是因为当其父组件重新渲染时，组件也会重新渲染。
- en: 'It may seem like this re-rendering behavior will cause performance problems
    – particularly when a component is rendered near the top of a large component
    tree. However, it rarely does cause performance issues. This is because the DOM
    will only be updated after a re-render if the virtual DOM changes, and updating
    the DOM is the slow part of the process. In the preceding example, the DOM for
    `ChildComponent` won’t be updated when `SomeComponent` is re-rendered if the definition
    of `ChildComponent` is as follows:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重新渲染的行为可能会引起性能问题 – 尤其是在大型组件树的上层组件渲染时。然而，这很少会引起性能问题。这是因为只有当虚拟 DOM 发生变化时，DOM
    才会更新，而更新 DOM 是这个过程中的慢速部分。在先前的例子中，如果 `ChildComponent` 的定义如下，那么在 `SomeComponent`
    重新渲染时，`ChildComponent` 的 DOM 不会更新：
- en: '[PRE254]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: The DOM for `ChildComponent` won’t be updated during a re-render because the
    virtual DOM will be unchanged.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新渲染期间，`ChildComponent` 的 DOM 不会更新，因为虚拟 DOM 将保持不变。
- en: While this re-rendering behavior generally doesn’t cause performance problems,
    it can cause performance issues if a computationally expensive component is frequently
    re-rendered or a component with a slow side effect is frequently re-rendered.
    For example, we would want to avoid unnecessary re-renders in components with
    a side effect that fetches data.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种重新渲染的行为通常不会引起性能问题，但如果一个计算密集型的组件频繁重新渲染，或者一个具有缓慢副作用组件频繁重新渲染，它可能会引起性能问题。例如，我们希望避免在具有数据获取副作用的组件中不必要的重新渲染。
- en: 'There is a function called `memo` in React that can be used to prevent unnecessary
    re-renders. The memo function can be applied as follows to `ChildComponent` to
    prevent unnecessary re-renders:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: React 中有一个名为 `memo` 的函数，可以用来防止不必要的重新渲染。memo 函数可以按照以下方式应用于 `ChildComponent` 以防止不必要的重新渲染：
- en: '[PRE255]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: The `memo` function wraps the component and memoizes the result for a given
    set of props. The memoized function is then used during a re-render if the props
    are the same. Note that the preceding code snippet uses arrow function syntax
    so that the component can be a named export.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`memo` 函数包装了组件，并针对一组给定的属性对结果进行记忆化。如果属性相同，则在重新渲染期间使用记忆化的函数。请注意，前面的代码片段使用了箭头函数语法，以便组件可以作为命名导出。'
- en: In summary, React’s `memo` function can prevent the unnecessary re-rendering
    of slow components.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，React 的 `memo` 函数可以防止缓慢组件的不必要重新渲染。
- en: Next, we will use the `memo` function and the `useCallback` Hook to prevent
    unnecessary re-renders.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `memo` 函数和 `useCallback` 钩子来防止不必要的重新渲染。
- en: Using the callback Hook
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用回调钩子
- en: We will now refactor the `PersonScore` component by extracting the `Reset`.
    This will lead to unnecessary re-rendering of the `Reset` component, which we
    will resolve using React’s `memo` function and the `useCallback` Hook.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过提取 `Reset` 来重构 `PersonScore` 组件。这将导致 `Reset` 组件的不必要重新渲染，我们将使用 React 的
    `memo` 函数和 `useCallback` 钩子来解决这个问题。
- en: 'To do so, carry out the following steps. The code snippets used are available
    at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4/Section5-Using-the-callback-hook](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4/Section5-Using-the-callback-hook):'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请执行以下步骤。使用的代码片段可在 [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4/Section5-Using-the-callback-hook](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4/Section5-Using-the-callback-hook)
    找到：
- en: 'Start by creating a new file in the `src` folder for the reset button called
    `Reset.tsx` with the following content:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src` 文件夹中创建一个新的文件，名为 `Reset.tsx`，用于重置按钮，内容如下：
- en: '[PRE256]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE262]'
- en: The component takes in a click handler and displays the reset button. The component
    also outputs **render Reset** to the console so that we can clearly see when the
    component is re-rendered.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件接受一个点击处理程序并显示重置按钮。该组件还会将 **render Reset** 输出到控制台，以便我们可以清楚地看到组件何时重新渲染。
- en: 'Open `PersonScore.tsx` and import the `Reset` component:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PersonScore.tsx` 并导入 `Reset` 组件：
- en: '[PRE263]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'Replace the existing reset button with the new `Reset` component as follows:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式替换现有的重置按钮为新 `Reset` 组件：
- en: '[PRE264]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'Go to the app running in the browser and open React’s DevTools. Make sure the
    **Highlight updates when components render.** option is ticked in the **Components**
    panel’s settings:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往浏览器中运行的 app，打开 React 的 DevTools。确保在 **Components** 面板的设置中勾选了 **Highlight updates
    when components render.** 选项：
- en: '![Figure 4.9 – The re-render highlight option](img/B19051_04_09.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 重新渲染高亮选项](img/B19051_04_09.jpg)'
- en: Figure 4.9 – The re-render highlight option
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 重新渲染高亮选项
- en: In the browser, the `Reset` is unnecessarily re-rendered. You will also see
    the re-render highlight around the **Reset** button.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，`Reset` 不必要地重新渲染。你还会看到重新渲染高亮显示在 **Reset** 按钮周围。
- en: '![Figure 4.10 – The unnecessary re-renders of the Reset component](img/B19051_04_10.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 重置组件不必要的重新渲染](img/B19051_04_10.jpg)'
- en: Figure 4.10 – The unnecessary re-renders of the Reset component
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 重置组件不必要的重新渲染
- en: Use the browser’s DevTools to inspect the DOM. To do this, right-click on the
    `h3` element content was updated – none of the other elements are highlighted
    due to an update occurring.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用浏览器的 DevTools 检查 DOM。为此，右键单击 `h3` 元素内容被更新 – 由于没有其他元素因更新而高亮显示。
- en: '![Figure 4.11 – The h3 element was updated after a re-render](img/B19051_04_11.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 重新渲染后 h3 元素被更新](img/B19051_04_11.jpg)'
- en: Figure 4.11 – The h3 element was updated after a re-render
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 重新渲染后 h3 元素被更新
- en: Even though `Reset` is unnecessarily re-rendered, it doesn’t result in a DOM
    update. In addition, `Reset` isn’t computationally expensive and doesn’t contain
    any side effects. So, the unnecessary render isn’t really a performance problem.
    However, we will use this example to learn how to use React’s `memo` function,
    and the `useCallback` Hook can prevent the unnecessary render.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `Reset` 不必要地重新渲染，也不会导致 DOM 更新。此外，`Reset` 的计算成本不高，也不包含任何副作用。因此，不必要的渲染实际上并不是性能问题。然而，我们将使用这个例子来学习如何使用
    React 的 `memo` 函数，以及 `useCallback` 钩子可以防止不必要的渲染。
- en: 'We will now add React’s `memo` function to try to prevent unnecessary re-renders.
    Open `React.tsx` and add a React import statement to import `memo` at the top
    of the file:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加 React 的 `memo` 函数来尝试防止不必要的重新渲染。打开 `React.tsx` 并在文件顶部添加一个 React 导入语句以导入
    `memo`：
- en: '[PRE271]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'Now, wrap `memo` around the `Reset` component as follows:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照以下方式将 `memo` 包裹在 `Reset` 组件周围：
- en: '[PRE272]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'In addition, add the following line beneath the `Reset` component definition
    so that it has a meaningful name in React’s DevTools:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在 `Reset` 组件定义下方添加以下行，以便在 React 的 DevTools 中具有有意义的名称：
- en: '[PRE276]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE276]'
- en: In the browser, click the `Reset` is *still* unnecessarily re-rendered.
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，点击 `Reset` 仍然是不必要地重新渲染。
- en: 'We will use React’s DevTools to start to understand why Reset is still unnecessarily
    re-rendered when its result is memoized. Open the **Profiler** panel and click
    the cog icon to open the settings. Go to the **Profiler** settings section and
    make sure **Record why each component rendered while profiling.** is ticked:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 React 的 DevTools 来开始理解为什么当其结果被记忆化时，Reset 仍然不必要地重新渲染。打开 **Profiler** 面板并点击齿轮图标以打开设置。转到
    **Profiler** 设置部分并确保 **Record why each component rendered while profiling.** 被勾选：
- en: '![Figure 4.12 – Ensuring the Record why each component rendered while profiling.
    option is ticked](img/B19051_04_12.jpg)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – 确保 Record why each component rendered while profiling. 选项被勾选](img/B19051_04_12.jpg)'
- en: Figure 4.12 – Ensuring the Record why each component rendered while profiling.
    option is ticked
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 确保 Record why each component rendered while profiling. 选项被勾选
- en: Click the blue circle icon to start profiling and then click the **Add** button
    in our app. Click the red circle icon to stop profiling.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击蓝色圆圈图标开始分析，然后点击应用中的 **Add** 按钮。点击红色圆圈图标停止分析。
- en: 'In the flamegraph that appears, click the `Reset` component re-render:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的火焰图中，点击 `Reset` 组件的重新渲染：
- en: '![Figure 4.13 – Information about the Reset re-render](img/B19051_04_13.jpg)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – 重置重新渲染的信息](img/B19051_04_13.jpg)'
- en: Figure 4.13 – Information about the Reset re-render
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 重置重新渲染的信息
- en: So, the unnecessary `Reset` render is happening because the `onClick` prop changes.
    The `onClick` handler contains the same code, but a new instance of the function
    is created on every render. This means `onClick` will have a different reference
    on each render. The changing `onClick` prop reference means that the memorized
    result from `Reset` isn’t used and a re-render occurs instead.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不必要的 `Reset` 渲染发生是因为 `onClick` 属性发生了变化。`onClick` 处理程序包含相同的代码，但在每次渲染时都会创建一个新的函数实例。这意味着
    `onClick` 在每次渲染时将具有不同的引用。变化的 `onClick` 属性引用意味着从 `Reset` 中记忆的结果没有被使用，而是发生了重新渲染。
- en: 'We can use the `useCallback` Hook to memoize the `onClick` handler and prevent
    the re-render. Open `PersonScore.tsx` and start by refactoring the handler into
    a named function:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `useCallback` 钩子来记忆 `onClick` 处理程序并防止重新渲染。打开 `PersonScore.tsx` 并首先将处理程序重构为命名函数：
- en: '[PRE277]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE288]'
- en: 'Now, add `useCallback` to the React import statement:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `useCallback` 添加到 React 导入语句中：
- en: '[PRE289]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE295]'
- en: 'Lastly, wrap `useCallback` around the click handler we just created:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `useCallback` 包裹在我们刚刚创建的点击处理程序周围：
- en: '[PRE296]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE299]'
- en: Now, if you click the `Reset` is no longer unnecessarily re-rendered.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你点击 `重置`，它就不再会不必要地重新渲染。
- en: That completes our exploration of the `useCallback` Hook.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对 `useCallback` Hooks 的探索。
- en: 'Here’s a quick recap of everything we learned in this section:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对本节所学内容的快速回顾：
- en: A component is re-rendered when its parent is re-rendered.
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其父组件重新渲染时，组件会重新渲染。
- en: React’s `memo` function can be used to prevent unnecessary re-renders to child
    components.
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 的 `memo` 函数可以用来防止对子组件的不必要重新渲染。
- en: '`useCallback` can be used to memoize functions. This can be used to create
    a stable reference for function props passed to child components to prevent unnecessary
    re-renders.'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useCallback` 可以用来缓存函数。这可以用来为传递给子组件的函数属性创建一个稳定的引用，以防止不必要的重新渲染。'
- en: React’s `memo` function and `useCallback` should be used wisely – make sure
    they help performance before using them because they increase the complexity of
    the code.
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 的 `memo` 函数和 `useCallback` 应该明智地使用——在使用它们之前确保它们有助于性能，因为它们会增加代码的复杂性。
- en: Next, we will summarize the chapter.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将总结本章内容。
- en: Summary
  id: totrans-571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned that all React Hooks must be called at the top level
    of a function component and can’t be called conditionally.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到所有 React Hooks 都必须在函数组件的最高级别调用，并且不能有条件地调用。
- en: The `useEffect` Hook can be used to execute component side effects when it is
    rendered. We learned how to use `useEffect` to fetch data, which is a common use
    case.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` Hook 可以用来在组件渲染时执行组件副作用。我们学习了如何使用 `useEffect` 来获取数据，这是一个常见的用例。'
- en: '`useReducer` is an alternative to `useState` for using state, and we experienced
    using both approaches in our `PersonScore` example component. `useState` is excellent
    for primitive state values. `useReducer` is great for complex object state values,
    particularly when state changes depend on previous state values.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '`useReducer` 是 `useState` 用于使用状态的另一种选择，我们在 `PersonScore` 示例组件中体验了这两种方法。`useState`
    对于原始状态值非常出色。`useReducer` 对于复杂对象状态值非常好，尤其是在状态变化依赖于先前状态值时。'
- en: The `useRef` Hook creates a mutatable value and doesn’t cause a re-render when
    changed. We used `useRef` to set focus to an HTML element after it was rendered,
    which is a common use case.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRef` Hook 创建一个可变的值，在改变时不会引起重新渲染。我们使用 `useRef` 在渲染后设置 HTML 元素的焦点，这是一个常见的用例。'
- en: The `useMemo` and `useCallback` Hooks can be used to memoize values and functions,
    respectively, and can be used for performance optimization. The examples we used
    for these Hooks were a little contrived and using `useCallback` didn’t improve
    performance, so remember to check that the use of these Hooks does improve performance.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo` 和 `useCallback` Hooks 可以用来分别缓存值和函数，并且可以用于性能优化。我们用于这些 Hooks 的示例有点牵强，使用
    `useCallback` 并没有提高性能，所以请记住，使用这些 Hooks 确实可以提高性能。'
- en: So far in this book, the components we have created are unstyled. In the next
    chapter, we will learn several approaches for styling React components.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们创建的组件都是未加样式的。在下一章，我们将学习几种为 React 组件添加样式的途径。
- en: Questions
  id: totrans-578
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to check what you have learned about React Hooks:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以检查你对 React Hooks 的了解：
- en: The following component renders some text for 5 seconds. This is problematic
    though – what is the problem?
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下组件将渲染一些文本 5 秒。但这是有问题的——问题是什么？
- en: '[PRE300]'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE309]'
- en: The following code is a snippet from a React component that fetches some data
    and stores it in state. There are several problems with this code though – can
    you spot any of the problems?
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码是从一个 React 组件中摘取的，该组件获取一些数据并将其存储在状态中。尽管如此，这段代码有几个问题——你能找出任何问题吗？
- en: '[PRE310]'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE314]'
- en: How many times will the following component re-render in production mode when
    the button is clicked? Also, what will the button content be after one click?
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按钮被点击时，以下组件在生产模式下会重新渲染多少次？此外，点击一次后按钮的内容会是什么？
- en: '[PRE315]'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE328]'
- en: How many times will the following component re-render in production mode when
    the button is clicked? Also, what will the button content be after one click?
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按钮被点击时，以下组件在生产模式下会重新渲染多少次？此外，点击一次后按钮的内容会是什么？
- en: '[PRE329]'
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE340]'
- en: 'Consider the following `reducer` function:'
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下 `reducer` 函数：
- en: '[PRE341]'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE354]'
- en: What will the type of the `action` parameter be narrowed down to in the `"backwards"`
    switch branch?
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `"backwards"` 分支中，`action` 参数的类型会被缩小到什么？
- en: 'Consider the following `Counter` component:'
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下 `Counter` 组件：
- en: '[PRE355]'
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-649
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-650
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-652
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE365]'
- en: What will the button content be after it is clicked once?
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 点击一次后按钮的内容会是什么？
- en: 'Consider the following `Counter` component:'
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下`Counter`组件：
- en: '[PRE366]'
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-658
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-659
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-663
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-664
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE376]'
- en: What will the button content be after it is clicked twice?
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 点击两次后按钮的内容会是什么？
- en: Answers
  id: totrans-667
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'The problem with the component is that both `useState` and `useEffect` are
    called conditionally (when the `text` prop is defined), and React doesn’t allow
    its Hooks to be called conditionally. Placing the Hooks before the `if` statement
    resolves the problem:'
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件的问题在于`useState`和`useEffect`都是条件性地调用的（当`text`属性定义时），React不允许其钩子被条件性地调用。在`if`语句之前放置钩子可以解决这个问题：
- en: '[PRE377]'
  id: totrans-669
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-670
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-671
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-675
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-677
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE386]'
- en: 'The main problem with the code is that the effect function can’t be marked
    as asynchronous with the `async` keyword. A solution is to revert to the older
    promise syntax:'
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的主要问题是效果函数不能使用`async`关键字标记为异步。一个解决方案是恢复到较旧的promise语法：
- en: '[PRE387]'
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-681
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-683
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE390]'
- en: 'The other major problem is that no dependencies are defined in the call to
    `useEffect`. This means the effect function will be executed on every render.
    The effect function sets some state, which causes a re-render. So, the component
    will keep re-rendering, and the effect function will keep executing indefinitely.
    An empty array passed into the second argument of `useEffect` will resolve the
    problem:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个主要问题是调用`useEffect`时没有定义依赖项。这意味着效果函数将在每次渲染时执行。效果函数设置了一些状态，这导致重新渲染。因此，组件将不断重新渲染，效果函数将无限期地执行。将空数组传递到`useEffect`的第二个参数将解决问题：
- en: '[PRE391]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: 'Another problem is that the `data` state will have the `any[]` type, which
    isn’t ideal. In this case, it is probably better to explicitly define the type
    of the state as follows:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是在`data`状态中将具有`any[]`类型，这并不理想。在这种情况下，可能最好显式定义状态类型如下：
- en: '[PRE392]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: 'The last problem is that the data state could be set after the component has
    been unmounted, which can lead to memory leaks. A solution is to set a flag when
    the component is unmounted and not set the state when the flag is set:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题是在组件卸载之后可能设置数据状态，这可能导致内存泄漏。一个解决方案是在组件卸载时设置一个标志，并在标志设置时不设置状态：
- en: '[PRE393]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: The button will only render once in production mode because state changes are
    batched.
  id: totrans-690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产模式下，按钮只会渲染一次，因为状态更改是分批处理的。
- en: The state isn’t changed until the next render, so clicking the button once will
    result in `count` being set to `1`, which means the button content will be `1`.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 状态直到下一次渲染才会改变，所以点击一次按钮将导致`count`被设置为`1`，这意味着按钮内容将是`1`。
- en: The button will not re-render when the button is clicked because changes to
    a ref don’t cause a re-render.
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按钮被点击时，按钮不会重新渲染，因为对ref的更改不会导致重新渲染。
- en: The `counter` ref will be incremented when the button is clicked. However, because
    a re-render doesn’t occur, the button content will still be `0`.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被点击时，`counter`引用将增加。然而，因为不会发生重新渲染，按钮内容仍然是`0`。
- en: 'TypeScript will narrow the type of the `action` parameter to `{ type: ''backwards`
    `''; steps: number }` in the `''backwards''` switch branch.'
  id: totrans-694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`''backwards''`分支中，TypeScript将`action`参数的类型缩小为`{ type: ''backwards''; steps:
    number }`。'
- en: The button’s content will always be `0` because the initial count of `0` is
    memoized and never updated.
  id: totrans-695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮的内容始终是`0`，因为初始计数`0`被记忆化且从未更新。
- en: The button content will be `1` after one click and will stay as `1` after subsequent
    clicks. So, after two clicks, it will be `1`.
  id: totrans-696
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击一次后按钮内容将是`1`，在随后的点击中保持为`1`。所以，点击两次后，它将是`1`。
- en: The key here is that the `handleClick` function is only created when the component
    is initially rendered because `useCallback` memoizes it. So, the `count` state
    will always be `0` within the memoized function. This means the `count` state
    will always be updated to `1`, which will appear in the button content.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于`handleClick`函数仅在组件最初渲染时创建，因为`useCallback`记忆化了它。所以，在记忆化的函数中，`count`状态始终是`0`。这意味着`count`状态将始终更新为`1`，这将出现在按钮内容中。
- en: 'Part 2: App Fundamentals'
  id: totrans-698
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分：应用基础
- en: This part covers the fundamental topics for building apps that are outside the
    core of React. These topics are styling, clientside routing, and forms. Each topic
    involves different approaches that you can take, along with the benefits of each
    one. We will also cover several popular third-party libraries that are commonly
    used for these parts of an application.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分涵盖了构建React核心之外的应用程序的基本主题。这些主题包括样式、客户端路由和表单。每个主题都涉及你可以采取的不同方法，以及每种方法的优点。我们还将介绍几个常用的第三方库，这些库通常用于应用程序的这些部分。
- en: 'This part includes the following chapters:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分包括以下章节：
- en: '[*Chapter 5*](B19051_05.xhtml#_idTextAnchor127), *Approaches to Styling React
    Frontends*'
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B19051_05.xhtml#_idTextAnchor127), *React前端样式化方法*'
- en: '[*Chapter 6*](B19051_06.xhtml#_idTextAnchor151), *Routing with React Router*'
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19051_06.xhtml#_idTextAnchor151), *使用React Router进行路由*'
- en: '[*Chapter 7*](B19051_07.xhtml#_idTextAnchor188), *Working with Forms*'
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19051_07.xhtml#_idTextAnchor188), *使用表单*'
