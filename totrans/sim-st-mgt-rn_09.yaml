- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Using React Query for Server-Side-Driven State Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Query进行服务器端驱动状态管理
- en: Welcome, my dear reader, to the last chapter describing state management solutions
    for our Funbook app. In the previous chapter, we looked at the youngest state
    management library (as of the writing of this book) – **Jotai**. Jotai is a minimal
    solution, based on ideas proposed by the **Facebook** team in their open source
    library – **Recoil**. **React** **Query** is minimal as well but in a very different
    sense. React Query is created for managing fetching and mutating data on the server.
    In this chapter, we will look at what React Query has to offer. We will start
    by taking a broad look at this library; we will then implement it for data fetching.
    With our current app setup, we don’t have a real backend server to communicate
    with, so we can only look at mutating data in theory. We will also look at a few
    specialized utilities created for **React** **Native** by the React Query team.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎您，我亲爱的读者，来到最后一章，本章将描述我们Funbook应用的状态管理解决方案。在前一章中，我们探讨了（截至本书编写时）最年轻的状态管理库——**Jotai**。Jotai是一个基于Facebook团队在他们的开源库**Recoil**中提出的想法的极简解决方案。**React
    Query**同样也是极简的，但意义却大不相同。React Query是为了在服务器上管理获取和修改数据而创建的。在本章中，我们将探讨React Query能提供什么。我们将首先对这个库进行广泛的了解；然后我们将实现它用于数据获取。鉴于我们当前的应用设置，我们没有真实的后端服务器进行通信，所以我们只能从理论上查看数据修改。我们还将查看React
    Query团队为**React Native**创建的一些专用实用工具。
- en: 'Here’s a list of topics we will cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将在本章中涵盖的主题列表：
- en: What is React Query and why is it in this book?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是React Query，为什么它会在本书中？
- en: Installing and configuring React Query
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置React Query
- en: Using React Query for data fetching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Query进行数据获取
- en: Other React Query functionalities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他React Query功能
- en: React Query utilities for React Native
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Query的React Native实用工具
- en: By the end of this chapter, you will have a good understanding of how you can
    use React Query to improve your developer experience and your code bases. You
    will have a good knowledge of how to handle fetching data with React Query and
    a general knowledge of other functionalities of this library.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将很好地理解如何使用React Query来提升你的开发体验和代码库。你将掌握如何使用React Query处理数据获取，并对该库的其他功能有一般了解。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to follow along with this chapter, you will need some knowledge of
    **JavaScript** and **ReactJS**. If you have followed at least *Chapters 1* through
    *4* of this book, you should be able to go forward without any issues.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟上本章的内容，你需要具备一些**JavaScript**和**ReactJS**的知识。如果你已经阅读了本书的至少**第1章**到**第4章**，你应该能够无任何问题地继续前进。
- en: Feel free to use an IDE of your choice, as **React** **Native** does not need
    any specific functionality. Currently, the most popular IDEs for frontend developers
    are Microsoft’s VSCode, Atom, Sublime Text, and WebStorm.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随意使用你选择的IDE，因为**React Native**不需要任何特定功能。目前，前端开发者中最受欢迎的IDE包括微软的VSCode、Atom、Sublime
    Text和WebStorm。
- en: The code snippets provided in this chapter are here to illustrate what we should
    be doing with the code. They do not provide the whole picture. For a better experience
    while coding alongside reading this chapter, please open the GitHub repo in your
    IDE and look at the files in there. You can either start with the files in the
    folder named `example-app-full` or `chapter-9` If you start with `example-app-full`
    you will be responsible for implementing the solutions described in this chapter.
    If you choose to look at `chapter-9` you will see the entire solution implemented
    by me.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的代码片段旨在说明我们应该如何使用代码。它们并不提供完整的画面。为了在阅读本章的同时获得更好的编码体验，请在你的IDE中打开GitHub仓库，查看其中的文件。你可以从名为`example-app-full`或`chapter-9`的文件夹中的文件开始。如果你从`example-app-full`开始，你将负责实现本章中描述的解决方案。如果你选择查看`chapter-9`，你将看到我实现的整个解决方案。
- en: 'If you get stuck or lost, you can check the code in the GitHub repo: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-9](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-9).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到困难或迷失方向，可以查看GitHub仓库中的代码：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-9](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-9)。
- en: What is React Query and why is it in this book?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是React Query，为什么它会在本书中？
- en: 'First things first: let’s talk about the name of this library. In this chapter,
    I use the name React Query, it is also a commonly used name. However, the creator
    of React Query, *Tanner Linsley*, did some restructuring in 2022, in the open
    source libraries that he owns and maintains. He created an umbrella name, **TanStack**,
    and placed a plethora of libraries under this name. And so, React Query became
    TanStack Query, as of React Query version 4\. You can find a link to the TanStack
    home page in the *Further reading* section at end of this chapter.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈这个库的名字。在本章中，我使用的是 React Query 这个名字，它也是一个常用的名字。然而，React Query 的创造者 *Tanner
    Linsley* 在 2022 年对他拥有的和维护的开源库进行了一些重构。他创建了一个总称，**TanStack**，并将大量库放在这个名字下。因此，React
    Query 变成了 TanStack Query，从 React Query 版本 4 开始。你可以在本章末尾的 *进一步阅读* 部分找到 TanStack
    主页的链接。
- en: 'Now that we have the name out of the way, let’s talk about the place of React
    Query in this book. React Query is *not* a state management library. It’s a library
    offering a solution for comfortable fetching and data mutations on the server.
    Why are we talking about it then? Because it turns out that efficient communication
    with the server can replace any need for global state management. Given our real-life
    social media app clone, we’ve been managing liked images in every chapter. What
    if, instead of working with the app state, every time a user likes an image, we
    sent that information to the server? Or when the user visits the **FavoritedImages**
    surface we pull the latest version of the list from the server? You may think:
    “Boy, that would be a lot of requests! A lot of loading states and the app being
    useless…” And you would be right! Except if you use React Query. React Query not
    only facilitates data fetching, but it also manages cached values, refreshing
    values, background fetching, and much more.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了名字的问题，让我们来谈谈 React Query 在本书中的位置。React Query **不是**一个状态管理库。它是一个提供在服务器上舒适地进行数据获取和数据变更的解决方案的库。为什么我们要讨论它呢？因为高效地与服务器通信可以替代任何全局状态管理的需要。鉴于我们现实生活中的社交媒体应用克隆，我们在每一章中都在管理点赞的图片。如果我们每次用户点赞图片时都向服务器发送那个信息，或者当用户访问
    **FavoritedImages** 表面时从服务器拉取列表的最新版本，会怎么样呢？你可能认为：“哇，那会有很多请求！很多加载状态，应用就会变得毫无用处……”
    你是对的！除非你使用 React Query。React Query 不仅简化了数据获取，还管理了缓存值、刷新值、后台获取以及更多。
- en: Now that we have a theoretical understanding of what React Query is, we can
    get to coding. Let’s play with this non-state-management library.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 React Query 有了一个理论上的理解，我们可以开始编码了。让我们来玩一玩这个非状态管理库。
- en: Installing and configuring React Query
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置 React Query
- en: 'Installing this library is no different from any other dependency, we need
    to run an installation script. To do this using `npm`, enter the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这个库与其他依赖项没有不同，我们需要运行一个安装脚本。要使用 `npm` 来做这件事，请输入以下内容：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or if you would prefer to use `yarn`, enter the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你更喜欢使用 `yarn`，请输入以下内容：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the library is installed, we will need to add some minimal boilerplate.
    We will need to let our app know that we’re using React Query. We will need to
    use a special wrapper. Do you see where I’m going with this? Yes! We will use
    a provider as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了库，我们需要添加一些最小化的模板代码。我们需要让我们的应用知道我们正在使用 React Query。我们需要使用一个特殊的包装器。你看到我在说什么了吗？是的！我们将使用一个提供者，如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will start by importing the necessary functions from React Query – `QueryClient`
    and `QueryClientProvider`. Then, we will create a new `QueryClient` function and
    pass it to `QueryClientProvider`. Our app is ready to use React Query functionalities
    instead of simple fetching.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先从 React Query 导入必要的函数——`QueryClient` 和 `QueryClientProvider`。然后，我们将创建一个新的
    `QueryClient` 函数并将其传递给 `QueryClientProvider`。我们的应用现在可以使用 React Query 的功能，而不是简单的获取。
- en: This is a good moment to make sure the app is running correctly on your simulator
    or device.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个确保你的应用在模拟器或设备上正确运行的好时机。
- en: Once you have made sure installing new dependencies did not break anything unexpected
    in your project, we will be ready to implement real data fetching with React Query
    in the next section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确认安装新的依赖项没有在你的项目中造成意外的破坏，我们就可以在下一节中实现使用 React Query 的真实数据获取了。
- en: Using React Query for data fetching
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Query 进行数据获取
- en: 'As you know, we need to fetch a few different pieces of data for our app. We
    will fetch a list of avatars, a list of images for the feed surface, a list of
    images for the `FavoritedImages` surface, and a list of conversations. We are
    free to add the React Query fetching wherever we like. For simple queries, we
    can simply use the `useQuery` hook provided by the library in our components.
    We can also write our own custom hooks, holding more logic or conditions. Let’s
    start by looking at the simplest possible example: querying the server to check
    whether the user is logged in.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，我们需要为我们的应用获取一些不同的数据。我们将获取头像列表、用于动态界面的图片列表、用于“收藏的图片”界面的图片列表以及会话列表。我们可以自由地在任何地方添加
    React Query 的获取操作。对于简单的查询，我们可以在组件中使用库提供的 `useQuery` 钩子。我们也可以编写自己的自定义钩子，包含更多的逻辑或条件。让我们从一个最简单的例子开始：查询服务器以检查用户是否已登录。
- en: 'In order to use a React Query hook in the top-level component where we set
    up our navigation to display either the login screen or not, we will need to reorganize
    our code a little bit. We cannot have `QueryClientProvider` in the return statement
    of the same component trying to use a `useQuery` hook. Let’s change the name of
    the main component from `App` to `AppWrapped` and let’s add this new app component
    in the `App.js` file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在设置导航以显示登录屏幕或否的顶层组件中使用 React Query 钩子，我们需要稍微重新组织一下我们的代码。我们不能在同一个组件的返回语句中同时使用
    `QueryClientProvider` 和 `useQuery` 钩子。让我们将主组件的名称从 `App` 改为 `AppWrapped`，并在 `App.js`
    文件中添加这个新的应用组件：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let’s change the name of the main component from `App` to `AppWrapped`,
    and let’s remove `QueryClientProvider` from the child component. Let me remind
    you that if you ever get lost in the code examples, you can take a look at the
    GitHub repo: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-9](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-9).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将主组件的名称从 `App` 改为 `AppWrapped`，并从子组件中移除 `QueryClientProvider`。让我提醒你，如果你在代码示例中迷路了，可以查看
    GitHub 仓库：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-9](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-9)。
- en: 'Our `AppWrapped` component should be ready to use the `useQuery` hook. Make
    sure you start by importing it as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `AppWrapped` 组件应该准备好使用 `useQuery` 钩子。确保你首先按照以下方式导入它：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After you’ve imported the `useQuery` hook, you need to create a function responsible
    for fetching and awaiting data from the server. This is the `fetchLoginStatus`
    function, which we will pass to the `useQuery` hook. This function can be created
    in any file you would like. Once we have the fetching set up, we need to use the
    `useQuery` hook in the component. We pull in a destructured object key data, where
    we check the `loggedInStatus` value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在你导入 `useQuery` 钩子之后，你需要创建一个负责从服务器获取和等待数据的函数。这个函数是 `fetchLoginStatus`，我们将将其传递给
    `useQuery` 钩子。这个函数可以创建在任何你想要的文件中。一旦我们设置了获取操作，我们需要在组件中使用 `useQuery` 钩子。我们引入了一个解构的对象键
    `data`，其中我们检查 `loggedInStatus` 的值。
- en: Object destructuring
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对象解构
- en: Depending on how often you use modern JavaScript, you may have noticed the destructuring
    syntax, where the `const` keyword is followed by items in curly or square brackets.
    This syntax is called destructuring assignment and is used to unpack values from
    arrays (square brackets), objects, or properties (curly brackets).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用现代 JavaScript 的频率，你可能已经注意到了解构语法，其中 `const` 关键字后面跟着花括号或方括号中的项。这种语法称为解构赋值，用于从数组（方括号）、对象或属性（花括号）中提取值。
- en: '`const { data } = objectWithADataItem` is the same as `const data =` `objectWithADataItem.data`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`const { data } = objectWithADataItem` 与 `const data = objectWithADataItem.data`
    是相同的。'
- en: Now that we have seen a simple example, let’s look at something slightly more
    complex and create a custom hook and a dependent query.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一个简单的例子，让我们看看稍微复杂一点的内容，创建一个自定义钩子和一个依赖查询。
- en: Fetching image data
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取图像数据
- en: 'Fetching image data could be just as simple as fetching the login state data;
    however, I would like to talk about something more complicated. So, we will artificially
    complicate our lives by making sure the images are fetched only after the user
    is logged in. We will start by creating a custom hook called `useCustomImageQuery`
    inside a newly created `queries` folder. Our custom hook will return a `useQuery`
    hook:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 获取图像数据可能就像获取登录状态数据一样简单；然而，我想谈谈一些更复杂的事情。所以，我们将通过确保只有在用户登录后才能获取图像来人为地使我们的生活复杂化。我们将从在新建的
    `queries` 文件夹内创建一个名为 `useCustomImageQuery` 的自定义钩子开始。我们的自定义钩子将返回一个 `useQuery` 钩子：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We started by importing the necessary `useQuery` function and our utility `requestBase`.
    Next, we created our fetching function called `getImages`. This function fetches
    data from a given API endpoint and returns it. Finally, we created a custom hook
    called `useCustomImageQuery`. On the first line of the hook, we check the `loginState`
    query. It looks different than in `App.js` where we used it first, doesn’t it?
    It has only one parameter: `loginState`. This parameter is called a **query key**
    in the React Query world and it is literally a key to unlocking the power of React
    Query. Using this key, you can access any and all previously fetched data; you
    could also invalidate it manually or mutate it. As for us, we only need to check
    the login status now, using this particular query key.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入了必要的 `useQuery` 函数和我们的工具函数 `requestBase`。接下来，我们创建了一个名为 `getImages` 的获取函数。这个函数从指定的
    API 端点获取数据并返回它。最后，我们创建了一个自定义钩子，名为 `useCustomImageQuery`。在钩子的第一行，我们检查 `loginState`
    查询。它看起来与我们在 `App.js` 中首次使用它的样子不同，不是吗？它只有一个参数：`loginState`。在这个 React Query 的世界里，这个参数被称为
    **查询键**，它实际上是解锁 React Query 力量的钥匙。使用这个键，你可以访问任何之前获取的数据；你也可以手动使其无效或修改它。至于我们，我们现在只需要检查登录状态，使用这个特定的查询键。
- en: 'The `return` statement of our custom hook consists of a `useQuery` hook with
    three parameters. In the first place, we have the awesomely important query key,
    `imageList`. Next, we see the call to the fetching function. Last but not least,
    we have a configuration object holding a key called `enabled`. This key determines
    when the given query should be called. In our case, the query will be called when
    the result of the `loginStatus` query returns the value of `true`. We just successfully
    set up React Query to fetch images. All that is left is to display them. Let’s
    go to the `ListOfFavorited` component where we will replace the context call with
    the following custom hook:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自定义钩子的 `return` 语句由一个带有三个参数的 `useQuery` 钩子组成。首先，我们有至关重要的查询键，`imageList`。接下来，我们看到对获取函数的调用。最后但同样重要的是，我们有一个包含名为
    `enabled` 的键的配置对象。这个键决定了何时调用给定的查询。在我们的例子中，当 `loginStatus` 查询的结果返回 `true` 值时，将调用查询。我们刚刚成功设置了
    React Query 来获取图像。剩下要做的就是显示它们。让我们转到 `ListOfFavorited` 组件，我们将用以下自定义钩子替换上下文调用：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If everything went according to plan, you should be able to run the application
    now and see a list of favorited images, which is pulled by React Query from the
    backend. If you run into any trouble, remember that the custom hook we created
    is just another function, and can be debugged as such. You can put `console.log`
    in the component, in the hook, or in the `getImages` function called by the hook.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按计划进行，你现在应该能够运行应用程序并看到由 React Query 从后端拉取的收藏图像列表。如果你遇到任何问题，请记住，我们创建的自定义钩子只是一个函数，可以像这样进行调试。你可以在组件中、在钩子中或在钩子调用的
    `getImages` 函数中放置 `console.log`。
- en: Hopefully, you were able to set up everything smoothly. In this section, we
    practiced using React Query for fetching and displaying data. We leveraged ReactJS
    knowledge – because we created a custom hook – but React Query hooks can be set
    up in many ways. Given that our app has a fake backend that can only serve data,
    this is as far as we can go in practical usage of React Query. I invite you though,
    my dear reader, to continue reading and find out what other great functionalities
    this library holds.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能够顺利地设置好一切。在本节中，我们练习了使用 React Query 来获取和显示数据。我们利用了 ReactJS 的知识——因为我们创建了一个自定义钩子——但
    React Query 钩子可以以多种方式设置。鉴于我们的应用程序有一个只能提供数据的模拟后端，这就是我们在 React Query 的实际使用中能走多远。不过，我亲爱的读者，我邀请你继续阅读，了解这个库还包含哪些其他优秀功能。
- en: Other React Query Functionalities
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他 React Query 功能
- en: 'As stated above, we can’t use React Query in our example app to mutate data
    on the server because our backend is not robust enough. In a real-life application,
    you would most probably use an API that accepts a `POST` request just as well
    as a `GET` request. In these cases, you would be able to change data with the
    help of React Query. In order to do so, we are provided with another specialized
    hook: `useMutation`. Here’s what this hook would look like if we could use it
    for the favorited images:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，我们无法在我们的示例应用中使用React Query在服务器上突变数据，因为我们的后端不够健壮。在实际应用中，你可能会使用一个既能接受`POST`请求也能接受`GET`请求的API。在这些情况下，你将能够借助React
    Query来更改数据。为了做到这一点，我们得到了另一个专门的钩子：`useMutation`。以下是我们如果能够使用它来处理收藏图片时这个钩子的样子：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding function is very simple. It wraps a `fetch` call in a React Query
    utility. This utility offers us a few things, such as the fact that it has the
    following states: `isIdle`, `isLoading`, `isError`, and `isSuccess`. We can check
    these states and update the view accordingly. We would use this mutation in `ImageDetailsmodal`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数非常简单。它将一个`fetch`调用包裹在React Query实用工具中。这个实用工具为我们提供了一些东西，比如它有以下状态：`isIdle`、`isLoading`、`isError`和`isSuccess`。我们可以检查这些状态并根据情况更新视图。我们将在`ImageDetailsmodal`中使用这个突变：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let me reiterate: we are doing a dry run of sending data to the server because
    our app’s backend cannot handle a `POST` request.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我重申：我们正在进行发送数据到服务器的干运行，因为我们的应用后端无法处理`POST`请求。
- en: In the preceding code, we started by adding a React Query mutation function
    to `ImageDetailsModal`. We passed it into the `Pressable` component. Then, inside
    the `Pressable` component, we added a ternary operator to check whether the mutation
    is in a loading state. In case it is, we display a `Text` component saying `isSucccess`
    and `isError` as well and you would probably handle loading more gracefully.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先向`ImageDetailsModal`添加了一个React Query突变函数。我们将其传递给`Pressable`组件。然后，在`Pressable`组件内部，我们添加了一个三元运算符来检查突变是否处于加载状态。如果是的话，我们将显示一个`Text`组件，显示`isSucccess`和`isError`，你可能会更优雅地处理加载。
- en: 'This is all nice, but the way we implemented the mutation above we would still
    need to re-fetch the data traditionally to have the latest version in the `ListOfFavorites`
    component. Unless, we use the full power of React Query and update the cached
    version of data, fetched previously through the `useCustomImageQuery` hook! Here’s
    what we would need to change in the mutation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很棒，但按照我们上面实现突变的方式，我们仍然需要传统地重新获取数据，以便在`ListOfFavorites`组件中获取最新版本。除非我们使用React
    Query的全部力量来更新之前通过`useCustomImageQuery`钩子获取的数据的缓存版本！以下是我们在突变中需要更改的内容：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code snippet, we started by extracting the `fetch` function
    for better readability. We then add `onSuccess` logic to the mutation and we tell
    it to update the item marked by the `imageList` query key with the new data. Thanks
    to this strategy we will not have to manually update the `imageList` data every
    time a mutation occurs. You can read more about updating after mutation responses
    in the TanStack documentation, linked in the *Further* *reading* section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先提取了`fetch`函数以提高可读性。然后，我们将`onSuccess`逻辑添加到突变中，并告诉它使用`imageList`查询键更新标记的项目的新数据。多亏了这个策略，我们不必每次突变发生时都手动更新`imageList`数据。你可以在*进一步阅读*部分链接的TanStack文档中了解更多关于突变响应后更新的信息。
- en: 'We have covered the two most important aspects of React Query: fetching and
    mutating data. However, there’s much more functionality to be taken advantage
    of in a real-life project. You can check the fetching status, just like we did
    with the example mutation. You can also do parallel queries for fetching data
    simultaneously. If you want to, you can set initial data to fill your views before
    fetching is complete. It is also possible to pause or disable queries whenever
    you need. For large datasets, there is a special type of query, a paginated query,
    which will batch data into consumable chunks. In case your data is infinite, React
    Query provides utilities for infinite queries. Many big apps may take advantage
    of prefetching data on page load.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了React Query的两个最重要的方面：获取和突变数据。然而，在实际项目中还有很多更多功能可以利用。你可以检查获取状态，就像我们在示例突变中所做的那样。你也可以进行并行查询以同时获取数据。如果你想的话，你可以在获取完成之前设置初始数据来填充你的视图。你也可以在任何需要的时候暂停或禁用查询。对于大型数据集，有一种特殊的查询类型，即分页查询，它将数据批量处理成可消费的块。如果你的数据是无限的，React
    Query提供了无限查询的实用工具。许多大型应用可能会利用页面加载时预取数据。
- en: I encourage you, my dear reader, to read the React Query documentation to be
    able to grasp all the possible solutions it offers. I was surprised myself while
    using React Query by how many common problems are solved out of the box by this
    library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您，亲爱的读者，阅读React Query文档，以便能够掌握它提供的所有可能的解决方案。我自己在使用React Query时也感到惊讶，因为这个库可以解决许多常见问题。
- en: React Query utilities for React Native
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native的React Query实用工具
- en: As we all know, React Native has its own quirks as compared to pure ReactJS.
    React Query doesn’t leave managing those quirks to the developers, but rather
    steps up with some interesting solutions. For example, there’s an `onlineManager`
    that can be added to React Native apps to have our apps reconnect when they are
    online. If we would like to refresh or refetch data when the app is focused, we
    can use React Query’s `focusManager` together with React Native’s `AppState`.
    In some cases, we may want to refetch data when a specific screen in our app is
    focused, and React Query offers a solution for that use case as well. If you want
    to read about these utilities and how to use them in more detail, head over to
    the TanStack documentation at [https://tanstack.com/query/v4/docs/react-native](https://tanstack.com/query/v4/docs/react-native).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，与纯ReactJS相比，React Native有其独特的特性。React Query并没有将管理这些特性的任务留给开发者，而是提供了一些有趣的解决方案。例如，有一个`onlineManager`可以添加到React
    Native应用中，以便当应用在线时重新连接。如果我们希望在应用聚焦时刷新或重新获取数据，我们可以使用React Query的`focusManager`与React
    Native的`AppState`一起使用。在某些情况下，我们可能希望在应用中特定屏幕聚焦时重新获取数据，React Query也为此用例提供了解决方案。如果您想详细了解这些实用工具及其使用方法，请访问TanStack文档[https://tanstack.com/query/v4/docs/react-native](https://tanstack.com/query/v4/docs/react-native)。
- en: Summary
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: React Query is battle tested for scaling applications and can be a great solution
    for all sorts of projects. In this chapter, we installed it in the Funbook app
    and added it to the app. We didn’t configure anything specific, as our project
    is small and didn’t require any changes from the default configuration. We then
    looked at how a simple data fetching mechanism can be used for checking the login
    status of the user. Next, we created and used another, more complex, data-fetching
    hook with a dependency. We displayed the fetched data and then we took a tour
    of other React Query utilities. React Query is the last stop in our journey through
    the world of state management libraries for React Native apps. I hope you enjoyed
    the ride!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: React Query经过实战检验，适用于扩展应用程序，并且可以成为各种项目的绝佳解决方案。在本章中，我们在Funbook应用中安装了它，并将其添加到应用中。由于我们的项目规模较小，不需要对默认配置进行任何更改，所以我们没有进行任何特定的配置。然后，我们探讨了如何使用简单的数据获取机制来检查用户的登录状态。接下来，我们创建并使用了一个具有依赖关系的更复杂的数据获取钩子。我们展示了获取到的数据，然后我们对其他React
    Query实用工具进行了浏览。React Query是我们穿越React Native应用状态管理库世界的最后一站。我希望您喜欢这次旅程！
- en: I invite you, my dear reader, to accompany me to the last chapter, where we
    will summarize everything we have learned on the topic of state management in
    React Native apps.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我邀请您，亲爱的读者，与我一起进入最后一章，我们将总结我们在React Native应用状态管理主题上所学的所有内容。
- en: Further reading
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://tanstack.com/](https://tanstack.com/) – The TanStack home page.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://tanstack.com/](https://tanstack.com/) – TanStack主页。'
- en: '[https://tanstack.com/query/v4/docs/guides/updates-from-mutation-responses](https://tanstack.com/query/v4/docs/guides/updates-from-mutation-responses)
    – TanStack Query, *Updates from* *Mutation Responses.*'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://tanstack.com/query/v4/docs/guides/updates-from-mutation-responses](https://tanstack.com/query/v4/docs/guides/updates-from-mutation-responses)
    – TanStack Query，*来自* *突变响应* *的更新。*'
- en: Part 4 – Summary
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分 – 摘要
- en: In this part, readers will get an overview of all the different solutions covered
    throughout the book.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，读者将概述本书涵盖的所有不同解决方案。
- en: 'This part includes the following chapter:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 10*](B18396_10.xhtml#_idTextAnchor122), *Appendix*'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18396_10.xhtml#_idTextAnchor122)，*附录*'
