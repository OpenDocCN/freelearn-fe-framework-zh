- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Testing Angular Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Angular 应用程序
- en: Writing automated tests for your applications is just as important as writing
    the application code. Many developers don’t like to write tests or skip them altogether
    because they feel it’s too time-consuming, but as your applications and workspace
    grow, having automated tests becomes ever more critical. When working on an extensive
    application, the chances are significant that your changes will impact many things
    throughout the application. Small changes can affect many things, which becomes
    even more apparent when you’re making changes in a library used in many applications.
    You’ll often find yourself in a scenario where you make changes and don’t even
    know every application surface your changes will impact. Because you don’t want
    to break features, you don’t want to work on or manually test the entire workspace
    each time you make a change; you need automated tests that can test all affected
    code for you. Automated tests will help you look at your code differently; they
    can help you write better, more sturdy code. Automated tests will also catch bugs
    at an early stage and should give you the confidence to safely release code changes
    to production once all tests have successfully passed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的应用程序编写自动化测试与编写应用程序代码一样重要。许多开发者不喜欢编写测试或者完全跳过它们，因为他们觉得这太耗时了，但随着您的应用程序和工作空间的增长，拥有自动化测试变得越来越关键。当您在一个庞大的应用程序上工作时，您的更改可能会影响整个应用程序中的许多方面。小的更改可能会影响许多事物，当您在一个被许多应用程序使用的库中进行更改时，这一点尤为明显。您经常会发现自己处于这样的场景中：做出更改，甚至不知道您的更改会影响哪些应用程序的表面。因为您不想破坏功能，所以您不想每次更改时都手动处理或手动测试整个工作空间；您需要能够为您测试所有受影响代码的自动化测试。自动化测试将帮助您以不同的方式看待您的代码；它们可以帮助您编写更好、更坚固的代码。自动化测试还会在早期阶段捕捉到错误，并且应该让您有信心在所有测试成功通过后安全地将代码更改发布到生产环境。
- en: This chapter will dive into different types of automated tests and their purpose
    within your Angular applications. Next, you will dive deeper into the topic of
    unit testing and get some hands-on experience by writing unit tests for our Nx
    monorepo using Jest. Lastly, you will learn more about end-to-end testing and
    gain some experience writing end-to-end tests using Cypress. By the end of this
    chapter, you will understand why you need automated tests and how to write them
    for your Angular applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入探讨不同类型的自动化测试以及它们在您的 Angular 应用程序中的目的。接下来，您将更深入地探讨单元测试的主题，并通过为我们的 Nx monorepo
    编写单元测试来获得一些实践经验。最后，您将了解更多关于端到端测试的知识，并获得一些使用 Cypress 编写端到端测试的经验。到本章结束时，您将了解为什么您需要自动化测试以及如何为您的
    Angular 应用程序编写它们。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Different types of application testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的应用程序测试
- en: Unit testing of Angular applications using Jest
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jest 对 Angular 应用程序进行单元测试
- en: End-to-end testing of Angular applications using Cypress
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cypress 对 Angular 应用程序进行端到端测试
- en: Different types of application testing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的应用程序测试
- en: In a world where software plays an increasingly important role and the applications
    we build are growing more complex, automated testing is becoming more critical.
    Companies are constantly looking to improve their applications to give users a
    better experience. To achieve this, many companies aim for continuous delivery
    of their software, meaning their updates can be automatically released to production
    at any given time. To ensure you can safely release updates without breaking things
    in production, you need automated tests that can run in your build pipelines to
    automatically test your software before releasing changes to your testing, acceptance,
    and production environments.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件在日益重要的世界中扮演越来越重要角色，而我们构建的应用程序变得越来越复杂的情况下，自动化测试正变得越来越关键。公司不断寻求改进他们的应用程序，以给用户提供更好的体验。为了实现这一点，许多公司追求持续交付他们的软件，这意味着他们的更新可以在任何给定时间自动发布到生产环境。为了确保您可以在不破坏生产环境中的事物的情况下安全地发布更新，您需要能够在您的构建管道中运行的自动化测试，在将更改发布到您的测试、验收和生产环境之前自动测试您的软件。
- en: As applications become more complex, manually testing all changes becomes too
    time-consuming, and the chances of not testing something affected by your code
    changes increase significantly. Manual testing is also much slower, repetitive,
    and boring. Tasks that are time-consuming, tedious, and repetitive tend to get
    skipped and lead to mistakes. All that manual labor is also a considerable expense
    for the business, so having a sound automated testing system in place is a necessity.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序变得更加复杂，手动测试所有更改变得过于耗时，并且由于您的代码更改而未测试到的风险显著增加。手动测试也慢得多，重复且无聊。耗时、繁琐和重复的任务往往会被跳过，导致错误。所有这些人工劳动对于企业来说也是一笔相当大的开销，因此拥有一个健全的自动化测试系统是必需的。
- en: Besides speeding up the testing process and making it less error-prone, automated
    tests should give you the confidence that any code you merge will not break the
    existing application code. If you’ve ever merged a large code change in an environment
    without a good testing suite, you know what a nerve-wracking experience it is
    and that you never really feel confident that your changes didn’t break anything.
    If there are tests, they will catch bugs and help you think differently about
    how you implement your code, but having the ability to release changes confidently
    is the real goal we’re trying to achieve when writing automated tests.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加快测试过程并减少错误率外，自动化测试还应让您有信心，合并的任何代码都不会破坏现有的应用程序代码。如果您曾在没有良好测试套件的环境中合并过大型代码更改，您就知道这是一次多么令人紧张的经历，并且您从未真正有信心您的更改没有破坏任何东西。如果有测试，它们会捕获错误并帮助您以不同的方式思考您的代码实现，但能够有信心地发布更改是我们编写自动化测试时试图实现的真实目标。
- en: 'When it comes to automated tests for your Angular applications, you can divide
    them into four major types:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到为您的 Angular 应用程序进行自动化测试时，您可以将其分为四大主要类型：
- en: Unit tests
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: End-to-end tests
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试
- en: Component tests
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件测试
- en: Integration tests
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Let’s learn about these four types of tests, how they are used in Angular applications,
    and the differences between them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这四种测试类型，它们在 Angular 应用程序中的使用方式以及它们之间的区别。
- en: Understanding unit tests
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解单元测试
- en: One of the fundamental aspects of software testing is **unit testing**. Simply
    put, unit tests validate small units of code, commonly individual functions, properties,
    or methods. Unit tests are used to test the update behavior of properties and
    the implementation of functions under different scenarios. Given a specified input,
    you expect the function to return a specific value and update certain properties.
    Unit tests run in isolation from the rest of your application, so you can test
    small units of code without them being affected by other parts of the application
    code; that way, you can quickly identify whether the function works as intended
    based on its implementation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试的基本方面之一是**单元测试**。简单来说，单元测试验证代码的小单元，通常是单个函数、属性或方法。单元测试用于测试属性在不同场景下的更新行为和函数的实现。给定一个特定的输入，您期望函数返回一个特定的值并更新某些属性。单元测试在与其他应用程序代码隔离的情况下运行，因此您可以在不受应用程序代码其他部分影响的情况下测试代码的小单元；这样，您可以根据其实现快速确定函数是否按预期工作。
- en: A common and popular technique for developing applications is **test-driven
    development** (**TDD**). In simple terms, when you use TDD to develop your applications,
    you first write the test scenarios and then the code implementations. Developing
    your code this way allows you to look at your code implementations from another
    perspective. Writing tests helps you to look at your code implementations differently
    in general. Still, when you first write all the possible test scenarios you want
    to cover and write the code implementation afterward, it changes your perspective.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 开发应用程序的一种常见且流行的技术是**测试驱动开发**（**TDD**）。简单来说，当您使用 TDD 来开发应用程序时，您首先编写测试场景，然后编写代码实现。以这种方式开发代码允许您从另一个角度审视您的代码实现。编写测试有助于您以不同的方式看待代码实现。尽管如此，当您首先编写所有想要覆盖的可能测试场景，然后编写代码实现之后，这会改变您的视角。
- en: In Angular applications, unit tests are commonly implemented using frameworks
    such as **Jest** or **Karma** and typically test specific Angular components,
    services, pipes, or directives. These tests are essential for verifying that each
    unit of code behaves as expected, adhering to its defined specifications and requirements.
    By isolating each unit of code, developers can identify and address bugs and issues
    early in development, promoting a more robust and stable application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 应用程序中，单元测试通常使用 **Jest** 或 **Karma** 等框架来实现，通常测试特定的 Angular 组件、服务、管道或指令。这些测试对于验证每个代码单元是否按预期行为，遵守其定义的规范和需求至关重要。通过隔离每个代码单元，开发者可以在开发早期识别并解决错误和问题，从而促进更健壮和稳定的应用程序。
- en: The primary purpose of unit tests in Angular applications is to give developers
    confidence in their code implementations, ensuring properties are updated and
    functions work as expected. By thoroughly testing individual units of code under
    different scenarios, developers can ensure that each line of code functions as
    intended, even as the codebase evolves and changes over time. This confidence
    is crucial to enabling developers to make changes and enhancements to the application
    with the assurance that existing functionalities remain intact.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 应用程序中，单元测试的主要目的是让开发者对其代码实现有信心，确保属性得到更新，函数按预期工作。通过在不同场景下彻底测试单个代码单元，开发者可以确保每一行代码都按预期工作，即使代码库随着时间的推移而演变和变化。这种信心对于开发者能够有信心地对应用程序进行更改和改进至关重要，同时确保现有功能保持完整。
- en: A characteristic of unit tests is that they are quick to run, allowing developers
    to run them multiple times during the development process, making it easy to identify
    unintended side effects and bugs early. Unit tests also aim to cover a specific
    percentage of the codebase. Typically, companies like to test between 80% and
    100% of the lines of code, functions, and branches (or paths) of the code; most
    unit test frameworks can enforce these thresholds, so you can’t merge the code
    if you don’t have enough testing coverage.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的一个特点是它们运行速度快，允许开发者在开发过程中多次运行它们，这使得早期识别意外的副作用和错误变得容易。单元测试还旨在覆盖代码库的特定百分比。通常，公司喜欢测试
    80% 到 100% 的代码行、函数和分支（或路径）；大多数单元测试框架可以强制执行这些阈值，所以如果你没有足够的测试覆盖率，就不能合并代码。
- en: To summarize, unit tests are used to test small units of code such as functions,
    methods, and properties. With unit tests, you test code implementations under
    different scenarios to give you confidence that the code behaves as expected given
    a specified input. Commonly, you try to achieve a code testing coverage of between
    80% and 100% for unit tests; so, compared to the other testing types (end-to-end,
    component, and integration), your unit tests will have the most test cases. Unit
    tests are fast to run and rarely fail because of your environment because they
    run in isolation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，单元测试用于测试如函数、方法和属性等小的代码单元。通过单元测试，你可以在不同的场景下测试代码实现，以增强你对代码在给定特定输入时按预期行为的信心。通常，你试图实现
    80% 到 100% 的代码测试覆盖率；因此，与其他测试类型（端到端、组件和集成）相比，你的单元测试将拥有最多的测试用例。单元测试运行速度快，很少因为环境问题而失败，因为它们是在隔离状态下运行的。
- en: 'Now that you have a good idea of what unit tests are and why they are useful,
    let’s dive into the next type of tests: end-to-end tests.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你对单元测试有了很好的了解，知道它们为什么有用，那么让我们深入了解下一类测试：端到端测试。
- en: Understanding end-to-end tests
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解端到端测试
- en: '**End-to-end** (**e2e**) tests are an integral part of the testing strategy
    for Angular applications. They offer a comprehensive approach to validating the
    application’s behavior and functionality from the user’s perspective. Unlike unit
    tests, which focus on testing individual units of code in isolation, e2e tests
    simulate real user interactions with the application, spanning multiple components
    and services to ensure that the application functions correctly as a whole.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**端到端**（**e2e**）测试是 Angular 应用程序测试策略的一个关键部分。它们提供了一个全面的方法来验证应用程序从用户角度的行为和功能。与专注于测试独立代码单元的单元测试不同，端到端测试模拟了与应用程序的真实用户交互，跨越多个组件和服务，以确保应用程序作为一个整体正确运行。'
- en: In the context of Angular applications, e2e tests are commonly implemented using
    frameworks such as **Cypress**, **Playwright**, or **Protractor**. These frameworks
    provide helpful tools to automate browser interactions, allowing them to simulate
    user actions such as clicking buttons, entering text, and navigating between pages.
    By automating these interactions, developers can thoroughly test the application’s
    user interface and workflow, identifying and addressing issues that may arise
    during real-world usage.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular应用程序的背景下，端到端测试通常使用**Cypress**、**Playwright**或**Protractor**等框架来实现。这些框架提供了有助于自动化浏览器交互的有用工具，允许它们模拟用户操作，例如点击按钮、输入文本和在不同页面之间导航。通过自动化这些交互，开发者可以彻底测试应用程序的用户界面和工作流程，识别和解决在实际使用中可能出现的问题。
- en: The primary goal of e2e tests is verifying that the applications work as expected
    from the perspective of the user, encompassing the application’s functional and
    non-functional aspects. e2e tests serve and render the application (or specific
    libraries or modules of the application) in a real browser (you can also run them
    headless without opening a browser), visit a specific URL, and interact with the
    application as a user would. With e2e tests, you are testing whether components
    render correctly and whether features such as form submission, data retrieval
    and display, models, and error handling work as intended. By testing the application
    end-to-end, developers can ensure that multiple components and services work together
    seamlessly to deliver a cohesive user experience.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试的主要目标是验证应用程序从用户的角度来看是否按预期工作，包括应用程序的功能性和非功能性方面。端到端测试在真实浏览器中（你也可以在不打开浏览器的情况下运行它们）呈现应用程序（或应用程序的特定库或模块），访问特定的URL，并以用户的方式与之交互。通过端到端测试，你可以测试组件是否正确渲染，以及诸如表单提交、数据检索和显示、模型和错误处理等功能是否按预期工作。通过端到端测试应用程序，开发者可以确保多个组件和服务能够无缝协作，提供一致的用户体验。
- en: One of the main advantages of e2e tests is their ability to detect issues that
    may be absent when testing individual units of code in isolation. By exercising
    the entire application stack during the tests, including the frontend user interface,
    external dependencies, and (optionally) backend services, e2e tests can uncover
    issues related to data flow, communication between components, and interoperability
    with third-party services. This holistic approach to testing helps developers
    identify and address potential bottlenecks and failure points within the application,
    leading to a more robust and reliable software product.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试的主要优势之一是它们能够检测在单独测试代码单元时可能缺失的问题。通过在测试期间对整个应用程序堆栈进行操作，包括前端用户界面、外部依赖项以及（可选的）后端服务，端到端测试可以揭示与数据流、组件间的通信以及与第三方服务的互操作性相关的问题。这种全面的测试方法有助于开发者识别和解决应用程序中可能存在的瓶颈和故障点，从而产生更健壮和可靠的应用软件产品。
- en: However, while e2e tests offer many benefits, they also come with certain challenges
    and considerations that developers must address. The setup for e2e tests is more
    challenging than unit tests, and e2e tests are more prone to fail because of issues
    in the test environment. Nx already handles most of the setup for us, making starting
    with our e2e tests easier.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管端到端测试提供了许多好处，但它们也带来了一些挑战和开发者必须解决的问题。端到端测试的设置比单元测试更具挑战性，并且由于测试环境中的问题，端到端测试更容易失败。Nx已经为我们处理了大部分设置工作，这使得开始我们的端到端测试变得更加容易。
- en: With e2e tests, you also don’t have an easy way to detect code coverage, so
    they require more planning and coordination to ensure you’re testing everything
    within your application and handling different scenarios and use cases.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用端到端测试，你也没有简单的方法来检测代码覆盖率，因此它们需要更多的规划和协调，以确保测试了应用程序中的所有内容，并处理了不同的场景和用例。
- en: Furthermore, e2e tests can be more time-consuming and resource-intensive to
    execute than unit tests due to their reliance on browser automation and the need
    to simulate real user behavior. As a result, developers must strike a balance
    between the depth and scope of e2e test coverage and the practical constraints
    of test execution time and resources.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于端到端测试依赖于浏览器自动化和模拟真实用户行为的需求，因此它们的执行可能比单元测试更耗时和资源密集。因此，开发者必须在端到端测试覆盖的深度和范围与测试执行时间和资源等实际约束之间取得平衡。
- en: Despite these challenges, e2e tests play a crucial role in ensuring Angular
    applications’ overall quality and reliability, complementing other testing techniques
    such as unit tests and integration tests. By thoroughly testing the application
    from end to end, developers can gain confidence in its behavior and functionality,
    identify and address issues early in the development process, and ultimately deliver
    a high-quality user experience to their customers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些挑战，端到端测试（e2e tests）在确保 Angular 应用程序的整体质量和可靠性方面发挥着至关重要的作用，它补充了其他测试技术，如单元测试和集成测试。通过彻底测试应用程序的每个环节，开发者可以对其行为和功能充满信心，在开发早期阶段识别并解决问题，最终向客户交付高质量的用户体验。
- en: To summarize, e2e tests are designed to test your application from the user’s
    perspective and interact with your application in a real browser. They ensure
    your application (or specific libraries or modules) works as a whole and responds
    in the intended way to user interactions. e2e tests, while more time-consuming
    to write and execute than unit tests, provide the assurance that the user can
    interact with your applications as you intended, fostering a stronger connection
    with your end users.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，端到端测试旨在从用户的角度测试你的应用程序，并在真实浏览器中与之交互。它们确保你的应用程序（或特定的库或模块）作为一个整体工作，并按预期对用户交互做出响应。虽然端到端测试在编写和执行方面比单元测试更耗时，但它们提供了用户可以按预期与你的应用程序交互的保证，从而与最终用户建立更强的联系。
- en: Now that you know what e2e tests are and how they differ from unit tests, I
    will briefly explain component and integration testing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了端到端测试是什么以及它们与单元测试的不同之处，我将简要解释组件测试和集成测试。
- en: Understanding component tests
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解组件测试
- en: '**Component testing** is a relatively new concept compared to unit and e2e
    testing. In modern frontend frameworks such as Angular, we develop applications
    using **components**. Components can be simple components, such as buttons, or
    more complex ones, such as tables or forms.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件测试**与单元测试和端到端测试相比是一个相对较新的概念。在现代前端框架如 Angular 中，我们使用 **组件** 来开发应用程序。组件可以是简单的组件，如按钮，也可以是更复杂的组件，如表格或表单。'
- en: Using component tests, frameworks such as Cypress provide a new approach for
    testing component-based applications. Instead of visiting a URL and running the
    entire application, component tests mount individual components and test those
    components in isolation. Component testing is like unit testing of e2e testing.
    You still mount the component and show it in a browser to interact with the component
    like a user would, but you test it in isolation from the rest of your application.
    Testing components in isolation allows you to test the component from a user interaction
    perspective without worrying about the rest of the application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件测试，例如 Cypress 这样的框架提供了一种测试基于组件的应用程序的新方法。而不是访问 URL 并运行整个应用程序，组件测试会挂载单个组件并在隔离状态下测试这些组件。组件测试类似于端到端测试的单元测试。你仍然挂载组件并在浏览器中显示它，以便像用户一样与之交互，但你是在与应用程序的其他部分隔离的情况下进行测试。在隔离状态下测试组件允许你从用户交互的角度测试组件，而不必担心应用程序的其他部分。
- en: One thing to keep in mind is that even if all your component tests are passing,
    it does not automatically mean your application is working as expected. Components
    can work in isolation but fail when they’re combined or have to interact with
    other components in your application. Compared to e2e tests, component tests don’t
    need the entire system to be executed, so they can run faster and rarely fail
    due to issues with your test environment.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一点是，即使所有组件测试都通过，这也并不意味着你的应用程序按预期工作。组件可以独立工作，但在组合或需要与其他应用程序中的组件交互时可能会失败。与端到端测试相比，组件测试不需要执行整个系统，因此它们可以更快地运行，并且很少因为测试环境的问题而失败。
- en: If you and your team want to implement component tests, it is up to you; these
    tests can help reduce the number of e2e tests you need to write. I like to write
    more e2e tests as opposed to component tests. Component tests still need to be
    adopted as an industry standard; most companies only require unit, e2e, and integration
    tests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和你的团队想要实施组件测试，这取决于你；这些测试可以帮助减少你需要编写的端到端测试的数量。我更喜欢编写更多的端到端测试而不是组件测试。组件测试仍然需要被采纳为行业标准；大多数公司只需要单元测试、端到端测试和集成测试。
- en: To summarize, component tests test individual components from the user’s perspective.
    Component tests ensure a component works in isolation but don’t ensure the component
    works within the context of your entire application. Component tests are easier
    to set up than e2e tests as they don’t need to run the entire application. You
    can think of component testing as a mix between unit and e2e testing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，组件测试从用户的角度测试单个组件。组件测试确保组件在隔离状态下可以工作，但并不确保组件在应用程序的整个上下文中也能工作。组件测试比端到端测试更容易设置，因为它们不需要运行整个应用程序。你可以将组件测试视为单元测试和端到端测试之间的混合体。
- en: Now that you know what component tests are and how they differ from e2e tests,
    we will finish this section on different testing types by explaining integration
    tests.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了组件测试是什么以及它们与端到端测试的不同，我们将通过解释集成测试来结束关于不同测试类型的这一部分。
- en: Understanding integration tests
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解集成测试
- en: '**Integration tests** are used to test whether different modules and elements
    of your software integrate without breaking. They are generally the final testing
    stage before you release your changes to production. So, unit tests focus on testing
    individual units of code in isolation, end-to-end tests simulate and test user
    interactions for specific application libraries and modules, and integration tests
    are used to test the interactions between various modules and elements within
    the application.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**用于测试软件的不同模块和元素是否可以集成而不会出错。它们通常是你在将更改发布到生产之前进行的最终测试阶段。因此，单元测试专注于在隔离状态下测试单个代码单元，端到端测试模拟并测试特定应用程序库和模块的用户交互，而集成测试用于测试应用程序内各种模块和元素之间的交互。'
- en: Integration tests can be used and written for different integration levels within
    an application. For example, you can write functional tests comparable to unit
    tests. Still, instead of testing code implementations for an isolated component
    or service, you test whether your functionality and implementations work as expected
    for a group of components or services that work together. You can also write integration
    tests from the user’s perspective, similar to e2e tests. When you write integration
    tests from the user’s perspective, you can test whether your frontend works together
    with your API or whether your deployed application is composed of multiple Angular
    applications. You can also test whether the different applications can work together
    when everything is deployed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试可以在应用程序的不同集成级别中使用和编写。例如，你可以编写与单元测试相当的功能测试。然而，你测试的不是孤立组件或服务的代码实现，而是测试你的功能实现是否按预期工作，对于一组协同工作的组件或服务。你也可以从用户的角度编写集成测试，类似于端到端测试。当你从用户的角度编写集成测试时，你可以测试你的前端是否与API协同工作，或者你的部署应用程序是否由多个Angular应用程序组成。你还可以测试当所有内容都部署时，不同的应用程序是否可以协同工作。
- en: When you create integration tests from the user’s perspective, you commonly
    run the tests in an environment that mirrors the production environment. You test
    with an actual deployed application with real APIs and data. By testing on a deployed
    system, you can test whether all elements of your software work together as expected
    without any boundaries.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从用户的角度创建集成测试时，你通常会在一个与生产环境相似的环境中运行测试。你使用实际部署的应用程序和真实的API以及数据进行测试。通过在部署的系统上进行测试，你可以测试你的软件的所有元素是否按预期协同工作，没有任何边界。
- en: Now you know about unit, e2e, component, and integration tests, it’s time to
    get our hands dirty and write some tests ourselves. We will skip the integration
    tests because we don’t have a large system or a deployed version with different
    elements that integrate. We will start by writing and running unit tests for our
    Angular application using the Jest testing framework. After writing our unit test,
    we will finish the chapter by writing e2e tests using the Cypress testing framework.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了单元测试、端到端测试、组件测试和集成测试，是时候动手编写一些测试了。我们将跳过集成测试，因为我们没有大型系统或包含不同集成元素的部署版本。我们将从使用Jest测试框架为我们的Angular应用程序编写和运行单元测试开始。编写完单元测试后，我们将使用Cypress测试框架编写端到端测试来结束本章。
- en: Unit testing of Angular applications using Jest
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest对Angular应用程序进行单元测试
- en: When you add an Angular project to your Nx monorepo, the application is set
    up to use Jest as a test runner by default. Jest is a testing framework commonly
    used to write and run automated unit tests for JavaScript and TypeScript-based
    applications. This section will give you hands-on experience writing unit tests
    for your Angular application using Jest. Before you start writing tests, let’s
    expand upon the default configuration Nx provided to make your testing experience
    better.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 Angular 项目添加到你的 Nx 单一代码仓库中时，应用程序默认设置为使用 Jest 作为测试运行器。Jest 是一个常用的测试框架，通常用于编写和运行基于
    JavaScript 和 TypeScript 的应用程序的自动化单元测试。本节将为你提供使用 Jest 为你的 Angular 应用程序编写单元测试的实践经验。在你开始编写测试之前，让我们扩展
    Nx 提供的默认配置，以使你的测试体验更佳。
- en: Setting the coverage threshold
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置覆盖率阈值
- en: 'The first thing you want to add in the Jest configuration is a coverage threshold
    for the minimum required percentage of lines, functions, and branches that unit
    tests should cover. A commonly used percentage is 80%, but you can set the coverage
    percentages to whatever you and your team deem enough to make you confident that
    new changes won’t break existing code. You can add the global configurations for
    testing coverage inside the `jest.preset.js` file in the root of your Nx monorepo.
    Additionally, you can set specific configurations for each project in the `jest.config.ts`
    file at the root of each project. I will only add the following configurations
    in `jest.preset.js` in the root of the Nx monorepo:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jest 配置中，你首先想要添加的是单元测试应该覆盖的最小行、函数和分支的覆盖率阈值。常用的百分比是 80%，但你可以将覆盖率百分比设置为你和你的团队认为足够的任何值，以确保新的更改不会破坏现有代码。你可以在
    Nx 单一代码仓库根目录下的 `jest.preset.js` 文件中添加测试覆盖率的全局配置。此外，你还可以在每个项目的根目录下的 `jest.config.ts`
    文件中为每个项目设置特定的配置。我将在 Nx 单一代码仓库根目录下的 `jest.preset.js` 中添加以下配置：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding configuration ensures that all branches, functions, and lines
    have a minimum test coverage of 80%. The configuration also tells Jest to collect
    the coverage results and present you with a text-based coverage report. In the
    coverage report, you can see how much of your code is covered, what lines, functions,
    and branches are missing, and their respective page line numbers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置确保所有分支、函数和行至少有 80% 的测试覆盖率。该配置还告诉 Jest 收集覆盖率结果并向你提供一个基于文本的覆盖率报告。在覆盖率报告中，你可以看到你的代码覆盖了多少，哪些行、函数和分支缺失，以及它们各自的页面行号。
- en: Now that you have configured your test coverage reports, it’s time to add a
    testing module for Transloco.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经配置了测试覆盖率报告，是时候为 Transloco 添加一个测试模块了。
- en: Adding additional configurations
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加额外的配置
- en: 'The testing module makes it easy to import the correct configuration to test
    components using Transloco. In the root of your `expenses-registration` project,
    you can create a `transloco-testing.module.ts` file and add the following content:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模块使得导入正确的配置来测试使用 Transloco 的组件变得容易。在你的 `expenses-registration` 项目根目录下，你可以创建一个
    `transloco-testing.module.ts` 文件，并添加以下内容：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding example, we created a `getTranslocoModule()` function. This
    function will be used inside our unit test files to add the necessary Transloco
    configuration for the test setup. It’s simply a function returning the `TranslocoTestingModule`
    class provided by the `Transloco` library. At the top of the file, we import two
    JSON files containing our translations. If you want to import these two JSON files
    without trouble, you need to add the following configurations inside your `tsconfig.base.json`
    file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个 `getTranslocoModule()` 函数。这个函数将在我们的单元测试文件中使用，为测试设置添加必要的 Transloco
    配置。它只是一个返回 `TranslocoTestingModule` 类的函数，该类由 `Transloco` 库提供。在文件顶部，我们导入包含我们翻译的两个
    JSON 文件。如果你想无障碍地导入这两个 JSON 文件，你需要在你的 `tsconfig.base.json` 文件中添加以下配置：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After adding the preceding configuration and the `transloco-testing.module.ts`
    file with the `getTranslocoModule()` function, we are almost done with our addition
    to the default Jest setup Nx provided us with. Lastly, we need to update the `transformIgnorePatterns`
    configuration inside our `jest.config.ts` files to the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加上述配置和包含 `getTranslocoModule()` 函数的 `transloco-testing.module.ts` 文件之后，我们几乎完成了对
    Nx 提供的默认 Jest 设置的补充。最后，我们需要更新 `jest.config.ts` 文件中的 `transformIgnorePatterns`
    配置，如下所示：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you change the `transformIgnorePatterns` configuration, you ensure Jest
    will not start to complain about missing imports and packages inside your `node_modules`
    folder. There already are `transformIgnorePatterns` configurations inside each
    `jest.config.ts` file in your Nx monorepo, but in many cases, you need to adjust
    them or else your tests might fail based on things inside your `node_modules`
    folder.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更改 `transformIgnorePatterns` 配置时，你确保 Jest 不会开始抱怨 `node_modules` 文件夹中缺少导入和包。在你的
    Nx monorepo 中，每个 `jest.config.ts` 文件中已经存在 `transformIgnorePatterns` 配置，但在许多情况下，你需要调整它们，否则你的测试可能会因为
    `node_modules` 文件夹中的内容而失败。
- en: That is all the additional setup we will be doing. You can always add additional
    configurations as needed. You can find all additional Jest configurations in their
    official documentation at [https://jestjs.io/docs/configuration](https://jestjs.io/docs/configuration).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将进行的所有额外设置。你总是可以根据需要添加额外的配置。你可以在他们的官方文档中找到所有额外的 Jest 配置：[https://jestjs.io/docs/configuration](https://jestjs.io/docs/configuration)。
- en: Now that you have added the configuration needed to test Transloco and obtained
    testing coverage reports, let’s start to write and run unit tests for our Angular
    application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经添加了测试 Transloco 所需的配置并获得了测试覆盖率报告，让我们开始编写和运行我们的 Angular 应用程序的单元测试。
- en: Writing and running unit tests
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写和运行单元测试
- en: You write your unit tests inside `.spec.ts` file for the created resource. These
    `.spec.ts` files contain the default-generated unit tests.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你将单元测试写在为创建的资源创建的 `.spec.ts` 文件中。这些 `.spec.ts` 文件包含默认生成的单元测试。
- en: Let’s take the `expenses-registration` Angular application as our example. When
    you generated the application, Nx generated an `AppComponent` class for you and
    an `app.component.spec.ts` file where the default generated unit test for `AppComponent`
    resides. Additionally, we created `ExpensesOverviewPageComponent` and `ExpensesApprovalPageComponent`
    inside the *expenses-registration application*; for both these components, Nx
    also generated `.spec.ts` files. Let’s start with these files.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 `expenses-registration` Angular 应用程序为例。当你生成应用程序时，Nx 为你生成了一个 `AppComponent`
    类和一个 `app.component.spec.ts` 文件，其中包含为 `AppComponent` 生成的默认单元测试。此外，我们在 *expenses-registration
    应用程序* 中创建了 `ExpensesOverviewPageComponent` 和 `ExpensesApprovalPageComponent`；对于这两个组件，Nx
    也生成了 `.spec.ts` 文件。让我们从这些文件开始。
- en: Fixing the generated spec files
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复生成的 spec 文件
- en: 'If you currently run the tests inside these spec files, they will fail. The
    tests will fail because we haven’t touched the spec files since they have been
    generated, but we did adjust the component classes. So before we try to run the
    tests, let’s fix the spec files one by one. We will also write some new tests
    and explain what Nx generated for us. Starting with the `app.component.spec.ts`
    file, let’s see what Nx has generated inside the spec file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在在这些 spec 文件中运行测试，它们将会失败。测试会失败，因为我们自生成以来还没有修改过 spec 文件，但我们确实调整了组件类。所以在我们尝试运行测试之前，让我们逐个修复
    spec 文件。我们还将编写一些新的测试并解释 Nx 为我们生成了什么。从 `app.component.spec.ts` 文件开始，让我们看看 Nx 在
    spec 文件中生成了什么：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Nx generated the preceding code for you. As you can see, there are `describe()`,
    `beforeEach()`, and two `it()` functions. All of these functions have some additional
    code inside their respective callback functions, but we will ignore that for now.
    Let’s first explain what `describe()`, `beforeEach()`, and `it()` functions are
    used for:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Nx 为你生成了前面的代码。正如你所见，有 `describe()`、`beforeEach()` 和两个 `it()` 函数。所有这些函数在其各自的回调函数中都有一些额外的代码，但我们现在将忽略这些代码。让我们首先解释
    `describe()`、`beforeEach()` 和 `it()` 函数的用途：
- en: '`describe()`: The `describe()` function is used to group multiple tests together
    and describe what element we are testing. You provide the `describe()` function
    with two parameters: a string with a description of what we’re writing tests for—in
    our example, `AppComponent`—and a callback function where we will write out specific
    test cases.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe()`: `describe()` 函数用于将多个测试组合在一起并描述我们正在测试的元素。你向 `describe()` 函数提供两个参数：一个字符串，描述我们正在为哪些内容编写测试——在我们的例子中是
    `AppComponent`——以及一个回调函数，我们将在这里编写具体的测试用例。'
- en: '`beforeEach()`: The `beforeEach()` function is used to perform specific steps
    before each test, commonly configurations such as setting up `TestBed`, creating
    the component, service, pipe, or directive we are testing, and any additional
    configuration we want to do before each test we run.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach()`: `beforeEach()` 函数用于在每个测试之前执行特定的步骤，通常包括配置，如设置 `TestBed`、创建我们正在测试的组件、服务、管道或指令，以及我们在每个测试运行之前想要进行的任何其他配置。'
- en: '`it()`: The `it()` functions define each test case. An `it()` function takes
    in two parameters: a string containing a description of the test case and a callback
    function containing the testing logic.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you know what `describe()`, `beforeEach()`, and `it()` functions are,
    let’s replace the generated code of your `app.component.spec.ts` file with something
    that reflects the current state of the app component.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Defining our test cases
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we start adjusting the code inside the spec file, let’s first clarify
    what we want to test.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look inside your `AppComponent` class, you find two properties: a `translationService`
    and a `navItems` property. Additionally, inside the HTML template of your app
    component, you’ll find the navbar component with some inputs and an output for
    when the selected language changes. As we mentioned before, when writing unit
    tests, you want to test a single unit of code in isolation—in this case, our app
    component. So, what functionalities are related to the app component?'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Defining the component class properties.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling the `setActiveLanguage` method on the `translationService` property
    of the navbar to emit a `languageChange` event.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The aforementioned points are the only component logic related to the app component;
    checking whether the navbar inputs are correctly handled and whether the navbar
    renders correctly is logic related to the navbar and should be tested in the spec
    file of the navbar component. If we were to check these things inside the spec
    file of the app component, we would be testing whether the navbar and app components
    integrate correctly. For the same reason, we do not check whether `TranslationService`
    actually adjusts the active language after we call the method. This would test
    the integration between the app component and `TranslationService`. From the perspective
    of the app component, we are only interested if the app component actually makes
    the function call. Now we know what we will be testing, let’s define what `it()`
    statements we will be creating inside our spec file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: They should create the component and set the component properties with the expected
    values.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They should call the `setActiveLanguage` method when the `languageChange` event
    is emitted.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have defined the `it()` statements we’re about to define inside
    the `app.component.spec.ts` file, let’s start to adjust the file step by step
    so we can actually test these statements successfully.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the code inside the spec file
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We defined the test cases we wanted to write and learned about the three main
    functions inside the spec files. Now, let’s write our test cases and learn how
    to configure your testing modules, make assertions for your test cases, and actually
    run the tests.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The describe() function
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will start by removing all the code inside the `describe()` function so
    we can start fresh. The `describe()` function itself can remain as it was generated
    for you. After you remove the generated code, start by defining three properties
    inside the `describe()` function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see in the preceding code snippet, we added `component`, `fixture`,
    and `mockTranslationService` properties inside the `describe()` function. The
    `component` variable will hold an instance of our `AppComponent` class, `fixture`
    will be an element containing a test harness that can be used to debug and interact
    with the app component (the class, native element, element ref, lifecycle methods,
    etc.), and `mockTranslationService` will be used as a value for the `TranslationService`
    injectable we use inside the app component. We use this mock version of `TranslationService`
    to simplify the setup we need to do inside our spec file. Because we don’t want
    to test the integration between our app component and `TranslationService`, we
    want to test the app component in isolation. After you have defined these three
    properties, it’s time to add the `beforeEach()` function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The beforeEach() function
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `beforeEach()` function will be added underneath the three properties we
    added just now and will be used to configure `TestBed` and assign our `component`
    and `fixture` properties before each test. Let’s start simply by defining the
    `beforeEach()` method itself:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now inside the callback of the `beforeEach()` function, we start by configuring
    the testing module using the `TestBed.configureTestingModule()` method. The testing
    module requires everything needed to create our app component:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see in the preceding code, we need to import three classes and define
    a provider to configure the testing module. You need to import the `AppComponent`
    class because `AppComponent` is a standalone component, `RouterTestingModule`
    because we use the `RouterOutlet` inside the app component template, and `TranslocoTestingModule`
    using the `getTranslocoModule()` function we defined in the *Adding additional
    configurations* section of this chapter. Besides the imports, you need to create
    a provider for `TranslationService` so that the app component uses `mockTranslationService`
    during the tests. At the end of the `configureTestingModule()` method, you need
    to call the `compileComponents()` methods so that Jest will compile everything
    we defined inside the testing module configuration.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `TestBed` testing module is configured, we will assign the `component`
    and `fixture` properties. The `fixture` property will be assigned using the `TestBed.createComponent()`
    method. Calling the `createComponent()` function on `TestBed` will freeze the
    current `TestBed` class, meaning you can’t call `TestBed` configuration methods
    anymore. It will also return a test harness that can be used to interact with
    the component created inside your test cases:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After assigning `fixture`, you assign the `component` variable using the `componentInstance`
    property of `fixture`. This `componentInstance` property is an object containing
    all the properties and functions of the component you’re testing—in our case,
    `AppComponent`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Lastly, you need to call the `detectChanges()` method on `fixture` so that
    change detection will run for the created app component:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that you have defined the `beforeEach()` function and configured `TestBed`,
    we can start with our first `it()` function and define the first test case.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The first it() function and test case
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can define your `it()` function underneath the `beforeEach()` function.
    In our case, the first test case should test whether the component is successfully
    created and the `navItems` and `translationService` properties are correctly assigned:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see in the preceding code, we start with the `it()` function and
    provide the function with a description. Then, in the callback function, we assess
    what we want to test using the `expect()` function combined with an assertion
    method. You provide the `expect()` method with the value you want to test and
    expect to be or not to be something. In our case, we first expect the component
    property (which is assigned without a component instance inside the `beforeEach()`
    function) to be defined. Next, we expect the `navItems` property of the component
    to equal the object we defined inside the component class for the `navItems` property.
    Lastly, we expect `translationService` to equal `mockTranslationService`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you have defined the `beforeEach()` function, configured `TestBed`, created
    the component inside the `beforeEach()` function, and written your first testing
    case. You can run the test inside the `app.component.spec.ts` file. You run unit
    tests by running the following command in the root of your Nx monorepo:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding Terminal command, you need to replace the `<project-name>`
    placeholder with the actual name of the project you want to run tests for. You
    can find the project name inside the `project.json` file of each application or
    library within your Nx monorepo. To run the unit tests for a specific file, add
    the `–test-file` flag at the end of the command. For example, to run the unit
    tests for our `app.component.spec.ts` file, you run the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding command will run the tests inside the `app.component.spec.ts`
    file. After running the tests, you’ll notice that your test case is failing with
    the following error message: `NavbarComponent` and Jest doesn’t support signal
    inputs (at the time of writing).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'As a workaround, you can create a simplified replica of `NavbarComponent` that
    is used for unit testing components that use `NavbarComponent` in their template.
    Such a replica is commonly named a `AppComponent` functionality in isolation instead
    of having it integrated with `NavbarComponent`. You create the navbar stub component
    in your `common-components` library inside the `navbar` folder by adding a `navbar.component.stub.ts`
    file with the following content:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After creating the stub component, export it in the `index.ts` file of your
    `common-components` library so you can access the stub component in your spec
    files. Now, inside the `beforeEach()` function of the `app.component.spec.ts`
    file, you can ensure the app component uses the stub navbar component during the
    tests instead of the regular navbar component. You can achieve this by changing
    the navbar component import for the stub navbar component using the `TestBed.overrideComponent()`
    method. You need to simply remove the `NavbarComponent` import and add the `StubNavbarComponent`
    import:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see in the preceding code, we remove the `NavbarComponent` import
    from `AppComponent` and add `StubNavbarComponent`. It’s important that you overwrite
    the component imports before you call the `TestBed.createComponent()` method and
    freeze `TestBed`; otherwise, your override will not be included in `TestBed`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Using stub components and services can be helpful in cases like this, where
    Jest still needs to add support for specific features. Additionally, stubs ensure
    that you’re not integration testing but focusing on units of code in isolation.
    If you want to unit test the navbar, for example, you should do so in the spec
    file of the navbar component and not in the spec file of the app component. Additionally,
    using stub components can simplify the setup you need in the `beforeEach()` method
    to ensure Jest can create the component or service you want to unit test.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you rerun the app component unit tests after adding the stub navbar
    component. In that case, you’ll see that the test case we defined in the spec
    file is passing, meaning the test successfully creates `componentInstance`. Still,
    the test run fails because we don’t meet the configured coverage requirements
    of 80%. If you look at the coverage report in your terminal, you’ll see that the
    coverages of your `app.component.ts` and `app.component.html` files are 100%,
    but the coverage of your `translation.service.ts` file is 0%, bringing the total
    testing coverage under the required 80%.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: So, why is the testing coverage including `translation.service.ts`, and should
    you care? The `translation.service.ts` file is included in your coverage report
    because, by default, Jest (and other test runners) will consist of all files in
    the coverage report you import and use within the class you’re testing—in this
    case, the `AppComponent` class. Should you care, and do you need to fix this shortfall
    in your coverage percentage?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The answer is it depends on how you run the tests. If you’re running the tests
    for a single file, as we are doing now, you shouldn’t care and should only focus
    on the files related to the unit you’re testing—in our case, the app component.
    After all, you want to write shallow unit tests that only test a single unit of
    code in isolation, so if you have a testing coverage of 80% or higher for the
    files related to the unit you’re testing, everything is good! However, if you’re
    running the unit test for an entire project by omitting the `–test-file` flag,
    you should care about the coverage percentage. For your entire project, you should
    have enough coverage. In this example, the code related to the `translation.service.ts`
    file should be tested in a `translation.service.spec.ts` file. If you run the
    unit tests for the entire project and you cover the logic of your `translation.service.ts`
    file inside the `translation.service.spec.ts` file, you will not have the shortfall
    in your coverage report and the test run will succeed. Now that we have clarified
    that, let’s add our second `it()` function for `app.component.spec.ts`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The second it() function
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we have 100% testing coverage for our app-component-related files, our
    test might not give us the confidence we need that everything works as expected.
    We don’t test whether the app component class calls the `setActiveLanguage` method
    when the navbar emits a `languageChange` event, so let’s add a test for this.
    You can add the following code to test whether the app component calls the `setActiveLanguage`
    method when it receives the `languageChange` event:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, quite a lot is happening, so let’s examine each line
    carefully.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: First, we define the `it()` function and provide it with a description of our
    test case. Inside the callback function, we start by creating a spy element.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '`setActiveLanguage` method of the `translationService` property is called.
    Create the spy object by using the `jest.spyOn()` function. Inside the `jest.spyOn()`
    function, first provide the object containing the function you want to spy on
    and then, as a string, the function name you want to spy on.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: After creating the spy object, we use `debugElement` of `fixture` to access
    `StubNavbarComponent` inside our HTML template and save it in a constant named
    `navBarElement`. Next, we use the `triggerEventHandler` method on `navBarElement`
    to trigger the `languageChange` event and provide `nl` as the event data.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: After triggering the `languageChange` event, we expect that `setActiveLanguage()`
    is called with the `nl` parameter. We check whether this is correct by providing
    the `expect()` function with the `setActiveLanguage` spy object and calling the
    `toHaveBeenCalledWith('nl')` assertion method on the `expect()` function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: After adding your second testing case to the `app.component.spec.ts` file, you
    can run the tests again, and you’ll notice that both test cases are successful.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, you learned that the `describe()` function is used to group test
    cases and the `beforeEach()` function is used to configure `TestBed` and define
    values before each test case runs. The `it()` functions are used to define your
    test cases, and inside the `it()` functions, you use the `expect()` function combined
    with assertion methods to perform your test statements. You can create and use
    spy objects to validate whether functions are called. When writing unit tests,
    you should write shallow unit tests that focus on a single unit of code instead
    of testing the integration of different components and services. You can write
    shallow unit tests and prevent issues with unsupported features by creating stub
    components and services, which are simplified replicas used within your unit tests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a better understanding of unit tests and you’ve created your
    first tests, we will fix the additional spec files of the `expenses-registration`
    component so we can do a successful test run for the application. Additionally,
    you will learn how to run unit tests for multiple projects in your Nx monorepo.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Adding additional unit tests for the expenses-registration application
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now start writing some additional unit tests for the *expenses-registration
    application* so you can successfully run the unit tests for the entire application
    without specifying the `–test-file` flag. To start, we will remove the `expenses-approval-page.component.spec.ts`
    file because we haven’t added any code yet inside the expenses approval component.
    After removing `expenses-approval-page.component.spec.ts`, we will adjust the
    tests inside `expenses-overview-page.component.spec.ts`. We made quite some adjustments
    to the `ExpensesOverviewPageComponent` class, so fixing the related spec file
    will be a bit more work compared to the spec file for `AppComponent`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by running the unit tests with the following command and see what
    pops up:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It might come as no surprise that the test run fails. Let’s fix the issues with
    the spec file one by one, starting with the import of `ExpensesOverviewPageComponent`
    inside the spec file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the code inside our other spec file
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because we changed the export of `ExpensesOverviewPageComponent` to a default
    export, we also need to adjust the import inside the spec file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After changing the `import` statement, you need to adjust the spec file so
    `TestBed` can successfully create the `expenses-overview` component. Just like
    the app component, the `expenses-overview` component uses `TranslationService`,
    so we will make a mock object for this service (alternatively, you can create
    a stub service for it and also use that inside the spec file of the app component):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see in the preceding code, `mockTranslationService` for this spec
    file differs from the `mockTranslationService` class we created for the spec file
    of the app component. The mock objects differ because we only include what we
    use inside the component we are about to test in the mock object; in this case,
    the `expenses-overview` component only uses the `translocoService` and `translationsLoaded`
    properties of the service. Besides `mockTranslationService`, we also need a stub
    for `ExpensesFacade`. You can copy `StubExpensesFacade` from the GitHub repository
    for this book. The `expenses.facade.stub.ts` file is located next to the regular
    `expenses.facade.ts` file inside the finance `data-access` library. After creating
    the mock and stub objects we need for our unit tests, we can create the `beforeEach()`
    function and set up `TestBed`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see in the preceding code, we import `ExpensesOverviewPageComponent`
    and `TranslocoTestingModule` using the `getTranslocoModule()` function. After
    the imports for the testing module, we added some providers that needed to configure
    the testing module. We provide `ExpensesFacade` and `TranslationService` with
    the mock and stub values, and we provide the `TranslocoLocale` configuration because
    we use the localization pipes inside the `expenses-overview` page. After configuring
    the imports and providers for the testing module, we created and assigned the
    `fixture` and `component` properties and called `detectChanges()` on `fixture`.
    Now we have configured everything needed to create the component inside `TestBed`,
    let’s remove all `it()` functions and write our own test cases.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Writing the test cases
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will create the following test cases:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The test should create the component and initialize the properties correctly.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should fetch expenses on `init`.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should translate the title if translations are loaded.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should change `summaryBtnText` if `onSummaryChange` is called.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should call `addExpense` on the expenses facade with the correct values when
    `onAddExpense` is called.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have defined our test cases, let’s create them one by one:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see in the preceding code, this test is really straightforward;
    we simply check whether the component variable is defined and whether each component
    property is initialized with the value we expect. As you may have noticed, we
    used some new assertion methods here, such as `toBeFalsy()` and `toBeInstanceOf()`.
    These assertion methods can be used to check whether a value is false in a Boolean
    context and whether an object is an instance of a specific class. Besides `toBeFalsy()`
    and `toBeInstanceOf()`, we did nothing new in this test, so let’s move on to our
    next test case:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding test, we create a spy object to spy on the `fetchExpenses()`
    function of `ExpensesFacade`. After that, we call `ngOnInit()` for the component
    we are testing—in this case, the `expenses-overview` page component—and at the
    end of our test, we use the `expect()` function to check whether the `fetchExpenses()`
    function is called. As you can see, calling a method declared in the component
    we are testing is super straightforward; you simply use the `component` variable
    and call the method you want to run. Now that we’ve also covered this test, let’s
    move on to the next test case we defined:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding test, a bit more is going on, and we used some new techniques.
    Let’s explore what we do here in more detail. Because we are testing a signal
    effect in this test and signal effect are asynchronous, we wrapped the callback
    of our `it()` function inside a `fakeAsync()` function. Inside the `fakeAsync()`
    function, times are synchronous. You can manually execute microtasks by calling
    `flushMicroTasks()` and simulating time passing with the `tick()` function. After
    using the `fakeAsync()` function, we first define a spy object. Then, we check
    whether the `translationsLoaded` signal has a false value and that the `translate()`
    function that we use inside our signal effect isn’t called. Next, we set the value
    of the `translationsLoaded` signal to `true`. This should trigger the signal effect
    again, and this time, we should reach the part where we use the `translate()`
    function. Because the signal effect is asynchronous, we first call the `tick()`
    function to simulate the passing of time, and after that, we check whether our
    spy object is called with the correct translation key.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have explained the `fakeAsync()` and `tick()` functions used in
    our last test case, let’s continue and add the next test case:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see in the preceding code, this is a simple test. We first check
    whether the `showSummary` signal is false and the `summaryBtnText` computed signal
    returns `onSummaryChange()` function and check whether the `showSummary` signal
    and the `summaryBtnText` computed signal are adjusted correctly. After adding
    the preceding test, there is only one test case to add to our spec file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding test, we first create a spy object to spy on the `addExpense()`
    function of `ExpensesFacade`. After creating the spy object, we create an `expense`
    object to provide to the `onAddExpense()` method. After creating `expense`, we
    call the `onAddExpense()` method and provide it with the `expenseToAdd` property.
    After we call the `onAddExpense()` method, the `addExpense()` function of the
    facade should be called with the `expenseToAdd` property as a function parameter.
    We verify that the `addExpense()` function is called with the correct parameter
    using the `toHaveBeenCalledWith()` assertion method. Lastly, we use the `toContainEqual()`
    assertion method to check whether `expense` is added to the `expenses` signal
    of the `expenses-overview` page component.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the last test case, you can run the tests again using the following
    command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After you run the tests again, you’ll find that all tests are passing and you
    have 100% coverage for the files related to the `expenses-overview` component.
    You can write some additional tests to test the template, but this will also be
    covered with the e2e tests we will write in the next section. Now that you know
    how to run the unit tests for your individual spec file, let’s examine how to
    run unit tests for one or more projects within your Nx monorepo.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Running unit tests for one or more projects
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We ran the unit tests for the spec files one by one, so now let’s run them
    for the entire `finance-expenses-registration` project. When you run the unit
    tests for an entire project, it will run the tests in all spec files found inside
    that Nx project. Note that this will not include any library projects you use
    inside the project. For example, to run the test for all spec files inside the
    `finance-expenses-registration` project, you use the following Terminal command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When you run the preceding command, you’ll notice that the test run fails because
    we do not meet the coverage threshold of 80%. This is because we do not test the
    `translation.service.ts` file. As an exercise, you can create the spec file for
    `TranslationService` yourself; alternatively, you can lower the coverage threshold.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides running the unit tests for a single project, you can also run unit
    tests for multiple projects at the same time using the `run-many` command. When
    using the `run-many` command without any additional parameters, you will run the
    unit tests for projects found in your entire Nx monorepo:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Furthermore, you can add specific project names at the end of the terminal
    command to only run the unit tests for specific projects:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can also run the unit tests for all projects and exclude specific projects
    from the test run using the `–``exclude` flag:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lastly, you can use the `affected` terminal command. The `affected` command
    can be used to run the unit tests for all projects affected by your changes. Nx
    will look at its cache and check what projects have changed since the last time
    the unit tests ran. Any project affected by changes made after the latest cached
    test run will be run when using the `affected` command. The `affected` command
    is particularly useful when you run your unit tests on a build pipeline and want
    to test your code each time you’re merging code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To summarize, you can run tests for individual spec files, for one or more Nx
    projects, or for projects affected by your changes. Unit tests are meant to test
    isolated units and should make you confident that your changes will not break
    your existing code implementations. Unit tests consist of three main parts, the
    `describe()`, `beforeEach()` and `it()` functions, and inside your test cases,
    you assert them using the `expect()` function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to write and run unit tests, it’s time to dive deeper
    into the topic of e2e tests.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing of Angular applications using Cypress
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you create an application using the Nx CLI or Nx console, two projects
    are created for you: a regular application (in our case, an Angular application)
    and an e2e project configured to test the generated application project using
    the Cypress testing framework. For example, when we created the `expenses-registration`
    project, Nx also created an `expenses-registration-e2e` project. The folder for
    the `expenses-registration-e2e` project is located next to the `expenses-registration`
    project folder.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start writing our own e2e tests, let’s see what Nx generated for
    us inside the `expenses-registration-e2e` folder. When you open the `expenses-registration-e2e`
    folder, you find some folders and four files. The `.eslintrc.json`, `cypress.config.ts`,
    `project.json`, and `tsconfig.json` files are all meant to configure Cypress and
    the e2e project. We want to adjust one small thing inside the `tsconfig.json`
    file; you can leave the rest of the files untouched. Inside this `tsconfig.json`
    file, you’ll find an `include` array; inside this `include` array, add the following
    string:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Besides the configurations created by Nx, you also want to add one small thing
    inside the `.eslintrc.json` file at the root of your Nx monorepo. Inside the `.eslintrc.json`
    file at the root of your Nx monorepo, you’ll find a `project` array; inside this
    array, add the following value:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Without the two aforementioned additions to your configuration, you will run
    into some ESLint parsing errors. After adding the additional configurations, let’s
    see what else Nx has generated inside the `expenses-registration-e2e` project.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll see a `cypress` folder and an `src` folder inside the `expenses-registration-e2e`
    folder. The `cypress` folder can be ignored; inside the `src` folder, you’ll find
    `e2e`, `fixtures`, and `support` folders that have the following purposes:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '`e2e`: Inside the `e2e` folder, you’ll add the files containing your e2e tests.
    Nx already generated an `app.cy.ts` file inside this folder. As you can see, the
    file name ends with `cy.ts`. This is a naming convention for the files containing
    your Cypress e2e tests. The `cy` at the end of your file is short for Cypress.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixtures`: Inside the `fixture` folder, you can add JSON files containing
    the mock data you want to use inside your e2e test. Using fixtures is useful when
    you want to use specific data for e2e tests. Additionally, you often won’t have
    an API or mocking service you can or want to use during your e2e tests. Adding
    mocking services or APIs in your e2e tests often requires a lot of additional
    setup in both your local environment and in your pipelines where you want to run
    the e2e tests. Besides additional setup, using a real API or the same mocking
    service as your development environment can lead to more instability for your
    e2e test.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`support`: Inside the `support` folder, you’ll find everything you need to
    write and run your e2e tests. Some things you place inside the `support` folder
    are a file containing all the imports you use inside the e2e project, a file containing
    page objects used inside your `.cy.ts` files, additional setup files, or files
    with custom Cypress commands.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have an idea of what Nx generated for you and what the files and
    folders inside your e2e project are used for, let’s start to write and run e2e
    tests for the `expenses-registration` project.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first e2e test
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by removing the `app.cy.ts` file and replacing it with an `expenses-registration.cy.ts`
    file. Inside this `expenses-registration.cy.ts` file, we will write the e2e tests
    that will test the *expenses-registration application*. As we did with the unit
    tests, we define a `describe()` function. You use the `describe()` function for
    grouping multiple e2e tests, similar to the `describe()` function we used for
    the unit tests. The `describe()` function takes two arguments: a description and
    a callback function:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, inside the callback function of the `describe()` function, we will add
    a `beforeEach()` function. Inside the `beforeEach()` function, you can define
    the steps you want to perform before each e2e test. Some common steps defined
    inside the `beforeEach()` function are visiting the URL of your application, setting
    up interceptors, logging in as a user, and closing the cookie consent message.
    In our case, we will only visit the URL of the application, and later, we will
    create an interceptor to demonstrate how you can use the fixtures to provide mocked
    data:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, we defined the `beforeEach()` function, and inside the
    callback, we visited the base URL of our application using the `visit()` method
    on the `cy` object. The `cy` object is a global helper object provided to you
    by the Cypress framework used for all sorts of things, such as visiting pages,
    accessing page and window objects, reacting to events, setting up interceptors,
    and waiting for requests. In the preceding example, we used the `visit()` method.
    We provided it with an empty string as a function parameter to indicate Cypress
    should visit the base URL of our application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining the `beforeEach()` function and visiting your application base
    URL, let’s add our first simple e2e test. As with unit tests, your test cases
    are defined using the `it()` function. Similar to the unit tests, your `it()`
    functions receive a description and a callback function. Inside the callback function,
    you write the code for your test cases. Let’s start simple and write an e2e test
    to check whether the application redirects to the `expenses-overview` route when
    we visit the base URL:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see in the preceding code, we describe the test case and then write
    the logic for our test case inside the callback of the `it()` function. For the
    prior test case, we only need one line of logic. The `beforeEach()` function will
    open the application on the base URL. When we open our app on the base URL, we
    should be redirected to the `expenses-overview` route, so when we reach the `it()`
    function, the application should be redirected to the `expenses-overview` route.
    In this test case, you only have to assert whether the current URL equals `http://localhost:4200/expenses-overview`.
    In your Cypress tests, you generally get a page or window element and interact
    with them or assert the text, CSS classes, or attributes; in this case, you get
    the browser URL and assert whether the URL equals the text you expect.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The `cy` object exposes most window objects by default; if you want to access
    elements from within the HTML structure of your application, you can use the `.get()`
    method on the `cy` object. In our example, we are interested in the URL, which
    is located in the `location.href` property of the `window` object. The `cy` object
    exposes the `location.href` property by default using the `.``URL()` method.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'After you get the element you want to assert, you can chain the `.should()`
    assertion method to make the assertion you want to make. The `.should()` method
    takes in two parameters: an assertion type and a value with which to perform the
    assertion. In our case, we provided the `.should()` method with the `equal` assertion
    type and provided the `http://localhost:4200/expenses-overview` value to check
    whether our provided value equals the element we want to assert—in this instance,
    the URL.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a list of all assertion types in the official Cypress documentation:
    [https://docs.cypress.io/guides/references/assertions](https://docs.cypress.io/guides/references/assertions).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve written the first e2e tests and explained how everything works,
    let’s run the e2e test and see whether the test will succeed. You can start your
    e2e tests by running the following terminal command at the root of your Nx monorepo:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding command, you need to replace `<project-name>` with the name
    found in the `project.json` file of the e2e project you want to run. Just as with
    the unit tests, you can also run the e2e tests for multiple projects using the
    `run-many` command or for affected projects with the `affected` command.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: When running one of the aforementioned commands, the e2e tests will run headlessly,
    meaning no browser will be opened to execute your e2e tests. Running your e2e
    tests headlessly is ideal if you want to run your tests in a build pipeline or
    another environment where you don’t have access to a browser.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'It is nice to see Cypress executing the tests in a real browser during the
    development process. When Cypress executes the tests in a real live browser, you
    can better understand why tests are failing. There is a nice user interface allowing
    you to easily spot what tests are failing and navigate to the specific steps in
    which they’re failing. To run the e2e tests in a real live browser, you can use
    the following command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So let’s change the `<project-name>` placeholder with `finance-expenses-registration-e2e`
    and run the test we created:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As shown in *Figure 11**.1*, the Cypress UI will be started and ask you to
    choose a browser when you run the preceding terminal command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: Cypress UI start screen](img/B21625_11_001.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: Cypress UI start screen'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `.cy.ts` files located inside the `e2e` folder of your e2e project;
    in our case, we only have one file, the `expenses-registration.cy.ts` file. When
    you click on the file name, Cypress will run the e2e tests for that specific file.
    In *Figure 11**.2*, you can see what the test run looks like for our `expenses-registration.cy.ts`
    file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: Cypress UI test run screen](img/B21625_11_002.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Cypress UI test run screen'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 11**.2*, on the left side, you can see the tests that are
    being executed and whether they pass or fail, and on the right side, you can see
    the application and what Cypress is doing inside the application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, Nx creates an e2e project for each application you generate using
    the Nx cli or Nx console. You create `.cy.ts` files inside the `e2e` folder to
    define your test cases. Test cases are grouped using the `describe()` function
    and the `beforeEach()` function, which can be used to execute logic before each
    e2e test. The test cases themselves are defined using the `it()` function, and
    inside the callback of your `it()` function, you define the test logic. You can
    get elements using the `cy` object and assert values using the `.should()` method
    combined with an assertion type and a value to assert. When you define your tests,
    you can execute them in a real browser or headlessly if you want to run them inside
    an environment where you don’t have access to a browser.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned the basics of e2e testing, created your first test,
    and run your test using the Cypress UI, let’s add some extra e2e tests to learn
    about additional concepts and patterns commonly used within e2e testing.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Defining page objects for e2e testing
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common pattern in e2e testing is the **page object pattern**. When using the
    page object pattern, you abstract the selection of page elements away from the
    actual tests, resulting in more readable and maintainable tests. To demonstrate
    the page object pattern, let’s first create a new e2e test without using the page
    object pattern and then adjust the new test by using the page object pattern.
    The new test case will check whether the **Show summary** button is shown by default,
    and when we click the button, the summary will be shown. Additionally, the test
    checks whether the button text is changed to **Hide summary** and whether the
    summary disappears if we click on the button again.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this test case, let’s start by defining the `it()` function and provide
    it with a description for the test case:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that the `it()` function has been defined and we have provided a fitting
    description, we need to add the testing logic inside the callback of the `it()`
    function. First, we need to get the button we used to toggle the summary. As mentioned
    before, you can get elements from within your application using `cy.get()`. You
    provide the `.get()` method with a query selector; these selectors work identically
    to jQuery selectors:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding code snippet, you can see we use `cy.get()` and provide it
    with the query selector to get the **Show summary** button. If you’re not familiar
    with jQuery selectors, you can alternatively copy the selector through the **DevTools**
    of the Chrome browser. Simply inspect the HTML page, find the element you want
    to use inside your Cypress test in your **DevTools**, right-click on the element,
    and select **Copy** | **Copy selector**. In *Figure 11**.3*, you can see where
    you can copy the selector:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: DevTools Copy selector](img/B21625_11_003.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: DevTools Copy selector'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'The selectors copied using the **DevTools** always start at the root of your
    HTML document and can be simplified by removing the beginning of the selector.
    Now that you know how to select elements so you can use them within your tests,
    let’s write the rest of the test logic:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, we first define two constants, one for `button` and one
    for `summary`. As you can see, we use a function that returns the `cy.get()` method.
    Directly assigning the return value of `cy.get()` to a variable is an anti-pattern
    because you can modify the return value during your tests. Commonly, when you
    get the button, you want to get it unmodified, so we create a function that returns
    the `cy.get()` function call and assign that to our variables.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: After defining the two constants, we check whether the button contains the **Show
    summary** text and whether the summary element doesn’t exist yet. Afterward, we
    click the button and check whether the button text is changed to **Hide summary**
    and whether the summary element exists. Lastly, we click the button again and
    see if everything is toggled back to its initial state.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run your e2e tests now, you’ll find that the test succeeds. While there
    is nothing wrong with this test, there are some things we can do to clean it up
    a bit. First, we can simplify the selectors by adding a `data-test-id` attribute
    on the HTML elements we want to select. The `data-test-id` attribute is a simple
    HTML attribute commonly added to elements you want to use in your e2e tests. So,
    let’s add the attribute to the button and summary element inside your `expenses-overview-page.component.html`
    file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<td data-test-id attributes, you can simplify the selectors used inside your
    e2e test. Instead of the long selector used to select the button and summary elements,
    you can use the following syntax:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, this dramatically simplifies the selectors for your HTML elements.
    Besides simplifying the selectors by introducing the `data-test-id` attributes,
    you can create a function that checks the button text and checks whether the summary
    element exists. You don’t have to repeat it three times inside your test.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined the logic for the test case, it’s time to improve
    it and move some logic to the page object file. Start by removing the `app.po.ts`
    file from the support folder and adding a `new expenses-overview.po.ts` file.
    As you might have figured out, the `.po.ts` is short for `.page-object.ts`. Inside
    the `expenses-overview.po.ts` file, you will define all the logic to get the elements
    needed for the e2e tests for the `expenses-overview` page. By abstracting the
    element selection to this page object file, you can easily reuse them, making
    your e2e tests smaller and easier to read, write, and maintain. Currently, we
    only have two elements we can move to the page object file—the summary button
    and the summary element:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding code snippet, you can see that we moved the two constants defined
    inside the test case to the page object file and exported them so they can be
    accessed inside the e2e tests. We also gave the two constants a more descriptive
    name. Now, inside the `expenses-registration.cy.ts` file, import the two constants
    and adjust the e2e test to use the imported constants. If you now need the button
    or summary type in another e2e test, you can simply use the one defined inside
    the page object file instead of redefining the logic to get the element.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the page object file, we can also add the function to check the `toggle
    summary button` text and the visibility of the summary itself:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After adding the preceding function, let’s update the e2e test to use the function
    and see the final result after adding the page object file:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see in the preceding code, now that we use the page object pattern,
    the test is much easier to understand and needs fewer lines of code; besides that,
    the code is easier to reuse in new test cases.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, you select elements using the `cy.get()` method combined with
    selectors identical to jQuery selectors. To simplify your selectors, you can use
    `data-test-id` attributes, and by using the page object pattern, you can abstract
    the element selection logic away from your test cases, making your tests easier
    to read, write, and maintain. Now that you have a better grasp of how to select
    elements and how the page object pattern can help you write better e2e tests,
    let’s learn how to intercept requests and use mock data from your fixtures inside
    your e2e tests.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Using fixtures in your e2e tests
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Fixtures are used to provide your e2e tests with specific mock data. Using mock
    data for your e2e tests ensures that you have stable data with which to run your
    e2e tests. Often, you need to run your e2e tests in an environment where you don’t
    have access to an API or mocking service; in this case, you can use the data defined
    in your fixtures. Another common scenario is that you run your e2e tests in your
    test or acceptance environment, and the data on these environments isn’t always
    stable and might change over time, resulting in failing tests. So, depending on
    your environment, fixtures can provide you with additional stability, ensuring
    that your tests don’t fail based on the data but only fail if you actually break
    something within your application code.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first run the e2e tests in production mode to demonstrate why you need
    fixtures. Our `mock.interceptor.ts` file will not return the mock data if we serve
    a production build of our application. You can use the following terminal command
    to run the e2e tests with a production build of the application:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After running the preceding command, you’ll notice the application doesn’t have
    any data to display during the e2e tests. For our current test cases, this is
    no issue, but when you have more tests, this will most likely result in some failing
    tests. Instead of relying on `mock.interceptor.ts`, we can use the fixtures to
    provide data during the e2e tests.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: To use the data from your fixtures, you first need to add a file with mock data
    inside the `fixtures` folder. We will use the same mock data as we use for our
    mock interceptor, so start by copying the `expenses.json` file inside the `assets/api`
    folder from your *expenses-registration application* to the `fixtures` folder
    of your e2e project.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'After copying the `expenses.json` file, you need to adjust the `beforeEach()`
    function inside the `expenses-registration.cy.ts` file. Inside the `beforeEach()`
    function, you need to set up an interceptor to intercept the API request we make
    to get the expenses and provide it with a file from your fixtures:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding code, you can see we set up the interceptor using the `cy.intercept()`
    method. The `cy.intercept()` method first takes a string to define what type of
    API request you want to intercept; in our case, we want to intercept a `GET` request.
    Next, you need to provide the API URL you want to intercept, and lastly, you need
    to provide an object with a fixture property assigned with the fixture file you
    want to use as a response for the intercepted request. At the end of the `cy.intercept()`
    method, we chain the `.as()` method and provide that with an alias for the interceptor;
    in this case, we used `getExpenses`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: After setting up the interceptor, we define the `cy.visit()` method to visit
    the application page, just like we did before. After the `cy.visit()` method,
    we define the `cy.wait()` method, indicating that Cypress must wait for the interceptor
    we set up. Then, provide the `cy.wait()` method with the interceptor alias prefixed
    with an `@` sign.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The preceding steps involve everything required to use the fixture file for
    your mock data during the e2e tests. If you need to set up the same interceptor
    and visit the same page for multiple testing files, you can abstract the logic
    away into a function and call that function inside the `beforeEach()` callback
    so that you don’t have to repeat yourself multiple times.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test whether the interceptor and fixture work by running the e2e tests
    in production using the following command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: After running the preceding command, you’ll notice that the application shows
    data again when running the e2e tests.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, you learned that fixtures can be used to provide mock data during
    your e2e tests. Using mock data can provide your tests with additional stability
    and help you run them in an environment where you don’t have access to an API
    or mocking service. You use fixtures by setting up an interceptor in the `beforeEach()`
    function of your tests and providing the interceptor with the fixture file.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about automated application testing. You learned
    that unit tests are used to test small code units in isolation to ensure the code
    implantation works as expected. e2e testing tests applications from the user’s
    perspective and checks whether the correct values are displayed and user interactions
    are processed and rendered correctly in the application view. Component testing
    is a relatively new concept, comparable to e2e testing, but instead of compiling
    and testing an entire application, component testing focuses on testing a single
    component from the perspective of a user. Lastly, integration tests are used to
    check how different modules and elements of your software integrate together.
    Integration tests can be implemented on various levels, for example, to check
    whether code implementation remains working when you combine multiple components
    and services or whether your application still works when you combine and deploy
    various Angular applications and backend APIs as a single product for your customers.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: After learning about the different types of tests, you created your own unit
    and e2e tests. You learned about the `describe()`, `beforeEach()`, and `its()`
    functions and how they can be used for e2e and unit tests. You learned how to
    use mock data in e2e tests and stub components and services in your unit tests.
    Asserting values in unit tests is done using the `expect()` function, and in e2e
    tests, you use the `cy.should()` method.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you learned about different terminal commands to run tests for individual
    files, single projects, multiple projects, or projects that are affected by your
    changes. In the next and final chapter of this book, you’ll add the finishing
    touches and learn about the different steps you need to take to deploy Angular
    applications in your Nx monorepo.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
