- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Building a Quiz Game Application to Learn about Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过构建问答游戏应用程序来学习测试
- en: In this chapter, we will continue our journey and build a quiz game application
    using Nuxt 3, with a deep focus on enhancing our testing skills. This chapter
    is crafted for developers aiming to refine their skills in unit testing and **End-to-End**
    (**E2E**) testing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续我们的旅程，使用Nuxt 3构建一个问答游戏应用程序，并深入关注提高我们的测试技能。本章是为那些希望提高单元测试和**端到端**（**E2E**）测试技能的开发者量身定制的。
- en: Initially, we’ll talk about the importance of testing in software development,
    illustrating how it serves as the backbone of any application. We’ll kick off
    with unit testing, where you’ll learn how to construct unit tests for both the
    Pinia store and Vue components, ensuring each piece of logic and every UI element
    behaves as intended.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论在软件开发中测试的重要性，说明它如何作为任何应用程序的支柱。我们将从单元测试开始，在这里你将学习如何为Pinia存储和Vue组件构建单元测试，确保每一块逻辑和每一个UI元素都按预期工作。
- en: Following this, we’ll continue our testing strategy to learn about E2E tests,
    simulating real user interactions to affirm the overall functionality of the quiz
    game. We will also provide visual insights into test results and coverage.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续我们的测试策略，了解端到端测试（E2E测试），模拟真实用户交互以确认问答游戏的整体功能。我们还将提供测试结果和覆盖率的视觉洞察。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Implementing the quiz game app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现问答游戏应用程序
- en: Writing unit tests for the Pinia store
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Pinia存储编写单元测试
- en: Writing unit tests for components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为组件编写单元测试
- en: Writing end-to-end tests for the quiz game
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为问答游戏编写端到端测试
- en: Exploring Vitest UI and test coverage tools
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Vitest UI和测试覆盖率工具
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter07](https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter07).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter07](https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter07)找到。
- en: The CiA video for this chapter can be found on [https://packt.link/tAMjs](https://packt.link/tAMjs)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可以在[https://packt.link/tAMjs](https://packt.link/tAMjs)找到。
- en: Exploring the repository
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索仓库
- en: 'As we did in the previous chapter, let’s quickly review the `starter` folder
    in our repository. This folder, pre-populated with essential components, a quiz
    store, and TypeScript interfaces, is ready to be copied into your new project.
    It serves as the groundwork, allowing us to concentrate on the critical task of
    this chapter: implementing and learning testing strategies within Nuxt 3.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中所做的那样，让我们快速回顾一下我们仓库中的`starter`文件夹。这个文件夹预先填充了必要的组件、问答存储和TypeScript接口，准备好复制到你的新项目中。它作为基础，使我们能够专注于本章的关键任务：在Nuxt
    3中实现和学习测试策略。
- en: Essential background – fundamentals of testing
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必要的背景知识——测试基础
- en: As we shift our focus to testing in [*Chapter 7*](B19760_07.xhtml#_idTextAnchor141),
    understanding the foundational aspects of testing becomes crucial. Testing is
    a critical process in software development, aimed at ensuring that your application
    performs correctly under various scenarios.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将重点转向第[*7章*](B19760_07.xhtml#_idTextAnchor141)中的测试时，理解测试的基础知识变得至关重要。测试是软件开发中的一个关键过程，旨在确保你的应用程序在各种情况下都能正确运行。
- en: 'Traditionally, developers used to test applications manually, which required
    hands-on effort to find bugs. However, the evolution of testing practices has
    significantly reduced reliance on manual testing through the adoption of automated
    testing. Automated testing introduces efficiency and consistency by automating
    repetitive tasks. It encompasses three primary levels:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，开发者习惯于手动测试应用程序，这需要手动努力来查找错误。然而，测试实践的演变通过采用自动化测试显著减少了对手动测试的依赖。自动化测试通过自动化重复性任务引入了效率和一致性。它包括三个主要级别：
- en: '**Unit** testing: Focuses on testing individual components or functions in
    isolation, making it easier to pinpoint errors.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：专注于测试单个组件或函数的独立情况，这使得定位错误变得更加容易。'
- en: '**Integration** testing: Tests the interaction between integrated units or
    components to ensure they work together as intended. While this chapter will not
    focus heavily on integration testing, it remains an important part of the testing
    pyramid.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：测试集成单元或组件之间的交互，以确保它们按预期协同工作。虽然本章不会重点介绍集成测试，但它仍然是测试金字塔的一个重要组成部分。'
- en: '**E2E testing**: Simulates real-world user behaviors and interactions with
    the application from start to finish, ensuring the entire system functions as
    expected.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：从开始到结束模拟真实用户与应用程序的行为和交互，确保整个系统按预期运行。'
- en: By implementing automated testing, we can significantly reduce the need for
    manual testing, allowing for more frequent and comprehensive test runs with less
    effort. Next, let’s see how to implement the quiz game app.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现自动化测试，我们可以显著减少手动测试的需求，允许以更频繁、更全面的测试运行，且更省力。接下来，让我们看看如何实现测验游戏应用。
- en: Implementing the quiz game app
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现测验游戏应用
- en: We will kick off our quiz game application by setting up a new Nuxt 3 project.
    As with our previous endeavors, we’ll utilize the `starter` folder to fast-track
    our development process. Once you’ve created your new project, copy the contents
    of the starter folder into it. If prompted, agree to replacing the existing files.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过设置一个新的Nuxt 3项目来启动我们的测验游戏应用。就像我们之前的努力一样，我们将利用`starter`文件夹来加速我们的开发过程。一旦您创建了新的项目，请将`starter`文件夹的内容复制到其中。如果提示，请同意替换现有文件。
- en: 'Next, we’ll need to install a few essential Nuxt modules, such as Pinia, Tailwind
    CSS, and Google Fonts. We already discussed each module in previous chapters.
    Run the following commands in your terminal to add these packages to your project:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装几个基本的Nuxt模块，例如Pinia、Tailwind CSS和Google Fonts。我们已经在之前的章节中讨论了每个模块。请在您的终端中运行以下命令，将这些包添加到您的项目中：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With the dependencies in place, it’s time to fire up our project and see the
    initial setup in action. Execute the project as usual:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好依赖项后，是时候启动我们的项目并看到初始设置的实际效果了。像往常一样执行项目：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Upon running the project, you should be greeted with the initial layout of
    the quiz game application:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目后，您应该会看到测验游戏应用的初始布局：
- en: '![Figure 7.1: Quiz game app](img/B19760_07_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：测验游戏应用](img/B19760_07_01.jpg)'
- en: 'Figure 7.1: Quiz game app'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：测验游戏应用
- en: Before diving into the testing aspect of our quiz game application, let’s take
    a moment to understand the structure and components that form the backbone of
    our project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入到我们的测验游戏应用测试方面之前，让我们花一点时间来了解构成我们项目骨架的结构和组件。
- en: Questions data
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题是数据
- en: The questions data is located in `data/questions.ts`. It stores the quiz questions,
    each with multiple answers, enabling the dynamic generation of quizzes each time
    a user engages with the app.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 题目数据位于`data/questions.ts`中。它存储了测验问题，每个问题都有多个答案，使得每次用户与应用程序互动时都能动态生成测验。
- en: Types definitions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型定义
- en: 'The structure and types of data used across the application are meticulously
    defined in `types/index.ts`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中使用的结构和数据类型在`types/index.ts`中进行了细致的定义：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s ad breakdown of the types:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对类型的概述：
- en: '`rightAnswerId`)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rightAnswerId`)'
- en: '**Answer**: Defines the structure for each answer option for a question, with
    its own ID and the answer body'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**答案**：定义了每个问题答案选项的结构，包括其自己的ID和答案正文'
- en: '`Question` type by including the user’s selected answer (`userAnswer`) and
    a flag (`answerIsRight`) indicating whether the chosen answer is correct'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过包含用户的所选答案（`userAnswer`）和一个标志（`answerIsRight`），指示所选答案是否正确来定义`Question`类型
- en: Next, let’s see the content of the quiz store.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看测验存储的内容。
- en: Quiz Pinia store
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测验Pinia存储
- en: This store is designed to manage the game’s state using Pinia, from tracking
    the current question to calculating the player’s score. Here’s an overview of
    its key features.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存储库旨在使用Pinia管理游戏状态，从跟踪当前问题到计算玩家的分数。以下是其关键功能的概述。
- en: 'This initial segment sets up the quiz store and initializes the state, including
    the current question index, quiz completion status, results array, and score:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始部分设置了测验存储并初始化了状态，包括当前问题索引、测验完成状态、结果数组和分数：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, `quiz` is a computed property that selects five random questions from
    the provided questions dataset, ensuring a varied quiz experience each time:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`quiz`是一个计算属性，它从提供的题目数据集中选择五个随机问题，确保每次测验体验的多样性：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that `selectRandomQuestions` is a utility function stored in the `utils`
    folder. So, it’s automatically imported due to the power of the Nuxt auto-imports
    feature.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`selectRandomQuestions`是一个存储在`utils`文件夹中的实用函数。因此，由于Nuxt自动导入功能的强大，它会被自动导入。
- en: 'To get the instance of the current question based on `currentQuestionIndex`,
    we’ll create another computed method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了根据`currentQuestionIndex`获取当前问题的实例，我们将创建另一个计算方法：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, in order to update the progress, there is a function called `updateProgress`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了更新进度，有一个名为`updateProgress`的函数：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`updateProgress` is a crucial function that evaluates whether the user’s answer
    is correct, updates the score for correct answers, and appends the question along
    with the user’s answer and the correct answer to the results array. It also determines
    whether to move to the next question or conclude the quiz.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateProgress`是一个关键函数，它评估用户的答案是否正确，为正确答案更新分数，并将问题以及用户的答案和正确答案附加到结果数组中。它还确定是否移动到下一个问题或结束测验。'
- en: 'Finally, in order to restart the quiz after finishing, we can use the `restartQuiz`
    function, which allows users to reset the quiz to its initial state, clearing
    all progress and scores, and make another attempt with the same set of questions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了在完成测验后重新开始，我们可以使用`restartQuiz`函数，该函数允许用户将测验重置到初始状态，清除所有进度和分数，并使用相同的问题集再次尝试：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Make sure to return all refs and functions at the end of the store file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在store文件末尾返回所有引用和函数：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, let’s move on to see an overview of `app.vue`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续查看`app.vue`的概述。
- en: The app.vue file
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`app.vue`文件'
- en: 'Here is the skeleton of the `app.vue` file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`app.vue`文件的框架：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This file contains the main layout and flow of our quiz game. We initiate the
    quiz store in the `script` section to be accessible within the component. `template`
    employs a conditional rendering approach with `v-if="quizFinished"`. This condition
    checks whether the quiz has concluded, based on the `quizFinished` flag from our
    `quizStore`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含我们测验游戏的主体布局和流程。我们在`script`部分初始化测验存储，以便在组件内访问。`template`使用条件渲染方法，通过`v-if="quizFinished"`。这个条件检查测验是否结束，基于`quizFinished`标志，该标志来自我们的`quizStore`。
- en: Upon completion, it displays the user’s score out of five and lists the questions
    alongside the user’s answers, as well as the correct answers, applying different
    background colors to indicate whether the answers were correct or incorrect. There
    is also a restart quiz button that allows users to reset the quiz and try again.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，它将显示用户在五分中的得分，并列出问题以及用户的答案，以及正确答案，应用不同的背景颜色来指示答案是否正确。还有一个重新开始测验的按钮，允许用户重置测验并再次尝试。
- en: Otherwise, the app will render `Question.vue`, which will be responsible for
    rendering the question with answers, capturing user responses, and updating the
    quiz’s progress. It’s straightforward. You can check its content from the starter
    file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，应用将渲染`Question.vue`，该组件将负责渲染带答案的问题，捕获用户响应，并更新测验的进度。这很简单。您可以从启动文件中查看其内容。
- en: Having explored the foundational components of our quiz game project, we’re
    now ready to dive into the basics of unit testing and E2E testing. This knowledge
    equips us with the necessary skills to ensure our application meets the high standards
    of quality and reliability expected in modern web development.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了我们的测验游戏项目的基石组件之后，我们现在准备好深入单元测试和端到端测试的基础。这些知识使我们具备确保我们的应用程序达到现代Web开发所期望的高标准和可靠性的必要技能。
- en: Writing unit tests for the Pinia store
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Pinia存储编写单元测试
- en: As we move forward, the task at hand involves writing unit tests for the Pinia
    store. This step is pivotal in verifying the application’s state management logic
    and introduces us to the principles of unit testing within a Pinia store.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，当前的任务涉及为Pinia存储编写单元测试。这一步对于验证应用程序的状态管理逻辑至关重要，并使我们接触到Pinia存储中的单元测试原则。
- en: Exploring Vitest
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Vitest
- en: Vitest, designed with Vite in mind, offers a next-generation testing framework
    that enhances the testing experience through integration with Vite’s ecosystem,
    leading to faster and more efficient tests. It provides a Jest-compatible API,
    enabling easy migration and parallel test execution for improved performance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Vitest，考虑到Vite而设计，提供了一个下一代测试框架，通过集成Vite生态系统来增强测试体验，从而实现更快、更高效的测试。它提供了一个与Jest兼容的API，使得迁移和并行测试执行变得容易，从而提高了性能。
- en: 'Compared to Jest, Vitest stands out for projects using Vite due to its seamless
    integration, faster setup, and execution, making it a preferred choice for modern
    web development. For more details, visit the official website: [https://vitest.dev](https://vitest.dev).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与Jest相比，Vitest因其无缝集成、快速设置和执行而突出，使其成为现代Web开发的优选选择。更多详情，请访问官方网站：[https://vitest.dev](https://vitest.dev)。
- en: 'To ensure Vitest works seamlessly with Nuxt, we integrate `@nuxt/test-utils`
    into our setup. This toolkit is designed to work with various testing frameworks
    and environments, providing flexibility and power to our testing strategy. Let’s
    clarify the key components of our setup:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保Vitest与Nuxt无缝工作，我们将`@nuxt/test-utils`集成到我们的设置中。此工具包旨在与各种测试框架和环境协同工作，为我们提供灵活性和强大的测试策略。让我们明确我们设置的关键组件：
- en: '`@nuxt/test-utils`: Essential for Nuxt applications, offering specialized tools
    and functionalities, as well as integration with existing testing frameworks,
    for a smooth testing experience in the Nuxt environment.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@nuxt/test-utils`：对于Nuxt应用程序至关重要，提供专门的工具和功能，以及与现有测试框架的集成，以在Nuxt环境中提供流畅的测试体验。'
- en: '`Vitest`: Our chosen testing framework.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vitest`：我们选择的测试框架。'
- en: '`happy-dom`: A lightweight DOM simulation library, `happy-dom` provides a more
    accurate and faster simulation of browser environments within tests. It’s chosen
    for its efficiency in running tests that involve DOM manipulation or browser API
    interactions, replicating how components behave in a real browser without needing
    one.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`happy-dom`：一个轻量级的DOM模拟库，`happy-dom`为测试提供了更准确和更快的浏览器环境模拟。它因其运行涉及DOM操作或浏览器API交互的测试的高效性而被选中，它能够复制组件在真实浏览器中的行为，而无需实际浏览器。'
- en: 'Now, install these tools with the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令安装这些工具：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We then create a `vitest.config.ts` file in the root of our project. This configuration
    file is crucial for specifying our test environment preferences:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在项目的根目录下创建一个`vitest.config.ts`文件。此配置文件对于指定我们的测试环境偏好至关重要：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By setting the environment to `'happy-dom'`, we instruct Vitest to simulate
    a browser-like environment using `happy-dom` for our tests.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将环境设置为`'happy-dom'`，我们指示Vitest使用`happy-dom`模拟浏览器环境进行我们的测试。
- en: Next, we create a test file named `temp.spec.ts` in the root folder of our project.
    The `.spec` suffix in the filename is a convention that stands for “specification.”
    It signifies that the file contains a series of specifications (tests) that describe
    how the application or a particular component should behave. This naming convention
    helps Vitest to automatically locate and execute tests, scanning for files that
    end with `.spec.ts` or `.test.ts`, when we run the `vitest` command.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在项目的根目录下创建一个名为`temp.spec.ts`的测试文件。文件名中的`.spec`后缀是一个约定，代表“规范”。它表示该文件包含一系列规范（测试），描述了应用程序或特定组件应该如何行为。这种命名约定有助于Vitest在运行`vitest`命令时自动定位和执行测试，扫描以`.spec.ts`或`.test.ts`结尾的文件。
- en: 'Let’s now populate `temp.spec.ts` with a simple test to get familiar with Vitest’s
    syntax and capabilities:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用Vitest的语法和能力的一个简单测试来填充`temp.spec.ts`，以便熟悉Vitest：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, `describe` is used to group our test under a common suite,
    `it` outlines an individual test case, and `expect` formulates an assertion about
    the code’s behavior. Here, we’ve created a simple test case to ensure that the
    `sum` function is working properly. We expected the result of `sum(2, 3)` to be
    equal to `5`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`describe`用于将我们的测试分组到公共套件中，`it`概述单个测试用例，而`expect`则对代码的行为提出断言。在这里，我们创建了一个简单的测试用例，以确保`sum`函数正常工作。我们期望`sum(2,
    3)`的结果等于`5`。
- en: 'To run our newly created test, we first need to make a small adjustment to
    our project’s `package.json` file. By adding a new script entry for `"test"`,
    we configure it to execute `vitest`, which in turn runs our test suite:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们新创建的测试，我们首先需要对我们项目的`package.json`文件进行一些小的调整。通过添加一个新的脚本条目`"test"`，我们配置它执行`vitest`，然后它运行我们的测试套件：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With this script in place, execute the test suite by running the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本到位后，通过运行以下命令执行测试套件：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Upon execution, Vitest springs into action, automatically scanning the project
    for any test files. For our simple test in `temp.spec.ts`, Vitest should recognize
    it as the sole test file, identifying the single `describe` block and the one
    test case it contains. If everything is set up correctly, you’ll see output indicating
    that the test case passed as expected:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行过程中，Vitest迅速启动，自动扫描项目中的任何测试文件。对于我们的简单测试`temp.spec.ts`，Vitest应该将其识别为唯一的测试文件，识别包含的单个`describe`块和其中包含的一个测试用例。如果一切设置正确，你将看到表示测试用例按预期通过的输出：
- en: '![Figure 7.2: Vitest output](img/B19760_07_02.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：Vitest输出](img/B19760_07_02.jpg)'
- en: 'Figure 7.2: Vitest output'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：Vitest输出
- en: 'Next, let’s introduce an additional test case to our `temp.spec.ts` file, one
    that we anticipate will fail, to observe Vitest’s behavior in handling failing
    tests:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在 `temp.spec.ts` 文件中引入一个额外的测试用例，我们预计它会失败，以观察 Vitest 在处理失败测试时的行为：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Vitest continuously monitors for any changes in your test files. So, when you
    save your `temp.spec.ts` file with the intentionally failing test, Vitest automatically
    re-runs the tests. This time, you’ll notice in the terminal output that while
    the first test case passes as before, the new test case fails. This immediate
    feedback highlights the failing assertion, offering insights into what went wrong
    and where, directly in your terminal:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Vitest 会持续监控你的测试文件中的任何更改。因此，当你保存包含故意失败的测试的 `temp.spec.ts` 文件时，Vitest 会自动重新运行测试。这次，你会在终端输出中注意到，尽管第一个测试用例像以前一样通过，但新的测试用例失败了。这种即时反馈突出了失败的断言，直接在你的终端中提供了出错和出错位置的信息：
- en: '![Figure 7.3: Vitest output with wrong tests](img/B19760_07_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3：带有错误测试的 Vitest 输出](img/B19760_07_03.jpg)'
- en: 'Figure 7.3: Vitest output with wrong tests'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：带有错误测试的 Vitest 输出
- en: Now, with Vitest actively monitoring our project for changes, let’s proceed
    to test the quiz store to ensure its logic performs correctly under various conditions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着 Vitest 主动监控我们的项目以查找更改，让我们继续测试测验存储，以确保其在各种条件下逻辑正确执行。
- en: Testing the quiz store
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试测验存储
- en: Our focus now shifts to the quiz store. By unit testing this store, we aim to
    confirm that our game’s logic and state management work as intended, providing
    a solid foundation for a great user experience.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将重点转向测验存储。通过对这个存储进行单元测试，我们旨在确认我们的游戏逻辑和状态管理按预期工作，为提供良好的用户体验奠定坚实的基础。
- en: 'First, let’s clear the stage by removing the `temp.spec.ts` temporary test
    file and creating `quiz.spec.ts` in the `/stores` folder next to our quiz store.
    To effectively unit test a Pinia store, we have to establish a fresh Pinia instance
    for each test:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过删除 `temp.spec.ts` 临时测试文件并在 `/stores` 文件夹中创建 `quiz.spec.ts` 来清理舞台，该文件夹位于我们的测验存储旁边。为了有效地对
    Pinia 存储进行单元测试，我们必须为每个测试建立一个新的 Pinia 实例：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `beforeEach` function is important for maintaining test integrity. It’s
    a function provided by Vitest that runs before each test case in our `describe`
    block. By calling `setActivePinia(createPinia())` within `beforeEach`, we guarantee
    that each test interacts with a fresh instance of Pinia, allowing us to assess
    the functionality of the quiz store in each test independently.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach` 函数对于保持测试完整性非常重要。这是 Vitest 提供的一个函数，在 `describe` 块中的每个测试用例之前运行。通过在
    `beforeEach` 中调用 `setActivePinia(createPinia())`，我们确保每个测试都与 Pinia 的新实例交互，从而使我们能够独立评估每个测试中测验存储的功能。'
- en: 'With our testing setup ready, it’s time to write our first test:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试设置准备就绪后，是时候编写我们的第一个测试了：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This test verifies that the quiz store correctly initializes with a set of five
    questions, ensuring our game starts with the expected number of challenges for
    the player. After running the test, the terminal should indicate the test case
    passed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试验证了测验存储正确地初始化了包含五个问题的集合，确保我们的游戏以玩家预期的挑战数量开始。在运行测试后，终端应指示测试用例通过。
- en: To ensure our quiz store behaves as expected, we need to test each function
    comprehensively. One crucial aspect is verifying that the store correctly handles
    incorrect answers. The idea here is to simulate a scenario where a player chooses
    a wrong answer and to confirm that such an action does not lead to an increase
    in their score.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的测验存储按预期行为，我们需要全面测试每个函数。一个关键方面是验证存储是否正确处理了错误答案。这里的想法是模拟一个玩家选择错误答案的场景，并确认这种操作不会导致他们的分数增加。
- en: 'Here’s how we implement this test:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何实现这个测试的：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To achieve 100% coverage, we should continue using this testing approach for
    every function within the quiz store, ensuring each aspect of our game’s logic
    is rigorously validated.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到 100% 的覆盖率，我们应该继续使用这种测试方法对测验存储中的每个函数进行测试，确保我们游戏逻辑的每个方面都得到严格的验证。
- en: 'Following the approach to not increment the score with a wrong answer, we will
    also test the positive scenario. We implement a similar test case to ensure the
    score increments by 1 when the correct answer is selected:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在不增加错误答案分数的方法之后，我们还将测试积极场景。我们实现了一个类似的测试用例，以确保在选择了正确答案时分数增加 1：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, let’s validate the quiz’s flow with a test to ensure it moves to the
    next question after an answer is selected. This test starts by checking the initial
    question index is 0, simulates answering the first question, and then confirms
    the quiz store correctly updates to indicate the next question is ready:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过一个测试来验证测验的流程，确保在选择了答案后，测验能够移动到下一个问题。这个测试首先检查初始问题索引为 0，模拟回答第一个问题，然后确认测验存储正确更新，以指示下一个问题已准备好：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To conclude our testing of the quiz flow, we implement a test to confirm the
    quiz is marked as finished after the last question is answered. This test iterates
    through all questions, simulating correct answers for each, and checks that the
    quiz store flags the quiz as completed. It further verifies that all questions
    have been accounted for in the results, ensuring the game concludes as expected:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成对测验流程的测试，我们实现了一个测试来确认在回答最后一个问题后，测验被标记为完成。这个测试遍历所有问题，模拟每个问题的正确答案，并检查测验存储将测验标记为完成。它进一步验证了所有问题都已计入结果，确保游戏按预期结束：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With these main test cases covered, we’ve laid a solid foundation for ensuring
    the quiz store functions correctly. For a complete view of all test cases, please
    refer to the full suite available in the project repository.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些主要测试用例得到覆盖后，我们已经为确保测验存储正确运行奠定了坚实的基础。要查看所有测试用例的完整视图，请参阅项目存储库中可用的完整测试套件。
- en: Next, let’s shift our focus to writing unit tests for the `Question` component,
    where we’ll apply similar rigor to ensure the components of our quiz game app
    behave as expected under various scenarios.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将重点转向编写 `Question` 组件的单元测试，我们将应用类似的严谨性来确保我们的测验游戏应用在各种场景下表现如预期。
- en: Writing unit tests for components
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为组件编写单元测试
- en: When transitioning from testing the store to testing Vue components, our focus
    moves toward verifying that components behave as expected when they receive props,
    interact with the Pinia store, and render correctly. Component testing can include
    checking that components properly display data passed via props, react to user
    input, and integrate seamlessly with the store for state management.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当从测试存储过渡到测试 Vue 组件时，我们的重点转向验证组件在接收属性、与 Pinia 存储交互以及正确渲染时的行为。组件测试可以包括检查组件是否正确显示通过属性传递的数据，对用户输入做出反应，以及与存储无缝集成以进行状态管理。
- en: Setting up for component testing
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置组件测试环境
- en: 'To effectively test Vue components, we introduce two crucial tools: `@vue/test-utils`
    and `@pinia/testing`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地测试 Vue 组件，我们引入了两个关键工具：`@vue/test-utils` 和 `@pinia/testing`：
- en: '`@vue/test-utils`: This library provides utilities to mount and interact with
    Vue components in a testing environment. The `mount` function is particularly
    important as it allows us to render a component in isolation and returns a wrapper
    object that we can use to examine the rendered output and simulate user interactions.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/test-utils`：这个库提供了一组在测试环境中挂载和与 Vue 组件交互的实用工具。`mount` 函数尤为重要，因为它允许我们独立渲染一个组件，并返回一个包装器对象，我们可以用它来检查渲染输出并模拟用户交互。'
- en: '`@pinia/testing`: This offers tools for testing Pinia stores within Vue components.
    The `createTestingPinia` function is used to create a mock Pinia instance that
    can be used in tests.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@pinia/testing`：这为在 Vue 组件中测试 Pinia 存储提供了工具。`createTestingPinia` 函数用于创建一个模拟的
    Pinia 实例，可以在测试中使用。'
- en: 'So, let’s install these libraries:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们安装这些库：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, let’s move on to creating the component test file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续创建组件测试文件。
- en: Creating the Question.spec.ts test file
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Question.spec.ts 测试文件
- en: 'Inside the `/components` folder, create a file called `Question.spec.ts` and
    add the following code to it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/components` 文件夹内，创建一个名为 `Question.spec.ts` 的文件，并将以下代码添加到其中：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here’s a breakdown of the code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码的分解：
- en: The `wrapper` object returned by `mount` encapsulates the mounted component,
    providing a range of methods and properties to query and interact with it. This
    wrapper allows you to test the component’s rendered output, check its state, and
    simulate user interactions, such as clicks and input changes..
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 `mount` 返回的 `wrapper` 对象封装了挂载的组件，提供了一系列方法和属性来查询和与之交互。这个包装器允许你测试组件的渲染输出，检查其状态，并模拟用户交互，例如点击和输入更改。
- en: The `createSpy` option, used in conjunction with `createTestingPinia`, allows
    us to pass a spy function (`vi.fn` from Vitest) that can be used to monitor and
    verify interactions with the store. Spies can track calls to store refs and methods,
    providing insights into how the component interacts with the store.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createSpy` 选项与 `createTestingPinia` 结合使用，允许我们传递一个间谍函数（来自Vitest的 `vi.fn`），该函数可以用来监控和验证与存储的交互。间谍可以跟踪对存储引用和方法的调用，提供有关组件如何与存储交互的见解。'
- en: With our testing environment configured, let’s proceed to write our first unit
    test for the component.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置好我们的测试环境后，让我们开始编写该组件的第一个单元测试。
- en: Writing the component unit test
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写组件单元测试
- en: 'First, let’s have a look at the `Question.vue` component that we’ve already
    copied from the `starter` file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们已从 `starter` 文件中复制的 `Question.vue` 组件：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `Question` component is a key part of our quiz game application, designed
    to present users with a single question and its multiple-choice answers. Upon
    rendering, it dynamically displays the content of the current question retrieved
    from the Pinia store, including the question text and a set of buttons for each
    answer option. Users can select their answer by clicking one of these buttons,
    triggering the answered function that calls the `updateProgress` function from
    the Pinia store to update the quiz’s progress based on the selected answer ID
    and move on to the next question.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Question` 组件是我们问答游戏应用的关键部分，旨在向用户展示一个问题和其多项选择题的答案。在渲染时，它动态显示从Pinia存储中检索到的当前问题的内容，包括问题文本和每个答案选项的一组按钮。用户可以通过点击这些按钮之一来选择答案，触发调用Pinia存储中的
    `updateProgress` 函数的 `answered` 函数，根据所选答案的ID更新测验的进度并进入下一个问题。'
- en: 'Our goal in testing the `Question` component is to ensure it functions as intended:
    displaying the current question and its answers correctly and responding to user
    interactions appropriately.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试 `Question` 组件时，我们的目标是确保它按预期工作：正确显示当前问题和其答案，并适当地响应用户交互。
- en: 'The first test case focuses on verifying that the `Question` component correctly
    displays the current question along with its four corresponding answers. Inside
    the `Question.spec.ts` file, add the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试用例侧重于验证 `Question` 组件是否正确显示了当前问题及其四个相应的答案。在 `Question.spec.ts` 文件中，添加以下内容：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following are key points in the code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中的关键点：
- en: '`wrapper.text()`: Checks the text content of the mounted component to ensure
    it includes the current question’s body'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wrapper.text()`: 检查已挂载组件的文本内容，以确保它包含当前问题的正文'
- en: '`wrapper.`findAll`(''button'')`: Verifies that exactly four buttons (answers)
    are rendered'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wrapper.findAll(''button'')`: 验证恰好渲染了四个按钮（答案）'
- en: '`wrapper.html()`: Used to inspect the HTML output of the component, ensuring
    each answer’s body is present'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wrapper.html()`: 用于检查组件的HTML输出，确保每个答案的正文都存在'
- en: 'The second test case verifies that when a user clicks an answer, the component’s
    `answered` method is correctly called with the appropriate `answerId`. This test
    simulates user interaction and checks the component’s logic for processing answers:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试用例验证当用户点击一个答案时，组件的 `answered` 方法是否被正确地调用，并带有适当的 `answerId`。这个测试模拟用户交互并检查组件处理答案的逻辑：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Key points in the code are as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的关键点如下：
- en: '`wrapper.findAll(''button'')[0].trigger(''click'')`: Simulates a user clicking
    the first answer button. The trigger function is used to dispatch DOM events,
    imitating user actions. If you check the questions data, you’ll notice that the
    ID of the first answer is always 1\. We’ll use the information to check the prop
    that is passed to the `updateProgress` method.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wrapper.findAll(''button'')[0].trigger(''click'')`: 模拟用户点击第一个答案按钮。触发函数用于派发DOM事件，模仿用户操作。如果你检查问题数据，你会注意到第一个答案的ID总是1。我们将使用这些信息来检查传递给
    `updateProgress` 方法的属性。'
- en: '`toHaveBeenCalledWith(1)`: Asserts that the `updateProgress` method within
    the quiz store was called with the correct argument, indicating the user’s selected
    answer ID (in this case, it’s 1). This ensures the component correctly communicates
    user selections to the store.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toHaveBeenCalledWith(1)`: 断言在测验存储中的 `updateProgress` 方法被正确的参数调用，即用户的所选答案ID（在这种情况下，它是1）。这确保了组件正确地将用户的选择传达给存储。'
- en: 'After running the unit tests for our quiz game components and the quiz store,
    you should see results similar to this in your terminal:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行我们的问答游戏组件和测验存储的单元测试后，你应该在你的终端看到类似以下的结果：
- en: '![Figure 7.4: Vitest output after testing component](img/B19760_07_04.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4：测试组件后的 Vitest 输出](img/B19760_07_04.jpg)'
- en: 'Figure 7.4: Vitest output after testing component'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：测试组件后的 Vitest 输出
- en: Now, let’s transition to writing E2E tests to ensure the game operates seamlessly
    from start to finish, as experienced by the end user.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们过渡到编写端到端测试，以确保游戏从开始到结束都能无缝运行，就像最终用户所体验的那样。
- en: Writing end-to-end tests for the quiz game
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测验游戏的端到端测试
- en: E2E testing is a technique used to test the entire application from start to
    finish, simulating real-user scenarios and interactions. It ensures that the application
    behaves as expected in a production-like environment, covering UIs, databases,
    APIs, and other services. E2E testing is crucial for verifying the integrated
    operation of all application components and detecting issues that unit or integration
    tests might miss.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试是一种从开始到结束测试整个应用程序的技术，模拟真实用户的场景和交互。它确保应用程序在类似生产环境中的行为符合预期，涵盖UI、数据库、API和其他服务。端到端测试对于验证所有应用程序组件的集成操作和检测单元或集成测试可能遗漏的问题至关重要。
- en: Setting up for E2E testing
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置端到端测试环境
- en: 'To conduct E2E tests in our project, we have to install `playwright-core`,
    a powerful tool for automating browser interactions, enabling tests that simulate
    real user actions. It also supports testing across multiple browsers. Run this
    command to install it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的项目中执行端到端测试，我们必须安装 `playwright-core`，这是一个强大的自动化浏览器交互的工具，它能够模拟真实用户行为的测试。它还支持跨多个浏览器进行测试。运行以下命令来安装它：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `@nuxt/test-utils` package includes utilities such as `setup` and `createPage`
    to facilitate E2E testing with Playwright or other test runners. Before beginning
    your E2E tests, initializing the test context with `setup` is necessary. This
    function prepares the Nuxt environment for testing by configuring the necessary
    `beforeAll`, `beforeEach`, `afterEach`, and `afterAll` hooks, ensuring your tests
    run within a correctly set up Nuxt context. `createPage`, on the other hand, allows
    you to create a configured Playwright browser instance and optionally navigate
    to a specific path on your running server. We’ll use it to create an instance
    from the quiz page to be able to simulate the user actions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`@nuxt/test-utils` 包包含如 `setup` 和 `createPage` 等实用工具，以方便使用 Playwright 或其他测试运行器进行端到端测试。在开始您的端到端测试之前，使用
    `setup` 初始化测试上下文是必要的。此函数通过配置必要的 `beforeAll`、`beforeEach`、`afterEach` 和 `afterAll`
    钩子来准备 Nuxt 测试环境，确保您的测试在正确设置的 Nuxt 上下文中运行。另一方面，`createPage` 允许您创建一个配置好的 Playwright
    浏览器实例，并可选地导航到运行服务器上的特定路径。我们将使用它从测验页面创建一个实例，以便能够模拟用户操作。'
- en: 'Let’s begin by creating our E2E test file, `app.spec.ts`, at the root of our
    project, then add the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在项目根目录下创建我们的端到端测试文件 `app.spec.ts` 开始，然后添加以下代码：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With the initial setup complete, we’re now ready to write specific test cases
    that will walk through the quiz game.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 初始设置完成后，我们现在可以编写具体的测试用例，这些测试用例将遍历测验游戏。
- en: Writing E2E tests
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写端到端测试
- en: 'In our E2E testing sequence, we begin by verifying the initial state of the
    quiz game to ensure it loads correctly for the user. This includes checking for
    the presence of a question headline and four corresponding answer buttons, which
    are fundamental to the quiz’s functionality. Here is the test case:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的端到端测试序列中，我们首先验证测验游戏的初始状态，以确保它正确加载供用户使用。这包括检查是否存在问题标题和四个相应的答案按钮，这些是测验功能的基本要素。以下是测试用例：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is a breakdown of the code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码的分解：
- en: '`createPage(''/'')`: This function initializes a new browser page instance
    and navigates to the root of our application, where the quiz is presumed to start.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createPage(''/'')`: 此函数初始化一个新的浏览器页面实例，并导航到我们应用程序的根目录，假设测验从这里开始。'
- en: '`page.locator(''h1'').count()`: This uses Playwright’s locator API to find
    all `<h1>` elements on the page, then counts them. We expect exactly one `<h1>`
    element, typically containing the quiz question.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page.locator(''h1'').count()`: 这使用 Playwright 的定位器API在页面上查找所有 `<h1>` 元素，然后计数它们。我们期望恰好有一个
    `<h1>` 元素，通常包含测验问题。'
- en: '`page.locator(''button'').count()`: Similarly, this line finds and counts all
    `<button>` elements, which should correspond to the quiz answer options. The expectation
    is to have exactly four buttons, each representing a potential answer.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page.locator(''button'').count()`: 同样，这一行查找并计数所有 `<button>` 元素，这些元素应该对应于测验答案选项。预期有恰好四个按钮，每个代表一个可能的答案。'
- en: 'Now let’s move on to the next test case. In this test case, we aim to simulate
    a user accurately answering all quiz questions to verify that the application
    correctly transitions to the result page and displays the final score. This process
    involves the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续到下一个测试用例。在这个测试用例中，我们的目标是模拟用户准确回答所有测验问题，以验证应用程序是否正确过渡到结果页面并显示最终分数。这个过程涉及以下步骤：
- en: Navigating to the quiz
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到测验
- en: 'Iterating through questions: For each question displayed, the test locates
    the correct answer based on our predefined questions data, then simulates a click
    on the corresponding answer button.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历问题：对于显示的每个问题，测试根据我们预定义的问题数据找到正确答案，然后模拟点击相应的答案按钮。
- en: 'Verifying the result page : After all questions have been answered correctly,
    the quiz should transition to a result page. This page displays a message indicating
    the quiz is finished and shows the user’s score.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证结果页面：在回答所有问题正确后，测验应过渡到结果页面。此页面显示一条消息，表明测验已完成，并显示用户的分数。
- en: 'Checking the score: The final part verifies that the score displayed matches
    the expected outcome of answering all questions correctly.'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查分数：最后一部分验证显示的分数与回答所有问题正确后的预期结果相匹配。
- en: 'Here is the test case:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是测试用例：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Some syntax highlights are as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些语法高亮示例：
- en: '`page.locator(button:has-text("${answerText}")).click()`: Locates the button
    with the text matching the correct answer and simulates a click event'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page.locator(button:has-text("${answerText}")).click()`：定位到文本匹配正确答案的按钮，并模拟点击事件'
- en: '`expect(finishedText).toBe(''Finished'')`: Checks whether the text Finished
    is displayed, indicating the quiz completion'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect(finishedText).toBe(''Finished'')`：检查是否显示了“Finished”文本，这表明测验已完成'
- en: '`expect(score).toContain(''5 / 5'')`: Validates that the final score, displayed
    within an `<h2>` element, correctly indicates all questions were answered correctly'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect(score).toContain(''5 / 5'')`：验证最终分数，显示在`<h2>`元素中，正确地表明所有问题都已正确回答'
- en: Note
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this test case, we’ve opted for a more general search approach by using element
    tags (`h1` and `h2`) directly due to our knowledge of the page structure—there’s
    only one `h1` element displaying the quiz question and a single `h2` element showing
    the result. However, for more complex UIs or when multiple elements of the same
    type exist on a page, it’s advisable to perform more specific searches, such as
    targeting elements with unique identifiers such as classes or IDs. This will enhance
    the test’s precision, ensuring we’re interacting with the correct elements even
    in densely structured pages.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试用例中，我们由于对页面结构的了解，选择了更通用的搜索方法，直接使用元素标签（`h1`和`h2`）。因为页面上只有一个`h1`元素显示测验问题，以及一个单独的`h2`元素显示结果。然而，对于更复杂的UI或页面上存在多个相同类型的元素时，建议进行更具体的搜索，例如针对具有唯一标识符（如类或ID）的元素进行搜索。这将提高测试的精确性，确保即使在密集结构的页面上，我们也在与正确的元素进行交互。
- en: 'Once we initiate the E2E test, be prepared for it to take a bit longer to complete
    compared to unit tests. This delay is because the test involves simulating a real
    browser environment, requiring the page to fully load before any interactions
    (such as clicking on answer buttons) can occur. Your output in the terminal should
    look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动端到端测试，请准备好它可能需要比单元测试更长的时间来完成。这种延迟是因为测试涉及模拟真实浏览器环境，需要在任何交互（如点击答案按钮）发生之前，页面必须完全加载。您的终端输出应如下所示：
- en: '![Figure 7.5: E2E test output](img/B19760_07_05.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：端到端测试输出](img/B19760_07_05.jpg)'
- en: 'Figure 7.5: E2E test output'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：端到端测试输出
- en: Note
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If this is the first time you’re using the Playwright library on your machine,
    you might encounter an error:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是您第一次在机器上使用Playwright库，您可能会遇到错误：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this case, just run the command shown in the terminal, then retry the test.
    Some developers have reported the need to run the following as well, in order
    to make Playwright work properly:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只需在终端中运行显示的命令，然后重试测试。一些开发者报告说，为了使Playwright正常工作，还需要运行以下命令：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With our E2E tests now complete, let’s shift our focus to exploring Vitest’s
    interactive UI and understanding test coverage. This will help us visualize our
    testing efforts and ensure complete coverage across our application.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了端到端测试，让我们将注意力转向探索Vitest的交互式UI和理解测试覆盖率。这将帮助我们可视化我们的测试努力，并确保我们的应用程序覆盖全面。
- en: Exploring Vitest UI and test coverage tools
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Vitest UI和测试覆盖率工具
- en: 'In our journey toward mastering testing with Vitest, two powerful tools stand
    out for their ability to enhance our development workflow: Vitest UI and test
    coverage tools. Vitest UI offers an interactive interface for running tests and
    visualizing results in real time, making it easier to manage and debug tests.
    Meanwhile, the test coverage tool provides insights into which parts of our code
    are thoroughly tested and which areas might need more attention.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们掌握Vitest测试的旅程中，有两个强大的工具因其增强我们开发工作流程的能力而脱颖而出：Vitest UI和测试覆盖率工具。Vitest UI提供了一个交互式界面，用于实时运行测试和可视化结果，这使得管理和调试测试更加容易。同时，测试覆盖率工具提供了关于我们代码哪些部分被彻底测试以及哪些区域可能需要更多关注的见解。
- en: 'To incorporate these tools into our project, we first need to install them:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这些工具集成到我们的项目中，我们首先需要安装它们：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With the packages installed, we’ll adjust our testing script to enable both
    the UI and coverage reporting:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 安装好这些包后，我们将调整测试脚本以启用UI和覆盖率报告：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After making this adjustment, stop any currently running test processes and
    restart them to activate the changes. Upon reinitiating the tests, you’ll observe
    that Vitest launches a UI project, indicated by a message in the terminal similar
    to this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行此调整后，停止任何当前正在运行的测试进程并重新启动它们以激活更改。重新启动测试后，您将观察到Vitest启动一个UI项目，终端中的消息类似于以下内容：
- en: '![Figure 7.6: Vitest UI dashboard URL](img/B19760_07_06.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：Vitest UI仪表板URL](img/B19760_07_06.jpg)'
- en: 'Figure 7.6: Vitest UI dashboard URL'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：Vitest UI仪表板URL
- en: By navigating to this URL in your web browser, you’re greeted by the Vitest
    UI dashboard. Let’s explore the UI and coverage reports to gain deeper insights
    into our testing landscape and identify opportunities for improvement.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在您的网络浏览器中访问此URL，您将看到Vitest UI仪表板。让我们探索UI和覆盖率报告，以深入了解我们的测试环境并识别改进的机会。
- en: The **Dashboard** interface summarizes key metrics, including the total number
    of tests run, the breakdown of passed and failed tests, the total number of test
    files involved, and the execution time for all tests. This overview provides a
    clear snapshot of the project’s testing health.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**仪表板**界面总结了关键指标，包括运行的总测试数、通过和失败的测试细分、涉及的总测试文件数以及所有测试的执行时间。这个概览提供了项目测试健康状况的清晰快照。'
- en: '![Figure 7.7: Vitest UI Dashboard](img/B19760_07_07.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7：Vitest UI仪表板](img/B19760_07_07.jpg)'
- en: 'Figure 7.7: Vitest UI Dashboard'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：Vitest UI仪表板
- en: As you explore the sidebar, you’ll find a list of your project’s test files.
    Clicking on one, for example, `app.spec.ts`, opens a detailed view of that specific
    test file. In this detailed view, you’ll see each test case listed along with
    its execution status—passed, failed, or skipped. Also, you’ll be able to re-run
    the test cases in this file. This allows for easy identification of which tests
    have succeeded and which may require further attention or debugging.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当您探索侧边栏时，您会看到一个包含您项目测试文件列表。点击其中一个，例如`app.spec.ts`，将打开该特定测试文件的详细视图。在这个详细视图中，您将看到每个测试用例及其执行状态——通过、失败或跳过。此外，您还可以重新运行此文件中的测试用例。这允许轻松识别哪些测试已成功，哪些可能需要进一步的关注或调试。
- en: '![Figure 7.8: Vitest test file](img/B19760_07_08.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8：Vitest测试文件](img/B19760_07_08.jpg)'
- en: 'Figure 7.8: Vitest test file'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：Vitest测试文件
- en: To gain insights into our code’s test coverage, a simple click on the coverage
    icon (located in the top-left corner, next to the play button) reveals a new dimension
    of our project’s health. The coverage overview presents a summary at the top of
    tested files, tested statements, branches, functions, and lines. Below the summary,
    a table lists each file alongside its coverage percentage
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解我们代码的测试覆盖率，只需点击左上角（在播放按钮旁边）的覆盖率图标，即可揭示我们项目健康状况的新维度。覆盖率概览在顶部呈现了已测试文件、测试语句、分支、函数和行的摘要。在摘要下方，一个表格列出了每个文件及其覆盖率百分比。
- en: Let’s search for the `stores` folder and click on it. It reveals that 88.46%
    of the code and 50% of functions have been tested.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们搜索`stores`文件夹并点击它。它显示88.46%的代码和50%的函数已经过测试。
- en: '![Figure 7.9: Vitest coverage UI](img/B19760_07_09.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9：Vitest覆盖率UI](img/B19760_07_09.jpg)'
- en: 'Figure 7.9: Vitest coverage UI'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：Vitest覆盖率UI
- en: A closer look at an individual file within this folder highlights untested code
    segments, such as the `restartQuiz` function—confirming areas where our test coverage
    could be improved.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看此文件夹中的单个文件，可以突出显示未测试的代码段，例如`restartQuiz`函数——确认了我们测试覆盖率可以改进的区域。
- en: '![Figure 7.10: Vitest file coverage](img/B19760_07_10.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10：Vitest文件覆盖率](img/B19760_07_10.jpg)'
- en: 'Figure 7.10: Vitest file coverage'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：Vitest 文件覆盖率
- en: This level of detail pinpoints exactly where we need to enhance our tests. Such
    an approach to identifying untested code is invaluable, guiding us to achieve
    more comprehensive test coverage and, by extension, a more reliable application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这么详细的级别精确地指出了我们需要增强测试的地方。这种识别未测试代码的方法非常有价值，引导我们实现更全面的测试覆盖率，并由此扩展到更可靠的应用程序。
- en: Our exploration of Vitest UI and test coverage concludes here, setting the stage
    for a summary of our journey through strong testing practices in enhancing the
    quiz game application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 Vitest UI 和测试覆盖率的探索到此结束，为总结我们在增强测验游戏应用程序的强大测试实践中的旅程奠定了基础。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: '[*Chapter 7*](B19760_07.xhtml#_idTextAnchor141) steered us through the crucial
    role of testing in the development of a quiz game application with Nuxt 3\. We
    began by laying the groundwork with unit testing, utilizing Vitest to test the
    logic of our Pinia store and components, ensuring their reliability. By simulating
    user interactions and asserting expected outcomes, we verified the functionality
    of critical parts of our application.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第7章*](B19760_07.xhtml#_idTextAnchor141) 引导我们了解在 Nuxt 3 开发测验游戏应用程序中测试的关键作用。我们首先通过单元测试打下基础，利用
    Vitest 测试 Pinia 商店和组件的逻辑，确保它们的可靠性。通过模拟用户交互和断言预期结果，我们验证了应用程序关键部分的功能。'
- en: Transitioning to E2E testing, we employed Playwright to mimic real-user scenarios,
    from navigating through quiz questions to completing the game. This phase reinforced
    our application’s user experience and functionality, highlighting the significance
    of testing in identifying and rectifying potential issues before they affect users.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 转向端到端（E2E）测试，我们使用了 Playwright 来模拟真实用户场景，从浏览测验问题到完成游戏。这一阶段加强了我们的应用程序的用户体验和功能，突出了测试在识别和纠正潜在问题以避免影响用户方面的重要性。
- en: The journey concluded with an exploration of Vitest UI and coverage tools, which
    illuminated untested code segments and provided a visual and interactive approach
    to managing our test suite. This not only enhanced our testing efficiency but
    also deepened our understanding of test coverage’s impact on application quality.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 旅程以探索 Vitest UI 和覆盖率工具结束，这些工具揭示了未测试的代码段，并提供了可视化和交互式的方法来管理我们的测试套件。这不仅提高了我们的测试效率，也加深了我们对于测试覆盖率对应用程序质量影响的了解。
- en: Looking ahead, [*Chapter 8*](B19760_08.xhtml#_idTextAnchor165) levels up our
    skills by creating a custom translation module in Nuxt 3\. This next chapter will
    guide us through the intricacies of i18n (Internationalization), from building
    a custom module to injecting it with the necessary components and functionalities
    to facilitate seamless language switching and localization.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，[*第8章*](B19760_08.xhtml#_idTextAnchor165) 通过在 Nuxt 3 中创建自定义翻译模块来提升我们的技能。下一章将引导我们了解
    i18n（国际化）的复杂性，从构建自定义模块到注入必要的组件和功能以实现无缝语言切换和本地化。
- en: Practice questions
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践问题
- en: What is the purpose of unit testing in a Vue.js application?
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试在 Vue.js 应用程序中的目的是什么？
- en: Describe the process of setting up Vitest in a Nuxt 3 project.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述在 Nuxt 3 项目中设置 Vitest 的过程。
- en: Explain how to use the `describe` and `it` blocks to structure your tests in
    Vitest.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释如何在 Vitest 中使用 `describe` 和 `it` 块来构建你的测试。
- en: What role does `expect` play in a test case?
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试用例中，`expect` 扮演什么角色？
- en: How can you mock a user interaction, such as clicking a button, in a unit test?
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何在单元测试中模拟用户交互，例如点击按钮？
- en: How do you test a Vue component that interacts with a Pinia store?
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何测试与 Pinia 商店交互的 Vue 组件？
- en: How can you simulate browser interactions in an E2E test?
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何在端到端测试中模拟浏览器交互？
- en: What is the purpose of the `createPage` function in Nuxt’s test utils?
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nuxt 的测试工具中的 `createPage` 函数的目的是什么？
- en: How can Vitest’s UI and coverage tools help improve the quality of your tests?
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vitest 的 UI 和覆盖率工具如何帮助提高测试质量？
- en: Further reading
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Vitest official website: [https://vitest.dev/](https://vitest.dev/)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vitest 官方网站：[https://vitest.dev/](https://vitest.dev/)
- en: 'Why Vitest: [https://vitest.dev/guide/why.html#why-vitest](https://vitest.dev/guide/why.html#why-vitest)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择 Vitest：[https://vitest.dev/guide/why.html#why-vitest](https://vitest.dev/guide/why.html#why-vitest)
- en: 'Vue testing: [https://vuejs.org/guide/scaling-up/testing](https://vuejs.org/guide/scaling-up/testing)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue 测试：[https://vuejs.org/guide/scaling-up/testing](https://vuejs.org/guide/scaling-up/testing)
- en: 'Pinia testing: [https://pinia.vuejs.org/cookbook/testing.html](https://pinia.vuejs.org/cookbook/testing.html)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pinia 测试：[https://pinia.vuejs.org/cookbook/testing.html](https://pinia.vuejs.org/cookbook/testing.html)
- en: 'Nuxt testing: [https://nuxt.com/docs/getting-started/testing](https://nuxt.com/docs/getting-started/testing)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Nuxt 测试: [https://nuxt.com/docs/getting-started/testing](https://nuxt.com/docs/getting-started/testing)'
- en: 'Vitest UI: [https://vitest.dev/guide/ui](https://vitest.dev/guide/ui)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Vitest UI: [https://vitest.dev/guide/ui](https://vitest.dev/guide/ui)'
- en: 'Vitest coverage: [https://vitest.dev/guide/coverage](https://vitest.dev/guide/coverage)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Vitest 覆盖率: [https://vitest.dev/guide/coverage](https://vitest.dev/guide/coverage)'
