- en: Chapter 5. Component-Based Routing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 组件式路由
- en: 'Routing is an integral part of today''s frontend applications. In general,
    a router serves two main purposes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是当今前端应用的一个核心部分。一般来说，路由器有两个主要用途：
- en: Making your application navigable so that users can use their browser's back
    button and store and share links within the application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您的应用可导航，以便用户可以使用浏览器的后退按钮，并在应用内存储和分享链接
- en: Offload parts of the application composition so that the router takes responsibility
    to compose your application, based on routes and route parameters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用组合的部分卸载，以便路由器根据路由和路由参数负责组合您的应用
- en: The router that comes with Angular supports many different use-cases, and it
    comes with an easy-to-use API. This supports child routers that are similar to
    the Angular UI-Router nested states, Ember.js nested routes, or child routers
    in the Durandal framework. Tied to the component tree, this also makes use of
    its own tree structure to store states and to resolve requested URLs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随Angular一起提供的路由器支持许多不同的用例，并附带一个易于使用的API。这支持类似于Angular UI-Router嵌套状态、Ember.js嵌套路由或Durandal框架中的子路由的子路由。与组件树绑定，这也利用其自己的树结构来存储状态和解析请求的URL。
- en: In this chapter, we refactor our code to use the component-based router of Angular.
    We will look into the core elements of the router and how to use them to enable
    routing in our application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重构我们的代码以使用Angular的基于组件的路由器。我们将探讨路由器的核心元素以及如何使用它们在我们的应用中启用路由。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to the Angular router
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular路由简介
- en: An overview of the refactoring to enable the router in our application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对启用我们应用中路由的代码重构的概述
- en: Composition by template, composition by routing, and how to mix them
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模板组合、通过路由组合，以及如何混合它们
- en: Using the `Routes` decorator to configure routes and child routes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Routes`装饰器来配置路由和子路由
- en: Using the `OnActivate` router lifecycle hook to obtain route parameters
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`OnActivate`路由生命周期钩子来获取路由参数
- en: Using the `RouterOutlet` directive to create insertion points that are controlled
    by the router
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RouterOutlet`指令来创建由路由器控制的插入点
- en: Using the `RouterLink` directive and the router DSL to create navigation links
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RouterLink`指令和路由DSL创建导航链接
- en: Querying for the `RouterLink` directives using the `@ChildView` decorator in
    order to obtain the link's active state
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@ChildView`装饰器查询`RouterLink`指令以获取链接的激活状态
- en: An introduction to the Angular router
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular路由简介
- en: The router in Angular is closely coupled to our component tree. The design of
    the Angular router is built on the assumption that a component tree is directly
    related to our URL structure. This is certainly true for most of the cases. If
    we look at a component **B**, which is nested within a component **A**, the URL
    to represent our location would very likely be `/a/b`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的路由器与我们的组件树紧密耦合。Angular路由器的设计基于这样的假设：组件树直接与我们的URL结构相关。这在大多数情况下都是正确的。如果我们看一个嵌套在组件**A**中的组件**B**，表示我们位置的URL很可能就是`/a/b`。
- en: In order to specify the location in our template where we'd like to enable the
    router to instantiate components, we can use so-called outlets. Simply by including
    a `<router-outlet>` element, we can make use of the `RouterOutlet` directive to
    mark the router insertion point in our template.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定模板中我们希望启用路由器实例化组件的位置，我们可以使用所谓的出口。只需包含一个`<router-outlet>`元素，我们就可以利用`RouterOutlet`指令在我们的模板中标记路由插入点。
- en: Based on some route configuration that we can place on our component, the router
    then decides which components need to be instantiated and placed into the router
    outlets. Routes can also be parameterized, and we can access these parameters
    within the instantiated components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们可以放置在我们组件上的某些路由配置，路由器随后决定哪些组件需要实例化并放置到路由出口中。路由也可以参数化，我们可以在实例化的组件中访问这些参数。
- en: Based on our component tree and the route configurations on components in this
    tree, we can build a hierarchical routing and decouple child routes from their
    parent routes. Such nested routes make it possible to specify route configuration
    on multiple layers in our component tree and reuse parent components for multiple
    child routes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们的组件树以及该树中组件的路由配置，我们可以构建一个分层路由，并将子路由与其父路由解耦。这种嵌套路由使得在组件树的多个层级上指定路由配置，并重用父组件为多个子路由成为可能。
- en: '![An introduction to the Angular router](img/image00319.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Angular路由简介](img/image00319.jpeg)'
- en: Router hierarchy established through a component tree
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组件树建立的路由层次结构
- en: 'Let''s look at the elements of the router again in more detail:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看路由器的元素：
- en: '**Route configuration**: The route configuration is placed at component level,
    and it contains the different routes possible for this level in the component
    tree. By placing multiple route configurations on different components in the
    component tree, we can build decoupled nested routes easily.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由配置**：路由配置放置在组件级别，它包含组件树中此级别的不同路由。通过在组件树的不同组件上放置多个路由配置，我们可以轻松构建解耦的嵌套路由。'
- en: '**Router outlets**: Outlets are the locations in components that will be managed
    by the router. Instantiated components that are based on the route configuration
    will be placed into these outlets.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由出口**：出口是组件中将被路由器管理的位置。基于路由配置的实例化组件将被放置在这些出口中。'
- en: '**Router link**: These are links built with a DSL style notation that enable
    the developer to build complex links through the routing tree.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由链接**：这些是以DSL风格符号构建的链接，使开发者能够通过路由树构建复杂的链接。'
- en: Composition by routing
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过路由进行组合
- en: So far, we achieved composition by including subcomponents in component templates.
    However, we'd now like to give the control to the router to decide which component
    should be included and where.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过在组件模板中包含子组件来实现组合。然而，我们现在希望将控制权交给路由器，以决定哪个组件应该被包含以及在哪里。
- en: 'The following illustration provides an overview of the component architecture
    of our application, which we''re going to enable to route:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图概述了我们应用程序的组件架构，我们将启用它来进行路由：
- en: '![Composition by routing](img/image00320.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![通过路由的组成](img/image00320.jpeg)'
- en: A component tree displaying routing components (solid line) and router outlets
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 显示路由组件（实线）和路由出口的组件树
- en: The `Project` component is now not directly included with our `App` component.
    Instead, we use a router outlet in the template of our `App` component. This way,
    we can give control to the router, and let it decide which component should be
    placed into the outlet. The `App` component's router configuration will contain
    all top-level routes. In the current application, we only have the `Project` component
    as a secondary-level component, but this will change in further chapters.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`Project`组件不再直接与我们的`App`组件一起包含。相反，我们在`App`组件的模板中使用路由出口。这样，我们可以将控制权交给路由器，让它决定哪个组件应该放入出口。`App`组件的路由配置将包含所有顶级路由。在当前应用程序中，我们只有`Project`组件作为二级组件，但在后续章节中这将会改变。
- en: The `Project` component contains child route configuration to navigate to the
    tasks and comments view. However, it does not directly contain a router outlet.
    We use the `Tabs` component as a navigation element for any sub views. As a result,
    we'll place the router outlet into the `Tabs` component and include the component
    directly in the template of the `Project` component.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Project`组件包含子路由配置，用于导航到任务和评论视图。然而，它并不直接包含路由出口。我们使用`Tabs`组件作为任何子视图的导航元素。因此，我们将路由出口放入`Tabs`组件，并在`Project`组件的模板中直接包含该组件。'
- en: Router versus template composition
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由与模板组合的比较
- en: The composition that we dealt with so far was purely based on instantiation
    via template inclusion. We used input and output properties to decouple and encapsulate
    components, and followed nice reusable patterns.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止处理的组合完全是基于模板包含的实例化。我们使用输入和输出属性来解耦和封装组件，并遵循了良好的可重用模式。
- en: With the router, we face a problem that has not yet been solved by Angular and
    requires that we find our own solution. As we give control to the router to instantiate
    and insert components into our component tree, we can't control any bindings on
    our instantiated component. While we previously relied on the clean decoupling
    of components using input and output properties, we can no longer do this. The
    only thing that a router provides us are route parameters that may have been set
    along the activated route.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用路由器，我们面临一个Angular尚未解决的问题，需要我们找到自己的解决方案。当我们把控制权交给路由器来实例化和将组件插入到我们的组件树中时，我们就无法控制实例化组件上的任何绑定。虽然我们之前依赖于使用输入和输出属性进行组件的清洁解耦，但我们不能再这样做。路由器为我们提供的唯一东西是可能设置在激活路由上的路由参数。
- en: 'This puts us in quite a nasty situation. Basically, we need to decide between
    two designs when writing components, which are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们陷入了一个相当糟糕的情况。基本上，在编写组件时，我们需要在两种设计之间做出选择，如下所示：
- en: We use a given component purely in template composition and, therefore, rely
    on input and output properties as the glue between the parent component
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们纯粹在模板组合中使用给定的组件，因此依赖于输入和输出属性作为父组件之间的粘合剂
- en: We use a component instantiated by the router and rely on input-provided view
    route parameters and don't require communication with the parent component
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用由路由器实例化的组件，并依赖于由输入提供的视图路由参数，并且不需要与父组件通信
- en: Well, both of the preceding design approaches aren't very nice, are they? In
    an ideal world, we would not need to apply any changes to a component when we
    enable it for routing. The router should just enable the component for routing,
    but it should not require any changes on the component itself. Unfortunately,
    there's no agreement for a solution to this problem at the time of writing this
    book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，上述两种设计方法都不是很好，对吧？在一个理想的世界里，当我们为路由启用组件时，我们不需要对组件本身进行任何更改。路由器应该只是使组件能够进行路由，但不应要求对组件本身进行任何更改。不幸的是，在撰写本书时，对于解决这个问题还没有达成共识。
- en: As we don't want to lose any composition capabilities that we gain from relying
    on inputs and outputs in our `TaskList` and `Comments` components, we need to
    a find a better solution to enable routing in our application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望失去从`TaskList`和`Comments`组件依赖输入和输出所获得的所有组合能力，我们需要找到一个更好的解决方案来在我们的应用程序中启用路由。
- en: The following solution allows us to leave the `TaskList` and `Comments` components
    untouched while they can still rely on input and output properties. Instead of
    exposing them directly to the router, we will build wrapper components that we
    address from our routes. These wrappers follow some mechanics to bridge this gap
    between the router and our components.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下解决方案使我们能够在不修改`TaskList`和`Comments`组件的情况下使用它们，同时它们仍然可以依赖于输入和输出属性。我们不会直接将它们暴露给路由器，而是将构建包装组件，并从我们的路由中引用这些包装组件。这些包装组件遵循一些机制来弥合路由器和我们的组件之间的差距。
- en: The `wrapper` component deals with any route parameters or route data that might
    have been set in the activated route.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wrapper`组件处理任何可能已在激活的路由中设置的任何路由参数或路由数据。'
- en: Their template should only include the component that is wrapped and its input
    and output bindings.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的模板应仅包含包装的组件及其输入和输出绑定。
- en: They handle the required data and functionality to provide the input and output
    bindings of the concerned component
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们处理所需的数据和功能，以提供相关组件的输入和输出绑定
- en: They may use parent component injection to establish communication with the
    parent and propagate any action that is required by emitted events. Parent component
    injection should be used with caution as it somewhat breaks our decoupling of
    components.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能使用父组件注入来与父组件建立通信并传播由发出的事件所要求的任何动作。父组件注入应谨慎使用，因为它在一定程度上破坏了组件的解耦。
- en: Understanding the route tree
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解路由树
- en: Angular uses tree data structures to represent the router state. You can imagine
    that every navigation in your application activates a branch in this tree. Let's
    look at the following example.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 使用树形数据结构来表示路由状态。你可以想象，在你的应用程序中，每一次导航都会激活这棵树的一个分支。让我们来看以下示例。
- en: 'We have an application that consists of four possible routes:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个由四个可能的路由组成的应用程序：
- en: '`/`: This is the root route of the application, which is handled in a component
    called **A**.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`：这是应用程序的根路由，由一个名为**A**的组件处理。'
- en: '`/b/:id`: This is the route where we can access a `b` detail view, which is
    handled in a component called **B**. In the URL, we can pass an `id` parameter
    (that is, `/b/100`).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/b/:id`：这是我们可以访问`b`详细视图的路由，由一个名为**B**的组件处理。在URL中，我们可以传递一个`id`参数（即`/b/100`）。'
- en: '`/b/:id/c`: This is the route where the `b` detail view has another navigation
    possibility, which reveals more specific details that we call `c`. This is handled
    in a **C** component.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/b/:id/c`：这是`b`详细视图有另一个导航可能性的路由，揭示了更具体的细节，我们称之为`c`。这由一个名为**C**的组件处理。'
- en: '`/b/:id/d`: This is the route where we can also navigate to a `d` view in the
    `b` detail view. This is handled by a component, called **D**:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/b/:id/d`：这是我们可以导航到`b`详细视图中的`d`视图的路由。这由一个名为**D**的组件处理：'
- en: '![Understanding the route tree](img/image00321.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![理解路由树](img/image00321.jpeg)'
- en: A route tree consisting of an active branch of route segments for an activated
    route /b/100/d
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由激活的路由/b/100/d的路由段组成的路由树
- en: Let's assume that we activate a route in our example by navigating the URL,
    `/b/100/d`. In this case, we'd activate a route that reflects the state that is
    outlined in the preceding figure. Note that the route segment **B** actually consists
    of two URL segments. The reason for this is that we've specified that our route
    **B** actually consists of the `b` identifier and an `:id` route parameter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们通过导航URL `/b/100/d`激活我们的示例路由。在这种情况下，我们将激活一个反映前面图中所述状态的路由。请注意，路由段**B**实际上由两个URL段组成。这是因为我们指定了我们的路由**B**实际上由`b`标识符和`:id`路由参数组成。
- en: Using this tree data structure, we have a perfect abstraction to deal with navigation
    trees. We can compare trees, check whether certain segments exist in a tree, and
    extract parameters present on resolved route segments.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种树形数据结构，我们有一个完美的抽象来处理导航树。我们可以比较树，检查某些段是否存在于树中，并从解析的路由段中提取参数。
- en: 'To demonstrate the use of routing trees, let''s take a look at the `OnActivate`
    router lifecycle hook that we can implement on our navigable components:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示路由树的使用，让我们看看我们可以在我们的可导航组件上实现的`OnActivate`路由生命周期钩子：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When we implement this lifecycle hook on our components, we can run some code
    after the route was activated. The `currentRouteSegment` argument will point to
    the `RouteSegment` instance that was activated on our component.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在组件上实现此生命周期钩子时，我们可以在路由激活后运行一些代码。`currentRouteSegment`参数将指向在组件上激活的`RouteSegment`实例。
- en: 'Let''s take a look at our example again and assume that we want to access the
    `:id` parameter in the `routerOnActivate` hook of our **B** component:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看我们的示例，并假设我们想要访问我们**B**组件的`routerOnActivate`钩子中的`:id`参数：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the `getParam` function on the `RouteSegment` instance, we obtain any
    parameters that are resolved on the given segment. In our example case, this would
    return a `100` string.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RouteSegment`实例上使用`getParam`函数，我们可以获取在给定段上解析的任何参数。在我们的示例中，这将返回一个`100`字符串。
- en: 'Let''s take a look at a more complex example. What if we want to access the
    `:id` parameter from the **D** component on the `d` detail view? In the `OnActivate`
    lifecycle hook, we''ll receive only the route segment that is relevant to the
    **D** component. This only consists of the `d` URL segment and this does not include
    the `:id` parameter from the parent route. We can now make use of the `RouteTree`
    instance to find the parent route segment and obtain the parameter from there:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更复杂的例子。如果我们想从`d`详细视图的**D**组件中访问`:id`参数怎么办？在`OnActivate`生命周期钩子中，我们只会收到与**D**组件相关的路由段。这仅包括`d`
    URL段，不包括父路由中的`:id`参数。我们现在可以利用`RouteTree`实例来找到父路由段并从那里获取参数：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the current `RouteTree` instance, we can obtain the parent of the current
    route segment. As a result, we'll receive the parent route segment (`RouteSegment`
    **B** in the preceding figure) from where we can obtain the `:id` parameter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用当前的`RouteTree`实例，我们可以获取当前路由段的上层路由。结果，我们将收到前面图中所示的父路由段（`RouteSegment` **B**），从那里我们可以获取`:id`参数。
- en: As you can see, the router API is quite flexible, and it allows us to inspect
    route activity on a very fine granularity. The tree structures that are used in
    the router make it possible to compare complex router states in our application
    without bothering about the underlying complexity.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，路由API非常灵活，它允许我们以非常细粒度地检查路由活动。路由器中使用的树结构使得我们能够在应用中比较复杂的路由状态，而无需担心底层复杂性。
- en: Back to the routes
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回路由
- en: 'All right, now it''s time to implement routing for our application! In the
    following topics, we''ll create the following routes for our application:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是我们为我们的应用程序实现路由的时候了！在以下主题中，我们将为我们的应用程序创建以下路由：
- en: '| Route path | Description |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 路由路径 | 描述 |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `/projects/:projectId` | This route will activate the `Project` component
    in the outlet of our main application component. This consists of the `projects`
    URL segment as well as the `:projectId` URL segment to specify the project ID.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `/projects/:projectId` | 此路由将在我们的主应用程序组件的出口处激活`Project`组件。这包括`projects` URL段以及`:projectId`
    URL段来指定项目ID。|'
- en: '| `/projects/:projectId/tasks` | This route will activate the `TaskList` component.
    We will create a `ProjectTaskList` wrapper component in order to decouple our
    `TaskList` component from routing. We''ll apply the procedure described in the
    previous section, *Router versus template composition*. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `/projects/:projectId/tasks` | 此路由将激活`TaskList`组件。我们将创建一个`ProjectTaskList`包装组件，以便将我们的`TaskList`组件与路由解耦。我们将应用前一小节中描述的程序，即*路由与模板组合*。|'
- en: '| `/projects/:projectId/comments` | This route will activate the `Comments`
    component. We''ll create a `ProjectComments` wrapper component in order to decouple
    our `Comments` component from routing. We''ll apply the procedure described in
    the previous section, *Router versus template composition*. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `/projects/:projectId/comments` | 此路由将激活`Comments`组件。我们将创建一个`ProjectComments`包装组件，以便将我们的`Comments`组件与路由解耦。我们将应用前一小节中描述的程序，即*路由与模板组合*。|'
- en: 'In order to use the router of Angular, the first thing that we need to do is
    to add the route provider to our application. We''ll do this on bootstrap in order
    to make sure the router providers are only loaded once. Let''s open our `boostrap.js`
    file and add the necessary dependencies:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Angular的路由器，我们首先需要做的事情是将路由提供者添加到我们的应用程序中。我们将在引导时这样做，以确保路由提供者只加载一次。让我们打开我们的`boostrap.js`文件并添加必要的依赖项：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From the router module, we import the `ROUTER_PROVIDERS` constant that contains
    a list of modules that are required to be exposed as providers when using the
    router. We also import the `LocationStrategy` and `HashLocationStrategy` type
    from the common module that need to be provided manually.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从路由模块中，我们导入包含需要作为提供者公开的模块列表的`ROUTER_PROVIDERS`常量。我们还从通用模块中导入需要手动提供的`LocationStrategy`和`HashLocationStrategy`类型。
- en: Using the `provide` function, we provide the `HashLocationStrategy` class as
    a substitution for the `LocationStrategy` abstract class. This way, the router
    will know which strategy to use when resolving URLs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`provide`函数，我们将`HashLocationStrategy`类作为对`LocationStrategy`抽象类的替代。这样，路由器将知道在解析URL时使用哪种策略。
- en: 'The following two strategies exist at the moment:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 目前存在以下两种策略：
- en: '**HashLocationStrategy**: This can be used when the router should use hash
    URLs, such as `localhost:8080#/child/something`. This location strategy makes
    sense if you''re working in an environment where the HTML5 push state can''t be
    used due to browser or server constraints. The whole navigation state will be
    managed in the fragment identifier of the URL.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HashLocationStrategy**：当路由应使用hash URL时，例如`localhost:8080#/child/something`，可以使用此策略。如果由于浏览器或服务器限制而无法使用HTML5的push
    state，则此位置策略是有意义的。整个导航状态将管理在URL的片段标识符中。'
- en: '**PathLocationStrategy**: This strategy can be used if you''d like to use the
    HTML5 push state to handle application URLs. This means that your application
    navigation becomes the actual path of the URL. Using the preceding example of
    a hash-based URL, this strategy would enable the direct use of `localhost:8080/child/something`.
    As the initial requests will hit the server if the state is encoded in the path
    of a URL, you''ll need to enable the correct routing on the server to make this
    work properly.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PathLocationStrategy**：如果您想使用HTML5的push state来处理应用程序URL，则可以使用此策略。这意味着您的应用程序导航成为URL的实际路径。使用前面基于hash的URL的示例，此策略将允许直接使用`localhost:8080/child/something`。由于初始请求将击中服务器，如果状态编码在URL的路径中，您需要启用服务器上的正确路由以使其正常工作。'
- en: 'After enabling the router for our application, we will need to make our root
    component routable. We can do this by including a route configuration on our `App`
    component. Let''s look at the necessary code to do this. We edit the `app.js`
    file in our `lib` folder:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的应用程序启用路由后，我们需要使我们的根组件可路由。我们可以通过在`App`组件上包含路由配置来实现这一点。让我们看看完成此操作所需的代码。我们编辑`lib`文件夹中的`app.js`文件：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we imported the `Routes` decorator as well as the `Route`
    type from the router module.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从路由模块中导入了`Routes`装饰器以及`Route`类型。
- en: In order to configure routes on our component, we can use the `@Routes` decorator
    by passing an array of `Route` objects that describe the possible child routes
    on this component.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的组件上配置路由，我们可以通过传递一个描述此组件上可能存在的子路由的`Route`对象数组来使用`@Routes`装饰器。
- en: 'Let''s look at the available options that we can pass to the `Route` constructor:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以传递给`Route`构造函数的可用选项：
- en: '| Route property | Description |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 路由属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `path` | This property is required. Using the path, we can describe the navigation
    URL in the browser using the route matcher DSL. This can contain route parameter
    placeholders.Some examples are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '| `path` | 这个属性是必需的。使用路径，我们可以使用路由匹配 DSL 描述浏览器中的导航 URL。这可以包含路由参数占位符。以下是一些示例：'
- en: 'The following route gets activated if the user navigates to `/home` in the
    browser:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户在浏览器中导航到 `/home` 时，以下路由会被激活：
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following route gets activated when the user navigates to a `/child/something`
    URL where something will be available as route parameter with the name, `id`:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户导航到 `/child/something` URL 时，以下路由会被激活，其中 `something` 将作为名为 `id` 的路由参数可用：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `component` | This property is required, and it defines which component should
    be instantiated by the router. As already explained in the previous section, the
    router does not allow us here to specify any bindings to the instantiated component.
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `component` | 这个属性是必需的，它定义了路由器应该实例化哪个组件。正如在上一节中解释的，路由器不允许我们在这里指定任何绑定到实例化组件的绑定。|'
- en: The route configuration on our `App` component covers the `Project` component
    being instantiated on the `projects/:projectId` route path. This means that we
    use a `projectId` parameter on the child route, which will be available to the
    `Project` component.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `App` 组件上的路由配置涵盖了在 `projects/:projectId` 路径上实例化的 `Project` 组件。这意味着我们在子路由上使用
    `projectId` 参数，它将可用于 `Project` 组件。
- en: We also need to modify our `App` component template and remove the direct inclusion
    of the `Project` component there. We now give control to the router to decide
    which component to display. For this, we need to make use of the `RouterOutlet`
    directive to provide a slot in our template where the router will instantiate
    components.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改我们的 `App` 组件模板，并从中移除直接包含的 `Project` 组件。我们现在将控制权交给路由器来决定显示哪个组件。为此，我们需要使用
    `RouterOutlet` 指令在我们的模板中提供一个插槽，路由器将在其中实例化组件。
- en: 'The `RouterOutlet` directive is part of the `ROUTER_DIRECTIVES` constant that
    is exported by the router module. Let''s import and add the constant to the directives
    list on our component:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterOutlet` 指令是路由模块导出的 `ROUTER_DIRECTIVES` 常量的一部分。让我们将其导入并添加到我们组件的指令列表中：'
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we can use the `RouterOutlet` directive in our template to indicate the
    insertion position of instantiated components by the router. Let''s open our `App`
    component template file, `app.html`, and make the necessary modifications:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在模板中使用 `RouterOutlet` 指令来指示路由器实例化组件的插入位置。让我们打开我们的 `App` 组件模板文件，`app.html`，并进行必要的修改：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The next step is to refactor our `Project` component so that it can be used
    in routing. As we already outlined in the previous section, the router comes with
    certain constraints when it comes to component design. For the `Project` component,
    we decide to redesign it in a way so that we can only use it with routing. This
    isn't a bad thing here because we can exclude the possibility that it will be
    reused somewhere else in our application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将我们的 `Project` 组件重构，使其可用于路由。正如我们在上一节中概述的，路由在组件设计方面有一些限制。对于 `Project` 组件，我们决定以这种方式重新设计它，以便我们只能用它进行路由。在这里这并不是坏事，因为我们排除了它在我们的应用程序的其他地方被重用的可能性。
- en: 'The redesign of the `Project` component includes the following steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Project` 组件的重设计包括以下步骤：'
- en: Getting rid of all input and output properties of the component.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除组件的所有输入和输出属性。
- en: Using the `OnActivate` router lifecycle hook to obtain the `projectId` parameter
    from the activated route segment of the `App` component.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `OnActivate` 路由生命周期钩子从 `App` 组件激活的路由段中获取 `projectId` 参数。
- en: Obtaining the project data directly from the data store using the `projectId`
    parameter.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `projectId` 参数直接从数据存储中获取项目数据。
- en: Handling updates on the project data directly on the component instead of delegating
    to the `App` component.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接在组件上处理项目数据的更新，而不是委托给 `App` 组件。
- en: 'Let''s modify the `Component` class located in `lib/project/project.js` to
    implement the preceding design changes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改位于 `lib/project/project.js` 中的 `Component` 类以实现前面的设计更改：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Besides implementing these changes that are already described in the redesigning
    steps, we also made use of a new `LiveDocument` utility class that we imported
    from the `data-access` folder. This helps us to keep our programming reactive
    when we're concerned about changes on a single data entity. Using the `LiveDocument`
    class, we can query the database for a single entity, while the change property
    of the `LiveDocument` instance is an observable that keeps us notified about changes
    on the entity. A `LiveDocument` instance also exposes the data of the entity into
    a `data` property, which can be accessed directly. If we'd like to make an update
    on the entity, we can add, modify, or remove properties on the data object and
    then store the changes by calling `persist()`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实现已经描述在重新设计步骤中的这些更改之外，我们还利用了从`data-access`文件夹导入的新`LiveDocument`实用类。这有助于我们在关注单个数据实体的变化时保持编程的响应性。使用`LiveDocument`类，我们可以查询数据库中的单个实体，而`LiveDocument`实例的变化属性是一个可观察对象，它会通知我们实体的变化。`LiveDocument`实例还通过`data`属性暴露实体的数据，可以直接访问。如果我们想对实体进行更新，我们可以在数据对象上添加、修改或删除属性，然后通过调用`persist()`来存储更改。
- en: As our `Project` component is now activated by the router in the `App` component,
    we can make use of the `OnActivate` router lifecycle hook by implementing a method,
    named `routerOnActivate`. We use the `getParam` function of the current route
    segment to obtain the `:projectId` parameter of the route.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`Project`组件现在由`App`组件中的路由激活，我们可以通过实现一个名为`routerOnActivate`的方法来使用`OnActivate`路由生命周期钩子。我们使用当前路由段上的`getParam`函数来获取路由的`:projectId`参数。
- en: In the `subscribe` function on the change observable of our `LiveDocument` instance,
    we expose the project data directly on the `Project` component. This simplifies
    later use in the view.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`LiveDocument`实例的变化可观察对象上的`subscribe`函数中，我们直接在`Project`组件上暴露项目数据。这简化了后续在视图中的使用。
- en: In the `OnDestroy` lifecycle hook, we make sure that we unsubscribe from the
    document change observable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnDestroy`生命周期钩子中，我们确保我们取消订阅文档变化可观察对象。
- en: Now, we can rely on the `projectId` route parameter to be passed into our component,
    which makes the `Project` component depend on the router. We got rid of all input
    properties, and then we set the necessary data by querying our data store using
    the project ID.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以依赖`projectId`路由参数传递到我们的组件中，这使得`Project`组件依赖于路由。我们移除了所有输入属性，然后通过查询我们的数据存储使用项目ID来设置必要的数据。
- en: Now, it's time to build the wrapper components that we talked about in order
    to route to our `TaskList` and `Comments` components.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候构建我们之前提到的包装组件，以便路由到我们的`TaskList`和`Comments`组件。
- en: 'Let''s create a new component called `ProjectTaskList`, which will serve as
    a wrapper to enable the `TaskList` component in routing. We will create a `project-task-list.js`
    file in the `lib/project/project-task-list` path, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的组件，称为`ProjectTaskList`，它将作为包装器来启用路由中的`TaskList`组件。我们将在`lib/project/project-task-list`路径下创建一个`project-task-list.js`文件，如下所示：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s also take a look at the template in the `project-task-list.html` file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也看看`project-task-list.html`文件中的模板：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We inject the `Project` parent component into our wrapper component. As we can't
    rely on output properties any more to emit events, this is the only way to communicate
    with the parent `Project` component. We're dealing with a circular reference here
    (`Project` depends on `ProjectTaskList`, and `ProjectTaskList` depends on `Project`),
    hence we need to use a `forwardRef` helper function to prevent the `Project` type
    evaluating to `undefined`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Project`父组件注入到我们的包装组件中。由于我们不能再依赖输出属性来发出事件，这是与父`Project`组件通信的唯一方式。我们在这里处理一个循环引用（`Project`依赖于`ProjectTaskList`，而`ProjectTaskList`依赖于`Project`），因此我们需要使用`forwardRef`辅助函数来防止`Project`类型评估为`undefined`。
- en: If we receive a `tasksUpdated` event in the template, we will call the `updateTasks`
    method on our wrapper component. The wrapper then simply delegates the call to
    the project component.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在模板中接收到`tasksUpdated`事件，我们将在我们的包装组件上调用`updateTasks`方法。然后包装组件简单地委托调用到项目组件。
- en: Similarly, we use the project data to obtain the list of tasks and create a
    binding to the `tasks` input property of the `TaskList` component.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们使用项目数据来获取任务列表并创建与`TaskList`组件的`tasks`输入属性的绑定。
- en: Using this wrapper approach for routing, we're able to leave our components
    unmodified when enabling them for routing. This is much better than the option
    to make our task list only available for the router. We would lose the freedom
    to use a task list outside of the context of a project, and then use it with pure
    template composition.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种包装方法进行路由，我们能够在启用路由时不对组件进行修改。这比仅使任务列表对路由可用要好得多。我们将会失去在项目上下文之外使用任务列表的自由，然后使用纯模板组合。
- en: For the `Comments` component, we perform the exact same task, and create a wrapper
    on the `lib/project/project-comments` path. Besides dealing with comments instead
    of tasks, the code looks exactly the same as with the `ProjectTaskList` wrapper
    component.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Comments`组件，我们执行完全相同的任务，并在`lib/project/project-comments`路径上创建一个包装器。除了处理评论而不是任务之外，代码与`ProjectTaskList`包装组件完全相同。
- en: 'After creating the two wrapper components, we can now create the router configuration
    on our `Project` component. Let''s modify the `project/project.js` file to enable
    routing:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了两个包装组件之后，我们现在可以在我们的`Project`组件上创建路由配置。让我们修改`project/project.js`文件以启用路由：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To enable the task list and make comments navigable using the router, we simply
    create a router configuration that instantiates our wrapper components. We also
    specify that the tasks route should be the default route if no child route was
    selected.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用任务列表并使用路由使评论可导航，我们只需创建一个路由配置来实例化我们的包装组件。我们还指定如果没有选择子路由，则任务路由应该是默认路由。
- en: Routable tabs
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可路由标签页
- en: Okay, if you've read through this chapter so far, you now may wonder where the
    router will instantiate the components of the child routes. We've not yet included
    a router outlet in the `Project` component template so that the router knows where
    to instantiate components.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，如果你已经阅读了这一章到目前为止的内容，你现在可能想知道路由将在哪里实例化子路由的组件。我们尚未在`Project`组件模板中包含路由出口，这样路由就知道在哪里实例化组件。
- en: 'We won''t include the outlet for the project router directly in the `Project`
    component. Instead, we will use our `Tabs` component to take over this job. Instead
    of using content insertion in our `Tabs` component like we did so far, we now
    use a router outlet to compose its content. This will make our `Tabs` component
    unusable for nonrouting cases, but we can establish a nice decoupling by only
    providing the router outlet. This way we can still reuse the `Tabs` component
    in other routing situations:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会直接在`Project`组件中包含项目路由的出口。相反，我们将使用我们的`Tabs`组件来接管这个任务。不同于我们迄今为止在`Tabs`组件中使用的内容插入，我们现在使用一个路由出口来组合其内容。这将使我们的`Tabs`组件在非路由情况下不可用，但我们可以通过仅提供路由出口来建立良好的解耦。这样我们仍然可以在其他路由场景中重用`Tabs`组件：
- en: '![Routable tabs](img/image00322.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![可路由标签页](img/image00322.jpeg)'
- en: The App component includes a router outlet directly; however, the Project component
    relies on the Tabs component to provide a router outlet.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: App组件直接包含一个路由出口；然而，Project组件依赖于Tabs组件来提供路由出口。
- en: 'On a higher level, we can describe the new design of our `Tabs` component,
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高层次上，我们可以描述我们的`Tabs`组件的新设计，如下所示：
- en: It renders all tab buttons, based on a list of router links and titles to provide
    a router navigation
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它根据路由链接和标题列表渲染所有标签按钮，以提供路由导航
- en: It provides a router outlet that will be used by the parent component to instantiate
    navigated components
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个路由出口，将被父组件用来实例化导航组件
- en: 'Let''s modify our `Tabs` component in `lib/ui/tabs/tabs.js` to implement these
    changes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的`Tabs`组件在`lib/ui/tabs/tabs.js`中的实现这些更改：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `ROUTER_DIRECTIVES` constant from the router module contains the `RouterOutlet`
    directive as well as the `RouterLink` directive. By importing the constant and
    providing it to the components directives list, we enable both router directives
    to be used in our template.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 路由模块中的`ROUTER_DIRECTIVES`常量包含`RouterOutlet`指令以及`RouterLink`指令。通过导入这个常量并将其提供给组件指令列表，我们使这两个路由指令可以在我们的模板中使用。
- en: The `RouterOutlet` directive is used inside the `Tabs` component template to
    indicate the instantiation point for the router.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Tabs`组件的模板中使用`RouterOutlet`指令来指示路由的实例化点。
- en: The `RouterLink` directive can be used to generate routing URLs from the template
    using the router link DSL. This allows you to generate navigation links in your
    application and it can be placed both on anchor tags as well as other elements
    where it will trigger navigation on click.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterLink`指令可以用来从模板生成路由URL，使用路由链接DSL。这允许你在应用程序中生成导航链接，它既可以放在锚标签上，也可以放在其他元素上，点击时将触发导航。'
- en: The `items` input is an array of link items that contain a title and a router
    link. On our parent project component, we already prepare these items in the constructor.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`items`输入是一个包含标题和路由链接的链接项数组。在我们的父项目组件中，我们已经在构造函数中准备好了这些项。'
- en: 'Let''s also take a quick look at the template of our component in the `tabs.html`
    file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下`tabs.html`文件中我们组件的模板：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we let the router deal with the active view using a router outlet, there's
    no need any more to use multiple tab components that are switched active. We will
    always have one active tab, and let the router handle the content.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们让路由器通过路由出口处理活动视图时，就不再需要使用多个可切换的活动标签组件了。我们始终只有一个活动标签，并让路由器处理内容。
- en: 'Let''s see how we can make use of the new `Tabs` component in our `Project`
    component to make the configured routes navigable. First, we need to add the following
    code to our `Project` component constructor to provide the necessary navigation
    items to our `Tabs` component:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在`Project`组件中使用新的`Tabs`组件来使配置的路由可导航。首先，我们需要将以下代码添加到`Project`组件构造函数中，为`Tabs`组件提供必要的导航项：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the link property of our navigation items, we use the router link DSL to
    specify which route should be navigated. As the navigation is relative to the
    parent route segment and we're already in the `/projects/:projectId` route, the
    only thing in our router link DSL should be a relative path to the `tasks` and
    `comments` child routes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的导航项的链接属性中，我们使用路由链接DSL来指定应该导航到哪个路由。由于导航相对于父路由段，并且我们已经在`/projects/:projectId`路由中，所以我们的路由链接DSL中应该只包含到`tasks`和`comments`子路由的相对路径。
- en: 'In the template of our `Project` component, we can now use the `tabItems` property
    to create a binding to the input property of the `Tabs` component:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Project`组件模板中，我们现在可以使用`tabItems`属性来创建与`Tabs`组件输入属性的绑定：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Refactoring navigation
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新整理导航
- en: As a final step, we also need to refactor our navigation components to rely
    on the router. So far, we used our own routing that was implemented in a complex
    nested-navigation component structure. We can simplify this a lot using the Angular
    router.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们还需要重新整理我们的导航组件，使其依赖于路由器。到目前为止，我们使用的是我们自己实现的复杂嵌套导航组件结构中的路由。我们可以使用Angular路由器大大简化这一点。
- en: 'Let''s start with the smallest component first, and edit our `NavigationItem`
    component template in the `lib/navigation/navigation-section/navigation-item/navigation-item.html`
    file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最小的组件开始，并编辑`lib/navigation/navigation-section/navigation-item/navigation-item.html`文件中的`NavigationItem`组件模板：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Instead of controlling the link behavior ourselves, we now use the `RouterLink`
    directive to generate a link that is based on the component `link` input property.
    To set the active class on the navigation link, we still rely on the `isActive`
    method on our component, and there's no change required in the template.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不再自己控制链接行为，而是使用`RouterLink`指令生成一个基于组件`link`输入属性的链接。为了在导航链接上设置活动类，我们仍然依赖于组件上的`isActive`方法，并且模板中不需要任何更改。
- en: 'Let''s look at the changes to the `Component` class in the `navigation-item.js`
    file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`navigation-item.js`文件中`Component`类的更改：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Instead of relying on the `Navigation` component to manage the active state
    of navigation items, we now rely on the `RouterLink` directive. Each `RouterLink`
    directive provides an `accessor` property, `isActive`, which tells us whether
    this specific route addressed by the router link is currently activated within
    the browsers URL. Using the `@ViewChild` decorator, we can query for the `RouterLink`
    directive in our view and then query the `isActive` property to find out if the
    current navigation item is active or not.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不再依赖于`Navigation`组件来管理导航项的活动状态，而是依赖于`RouterLink`指令。每个`RouterLink`指令提供一个`accessor`属性，`isActive`，它告诉我们由路由链接指定的特定路由是否在浏览器的URL中当前激活。使用`@ViewChild`装饰器，我们可以在视图中查询`RouterLink`指令，然后查询`isActive`属性以确定当前导航项是否处于活动状态。
- en: Now, we only need to make sure that we pass the necessary items to the `Navigation`
    component in our `App` component in order to make our navigation work again.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需确保在`App`组件中将必要的项目传递给`Navigation`组件，以便使我们的导航再次工作。
- en: 'The following code needs to be changed in the `App` component constructor in
    the `app.js` file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在`app.js`文件中的`App`组件构造函数中更改以下代码：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By filtering and mapping the available projects, we can create a list of navigation
    items that contain a `title` and `link` property. The `link` property contains
    a route link DSL that points to the project details route that is configured in
    the `App` component router configuration. By passing an object literal as a sibling
    to the route name, we can specify some parameters along the route. Here, we simply
    set the expected `projectId` parameter to the ID of the project in the projects
    list.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过过滤和映射可用的项目，我们可以创建一个包含`title`和`link`属性的导航项列表。`link`属性包含一个指向在`App`组件路由配置中配置的项目详情路由的路由链接DSL。通过将对象字面量作为路由名称的兄弟节点传递，我们可以在路由中指定一些参数。在这里，我们只需将预期的`projectId`参数设置为项目列表中项目的ID。
- en: Now, our navigation components make use of the router to enable navigation.
    We got rid of our custom routing functionality in the `Navigation` component,
    and we use router link DSL to create navigation items.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的导航组件利用路由器来实现导航功能。我们在`Navigation`组件中移除了自定义路由功能，并使用路由链接DSL来创建导航项。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the basic concepts of the router in Angular.
    We looked at how we can use the existing component tree to configure child routes
    in nested-router scenarios. Using nested-child routes, we enabled the reuse of
    components with route configurations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Angular中路由器的基本概念。我们探讨了如何使用现有的组件树在嵌套路由场景中配置子路由。通过使用嵌套子路由，我们实现了带有路由配置的组件的重用。
- en: We also looked at the problem of router versus template composition and how
    to mitigate this problem using wrapper components. In this way, we close the gap
    between the router and underlying components using an in-between layer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了路由器与模板组合的问题以及如何通过使用包装组件来缓解这个问题。通过这种方式，我们通过一个中间层来缩小路由器和底层组件之间的差距。
- en: We looked into route configuration specifics and the basics of the router link
    DSL. We also covered the basics of the `RouteTree` and `RouteSegment` classes
    and how to use them to perform in-depth route analysis.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了路由配置的细节和路由链接DSL的基础知识。我们还涵盖了`RouteTree`和`RouteSegment`类的基础知识以及如何使用它们进行深入的路由分析。
- en: In the next chapter, we will learn about SVG and how to use this web standard
    in order to draw graphics in our Angular applications. We will visualize an activity
    log of our application activities using SVG and see how Angular makes this technology
    even greater by enabling composability.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习SVG以及如何在我们的Angular应用程序中使用这个网络标准来绘制图形。我们将使用SVG可视化我们的应用程序活动日志，并看到Angular如何通过启用组合性使这项技术更加出色。
