- en: Supporting Server Data Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持服务器数据持久性
- en: It's now time to talk to the server! There is no fun in creating a workout,
    adding exercises, and saving it to later realize that all our efforts are lost
    because the data did not persist anywhere. We need to fix this.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候与服务器进行交流了！创建锻炼、添加练习并保存下来，然后发现所有努力都白费，因为数据没有持久化存储。我们需要解决这个问题。
- en: Seldom are applications self-contained. Any consumer app, irrespective of its
    size, has parts that interact with elements outside its boundary. With web-based
    applications, the interaction is mostly with a server. Apps interact with the
    server to authenticate, authorize, store/retrieve data, validate data, and perform
    other such operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序很少是自包含的。无论大小如何，任何消费者应用程序都有与其边界之外的元素交互的部分。对于基于Web的应用程序，交互主要是与服务器进行的。应用程序与服务器交互用于认证、授权、存储/检索数据、验证数据以及执行其他操作。
- en: This chapter explores the constructs that Angular provides for client-server
    interaction. In the process, we add a persistence layer to *Personal Trainer*
    that loads and saves data to a backend server.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了Angular提供的用于客户端-服务器交互的构造。在这个过程中，我们为*个人教练* 添加了一个持久化层，用于向后端服务器加载和保存数据。
- en: 'The topics we cover in this chapter include the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们讨论的主题包括以下内容：
- en: '**Provisioning a backend to persist workout data**: We set up a MongoLab account
    and use its Data API to access and store workout data.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置后端以持久化训练数据**：我们设置一个MongoLab账户，并使用其数据API来访问和存储锻炼数据。'
- en: '**Understanding the Angular HttpClient**: The `HttpClient` allows us to interact
    with a server over HTTP. You''ll learn how to make all types of `GET`, `POST`,
    `PUT`, and `DELETE` requests with the `HttpClient`.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**了解Angular HttpClient**：`HttpClient`允许我们通过HTTP与服务器进行交互。您将学习如何使用`HttpClient`
    发起各种类型的`GET`、`POST`、`PUT` 和 `DELETE` 请求。'
- en: '**Implementing the loading and saving of workout data**: We use the `HTTPClient`
    to load and store workout data in the MongoLab databases.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现锻炼数据的加载和保存**：我们使用`HTTPClient`加载并存储MongoLab数据库中的锻炼数据。'
- en: '**Two ways in which we can use the HttpClient''s XMLHttpRequest**: Either Observables
    or with promises.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们可以使用HttpClient的XMLHttpRequest的两种方式**：使用Observables或承诺。'
- en: '**Using RxJS and Observables**: To subscribe to and query streams of data.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用RxJS和Observables**：用于订阅和查询数据流。'
- en: '**Using promises**: In this chapter, we will see how to use promises as part
    of HTTP invocation and response.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用承诺**：在本章中，我们将学习如何在HTTP调用和响应中使用承诺。'
- en: '**Working with cross-domain access**: As we are interacting with a MongoLab
    server in a different domain, you will learn about browser restrictions on cross-domain
    access. You will also learn how JSONP and CORS help us make cross-domain access
    easy and about Angular JSONP support.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨域访问工作**：由于我们要与不同域的MongoLab服务器进行交互，您将了解浏览器对跨域访问的限制。您还将学习JSONP和CORS如何帮助我们轻松进行跨域访问，以及Angular对JSONP的支持。'
- en: Let's set the ball rolling.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Angular and server interactions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular和服务器交互
- en: Any client-server interaction typically boils down to sending HTTP requests
    to a server and receiving responses from a server. For heavy JavaScript apps,
    we depend on the AJAX request/response mechanism to communicate with the server.
    To support AJAX-based communication, Angular provides the Angular `HttpClient` module.
    Before we delve into the `HttpClient` module, we need to set up our server platform
    that stores the data and allows us to manage it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 任何客户端-服务器交互通常归结为向服务器发送HTTP请求并从服务器接收响应。对于重型JavaScript应用程序，我们依赖AJAX请求/响应机制与服务器通信。为了支持基于AJAX的通信，Angular提供了Angular
    `HttpClient` 模块。在深入研究`HttpClient` 模块之前，我们需要设置存储数据并允许我们管理数据的服务器平台。
- en: Setting up the persistence store
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置持久化存储
- en: For data persistence, we use a document database called MongoDB ([https://www.mongodb.com/](https://www.mongodb.com/)),
    hosted over MongoLab ([https://www.mlab.com/](https://www.mlab.com/)), as our
    data store. The reason we zeroed in on MongoLab is that it provides an interface
    to interact with the database directly. This saves us the effort of setting up
    server middleware to support MongoDB interaction.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据持久性，我们使用名为MongoDB（[https://www.mongodb.com/](https://www.mongodb.com/)）的文档数据库，托管在MongoLab（[https://www.mlab.com/](https://www.mlab.com/)）上作为我们的数据存储。我们选择MongoLab的原因是它提供了与数据库直接交互的接口。这样可以节省我们设置服务器中间件来支持MongoDB交互的工作。
- en: It is never a good idea to expose the data store/database directly to the client.
    But in this case, since our primary aim is to learn about Angular and client-server
    interaction, we take this liberty and directly access the MongoDB instance hosted
    in MongoLab. There is also a new breed of apps that are built over **noBackend**
    solutions. In such a setup, frontend developers build apps without the knowledge
    of the exact backend involved. Server interaction is limited to making API calls
    to the backend. If you are interested in knowing more about these noBackend solutions,
    do check out [http://nobackend.org/](http://nobackend.org/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将数据存储/数据库暴露给客户端并不是一个好主意。但在这种情况下，由于我们的主要目的是学习 Angular 和客户端-服务器交互，我们冒险直接访问了MongoLab托管的
    MongoDB 实例。还有一种新型应用程序是建立在**无后端**解决方案上的。在这样的设置中，前端开发人员构建应用程序而无需了解涉及的确切后端知识。服务器交互仅限于向后端发出
    API 调用。如果你对这些无后端解决方案感兴趣，可以查看 [http://nobackend.org/](http://nobackend.org/)。
- en: 'Our first task is to provision an account on MongoLab and create a database:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个任务是在 MongoLab 上配置一个账号并创建一个数据库：
- en: Go to [https://mlab.com](https://mlab.com) and sign up for an mLab account by
    following the instructions on the website
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://mlab.com](https://mlab.com) 并按照网站上的说明注册一个 mLab 账号
- en: Once the account is provisioned, log in and create a new Mongo database by clicking
    on the Create New button on the home page
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账号配置好后，登录并点击主页上的“Create New”按钮创建一个新的Mongo数据库
- en: 'On the database creation screen, you need to make some selections to provision
    the database. See the following screenshot to select the free database tier and
    other options:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库创建页面上，你需要进行一些选择来配置数据库。参见下面的截图选择免费的数据库层级和其他选项：
- en: '![](img/f77d00af-d5f5-4a3c-80ec-b4f229c79e75.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f77d00af-d5f5-4a3c-80ec-b4f229c79e75.png)'
- en: Create the database and make a note of the database name that you create
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据库，记下你创建的数据库名称
- en: 'Once the database is provisioned, open the database and add two collections
    to it from the Collection tab:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦数据库被配置好，打开数据库并从“Collection”标签页向其中添加两个集合：
- en: '`exercises`: This stores all *Personal Trainer* exercises'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exercises`: 这里存储了所有*个人教练*的锻炼'
- en: '`workouts`: This stores all *Personal Trainer* workouts'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workouts`: 这里存储了所有的*个人教练*锻炼'
- en: Collections in the MongoDB world equate to a database table.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 中的集合相当于数据库表。
- en: MongoDB belongs to a breed of databases called **document databases**. The central
    concepts here are documents, attributes, and their linkages. And unlike traditional
    databases, the schema is not rigid. We will not be covering what document databases
    are and how to perform data modeling for document-based stores in this book. *Personal
    Trainer* has a limited storage requirement and we manage it using the two previously
    mentioned document collections. We may not even be using the document database
    in its true sense.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 属于一类称为**文档数据库**的数据库。这里的核心概念是文档、属性和它们的关联。与传统数据库不同，这里的模式不是固定的。我们在这本书中不会涵盖文档数据库的概念以及如何为基于文档的存储执行数据建模。*个人教练*的存储需求有限，我们使用上述的两个文档集合进行管理。甚至我们可能根本不会以真正意义上的文档数据库来使用它。
- en: Once the collections are added, add yourself as a user to the database from
    the Users tab.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 添加集合后，从“Users”标签页将自己添加为数据库用户。
- en: 'The next step is to determine the API key for the MongoLab account. The provisioned
    API key has to be appended to every request made to MongoLab. To get the API key,
    perform the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确定 MongoLab 账号的 API 密钥。配置好的 API 密钥必须附加到每个发送给 MongoLab 的请求中。要获得 API 密钥，请执行以下步骤：
- en: Click on the username (not the account name) in the top-right corner to open
    the user profile.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右上角的用户名（而不是账户名）以打开用户配置文件。
- en: In the section titled API Key, the current API key is displayed; copy it. At
    the same time, click on the button below the API key to Enable Data API access.
    This is disabled by default.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为“API Key”的部分，会显示当前的 API 密钥；复制它。同时，点击 API 密钥下面的按钮以启用数据 API 访问。默认情况下是禁用的。
- en: The data store schema is complete. We now need to seed these collections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储模式已经完成。现在我们需要填充这些集合。
- en: Seeding the database
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充数据库
- en: The *Personal Trainer* app already has a predefined workout and a list of 12
    exercises. We need to seed the collections with this data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*个人教练*应用程序已经有一个预定义的锻炼和一个包含 12 个锻炼的列表。我们需要使用这些数据填充集合。'
- en: Open `seed.js` in the `trainer/db` folder for checkpoint 5.1 from the companion
    code base. It contains the seed JSON script and detailed instructions on how to
    seed data into the MongoLab database instance.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在`trainer/db`文件夹的检查点5.1中打开`seed.js`。 它包含种子JSON脚本和有关如何向MongoLab数据库实例种子数据的详细说明。
- en: 'Once seeded, the database will have one workout in the workouts collection
    and 12 exercises in the exercises collection. Verify this on the MongoLab site;
    the collections should show the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 种子后，数据库将在workouts收集中有一个锻炼和在exercises收集中有12个练习。 在MongoLab网站上验证这一点;收集应该显示如下：
- en: '![](img/f0da6449-0b07-4221-a218-299189fbad23.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0da6449-0b07-4221-a218-299189fbad23.png)'
- en: Everything has been set up now, so let's start our discussion of the `HttpClient` module
    and implement workout/exercise persistence for the *Personal Trainer* app.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都设置好了，让我们开始讨论`HttpClient`模块并为*个人健身教练*应用程序实现锻炼/运动持久性。
- en: The basics of the HTTPClient module
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPClient模块的基础
- en: At the core of the `HTTPClient` module is the `HttpClient`. It performs HTTP
    requests using `XMLHttpRequest` as the default backend (JSONP is also available,
    as we will see later in this chapter). It supports requests such as `GET`, `POST`,
    `PUT`, and `DELETE`. In this chapter, we will use the `HttpClient` to make all
    of these types of requests. As we will see, the `HttpClient` makes it easy to
    make these calls with a minimal amount of setup and complexity. None of this terminology
    will come as a surprise to anyone who has previously worked with Angular or built
    JavaScript applications that communicate with a backend data store.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HTTPClient`模块的核心是`HttpClient`。 它使用`XMLHttpRequest`作为默认后端执行HTTP请求（JSONP也可用，我们将在本章后面看到）。
    它支持`GET`，`POST`，`PUT`和`DELETE`等请求。 在本章中，我们将使用`HttpClient`进行所有这些类型的请求。 正如我们将看到的，`HttpClient`使得以最少的设置和复杂性很容易进行这些调用。
    这些术语对于之前曾经使用过Angular或构建过与后端数据存储通信的JavaScript应用程序的人来说都不会感到意外。
- en: However, there is a substantial change in the way Angular handles HTTP requests.
    Calling a request now returns an Observable of HTTP responses. It does so by using
    the RxJS library, which is a well-known open source implementation of the asynchronous
    Observable pattern.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Angular处理HTTP请求的方式发生了重大变化。 现在调用请求会返回HTTP响应的Observable。 它这样做是使用RxJS库，这是一种广为人知的异步Observable模式的开源实现。
- en: You can find the RxJS project on GitHub at [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS).
    The site indicates that the project is being actively developed by Microsoft in
    collaboration with a community of open source developers. We will not be covering
    the asynchronous Observable pattern in great detail here, and we encourage you
    to visit that site to learn more about the pattern and how RxJS implements it.
    The version of RxJS that Angular is using is beta 5.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到RxJS项目[https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)。
    该网站表明该项目正在与开源开发人员社区一起由微软积极开发。 我们将不会在这里详细介绍RxJS如何实现异步Observable模式，我们鼓励您访问该网站，以了解有关该模式以及RxJS如何实现它的更多信息。
    Angular使用的RxJS版本是beta 5。
- en: In the simplest of terms, using Observables allows a developer to think about
    the data that flows through an application as streams of information that the
    application can dip into and use whenever it wants. These streams change over
    time, which allows the application to react to these changes. This quality of
    Observables provides a foundation for **functional reactive programming** (**FRP**),
    which fundamentally shifts the paradigm for building web applications from imperative
    to reactive.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，使用Observable允许开发人员将应用程序中流动的数据视为信息流，应用程序可以随时候接并使用的信息流。 这些信息流随时间变化，这允许应用程序对这些变化做出反应。
    Observable的这种特性为**函数式响应式编程**（**FRP**）提供了基础，从命令式转变为响应式从根本上改变了构建Web应用程序的范例。
- en: The `RxJS` library provides operators that allow you to subscribe to and query
    these data streams. Moreover, you can easily mix and combine them, as we will
    see in this chapter. Another advantage of Observables is that it is easy to cancel
    or unsubscribe from them, making it possible to seamlessly handle errors inline.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`RxJS`库提供了运算符，允许您订阅和查询这些数据流。 此外，您可以轻松混合和组合它们，正如我们将在本章看到的。 Observable的另一个优点是轻松取消或退订它们，从而可以无缝处理错误。'
- en: While it is still possible to use promises, the default method in Angular uses
    Observables. We will also cover promises in this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管仍然可以使用promises，但Angular的默认方法使用Observables。本章还将介绍promises。
- en: Personal Trainer and server integration
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人教练和服务器集成
- en: As described in the previous section, client-server interaction is all about
    asynchronicity. As we alter our *Personal Trainer* app to load data from the server,
    this pattern becomes self-evident.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一节所述，客户端-服务器交互完全是异步的。当我们修改*个人教练*应用程序以从服务器加载数据时，这种模式变得不言自明。
- en: In the previous chapter, the initial set of workouts and exercises was hardcoded
    in the `WorkoutService` implementation. Let's see how to load this data from the
    server first.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，练习和锻炼的初始集合是硬编码在`WorkoutService`实现中的。让我们先看看如何从服务器加载这些数据。
- en: Loading exercise and workout data
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载练习和锻炼数据
- en: Earlier in this chapter, we seeded our database with a data form, the `seed.js`
    file. We now need to render this data in our views. The MongoLab Data API is going
    to help us here.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面部分，我们使用一个数据形式在数据库中播种了数据，即`seed.js`文件。现在我们需要在视图中呈现这些数据。MongoLab数据API将在这里帮助我们。
- en: The MongoLab Data API uses an API key to authenticate access requests. Every
    request made to the MongoLab endpoints needs to have a query string parameter,
    `apikey=<key>`, where `key` is the API key that we provisioned earlier in the
    chapter. Remember that the key is always provided to a user and associated with
    their account. Avoid sharing your API keys with others.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: MongoLab数据API使用API密钥来验证访问请求。对MongoLab端点发出的每个请求都需要一个查询字符串参数，`apikey=<key>`，其中`key`是我们在本章中之前提供的API密钥。请记住，密钥始终提供给用户并与其帐户关联。不要与他人共享您的API密钥。
- en: 'The API follows a predictable pattern to query and update data. For any MongoDB
    collection, the typical endpoint access pattern is one of the following (given
    here is the base URL: [https://api.mongolab.com/api/1/databases](https://api.mongolab.com/api/1/databases)):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 该API遵循可预测的模式来查询和更新数据。对于任何MongoDB集合，典型的端点访问模式是以下之一（此处提供了基本URL：[https://api.mongolab.com/api/1/databases](https://api.mongolab.com/api/1/databases)）：
- en: '`/<dbname>/collections/<name>?apiKey=<key>`: This has the following requests:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/<dbname>/collections/<name>?apiKey=<key>`: 这包括以下请求:'
- en: '`GET`: This action gets all objects in the given collection name.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`: 此操作获取给定集合名称中的所有对象。'
- en: '`POST`: This action adds a new object to the collection name. MongoLab has
    an `_id` property that uniquely identifies the document (object). If not provided
    in the posted data, it is auto-generated.'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`: 此操作将新对象添加到集合名称中。MongoLab有一个`_id`属性，它可以唯一标识文档（对象）。如果在发布的数据中未提供，它将被自动生成。'
- en: '`/<dbname>/collections/<name>/<id>?apiKey=<key>`: This has the following requests:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/<dbname>/collections/<name>/<id>?apiKey=<key>`: 这包括以下请求:'
- en: '`GET`: This gets a specific document/collection item with a specific ID (a
    match done on the `_id` property) from the collection name.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`: 这会获取具有特定ID的特定文档/集合项（在集合名称中的 `_id`属性上进行匹配）。'
- en: '`PUT`: This updates the specific item (`id`) in the collection name.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`: 这会更新集合名称中的特定项目（`id`）。'
- en: '`DELETE`: This deletes the item with a specific ID from the collection name.'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`: 这将从集合名称中删除具有特定ID的项目。'
- en: For more details on the Data API interface, visit the MongoLab Data API documentation
    at [http://docs.mlab.com/data-api](http://docs.mlab.com/data-api).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Data API接口的更多细节，请访问MongoLab Data API文档：[http://docs.mlab.com/data-api](http://docs.mlab.com/data-api)。
- en: Now we are in a position to start implementing exercise/workout list pages.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有能力开始实现练习/锻炼列表页面。
- en: 'The code that we are starting with in this chapter is `checkpoint 4.6` (folder:
    `trainer`) in the GitHub repository for this book. It is available on GitHub ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)).
    Checkpoints are implemented as branches in GitHub. If you are not using Git, download
    the snapshot of checkpoint 4.6 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint4.6](https://github.com/chandermani/angular6byexample/tree/checkpoint4.6).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中开始时使用的代码是`checkpoint 4.6`（文件夹：`trainer`）在本书的GitHub存储库中。它可以在GitHub上找到（[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)）。检查点在GitHub中作为分支进行实现。如果您没有使用Git，请从以下GitHub位置下载检查点4.6的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint4.6](https://github.com/chandermani/angular6byexample/tree/checkpoint4.6)。第一次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Loading exercise and workout lists from a server
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器加载练习和锻炼列表
- en: 'To pull exercise and workout lists from the MongoLab database, we have to rewrite
    our `WorkoutService` service methods: `getExercises` and `getWorkouts`. But before
    we can do that, we have to set up our service to work with Angular''s HTTPClient
    module.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从MongoLab数据库中提取练习和锻炼列表，我们必须重新编写我们的`WorkoutService`服务方法：`getExercises`和`getWorkouts`。但在此之前，我们必须设置我们的服务以便与Angular的HTTPClient模块一起使用。
- en: Adding the HTTPClient module and RxJS to our project
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将HTTPClient模块和RxJS添加到我们的项目中
- en: 'The Angular HTTPClient module is included in the Angular bundles that you have
    already installed. To use it, we need to import it into `app.module.ts,` like
    so (make sure that the import follows `BrowserModule`):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的HTTPClient模块已经包含在您已经安装的Angular包中。要使用它，我们需要将其导入到`app.module.ts`中，就像这样（确保导入跟在`BrowserModule`之后）：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We also need an external third-party library: **Reactive Extensions for JavaScript**
    (**RxJS**). RxJS implements the Observable pattern and it is used by Angular with
    the HTTPClient module. It is included in the Angular bundles that are already
    part of our project.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个外部第三方库：**JavaScript响应式扩展**（**RxJS**）。RxJS实现了Observable模式，并且它与HTTPClient模块一起被Angular使用。它已经包含在我们项目中已经存在的Angular包中。
- en: Updating workout-service to use the HTTPClient module and RxJS
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新workout-service以使用HTTPClient模块和RxJS
- en: 'Open  `workout.service.ts` from `trainer/src/app/core`. In order to use the
    HTTPClient and RxJS within the `WorkoutService`, we need to add the following
    imports to that file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从`trainer/src/app/core`中打开`workout.service.ts`。为了在`WorkoutService`中使用HTTPClient和RxJS，我们需要将以下导入添加到该文件中：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are importing the `HTTPClient` module along with `Observable` from RxJS and
    one additional RxJS operator: `catchError`. We'll see how this operator is used
    as we work through the code in this section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从RxJS导入`HTTPClient`模块以及`Observable`，还有一个额外的RxJS运算符：`catchError`。随着我们在这一节中的工作，我们将看到这个运算符是如何使用的。
- en: 'In the class definition, add the following properties, which include a workout
    property and ones that set the URL for the collections in our Mongo database and
    the key to that database as well as another property: `params`, which sets up
    the API key as a query string for API access:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义中，添加以下属性，其中包括一个锻炼属性和用于设置我们Mongo数据库中集合的URL以及该数据库的密钥的属性，以及另一个属性：`params`，它将API密钥设置为API访问的查询字符串：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Replace the `<dbname>` and `<key>` tokens with the database name and API key
    of the database that we provisioned earlier in the chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 用数据库名称和我们在本章中提供的数据库的API密钥替换`<dbname>`和`<key>`标记。
- en: 'Next, inject the HTTPClient module into the `WorkoutServiceconstructor` using
    the following line of code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下代码将HTTPClient模块注入`WorkoutServiceconstructor`中：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then change the `getExercises()` method to the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`getExercises()`方法更改为以下内容：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you are used to working with promises for asynchronous data operations, what
    you see here will look different. Instead of a promise that has a call to `then()`
    chained to it, what happens here is that the `http.get` method returns an Observable from
    the RxJS library. Notice that we are also setting the response to be of type `<ExercisePlan>` to
    make explicit to our upstream callers what type of Observable is being returned
    from our HTTP GET call.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您习惯于使用承诺进行异步数据操作，那么您在这里看到的将会有所不同。在这里发生的是`http.get`方法返回了来自RxJS库的Observable。请注意，我们还设置了响应为`<ExercisePlan>`类型，以明确告诉我们的上游调用者我们的HTTP
    GET调用返回的Observable类型。
- en: Returning an Observable is the default response when using the `HTTPClient`
    module's `get` method. The Observable can, however, be converted to a promise.
    And, as we will see later in this chapter, the option to return JSONP also exists.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`HTTPClient`模块的`get`方法时，默认响应是返回一个Observable。然而，Observable可以转换为一个promise。正如我们将在本章后面看到的那样，也存在返回JSONP的选项。
- en: 'Before we move on, there is one more thing to touch upon in this code. Notice
    that we are using a pipe method to add a `catchError` operator. This operator
    accepts a method, `handleError`, for handling a failed response. The `handleError`
    method takes the failed response as a parameter. We log the error to the console
    and use `Observable.throw` to return the error to the consumer:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，在这段代码中还有一件事要注意。请注意，我们使用了一个管道方法来添加一个`catchError`操作符。这个操作符接受一个方法，`handleError`，用于处理失败的响应。`handleError`方法将失败的响应作为参数。我们将错误记录到控制台并使用`Observable.throw`将错误返回给消费者：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To be clear, this is not production code, but it will give us the opportunity
    to show how to write code upstream to handle errors that are generated as part
    of data access.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 明确一点，这不是生产代码，而是让我们有机会展示如何编写上游代码来处理作为数据访问一部分生成的错误。
- en: It is important to understand that at this stage no data is flowing through
    the Observable until there is a subscription to it. This can bring about a gotcha
    moment for things such as adds and updates if you are not careful to add subscriptions
    to your Observables.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 需要明确的是，在这个阶段，Observable中没有任何数据流动，直到有订阅它的操作。如果您不小心为您的Observables添加订阅，这可能会在诸如添加和更新之类的操作中带来一个令人惊讶的时刻。
- en: Modifying getWorkouts() to use the HTTPClient module
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改`getWorkouts()`以使用HTTPClient模块
- en: 'The change in the code for retrieving workouts is almost identical to that
    for the exercises:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 检索运动的代码变化与检索锻炼的代码几乎完全相同：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again we are specifying the type of Observable—in this case `<WorkoutPlan[]>`—that
    will be returned by our HTTP GET call and using `pipe` to add a `catchError` operator.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 再次指定Observable的类型——在这种情况下是`<WorkoutPlan[]>`——我们使用`pipe`来添加一个`catchError`操作符。
- en: Now that the `getExercises` and `getWorkouts` methods are updated, we need to
    make sure that they work with the upstream callers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`getExercises`和`getWorkouts`方法已经更新，我们需要确保它们与上游调用者配合工作。
- en: Updating the workout/exercise list pages
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新锻炼/运动列表页面
- en: 'The exercise and workout list pages (as well as `LeftNavExercises`) call either
    the `getExercises` or `getWorkouts` method in `model.ts`. In order to get these
    working with the remote calls that are now being made using the `HTTPClient` module,
    we need to modify those calls to subscribe to the Observable that is being returned
    by the `HTTPClient` module. So, update the code in the `ngOnInit` method in `exercises.component.ts`
    to the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 锻炼和运动列表页面（以及`LeftNavExercises`）调用`model.ts`中的`getExercises`或`getWorkouts`方法。为了使这些与正在使用`HTTPClient`模块进行的远程调用能够正常工作，我们需要修改这些调用以订阅被`HTTPClient`模块返回的Observable。因此，请更新`exercises.component.ts`中的`ngOnInit`方法中的代码如下：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our method now subscribes to the Observable that is being returned by the `getExercises`
    method; at the point when the response arrives, it assigns the results to `exerciseList`.
    If there is an error, it assigns it to a `console.error` call that displays the
    error in the console. All of this is now being handled asynchronously using the
    `HTTPClient` module with RxJS.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法现在订阅由`getExercises`方法返回的Observable；当响应到达时，它将结果赋给`exerciseList`。如果发生错误，它将分配给一个`console.error`调用，该调用在控制台中显示错误。所有这些现在都是使用RxJS和`HTTPClient`模块以异步方式处理的。
- en: Go ahead and make similar changes to the `ngOnInit` methods in `workouts.component.ts`
    and `left-nav-exercises.component.ts`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 继续对`workouts.component.ts`和`left-nav-exercises.component.ts`中的`ngOnInit`方法进行类似的更改。
- en: Refresh the workout/exercise list page and the workout and exercise data will
    be loaded from the database server.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新锻炼/运动列表页面，锻炼和运动数据将从数据库服务器加载。
- en: Look at the complete implementation in checkpoint 5.1 in the GitHub repository
    if you are having difficulty in retrieving/showing data. Note that in this checkpoint,
    we have disabled navigation links to the workout and exercise screens because
    we still have to add the Observable implementation to them. We'll do that in the
    next section. Also remember to replace the database name and API key before you
    run the code from `Checkpoint 5.1`. If you are not using Git, download the snapshot
    of `Checkpoint 5.1` (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.1](https://github.com/chandermani/angular6byexample/tree/checkpoint5.1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在检索/显示数据时遇到困难，请查看GitHub仓库中检查点5.1中的完整实现。 请注意，在此检查点中，我们已经禁用了导航链接到锻炼和练习屏幕，因为我们仍然需要为它们添加Observable实现。
    我们将在下一节中执行此操作。 还记得在运行`Checkpoint 5.1`的代码之前，请替换数据库名称和API密钥。 如果您没有使用Git，请从以下GitHub位置下载`Checkpoint
    5.1`的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint5.1](https://github.com/chandermani/angular6byexample/tree/checkpoint5.1)。
    在首次设置快照时，请参考“trainer”文件夹中的`README.md`文件。
- en: 'This looks good and the lists are loading fine. Well, almost! There is a small
    glitch in the workout list page. We can easily spot it if we look carefully at
    any list item (in fact, there is only one item):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很不错，列表加载正常。 嗯，几乎没有问题！ 在锻炼列表页面有一个小故障。 如果我们仔细观察任何列表项（实际上只有一项），我们可以很容易地发现它：
- en: '![](img/4851c5e6-0779-4132-8184-519d877ee77f.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4851c5e6-0779-4132-8184-519d877ee77f.png)'
- en: The workout duration calculations are not working anymore! What could be the
    reason? We need to look back at how these calculations were implemented. The `WorkoutPlan`
    service (in `model.ts`) defines a `totalWorkoutDuration` method that does the
    math for this.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 锻炼时长的计算不再有效！ 这可能是原因是什么？ 我们需要回顾一下这些计算是如何实现的。 `WorkoutPlan`服务（在`model.ts`中）定义了一个`totalWorkoutDuration`方法，用于执行这个计算。
- en: The difference is in the workout array that is bound to the view. In the previous
    chapter, we created the array with model objects that were created using the `WorkoutPlan`
    service. But now, since we are retrieving data from the server, we bind a simple
    array of JavaScript objects to the view, which for obvious reasons has no calculation
    logic.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 工作数组的差异在于绑定到视图上。在前一章中，我们使用`WorkoutPlan`服务创建的模型对象数组创建了该数组。 但是现在，因为我们从服务器检索数据，我们将一个简单的JavaScript对象数组绑定到视图，这显然没有计算逻辑。
- en: We can fix this problem by mapping a server response to our model class objects
    and returning them to any upstream caller.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将服务器响应映射到我们的模型类对象并将它们返回给任何上游调用者来解决这个问题。
- en: Mapping server data to application models
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将服务器数据映射到应用程序模型
- en: Mapping server data to our model and vice versa may be unnecessary if the model
    and server storage definition match. If we look at the `Exercise` model class
    and the seed data that we have added for the exercise in MongoLab, we will see
    that they do match and hence mapping becomes unnecessary.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型和服务器存储定义匹配，那么将服务器数据映射到我们的模型，反之亦然可能是不必要的。 如果我们看一下`Exercise`模型类和我们在MongoLab中为练习添加的种子数据，我们会发现它们是匹配的，因此映射变得不必要。
- en: 'Mapping a server response to the model data becomes imperative if:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果：
- en: Our model defines any methods
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的模型定义了任何方法
- en: A stored model is different from its representation in code
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储的模型与其在代码中的表示不同
- en: The same model class is used to represent data from different sources (this
    can happen for mashups, where we pull data from disparate sources)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的模型类用于表示来自不同来源的数据（这可能发生在混搭数据的情况下，我们从不同的来源拉取数据）
- en: 'The `WorkoutPlan` service is a prime example of an impedance mismatch between
    a model representation and its storage. Look at the following screenshot to understand
    these differences:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutPlan`服务是模型表示和其存储之间阻抗不匹配的一个典型例子。 查看下面的屏幕截图以了解这些差异：'
- en: '![](img/df31aa0c-237d-4043-afea-d2c9a6531a3b.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df31aa0c-237d-4043-afea-d2c9a6531a3b.png)'
- en: 'The two major differences between the model and server data are as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 模型和服务器数据之间的两个主要差异如下：
- en: The model defines the `totalWorkoutDuration` method.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该模型定义了`totalWorkoutDuration`方法。
- en: The `exercises` array representation also differs. The `exercises` array of
    the model contains the full `Exercise` object, while the server data stores just
    the exercise identifier or name.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exercises`数组的表示方式也不同。 模型的`exercises`数组包含完整的`Exercise`对象，而服务器数据只存储了练习标识符或名称。'
- en: This clearly means that loading and saving a workout requires model mapping.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这明显意味着加载和保存锻炼需要模型映射。
- en: The way we will do this is by adding another operator to transform the Observable
    response object. So far, we have only returned a plain JavaScript object as the
    response. The nice thing is that the pipe method that we used to add error handling
    also allows us to add additional operators that we can use to transform the JavaScript
    object into the `WorkoutPlan` type in our model.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加另一个操作符来转换 Observable 响应对象的方式来实现这一点。到目前为止，我们只返回了一个普通的 JavaScript 对象作为响应。很好的一点是，我们用于添加错误处理的`pipe`方法也允许我们添加额外的操作符，我们可以用它们将
    JavaScript 对象转换为我们模型中的`WorkoutPlan`类型。
- en: 'Let''s rewrite the `getWorkouts` method in the `workout-service.ts` file to
    the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`workout-service.ts`文件中的`getWorkouts`方法重写为以下内容：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have added a  `map` operator that transforms this Observable into one made
    up of `WorkoutPlan` objects. Each `WorkoutPlan` object (we have only one at the
    moment) will then have the `totalWorkoutDuration` method that we need.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`map`操作符，将这个 Observable 转换为由`WorkoutPlan`对象组成的 Observable。每个`WorkoutPlan`对象（目前我们只有一个）将拥有我们所需的`totalWorkoutDuration`方法。
- en: Looking at the code you can see that we operate on the JSON results HTTPClient
    response, which is why we are using the `<any>` type. And then we create a typed
    array of `WorkoutPlans` and iterate through the first array using a fat arrow
    `forEach` function, assigning each JavaScript object to a `WorkoutPlan` object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 查看代码，你会发现我们是对 JSON 结果的 HTTPClient 响应进行操作，这就是我们使用`<any>`类型的原因。然后，我们创建了一个`WorkoutPlans`的类型数组，并使用箭头函数`forEach`依次对第一个数组进行迭代，将每个
    JavaScript 对象赋给一个`WorkoutPlan`对象。
- en: We return the results of these mappings to the callers that subscribe to them,
    `workouts.component.ts` in this case. We have also updated the `catchError` operator
    with a new `handleError` method which you can find in `Checkpoint 5.2`. The callers
    do not need to make any changes to the code they use to subscribe to our workouts
    Observable. Instead, the model mapping can take place at one spot in the application
    and then be used throughout it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些映射的结果返回给订阅它们的调用者，例如`workouts.component.ts`。我们还使用新的`handleError`方法更新了`catchError`操作符，你可以在检查点5.2中找到。调用者不需要对他们用来订阅我们的
    workouts Observable 的代码进行任何更改。相反，在应用程序的一个地方可以进行模型映射，然后在整个应用程序中使用它。
- en: 'If you rerun the application, you will see that the total number of seconds
    now displays properly:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新运行应用程序，你会发现总的秒数现在可以正确显示了：
- en: '![](img/93bf867c-e80e-46a1-baa0-d5abedd32142.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93bf867c-e80e-46a1-baa0-d5abedd32142.png)'
- en: 'Checkpoint 5.2 in the GitHub repository contains the working implementation
    for what we have covered so far. The GitHub branch is `checkpoint5.2` (folder:
    `trainer`).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 仓库的检查点5.2包含了我们到目前为止所涵盖的工作实现。GitHub 分支是`checkpoint5.2`（文件夹：`trainer`）。
- en: Loading exercise and workout data from the server
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器加载练习和锻炼数据
- en: Just as we fixed the `getWorkouts` implementation in `WorkoutService` earlier,
    we can implement other get operations for exercise- and workout-related stuff.
    Copy the service implementation for the `getExercise` and `getWorkout` methods
    of `WorkoutService` from `workout.service.ts` in the `trainer/src/app/core` folder
    in checkpoint 5.2.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前修复了`WorkoutService`中的`getWorkouts`实现一样，我们可以为与练习和锻炼相关的其他获取操作实现。从`trainer/src/app/core`文件夹中的`workout.service.ts`文件中拷贝`WorkoutService`的`getExercise`和`getWorkout`方法的服务实现到检查点5.2。
- en: The `getWorkout` and `getExercise` methods use the name of the workout/exercise
    to retrieve results. Every MongoLab collection item has an `_id` property that
    uniquely identifies the item/entity. In the case of our `Exercise` and `WorkoutPlan`
    objects, we use the name of the exercise for unique identification. Hence, the
    `name` and `_id` property of each object always match.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWorkout`和`getExercise`方法使用锻炼/练习的名称来检索结果。每个 MongoLab 集合项都有一个唯一标识这个项/实体的`_id`属性。对于我们的`Exercise`和`WorkoutPlan`对象，我们使用练习的名称来进行唯一标识。因此，每个对象的`name`和`_id`属性总是匹配的。'
- en: 'At this point, we will need to add one more import to `workout.service.ts`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要在`workout.service.ts`中添加另一个导入：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This import brings in the `forkJoin` operator, which we will be discussing shortly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入引入了`forkJoin`操作符，我们将在稍后讨论它。
- en: 'Pay special attention to the implementation of the `getWorkout` method because
    there is a decent amount of data transformation happening due to the model and
    data storage format mismatch. This is how the `getWorkout` method now looks:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意`getWorkout`方法的实现，因为由于模型和数据存储格式不匹配，这个方法涉及大量的数据转换。现在`getWorkout`方法的样子如下：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is a lot happening inside `getWorkout` that we need to understand.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getWorkout`中发生了很多需要我们理解的事情。
- en: 'The `getWorkout` method uses Observable and its `forkJoin` operator to return
    two Observable objects: one that retrieves the `Workout` and another that retrieves
    a list of all the `Exercises`. What is interesting about the `forkJoin` operator
    is that not only does it allow us to return multiple Observable streams, but it
    also waits until both Observable streams have retrieved their data before further
    processing the results. In other words, it enables us to stream the responses
    from multiple concurrent HTTP requests and then operate on the combined results.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWorkout`方法使用Observable及其`forkJoin`操作符来返回两个Observable对象：一个是检索到的`Workout`，另一个是检索到的所有`Exercises`的列表。`forkJoin`操作符的有趣之处在于它不仅允许我们返回多个Observable流，而且还会等待两个Observable流都检索到其数据后才进一步处理结果。换句话说，它使我们能够从多个并发的HTTP请求中获取响应，然后对组合的结果进行操作。'
- en: Once we have the `Workout` details and the complete list of exercises, we then
    `pipe` the results to the `map` operator (which we saw previously with the code
    for the `Workouts` list), which we use to change the `exercises` array of the
    workout to the correct `Exercise` class object. We do this by searching the `allExercises`
    Observable for the name of the exercise in the `workout.exercises` array returned
    from the server, and then assigning the matching exercise to the workout services
    array. The end result is that we have a complete `WorkoutPlan` object with the
    `exercises` array set up correctly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`Workout`详情和完整的练习列表，我们将结果`pipe`到`map`操作符（正如我们之前在`Workouts`列表的代码中看到的），我们用它来将锻炼的`exercises`数组改为正确的`Exercise`类对象。我们通过在从服务器返回的`workout.exercises`数组中搜索`allExercises`
    Observable的练习名称，然后将匹配的练习分配给锻炼服务的数组来完成这个操作。最终结果是我们有了一个正确设置了`exercises`数组的完整的`WorkoutPlan`对象。
- en: These `WorkoutService` changes warrant fixes in upstream callers too. We have
    already fixed the lists of exercises in the `LeftNavExercises` and `Exercises`
    components and the workouts in the `Workouts` component. Now let's fix the `Workout`
    and `Exercise` components along similar lines. The `getWorkout` and `getExercise`
    methods in the workout services are not directly called by these components, but
    by builder services. So we'll have to fix the builder services together with the
    `Workout` and `Exercise` components and the two resolvers—`WorkoutResolver` and
    `ExerciseResolver`—that we have added to the routes for these components.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`WorkoutService`的更改需要上游调用方也进行修复。我们已经修复了`LeftNavExercises`和`Exercises`组件中的练习列表，以及`Workouts`组件中的锻炼。现在让我们按照类似的方式来修复`Workout`和`Exercise`组件。`Workout`服务中的`getWorkout`和`getExercise`方法不是直接由这些组件调用的，而是由构建器服务调用的。因此，我们将不得不连同`Workout`和`Exercise`组件以及我们为这些组件添加的两个解析器—`WorkoutResolver`和`ExerciseResolver`—一起修复构建器服务。
- en: Fixing the builder services
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复构建器服务
- en: 'Now that we have `WorkoutService` set up to retrieve a workout from our remote
    data store, we have to modify `WorkoutBuilderService` to be able to retrieve that
    workout as an Observable. The method that pulls the `Workout` details is `startBuilding`.
    In order to do that, we will break the current `startBuilding` method into two
    methods, one for new workouts and one for existing workouts that we have retrieved
    from the server. Here is the code for new workouts:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好`WorkoutService`以从远程数据存储中检索锻炼，我们必须修改`WorkoutBuilderService`以便能够将该锻炼作为Observable检索。提取`Workout`详情的方法是`startBuilding`。为了做到这一点，我们将当前的`startBuilding`方法分成两个方法，一个是为新的锻炼，一个是对我们从服务器检索到的旧的锻炼。以下是新锻炼的代码：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For existing workouts, we add the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于旧的锻炼，我们添加以下代码：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We'll let you make the same fixes in `ExerciseBuilderService`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让您在`ExerciseBuilderService`中做同样的修复。
- en: Updating the resolvers
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新解析器
- en: As we move on to using Observable types with our data access, we are going to
    have to make some adjustments to the resolvers that we have created for the routes
    leading to workout and exercise screens. We start with the `WorkoutResolver` in
    `workout-resolver.ts` that can be found in the `workout` folder.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始使用 Observable 类型来访问数据，我们需要对通往锻炼和练习屏幕的路由创建的解析器进行一些调整。我们首先处理 `workout` 文件夹中的
    `workout-resolver.ts` 中的 `WorkoutResolver`。
- en: 'First, add the following imports from RxJs:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从 RxJs 中添加以下导入：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next update the `resolve` method as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，按以下方式更新 `resolve` 方法：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we have split out the behavior for a new workout (one where
    there is no workout name being passed as a parameter in the URL) and that for
    an existing workout. In the former case, we call `workoutBuilderService.startBuildingExisting`,
    which will return a new `WorkoutPlan`. In the latter case, we call `workoutBuilderService.startBuildingExisting` and pipe
    the results and then map them to return the `workout` unless it is not found,
    in which case we route the user back to the `Workouts` screen.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将新锻炼的行为（在 URL 参数中未传递锻炼名称的情况）和现有锻炼的行为分开了。在前一种情况下，我们调用 `workoutBuilderService.startBuildingExisting`，它将返回一个新的
    `WorkoutPlan`。在后一种情况下，我们调用 `workoutBuilderService.startBuildingExisting` 并对结果进行处理，然后将其映射为返回
    `workout`，除非找不到，此时我们会将用户重新路由到 `Workouts` 屏幕。
- en: Fixing the Workout and Exercise components
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复锻炼和练习组件
- en: 'Once we have fixed the `WorkoutBuilderService` and the `WorkoutResolver`, there
    are actually no further fixes needed in the `WorkoutComponent`. All the work to
    handle the Observables has been done further downstream and all we need to do
    at this stage is subscribe to the route data and retrieve the workout as we have
    already been doing:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们修复了 `WorkoutBuilderService` 和 `WorkoutResolver`，实际上在 `WorkoutComponent`
    中不需要进一步的修复。处理 Observable 的所有工作都已经在更下游完成，而在此阶段我们只需要订阅路由数据，获取锻炼，就像我们之前一直在做的那样：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To test the implementation, uncomment the following highlighted code contained
    in the `onSelect` method within `workouts.component.ts`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试实现，在 `workouts.component.ts` 的 `onSelect` 方法中取消注释以下突出显示的代码：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then click on any existing workout, such as *7 Minute Workout*, from the list
    of workouts displayed at `/builder/workouts/`. The workout data should load successfully.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `builder/workouts/` 显示的锻炼列表中点击任何现有锻炼，比如 *7 分钟锻炼*。锻炼数据应成功加载。
- en: The `ExerciseBuilderService` and `ExerciseResolver` also need fixing. `Checkpoint
    5.2` contains those fixes. You can copy those files or do it yourself and compare
    the implementation. And don't forget to uncomment the code in the `onSelect` method
    in `exercises.component.ts`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExerciseBuilderService` 和 `ExerciseResolver` 也需要修复。`检查点 5.2` 包含这些修复。您可以复制这些文件，或自己进行修复并比较实现。不要忘记在
    `exercises.component.ts` 中的 `onSelect` 方法中取消注释代码。'
- en: '`Checkpoint 5.2` in the GitHub repository contains the working implementation
    for what we have covered thus far. If you are not using Git, download the snapshot
    of Checkpoint 5.2 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.2](https://github.com/chandermani/angular6byexample/tree/checkpoint5.2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 代码库中的 `检查点 5.2` 包含迄今为止我们所涵盖内容的工作实现。如果您不使用 Git，请从以下 GitHub 位置下载 `检查点 5.2`
    的快照（ZIP 文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint5.2](https://github.com/chandermani/angular6byexample/tree/checkpoint5.2)。在首次设置快照时，请参阅
    `trainer` 文件夹中的 `README.md` 文件。
- en: It is now time to fix, create, and update scenarios for the exercises and workouts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候修复、创建和更新练习和锻炼的情景了。
- en: Performing CRUD on exercises/workouts
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对练习/锻炼进行 CRUD
- en: When it comes to create, read, update, and delete (CRUD) operations, all save,
    update, and delete methods need to be converted to the Observable pattern.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建，读取，更新和删除（CRUD）操作时，所有保存、更新和删除方法都需要转换为 Observable 模式。
- en: Earlier in the chapter, we detailed the endpoint access pattern for CRUD operations
    in a MongoLab collection. Head back to the *Loading exercise and workout data* section
    and revisit the access patterns. We need this now as we plan to create/update
    workouts.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们详细描述了 MongoLab 集合中进行 CRUD 操作的端点访问模式。返回到 *加载练习和锻炼数据* 部分，重新查看访问模式。我们现在需要这个，因为我们计划创建/更新锻炼。
- en: Before we start the implementation, it is important to understand how MongoLab
    identifies a collection item and what our ID generation strategy is. Each collection
    item in MongoDB is uniquely identified in the collection using the `_id` property.
    While creating a new item, either we supply an ID or the server generates one
    itself. Once `_id` is set, it cannot be changed. For our model, we will use the
    `name` property of the exercise/workout as the unique ID and copy the name into
    the `_id` field (hence, there is no autogeneration of `_id`). Also, remember that
    our model classes do not contain this `_id` field; it has to be created before
    saving the record for the first time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施之前，了解MongoLab如何识别集合项以及我们的ID生成策略是很重要的。MongoDB中的每个集合项都是使用`_id`属性在集合中唯一标识的。在创建新项时，我们可以提供ID，也可以让服务器自动生成ID。一旦设置了`_id`，就无法更改。对于我们的模型，我们将锻炼/运动的`名称`属性作为唯一的ID，并将该名称复制到`_id`字段中（因此，`_id`没有自动生成）。另外，记住我们的模型类不包含这个`_id`字段；必须在第一次保存记录之前创建它。
- en: Let's fix the workout creation scenario first.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解决锻炼创建的场景。
- en: Creating a new workout
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的锻炼
- en: 'Taking the bottom-up approach, the first thing that needs to be fixed is `WorkoutService`.
    Update the `addWorkout` method as shown in the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 采用自下而上的方法，需要修复的第一件事是`WorkoutService`。根据以下代码更新`addWorkout`方法：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In `getWorkout`, we had to map data from the server model to our client model;
    the reverse has to be done here. First, we create a new array for the exercises,
    `workoutExercises`, and then add to that array a version of the exercises that
    is more compact for server storage. We only want to store the exercise name and
    duration in the exercises array on the server (this array is of type `any` because
    in its compact format it does not conform to the `ExercisePlan` type).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getWorkout`中，我们必须将数据从服务器模型映射到我们的客户端模型；在这里需要做相反的操作。首先，我们为锻炼创建一个新的数组，`workoutExercises`，然后将更紧凑的版本的锻炼添加到该数组中，以便更好地存储在服务器上。我们只想在服务器上的exercises数组中存储锻炼名称和持续时间（该数组是`any`类型，因为在其紧凑格式中，它不符合`ExercisePlan`类型）。
- en: Next, we set up the body of our post by mapping these changes into a JSON object.
    Note that as part of constructing this object, we set the `_id` property as the
    name of the workout to uniquely identify it in the database of the workouts collection.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过将这些更改映射到JSON对象来设置我们的post的主体。请注意，作为构造此对象的一部分，我们将`_id`属性设置为锻炼的名称，以在锻炼集合的数据库中唯一标识它。
- en: The simplistic approach of using the *name* of the workout/exercise as a record
    identifier (or `id`) in MongoDB will break for any decent-sized app. Remember
    that we are creating a web-based application that can be accessed simultaneously
    by many users. Since there is always the possibility of two users coming up with
    the same name for a workout/exercise, we need a strong mechanism to make sure
    that names are not duplicated. Another problem with the MongoLab REST API is that
    if there is a duplicate `POST` request with the same `id` field, one will create
    a new document and the second will update it, instead of the second failing. This
    implies that any duplicate checks on the `id` field on the client side still cannot
    safeguard against data loss. In such a scenario, assigning auto generation of
    the `id` value is preferable. In standard cases where we are creating entities,
    unique ID generation is done on the server (mostly by the database). The response
    to when an entity is created then contains the generated ID. In such a case, we
    need to update the model object before we return data to the calling code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，将锻炼/运动的*名称*作为记录标识符（或`id`）的简单方法将无法在任何体量较大的应用程序中使用。请记住，我们正在创建一个可以同时被许多用户访问的基于Web的应用程序。由于存在两个用户可能使用相同的锻炼/运动名称的可能性，所以我们需要一个强大的机制来确保名称不重复。MongoLab
    REST API的另一个问题是，如果有一个具有相同`id`字段的重复`POST`请求，其中一个将创建一个新文档，而另一个将更新它，而不是第二个失败。这意味着在客户端对`id`字段进行任何重复检查仍然无法防止数据丢失。在这种情况下，分配`id`值的自动生成是可取的。在标准情况下，在创建实体时，唯一的ID生成是在服务器上完成的（主要是由数据库完成）。当实体创建时，响应然后包含生成的ID。在这种情况下，在我们将数据返回给调用代码之前，我们需要更新模型对象。
- en: Lastly, we call the `post` method of the `HTTPClient` module, passing the URL
    to connect to, an extra query string parameter (`apiKey`), and the data we are
    sending.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`HTTPClient`模块的`post`方法，传递要连接的URL，额外的查询字符串参数（`apiKey`）和我们要发送的数据。
- en: The last return statement should look familiar, as we use Observables to return
    the workout object as part of the Observable resolution. You need to be sure you add
    `.subscribe` to the Observable chain in order to make it work. We'll do that shortly
    by adding a subscription to the `save` method to `WorkoutComponent`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条返回语句应该很熟悉，因为我们使用Observables返回锻炼对象作为Observable解析的一部分。您需要确保在Observable链中添加`.subscribe`以使其起作用。我们将很快通过向`WorkoutComponent`的`save`方法添加订阅来实现这一点。
- en: Updating a workout
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新锻炼
- en: 'Why not try to implement the update operation? The `updateWorkout` method can
    be fixed in the same manner, the only difference being that the `HTTPClient` module''s
    `put` method is required:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不尝试实现更新操作呢？`updateWorkout`方法可以以同样的方式修复，唯一的区别是需要`HTTPClient`模块的`put`方法。
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding request URL now contains an extra fragment (`workout.name`) that
    denotes the identifier of the collection item that needs to be updated.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的请求URL现在包含了一个额外的片段（`workout.name`），表示需要更新的集合项的标识符。
- en: The MongoLab `PUT` API request creates the document passed in as the request
    body if the document is not found in the collection. While making the `PUT` request,
    make sure that the original record exists. We can do this by making a `GET` request
    for the same document first and confirming that we get a document before we update
    it. We'll leave that for you to implement.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: MongoLab的`PUT`API请求会在集合中找不到传递的文档时创建请求体中的文档。在进行`PUT`请求时，请确保原始记录存在。我们可以通过首先对同一文档进行`GET`请求并确认我们获取到一个文档来实现这一点。将这留给您来实现。
- en: Deleting a workout
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除锻炼
- en: 'The last operation that needs to be fixed is deleting the workout. Here is
    a simple implementation where we call the `HTTPClient` module''s `delete` method
    to delete the workout referenced by a specific URL:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 需要修复的最后一个操作是删除锻炼。这里是一个简单的实现，我们调用`HTTPClient`模块的`delete`方法来删除特定URL引用的锻炼：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Fixing the upstream code
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复上游代码
- en: 'With that, it''s now time to fix the `WorkoutBuilderService` and `Workout`
    components. The `save` method of `WorkoutBuilderService` now looks as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候修复`WorkoutBuilderService`和`Workout`组件了。`WorkoutBuilderService`的`save`方法现在如下所示：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Most of it looks the same as it was earlier because it is the same! We did not
    have to update this code because we effectively isolated the interaction with
    the external server in our `WorkoutService` component.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分都和之前一样，因为它确实是一样的！我们不必更新这段代码，因为我们有效地将与外部服务器的交互隔离在我们的`WorkoutService`组件中。
- en: 'Finally, the save code for the `Workout` component is shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Workout`组件的保存代码如下所示：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we have made a change so that we now subscribe to the save. As you may
    recall from our previous discussions, `subscribe` makes an Observable live so
    that we can complete the save.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们进行了更改，以便现在订阅保存。正如您可能还记得我们之前的讨论，`subscribe`使Observable活跃，以便我们可以完成保存。
- en: And that's it! We can now create new workouts and update existing workouts (we'll
    leave completion of deleting workouts to you). That was not too difficult!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在我们可以创建新的锻炼和更新现有的锻炼（删除锻炼的完成留给您）。这并不是太困难！
- en: Let's try it out. Open the new `Workout Builder` page, create a workout, and
    save it. Also try to edit an existing workout. Both scenarios should work seamlessly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一下。打开新的`Workout Builder`页面，创建一个锻炼，并保存它。还尝试编辑一个现有的锻炼。这两种情况应该可以无缝运行。
- en: Check out `checkpoint 5.3` for an up-to-date implementation if you are having
    issues running your local copy. If you are not using Git, download the snapshot
    of Checkpoint 5.3 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.3](https://github.com/chandermani/angular2byexample/tree/checkpoint5.3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行本地副本时遇到问题，请查看`检查点5.3`以获取最新的实现。如果您没有使用Git，可以从以下GitHub位置下载`检查点5.3`的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint5.3](https://github.com/chandermani/angular2byexample/tree/checkpoint5.3)。初次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'Something interesting happens on the network side while we make `POST` or `PUT`
    requests save data. Open the browser''s network log console (*F12*) and see the
    requests being made. The log looks something like the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行`POST`或`PUT`请求保存数据时，网络端会发生一些有趣的事情。打开浏览器的网络日志控制台（*F12*），看看发出的请求。日志看起来类似于以下内容：
- en: '![](img/fb3766cd-7ab6-48bf-a59c-d80192bca5e8.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb3766cd-7ab6-48bf-a59c-d80192bca5e8.png)'
- en: The network log
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 网络日志
- en: An `OPTIONS` request is made to the same endpoint before the actual `POST` or `PUT` is
    done. The behavior that we witness here is termed as a **prefight request**. This
    happens because we are making a cross-domain request to `api.mongolab.com`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行实际的`POST`或`PUT`之前，会对相同的端点进行一个`OPTIONS`请求。在这里我们见到的行为被称为**预检请求**。这是因为我们正在对`api.mongolab.com`进行跨域请求。
- en: Using promises for HTTP requests
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用promises进行HTTP请求
- en: The bulk of this chapter has focused on how the Angular `HTTPClient` uses Observables
    as the default for `XMLHttpRequests`. This represents a significant change from
    the way things used to work. Many developers are familiar with using promises
    for asynchronous HTTP requests. With that being the case, Angular continues to
    support promises, but just not as the default choice. A developer has to opt for
    promises in an `XMLHttpRequest` in order to be able to use them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容都集中在Angular `HTTPClient`如何将Observables作为`XMLHttpRequests`的默认方式。这代表着与过去的工作方式相比存在着重大的变化。许多开发人员习惯于使用promises进行异步HTTP请求。在这种情况下，Angular继续支持promises，但不再是默认选择。开发人员必须选择promises才能在`XMLHttpRequest`中使用它们。
- en: 'For example, if we want to use promises with the `getExercises` method in `WorkoutService`,
    we will have to restructure the command as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要在`WorkoutService`的`getExercises`方法中使用promises，我们将不得不重新构建命令如下：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In order to convert this method to use promises, all we have to do is add `.toPromise()`
    to the method chain, a success parameter, `then`, for the promise, and  `catch`
    with a `Promise.reject` pointing to the existing `handleError` method.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此方法转换为使用promises，我们只需在方法链中添加`.toPromise()`，一个成功的参数`then`，以及一个指向现有`handleError`方法的`catch`和`Promise.reject`。
- en: 'For upstream components, we just have to switch to handling the return value
    as a promise rather than an Observable. So, to use promises in this case, we would
    have to change the code in `Exercises.component.ts` and `LeftNavExercises.component.ts`
    to first add a new property for the error message (we''ll leave it to you as to
    how the error message is displayed on the screen):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上游组件，我们只需将返回值的处理方式切换为promises而不是Observables。因此，要在这种情况下使用promises，我们需要更改`Exercises.component.ts`和`LeftNavExercises.component.ts`中的代码，首先添加一个用于错误消息的新属性（关于如何在屏幕上显示错误消息，我们将留给你来完成）：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then change the `ngOnInit` method that is calling `WorkoutService` to the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将调用`WorkoutService`的`ngOnInit`方法更改为以下内容：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Of course, the ease with which we can substitute promises for Observables in
    this simple example does not indicate that they are essentially the same. A `then`
    promise returns another promise, which means that you can create successively
    chained promises. In the case of an Observable, a subscription is essentially
    the end of the line and cannot be mapped or subscribed to beyond that point.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以在这个简单的例子中很容易地用promises代替Observables，这并不意味着它们本质上是相同的。一个`then` promise会返回另一个promise，这意味着你可以创建连续链接的promises。而在Observable的情况下，订阅本质上是终点，不能在此之后再进行映射或订阅。
- en: If you're familiar with promises, it may be tempting at this stage to stick
    with them and not give Observables a try. After all, much of what we have done
    with Observables in this chapter can be done with promises as well. For example,
    the mapping of two streams of Observables that we did with `getWorkouts` using
    the Observable's `forkJoin` operator can also be done with the promise's `q,all`
    function.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉promises，在这个阶段可能会倾向于坚持使用它们，而不去尝试使用Observables。毕竟，在本章中我们使用Observables所做的大部分工作也可以用promises实现。例如，我们使用Observable的`forkJoin`操作符对`getWorkouts`的两个Observable流进行映射，与之相对应，在promise中也可以使用`q,all`函数来执行相同的操作。
- en: However, you would be selling yourself short if you took that approach. Observables
    open up an exciting new way of doing web development using what is called functional
    reactive programming. They involve a fundamental shift in thinking that treats
    an application's data as a constant stream of information to which the application
    reacts and responds. This shift allows applications to be built with a different
    architecture that makes them faster and more resilient. Observables are at the
    core of Angular in such things as event emitters and the new version of `NgModel`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你采用这种方式，你实际上是在低估自己。Observables打开了一种令人兴奋的新的网页开发方式，这种方式称为函数式响应式编程。它们涉及到了一种根本性的思维转变，将应用程序的数据视为一种不断变化的信息流，应用程序对其做出反应和响应。这种转变使得应用程序可以以不同的架构构建，使其更快速和更具弹性。在Angular中，Observables是这些方面的核心，如事件发射器和新版本的`NgModel`。
- en: While promises are a useful tool to have in your toolkit, we encourage you to
    investigate Observables as you get into developing with Angular. They are part
    of the forward-looking philosophy of Angular and will be useful in future-proofing
    both your applications and your skill set.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管promises是你工具包中的一个有用工具，但我们鼓励你在使用Angular开发时调查Observables。它们是Angular前瞻性哲学的一部分，并将对未来的应用程序和技能集具有用处。
- en: 'Check out the `checkpoint 5.3` file for an up-to-date implementation that includes
    the promises-related code that we covered previously. If you are not using Git,
    download the snapshot of Checkpoint 5.3 (a ZIP file) from the following GitHub
    location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.3](https://github.com/chandermani/angular6byexample/tree/checkpoint5.3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Be aware that in the next section, we will be reverting to
    the use of Observables for this code. This code can be found in the `checkpoint
    5.4` file.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`checkpoint 5.3`文件，其中包含我们之前涵盖的与promises相关的代码的最新实现。如果你不使用Git，请从以下GitHub位置下载Checkpoint
    5.3的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint5.3](https://github.com/chandermani/angular6byexample/tree/checkpoint5.3)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。请注意，在下一节中，我们将重新使用Observables来编写这段代码。这段代码可以在`checkpoint
    5.4`文件中找到。
- en: The async pipe
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步管道
- en: As we have seen with many of the data operations covered in this chapter, there
    is a fairly common pattern being repeated over and over again. When an Observable
    is returned from an HTTP request, we convert the response to JSON and subscribe
    to it. The subscription then binds the Observable output to a UI element. Wouldn't
    it be nice if we could eliminate this repetitive coding and replace it with a
    simpler way to accomplish what we are wanting to do?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章涵盖的许多数据操作中所看到的，有一个相当常见的模式一再重复。当一个Observable从HTTP请求中返回时，我们将响应转换为JSON并订阅它。订阅然后将Observable输出绑定到UI元素。如果我们能消除这种重复的编码并用更简单的方法来完成我们想要做的事情，那不是很好吗？
- en: Not surprisingly, Angular provides us with just the right way to do that. It's
    called the **async pipe**, and it can be used like any other pipe for binding
    to an element on the screen. However, the async pipe is a much more powerful mechanism
    than other pipes. It takes an Observable or a promise as an input and subscribes
    to it automatically. It also handles the teardown of the subscription for an Observable
    without necessitating any further lines of code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，Angular为我们提供了恰当的方法。它被称为**async管道**，可以像其他管道一样用于绑定到屏幕上的元素。但是，异步管道是比其他管道更强大的机制。它以Observable或promise作为输入，并自动订阅它。它还处理Observable的订阅解除，而无需任何进一步的代码。
- en: Let's look at an example of this in our application. Let's go back to the `LeftNavExercises`
    component that we were just looking at in the previous section in connection with
    promises. Note that we have converted this component and the `Exercises` component
    from promises back to using Observables.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在我们应用程序中的例子。让我们回到我们在之前关于promises讨论的部分中刚才看到的`LeftNavExercises`组件。请注意，我们已将该组件和`Exercises`组件从promises转换回使用Observables。
- en: 'Check out the `checkpoint 5.4` file for an up-to-date implementation that includes
    the conversion of this code to use Observables once again. If you are not using
    Git, download the snapshot of Checkpoint 5.4 (a ZIP file) from the following GitHub
    location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.4](https://github.com/chandermani/angular6byexample/tree/checkpoint5.4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`checkpoint 5.4`文件，其中包含将该代码再次转换为使用Observables的最新实现。如果你不使用Git，请从以下GitHub位置下载Checkpoint
    5.4的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint5.4](https://github.com/chandermani/angular6byexample/tree/checkpoint5.4)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'Then make the following changes in `LeftNavExercises`. First, import Observable
    from RxJs:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`LeftNavExercises`中做以下更改。首先，从RxJs导入Observable：
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then change `exerciseList` from an array of exercises to an Observable of the
    same type:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`exerciseList`从一组练习更改为相同类型的Observable：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next modify the call to `WorkoutService` that gets the exercises to eliminate
    the subscription:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后修改获取练习的`WorkoutService`调用以消除订阅：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, open `left-nav-exercises.component.html` and add the `async` pipe
    to the `*ngFor` loop, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开 `left-nav-exercises.component.html` 并在 `*ngFor` 循环中添加 `async` 管道，如下所示：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Refresh the page and you will still see the Exercise list displaying. But this
    time, we have used the `async` pipe to eliminate the need to set up the subscription
    to the Observable. Pretty cool! This is a nice convenience that Angular has added,
    and since we have been spending time in this chapter understanding how Observables
    work with subscriptions, we have a clear idea of what the `async` pipe is now
    handling for us under the hood.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面，您仍将看到显示练习列表。但这次，我们使用了 `async` 管道来消除设置订阅到 Observable 的需求。非常酷！这是 Angular
    添加的一个很好的便利，因为我们在这一章节中花费时间理解 Observables 如何使用订阅，现在我们清楚地了解了 `async` 管道在幕后为我们处理的内容。
- en: We'll leave it to you to implement the same change in the `Exercises` component.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让您在 `Exercises` 组件中实现相同的更改。
- en: It is important to understand the cross-domain behavior of the HTTP request
    and the constructs that Angular provides to make cross-domain requests.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 HTTP 请求的跨域行为以及 Angular 提供的构造函数以进行跨域请求非常重要。
- en: Cross-domain access and Angular
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨域访问和 Angular
- en: Cross-domain requests are requests made for resources in a different domain.
    Such requests, when originated from JavaScript, have some restrictions imposed
    by the browser; these are called *same-origin policy* restrictions. Such a restriction
    stops the browser from making AJAX requests to domains that are different from
    the script's original source. The source match is done strictly based on a combination
    of protocol, host, and port.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 跨域请求是针对不同域中的资源的请求。此类请求，当由 JavaScript 发起时，浏览器会施加一些限制；这些被称为 *同源策略* 限制。这种限制会阻止浏览器向不同于脚本原始来源的域发出
    AJAX 请求。源匹配严格基于协议、主机和端口的组合。
- en: For our own app, the calls to `https://api.mongolab.com` are cross-domain invocations
    as our source code hosting is in a different domain (most probably, something
    like `http://localhost/....`).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们自己的应用程序，对 `https://api.mongolab.com` 的调用是跨域调用，因为我们的源代码托管在不同域（很可能是类似 `http://localhost/....`
    的域）。
- en: 'There are some workarounds and some standards that help relax/control cross-domain
    access. We will be exploring two of these techniques as they are the most commonly
    used ones. They are as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些变通方法和一些标准可以帮助放松/控制跨域访问。我们将探索其中两种最常用的技术。它们是：
- en: '**JSON with Padding** (**JSONP**)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**填充式 JSON** （**JSONP**）'
- en: '**Cross-Origin Resource Sharing** (**CORS**)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨域资源共享**（**CORS**）'
- en: A common way to circumvent this same-origin policy is to use the JSONP technique.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过同源策略的一种常见方法是使用 JSONP 技术。
- en: Using JSONP to make cross-domain requests
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSONP 进行跨域请求
- en: The JSONP mechanism of remote invocation relies on the fact that browsers can
    execute JavaScript files from any domain irrespective of the source of origin
    as long as the script is included via the `<script>` tag.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 远程调用的 JSONP 机制依赖于浏览器可以执行来自任何域的 JavaScript 文件，无论源的来源是什么，只要脚本是通过 `<script>` 标签包含的。
- en: In JSONP, instead of making a direct request to a server, a dynamic `<script>`
    tag is generated, with the `src` attribute set to the server endpoint that needs
    to be invoked. This `<script>` tag, when appended to the browser's DOM, causes
    a request to be made to the target server.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSONP 中，不是直接向服务器发出请求，而是生成一个动态的 `<script>` 标签，并将 `src` 属性设置为需要调用的服务器端点。当将这个
    `<script>` 标签追加到浏览器的 DOM 中时，将会向目标服务器发出请求。
- en: The server then needs to send a response in a specific format, wrapping the
    response content inside a function invocation code (this extra padding around
    the response data gives this technique the name JSONP).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后服务器需要以特定格式发送响应，将响应内容包裹在函数调用代码中（在响应数据周围添加额外填充给这种技术命名为 JSONP）。
- en: The Angular JSONP service hides this complexity and provides an easy API to
    make JSONP requests. The StackBlitz link, [https://stackblitz.com/edit/angular-nxeuxo](https://stackblitz.com/edit/angular-nxeuxo),
    highlights how JSONP requests are made. It uses the *IEX Free Stock API* ([https://iextrading.com/developer/](https://iextrading.com/developer/))
    to get quotes for any stock symbol.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Angular JSONP 服务隐藏了这种复杂性，并提供了一个易于使用的 API 来进行 JSONP 请求。StackBlitz 链接，[https://stackblitz.com/edit/angular-nxeuxo](https://stackblitz.com/edit/angular-nxeuxo)，突出显示了如何进行
    JSONP 请求。它使用了 *IEX Free Stock API* ([https://iextrading.com/developer/](https://iextrading.com/developer/))
    来获取任何股票符号的报价。
- en: The Angular JSONP service only supports HTTP `GET` requests. Using any other
    HTTP request, such as `POST` or `PUT`, will generate an error.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Angular JSONP服务仅支持HTTP的`GET`请求。使用任何其他HTTP请求，比如`POST`或`PUT`，将产生错误。
- en: If you look at the StackBlitz project, you will see the familiar pattern for
    component creation that we have followed throughout this book. We will not go
    over this pattern again, but will highlight a few details that are relevant to
    using the Angular JSONP service.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看 StackBlitz 项目，你会看到我们在整本书中遵循的组件创建的熟悉模式。我们不会再次介绍这个模式，但会强调一些与使用 Angular JSONP
    服务相关的细节。
- en: 'First, along with the imports for `FormsModule` and `HttpClientModule`, you
    will need to import `HttpClientJsonpModule` into `app.module.ts` as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，除了`FormsModule`和`HttpClientModule`的导入之外，你需要在`app.module.ts`中导入`HttpClientJsonpModule`如下所示：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we need to add the following imports to `get-quote.component.ts`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`get-quote.component.ts`中添加以下导入：
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We are importing `HttpClient`, which contains the `JSONP` methods we will be
    using, as well as the RxJS `Observable` and the `map ` operator. These imports
    will look familiar to you from what we have been building in this chapter.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了`HttpClient`，其中包含我们将要使用的`JSONP`方法，以及RxJS的`Observable`和`map`运算符。这些导入对你来说应该是很熟悉的，因为我们在这一章中已经基于它们构建了一些内容。
- en: As you work with Angular JSONP, it is important to understand that by default,
    it returns Observables using RxJS. This means that we will have to follow the
    pattern for subscribing to those Observables and use the RxJS operators to manipulate
    the results. We can also use the async pipe to streamline these operations.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Angular JSONP时，重要的是要理解，默认情况下，它返回使用RxJS的Observables。这意味着我们将不得不遵循订阅这些Observables的模式，并使用RxJS运算符来操纵结果。我们也可以使用异步管道来简化这些操作。
- en: 'Then we inject `HttpClient` into the constructor:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将`HttpClient`注入到构造函数中：
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next we add several variables that we will be using in our JSONP call:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加几个我们将在JSONP调用中使用的变量：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `symbol` variable will hold the search string provided by the user. The
    `quote` variable will be used in our template to display the returned value from
    the JSONP call. And the `url` variable is the base URL for the call we will be
    making to the service.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`symbol`变量将保存用户提供的搜索字符串。`quote`变量将用于我们的模板来显示JSONP调用返回的值。而`url`变量是我们将要向服务进行的调用的基本URL。'
- en: 'Now we have everything in place for our `getQuote` method. Let''s take a look
    at it:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好我们的`getQuote`方法了。让我们来看一下：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We first construct our `searchUrl` by concatenating the `url` with the `symbol`
    and adding `/quote`. The last part `quote` is what we need to pass to the quote
    service to return a stock quote.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将`url`与`symbol`连接起来，并添加`/quote`来构建我们的`searchUrl`。最后部分的`quote`是我们需要传递给报价服务以返回股票报价的内容。
- en: We then use the HTTPClient's `jsonp` method to execute the remote call to the
    quote service. We pass the `searchUrl` as the first parameter of that method and
    a string `'callback'` as our second parameter. The latter parameter is used by
    Angular to augment the `searchUrl` with an extra query string parameter, `callback`.
    Internally, the Angular JSONP service then generates a dynamic `script` tag and
    a callback function and makes the remote request.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`HTTPClient`的`jsonp`方法来执行对报价服务的远程调用。我们将`searchUrl`作为该方法的第一个参数传递，将字符串`'callback'`作为我们的第二个参数。后者被Angular用于通过向`searchUrl`增加额外的查询字符串参数`callback`。在内部，Angular
    JSONP服务会生成一个动态的`script`标签和一个回调函数并进行远程请求。
- en: 'Open StackBlitz and enter symbols such as `GOOG`, `MSFT`, or `FB` to see the
    stock quote service in action. The browser network log for requests looks as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 StackBlitz 并输入诸如`GOOG`、`MSFT`或`FB`等股票代码以查看股票报价服务的操作。浏览器的网络日志请求如下所示：
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, `ng_jsonp_callback_0` is the dynamically generated function. And the
    response looks as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`ng_jsonp_callback_0`是动态生成的函数。响应如下所示：
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The response is wrapped in the callback function. Angular parses and evaluates
    this response, which results in the invocation of the `__ng_jsonp__.__req1` callback
    function. Then, this function internally routes the data to our function callback.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 响应被包裹在回调函数中。Angular解析并评估此响应，导致调用`__ng_jsonp__.__req1`回调函数。然后，此函数内部将数据路由到我们的函数回调。
- en: 'We hope this explains how JSONP works and what the underlying mechanism of
    a JSONP request is. However, JSONP has its limitations:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这解释了JSONP的工作原理和JSONP请求的基本机制。然而，JSONP有其局限性：
- en: First, we can make only `GET` requests (which is obvious as these requests originate
    due to script tags)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们只能进行`GET`请求（因为这些请求是由脚本标签生成的）
- en: Second, the server also needs to implement the part of the solution that involves
    wrapping the response in a function callback
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，服务器也需要实现涉及将响应包装在函数回调中的解决方案的部分
- en: Third, there is always a security risk involved, as JSONP depends on dynamic
    script generation and injection
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，由于JSONP依赖于动态脚本生成和注入，总是存在安全风险。
- en: Fourth, error handling is not reliable too because it is not easy to determine
    why a script load failed
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四，错误处理也不可靠，因为不容易确定为什么脚本加载失败
- en: Ultimately, we must recognize that JSONP is more of a workaround than a solution.
    As we move towards Web 2.0, where mashups become commonplace and more and more
    service providers decide to expose their API over the web, a far better solution/standard
    has emerged: CORS.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们必须认识到JSONP更像是一种变通方法而不是解决方案。随着我们迈向Web 2.0，混搭变得普遍，越来越多的服务提供商决定通过网络公开他们的API，一个更好的解决方案/标准出现了：CORS。
- en: Cross-origin resource sharing
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨域资源共享
- en: '**Cross-origin Resource Sharing** (**CORS**) provides a mechanism for the web
    server to support cross-site access control, allowing browsers to make cross-domain
    requests from scripts. With this standard, a consumer application (such as *Personal
    Trainer*) is allowed to make some types of requests, termed **simple requests**,
    without any special setup requirements. These simple requests are limited to `GET`,
    `POST` (with specific MIME types), and `HEAD`. All other types of requests are
    termed **complex requests**.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨域资源共享**（**CORS**）提供了一个机制，用于支持跨站点访问控制，允许浏览器从脚本中进行跨域请求。通过这个标准，消费端应用程序（如*私人教练*）被允许进行某些类型的请求，称为**简单请求**，而不需要任何特殊设置要求。这些简单请求限定为`GET`、`POST`（特定MIME类型）和`HEAD`。所有其他类型的请求被称为**复杂请求**。'
- en: For complex requests, CORS mandates that the request should be preceded by an
    HTTP `OPTIONS` request (also called a preflight request) that queries the server
    for HTTP methods allowed for cross-domain requests. And only on successful probing
    is the actual request made.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂请求，CORS规定请求应该由一个HTTP`OPTIONS`请求（也称为预检请求）开头，询问服务器允许用于跨域请求的HTTP方法。只有在成功探测后才进行实际请求。
- en: You can learn more about CORS from the MDN documentation available at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在MDN文档中了解更多关于CORS的信息，链接在[https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)。
- en: The best part about CORS is that the client does not have to make any adjustment
    as in the case of JSONP. The complete handshake mechanism is transparent to the
    calling code and our Angular `HTTPClient` calls work without a hitch.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: CORS最好的一点是，客户端无需像JSONP一样进行任何调整。整个握手机制对调用代码透明，我们的Angular`HTTPClient`调用无障碍运行。
- en: CORS requires configurations to be made on the server, and the MongoLab servers
    have already been configured to allow cross-domain requests. So the preceding
    `POST` and `PUT` requests that we made to the MongoLab to add and update `Exercise`
    and `Workout` documents all caused the preflight `OPTIONS` request.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: CORS需要在服务器上进行配置，MongoLab服务器已经配置为允许跨域请求。因此之前对MongoLab进行的`POST`和`PUT`请求用于添加和更新`练习`和`锻炼`文档都引起了预检请求`OPTIONS`。
- en: Handling workouts not found
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理未找到的锻炼
- en: You might recall that in [Chapter 2](4b0ad450-2a56-4c24-b431-116d7225a57e.xhtml),
    *Personal Trainer*, we created the `WorkoutResolver` to not only retrieve a workout
    prior to navigation to the `WorkoutComponent`, but also prevent navigation to
    that component if a non-existent workout was in the route parameters. Now we would
    like to augment this functionality by displaying an error message on the workouts
    screen, indicating that the workout was not found.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得在[第2章](4b0ad450-2a56-4c24-b431-116d7225a57e.xhtml)中，*个人教练*，我们创建了`WorkoutResolver`，不仅在导航到`WorkoutComponent`之前检索锻炼，还防止在路由参数中存在不存在的锻炼时导航到该组件。现在，我们想通过在锻炼屏幕上显示一个错误消息来增强此功能，指示找不到锻炼。
- en: 'In order to do this, we are going to modify `WorkoutResolver` so that it reroutes
    to the workouts screen if a workout is not found. To start, add the following
    child route to `WorkoutBuilderRoutingModule` (making sure it precedes the existing
    workouts route):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将修改`WorkoutResolver`，以便在找不到锻炼时重新路由到锻炼页面。首先，在`WorkoutBuilderRoutingModule`中添加以下子路由（确保在现有的锻炼路由之前）：
- en: '[PRE36]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, modify the `resolve` method in the `WorkoutResolver` to redirect to this
    route in the event that a workout is not found:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改`WorkoutResolver`中的`resolve`方法，在找不到锻炼时重定向到此路由：
- en: '[PRE37]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then add a `notFound` boolean set to `false` to the variables in the `Workouts`
    component:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`Workouts`组件的变量中添加一个名为`notFound`的布尔值，其值设为`false`：
- en: '[PRE38]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And, in the `ngOnInit` method of that component, add the following code to
    check for the `workout-not-found` path and set the `notFound` value to `true`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，在该组件的`ngOnInit`方法中，添加以下代码来检查`workout-not-found`路径并将`notFound`的值设为`true`：
- en: '[PRE39]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally in the `Workouts.component.html` template, add the following `div`
    tag above the workout list that will display if the `notFound` is set to `true`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Workouts.component.html`模板中，在锻炼列表上面添加以下`div`标签，如果`notFound`被设置为`true`则显示：
- en: '[PRE40]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we find `workout-not-found` in the path when a user is returned to the `Workouts`
    page, then this displays the following message on the screen:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在将用户返回到`Workouts`页面时，在路径中找到`workout-not-found`，那么屏幕上将显示以下消息：
- en: '![](img/fd1d8b39-7c56-46a0-9965-55fa568c53c4.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd1d8b39-7c56-46a0-9965-55fa568c53c4.png)'
- en: We have fixed routing failure for the Workout Builder page, but the exercise
    builder page is still pending. Again, we will leave it to you to fix it yourself.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为锻炼构建器页面修复了路由故障，但是还未修复锻炼构建器页面。再次，我们将留给你自己去修复它。
- en: Another major (and pending) implementation is fixing *7 Minute Workout*, as
    it currently caters to only one workout routine.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的（尚未实现的）工作是修复*7分钟锻炼*，因为它目前只适用于一个锻炼常规。
- en: Fixing the 7 Minute Workout app
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复 7 分钟锻炼应用程序
- en: As it stands now, the *7 Minute Workout* (or *Workout Runner*) app can play
    only one specific workout. It needs to be fixed to support the execution of any
    workout plan built using *Personal Trainer*. There is an obvious need to integrate
    these two solutions. We already have the groundwork done to commence this integration.
    We've got the shared model services and `WorkoutService` to load data, enough
    to get us started.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 目前*7分钟锻炼*（或*锻炼运行器*）程序只能播放一个特定的锻炼。它需要修复以支持使用*个人健身教练*构建的任何锻炼计划的执行。显然需要将这两种解决方案集成起来。我们已经做好了开始整合的准备工作。我们已经有了共享模型服务和`WorkoutService`来加载数据，这已经足够让我们开始了。
- en: 'Fixing *7 Minute Workout* and converting it into a generic *Workout Runner*
    roughly involves the following steps:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 修复*7分钟锻炼*并将其转换为通用的*锻炼运行器*大致涉及以下步骤：
- en: Removing the hardcoded workout and exercises used in *7 Minute Workout*.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除*7分钟锻炼*中使用的硬编码锻炼和练习。
- en: Fixing the start page to show all available workouts and allowing users to select
    a workout to run.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复起始页面以显示所有可用的锻炼，并允许用户选择要进行的锻炼。
- en: Fixing the workout route configuration to pass the selected workout name as
    the route parameter to the workout page.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复锻炼的路由配置，将所选的锻炼名称作为路由参数传递到锻炼页面。
- en: Loading the selected workout data using `WorkoutService` and starting the workout.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`WorkoutService`加载所选的锻炼数据并开始锻炼。
- en: And, of course, we need to rename the *7 Minute Workout* part of the app; the
    name is now a misnomer. I think the complete app can be called *Personal Trainer*.
    We can remove all references to *7 Minute Workout* from the view as well.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，我们需要重新命名应用程序的*7分钟锻炼*部分；这个名字现在是一个误称。我认为整个应用程序可以称为*个人健身教练*。我们也可以从视图中删除对*7分钟锻炼*的所有引用。
- en: An excellent exercise to try out yourself! And that is why we are not going
    to walk you through the solution. Instead, go ahead and implement the solution.
    Compare your implementation with the one available at `checkpoint 5.4`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常好的练习！这就是为什么我们不会为你讲解解决方案。相反，前进并实施解决方案。将你的实现与`检查点 5.4`提供的实现进行比较。
- en: It's time to end the chapter and summarize your learning.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候结束本章并总结你所学到的知识了。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We now have an app that can do a lot of stuff. It can run workouts, load workouts,
    save and update them, and track history. And if we look back, we have achieved
    this with minimal code. We bet that if we were to try this in standard jQuery
    or some other framework, it would require substantially more effort as compared
    to Angular.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以完成很多任务的应用程序。它可以运行锻炼，加载锻炼，保存和更新它们，并跟踪历史记录。回头看，我们以最少的代码实现了这一切。我们敢打赌，如果我们试图在标准的jQuery或其他框架中实现这个功能，相比Angular，会需要大大更多的工作。
- en: We started the chapter by providing a *MongoDB* database on *MongoLab* servers.
    Since MongoLab provided a RESTful API to access the database, we saved some time
    by not setting up our own server infrastructure.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在*MongoLab*服务器上提供*MongoDB*数据库开始了本章。由于MongoLab提供了访问数据库的RESTful API，我们节省了一些时间，因为不需要设置自己的服务器基础架构。
- en: The first Angular construct that we touched upon was the `HTTPClient`, which
    is the primary service for connecting to any HTTP backend.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先接触到的Angular构造是`HTTPClient`，这是连接到任何HTTP后端的主要服务。
- en: You also learned how the `HTTPClient` module uses Observables. For the first
    time, in this chapter, we created our own Observable and explained how to create
    subscriptions to those Observables.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学会了`HTTPClient`模块如何使用Observables。在本章中，我们首次创建了自己的Observable，并解释了如何订阅这些Observables。
- en: We fixed our *Personal Trainer* app so that it uses the `HTTPClient` module
    to load and save workout data (note that data persistence for exercises is left
    for you to complete). In the process, you also learned about issues surrounding
    cross-domain resource access. You learned about JSONP, a workaround to circumvent
    a browser's *same-origin* restrictions, and how to issue JSONP requests using
    Angular. We also touched upon CORS, which has emerged as a standard when it comes
    to cross-domain communication.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修复了*个人健身教练*应用程序，使其使用`HTTPClient`模块来加载和保存锻炼数据（请注意，关于锻炼数据的持久化留给您来完成）。在此过程中，您还了解了与跨域资源访问相关的问题。您学到了JSONP，这是一个绕过浏览器*同源*限制的解决方法，以及如何使用Angular发出JSONP请求。我们还涉及了CORS，这已经成为跨域通信的标准。
- en: 'We have now covered most of the building blocks of Angular, except the big
    one: Angular directives. We have used directives everywhere, but have not created
    one. The next chapter is exclusively dedicated to Angular directives. We will
    be creating a number of small directives, such as a remote validator, AJAX button,
    and a validation cues directive for the *Workout Builder* app.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了大部分Angular的构建模块，除了一个重要模块：Angular指令。我们在各处使用了指令，但还没有创建一个。下一章将专门讲解Angular指令。我们将创建许多小指令，例如远程验证器、AJAX按钮，以及*健身建造者*应用程序的验证提示指令。
