- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making Your Components Look Beautiful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our journey into React best practices and design patterns has now reached the
    point where we want to make our components look beautiful. To do that, we will
    go through all the reasons why regular CSS may not be the best approach for styling
    components, and we will check out various alternative solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with inline styles, then CSS modules, and `styled-components`, this
    chapter will guide you through the magical world of CSS in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Common problems with regular CSS at scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What it means to use inline styles in React and their downsides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up a project from scratch using Webpack and CSS modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Features of CSS modules and why they represent a great solution to avoid global
    CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`styled-components`, a new library that offers a modern approach to styling
    React components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 19+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter in the book’s GitHub repository: [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter06).'
  prefs: []
  type: TYPE_NORMAL
- en: CSS in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In November 2014, Christopher Chedeau, also known as *vjeux*, gave a talk at
    the NationJS conference ([https://blog.vjeux.com/2014/javascript/react-css-in-js-nationjs.xhtml](https://blog.vjeux.com/2014/javascript/react-css-in-js-nationjs.xhtml))
    that sparked a revolution in the way React components are styled. As a contributor
    to React and an employee of Meta, Christopher outlined the many issues Facebook
    faced with CSS at scale. Understanding these issues is important because they
    are common in web development and will help us introduce concepts such as inline
    styles and locally scoped class names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of the issues with CSS, which are basically problems
    with CSS at scale:'
  prefs: []
  type: TYPE_NORMAL
- en: Global namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dead code elimination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-deterministic resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first well-known problem of CSS is that all the selectors are global. No
    matter how organized our styles are by using namespaces or a procedure such as
    the **Block**, **Element**, **Modifier** (**BEM**) methodology, we are always
    polluting the global namespace, which we all know is wrong. It is not only wrong
    in principle, but it also leads to many errors in big code bases, and it makes
    maintainability very hard in the long term. Working with big teams, it is non-trivial
    to know whether a particular class or element has already been styled, and most
    of the time, we tend to add more classes instead of reusing existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem with CSS regards the definition of the dependencies. It is
    very hard, in fact, to state clearly that a particular component depends on a
    specific CSS and that the CSS has to be loaded for the style to be applied. Since
    styles are global, any style from any file can be applied to any element, and
    losing control is very easy.
  prefs: []
  type: TYPE_NORMAL
- en: The third is that frontend developers tend to use pre-processors to be able
    to split their CSS into submodules, but in the end, a big, global CSS bundle is
    generated for the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Since CSS code bases tend to become huge quickly, we lose control over them,
    and the third problem is to do with **dead code elimination**. It is not easy
    to quickly identify which styles belong to which component, and this makes deleting
    code incredibly hard. In fact, due to the cascading nature of CSS, removing a
    selector or a rule can result in an unintended result within the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Another pain point of working with CSS concerns the minification of the selectors
    and the class names, both in the CSS and in the JavaScript application. It might
    seem an easy task, but it is not, especially when classes are applied on the fly
    or concatenated in the client; this is the fourth problem.
  prefs: []
  type: TYPE_NORMAL
- en: Not being able to minify and optimize class names is bad for performance, and
    it can make a huge difference to the size of the CSS. Another pretty common operation
    that is non-trivial with regular CSS is sharing constants between the styles and
    the client application. We often need to know the height of a header, for example,
    to recalculate the position of other elements that depend on it.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we read the value in the client using the JavaScript APIs, but the
    optimal solution would be to share constants and avoid doing expensive calculations
    at runtime. This represents the fifth problem that `vjeux` and the other developers
    at Facebook tried to solve.
  prefs: []
  type: TYPE_NORMAL
- en: The sixth issue concerns the non-deterministic resolution of CSS. In fact, in
    CSS, the order matters, and if the CSS is loaded on demand, the order is not guaranteed,
    which leads to the wrong styles being applied to the elements.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose, for example, that we want to optimize the way we request CSS, loading
    the CSS related to a particular page only when the users navigate to it. If the
    CSS related to this last page has some rules that also apply to the elements of
    different pages, the fact that it has been loaded last could affect the styling
    of the rest of the app. For example, if the user goes back to the previous page,
    they might see a page with a UI that is slightly different than the first time
    they visited it.
  prefs: []
  type: TYPE_NORMAL
- en: It is incredibly hard to control all the various combinations of styles, rules,
    and navigation paths, but again, being able to load the CSS when needed could
    have a critical impact on the performance of a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, the seventh problem of CSS, according to Christopher Chedeau,
    is related to isolation. In CSS, it is almost impossible to achieve proper isolation
    between files or components. Selectors are global, and they can easily be overwritten.
    It is tricky to predict the final style of an element just by knowing the class
    names applied to it because styles are not isolated, and other rules in other
    parts of the application can affect unrelated elements. This can be solved by
    using inline styles.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will look at what it means to use inline styles
    with React and the benefits and downsides of it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and implementing inline styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official React documentation suggests developers use **inline styles** to
    style their React components. This seems odd because we all learned in past years
    that separating the concerns is important and we should not mix markup and CSS.
  prefs: []
  type: TYPE_NORMAL
- en: React tries to change the concept of separation of concerns by moving it from
    the separation of technologies to the separation of components. Separating markup,
    styling, and logic into different files when they are tightly coupled and where
    one cannot work without the other is just an illusion. Even if it helps keep the
    project structure cleaner, it does not give any real benefit.
  prefs: []
  type: TYPE_NORMAL
- en: In React, we compose components to create applications where components are
    a fundamental unit of our structure. We should be able to move components across
    the application, and they should provide the same result regarding both logic
    and UI, no matter where they get rendered.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the reasons why collocating the styles within our components
    and applying them using inline styles on the elements could make sense in React.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at an example of what it means to use the `style` attribute
    of the nodes to apply the styling to our components in React. We are going to
    create a button with the text `Click me!` and we are going to apply a color and
    background color to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is pretty easy to style elements with inline styles in React.
    We just have to create an object where the attributes are the CSS rules, and the
    values are the values we would use in a regular CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: The only differences are that the hyphenated CSS rules must be `camelCased`
    to be JavaScript-compliant, and the values are strings, so they have to be wrapped
    in quote marks.
  prefs: []
  type: TYPE_NORMAL
- en: There are some exceptions regarding the vendor prefixes. For example, if we
    want to define a transition on `webkit`, we should use the `WebkitTransition`
    attribute, where the `webkit` prefix begins with a capital letter. This rule applies
    to all the vendor prefixes, except for `ms`, which is lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: Other use cases are numbers – they can be written without quotes or units of
    measurement, and by default, they are treated as pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following rule applies a height of 100 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By using inline styles, we can also do things that are hard to implement with
    regular CSS. For example, we can recalculate some CSS values on the client at
    runtime, which is a very powerful concept, as you will see in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you want to create a form field in which the font size changes according
    to its value. So, if the value of the field is `24`, the font size is going to
    be 24 pixels. With normal CSS, this behavior is almost impossible to reproduce
    without putting in a huge effort and duplicated code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at how easy it is to use inline styles instead, by creating a `FontSize`
    component first and then declaring a value state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement a simple change handler, where we use the target attribute of
    the event to retrieve the current value of the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we render the input file of the number type, which is a controlled
    component because we keep its value updated by using the state. It also has an
    event handler, which is fired every time the value of the field changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, we use the `style` attribute of the field to set its font-size
    value. As you can see, we are using the `camelCased` version of the CSS rule to
    follow the React convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Rendering the preceding component, we can see an input field that changes its
    font size according to its value. The way it works is that when the value changes,
    we store the new value of the field inside the state. Modifying the state forces
    the component to re-render, and we use the new state value to set the display
    value of the field and its font size; it’s easy and powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Every solution in computer science has its downsides, and it always represents
    a trade-off. In the case of inline styles, unfortunately, the problems are many.
  prefs: []
  type: TYPE_NORMAL
- en: For example, with inline styles, it is not possible to use pseudo-selectors
    (for example, `:hover`) and pseudo-elements, which is a pretty significant limitation
    if you are creating a UI with interactions and animations.
  prefs: []
  type: TYPE_NORMAL
- en: There are some workarounds, and, for example, you can always create real elements
    instead of pseudo-elements, but for the pseudo-classes, it is necessary to use
    JavaScript to simulate the CSS behavior, which is not optimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same applies to **media queries**, which cannot be defined using inline
    styles, and it makes it harder to create responsive web applications. Since styles
    are declared using JavaScript objects, it is also not possible to use `style`
    fallbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript objects cannot have two attributes with the same name. Style fallbacks
    should be avoided, but it is always good to have the ability to use them if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Another feature of CSS that it is not possible to emulate using inline styles
    is **animations**. The workaround here is to define animations globally and use
    them inside the style attribute of the elements. With inline styles, whenever
    we need to override a style with regular CSS, we are always forced to use the
    `!important` keyword, which is bad practice because it prevents any other style
    from being applied to the element.
  prefs: []
  type: TYPE_NORMAL
- en: The most difficult thing that happens to work with inline styles is debugging.
    We tend to use class names to find elements in the browser DevTools to debug and
    check which styles have been applied. With inline styles, all the styles of the
    items are listed in their `style` attribute, which makes it very hard to check
    and debug the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the button that we created earlier in this section is rendered
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By itself, it does not seem very hard to read, but if you imagine you have hundreds
    of elements and hundreds of styles, you realize that the problem becomes very
    complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you are debugging a list where every single item has the same `style`
    attribute, and if you modify one on the fly to check the result in the browser,
    you will see that you are applying the styles only to it and not to all the other
    siblings, even if they share the same style.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, if we render our application on the server side (we will
    cover this topic in *Chapter 12*, *Server-Side Rendering*), the size of the page
    is bigger when using inline styles.
  prefs: []
  type: TYPE_NORMAL
- en: With inline styles, we are putting all the content of the CSS into the markup,
    which adds an extra number of bytes to the file that we send to the clients and
    makes the web application appear slower. Compression algorithms can help with
    that because they can easily compress similar patterns, and, in some cases, loading
    the critical path CSS is a good solution; but in general, we should try to avoid
    it.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that inline styles cause more problems than the problems they try
    to solve. For this reason, the community created different tools to solve the
    problems of inline styles but keeping the styles inside the components, or local
    to the components, to get the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: After Christopher Chedeau’s talk, a lot of developers started talking about
    inline styles, and many solutions and experiments have been made to find new ways
    of writing CSS in JavaScript. In the beginning, there were two or three solutions,
    while today there are more than 40.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how to use the CSS modules.
  prefs: []
  type: TYPE_NORMAL
- en: Using CSS modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you feel that inline styles are not a suitable solution for your project
    and your team, but you still want to keep the styles as close as possible to your
    components, there is a solution for you, called **CSS modules**. The CSS modules
    are CSS files in which all class names and animation names are scoped locally
    by default. Let’s see how we can use them in our projects; but first, we need
    to configure **webpack**.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into CSS modules and learning how they work, it is important to
    understand how they were created and the tools that support them.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 3*, *Cleaning Up Your Code*, we looked at how we can write ES6 code
    and transpile it by using Babel and its presets. As soon as the application grows,
    you may want to split your code base into modules as well.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Webpack or Browserify to divide the application into small modules
    that you can import whenever you need them, while still creating a big bundle
    for the browser. These tools are called **module bundlers**, and what they do
    is load all the dependencies of your application into a single bundle that can
    be executed in the browser, which does not have any concept of modules (yet).
  prefs: []
  type: TYPE_NORMAL
- en: In the React world, Webpack is especially popular because it offers many interesting
    and useful features, with the first one being the concept of loaders. With Webpack,
    you can potentially load any dependencies other than JavaScript, if there is a
    loader for them. For example, you can load JSON files, as well as images and other
    assets, inside the bundle.
  prefs: []
  type: TYPE_NORMAL
- en: In May 2015, Mark Dalgleish, one of the creators of CSS modules, figured out
    that you could import CSS inside a Webpack bundle as well, and he pushed the concept
    forward. He thought that, since the CSS could be imported locally into a component,
    all the imported class names could be locally scoped as well, this is great because
    this will isolate the styles.
  prefs: []
  type: TYPE_NORMAL
- en: After tracing the conceptual evolution of locally scoped CSS by one of its pioneers,
    Mark Dalgleish, and understanding how it revolutionized style isolation in Webpack
    bundles, let us transition into a more practical arena. The next section will
    guide us in setting up a project that utilizes these principles.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at how to set up a very simple Webpack application,
    using Babel to transpile the JavaScript and CSS modules to load our locally scoped
    CSS into the bundle. We will also go through all the features of CSS modules and
    look at the problems they can solve. The first thing to do is move to an empty
    folder and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will create a `package.json` file with some defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to install the dependencies, with the first one being Webpack
    and the second being `webpack-dev-server`, which we will use to run the application
    locally and to create the bundle on the fly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Webpack is installed, it is time to install Babel and its loader. Since
    we are using Webpack to create the bundle, we will use the Babel loader to transpile
    our ES6 code within Webpack itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we install `style-loader` and the CSS loader, which are the two loaders
    we need to enable the CSS modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one more thing to do to make things easier, and that is to install
    `html-webpack-plugin`, which is a plugin that can create an HTML page to host
    our JavaScript application on the fly, just by looking into the Webpack configuration
    and without us needing to create a regular file. Also, we need to install the
    `fork-ts-checker-webpack-plugin` package to make TypeScript work with Webpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, we install `react` and `react-dom` to use them in our simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that all the dependencies are installed, it is time to configure everything
    to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to create a `.babelrc` file in your root path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to do is add an npm script in `package.json` to run the `webpack-dev-server`,
    which will serve the application in development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In Webpack 5, you need to use this way to call webpack instead of `webpack-dev-server`
    but you still need to have this package installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Webpack needs a configuration file to know how to handle the different types
    of dependencies we are using in our application, and to do so, we must create
    a file called `webpack.config.ts`, which exports an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The object we export represents the configuration object used by Webpack to
    create the bundle, and it can have different properties depending on the size
    and the features of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to keep our example very simple, so we are going to add three attributes.
    The first one is `entry`, which tells Webpack where the main file of our application
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one is `module`, which is where we tell Webpack how to load the
    external dependencies. It has an attribute called `rules`, where we set a specific
    loader for each one of the file types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We are saying that the files that match the `.ts` or `.tsx` regular expression
    are loaded using `ts-loader` so that they get transpiled and loaded into the bundle.
  prefs: []
  type: TYPE_NORMAL
- en: You may also have noticed that we added our presets in the `.babelrc` file.
    As we saw in *Chapter 3*, *Cleaning Up Your Code*, the presets are sets of configuration
    options that instruct Babel on how to deal with the different types of syntax
    (for example, TSX).
  prefs: []
  type: TYPE_NORMAL
- en: The second entry in the `rules` array tells Webpack what to do when a CSS file
    is imported, and it uses `css-loader` with the `modules` flag enabled to activate
    **CSS modules**. The result of the transformation is then passed to `style-loader`,
    which injects the styles into the header of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we enable the HTML plugin to generate the page for us, adding the
    script tag automatically using the `entry` path we specified earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete `webpack.config.ts` should be as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to configure TypeScript, you need this `tsconfig.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to import CSS files using TypeScript, you need to create a declarations
    file at `src/declarations.d.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to create the main file at `src/index.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you need to create the initial HTML file at `src/index.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We are done, and if we run the `npm run dev` command in the terminal and point
    the browser to `http://localhost:8080`, we should be able to see the following
    markup being served:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Perfect – our React application is working! Let’s see now how we can add some
    CSS to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Locally scoped CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it is time to create our app, which will consist of a simple button of the
    same sort we used in previous examples. We will use it to show all the features
    of the CSS modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the `src/index.tsx` file, which is the entry we specified in the
    Webpack configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create a simple button. As usual, we are going to start with a
    non-styled button, and we will add the styles step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can render the button into the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose we want to apply some styles to the button – a background color,
    size, and so on. We create a regular CSS file, called `index.css`, and we put
    the following class into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, we said that with CSS modules we could import the CSS files into JavaScript;
    let’s look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our `index.ts` file where we defined the `button` component, we can
    add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The result of this `import` statement is a `styles` object, where all the attributes
    are the classes defined in `index.css`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run `console.log(styles)`, we can see the following object in the `DevTools`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: So, we have an object where the attributes are the class names and the values
    are (apparently) random strings. We will see later that they are non-random, but
    let’s check what we can do with that object first.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the object to set the class name attribute of our button, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go back to the browser, we can now see that the styles we defined in
    `index.css` have been applied to the button. This is not magic, because if we
    check in `DevTools`, the class that has been applied to the element is the same
    string that’s attached to the `style` object we imported inside our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the header section of the page, we can now see that the same
    class name has also been injected into the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is how the CSS and the style loaders work. The CSS loader lets you import
    the CSS files into your JavaScript modules and, when the `module` flag is activated,
    all the class names are locally scoped to the module they are imported into.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, the string we imported was non-random, but it is
    generated using the hash of the file and some other parameters in a way that is
    unique within the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `style-loader` takes the result of the CSS module’s transformation
    and injects the styles inside the header section of the page. This is very powerful
    because we have the full power and expressiveness of the CSS, combined with the
    advantages of having locally scoped class names and explicit dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the beginning of this chapter, CSS is global, and that makes
    it very hard to maintain in large applications. With CSS modules, class names
    are locally scoped, and they cannot clash with other class names in different
    parts of the application, enforcing a deterministic result.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, explicitly importing the CSS dependencies inside our components helps
    us see clearly which components need which CSS. It is also very useful for eliminating
    dead code because when we delete a component for any reason, we can tell exactly
    which CSS it was using.
  prefs: []
  type: TYPE_NORMAL
- en: CSS modules are regular CSS, so we can use pseudo-classes, media queries, and
    animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can add CSS rules such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be transformed into the following code and injected into the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The class names get created and they get replaced everywhere the button is used,
    making it reliable and local, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, those class names are great, but they make debugging
    pretty hard because we cannot easily tell which classes generated the hash. What
    we can do in development mode is add a special configuration parameter, with which
    we can choose the pattern that’s used to produce the scoped class names.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can change the value of the loader as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, `localIdentName` is the parameter, and `[local]` and `[hash:base64:5]`
    are placeholders for the original class name value and a five-character hash.
    Other available placeholders are `[path]`, which represents the path of the CSS
    file, and `[name]`, which is the name of the source CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activating the previous configuration option, the result we have in the browser
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is way more readable and easier to debug.
  prefs: []
  type: TYPE_NORMAL
- en: In production, we do not need class names like this, and we are more interested
    in performance, so we may want shorter class names and hashes.
  prefs: []
  type: TYPE_NORMAL
- en: With Webpack, it is pretty straightforward because we can have multiple configuration
    files that can be used in the different stages of our application life cycle.
    Also, in production, we may want to extract the CSS file instead of injecting
    it into the browser from the bundle so that we can have a lighter bundle and cache
    the CSS on a **Content Delivery Network** (**CDN**) for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, you need to install another Webpack plugin, called `mini-css-extract-plugin`,
    which can write an actual CSS file, putting in all the scoped classes that were
    generated from CSS modules.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of features of CSS modules that are worth mentioning.
  prefs: []
  type: TYPE_NORMAL
- en: The first one is the `global` keyword. Prefixing any class with `:global`, in
    fact, means asking CSS modules not to scope the current selector locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say we change our CSS as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is good if you want to apply styles that cannot be scoped locally, such
    as third-party widgets.
  prefs: []
  type: TYPE_NORMAL
- en: My favorite feature of CSS modules is **composition**. With composition, we
    can extract classes from the same file or external dependencies and get all the
    styles applied to the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, extract the rule to set the background to red from the rules for
    the button into a separate block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then compose it inside our button in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The result is that all the rules of the button and all the rules of the `composes`
    declaration are applied to the element.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very powerful feature, and it works in a fascinating way. You might
    expect that all the composed classes are duplicated inside the classes where they
    are referenced as **SASS @extend** does, but that is not the case. Simply put,
    all the composed class names are applied one after the other on the component
    in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our specific case, we would have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the CSS that is injected into the page is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our CSS class names have unique names, which is good to isolate
    our styles. Now, let’s take a look at the Atomic CSS modules.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic CSS modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It should be clear how composition works and why it is a very powerful feature
    of CSS modules. At Disney, the company where I worked when I started writing this
    book, we tried to push it a step further, combining the power of composes with
    the flexibility of **Atomic CSS** (also known as **Functional CSS**).
  prefs: []
  type: TYPE_NORMAL
- en: Atomic CSS is a way to use CSS where every class has a single rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can create a class to set `margin-bottom` to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use another one to set `font-weight` to `600`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can apply all those Atomic classes to the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This technique is controversial and particularly efficient at the same time.
    It is hard to start using it because you end up having too many classes in your
    markup, which makes it hard to predict the final result. If you think about it,
    it is pretty similar to inline styles, because you apply one class per rule, apart
    from the fact that you are using a shorter class name as a proxy.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest argument against Atomic CSS is usually that you are moving the styling
    logic from the CSS to the markup, which is wrong. Classes are defined in CSS files,
    but they are composed in the views, and every time you have to modify the style
    of an element, you end up editing the markup.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we tried using Atomic CSS for a bit and we found that it
    makes prototyping incredibly fast.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, when all the base rules have been generated, applying those classes
    to the elements and creating new styles is a very quick process, which is good.
    Second, using Atomic CSS, we can control the size of the CSS file, because as
    soon as we create new components with their styles, we are using existing classes
    and we do not need to create new ones, which is great for performance.
  prefs: []
  type: TYPE_NORMAL
- en: So, we tried to solve the problems of Atomic CSS using CSS modules and we called
    the technique **Atomic CSS modules**.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, you start creating your base CSS classes (for example, `mb0`), and
    then, instead of applying the class names one by one in the markup, you compose
    them into placeholder classes using CSS modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is great because you still keep the styling logic inside the CSS, and the
    CSS module’s `composes` does the job for you by applying all the single classes
    in the markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, `title`, `mb0`, and `fw6` are all applied automatically to the element.
    They are scoped locally as well, so we have all the advantages of CSS modules.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing styled-components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a library that is very promising because it takes into account all
    the problems other libraries have encountered in styling components. Different
    paths have been followed for writing CSS in JavaScript, and many solutions have
    been tried, so now the time is ripe for a library that takes all the learning
    and then builds something on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library is conceived and maintained by two popular developers in the JavaScript
    community: *Glenn Maddern* and *Max Stoiber*. It represents a very modern approach
    to the problem, and it uses the edge features of ES2015 and some advanced techniques
    that have been applied to React to provide a complete solution for styling.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how it is possible to create the same button we saw in the previous
    sections and check whether all the CSS features we are interested in (for example,
    pseudo-classes and media queries) work with `styled-components`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to install the library by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the library is installed, we have to import it inside our component’s
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: At that point, we can use the styled function to create any element by using
    `styled.elementName`, where `elementName` can be a div, a button, or any other
    valid DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to do is to define the style of the element we are creating
    and, to do so, we use an ES6 feature called **tagged template literals**, which
    is a way of passing template strings to a function without them being interpolated
    beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the function receives the actual template with all the JavaScript
    expressions, and this makes the library able to use the full power of JavaScript
    to apply the styles to the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a simple button with a basic styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This *kind-of-weird* syntax returns a proper React component called `Button`,
    which renders a `button` element and applies to it all the styles defined in the
    template. The way the styles are applied is by creating a unique class name, adding
    it to the element, and then injecting the corresponding style in the head of the
    document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the component that gets rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The style that gets added to the page is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The good thing about `styled-components` is that it supports almost all the
    features of CSS, which makes it a good candidate to be used in a real-world application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, it supports pseudo-classes using a SASS-like syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'It also supports media queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: There are many other features that this library can bring to your project.
  prefs: []
  type: TYPE_NORMAL
- en: For example, once you have created the button, you can easily override its styles
    and use it multiple times with different properties. Inside the templates, it
    is also possible to use the props that the component received and change the style
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Another great feature is **theming**. By wrapping your components in a `ThemeProvider`
    component, you can inject a `theme` property down to the three component’s children,
    which makes it extremely easy to create UIs where part of the style is shared
    between components and some other properties depend on the currently selected
    theme.
  prefs: []
  type: TYPE_NORMAL
- en: Without a doubt, the `styled-components` library is a game-changer when you
    are taking your styles to the next level. In the beginning, it could seem weird
    because it involves implementing styles with components, but once you get used
    to it, I guarantee it will be your favorite styles package.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored important topics that aim to help readers navigate
    the complexities of styling in React. We discussed the challenges of scaling CSS,
    using Meta’s experiences as examples to highlight the real-world difficulties
    faced by large organizations. This emphasizes the relevance and applicability
    of the knowledge we’re sharing.
  prefs: []
  type: TYPE_NORMAL
- en: To make styling in React more intuitive and efficient, we examined how inline
    styles work and the benefits of co-locating styles within components. This approach
    promotes organized and readable code, which is crucial for developers aiming to
    master React.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing the limitations of inline styles, we introduced CSS modules as an
    alternative. We provided a step-by-step guide to setting up a project, allowing
    readers to learn through hands-on experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: Importing CSS files into components was also emphasized as an important practice.
    This helps clarify dependencies and prevents issues by keeping class names scoped
    locally, ensuring scalable and conflict-free code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we introduced readers to `styled-components`, a library that aligns
    with our book’s goal of offering innovative ways to style components and optimize
    development practices in React.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have explored various approaches to managing CSS styles in React,
    each illustrating different aspects of our central proposition. In the next chapter,
    we will further enhance your understanding of React by delving into the practical
    implementation and benefits of server-side rendering—a technique that improves
    application performance and user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/React18DesignPatterns4e](https://packt.link/React18DesignPatterns4e)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2450023176943770109.png)'
  prefs: []
  type: TYPE_IMG
