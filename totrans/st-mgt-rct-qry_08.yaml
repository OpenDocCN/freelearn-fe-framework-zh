- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Testing React Query Hooks and Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试React Query钩子和组件
- en: You have almost mastered React Query! By now, you are well aware of how queries
    and mutations work and are ready to leverage React Query in a server-side, rendered
    project as well. Now, we’ll look at the last skill you need to be a full-on React
    Query hero – testing React Query using code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎已经掌握了React Query！到目前为止，你已经非常清楚查询和突变是如何工作的，并且准备好在服务器端渲染的项目中利用React Query。现在，我们将探讨你需要成为真正的React
    Query英雄的最后一种技能——使用代码测试React Query。
- en: This chapter will teach you how to test your `useQuery` and `useMutation` using
    components and hooks. But before that, you will get to know a super useful library
    to help you test your React Query code called Mock Service Worker.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何使用组件和钩子测试`useQuery`和`useMutation`。但在那之前，你将了解一个非常有用的库，它可以帮助你测试React Query代码，称为Mock
    Service Worker。
- en: You will then learn some restructuring tips and tricks you can leverage to make
    your React Query code more readable and reusable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将学习一些重构技巧和窍门，你可以利用它们使你的React Query代码更易于阅读和重用。
- en: With this knowledge, you can start testing your code. You will start with testing
    your components that leverage React Query and see what testing from a user-centric
    approach looks like for queries and mutations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了这些知识之后，你就可以开始测试你的代码了。你将从测试利用React Query的组件开始，看看从以用户为中心的角度进行查询和突变测试是什么样的。
- en: Finally, we will dive into implementation details and see when and how we should
    test our hooks that use React Query.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将深入了解实现细节，看看我们应该何时以及如何测试使用React Query的钩子。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Configuring Mock Service Worker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Mock Service Worker
- en: Organizing code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码组织
- en: Testing components that use React Query
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试使用React Query的组件
- en: Testing custom hooks that use React Query
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试使用React Query的自定义钩子
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_8](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_8).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到，地址为[https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_8](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_8)。
- en: Configuring Mock Service Worker
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Mock Service Worker
- en: 'When testing React applications, one question often asked is how to test API
    calls. This question often leads to a follow-up question: “*How can I make sure
    my network requests return the data I expect so that my tests always receive the
    same data and don’t become flaky?*” There are many ways to answer these questions,
    and many implementations we can follow. The most common implementation often leveraged
    is mocking your data-fetching clients.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试React应用程序时，人们经常问的一个问题是如何测试API调用。这个问题通常会导致一个后续问题：“*我如何确保我的网络请求返回我期望的数据，以便我的测试总是接收到相同的数据，不会变得不可靠？*”有许多方法可以回答这些问题，我们可以遵循许多实现。最常用的实现通常是模拟你的数据获取客户端。
- en: While this approach works, one thing that I’ve seen often in all the projects
    that I have worked on that followed this method is that the more tests you write,
    the more unmaintainable they become. This is due to the fact that mocking things
    such as `fetch` or `axios` comes with a lot of boilerplate code to take care of
    things such as different routes being hit, different responses for the same route,
    and cleaning up your client mocks to avoid tests leaking on each other. Let us
    not forget that if we use GraphQL and REST in the same application, we must mock
    an extra client, depending on the component you are testing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法可行，但我在我所参与的所有采用这种方法的项目中经常看到的一个问题是：你写的测试越多，它们就越难以维护。这是因为模拟像`fetch`或`axios`这样的东西需要大量的样板代码来处理不同路由被击中、同一路由的不同响应以及清理客户端模拟以避免测试相互泄漏等问题。我们不要忘记，如果我们在一个应用程序中使用GraphQL和REST，我们必须根据你正在测试的组件模拟额外的客户端。
- en: What if I told you there is an alternative you can use to intercept your network
    requests and return predefined data without having to mock any client? What if
    I told you this alternative supports REST and GraphQL? What if I told you that
    this alternative could also be used in your application to provide some dummy
    data for a route your backend team has not yet implemented? You can do all this
    with **Mock Service** **Worker** (**MSW**).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我告诉你有一个可以用来拦截你的网络请求并返回预定义数据而无需模拟任何客户端的替代方案，你会怎么想？如果我说这个替代方案支持 REST 和 GraphQL，你会怎么想？如果我说这个替代方案还可以用于你的应用程序，为你的后端团队尚未实现的某个路由提供一些模拟数据，你会怎么想？你可以用
    **Mock Service** **Worker** (**MSW**) 做到所有这些。
- en: 'As the MSW docs say: “*Mock Service Worker is an API mocking library that uses
    Service Worker API to intercept actual* *requests*” ([https://mswjs.io/docs/](https://mswjs.io/docs/)).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如 MSW 文档所述：“*Mock Service Worker 是一个使用 Service Worker API 来拦截实际* *请求* 的 API
    模拟库” ([https://mswjs.io/docs/](https://mswjs.io/docs/))。
- en: MSW leverages service workers to intercept requests on the network level and
    return some predefined data for that specific request. This means that just by
    having a defined API contract, you can return mocked data even before that endpoint
    exists. Also, leveraging this predefined data in your tests means you no longer
    need to mock `axios` or `fetch`. It is important to mention that service workers
    only work in the browser. In your tests, MSW uses a request interceptor library
    to allow you to reuse the same mock definitions you have in your browser.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: MSW 利用服务工作者在网络级别拦截请求，并为该特定请求返回一些预定义数据。这意味着，只要有一个定义好的 API 合同，你就可以在端点存在之前返回模拟数据。此外，利用这些预定义数据在你的测试中意味着你不再需要模拟
    `axios` 或 `fetch`。重要的是要提到，服务工作者仅在浏览器中工作。在你的测试中，MSW 使用请求拦截器库，允许你重用你在浏览器中已有的相同模拟定义。
- en: While leveraging MSW in the browser is super helpful, it sits outside this chapter’s
    scope. In this chapter, we will only use MSW in our tests.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 MSW 在浏览器中使用非常有帮助，但它超出了本章的范围。在本章中，我们只会使用 MSW 在我们的测试中。
- en: 'Here is how to add MSW to your project:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将 MSW 添加到你的项目的方法：
- en: 'If you are running npm in your project, run the following command:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在你的项目中运行 npm，请运行以下命令：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you are using Yarn, run the following command:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Yarn，请运行以下命令：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you are using pnpm, run the following command:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是 pnpm，请运行以下命令：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once MSW is installed, we must create our request handlers and response resolvers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 MSW 安装完成，我们必须创建我们的请求处理器和响应解析器。
- en: Request handlers allow you to specify the method, path, and response when handling
    a request. They are often paired with response resolvers. A response resolver
    is a function you pass to the request handler that allows you to specify the mocked
    response when intercepting a request.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请求处理器允许你在处理请求时指定方法、路径和响应。它们通常与响应解析器配对。响应解析器是一个传递给请求处理器的函数，它允许你在拦截请求时指定模拟的响应。
- en: Let us now create some handlers to handle some routes. Here is what we have
    to do.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在创建一些处理器来处理一些路由。以下是我们要做的事情。
- en: Inside the `src/mocks` folder, create a `handlers.js` file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/mocks` 文件夹中，创建一个 `handlers.js` 文件。
- en: 'In the `handlers.js` file, add the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `handlers.js` 文件中，添加以下代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding snippet, we do the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们做了以下操作：
- en: We import the `rest` namespace containing a set of request handlers to handle
    `REST` requests.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入包含一组请求处理器的 `rest` 命名空间，用于处理 `REST` 请求。
- en: We create a `handlers` array that will contain all of our request handlers.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个 `handlers` 数组，它将包含我们所有的请求处理器。
- en: The first mock we create is for a `GET` request to any route that contains `/api/`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的第一个模拟是一个针对包含 `/api/` 的任何路由的 `GET` 请求。
- en: When a request hits this request handler, it will return a response that will,
    in turn, return a `200 OK` response code with an object that, inside the `data`
    property, will include a `"value"` string .
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求击中这个请求处理器时，它将返回一个响应，该响应将返回一个包含 `"value"` 字符串的 `200 OK` 响应代码的对象。
- en: Now that we have created our `handlers`, we need to ensure that MSW will intercept
    our requests using our previously created `handlers`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的 `handlers`，我们需要确保 MSW 将使用我们之前创建的 `handlers` 来拦截我们的请求。
- en: This is what we have to do.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要做的事情。
- en: Inside the `src/mocks` folder, create a `server.js` file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/mocks` 文件夹中，创建一个 `server.js` 文件。
- en: 'In the `server.js` file, add the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `server.js` 文件中，添加以下代码：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding snippet, we leverage the `setupServer` function and our created
    `handlers` array to create an object responsible for intercepting our requests
    with our given `handlers`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created our server file, we need to ensure `Jest` uses them.
    To do this, inside our `setupTests.js` file, add the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is what we do in the preceding snippet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: We import our created `server` object.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We leverage the `beforeAll` global hook to ensure that MSW is intercepting our
    requests before any of our tests are executed.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then leverage the `afterEach` global hook so that after every single test,
    we reset our handlers. This considers a scenario where we add a custom handler
    for one of our tests so that they don’t leak into another test.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we leverage the `afterAll` global hook so that after all our tests
    run, we clean up and stop intercepting requests.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, any API requests made by our tests will be intercepted by MSW.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Before seeing how we can test our components and React Query using hooks, let
    us see a couple of patterns we can apply to make our code more structured and
    easier to test.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Organizing code
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many ways you can organize your code. Now, one thing we need to be
    aware of is choosing patterns that save you some time and make your code better
    in the long run. This section will discuss three different patterns that we can
    leverage together or independently to make our code more structured, readable,
    and organized. Here’s what we will discuss in this section:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Creating an API file
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging query key factories
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a hooks folder
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an API file
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating an API file to contain all my requests for a specific domain is a pattern
    that I follow.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: In this file, I leverage my API client and create the functions responsible
    to make a request to a given route and return the request data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: This is particularly useful because it avoids repeating the logic for the same
    request in your code and focuses all the domain-specific requests in the same
    file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: For all the requests made in the scope of this book, I would prefer to create
    a file for my user domain, given that the scope seems to be focused on users.
    So, inside our `api` folder, we will create a `userAPI.js` file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Adding userAPI.js to our API folder](img/Figure_8.1_B18501.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Adding userAPI.js to our API folder
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside that file, we can now move all of our requests inside our code. This
    is how it might look:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding snippet, we can see an example of a `userAPI` file containing
    our `axios` client instance, a `getUser` function (to fetch data from a given
    user), and a `createUser` function (to create a user).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this pattern improves the code reusability and readability in
    the components that end up using the functions from our API file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: One extra thing you can do that we didn’t do in the preceding snippet is add
    the specific logic from your query functions. This makes these functions more
    accessible in your application if you only use React Query. I prefer to keep my
    query functions and these API functions separated because I often use different
    query functions with the same API function. Still, it will improve your code readability
    if you choose to use it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging query key factories
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Managing query keys is often a nuisance. We forget which ones we have already
    used and need to go through most of our queries to remember them. This is where
    query key factories shine.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: A query key factory can be a single object that, inside each property, will
    include a function responsible for generating a query key. This way, you keep
    all your query keys in the same place and stop wasting time trying to remember
    them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what your query key factory can look like:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see from the preceding snippet, we create a `userKey` object, which
    will be our query key factory. In each property, we have a function that will
    be responsible for returning our query key.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Creating a hooks folder
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The name here also speaks for itself. One recommendation for organizing code
    I like to follow is creating a hooks folder.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: I like to create custom hooks in this folder that contain some of the queries
    and mutations I often repeat, or ones that end up having too much logic and impact
    my code readability. This makes it easier for me to test a specific hook in isolation
    and make the components that use them more readable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, remember when we performed optimistic updates in [*Chapter 6*](B18501_06.xhtml#_idTextAnchor159)?
    The `useMutation` hook we created is a great candidate to move to a custom hook.
    I will create a `useOptimisticUpdateUserCreation` custom hook and move my code
    in there. This is what that hook will look like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding snippet, we create the `useOptimisticUpdateUserCreation` hook
    and move the code from our `OptimisticMutation` component there. As you can also
    see from the code, we already applied our API file and query factory pattern.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'In the component using our hook, all we have to do now is import the hook and
    use it like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Applying all the patterns of this section, this is what your project structure
    can end up looking like:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – What the project structure may look like after following these
    three patterns](img/Figure_8.2_B18501.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – What the project structure may look like after following these
    three patterns
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen these patterns, let us finally move to start testing our
    code. We’ll start with one of the most recommended approaches – testing components
    using React Query hooks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Testing components that use React Query
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the React Testing Library was first introduced, it was under a main guiding
    principle that changed how we wrote tests going forward. That guiding principle
    is, “*The more your tests resemble the way your software is used, the more confidence
    they can give* *you*” ([https://testing-library.com/docs/guiding-principles/](https://testing-library.com/docs/guiding-principles/)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当 React Testing Library 首次推出时，它遵循一个主要指导原则，这个原则改变了我们编写测试的方式。这个指导原则是，“*你的测试越接近你的软件的使用方式，它们就能给你带来越多的信心*”
    ([https://testing-library.com/docs/guiding-principles/](https://testing-library.com/docs/guiding-principles/))。
- en: From that point on, many things changed in our tests. Focusing on a user-centric
    approach meant avoiding implementation details in our tests at all costs. This
    meant no more shallow rendering, no more state and prop references, and a more
    user-centric way of querying the DOM.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从那个点开始，我们的测试中发生了许多变化。专注于以用户为中心的方法意味着不惜一切代价避免在我们的测试中包含实现细节。这意味着不再有浅渲染，不再有状态和属性引用，以及更以用户为中心的查询
    DOM 的方式。
- en: Reading the last paragraph, you might be wondering how to test your components
    following a user-centric approach. Well, the answer is straightforward – a user
    doesn’t have to know the page they are using leverages React Query. If you write
    your tests like you are just using the page, this means that you will find issues
    that your user might find as well accidentally, and if for some reason you change
    your implementation, your tests won’t break.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读最后一部分，你可能想知道如何采用以用户为中心的方法来测试你的组件。嗯，答案很简单——用户不需要知道他们正在使用的页面是否使用了 React Query。如果你像使用页面一样编写测试，这意味着你可能会意外地发现用户可能会遇到的问题，并且如果由于某种原因你更改了实现，你的测试不会中断。
- en: There will be some scenarios where you might have to tie your tests to some
    implementation details to help you do some assertions, but we will try to avoid
    them at all costs in this section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，你可能需要将你的测试与某些实现细节绑定，以帮助你进行断言，但我们将不惜一切代价避免在本节中这样做。
- en: Before we start writing our tests, we need to do some setting up.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写测试之前，我们需要做一些设置。
- en: Setting up testing utils
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置测试工具
- en: When testing components that leverage React Query, we must ensure we wrap up
    those components with our `QueryClientProvider`. Now, we could create a custom
    wrapper for each test and wrap our component with it when rendering, but remember
    that you will most likely end up with many components that will use React Query
    in some way.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试利用 React Query 的组件时，我们必须确保我们用 `QueryClientProvider` 包裹这些组件。现在，我们可以在每个测试中创建一个自定义包装器，并在渲染时用它来包裹我们的组件，但请记住，你很可能会得到许多以某种方式使用
    React Query 的组件。
- en: This is where setting up some testing utils will help you. A pattern that I
    really like to follow is overwriting the `render` function from the testing library
    and wrapping every component that is rendered, using this function automatically
    with our React Query `QueryClientProvider`. To do that, I create a `test-utils.js`
    file inside a `utils` folder.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是设置一些测试工具可以帮助你的地方。我非常喜欢遵循的一个模式是覆盖测试库中的 `render` 函数，并使用这个函数自动包裹渲染的每个组件，使用我们的
    React Query `QueryClientProvider`。为此，我在 `utils` 文件夹中创建了一个 `test-utils.js` 文件。
- en: 'This is what we can add to our `test-utils.js` file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以在 `test-utils.js` 文件中添加的内容：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is what we do in the preceding snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们前面片段中做的事情：
- en: We import the `render` function from the React Testing Library.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从 React Testing Library 导入 `render` 函数。
- en: We import our `QueryClient` and our `QueryClientProvider` from React Query.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从 React Query 导入我们的 `QueryClient` 和 `QueryClientProvider`。
- en: 'We create a custom `render` function (`customRender`):'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个自定义的 `render` 函数 (`customRender`)：
- en: This function will receive a `ui` parameter, which will be the component we
    want to render. It will also receive an `options` object, which we can forward
    to the `render` function.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数将接收一个 `ui` 参数，它将是我们要渲染的组件。它还将接收一个 `options` 对象，我们可以将其转发给 `render` 函数。
- en: We create our `queryClient` instance. Here, we override our `logger` `error`
    property to avoid showing up errors from React Query. This is because we might
    want to test error scenarios, and we don’t want React Query to pollute our `console`
    with the errors we expect. We also define our queries to never attempt to retry
    a query after it fails, and we set our `cacheTime` to `Infinity` to avoid `Jest`
    error messages in scenarios where we manually set a `cacheTime` value.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a `CombinedProviders` wrapper that will be responsible for wrapping
    our components with our `QueryClientProvider`.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We call the React Testing Library `render` function, pass it the `ui` parameter,
    wrap it with our `CombinedProviders`, and send it the `options` we received.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We export all of the React Testing Library and our `customRender` function,
    which will now be the main `render` function. This means we now import this file
    instead of the React Testing Library in our tests.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note in the snippet that we create our `queryClient` inside the `customRender`
    function instead of outside it. You can follow this approach if you want to avoid
    having to clean up the query cache between tests. If you want to have the same
    `QueryClient` between tests, you can create the `queryClient` instance outside
    the function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Now that our `render` function is ready to render React Query using components,
    we can start writing tests.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Testing queries
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following subsections, we will see some common testing scenarios you
    might find in your day-to-day activities when using React Query.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether data is fetched
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most common tests we have to write is ensuring that our data was
    fetched properly. Let us start with this scenario and revisit our parallel queries
    example from [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140). We will also rewrite
    the code to adjust to some of the practices mentioned in this chapter. Let’s start
    by looking at our `ParallelQueries` component:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see from the preceding snippet, the code is pretty much the same
    as the one presented in [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140)*,* with
    the exception of the part where we fetch our data. Here, we applied one of the
    patterns mentioned in this chapter and moved this logic to a custom hook inside
    our custom hooks folder.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now look at what sits inside our `useMultipleQueriesV2` hook file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see from the preceding snippet, we basically just move what we had
    in our component to our `useMultipleQueriesV2` hook. Note also that we leverage
    the other two patterns we mentioned in this chapter:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: We create an entry inside the `userKeys` factory and leverage it to set our
    `useQueries` hook, `queryKey`
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create an API file to gather our user API functions and add our `getUser`
    function
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is what our `getUser` function looks like:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `getUser` function shown in this snippet is responsible for making a `GET`
    request for our given endpoint and aborting that request if our `signal` tells
    `axios` to do so.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中显示的`getUser`函数负责对我们的给定端点发起`GET`请求，并在我们的`signal`告诉`axios`这样做时取消该请求。
- en: Now that you are reacquainted with this component and how it works, let's start
    to test it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经重新熟悉了这个组件及其工作方式，让我们开始测试它。
- en: 'The first thing we need to do before we write our test is to make sure we have
    MSW intercepting the `GET` request and returning the data we want:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写测试之前，首先需要确保MSW正在拦截`GET`请求并返回我们想要的数据：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding snippet, we create a request handler to add to our `handlers`
    array, which does the following.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个请求处理器并将其添加到我们的`handlers`数组中，该处理器执行以下操作。
- en: Whenever we intercept a `GET` request to an endpoint that includes the `/react-query-api/`
    path, we return a `200 OK` response that will be delayed by 500 milliseconds,
    and it will have in its body an object with a `hello` property that will contain
    the parameter in the second position of the request parameters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们拦截到包含`/react-query-api/`路径的端点的`GET`请求时，我们返回一个将被延迟500毫秒的`200 OK`响应，其体中将包含一个具有`hello`属性的对象，该属性将包含请求参数的第二位参数。
- en: 'This means that a `GET` request for the [https://danieljcafonso.builtwithdark.com/react-query-api/userOne](https://danieljcafonso.builtwithdark.com/react-query-api/userOne)
    endpoint will return a `200 OK` response with the following object:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对[https://danieljcafonso.builtwithdark.com/react-query-api/userOne](https://danieljcafonso.builtwithdark.com/react-query-api/userOne)端点的`GET`请求将返回一个包含以下对象的`200
    OK`响应：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we are sure that our components will always receive the same data after
    a request, we can write our tests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确信我们的组件在请求后总是会接收到相同的数据，我们可以编写我们的测试。
- en: Now, I suggest you look at the `ParallelQueries` component from a user-centric
    perspective and consider the scenarios you might want to test. The rule of thumb
    here is to think, “*If I was a user interacting with this code, what would I interact
    with or expect* *to happen?*”
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我建议你从一个用户的角度来看`ParallelQueries`组件，并考虑你可能想要测试的场景。这里的经验法则是思考，“*如果我是与这段代码交互的用户，我会与什么交互或期望发生什么*？”
- en: 'Following the preceding analysis, I came up with two test scenarios:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的分析，我想出了两个测试场景：
- en: '`userOne`, `userTwo`, and `userThree`.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userOne`、`userTwo`和`userThree`。'
- en: '`"Fetching data…"` message for each of our requests.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们每个请求显示`"Fetching data…"`消息。
- en: 'With those scenarios in mind, we can write our tests. Let us see what our test
    file would look like:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些场景，我们可以编写我们的测试。让我们看看我们的测试文件会是什么样子：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let us now review what we do in the preceding snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在回顾一下前面代码片段中我们做了什么：
- en: We import our `ParallelQueries` component and, from our `test-utils`, our custom
    `render` function and the `screen` object.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入我们的`ParallelQueries`组件，以及从我们的`test-utils`中的自定义`render`函数和`screen`对象。
- en: 'We create our test suite and, inside it, our tests:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的测试套件，并在其中创建我们的测试：
- en: 'For the `"component should fetch and render multiple data"` test, we do the
    following:'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`"component should fetch and render multiple data"`测试，我们执行以下操作：
- en: Render our `ParallelQueries` component.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的`ParallelQueries`组件。
- en: Since we need to wait for the data to be fetched, we leverage an `async` query
    variant (`findBy`) from the React Testing Library and `await` until the `userOne`
    text shows up on the DOM.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要等待数据被获取，我们利用React Testing Library中的`async`查询变体（`findBy`）和`await`，直到`userOne`文本出现在DOM上。
- en: Once our query finds the `userOne` text, we assert that it is in the DOM and
    repeat the same assertion for `userTwo` and `userThree`. In these last two examples
    (`userTwo` and `userThree`), we won’t need to leverage the `findBy` variant because
    the data will already be on the DOM, so we use the `getBy` variant instead.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们的查询找到`userOne`文本，我们断言它在DOM中，并对`userTwo`和`userThree`重复相同的断言。在这些最后两个例子（`userTwo`和`userThree`）中，我们不需要利用`findBy`变体，因为数据已经存在于DOM上，所以我们使用`getBy`变体。
- en: 'For the `"component should show loading indicator for each query"` test, we
    do the following:'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`"component should show loading indicator for each query"`测试，我们执行以下操作：
- en: Render our `ParallelQueries` component.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的`ParallelQueries`组件。
- en: Due to the 500 millisecond delay we added to our mocked response, we won’t have
    our data immediately available to be rendered, so we should have our loading indicators
    showing up instead. Since we will have multiple indicators, we leverage the `getAllBy`
    variant to get an array of elements that match our query.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在模拟响应中添加了500毫秒的延迟，我们的数据不会立即可用以进行渲染，因此我们应该显示加载指示器。由于我们将有多个指示器，我们利用`getAllBy`变体来获取与我们的查询匹配的元素数组。
- en: We then assert that our array of elements has a length of `3` to ensure that
    we have a `"Fetching data…"` message for each query.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后断言我们的元素数组长度为`3`，以确保每个查询都有一个`"Fetching data…"`消息。
- en: With these tests, we have followed an approach that reflects our user behavior
    when interacting with our component and, at the same time, got 100% coverage on
    our `ParallelQueries` component and our `useMultipleQueriesV2` custom hook.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些测试，我们遵循了一种反映我们与组件交互时用户行为的方法，同时也在我们的`ParallelQueries`组件和`useMultipleQueriesV2`自定义钩子上实现了100%的覆盖率。
- en: In most scenarios, to deal with data-fetching scenarios, you only need to wait
    for the data you fetch to be rendered on the DOM. Got a single query? Wait for
    the data to be displayed on the DOM. Got some parallel queries? Wait for the data
    to be displayed on the DOM. Got some dependent queries? Wait for the first query
    data to be displayed on the DOM. Then, repeat this step for the following queries.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，为了处理数据获取场景，你只需要等待你获取的数据在DOM上被渲染。只有一个查询？等待数据在DOM上显示。有多个并行查询？等待数据在DOM上显示。有依赖查询？等待第一个查询的数据在DOM上显示。然后，为后续查询重复此步骤。
- en: Now, in some scenarios, you will have to fire some actions to get to your test
    assertion. Some of those scenarios might even involve query invalidation or query
    cancelation. Due to the similarity of these scenarios, let us now see what we
    can test with query invalidation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在某些场景中，您将不得不执行一些操作以到达您的测试断言。其中一些场景甚至可能涉及查询无效化或查询取消。由于这些场景的相似性，让我们现在看看我们可以使用查询无效化进行哪些测试。
- en: Checking whether a query was invalidated
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查查询是否被无效化
- en: As you should remember from [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140),
    query invalidation is when you manually mark your query as stale so that React
    Query can refetch it if it is being rendered.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您应该从[*第五章*](B18501_05.xhtml#_idTextAnchor140)中记住的，查询无效化是指您手动标记您的查询为过时，以便React
    Query可以在渲染时重新获取它。
- en: 'Let us review the `QueryInvalidation` component we saw in [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在[*第五章*](B18501_05.xhtml#_idTextAnchor140)中看到的`QueryInvalidation`组件：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see from the preceding snippet, the code is still very similar to
    the one from [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140). The only changes
    we made here were to apply the API file pattern and leverage the `getUser` function
    we saw previously in this chapter and change our query key to leverage the query
    key factory pattern.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中看到的，代码仍然非常类似于[*第五章*](B18501_05.xhtml#_idTextAnchor140)中的代码。我们在这里所做的唯一改变是应用API文件模式，并利用本章之前看到的`getUser`函数，以及将我们的查询键更改为利用查询键工厂模式。
- en: Now that you are reacquainted with this component and how it works, let us start
    to test it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经重新熟悉了这个组件及其工作方式，让我们开始对其进行测试。
- en: As we are leveraging our `getUser` function, we don’t need to create a new request
    handler in MSW due to the fact we are using the same endpoint.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在利用`getUser`函数，我们不需要在MSW中创建一个新的请求处理器，因为我们正在使用相同的端点。
- en: 'Now, looking at the `QueryInvalidation` component from a user-centric perspective,
    here are the three test scenarios that you might identify:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从以用户为中心的角度来看`QueryInvalidation`组件，以下是您可能识别出的三个测试场景：
- en: '`userOne`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userOne`。'
- en: '`"``Loading…"` message.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"``Loading…"`消息。'
- en: '**As a user, I want my query to be refetched when I click the Invalidate Query
    button**: In this scenario, we want our component to be rendered, and we wait
    for it to render a hello message, click the **Invalidate Query** button, wait
    for the hello message to disappear, wait for the loading indicator to disappear,
    and wait for the hello message to reappear. This way, we are sure our query was
    invalidated.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为用户，我希望点击无效查询按钮时重新获取我的查询**：在这种情况下，我们希望我们的组件被渲染，并等待它渲染一个问候消息，点击**无效查询**按钮，等待问候消息消失，等待加载指示器消失，并等待问候消息再次出现。这样，我们就能确保我们的查询已被无效化。'
- en: 'With those scenarios in mind, we can write our tests for our `QueryInvalidation`
    component. Let us see what our test file would look like:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let us now review what we are doing in the preceding snippet:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: We import our `QueryInvalidation` component, and from our `test-utils`, we import
    our custom `render` function, the `screen` object, the `fireEvent` util, and the
    `waitFor` function.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create our test suite, and inside it, our tests:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the `"component should display fetched data"` test, we do the following:'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render our `QueryInvalidation` component.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we need to wait for the data to be fetched, we leverage an `async` query
    variant (`findBy`) from the React Testing Library and `await` until the `userOne`
    text shows up on the DOM.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Once our query finds the `userOne` text, we assert it is in the DOM.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the `"component should show a loading indicator"` test, we do the following:'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render our `QueryInvalidation` component.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Due to the 500 millisecond delay we added to our mocked response, we won’t have
    our data immediately available to be rendered, so we should have our loading indicators
    showing up instead. We then leverage a `getBy` query variant to help assert that
    the `"Loading…"` text is in the DOM.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the `"component should invalidate query"` test, we do the following:'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render our `QueryInvalidation` component.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We wait for our data to be fetched and consequently assert it is on the DOM.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We find our `getByRole` query that will help us find the button with the `Invalidate`
    `Query` text.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then leverage the `fireEvent` util to fire a `click` event on our button.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then leverage the `waitFor` function to wait until an assertion evaluates
    to `true`. In this scenario, we wait for our query data to disappear from the
    DOM.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then leverage the `waitFor` function once again, this time to wait for the
    loading indicator to disappear from the DOM.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we assert that our query has finished refetching by checking whether
    our data is back on the DOM again.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we have checked how we can test query invalidation. You might be wondering
    how query cancelation differs from query invalidation. At the end of the day,
    testing query cancelation would differ on the following things:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Our query function would need to receive the `AbortController` signal and forward
    it to our `getUser` function.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of calling the `invalidateQuery` function from `queryClient`, we call
    `cancelQueries`.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our tests, the first two scenarios are exactly the same. In the third scenario,
    we immediately click the **cancel** button after rendering the component. After
    doing this, the DOM should not show either the data or the loading indicator.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you know how to test most scenarios in a user-centric approach, let's
    put this knowledge to the test and see how we would test a paginated scenario.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Testing paginated queries
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140), we learned how `useQuery`
    allowed us to create paginated queries and consequently used it to build a paginated
    UI component.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us review the `PaginatedQuery` component we saw in [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see from the preceding snippet, it is pretty much the same as what
    we saw in [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140). Note also that we leveraged
    two patterns we mentioned in this chapter:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: We created an entry into our `userKeys` factory and leveraged it to set our
    `useQuery` hook, `queryKey`
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created an API file to gather our user API functions and added our `getPaginatedData`
    function
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is what our `getPaginatedData` function looks like:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `getPaginatedData` function shown in the preceding snippet is responsible
    for making a `GET` request for our given endpoint for a given page.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are reacquainted with this component and how it works, let's test
    it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating our MSW request handler:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding snippet, we create a request handler to add to our `handlers`
    array, which does the following.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we intercept a `GET` request to an endpoint that includes the `/react-query-paginated`
    path, we get the `page` query parameter to help us define what data we will return.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: We return a `200 OK` response that will have in its body an object with the
    data for page one or page two, depending on the received page query parameter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: This means that a `GET` request for the [https://danieljcafonso.builtwithdark.com/react-query-paginated?page=0&results=10](https://danieljcafonso.builtwithdark.com/react-query-paginated?page=0&results=10)
    endpoint will return a `200 OK` response with the `pageOneData` object, while
    a `GET` request for the [https://danieljcafonso.builtwithdark.com/react-query-paginated?page=1&results=10](https://danieljcafonso.builtwithdark.com/react-query-paginated?page=1&results=10)
    endpoint will return a `200 OK` response with the `pageTwoData` object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are sure that our components will always receive the same data
    after a request, we can write our tests and look at the `PaginatedQuery` component
    from a user-centric perspective; here are the test scenarios that you might identify:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**As a user, I want to see that my data has loaded after opening the page**:
    In this scenario, we want our component to be rendered and check whether the initial
    loading data message shows up.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**As a user, I want to see an error message if my data fails to load**: In
    this scenario, we want our component to render and see whether it shows the error
    message when the request fails.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**As a user, I want to see the initially fetched data**: In this scenario,
    we want our component to render and wait until the data of the first page is fetched.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**As a user, I want to click on the** **Next Page** **button and see the data
    from the next page**: In this scenario, we want our component to be rendered,
    ensure we have the initial data, and after clicking on the **Next Page** button,
    wait until the data of the second page is fetched.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**As a user, I want to see a fetching indicator while fetching new data**:
    In this scenario, we want our component to be rendered, ensure we have the initial
    data, and after clicking on the **Next Page** button, ensure that the fetching
    indicator is rendered.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**As a user, I want my data to show up while clicking on** **Next Page** **and**
    **Previous Page**: In this scenario, we want our component to be rendered, ensure
    we have the initial data, and after clicking on the **Next Page** button, ensure
    the second page shows up. We then click on the **Previous Page** button and ensure
    that the data of the first page is rendered again.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**As a user, I want my** **Previous Page** **button to be disabled when I’m
    on the first page**: In this scenario, we want our component to be rendered and
    ensure we have the initial data. Since we are on the first page, we want our **Previous
    Page** button to be disabled.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**As a user, I want my** **Next Page** **button to be disabled while waiting
    for new data to show up**: In this scenario, we want our component to render and
    ensure we have the initial data. After clicking the **Next Page** button, we need
    to ensure that this button is disabled.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these scenarios in mind, this is the code we would write to test the `PaginatedQuery`
    component:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We start by doing the necessary imports:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `PaginatedQuery` component.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `render` and `screen` utils from `test-utils`.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `userEvent` util from the `user-event` companion from the testing library.
    One thing to be aware of here is that we are using a user-event version before
    v14.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our MSW `server` so that we can create a custom response mock for one of our
    test scenarios.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The MSW `rest` namespace to create relevant request handlers for one of our
    test scenarios.
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create our test suite and, inside it, our tests:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the `"should render loading indicator on start"` test, we do the following:'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render our `PaginatedQuery` component.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Leverage the `getByText` query to assert that the `"Loading initial data…"`
    message is on the DOM.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the `"should render error on failed fetching"` test, we do the following:'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Leverage our `server` `use` function to add a request handler to our current
    server instance. In this scenario, we add a handler that will catch every `GET`
    request (`"*"` indicates that this handler will match every route) and return
    `403 Forbidden` so that our request fails. Don’t worry about this leaking into
    other tests because we made sure to call the `resetHandlers` function in our `setupTests`
    file. This will ensure that this custom request handler will only be used on this
    test.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render our `PaginatedQuery` component.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Leverage the `findByText` query to `await` until the error message shows up
    on the DOM.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the `"should render first page data"` test, we do the following:'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render our `PaginatedQuery` component.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait until the data from the first name property from the first page shows up
    on the DOM.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert that the last name property also shows up on the DOM.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the `"should render second page data"` test, we do the following:'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render our `PaginatedQuery` component.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait until the data from the first page shows up on the DOM.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Leverage the `getByRole` query to get a button with the text `"should show
    fetching indicator while fetching data"` test, we do the following:'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render our `PaginatedQuery` component.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait until the data from the first page shows up on the DOM.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Leverage the `getByRole` query to get a button with the text `getByText` query
    to check whether the `"Loading…"` indicator shows up on the DOM.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the `"should change pages back and forth and render expected data"` test,
    we do the following:'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render our `PaginatedQuery` component.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait until the data from the first page shows up on the DOM and assert that
    it is there.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Leverage the `getByRole` query to get a button with the text `getByRole` query
    to get a button with the text `"should have previous page button disabled on first
    page"` test, we do the following:'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render our `PaginatedQuery` component.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Leverage the `findByRole` query to wait until the `"should have next page button
    disabled while changing pages"` test, we do the following:'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render our `PaginatedQuery` component.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Leverage the `findByRole` query to wait until the **Next Page** button shows
    up on the DOM and click on it.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert that the **Next Page** button is now disabled.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, we can test our queries in a fully user-centric approach and
    forget the implementation details. Now, let’s move into the mutation section and
    see how it gets a bit harder to follow a user-centric approach.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Testing mutations
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can definitely follow a user-centric approach with mutations, although,
    in some scenarios, this might be harder. Let us review a component we wrote in
    [*Chapter 6*](B18501_06.xhtml#_idTextAnchor159) and see how it might be harder
    for us to test it following a user-centric approach:'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding snippet, we can see our `SimpleMutation` component. Now, let
    us try to do our user-centric approach exercise and understand which test scenarios
    we could write:'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**As a user, I want to see a paused indicator when my mutation enters the paused
    state**: In this scenario, we want to render our component and, when we attempt
    to perform our mutation, the paused indicator message to appear.'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**As a user, I want to create data on the server**: In this scenario, we want
    to render our component, fill out the form, and then perform our mutation. But
    wait – how does our user assert this?'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the last scenario had an issue – a lack of information from
    the UI that our mutation was performed successfully.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Usually, an issue of this sort would be fixed by adding a notification for
    a user, informing them that the mutation was performed successfully. Letting the
    user know the mutation succeeded is always a good practice. Following this approach,
    our test would resemble something like this:'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**As a user, I want to create data on the server successfully**: In this scenario,
    we want to render our component, fill out the form, press the **Add** button,
    and wait for a success message to appear'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, now we have a user-centric way to test our mutation. However,
    for some reason, let us assume that we cannot perform changes to our `SimpleMutation`
    component. How would we ensure that our mutation was performed? We would have
    to resort to implementation details. Our test scenario would resemble something
    like this:'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**As a user, I want to perform a mutation**: In this scenario, we want to render
    our component, fill out the form, press the **Add** button, and assert that our
    mutation was triggered'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will show you how to write tests for instances where the
    ideal (user-centric) approach is not something we can employ.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first thing we need to do before we write our test is to make sure MSW
    intercepts our request and is successful:'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding snippet, we create a request handler to add to our `handlers`
    array, which does the following.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Whenever we intercept a `POST` request to an endpoint that includes the `/name-api/`
    path, we return a `201 Created` response that will have an object in its body,
    with a `hello` property containing a string.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now write our tests for our `SimpleMutation` component. Just to recap,
    here are the tests we will be performing:'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As a user, I want to see a paused indicator when my mutation enters the paused
    state
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I want to perform a mutation
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us now see our created test file:'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let us now review what we are doing in the preceding snippet:'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We import our `axiosInstance` from our API file, as well as the `SimpleMutation`
    component we saw in [*Chapter 6*](B18501_06.xhtml#_idTextAnchor159), our custom
    `render` function, the `screen` object, and the `waitFor` function from our `test-utils`.
    Finally, we import the `userEvent` util from the `user-event` companion in the
    testing library.
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: One thing to be aware of here is that we are using a user-event version before
    v14.
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we will tie one of our tests to implementation details, we create `jest`
    `spy` over the `post` function of our `axiosInstance`. This means we can check
    whether our `post` function was called without replacing its implementation.
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create our test suite, and inside it, our tests:'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the `"data should be sent to the server"` test, we do the following:'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable to hold the name we will use in our mutation.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render our `SimpleMutation` component.
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Leverage a `getByRole` query to get our name input.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Leverage the `type` event from `userEvent` and type our name inside our input.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Leverage the `click` event from `userEvent` and click on the `post` function
    of our `axiosInstance` is called with the data from our mutation.
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the `"on no network should display paused information"` test, we do the
    following:'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we want to make sure that we simulate being offline, we leverage the `mockReturnValue`
    function from the `spyOn` function to make sure we force our `navigator` `onLine`
    property to return `false`. This will make sure that our code is aware of being
    offline.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render our `SimpleMutation` component.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Leverage the `click` event from the `userEvent` and click on the `isPaused`
    property is `true`. Therefore, we wait until the `"Waiting for network to come
    back"` message appears. We then assert it is on the DOM.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: From the previous test, we learned that we can leverage `Jest` spies to check
    whether our function was called and make sure our mutation is performed. This
    doesn’t guarantee how our component will behave when our mutation is successful
    because we don’t have anything rendered in there to let us know. In the first
    case scenario, always ensure you have all the information your user needs so they
    can know that your mutation was successful. If you do this, you can test it in
    a user-centric way and avoid implementation details.
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: One mutation case that might be relevant for testing is when we perform an optimistic
    update. However, since we applied one of the aforementioned patterns in this chapter
    to it, we will be able to test it with the **React Hooks Testing Library** in
    the next section.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Testing custom hooks that use React Query
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: During development, there will be times when your custom hooks are too complex
    to test alongside the component that leverages them. This can be due to the size
    of the hook, complex logic, or just too many scenarios that would increase your
    test complexity if you focused on a user-centric approach. To fix this issue,
    the React Hooks Testing Library was created.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, it might be very tempting to go ahead and use this everywhere, but don’t
    forget that a user-centric approach will ultimately help you to find issues faster
    and save time if you decide to refactor the way your hooks work. Either way, if
    your hook is not used alongside a component or is too complex, the React Hooks
    Testing Library is definitely something to consider.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is how to add the React Hooks Testing Library to your project:'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you are running npm in your project, run the following command:'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you are using Yarn, run the following command:'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you are using pnpm, run the following command:'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you are using React from version 18 and above, there is something to be aware
    of here. You don’t need to install the React Hooks Testing Library, as from version
    13.1.0 onward, the React Testing Library includes `renderHook`, which works similarly
    to the one from the React Hooks Testing Library.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As mentioned at the end of the last section, we will see how to test optimistic
    updates. Before we write our tests, let us see how our code looks after applying
    the patterns mentioned in this chapter.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To do this, we will leverage the `useOptimisticUpdateUserCreation` hook shown
    previously:'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Considering we already have the route leveraged in this hook handled by MSW,
    we can start considering our tests.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These are the scenarios we will be considering:'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**I want to perform an optimistic update right after triggering my mutation**:
    In this scenario, we render our hook, trigger our mutation, and wait until the
    query data affected by our mutation is updated.'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I want my optimistic update data to be reverted after my mutation fails**:
    In this scenario, we render our hook and trigger our mutation, and when our mutation
    fails, our query data must stay the same as before the mutation was triggered.'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I want my query to be invalidated after my mutation settles**: In this scenario,
    we render our hook and trigger our mutation. Once our mutation settles, we check
    whether our query was invalidated.'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these scenarios in mind, we can create our tests. This is what our test
    file would look like:'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let us now review what we do in the preceding snippet:'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We start by doing the necessary imports:'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `useOptimisticUpdateUserCreation` custom hook.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `QueryClient` and `QueryClientProvider`. Remember that we won’t use the
    previously created `customRender`, so we must create a new wrapper here.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`renderHook` from the React Hooks Testing Library. If you use `renderHook`
    from the React Testing Library, import it there instead.'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `userKeys` factory.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our MSW `server` so that we can create a custom response mock for one of our
    test scenarios.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The MSW `rest` namespace to create relevant request handlers for one of our
    test scenarios.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We create our `QueryClient` instance and pass it to our `wrapper`. This will
    be used to wrap our hook to use React Query.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create our test suite and, inside it, our tests:'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the `"should perform optimistic update"` test, we do the following:'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure our cached query data for the query key under the `userKeys.all()` key
    is an empty array.
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `name` and `age` variables to avoid magic numbers in our test.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render our hook and destructure the `waitFor` function and the `result` object
    from it.
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We leverage our `result` object to access our `mutate` function and perform
    our mutation.
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `waitFor` function to loop our assertion until it evaluates to `true`.
    In this scenario, we wait until the query cache has the optimistically updated
    data cached under the `userKeys.all()` query key.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the `"should revert optimistic update"` test, we do the following:'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure our cached query data for the query key under the `userKeys.all()` key
    is an empty array.
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Leverage our `server use` function to add a request handler to our current server
    instance. In this scenario, we add a handler that will catch every `POST` request
    (`"*"` indicates that this handler will match every route) and return a `403 Forbidden`
    so that our request fails. Don’t worry about this leaking into other tests because
    we made sure to call the `resetHandlers` function in our `setupTests` file. This
    will ensure that this custom request handler will only be used on this test.
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `name` and `age` variables to avoid magic numbers in our test.
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render our hook and destructure the `waitFor` function and the `result` object
    from it.
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Leverage our `result` object to access our `mutate` function and perform our
    mutation.
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `waitFor` function to wait until our hook’s `isError` property is `true`.
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we are sure our mutation has failed, we again leverage the `waitFor` function
    to wait until the query data cached under the `userKeys.all()` key is the empty
    array we had before our mutation.
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the `"should invalidate query on settled"` test, we do the following:'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure our cached query data for the query key under the `userKeys.all()` key
    is an empty array.
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we are not rendering a query to make sure it is updating after our mutation,
    we create `invalidateQueriesSpy` over our `queryClient` `invalidateQueries` method.
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `name` and `age` variables to avoid magic numbers in our test.
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render our hook and destructure the `waitFor` function and the `result` object
    from it.
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Leverage our `result` object to access our `mutate` function and perform our
    mutation.
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait until our `isSuccess` is `true`. This means our mutation was successful.
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If our mutation is successful, we can assert that `invalidateQueriesSpy` was
    called with the `userKeys.all()`. This means that our `onSettled` function was
    called, and our query would be invalidated afterward.
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now handled how to test custom hooks with React Hooks Testing Library.
    It is all about rendering your hook and leveraging its result to access what your
    hook returns to perform your actions and assertions.
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Just for the sake of convenience and so that you can see a scenario where we
    test a query, let us see how we would test the `useMultipleQueriesV2` hook we
    saw in the *Checking whether data is* *fetched* section.
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For this hook, we would only need a single test scenario:'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**I want my parallel queries to fetch data**: In this scenario, we render our
    hook and wait until it returns the data for the three queries it fetches'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Like the previous hook, we have already set up our MSW request handlers previously,
    so we don’t need to worry about them.
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let us look at the test file for our `useMultipleQueriesV2` hook:'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let us now review what we are doing in the preceding snippet:'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We start by doing the necessary imports:'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `useMultipleQueriesV2` custom hook.
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `QueryClient` and `QueryClientProvider`.
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`renderHook` from the React Hooks Testing Library. If you are using `renderHook`
    from the React Testing Library, import it from there instead.'
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We create our `QueryClient` instance and pass it to our `wrapper`. This will
    be used to wrap our hook to use React Query.
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create our test suite and, inside it, our test:'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the `"should fetch all data"` test, we do the following:'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Render our hook with the `renderHook` function and destructure the `result`
    object and the `waitFor` function from it.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait until the data for the first query is defined.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that the data is now defined, we assert that the `hello` property from
    the returned object on the first query has `userOne`.
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We also assert that the `hello` property from the returned object on the second
    query has `userTwo`.
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We also assert that the `hello` property from the returned object on the third
    query has `userThree`.
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, testing hooks and leveraging queries is much simpler, as it
    mostly only involves rendering and asserting. This a test example, where I did
    not test the hook because testing the component using it is much easier. Just
    check the test we did for it in the *Checking whether data is* *fetched* section.
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: With all this knowledge in mind, you should be able to write your code and then
    sleep amazingly well at night because you also wrote valuable tests, ensuring
    that nothing will break.
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to test our components and hooks that leverage
    React Query. Congratulations! Thanks to this chapter, you have become a full-on
    React Query master!
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You learned how MSW can save you a lot of time developing and testing your React
    Query code by having a couple of request handlers.
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You got to meet the three patterns you can apply to make your code more readable
    and reusable (creating an API file, leveraging query key factories, and creating
    a hooks folder) and saw how valuable they were in adapting the code we saw in
    previous chapters.
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, you learned when to use the React Testing Library and the React Hooks
    Testing Library to test your queries and mutations, and you will keep the user-centric
    approach at the forefront of your mind when writing tests from now on.
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Once again, congratulations! You should now be able to leverage React Query
    in every scenario and sleep better at night because you can write valuable tests
    for it. Now, run with this knowledge, and go ahead and convince your teammates
    about the value of the amazing TanStack Query and how its React Adapter, called
    React Query, will make their server state management much easier.
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
