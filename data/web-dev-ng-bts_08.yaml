- en: Working with NG Bootstrap
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NG Bootstrap
- en: 'Bootstrap is one of the most popular CSS frameworks around—and Angular is one
    of the most popular web application frameworks around. NG Bootstrap is a collection
    of widgets (that is, components) that are built from Bootstrap 4 CSS. They are
    tailor-made to be used as Angular components, and are intended to be a complete
    replacement of Bootstrap components, which are powered by JavaScript. A few examples
    of JavaScript-powered Bootstrap components include the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap是最受欢迎的CSS框架之一，而Angular是最受欢迎的Web应用程序框架之一。NG Bootstrap是一个由Bootstrap 4
    CSS构建的小部件（即组件）集合。它们专门用于作为Angular组件使用，并旨在完全替代由JavaScript驱动的Bootstrap组件。一些由JavaScript驱动的Bootstrap组件的示例包括以下内容：
- en: Carousel
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮播
- en: Collapse
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 折叠
- en: Modal
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模态
- en: Popovers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹出框
- en: Tooltips
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具提示
- en: In this chapter, we're going to continue our exploration of components, but
    will focus on ng-bootstrap, which is a third-party Angular component library,
    as opposed to being a part of the Angular code base. This chapter, and [Chapter
    9](1a222c0e-7130-4ac2-959d-ae9d6cc1ca7d.xhtml), *Working with Angular Material*,
    are relatively short chapters, but I wanted to include them in this book for the
    same reason I mentioned for having included [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml), *Flex-Layout
    – Angular's Responsive Layout Engine*—and that is to give you choices. In the
    context of this chapter, that means having choices of ready-made components that
    you can leverage for your Angular applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探讨组件，但将重点放在ng-bootstrap上，这是一个第三方Angular组件库，而不是Angular代码库的一部分。这一章和[第9章](1a222c0e-7130-4ac2-959d-ae9d6cc1ca7d.xhtml)，*使用Angular
    Material*，都是相对较短的章节，但我想把它们包括在这本书中，原因与我包括[第5章](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml)，*Flex-Layout
    – Angular's Responsive Layout Engine*相同-那就是给你选择的机会。在这一章的背景下，这意味着你可以选择为你的Angular应用程序利用的现成组件。
- en: ng-bootstrap doesn't have an official acronym, but for the purposes of convenience,
    in this chapter, I'm going to give it one. We'll be referring to NG Bootstrap
    as NGB—which, as it turns out, is also a fun thing to type on the keyboard (since
    the letters are so closely placed together). Try it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ng-bootstrap没有官方的缩写，但为了方便起见，在本章中，我将给它一个。我们将把NG Bootstrap称为NGB-事实证明，这也是键盘上有趣的输入（因为字母之间的距离如此接近）。试试看。
- en: 'As in all the other chapters in this book, I will not consume page upon page
    to simply regurgitate NGB''s official documentation, which is freely available
    online, just to make the book seem formidable. I''d rather give you a 300-to 400-page
    book filled with hand-selected goodness that keeps you reading, rather than a
    500-600-page book that can be used as a sleep narcotic, for your hard-earned money.
    That being said, NGB''s official online documentation can be found here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本书中的其他章节一样，我不会消耗大量页面来简单地重复NGB的官方文档，这些文档可以在网上免费获取，只是为了让这本书看起来令人敬畏。我宁愿给你一本300到400页的书，充满了精心挑选的好东西，让你一直阅读，而不是一本500-600页的书，可以用作你辛苦赚来的钱的催眠剂。话虽如此，NGB的官方在线文档可以在这里找到：
- en: '[https://ng-bootstrap.github.io](https://ng-bootstrap.github.io).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://ng-bootstrap.github.io](https://ng-bootstrap.github.io)。'
- en: One last thing I wanted to mention really quickly is that this chapter and the
    following one ([Chapter 8](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml), *Working
    with NG Bootstrap*) will be a lot more visual than the other chapters in the book.
    This is because we're now getting into the actual meat of our example application,
    and we're going to start building things out visually.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我想最后快速提一下的是，本章和接下来的一章（[第8章](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml)，*使用NG
    Bootstrap*）将比本书中的其他章节更加视觉化。这是因为我们现在开始进入我们示例应用程序的实质内容，并且我们将开始在视觉上构建事物。
- en: 'With the housekeeping matters now out of the way, here''s what we''re going
    to be covering together in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在处理完了杂事，接下来我们将一起讨论本章中要涵盖的内容：
- en: Integrating NGB
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成NGB
- en: NGB widgets (specifically, collapse, modal, and carousel)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NGB小部件（特别是折叠、模态和轮播）
- en: Design rules of thumb that we should think about to help avoid overuse of widgets
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计规则是我们应该考虑的要点，以帮助避免过度使用小部件
- en: Integrating NGB
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成NGB
- en: NGB's purpose in life is to be a complete replacement for Bootstrap's components
    that require JavaScript (such as the components listed at the beginning of the
    chapter). In fact, on the very first page of the *Getting Started* section on
    their official website, they go further and say that you shouldn't be using any
    JavaScript-based components at all—or even their dependencies, such as jQuery or
    Popper.js. This can be found at: [https://ng-bootstrap.github.io/#/getting-started](https://ng-bootstrap.github.io/#/getting-started).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: NGB的存在意义是成为Bootstrap需要JavaScript的组件的完整替代品（例如本章开头列出的组件）。事实上，在官方网站的*入门*部分的第一页上，他们进一步表示，您不应该使用任何基于JavaScript的组件，甚至不应该使用它们的依赖项，如jQuery或Popper.js。这可以在以下网址找到：[https://ng-bootstrap.github.io/#/getting-started](https://ng-bootstrap.github.io/#/getting-started)。
- en: Installing NBG
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装NBG
- en: 'First things first: before we take a look at a caveat that we need to be aware
    of when using NGB, let''s add it to our project—and I''ll also show you how to
    fix the conflicting libraries that you may encounter (by showing you my `package.json`
    file).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的事情是：在我们查看使用NGB时需要注意的一个警告之前，让我们将其添加到我们的项目中——我还将向您展示如何解决可能遇到的冲突库（通过展示我的`package.json`文件）。
- en: 'Installing NGB is straightforward using `npm`. But, like other modules, we
    also need to import it and list it in our root module (that is, `app.module.ts`).
    Here are the steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`npm`安装NGB很简单。但是，与其他模块一样，我们还需要将其导入并在根模块中列出（即`app.module.ts`）。以下是步骤：
- en: Run `npm install`: `npm install --save @ng-bootstrap/ng-bootstrap`
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm install`：`npm install --save @ng-bootstrap/ng-bootstrap`
- en: Import NGB into our root module: `import {NgbModule} from '@ng-bootstrap/ng-bootstrap';`
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将NGB导入到我们的根模块中：`import {NgbModule} from '@ng-bootstrap/ng-bootstrap';`
- en: List `NgbModule` in the imports array (as a parameter to the root module's `@NgModule`
    decorator) like this: `NgbModule.forRoot()`
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入数组中列出`NgbModule`（作为根模块的`@NgModule`装饰器的参数）如下：`NgbModule.forRoot()`
- en: If you create an Angular module that uses NGB, you'll have to import NGB into
    it as well. The syntax for importing NGB into other modules is the exact same
    as the one just outlined for importing it into our root module, but the syntax
    for listing the NGB module as a parameter to the module's `@NgModule` decorator
    is slightly different. It's just listed in the imports array as `NgbModule`, as
    opposed to `NgbModule.forRoot()`, as we have to list it in our root module.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您创建了一个使用NGB的Angular模块，那么您也需要将NGB导入其中。将NGB导入其他模块的语法与刚刚概述的导入到根模块中的语法完全相同，但是将NGB模块列为模块的`@NgModule`装饰器的参数的语法略有不同。它只是在导入数组中列出为`NgbModule`，而不是`NgbModule.forRoot()`，因为我们必须在根模块中列出它。
- en: So, how are we going to take a look at a few of their components without unintentionally
    messing up the NGB portions of our example application? There's only one way—we're
    going to make sure that we do not directly or indirectly load jQuery or Popper.js
    into our example application, by not using the Bootstrap components (make sure
    you understand that Bootstrap and NGB are two different libraries).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们要如何查看一些组件，而不会无意中搞乱我们示例应用程序的NGB部分呢？只有一种方法——我们要确保我们不直接或间接地将jQuery或Popper.js加载到我们的示例应用程序中，不使用Bootstrap组件（确保您理解Bootstrap和NGB是两个不同的库）。
- en: Let me clarify something real quick. We have jQuery and Popper.js installed
    in our example application, and you can verify this by taking a look at our `package.json`
    file. In it, you will see entries for jQuery and Popper.js listed in the dependencies
    section. We are not going to be uninstalling these libraries. They are harmless
    to our use of NGB as long as we don't load them by also using Bootstrap. To put
    it another way, NGB components and Bootstrap components should not coexist in
    our Angular applications. We can use one or the other without issue—but never
    both. Does that make sense? OK, good.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我快速澄清一些事情。我们的示例应用程序中安装了jQuery和Popper.js，您可以通过查看我们的`package.json`文件来验证这一点。在其中，您将在依赖项部分看到jQuery和Popper.js的条目。我们不打算卸载这些库。只要我们不通过同时使用Bootstrap来加载它们，它们对我们使用NGB是无害的。换句话说，NGB组件和Bootstrap组件不应共存于我们的Angular应用程序中。我们可以使用其中一个而不会出现问题，但绝不能同时使用两者。这样清楚吗？好的。
- en: If you try to remove jQuery and/or Popper.js from the project, you will likely
    get several compile warnings whenever you run the project. While warnings may
    not prevent the project from running, always try to strive for clean builds.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试从项目中删除jQuery和/或Popper.js，每当运行项目时，您可能会收到几个编译警告。虽然警告可能不会阻止项目运行，但始终努力实现干净的构建。
- en: 'The chore of ensuring you get a clean build can sometimes be a pain in the
    neck, because you need to pay attention to the versions of your libraries. The
    code listing that follows is my `package.json` file. I consistently get a clean
    install compilation when I run `npm install` and then `npm start`. If you''re
    not getting a clean compilation, you may want to compare your `package.json` against
    mine, as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 确保获得干净的构建有时可能会很麻烦，因为您需要注意库的版本。接下来的代码清单是我的`package.json`文件。当我运行`npm install`然后`npm
    start`时，我一直能够获得干净的安装编译。如果您没有获得干净的编译，您可能想要将您的`package.json`与我的进行比较，如下所示：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can take a look at the list of available Angular modules, and their latest
    version numbers, that you can install with `npm` at: [https://www.npmjs.com/~angular](https://www.npmjs.com/~angular).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看可用的Angular模块列表及其最新版本号，您可以使用`npm`安装，网址是：[https://www.npmjs.com/~angular](https://www.npmjs.com/~angular)。
- en: Why use NGB?
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用NGB？
- en: With the restrictions of not being able to have JavaScript-based components,
    nor directly using JavaScript libraries such as jQuery or Popper.js, you may be
    asking, *why use NGB at all*?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无法使用基于JavaScript的组件，也无法直接使用JavaScript库（如jQuery或Popper.js），您可能会问，*为什么要使用NGB*？
- en: 'That''s a good question. Here''s the short answer, in point form:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的问题。以下是简短的答案，以要点形式：
- en: Angular does not depend on jQuery. It uses its own implementation of jQuery,
    called jQLite, which is a subset of jQuery.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular不依赖于jQuery。它使用自己的jQuery实现，称为jQLite，这是jQuery的子集。
- en: We don't lose out on being able to use any Bootstrap components that are powered
    by JavaScript (such as modal or carousel) because they are re-done for Angular
    in NGB. Again, NGB's sole purpose in life is to completely replace any JavaScript-powered
    Bootstrap components.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不会失去使用任何由JavaScript驱动的Bootstrap组件的能力（例如模态框或轮播），因为它们在NGB中已经重新设计为Angular。再次强调，NGB的唯一目的是完全替代任何由JavaScript驱动的Bootstrap组件。
- en: A rule of thumb when building Angular applications is to try to only use Angular-specific
    components; that is to say, components that are specifically made for Angular—such
    as NGB widgets and components from Angular Material. This, of course, includes
    creating your own custom Angular components. Though you can work around this by
    jerry-rigging non-Angular-specific components, it's not recommended. Angular is
    full featured, and as we've learned, it's also extremely extensible. It would
    be very difficult to think of a use case where sticking to Angular-specific components,
    modules, directives, pipes, services, and so on would prevent you from doing what
    you needed to do.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建Angular应用程序时的一个经验法则是尽量只使用特定于Angular的组件；也就是说，专门为Angular制作的组件，比如NGB小部件和来自Angular
    Material的组件。当然，这包括创建自定义的Angular组件。虽然你可以通过折衷使用非特定于Angular的组件来解决问题，但这并不推荐。Angular功能齐全，正如我们所学到的，它也非常可扩展。很难想象有哪种情况下坚持使用特定于Angular的组件、模块、指令、管道、服务等会阻止你做你需要做的事情。
- en: NGB is a solid Angular-centric component library and works well when you don't
    try to create workarounds that are discouraged.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NGB是一个坚实的Angular中心组件库，在你不尝试创建被不鼓励的变通方法时运行良好。
- en: Creating our playground for NGB (and Angular Material, and more)
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为NGB（和Angular Material等）创建我们的游乐场
- en: There are only two dependencies for NGB (Angular and Bootstrap CSS), and luckily
    our, example application already has these two things in place—one by default
    (since our example application is an Angular application), and the other from
    our having installed Bootstrap during [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components*. However, we are going to add something
    to our example application so that we can experiment with using NGB components—a
    playground view.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: NGB只有两个依赖项（Angular和Bootstrap CSS），幸运的是，我们的示例应用程序已经有了这两个东西——一个是默认的（因为我们的示例应用程序是一个Angular应用程序），另一个是在[第3章](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml)中安装Bootstrap时安装的。然而，我们将向我们的示例应用程序添加一些内容，以便我们可以尝试使用NGB组件——一个游乐场视图。
- en: A long-standing traditional thing I do when building web applications of any
    technology stack, and not just for Angular applications, is to add a page as a
    place where I can experiment with stuff within the context of the application
    that I'm building at the time. I refer to that as a playground. In our case, our playground
    will be a component whose template will act as our experimental canvas as we explore
    a few NGB components. We're also going to hook it up to our menu so that we can
    access it easily.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建任何技术堆栈的Web应用程序时，我长期以来的传统做法，不仅适用于Angular应用程序，是添加一个页面作为我可以在当前构建的应用程序的上下文中尝试各种东西的地方。我把它称为游乐场。在我们的情况下，我们的游乐场将是一个组件，其模板将作为我们探索一些NGB组件时的实验画布。我们还将把它连接到我们的菜单，以便我们可以轻松访问它。
- en: We'll hang on to our playground view throughout the rest of the book, only deleting
    it in [Chapter 15](f81ae891-b2dc-4620-bb4a-ad099c96e8a0.xhtml), *Deploying Angular
    Applications*, where we'll learn how to deploy our application and won't want
    our playground to go along for the ride.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将保留我们的游乐场视图，只会在[第15章](f81ae891-b2dc-4620-bb4a-ad099c96e8a0.xhtml)中删除它，*部署Angular应用程序*，在那里我们将学习如何部署我们的应用程序，并不希望我们的游乐场随之而去。
- en: So, let's do that now. It has been a while since we've added components to our
    example application that we created in [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing*, and so I wanted to take this opportunity to enumerate the steps to
    do this (within their own sections that follow) using the addition of the playground
    as the example. Note that this is the manual way of adding a component to our
    project—unlike using the CLI to add it for us, as we did a few chapters ago.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在让我们这样做。自从我们在[第4章](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml)中创建的示例应用程序中添加组件以来已经过了一段时间，因此我想借此机会列举出使用playground作为示例的步骤（在接下来的各自部分中）。请注意，这是手动向我们的项目添加组件的方式，与几章前使用CLI为我们添加的方式不同。
- en: Creating a playground directory
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建playground目录
- en: The first thing we need to do is to create a directory that will hold the files
    we'll need for our playground component. Each of our components has its own directory,
    and are all subdirectories the `app` directory—which is itself a subdirectory
    of the `src` directory within the project root directory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个目录，用于保存我们playground组件所需的文件。我们的每个组件都有自己的目录，并且都是“app”目录的子目录，而“app”目录本身是项目根目录中“src”目录的子目录。
- en: Since we're adding a new component, we'll follow our convention and create a
    directory for it. In your IDE, right-click the `app` directory, select `New Folder`*,*
    and enter `playground` as the name*—*which follows our convention that we've used
    so far. Once that is done, we'll have a place to insert the files that will collectively
    make up our component.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在添加一个新组件，我们将遵循我们的惯例并为其创建一个目录。在您的IDE中，右键单击“app”目录，选择“新建文件夹”，输入“playground”作为名称，这遵循了我们迄今为止使用的惯例。完成后，我们将有一个地方来插入将共同组成我们组件的文件。
- en: Creating the playground component class
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建playground组件类
- en: 'We now need to create our playground component class. In your IDE, right-click
    the newly created `playground` directory and select `New File` and enter `playground.component.ts` as
    the name. The `playground.component.ts` file our `component` class. Enter the
    following code in this file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建我们的playground组件类。在您的IDE中，右键单击新创建的“playground”目录，然后选择“新建文件”，输入“playground.component.ts”作为名称。“playground.component.ts”文件是我们的“component”类。在此文件中输入以下代码：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By looking at our playground `Component` class file, you''ll notice a few things:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看我们的playground“Component”类文件，您会注意到一些事情：
- en: We're importing `OnInit`, in addition to the component from the `@angular/core`
    module. This is because we're giving ourselves a place to set up some variables
    if we need to—such as for passing in any child components.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了从“@angular/core”模块中导入组件之外，我们还导入了“OnInit”。这是因为我们给自己一个设置一些变量的地方，如果需要的话，比如用于传递任何子组件。
- en: We've included a constructor for our class. Whether we use it or not, it provides
    us with a mechanism to tap into our component's life cycle to trigger some code
    if we wanted to. We won't use this right now, but I wanted to show you that our
    `components` function as traditional object-oriented classes, and thus have a
    constructor that we can leverage.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经为我们的类包含了一个构造函数。无论我们是否使用它，它都为我们提供了一种机制，可以在组件的生命周期中触发一些代码。我们现在不会使用它，但我想向您展示，我们的“组件”函数就像传统的面向对象类一样，因此具有我们可以利用的构造函数。
- en: We've set up our component to use external files for its template and its style,
    as opposed to having them inline. So, the next piece of business is to create
    these two files (see the following two sections).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经设置了组件以使用外部文件作为其模板和样式，而不是内联。因此，下一步是创建这两个文件（请参见以下两个部分）。
- en: We have a single property (that is, `pageTitle`) declared in our class as a
    string, and we've assigned the name of our view to it. Our template in the following
    section displays this property using the one-way binding syntax.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在类中声明了一个属性（即`pageTitle`），类型为字符串，并将我们视图的名称分配给它。在下一节中，我们的模板将使用单向绑定语法显示此属性。
- en: Creating the playground template file
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游乐场模板文件
- en: 'We now need to create the template file for our playground component, which
    will be our component''s visual interface. In your IDE, right-click the `playground` directory,
    select `New File`, and enter `playground.component.html`. The `playground.component.html`file
    is required because we''ve passed it into our component decorator as one of the
    parameters. Enter the following code in this file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要为我们的游乐场组件创建模板文件，这将是我们组件的视觉界面。在您的IDE中，右键单击`playground`目录，选择`新建文件`，输入`playground.component.html`。`playground.component.html`文件是必需的，因为我们已将其作为参数传递给了我们的组件装饰器。在此文件中输入以下代码：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There's not much in this file yet—but this is where we'll be adding the NGB
    components so that we can experiment with them. Experimenting, of course, is the
    very best way to learn any technology that may be new to you. The only thing our
    template does for now is to display our page name—by binding to our class's `pageTitle`
    property.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这个文件中还没有太多内容，但这将是我们添加NGB组件以便进行实验的地方。当然，实验是学习任何对您来说可能是新的技术的最佳方式。目前我们的模板只是通过绑定到我们类的`pageTitle`属性来显示我们的页面名称。
- en: Creating the playground CSS file
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游乐场CSS文件
- en: 'The final file we need to create for our playground component is that which
    will house its styles. In your IDE, right-click the `playground` directory, select `New
    File`, and enter `playground.component.css` as the name. The `playground.component.css`file
    is also required because we''ve passed it into our component decorator as one
    of the parameters. Enter the following code in this file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为游乐场组件创建的最后一个文件是用来存放其样式的文件。在您的IDE中，右键单击`playground`目录，选择`新建文件`，输入`playground.component.css`作为名称。`playground.component.css`文件也是必需的，因为我们已将其作为参数传递给了我们的组件装饰器。在此文件中输入以下代码：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code is self-explanatory. We don't have any styles in this file
    yet—but it's good to create at least one CSS file for every component that you
    create.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是不言自明的。目前这个文件中还没有任何样式，但为您创建的每个组件至少创建一个CSS文件是个好主意。
- en: Creating the playground menu item
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游乐场菜单项
- en: OK. So, after from following the directions in the preceding sections, you should
    now have a playground component that you can use as a sandbox for experimenting
    with almost anything you want. In our immediate case, we'll be using it for experimenting
    with NGB widgets (that is, components), but we'll also be using this sandbox during
    [Chapter 9](1a222c0e-7130-4ac2-959d-ae9d6cc1ca7d.xhtml), *Working with Angular
    Material*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。因此，按照前面部分的说明，您现在应该有一个游乐场组件，可以用作几乎任何实验的沙盒。在我们的特定情况下，我们将使用它来实验NGB小部件（即组件），但我们还将在[第9章](1a222c0e-7130-4ac2-959d-ae9d6cc1ca7d.xhtml)
    *使用Angular Material*期间使用这个沙盒。
- en: Before we move on to inserting the first NGB widget, we'll be taking a look
    at. It's a good idea to create a temporary menu link for our playground view so
    that we can get to it easily from within our application. Let's do this now.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续插入第一个NGB小部件之前，我们将会看一下。为我们的游乐场视图创建一个临时菜单链接是个好主意，这样我们就可以很容易地从应用程序内部访问它。现在让我们来做这个。
- en: 'In your IDE, open your `app.component.html` file. This is the main, or starting,
    a template that is loaded for your Angular application during the bootstrapping
    process. It is also where we created our menu in [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing*. In this file, insert the following code after the listings menu item:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的IDE中，打开`app.component.html`文件。这是在启动过程中为您的Angular应用程序加载的主要或起始模板。这也是我们在《第4章》《路由》中创建菜单的地方。在这个文件中，在清单菜单项之后插入以下代码：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All this small HTML code snippet does is to add a `playground` navigation link
    in our menu, and instruct Angular's routing system to load the playground component
    (and thus the playground template, and then recursively load any child components)
    when it is clicked.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小的HTML代码片段所做的只是在我们的菜单中添加一个`playground`导航链接，并指示Angular的路由系统在点击时加载游乐场组件（因此加载游乐场模板，然后递归加载任何子组件）。
- en: OK, good—we're now all set up and ready to take a look at our first NGB widget.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，很好，我们现在已经设置好，准备好看我们的第一个NGB小部件了。
- en: NGB widgets
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NGB小部件
- en: As previously mentioned, NGB widgets are third-party Angular components that
    are designed to replace the JavaScript-driven Bootstrap CSS components. NGB has
    many widgets available, but we're only going to be looking at three of them in
    the following sections.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，NGB小部件是第三方Angular组件，旨在取代基于JavaScript的Bootstrap CSS组件。NGB有许多小部件可用，但在接下来的章节中，我们只会看到其中的三个。
- en: You can find the entire list of NGB widgets, along with their documentation,
    at: [https://ng-bootstrap.github.io/#/components/](https://ng-bootstrap.github.io/#/components/).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下网址找到完整的NGB小部件列表以及它们的文档：[https://ng-bootstrap.github.io/#/components/](https://ng-bootstrap.github.io/#/components/)。
- en: Collapse
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 折叠
- en: The collapse component is a useful thing to use to preserve screen real estate.
    Our use case for the use of this component will be for toggling instructions to
    be either displayed or hidden. The state of the component would initially be collapsed
    when its parent component's template is rendered, but the user would be able to
    toggle the instructions to be shown and re-collapse them as needed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠组件是一个有用的东西，可以节省屏幕空间。我们使用这个组件的用例是切换说明的显示或隐藏。当其父组件的模板被渲染时，组件的状态最初将被折叠，但用户可以根据需要切换说明的显示和重新折叠它们。
- en: Let's take a look at a quick example in the code that we can try out in our
    playground which toggles the display of a section of the page on and off—in our
    case, this content will be hypothetical instructions (for now).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码中看一个快速示例，我们可以在我们的游乐场中尝试，在这个示例中，我们可以切换页面上的一部分内容的显示和隐藏，这部分内容将是假设的说明（目前）。
- en: We need to modify three files to make this work. The use of other NGB components
    (and even the Angular Material components that we'll be looking at in the next
    chapter) work similarly, so I'll take the time to explain things after each code
    listing because this is the very first third-party component that we're looking
    at together. When looking at similar components later on, any explanations will
    given if they differ substantially from these ones.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改三个文件才能使其工作。其他NGB组件的使用（甚至是我们将在下一章中看到的Angular Material组件）工作方式类似，因此我将花时间在每个代码清单后解释事情，因为这是我们一起看的第一个第三方组件。在以后看类似的组件时，如果它们与这些组件有实质性的不同，我会给出解释。
- en: Our parent component
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的父组件
- en: For this chapter, as well as [Chapter 8](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml),
    *Working with NG Bootstrap*, our parent component will always be our playground
    component.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及《第8章》《使用NG Bootstrap》中，我们的父组件将始终是我们的游乐场组件。
- en: 'Modify your playground component template (which is  `playground.component.html`
    file) so that it looks as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 修改你的playground组件模板（即`playground.component.html`文件），使其看起来如下：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The only new thing we've added that is of any importance to our playground template
    is  `<ngb-collapse></ngb-collapse>`, which is our custom directive that will instruct
    Angular to insert our child component's template there. `ngb-collapse` is the
    selector in our component class's metadata (that is, the object we passed to the
    component decorator). Let's take a look at that file next.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在playground模板中唯一添加的新内容是`<ngb-collapse></ngb-collapse>`，这是我们的自定义指令，将指示Angular在那里插入我们子组件的模板。`ngb-collapse`是我们组件类元数据中的选择器（即我们传递给组件装饰器的对象）。接下来让我们来看看那个文件。
- en: Our NGB collapse component class
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的NGB折叠组件类
- en: We've named our component class (which leverages NGB's `collapse` component)
    *`NgbCollapseComponent`—*but where does this code live? Well, we need to create
    a new directory and two new files within that directory just like we did when
    we created our playground component. Yes—we created three files for our playground
    component, but we'll be skipping the CSS file for `NgbCollapseComponent`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经命名了我们的组件类（利用了NGB的`collapse`组件）*`NgbCollapseComponent`*—但这段代码在哪里呢？好吧，我们需要创建一个新目录，并在该目录中创建两个新文件，就像我们创建playground组件时所做的那样。是的—我们为我们的playground组件创建了三个文件，但是对于`NgbCollapseComponent`，我们将跳过CSS文件。
- en: 'First, create a directory called `ngb-collapse`. Within that new directory,
    create a file named `ngb-collapse.component.ts` and add the following code in
    it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`ngb-collapse`的目录。在这个新目录中，创建一个名为`ngb-collapse.component.ts`的文件，并在其中添加以下代码：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we've not defined a `styleUrls` array, which is why we don't
    require a file for it (which we would have named something like `ngb-collapse.component.css`
    if we wanted this component to have styling). For the purposes of experimenting
    with the NBG collapse component, we only care about creating a component class
    file and its template file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们没有定义`styleUrls`数组，这就是为什么我们不需要为它创建一个文件（如果我们想要给这个组件添加样式，我们会命名为`ngb-collapse.component.css`）。为了实验NBG折叠组件，我们只关心创建一个组件类文件和它的模板文件。
- en: The other thing of interest to us in our component class file is the `isCollapsed`
    property. We can, of course, name it whatever we want, but the important thing
    is that it is declared and is initially set to `true`. We're going to use this
    property by binding its value to the `ngbCollapse` attribute within our template
    file. Doing so will cause a part of our component template to be either collapsed
    (hidden) or expanded (displayed). Note that I emphasized that our targeted content
    within our component will either be hidden or displayed, as opposed to being either
    added to or removed from the DOM. If our content is hidden (that is, non-visible),
    it is still in the DOM. This is because the NGB collapse widget does not function
    as a structural directive. It achieves its hide/show functionality via attribute
    binding.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在组件类文件中感兴趣的另一件事是`isCollapsed`属性。当然，我们可以随意命名它，但重要的是它被声明并且最初设置为`true`。我们将通过将其值绑定到模板文件中的`ngbCollapse`属性来使用这个属性。这样做将导致我们组件模板的一部分被折叠（隐藏）或展开（显示）。请注意，我强调了我们组件中的目标内容将被隐藏或显示，而不是被添加或从DOM中移除。如果我们的内容被隐藏（即不可见），它仍然存在于DOM中。这是因为NGB折叠小部件不作为结构指令。它通过属性绑定实现其隐藏/显示功能。
- en: Let's now take a look at the third file, the component template for our
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看第三个文件，我们的组件模板
- en: '`NgbCollapseComponent` class.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgbCollapseComponent`类。'
- en: Our NGB collapse component template
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的NGB折叠组件模板
- en: 'Create another file within the `ngb-collapse` directory, name it `ngb-collapse.component.ts`,
    and add the following code in it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ngb-collapse`目录中创建另一个文件，命名为`ngb-collapse.component.ts`，并在其中添加以下代码：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s look at this code together. The first thing of interest to us is the
    binding of the `click` event to the expression, which basically toggles our `isCollapsed`
    variable, defined in our component class, between `true` and `false`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起看一下这段代码。我们感兴趣的第一件事是将`click`事件绑定到表达式上，这个表达式基本上在我们的组件类中定义的`isCollapsed`变量之间切换`true`和`false`：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The text for our toggle button is always set to one of two values. When the
    instructions are displayed, the button text reads Hide Instructions. When the
    instructions are hidden, the button text reads Show Instructions. This is, of
    course, the behavior we want, but at first glance, you may assume that it takes
    an `if .. else` construct to make it all work. Surprisingly, thanks to Angular''s
    interpolation template syntax, it only takes a tiny amount of code to alter the
    button''s text depending on the value of our `isCollapsed` variable. Let''s take
    a moment to see the tiny code snippet responsible for determining what the button
    text should be, and how it renders it for us:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的切换按钮的文本始终设置为两个值中的一个。当显示说明时，按钮文本为“隐藏说明”。当说明被隐藏时，按钮文本为“显示说明”。这当然是我们想要的行为，但乍一看，你可能会认为需要一个`if
    .. else`结构才能使其全部工作。令人惊讶的是，多亏了Angular的插值模板语法，只需要很少的代码就可以根据我们的`isCollapsed`变量的值来改变按钮的文本。让我们花点时间来看一下负责确定按钮文本应该是什么的小代码片段，以及它是如何为我们呈现的：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In [Chapter 7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml), *Templates, Directives,
    and Pipes*, we took a look at all the symbols that we can use in our template
    syntax—such as interpolation, two-way binding, and so on. The symbol that works
    its magic for us, in this case, is the interpolation symbol (that is, the set
    of double curly braces). The reason I call it magical is that not only does it
    serve as a string interpolation, but it is also smart enough to handle expressions
    and even function calls. So, we're not restricted to just having a variable name
    being treated as a simple string interpolation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](cd8509d5-4bce-4056-8156-557186df18cd.xhtml)中，*模板、指令和管道*，我们看了一下我们可以在模板语法中使用的所有符号，比如插值、双向绑定等等。在这种情况下，为我们工作的符号是插值符号（即一对双大括号）。我之所以称它为神奇，是因为它不仅可以用作字符串插值，而且还足够聪明，可以处理表达式甚至函数调用。因此，我们不仅仅局限于将变量名视为简单的字符串插值。
- en: To determine what our button text should be, we use JavaScript's ternary operator
    syntax to render (or interpolate) the text to one of two values, Show or Hide,
    based on the value of our `isCollapsed` variable. Of course, whatever the Boolean
    value is, the *Instructions* text will always be rendered, resulting in the button
    text being either Show Instructions, or Hide Instructions. This is all done succinctly,
    and inline. Pretty cool, isn't it?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定我们的按钮文本应该是什么，我们使用JavaScript的三元运算符语法根据我们的`isCollapsed`变量的值渲染（或插值）文本为两个值中的一个，显示或隐藏。当然，无论布尔值是什么，*说明*文本都将始终被呈现，从而使按钮文本成为“显示说明”或“隐藏说明”。这一切都是简洁而内联完成的。相当酷，不是吗？
- en: Importations and declarations
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入和声明
- en: If you try and run the project at this point, you'll get a few errors. This
    is because we haven't set up our imports and declarations in our `app.module.ts`
    file for this component yet. Let's do this now.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试运行项目，你会得到一些错误。这是因为我们还没有在`app.module.ts`文件中为这个组件设置导入和声明。让我们现在来做这个。
- en: 'Add this import line after the import line we added for our playground component:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为我们的游乐场组件添加的导入行之后添加这个导入行：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: And add `NgbCollapseComponent` to the declarations array.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 并将`NgbCollapseComponent`添加到声明数组中。
- en: With the preceding import and addition of our component class to the declarations
    array in the `app.module.ts` file, our project should build and run just fine.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`app.module.ts`文件的声明数组中导入前述导入并将我们的组件类添加到其中，我们的项目应该可以构建和运行得很好。
- en: Good job. Let's now move on to our modal component.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好。现在让我们继续进行我们的模态组件。
- en: Modal
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模态
- en: Modal dialog windows have been around since the early days of the Windows OS
    on desktops (pre-internet), and have become popular for websites as well—this
    is especially true since jQuery came onto the scene. Modal windows are used for
    interacting with the user—typically, to get information from them. Moreover, they
    help the designers focus the users' attention to where it should be by dimming
    the background for contrast, as well as disabling any interaction anywhere outside
    the modal area. One of our use cases for the use of a modal window will be for
    displaying the login form.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 模态对话框窗口自从桌面Windows操作系统的早期时代（互联网之前）就存在了，并且在网站上也变得很受欢迎——特别是自从jQuery出现以来。模态窗口用于与用户进行交互，通常是为了从他们那里获取信息。此外，它们通过调暗背景以及禁用模态区域外的任何交互来帮助设计师将用户的注意力集中在应该的地方。我们使用模态窗口的一个用例是显示登录表单。
- en: Let's take a look at a quick example in the code that we can try out in our
    playground, to display a modal window. Since the integration of NGB widgets all
    follow the same pattern, I won't cover it in as much detail as the collapse NGB
    widget, but I'll point the important areas.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在我们的播放中可以尝试的快速示例代码，以显示一个模态窗口。由于NGB小部件的集成都遵循相同的模式，我不会像折叠NGB小部件那样详细介绍它，但我会指出重要的地方。
- en: Our components all start off the same way. We need to create a folder for our
    component (let's name it `ngb-modal`) and we need to create our two files—one
    for our component class, and the other for our component template. Let's name
    them `ngb-modal.component.ts` and `ngb-modal.component.html`, respectively.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的组件都以相同的方式开始。我们需要为我们的组件创建一个文件夹（让我们将其命名为`ngb-modal`），并且我们需要创建我们的两个文件——一个用于我们的组件类，另一个用于我们的组件模板。让我们分别将它们命名为`ngb-modal.component.ts`和`ngb-modal.component.html`。
- en: In the sections that follow are the two code listings for our NGB modal component,
    followed by the necessary imports and declarations—just like we did for our collapse
    component.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分是我们的NGB模态组件的两个代码清单，然后是必要的导入和声明，就像我们为折叠组件所做的那样。
- en: Our NGB modal component class
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的NGB模态组件类
- en: In our component class, we first import the necessary classes from the appropriate
    modules, and we then decorate our class with the `@Component` decorator, so we
    can link it to a template and set up our selector (that is, our custom HTML tag
    that we'll add to our playground template).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的组件类中，我们首先从适当的模块中导入必要的类，然后我们使用`@Component`装饰器装饰我们的类，这样我们就可以将其链接到模板并设置我们的选择器（即，我们将添加到我们的播放模板中的自定义HTML标记）。
- en: 'Next, we add a constructor so we can inject the `NgbModal` service (note: we''ll
    be covering dependency injection in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml),
    *Integrating Backend Data Services*).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个构造函数，这样我们就可以注入`NgbModal`服务（注意：我们将在[第12章](9610f27b-03db-4258-8a68-24eb3901117b.xhtml)中介绍依赖注入，*集成后端数据服务*）。
- en: Our class has a variable named `closeResult`, which is populated with a string
    (by the private method named `getDismissReason`), describing how the modal dialog
    is dismissed by the user.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类有一个名为`closeResult`的变量，它由私有方法`getDismissReason`填充，描述了用户如何关闭模态对话框。
- en: We also have an `open` method that is responsible for causing the modal dialog
    to render. As we'll see in the code listing in the next section (on our component
    template), the `open` method is triggered by a button click from within our playground.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个`open`方法，负责使模态对话框渲染。正如我们将在下一节的代码清单中看到的（在我们的组件模板中），`open`方法是由我们的游乐场内的按钮点击触发的。
- en: 'You''ll notice that the open method takes a parameter (named `content` in this
    example). Our component''s template wraps the content that is to be displayed
    in our modal dialog within its `ng-template` tags, and as you''ll see, these tags
    have the `#content` template variable associated with them. If you remember from
    [Chapter 7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml), *Templates, Directives,
    and Pipes*, the hash symbol (that is, `#`) in template syntax is used to denote
    a variable:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到open方法接受一个参数（在本例中命名为`content`）。我们组件的模板将要在模态对话框中显示的内容包裹在它的`ng-template`标签中，正如您将看到的，这些标签与`#content`模板变量相关联。如果您还记得[第7章](cd8509d5-4bce-4056-8156-557186df18cd.xhtml)中的内容，*模板、指令和管道*，模板语法中的井号（即`#`）用于表示一个变量：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's now take a look at our component template, `ngb-modal.component.html`*.*
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看我们的组件模板，`ngb-modal.component.html`。
- en: Our NGB modal component template
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的NGB模态组件模板
- en: Our component template is not only responsible for supplying our view with the
    content to be displayed in the modal dialog, but will also supply us with the
    visual element that our users will use (in this case, a button) to trigger the
    modal dialog.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件模板不仅负责为模态对话框中显示的内容提供视图，还将为我们提供用户将使用的视觉元素（在本例中为按钮）来触发模态对话框。
- en: 'The following HTML code is our component template, which we will use later
    for our login form (note: we will be covering forms in [Chapter 10](5f27121b-6fb2-4429-aa6e-394aec2152ac.xhtml),
    *Working with Forms*):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下HTML代码是我们的组件模板，稍后我们将用于我们的登录表单（注意：我们将在[第10章](5f27121b-6fb2-4429-aa6e-394aec2152ac.xhtml)中涵盖表单，*使用表单*）：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have our component class and our component template, we have to
    tell our application's root module about them—and we'll do just that in the next
    section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了我们的组件类和组件模板，我们必须告诉我们应用程序的根模块关于它们——我们将在下一节中做到这一点。
- en: Importations and declarations
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入和声明
- en: Just as with our collapse component, if you try and run the project at this
    point, you'll get a few errors—and for the same reasons—since we've not set up
    our imports and declarations in our `app.module.ts` file for this component. You
    know the drill.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的折叠组件一样，如果您在这一点上尝试运行项目，您会得到一些错误——出于同样的原因——因为我们还没有在`app.module.ts`文件中为这个组件设置导入和声明。你知道该怎么做。
- en: 'Add this import line after the import line we had added for our playground
    and collapse components:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为游乐场和折叠组件添加的导入行之后，添加这个导入行：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And add `NgbModalComponent` to the declarations array.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 并将`NgbModalComponent`添加到声明数组中。
- en: I know you're getting the hang of this. Let's get some more practice with this
    by integrating one more NGB widget to our playground view—and as a bonus, we'll
    take a sneak preview of Angular's `HttpClient` module. We'll be using the `HttpClient`
    module to fetch the images for our carousel, and we'll also be using the `HttpClient`
    module to call our APIs in [Chapter 11](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml), *Dependency
    Injection and Services*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你已经掌握了这个。让我们通过将另一个NGB小部件集成到我们的游乐场视图中来进行更多练习——作为奖励，我们将预览一下Angular的`HttpClient`模块。我们将使用`HttpClient`模块来获取我们轮播图的图片，并且我们还将在[第11章](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml)中使用`HttpClient`模块来调用我们的API，*依赖注入和服务*。
- en: So let's stretch our legs and arms, fill up our cups with coffee, and move on
    to one of the more interesting components (and what will be the start of the show
    in our example application), the NGB carousel.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们伸展双腿和双臂，用咖啡杯装满咖啡，然后继续前进到更有趣的组件之一（也将是我们示例应用程序的焦点），NGB轮播。
- en: Carousel
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮播
- en: 'The carousel component is most notably known as the tool (that is, the widget
    or component) to use for displaying a series of images in a predesignated order—much
    like flipping through a photo album. Our use case will be precisely that: giving
    the user the ability to flip through photos of the property.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 轮播组件最显著的特点是作为一种工具（即小部件或组件）来按照预定顺序显示一系列图像，就像翻阅相册一样。我们的用例将会是这样：让用户有能力翻阅物业的照片。
- en: Let's take a look at a quick example in the code that we can try out in our
    playground to display three images. We'll start with the component class, and
    then move on to the component template. These code listings are straight out of
    the carousel example on the NGB website, found at: [https://ng-bootstrap.github.io/#/components/carousel/examples](https://ng-bootstrap.github.io/#/components/carousel/examples).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个快速的示例代码，我们可以在我们的游乐场中尝试显示三张图片。我们将从组件类开始，然后转到组件模板。这些代码清单直接来自NGB网站上的轮播示例，网址为：[https://ng-bootstrap.github.io/#/components/carousel/examples](https://ng-bootstrap.github.io/#/components/carousel/examples)。
- en: 'I leave the wiring up of the class, using the `import` statement and so on,
    to you as an exercise. Hint: it''s exactly the same process that we previously
    covered when adding the collapse and modal components to our playground (in their
    respective *Importations and declarations* sections). However, I will make mention
    of a few things after each code listing.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把类的连接，使用`import`语句等等留给你作为练习。提示：这与我们之前在游乐场中添加折叠和模态组件时涵盖的过程完全相同（在它们各自的*导入和声明*部分）。然而，我会在每个代码清单后提到一些事情。
- en: Our NGB carousel component class
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的NGB轮播组件类
- en: 'In this section, we will implement the `ngb-carousel` component class. The
    following is the updated component class. We will analyze the code in a bit:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将实现`ngb-carousel`组件类。以下是更新后的组件类。我们将稍后分析代码：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are a few things going on in our component class, `ngb-carousel.component.ts`.
    We're importing the `HttpClient` class from Angular's `http` module, and we're
    also importing the `map` class from the `rxjs/operators` module. The `HttpClient` class,
    which we'll be looking at more closely in [Chapter 11](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml),
    *Dependency Injection and Services*, is used to fetch a JSON list of image objects
    from [https://picsum.photos](https://picsum.photos), a free service that serves
    up images as placeholders, providing, as their site says, The Lorem Ipsum for
    photos. The `map` class is used to randomly map three of the many image objects
    that are returned from the`GET` request of `HttpClient` to our string array variable,
    named `images`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的组件类`ngb-carousel.component.ts`中有一些事情正在进行。我们从Angular的`http`模块中导入`HttpClient`类，还从`rxjs/operators`模块中导入`map`类。`HttpClient`类将在[第11章](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml)中更仔细地讨论，*依赖注入和服务*，用于从[https://picsum.photos](https://picsum.photos)获取图像对象的JSON列表，这是一个免费服务，提供占位图像，就像他们的网站所说的那样，照片的Lorem
    Ipsum。`map`类用于将从`HttpClient`的`GET`请求返回的许多图像对象中随机映射三个到我们的字符串数组变量`images`。
- en: The fetching of the image objects from the API happens when our component is
    initialized because the `GET` request happens within the `ngOnInit()` component's
    life cycle hook.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从API中获取图像对象发生在我们的组件初始化时，因为`GET`请求发生在`ngOnInit()`组件的生命周期钩子内。
- en: Our NGB carousel component template
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的NGB轮播组件模板
- en: 'In this section, we will implement our `ngb-carousel` component template file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现我们的`ngb-carousel`组件模板文件：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This template is straightforward. Everything about it is hardcoded, except for
    the `src` property of the `img` HTML elements. Using square brackets around the
    HTML `img src` attribute is an example of property binding (as we learned in [Chapter
    7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml), *Templates, Directives, and Pipes*).
    In this case, the number of images in the carousel was known to be three. In practice,
    and as we will do in our example application, the template would normally make
    use of the `*ngFor` structural directive to iterate through an array of items
    of variable lengths.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板很简单。除了`img` HTML元素的`src`属性之外，其他都是硬编码的。在HTML `img src`属性周围使用方括号是属性绑定的一个例子（正如我们在[第7章](cd8509d5-4bce-4056-8156-557186df18cd.xhtml)中学到的，*模板、指令和管道*）。在这种情况下，轮播中的图片数量已知为三张。在实践中，就像我们在示例应用程序中所做的那样，模板通常会使用`*ngFor`结构指令来迭代长度可变的项目数组。
- en: Having gone through a few examples of integrating NGB widgets into our playground,
    we can now implement them in our application for real.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几个示例了解了如何将NGB小部件集成到我们的playground中后，现在我们可以在我们的应用程序中实现它们。
- en: Implementing NGB into our example application
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将NGB集成到我们的示例应用程序中
- en: In the preceding section, *NGBwidgets*, we covered few components that are available
    in NGB. Of course, you know by now why I would never cover any more than a small
    number of the available components—right? If you said, *yes Aki, I know why. If
    you covered all the components, you'd basically just be duplicating documentation
    that is readily available elsewhere*, you'd be correct! Covering 3 out of 16 is
    plenty—it's almost 19% (which is practically the same as duplicating one out of
    every five pages of documentation!).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的*NGBwidgets*部分，我们介绍了一些NGB中可用的组件。当然，你现在知道为什么我不会介绍所有可用的组件了，对吧？如果你说，“是的Aki，我知道为什么。如果你介绍了所有的组件，基本上就是在重复已经可以在其他地方找到的文档”，那么你是正确的！介绍16个组件中的3个就足够了，几乎占了19%（这几乎等同于每五页文档中重复一次！）。
- en: But there's also another reason. We're only going to implement two of the three
    NGB components that we covered—namely, the modal component and the carousel component—and
    so there is no need to cover too much more than those. OK, let's continue by putting
    our new found knowledge to practical use.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有另一个原因。我们只打算实现我们介绍过的三个NGB组件中的两个，即模态组件和轮播组件，所以没有必要介绍太多其他的内容。好的，让我们继续把我们新学到的知识付诸实践。
- en: We learned about implementing the modal, carousel, and collapse components in
    earlier sections. We created selectors for each of the components. For the modal
    component, we created a selector named `ngb-test-modal`; for the carousel component,
    we created a selector named `ngb-test-carousel`; and last, but not least, for
    the collapse component, we created a selector named  `ngb-collapse`. We now need
    to use these selectors in the `playground.component.html` file so that the widgets
    will be visible in the page.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的部分学习了如何实现模态、轮播和折叠组件。我们为每个组件创建了选择器。对于模态组件，我们创建了一个名为`ngb-test-modal`的选择器；对于轮播组件，我们创建了一个名为`ngb-test-carousel`的选择器；最后，对于折叠组件，我们创建了一个名为`ngb-collapse`的选择器。现在我们需要在`playground.component.html`文件中使用这些选择器，以便小部件在页面上可见。
- en: 'The following is the updated code of the playground component template file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是playground组件模板文件的更新代码：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We added the directives using the selectors for each of the components. Run
    the app using the `ng serve` command in the command line and we should see the
    output, as shown in the following screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了每个组件的选择器添加了指令。在命令行中使用`ng serve`命令运行应用程序，我们应该能看到输出，如下面的截图所示：
- en: '![](assets/34434c9b-57ad-4f17-bec9-3f8fe7d366db.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/34434c9b-57ad-4f17-bec9-3f8fe7d366db.png)'
- en: Our application has the widgets integrated, but surely we can do a much better
    job with the design. In the next few sections, we will learn about some of the
    design principles and best practices that we will be implementing in the chapters
    to come.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已经集成了小部件，但我们肯定可以在设计上做得更好。在接下来的几节中，我们将学习一些设计原则和最佳实践，这些将在接下来的章节中实施。
- en: UX design rules of thumb
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UX设计原则
- en: There are rules of thumb for just about everything, and web design isn't any
    different. There are do's and don'ts in web design—and since we're now really
    starting to dive into our templates, it's a good time to review some of these
    design tenets.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有事情都有经验法则，网页设计也不例外。在网页设计中有应该做和不应该做的事情，既然我们现在真的开始深入研究我们的模板，现在是回顾一些这些设计原则的好时机。
- en: There are probably several dozen design principals, but I'm not an expert on
    , **user experience** (**UX**), and thus you'd be better served to pick up a good
    book that is focused on UX and GUI/interface design (I know that there are titles
    from Packt that you can look into). However, since we are building an application,
    and our application is made up of several components, It would be remiss if I
    didn't cover the fundamental three design principals.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有几十个设计原则，但我不是一个专家，所以最好是去找一本专注于UX和GUI/界面设计的好书（我知道Packt有一些相关的书）。然而，由于我们正在构建一个应用程序，我们的应用程序由几个组件组成，如果我不介绍这三个基本的设计原则，那就不够周全。
- en: Not only will we cover them in the following three short sections, but we will
    be adhering to them as we build our example application's templates. The reason
    we have things such as UX design principals essentially comes down to one thing—we
    want to have happy users!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅将在接下来的三个小节中涵盖它们，而且在构建示例应用程序的模板时，我们将遵守它们。我们之所以有UX设计原则之类的东西，归根结底就是一件事——我们希望用户能够快乐！
- en: Keep it clean
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持简洁
- en: 'UX rule of thumb #1: Keep it clean.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'UX准则 #1：保持简洁。'
- en: Nothing gives users a headache faster than an overly busy (that is, cluttered)
    user interface. You may have heard of the expression *less is more*—and this expression
    certainly applies to UX design.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比过于繁忙（即混乱）的用户界面更容易让用户头疼。你可能听说过“少即是多”的表达方式，这个表达方式当然也适用于UX设计。
- en: 'People feel like they have no time to do anything—and if doing something makes
    them feel like they are wasting their precious resource (that is, time), they
    become unhappy faster than you can count to 10\. How does this relate to this
    first UX design principal? If there is a lot to look at on your page, they don''t
    know where to start looking—and if they can''t make sense of what they''re looking
    at in short order, then you guessed it: they become unhappy.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 人们觉得自己没有时间做任何事情——如果做某事让他们觉得他们在浪费他们宝贵的资源（即时间），他们会比你数到10更快地变得不快乐。这如何与第一个UX设计原则相关？如果你的页面上有很多东西要看，他们不知道从哪里开始看——如果他们不能很快理解他们所看到的东西，那么你猜对了：他们会变得不快乐。
- en: Clutter is almost never a good thing. Think of your bedroom or kitchen. Are
    you happier when it's tidy and everything has a place and purpose, and you can
    easily and quickly find what you're looking for? Or are you happier when you waste
    5 minutes looking for that spatula to cook your breakfast that you barely have
    time to eat? The answer, I hope, is obvious. Visitors to websites think the same
    way.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 混乱几乎从来都不是一件好事。想想你的卧室或厨房。当它整洁，每样东西都有一个地方和目的，你可以轻松快速地找到你要找的东西时，你会更快乐吗？还是当你浪费5分钟找那个铲子来做早餐，而你几乎没有时间吃时，你会更快乐？答案，我希望是显而易见的。访问网站的用户也是这样想的。
- en: Keep it functional
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持功能性
- en: 'UX rule of thumb #2: Keep it functional.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 'UX准则 #2：保持功能性。'
- en: This UX rule of thumb is related to the first one, in that it is the same as
    saying that nearly everything on our view should have a function. The days of
    having a million bells and other objects on the screen that are nothing but eye
    candy are over. Do you remember the way websites looked in the late 1990s? Flash
    was all the rage. Web pages looked like snow globes, or had large animated buttons
    that pulsated, and read Click Here Now**.** These are no longer tolerated. Chances
    are excellent that if you have any such things on your web page, your visitor
    is going to leave your website as fast as they possibly can. If there is something
    on the screen, it had better have a purpose.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个UX原则与第一个原则相关，因为它与说我们视图上的几乎所有东西都应该有一个功能是一样的。在屏幕上有成千上万个毫无意义的东西的日子已经过去了。你还记得上世纪90年代网站的样子吗？Flash风靡一时。网页看起来像雪球，或者有着大大的跳动的动画按钮，上面写着“立即点击这里”。这些都不再被容忍。如果你的网页上有这样的东西，很有可能你的访客会尽可能快地离开你的网站。如果屏幕上有东西，它最好有一个目的。
- en: If you'd like to see an extreme example of a website that pays attention to
    the first and second (and the upcoming third) UX design principals, just take
    a look at Google's home page, at: [https://www.google.com/](https://www.google.com/).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看一个极端的例子，一个网站关注第一和第二（以及即将到来的第三）UX设计原则，只需看一下谷歌的主页：[https://www.google.com/](https://www.google.com/)。
- en: Keep it obvious
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持明显
- en: 'UX rule of thumb #3: Keep it obvious.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'UX原则 #3：保持明显。'
- en: Nothing frustrates users more than forcing them to use a large portion of their
    brain power, time, and detective skills just to find out what they need to do
    next, or how to do a specific task they'd like to perform in a web application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比强迫用户使用大量的脑力、时间和侦探技能来找出他们需要做什么，或者如何在网页应用程序中执行他们想要执行的特定任务更让用户沮丧的了。
- en: Users of your web application are users for a reason, and that is that they
    need a tool to get something done. Whether the task that they want to get done
    is for pleasure or for work, it doesn't matter. Whatever it is they'd like to
    get done, they don't want to spend any more time than what is reasonable. If they
    need to spend too much time figuring things out, guess what? Yes! They become
    unhappy!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您的网页应用程序的用户之所以成为用户，是因为他们需要一个工具来完成某些事情。无论他们想要完成的任务是为了快乐还是工作，都无关紧要。无论他们想要完成什么，他们都不想花费比合理时间更多的时间。如果他们需要花费太多时间来弄清楚事情，猜猜看？是的！他们会变得不快乐！
- en: This third UX design principle is perhaps the most difficult one to adhere to,
    but it is our responsibility as application builders to give it the attention
    it deserves.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这第三个UX设计原则可能是最难坚持的，但作为应用程序构建者，我们有责任给予它应有的关注。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored NG Bootstrap—the first of the two third-party component
    libraries that are freely available to us for use in our Angular applications.
    We'll be exploring the second one, Angular Material, in the next chapter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了NG Bootstrap——两个免费提供给我们在Angular应用程序中使用的第三方组件库中的第一个。我们将在下一章中探讨第二个，Angular
    Material。
- en: We took a look at how to install NGB, and then we created a playground within
    our application so we can have a place to play (that is, experiment) with these
    third-party components—including temporarily wiring the playground up to our menu
    via routing for easy navigational access to our playground. While we could have
    created a separate project altogether for playing around with components before
    integrating them into our application for their intended purposes, it is usually
    more convenient to create a playground within our existing infrastructure. Of
    course, when the comes for us to deploy our application, we can easily remove
    the playground and the menu option with its accompanying route.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何安装NGB，然后在应用程序中创建了一个游乐场，这样我们就有了一个可以玩耍（即实验）这些第三方组件的地方，包括临时通过路由将游乐场与菜单连接起来，以便轻松访问我们的游乐场。虽然我们本可以在集成这些组件到应用程序的预期用途之前创建一个完全独立的项目来玩耍，但通常更方便的是在现有基础设施中创建一个游乐场。当然，当我们部署应用程序时，我们可以轻松地删除游乐场和菜单选项及其相应的路由。
- en: 'With our playground all set up, we then dove in and took a look at how to integrate
    three of NGB''s widgets: collapse, modal, and carousel.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好我们的游乐场后，我们开始学习如何集成NGB的三个小部件：折叠、模态和轮播。
- en: 'Finally, to wrap the chapter up, since we''re in the component and layout part
    of the book (as opposed to the backend data integration and services part of the
    book), it was a good time to cover a few design principle as well. So, we briefly
    covered three of the top tenants of good design: keeping it clean, functional,
    and obvious. We''ll be adhering to these design principle as best we can throughout
    the remainder of the book.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了结束本章，因为我们现在处于书中的组件和布局部分（而不是后端数据集成和服务部分），现在是一个很好的时机来介绍一些设计原则。因此，我们简要介绍了三个良好设计的主要原则：保持清晰、功能性和明显性。在本书的其余部分，我们将尽力遵守这些设计原则。
- en: Now then, keep your component hat firmly on your head, turn the page, and let's
    take a look at the gorgeously designed components that the Angular team cooked
    up for our use. Leveraging the Angular Material components in the right proportions
    and places will help boost our example application's usability and aesthetics.
    And fortunately, Angular Material plays nicely with Bootstrap, so there's no problem
    with having both libraries in the same Angular project.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，戴上你的组件帽子，翻开书页，让我们来看看Angular团队为我们设计的华丽组件。合理地利用Angular Material组件，可以提高我们示例应用的可用性和美观度。幸运的是，Angular
    Material与Bootstrap兼容良好，因此在同一个Angular项目中同时使用这两个库并不成问题。
