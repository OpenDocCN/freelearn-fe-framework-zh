- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Exploring Popular Composition Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索流行的组合模式
- en: In this chapter, we will learn how to make components communicate with each
    other effectively, which is a crucial part of building complex React applications
    using small, testable, and maintainable components. By mastering the popular composition
    patterns and tools in React, you will be able to take control of every single
    part of your application and build scalable and extensible software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使组件之间有效地进行通信，这是使用小型、可测试和可维护的组件构建复杂React应用程序的关键部分。通过掌握React中流行的组合模式和工具，您将能够控制应用程序的每一个部分，并构建可扩展的软件。
- en: 'Let’s dive in and explore how we can leverage these patterns and tools to build
    better React applications. We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨如何利用这些模式和工具构建更好的React应用程序。我们将涵盖以下主题：
- en: How components communicate with each other using props and children
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件如何使用props和children进行通信
- en: The container and presentational patterns and how they can make our code more
    maintainable
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器和表现模式以及它们如何使我们的代码更易于维护
- en: What **higher-order components** (**HOCs**) are and how, thanks to them, we
    can structure our applications in a better way
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高阶组件**（**HOCs**）是什么以及如何利用它们以更好的方式构建我们的应用程序'
- en: What the function of the child component pattern is and what its benefits are
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子组件模式的功能及其好处
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您需要以下内容：
- en: Node.js 19+
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 19+
- en: Visual Studio Code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: You can find the code for this chapter in the book’s GitHub repository at [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter04).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub仓库中找到本章的代码，网址为[https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter04)。
- en: Communicating components
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信组件
- en: Composing React components is one of the key benefits of building applications
    with React. By creating small, **reusable components** with clean interfaces,
    you can easily compose them together to create complex applications that are both
    powerful and maintainable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React构建应用程序的关键好处之一是编写React组件。通过创建具有清晰界面的小型、**可重用组件**，您可以轻松地将它们组合在一起，以创建既强大又易于维护的复杂应用程序。
- en: Small components with a clean interface can be composed together to create complex
    applications that are powerful and maintainable at the same time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 具有清晰界面的小型组件可以组合在一起，以创建既强大又易于维护的复杂应用程序。
- en: 'Composing React components is straightforward; you just have to include them
    in the render:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 组合React组件很简单；您只需在render中包含它们：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For example, you can create a `Profile` component by simply composing a `Picture`
    component to display the profile image and a `UserName` component to display the
    name and the screen name of the user.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以通过简单地组合一个`Picture`组件来显示用户头像，以及一个`UserName`组件来显示用户名和屏幕名，来创建一个`Profile`组件。
- en: In this way, you can produce new parts of the user interface very quickly, writing
    only a few lines of code. Whenever you compose components, as in the preceding
    example, you share data between them using props. Props are the way a parent component
    can pass its data down the tree to every component that needs it (or part of it).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，您可以非常快速地生成新的用户界面部分，只需编写几行代码。每当您组合组件时，就像前面的例子一样，您可以使用props在它们之间共享数据。Props是父组件将数据传递到树中每个需要它（或其部分）的组件的方式。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the next section, you will learn about the `children` prop and how to use
    it correctly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将了解`children`属性及其正确使用方法。
- en: Using the children prop
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用children属性
- en: There is a special prop that can be passed from the owners to the components
    defined inside their render—`children`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊的属性可以从所有者传递到其内部定义的组件——`children`。
- en: In the React documentation, it is described as `opaque` because it is a property
    that does not tell you anything about the value it contains. Subcomponents defined
    inside the render of a parent component usually receive props that are passed
    as attributes of the component itself in JSX, or as a second parameter of the
    `_jsx` function. Components can also be defined with nested components inside
    them, and they can access those children using the `children` prop.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在React文档中，它被描述为`不透明`，因为它是一个不告诉你其包含值的属性。通常，在父组件的渲染中定义的子组件会接收到作为组件自身属性传递的props，或者在JSX中的`_jsx`函数的第二个参数中传递。组件也可以在它们内部定义嵌套组件，并且它们可以使用`children`属性访问这些子组件。
- en: 'Consider that we have a `Button` component that has a text property representing
    the text of the button:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们有一个具有文本属性的`Button`组件，该属性表示按钮的文本：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The component can be used in the following way:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件可以使用以下方式：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And this will render the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染以下代码：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, suppose we want to use the same button with the same class name in multiple
    parts of our application, and we also want to be able to display more than a simple
    string. Our UI consists of buttons with text, buttons with text and icons, and
    buttons with text and labels.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想在应用程序的多个部分使用具有相同类名的相同按钮，并且我们还想能够显示比简单的字符串更多的内容。我们的UI由带文本的按钮、带文本和图标的按钮以及带文本和标签的按钮组成。
- en: In most cases, a good solution would be to add multiple parameters to `Button`
    or to create different versions of `Button`, each one with its single specialization,
    for example, `IconButton`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，一个好的解决方案是向`Button`添加多个参数或创建不同版本的`Button`，每个版本都有其单一的专业化，例如`IconButton`。
- en: 'However, we should realize that `Button` could just be a wrapper, and we are
    able to render any element inside it and use the `children` property:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们应该意识到`Button`可能只是一个包装器，我们能够在其中渲染任何元素并使用`children`属性：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By passing the `children` prop, we are not limited to a simple single text property,
    but we can pass any element to `Button`, and it is rendered in place of the `children`
    property.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递`children`属性，我们不仅限于简单的单个文本属性，我们还可以将任何元素传递给`Button`，并且它将替换`children`属性进行渲染。
- en: In this case, any element that we wrap inside the `Button` component will be
    rendered as a child of the button element with `btn` as the class name.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们包裹在`Button`组件内的任何元素都将被渲染为具有`btn`类名的按钮元素的子元素。
- en: 'For example, if we want to render an image inside the button and some text
    wrapped in a `span` tag, we can do this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在按钮内渲染一个图像，并在`span`标签内包裹一些文本，我们可以这样做：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding snippet gets rendered in the browser as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段在浏览器中的渲染方式如下：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a pretty convenient way to allow components to accept any children elements
    and wrap those elements inside a predefined parent.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种相当方便的方式，允许组件接受任何子元素并将这些元素包裹在预定义的父元素内。
- en: Now, we can pass images, labels, and even other React components inside the
    `Button` component, and they will be rendered as its children. As you can see
    in the preceding example, we defined the `children` property as an array, which
    means that we can pass any number of elements as the component’s children.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`Button`组件内传递图像、标签，甚至其他React组件，并且它们将被渲染为其子元素。正如您在前面的示例中看到的，我们将`children`属性定义为数组，这意味着我们可以传递任意数量的元素作为组件的子元素。
- en: 'We can pass a single child, as shown in the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以传递单个子元素，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s now explore the container and the presentational pattern in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一节中探索容器和展示模式。
- en: Exploring the container and presentational patterns
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索容器和展示模式
- en: In the last chapter, we saw how to take a coupled component and make it reusable
    step by step. Now we will see how to apply a similar pattern to our components
    to make them clearer and more maintainable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何逐步将耦合组件转换为可重用组件。现在我们将看到如何将类似的模式应用到我们的组件中，使它们更清晰、更易于维护。
- en: React components typically contain a mix of *logic* and *presentation*. By logic,
    we refer to anything that is unrelated to the UI, such as API calls, data manipulation,
    and event handlers. The presentation is the part of the render where we create
    the elements to be displayed on the UI.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: React组件通常包含逻辑和展示的混合。通过逻辑，我们指的是与UI无关的任何内容，例如API调用、数据处理和事件处理程序。展示是渲染的部分，我们在其中创建要在UI上显示的元素。
- en: In React, there are simple and powerful patterns, known as `container` and `presentational`,
    which we can apply when creating components that help us to separate those two
    concerns.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，有一些简单而强大的模式，称为`container`和`presentational`，我们可以在创建组件时应用这些模式，帮助我们分离这两个关注点。
- en: Creating well-defined boundaries between logic and presentation not only makes
    components more reusable, but also provides many other benefits, which you will
    learn about in this section. Again, one of the best ways to learn new concepts
    is by seeing practical examples, so let’s delve into some code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑和表示之间创建明确的边界不仅使组件更可重用，还提供了许多其他好处，你将在本节中了解到。再次强调，学习新概念的最佳方法之一是通过查看实际示例，所以让我们深入一些代码。
- en: Suppose we have a component that uses geolocation APIs to get the position of
    the user and displays the latitude and longitude on the page in the browser.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个组件，它使用地理位置API来获取用户的当前位置，并在浏览器页面上显示纬度和经度。
- en: 'First, we create a `Geolocation.tsx` file in our `components` folder and define
    the `Geolocation` component using a functional component:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`components`文件夹中创建一个`Geolocation.tsx`文件，并使用函数组件定义`Geolocation`组件：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then define our states:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义我们的状态：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can use the `useEffect` Hook to fire the request to the APIs:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`useEffect` Hook来触发对API的请求：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the browser returns the data, we store the result in the state using the
    following function (place this function before the `useEffect` Hook):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器返回数据时，我们使用以下函数将结果存储在状态中（在`useEffect` Hook之前放置此函数）：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we show the latitude and longitude values:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们显示纬度和经度值：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is important to note that, during the first render, the latitude and longitude
    are null because we asked the browser for the coordinates when the component was
    mounted. In a real-world component, you might want to display a spinner until
    the data gets returned. To do that, you can use one of the conditional techniques
    we saw in *Chapter 3*, *Cleaning Up Your Code*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在第一次渲染时，纬度和经度是空的，因为我们是在组件挂载时请求浏览器的坐标。在现实世界的组件中，你可能想在数据返回之前显示一个加载指示器。为此，你可以使用我们在*第3章*，*清理你的代码*中看到的一种条件技术。
- en: Now, this component does not have any problems, and it works as expected. Wouldn’t
    it be nice to separate it from the part where the position gets requested and
    loaded to iterate faster on it?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个组件没有任何问题，并且按预期工作。如果能够将其与请求和加载位置的部分分开，以便更快地迭代它，那岂不是很好？
- en: We will use the container and presentational patterns to isolate the presentational
    part. In this pattern, every component is split into two smaller ones, each one
    with its clear responsibilities. The container knows everything about the logic
    of the component and is where the APIs are called. It also deals with data manipulation
    and event handling.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用容器和表示模式来隔离表示部分。在这个模式中，每个组件都被分成两个更小的组件，每个组件都有其明确的职责。容器了解组件的所有逻辑，是调用API的地方。它还处理数据处理和事件处理。
- en: The presentational component is where the UI is defined, and it receives data
    in the form of props from the container. Since the presentational component is
    usually logic-free, we can create it as a functional, stateless component.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 表示组件是定义UI的地方，它从容器接收以props形式的数据。由于表示组件通常没有逻辑，我们可以将其创建为一个无状态的函数组件。
- en: There are no rules that say that the presentational component must not have
    a state (for example, it could keep a UI state inside it). In this case, we need
    a component to display the latitude and longitude, so we are going to use a simple
    function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 没有规则规定表示组件不能有状态（例如，它可以在内部保持UI状态）。在这种情况下，我们需要一个组件来显示纬度和经度，所以我们将使用一个简单的函数。
- en: 'First of all, we should rename our `Geolocation` component `GeolocationContainer`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该将我们的`Geolocation`组件重命名为`GeolocationContainer`：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will also change the filename from `Geolocation.tsx` to `GeolocationContainer.tsx`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将更改文件名，从`Geolocation.tsx`更改为`GeolocationContainer.tsx`。
- en: This rule is not strict, but it is a best practice that’s widely used in the
    React community to append `Container` to the end of the `Container` component
    name and give the original name to the presentational one.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则并不是强制性的，但在React社区中广泛使用的一种最佳实践是在`Container`组件名称的末尾附加`Container`，并将原始名称给表示组件。
- en: 'We also have to change the implementation of `render` and remove all the UI
    parts of it, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须更改`render`的实现，并从中删除所有UI部分，如下所示：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see in the preceding snippet, instead of creating the HTML elements
    inside the return of the container, we just use the presentational one (which
    we will create next), and we pass the state to it. The states are the latitude
    and longitude, which are null by default, and they contain the real position of
    the user when the browser fires the callback.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文片段所示，我们不是在容器的返回值内部创建HTML元素，而是使用当前的表现性组件（我们将在下一节创建），并将状态传递给它。这些状态是纬度和经度，默认为null，当浏览器触发回调时，它们包含用户的实际位置。
- en: 'Let’s create a new file, called `Geolocation.tsx`, where we define the functional
    component as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新文件，命名为`Geolocation.tsx`，在其中定义如下功能组件：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Functional components are an incredibly elegant way to define UIs. They are
    pure functions that, given a state, return the elements of it. In this case, our
    function receives the latitude and longitude from the owner, and it returns the
    markup structure to display it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 功能组件是定义UI的一种极其优雅的方式。它们是纯函数，给定一个状态，就返回它的元素。在这种情况下，我们的函数从所有者那里接收纬度和经度，并返回用于显示的标记结构。
- en: The first time you run the components in the browser, the browser will require
    your permission to allow it to know your location.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次在浏览器中运行组件时，浏览器将要求您授权以允许它知道您的位置。
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_04_01.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B18414_04_01.png)'
- en: 'Figure 4.1: Browser will require your permission to access your location'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：浏览器将要求您的权限以访问您的位置
- en: 'After you allow the browser to know your location, you will see something like
    this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在您允许浏览器知道您的位置后，您将看到如下内容：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_04_02.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B18414_04_02.png)'
- en: 'Figure 4.2: Displaying latitude and longitude'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：显示纬度和经度
- en: In adherence to the container and presentational pattern, we have created a
    “dumb” or presentational component that is reusable and can be effortlessly integrated
    into our components. This enables us to conveniently pass mock coordinates for
    testing or demonstration purposes. If a similar data structure is needed elsewhere
    in the application, it eliminates the necessity of building a new component from
    scratch. Instead, we can encapsulate this existing component within a new container.
    This container could, for example, be designed to retrieve latitude and longitude
    information from a separate endpoint.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循容器和表现性模式，我们创建了一个“哑”或表现性组件，它是可重用的，并且可以轻松地集成到我们的组件中。这使得我们可以方便地传递模拟坐标进行测试或演示。如果应用程序的其他地方需要类似的数据结构，它消除了从头开始构建新组件的需要。相反，我们可以在新容器中封装这个现有的组件。例如，这个容器可以设计为从单独的端点检索纬度和经度信息。
- en: At the same time, other developers in our team can improve the container that
    uses geolocation by adding some error-handling logic, without affecting its presentation.
    They can even build a temporary presentational component just to display and debug
    data and then replace it with the real presentational component when it is ready.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们团队中的其他开发者可以通过添加一些错误处理逻辑来改进使用地理位置的容器，而不会影响其展示。他们甚至可以构建一个临时的表现性组件，仅用于显示和调试数据，然后在准备就绪时替换为真实的表现性组件。
- en: Being able to work in parallel on the same component is a big win for teams,
    especially for those companies where building interfaces is an iterative process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在同一个组件上并行工作对团队来说是一个巨大的胜利，尤其是对于那些构建界面是一个迭代过程的公司。
- en: This pattern is simple but very powerful, and when applied to big applications,
    it can make a difference when it comes to the speed of development and the maintainability
    of the project. On the other hand, applying this pattern without a real reason
    can give us the opposite problem and make the code base less useful as it involves
    the creation of more files and components.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式简单但非常强大，当应用于大型应用程序时，它可以在开发速度和项目的可维护性方面产生差异。另一方面，如果没有真正的原因就应用这种模式，可能会带来相反的问题，使代码库变得不那么有用，因为它涉及到创建更多文件和组件。
- en: So, we should think carefully when we decide that a component has to be refactored
    following the container and presentational patterns. In general, the right path
    to follow is starting with a single component and splitting it only when the logic
    and the presentation become too coupled where they shouldn’t be.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们决定一个组件必须按照容器和展示模式进行重构时，我们应该仔细思考。一般来说，正确的路径是从一个单一组件开始，只有在逻辑和展示变得过于耦合时才将其拆分。
- en: 'In our example, we began with a single component, and we realized that we could
    separate the API call from the markup. Deciding what to put in the container and
    what goes into the presentation is not always straightforward; the following points
    should help you make that decision:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们从一个单一组件开始，并意识到我们可以将 API 调用与标记分离。决定将什么放入容器以及什么进入展示并不总是直接的；以下要点应有助于你做出这个决定：
- en: 'The following are the characteristics of container components:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些容器组件的特点：
- en: They are more concerned with behavior.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们更关注行为。
- en: They render their presentational components.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们渲染它们的展示组件。
- en: They make API calls and manipulate data.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们执行 API 调用并操作数据。
- en: They define event handlers.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们定义事件处理器。
- en: 'The following are the characteristics of presentational components:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些展示组件的特点：
- en: They are more concerned with the visual representation.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们更关注视觉表示。
- en: They render the HTML markup (or other components).
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们渲染 HTML 标记（或其他组件）。
- en: They receive data from the parents in the form of props.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们以 props 的形式从父组件接收数据。
- en: They are often written as stateless functional components.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通常被写成无状态的函数组件。
- en: As you can see, these patterns form a really powerful tool that will help you
    to develop your web applications faster. Let’s see what HOCs are in the next section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些模式形成了一个非常强大的工具，将帮助你更快地开发你的网络应用程序。让我们看看下一节中 HOCs 是什么。
- en: Understanding HOCs
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 HOCs
- en: In the *functional programming* section of *Chapter 3*, *Cleaning Up Your Code*,
    we introduced the concept of **higher-order functions** (**HOFs**). HOFs are functions
    that accept another function as an argument, enhance its behavior, and return
    a new function. Applying the idea of HOFs to components results in **higher-order
    components** (**HOCs**).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章 *清理你的代码* 的 *函数式编程* 部分，我们介绍了 **高阶函数**（**HOFs**）的概念。HOFs 是接受另一个函数作为参数、增强其行为并返回一个新函数的函数。将
    HOFs 的想法应用于组件会导致 **高阶组件**（**HOCs**）的产生。
- en: 'An HOC looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 HOC 看起来是这样的：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: HOCs are functions that take a component as input and return an enhanced component
    as output. Let’s start with a simple example to understand what an enhanced component
    looks like.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: HOCs 是接受一个组件作为输入并返回一个增强组件作为输出的函数。让我们从一个简单的例子开始，了解增强组件是什么样的。
- en: 'Suppose you need to attach the same `className` property to every component.
    You could manually add the `className` property to each render method, or you
    could write an HOC like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要将相同的 `className` 属性附加到每个组件上。你可以手动将 `className` 属性添加到每个渲染方法中，或者你可以编写一个像这样的
    HOC：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the React community, it’s common to use the `with` prefix for HOCs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 社区中，使用 `with` 前缀为 HOCs（高阶组件）是常见的。
- en: The code above might be confusing at first, so let’s break it down. We declare
    a `withClassName` function that takes a `Component` and returns another function.
    The returned function is a functional component that receives some props and renders
    the original component. The collected props are spread, and a `className` property
    with the `"my-class"` value is passed to the functional component.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码一开始可能让人感到困惑，所以让我们来分解一下。我们声明了一个 `withClassName` 函数，它接受一个 `Component` 并返回另一个函数。返回的函数是一个函数组件，它接收一些属性并渲染原始组件。收集到的属性被展开，并传递一个值为
    `"my-class"` 的 `className` 属性给函数组件。
- en: HOCs typically spread the props they receive on the component because they aim
    to be transparent and only add new behavior.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: HOCs 通常会传播它们接收的属性，因为它们旨在保持透明并仅添加新行为。
- en: While this example is simple and not particularly useful, it should give you
    a better understanding of what HOCs are and what they look like. Now, let’s see
    how we can use the `withClassName` HOC in our components.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子很简单且并不特别有用，但它应该能让你更好地理解 HOCs 是什么以及它们看起来像什么。现在，让我们看看我们如何在组件中使用 `withClassName`
    HOC。
- en: 'First, create a stateless functional component that receives the `className`
    and applies it to a `div` tag:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个接收 `className` 并将其应用于 `div` 标签的无状态函数组件：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Instead of using the component directly, we pass it to an HOC like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 不是直接使用组件，而是将其传递给一个HOC，如下所示：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Wrapping our components in the `withClassName` function ensures that they receive
    the `className` property.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的组件包裹在`withClassName`函数中确保它们接收`className`属性。
- en: 'Now, let’s create a more exciting HOC to detect the `innerWidth`. First, create
    a function that receives a `Component`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个更令人兴奋的HOC来检测`innerWidth`。首先，创建一个接收`Component`的函数：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It’s common practice to prefix HOCs that provide information to the components
    they enhance using the `with` pattern.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`with`模式为增强组件提供信息的HOCs通常会有前缀。
- en: 'Next, define the `innerWidth` state and the `handleResize` function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义`innerWidth`状态和`handleResize`函数：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, add the effects:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加效果：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, render the original component like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照如下方式渲染原始组件：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we spread the props as before, but we also pass the `innerWidth` state.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们像之前一样展开属性，但同时也传递了`innerWidth`状态。
- en: We store the `innerWidth` value as a state to achieve the original behavior
    without polluting the component’s state. Instead, we use props. Using props is
    an excellent way to promote reusability.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`innerWidth`值存储为状态，以在不污染组件状态的情况下实现原始行为。相反，我们使用属性。使用属性是提高可重用性的绝佳方式。
- en: 'Now, using an HOC and getting the `innerWidth` value is straightforward. The
    new React Hooks can easily replace an HOC by creating custom Hooks. Create a functional
    component that expects `innerWidth` as a property:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用HOC和获取`innerWidth`值是直接的。新的React Hooks可以通过创建自定义Hooks轻松地替换HOC。创建一个期望`innerWidth`作为属性的函数组件：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Enhance it as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如下增强它：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By using HOCs, we avoid polluting any state and don’t require the component
    to implement any function. This means the component and HOC are not coupled, and
    both can be reused throughout the application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用HOCs，我们避免了任何状态的污染，并且不需要组件实现任何函数。这意味着组件和HOC不是耦合的，并且可以在整个应用程序中重用。
- en: Using props instead of state allows us to create a “dumb” component that can
    be used in our style guide, ignoring complex logic and just passing down the props.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性而不是状态，我们可以创建一个“哑”组件，可以在我们的风格指南中使用，忽略复杂的逻辑，只需传递属性。
- en: 'In this specific case, we could create a component for each of the different
    `innerWidth` sizes we support. Consider the following example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，我们可以为支持的每个不同的`innerWidth`大小创建一个组件。考虑以下示例：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Or the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如下：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, by using HOCs, we can pass a component and then return a new
    component with additional functionalities. Some common HOCs are `connect` from
    Redux and `createFragmentContainer` from Relay.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过使用高阶组件（HOCs），我们可以传递一个组件，然后返回一个具有额外功能的新组件。一些常见的HOCs包括来自Redux的`connect`和来自Relay的`createFragmentContainer`。
- en: Understanding FunctionAsChild
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解函数作为子组件
- en: The `FunctionAsChild`pattern is gaining consensus within the React community.
    It is widely used in popular libraries like **react-motion**, which we will explore
    in *Chapter 5*, *Writing Code for the Browser*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`FunctionAsChild`模式在React社区中得到了共识。它在像**react-motion**这样的流行库中广泛使用，我们将在第5章*为浏览器编写代码*中探讨。'
- en: 'The main concept is that instead of passing a child as a component, we define
    a function that can receive parameters from the parent. Let’s see what it looks
    like:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 主要概念是，我们不是将子组件作为组件传递，而是定义一个可以接收来自父组件参数的函数。让我们看看它是什么样子：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, `FunctionAsChild` is a component with a children property defined
    as a function. Instead of being used as a JSX expression, it gets called.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`FunctionAsChild`是一个具有子属性定义为函数的组件。它不是用作JSX表达式，而是被调用。
- en: 'The preceding component can be used like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的组件可以这样使用：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This example is quite simple: the children function is executed within the
    parent’s render method, returning the `Hello, World!` text wrapped in a `div`
    tag, which is displayed on the screen.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子相当简单：子函数在父组件的渲染方法中执行，返回包裹在`div`标签中的`Hello, World!`文本，该文本在屏幕上显示。
- en: Now, let’s explore a more meaningful example where the parent component passes
    some parameters to the children function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索一个更有意义的例子，其中父组件将一些参数传递给子函数。
- en: 'Create a `Name` component that expects a function as children and passes it
    the `''World''` string:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Name`组件，它期望一个函数作为子组件，并将`'World'`字符串传递给它：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding component can be used like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的组件可以这样使用：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The primary advantage is the ability to encapsulate components, delivering
    variables dynamically, as opposed to utilizing static properties, which is a common
    practice with HOCs. An excellent illustration of this is a `Fetch` component,
    designed to retrieve data from a specific API endpoint and subsequently return
    it to its child function:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要优势是能够封装组件，动态传递变量，而不是使用静态属性，这是高阶组件中常见的做法。一个很好的例子是`Fetch`组件，它被设计用来从特定的API端点检索数据，并将其随后返回给其子函数：
- en: '[PRE33]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Secondly, composing components with this approach does not force children to
    use predefined prop names. Since the function receives variables, developers who
    use the component can decide on their names. This flexibility makes the Function
    as Child solution more versatile.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，使用这种方法组合组件不会强迫子组件使用预定义的prop名称。由于函数接收变量，使用该组件的开发者可以决定它们的名称。这种灵活性使得“函数作为子组件”解决方案更加灵活。
- en: Lastly, the wrapper is highly reusable because it does not make any assumptions
    about the children it receives—it just expects a function. Due to this, the same
    `FunctionAsChild` component can be used in different parts of the application
    to serve various children components.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，包装器非常可重用，因为它不对接收到的子组件做出任何假设——它只期望一个函数。因此，同一个`FunctionAsChild`组件可以在应用程序的不同部分使用，以服务于各种子组件。
- en: By adopting the Function as Child pattern, you can create more flexible, versatile,
    and reusable components in your React applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用“函数作为子组件”模式，你可以在React应用程序中创建更灵活、多功能和可重用的组件。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to effectively compose and communicate between
    our reusable components using props. By using props, we can create well-defined
    interfaces and decouple our components from each other.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何有效地使用props来组合和通信我们的可重用组件。通过使用props，我们可以创建定义良好的接口，并使我们的组件彼此解耦。
- en: 'We also explored two popular composition patterns: the container and presentational
    pattern, which help us separate our logic and presentation for more specialized
    and focused components. Additionally, we discovered **Higher-Order Components**
    (**HOCs**) as a way to handle context without tightly coupling our components
    to it, and the Function as Child pattern for composing components dynamically.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探索了两种流行的组合模式：容器模式和展示模式，这些模式帮助我们分离逻辑和展示，以便为更专业和专注的组件提供支持。此外，我们还发现了**高阶组件**（**HOCs**）作为处理上下文的一种方式，它允许我们不必将组件紧密耦合到上下文中，以及用于动态组合组件的“函数作为子组件”模式。
- en: In the next chapter, we will dive into controlled vs. uncontrolled components,
    refs, handling events, and animations in React.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨受控组件与不受控组件、refs、处理事件和React中的动画。
