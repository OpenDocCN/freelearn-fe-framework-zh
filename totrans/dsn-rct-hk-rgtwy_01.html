<html><head></head><body>
		<div id="_idContainer008">
			<h1 id="_idParaDest-17"><em class="italic"><a id="_idTextAnchor018"/>Chapter 1</em>: Introducing the Function Component</h1>
			<p>In this chapter, we will first start with a brief history of <em class="italic">UI</em> components developed over the past two decades and get to know how <em class="italic">React</em> uses <em class="italic">UI</em> components to put together an application. You will learn what a function component is, with an explanation of its props and the basic parent/child relationship. You will then get some tips on how to write a function component. At the end, you will see a practical function component example, <strong class="source-inline">Nav</strong>. The chapter also includes one bonus topic in the <em class="italic">Appendix</em> section: <em class="italic">How many component types does React support?</em></p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>History of <em class="italic">UI</em> components</li>
				<li>Building an app with components</li>
				<li>Introducing the function component</li>
				<li>Writing a function component</li>
				<li>Example of a function component</li>
				<li>Questions and answers</li>
				<li>Appendix</li>
			</ul>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor019"/>History of UI components</h1>
			<p>While we are fascinated by technology, it can also be intriguing to watch how slowly it evolves over <a id="_idIndexMarker000"/>time. In our case, it's <em class="italic">HTML</em>. On the surface, it doesn't appear to have changed for the past 20 years. You get that idea by comparing a typical web page written now with one written 20 years ago, and seeing that they look very similar, if not identical. </p>
			<p>The following snippet shows what typical <em class="italic">HTML</em> page code looks like:</p>
			<p class="source-code"><strong class="bold">&lt;HTML&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;head&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;meta</strong> <strong class="bold">charset</strong>="utf-8"<strong class="bold">&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;/head&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;style&gt;</strong></p>
			<p class="source-code">    h1 { <strong class="bold">color</strong>: red; }</p>
			<p class="source-code">  <strong class="bold">&lt;/style&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;script&gt;</strong></p>
			<p class="source-code">    console.log('start...')</p>
			<p class="source-code">  <strong class="bold">&lt;/script&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;body&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;h1&gt;</strong>Hello World<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;/body&gt;</strong> </p>
			<p class="source-code"><strong class="bold">&lt;/HTML&gt;</strong></p>
			<p>Those of us who have been in this industry long enough know that the web has been reshaped a couple of times. In particular, a tremendous amount of effort has been spent on how to generate the preceding <em class="italic">HTML</em>.</p>
			<p>Web engineers have tried to divide the file up into multiple parts, including <em class="italic">HTML</em>, <em class="italic">JavaScript</em>, and <em class="italic">CSS</em>, and then put it back together upon rendering the file onscreen. They have also tried to load one or two parts on servers, and the rest on client computers. They have also tried various compilers or builders to autogenerate the file after each change to the source code. They have tried lots of things. Actually, almost anything <a id="_idIndexMarker001"/>you can think of regarding <em class="italic">HTML</em> has been tried a couple of times in the past, and people will not stop trying something just because someone else has tried it. In a sense, web technology gets re-invented every once in a while. </p>
			<p>With so much new content being added to the web every day, engineers have found the <em class="italic">HTML</em> files a bit unmanageable. On the one hand, the demand is that users want to see more actionable items with quicker responses and, on the other hand, many of these actionable items on the screen create challenges for engineers to manage the workload and maintain the code base. </p>
			<p>So, engineers are on a constant lookout for better ways to organize <em class="italic">HTML</em> files. If this organization <a id="_idIndexMarker002"/>is done right, it can help them not get overwhelmed by a plethora of elements on the screen. At the same time, organizing files well means a scalable project, since the team can divide the project into smaller pieces and work on each in a divide-and-conquer way.</p>
			<p>Let's take a look at the history of how technologies using <em class="italic">JavaScript</em> assisted with these topics. We will choose four technologies for this conversation – <em class="italic">jQuery</em>, <em class="italic">Angular</em>, <em class="italic">React</em>, and <em class="italic">LitElemen<a id="_idTextAnchor020"/>t</em>.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor021"/>jQuery</h2>
			<p><em class="italic">jQuery</em> is a library used to manipulate the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) elements on the <a id="_idIndexMarker003"/>screen. It recognizes <a id="_idIndexMarker004"/>the challenges of working with the <em class="italic">DOM</em> directly, thereby <a id="_idIndexMarker005"/>providing a utility layer to simplify the syntax of finding, selecting, and manipulating <em class="italic">DOM</em> elements. It was developed in 2006 and has been used by millions of websites since then.</p>
			<p>What's great about jQuery is that it can work with an existing <em class="italic">HTML</em> by creating a wrapper around it using the famous <strong class="source-inline">$</strong> symbol, as you can see in the following code:</p>
			<p class="source-code">$(document).ready(<strong class="bold">function</strong>(){</p>
			<p class="source-code">  $("button").click(<strong class="bold">function</strong>(){</p>
			<p class="source-code">    $(<strong class="bold">this</strong>).css("background-color", "yellow");</p>
			<p class="source-code">    $("#div3").fadeIn(3000);</p>
			<p class="source-code">    $("#p1").css("color", "red")</p>
			<p class="source-code">      .slideUp(2000)</p>
			<p class="source-code">      .slideDown(2000);</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p class="source-code"><strong class="bold">function</strong> appendText() {</p>
			<p class="source-code">  <strong class="bold">var</strong> txt1 = "&lt;p&gt;Text.&lt;/p&gt;";       </p>
			<p class="source-code">  <strong class="bold">var</strong> txt2 = $("&lt;p&gt;&lt;/p&gt;").text("Text.");</p>
			<p class="source-code">  <strong class="bold">var</strong> txt3 = document.createElement("p");</p>
			<p class="source-code">  txt3.innerHTML = "Text.";</p>
			<p class="source-code">  $("body").append(txt1, txt2, txt3);</p>
			<p class="source-code">}</p>
			<p><em class="italic">jQuery</em> didn't have much competition when it came to changing color, font, or any attribute of an <a id="_idIndexMarker006"/>element at runtime. It made it possible to organize large <a id="_idIndexMarker007"/>chunks of business logic code into functions stored in multiple files. It also provided a modular way to create reusable UI widgets through one of its plugins at the time.</p>
			<p>Complete separation between <em class="italic">HTML</em> and <em class="italic">JavaScript</em> was strongly favored back then. At that time, people believed that this way of doing things helped to raise productivity, since people who work with website styles and behaviors can be from two departments. Theming, the word describing the application of style to a site, was gaining popularity and some jobs were looking for developers who could make a site look as beautiful as a Photoshop <a id="_idTextAnchor022"/>design.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor023"/>Angular</h2>
			<p><em class="italic">Angular</em> is a web framework used to develop a <strong class="bold">Single-Page Application</strong> (<strong class="bold">SPA</strong>). It was invented <a id="_idIndexMarker008"/>by <em class="italic">Google</em> in 2010. It was quite revolutionary at the time, because <a id="_idIndexMarker009"/>you could build a frontend application with it. This means <a id="_idIndexMarker010"/>that the code written in <em class="italic">Angular</em> could take over the body of <em class="italic">HTML</em> and apply logic to all elements within it at runtime. All code was run at the browser level, resulting in the word "frontend" starting to appear in job résumés. Since then, web developers have been roughly categorized as "backend," "frontend," and "full stack" (which means both frontend and backend).</p>
			<p>The code that <em class="italic">Angular</em> uses continues to be built on existing <em class="italic">HTML</em> by attaching additional tags to it like so:</p>
			<p class="source-code"><strong class="bold">&lt;body&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;div</strong> <strong class="bold">ng-app</strong>="myApp" <strong class="bold">ng-controller</strong>="myCtrl"<strong class="bold">&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;p&gt;</strong>Name: <strong class="bold">&lt;input</strong> <strong class="bold">type</strong>="text" <strong class="bold">ng-model</strong>="name" <strong class="bold">/&gt;&lt;/p&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;script&gt;</strong></p>
			<p class="source-code">    <strong class="bold">var</strong> app = angular.module('myApp', []);</p>
			<p class="source-code">    app.controller('myCtrl', <strong class="bold">function</strong>($scope) {</p>
			<p class="source-code">      $scope.name= "John";</p>
			<p class="source-code">    });</p>
			<p class="source-code">  <strong class="bold">&lt;/script&gt;</strong></p>
			<p class="source-code"><strong class="bold">&lt;/body&gt;</strong></p>
			<p>The controller and <a id="_idIndexMarker011"/>module introduced by <em class="italic">Angular</em> can imbue business logic to <a id="_idIndexMarker012"/>sections of <em class="italic">HTML</em> with unique scopes. <em class="italic">Angular</em> supports components and directives out of the box, which allows us to reference all relevant <em class="italic">HTML</em> and <em class="italic">JavaScript</em> together in a single file (although the <em class="italic">HTML</em> file still needs to be written in a separate file):</p>
			<p class="source-code"><strong class="bold">function</strong> HeroListController($scope, $element, $attrs) {</p>
			<p class="source-code">  <strong class="bold">var</strong> ctrl = <strong class="bold">this</strong>;</p>
			<p class="source-code">  ctrl.updateHero = <strong class="bold">function</strong>(hero, prop, value) {</p>
			<p class="source-code">    hero[prop] = value;</p>
			<p class="source-code">  };</p>
			<p class="source-code">  ctrl.deleteHero = <strong class="bold">function</strong>(hero) {</p>
			<p class="source-code">    <strong class="bold">var</strong> idx = ctrl.list.indexOf(hero);</p>
			<p class="source-code">    <strong class="bold">if</strong> (idx &gt;= 0) {</p>
			<p class="source-code">      ctrl.list.splice(idx, 1);</p>
			<p class="source-code">    }</p>
			<p class="source-code">  };</p>
			<p class="source-code">}</p>
			<p class="source-code">angular.module('heroApp').component('heroList', {</p>
			<p class="source-code">  templateUrl: 'heroList.html',</p>
			<p class="source-code">  controller: HeroListController</p>
			<p class="source-code">});</p>
			<p>The component <a id="_idIndexMarker013"/>created via Angular can be reused afterward in <a id="_idTextAnchor024"/>an HTML <a id="_idIndexMarker014"/>file.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor025"/>React</h2>
			<p><em class="italic">React</em>, also known as <em class="italic">React.js</em>, was developed by <em class="italic">Facebook</em> and released in 2013 as a <em class="italic">JavaScript</em> library <a id="_idIndexMarker015"/>for building <em class="italic">UI</em> components. Although it wasn't specifically <a id="_idIndexMarker016"/>marketed as a web framework, it has been used by developers to build single-page or mobile applications, and has been favored by start-up companies in particular ever since.</p>
			<p>What was controversial at the time was how it treated <em class="italic">HTML</em> statements. Instead of leaving them in a <em class="italic">HTML</em> file, it actually asked to take them out and put under a <strong class="source-inline">render</strong> function of a component, like so:</p>
			<p class="source-code"><strong class="bold">&lt;div</strong> id="root"<strong class="bold">&gt;&lt;/div&gt;</strong></p>
			<p class="source-code"><strong class="bold">&lt;script</strong> type="text/babel"<strong class="bold">&gt;</strong></p>
			<p class="source-code">  class App extends React.Component {</p>
			<p class="source-code">    render() {</p>
			<p class="source-code">      <strong class="bold">return &lt;h1&gt;</strong>Hello World<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  ReactDOM.render(App, document.getElementById('root'));</p>
			<p class="source-code"><strong class="bold">&lt;/script&gt;</strong></p>
			<p>This unique approach favors the component design much more than the integrity of the <em class="italic">HTML</em> file. This was (almost) the first time you could put <em class="italic">HTML</em> and <em class="italic">JavaScript</em> together under the same file. We call it <em class="italic">HTML</em> here because it looks like <em class="italic">HTML</em>, but actually <em class="italic">React</em> creates a wrapper to transform the <em class="italic">HTML</em> into <em class="italic">JavaScript</em> statements. </p>
			<p>When <em class="italic">React</em> was introduced, it came with a class component and in 2015, it added support for a function component, so you can write the logic under a function instead of a class:</p>
			<p class="source-code"><strong class="bold">&lt;script</strong> type="text/babel"<strong class="bold">&gt;</strong></p>
			<p class="source-code">  const App = function() {</p>
			<p class="source-code">    <strong class="bold">return &lt;h1&gt;</strong>Hello World<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">  }</p>
			<p class="source-code"><strong class="bold">&lt;/script&gt;</strong></p>
			<p>With <em class="italic">React</em>, the <em class="italic">HTML</em> files don't get touched as often as they used to be; in fact, they don't get changed <a id="_idIndexMarker017"/>at all, since the <em class="italic">HTML</em> content is all relocated to <em class="italic">React</em> components. This approach can still be controversial today because people who don't care <a id="_idIndexMarker018"/>about the location of the <em class="italic">HTML</em> would get onboard very easily, whereas people who care about the classical way of writing <em class="italic">HTML</em> would stay away. There's also a mentality shift here; with <em class="italic">React</em>, <em class="italic">JavaScript</em> becomes the focus o<a id="_idTextAnchor026"/>f web development.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor027"/>LitElement</h2>
			<p><em class="italic">Polymer</em> was developed by <em class="italic">Google</em> and released in 2015, designed to build web applications using <a id="_idIndexMarker019"/>web components. In 2018, the <em class="italic">Polymer</em> team <a id="_idIndexMarker020"/>announced that any future development would be shifted to <em class="italic">LitElement</em> to create fast and lightweight web components:</p>
			<p class="source-code">@customElement('my-element')</p>
			<p class="source-code">export <strong class="bold">class</strong> MyElement <strong class="bold">extends</strong> LitElement {</p>
			<p class="source-code">  ...</p>
			<p class="source-code">  render() {</p>
			<p class="source-code">    <strong class="bold">return</strong> html`</p>
			<p class="source-code">      &lt;h1&gt;Hello, ${<strong class="bold">this</strong>.name}!&lt;/h1&gt;</p>
			<p class="source-code">      &lt;button @click=${<strong class="bold">this</strong>._onClick}&gt;</p>
			<p class="source-code">        Click Count: ${<strong class="bold">this</strong>.count}</p>
			<p class="source-code">      &lt;/button&gt;</p>
			<p class="source-code">      &lt;slot&gt;&lt;/slot&gt;</p>
			<p class="source-code">    `;</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>There are quite a few similarities between <em class="italic">React</em> and <em class="italic">LitElement</em> since it allows you to define a class <a id="_idIndexMarker021"/>component with a <strong class="source-inline">render</strong> function. What's unique <a id="_idIndexMarker022"/>about <em class="italic">LitElement</em> is that once the element is registered, it can behave like a DOM element:</p>
			<p class="source-code"><strong class="bold">&lt;body&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;h1&gt;</strong>Hello World<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;my-element</strong> <strong class="bold">name</strong>="abc"<strong class="bold">&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;p&gt;</strong></p>
			<p class="source-code">      Let's get started.</p>
			<p class="source-code">    <strong class="bold">&lt;/p&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;/my-element&gt;</strong></p>
			<p class="source-code"><strong class="bold">&lt;/body&gt;</strong></p>
			<p>There's no apparent entry point for integrating <em class="italic">LitElement</em> into <em class="italic">HTML</em> since it doesn't need to gain control of a <strong class="source-inline">body</strong> element before using it. We can design the element somewhere else, and when it comes to its use, it's more like using an <strong class="source-inline">h1</strong> element. Therefore, it perfectly preserves the integrity of the HTML file while outsourcing the additional capability to the custom element, which can be designed by others. </p>
			<p>The goal of <em class="italic">LitElement</em> is to have the web component work in any web page <a id="_idTextAnchor028"/>within any framework. </p>
			<p>20 years ago, we didn't know what the web would become. From this brief historical review of <em class="italic">jQuery</em>, <em class="italic">Angular</em>, <em class="italic">React</em>, and <em class="italic">LitElement</em>, it's clear that an idea of having <em class="italic">UI</em> components has emerged. A component, like a block of LEGO, can do the following:</p>
			<ul>
				<li>Encapsulate functionalities inside</li>
				<li>Be reused in other places </li>
				<li>Not jeopardize the existing site</li>
			</ul>
			<p>Thus, when we use the component, it takes the following syntax:</p>
			<p class="source-code"><strong class="bold">&lt;component</strong> <strong class="bold">attr</strong>="Title"<strong class="bold">&gt;</strong>Hello World<strong class="bold">&lt;/component&gt;</strong></p>
			<p>Essentially, this isn't too different from where we started with writing <em class="italic">HTML</em>:</p>
			<p class="source-code"><strong class="bold">&lt;h1</strong> <strong class="bold">title</strong>="Title"<strong class="bold">&gt;</strong>Hello World<strong class="bold">&lt;/h1&gt;</strong></p>
			<p>There's a hidden <a id="_idIndexMarker023"/>requirement for a component here. While the components <a id="_idIndexMarker024"/>can be designed separately, in the end, they have to be put together to serve a higher purpose, to finish building a site. Therefore, as atomic as each component is, there still needs to be a communication layer to allow blocks to talk to one another.</p>
			<p>As long as components are functioning and there is communication between them, the app can function as a whole. This is actually the assumption of a component design along with building a site.</p>
			<p>So, into what category does our book fall? Our book is about building components under <em class="italic">React</em>, especially building smart components that can serve as a reusable block and are able to fit in an app. The technology we have chosen here is hooks inside a function component. </p>
			<p>Before we get into the details of components and hooks, let's first take a brief look at how components can be put together t<a id="_idTextAnchor029"/>o build an application. </p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor030"/>Building an app with components</h1>
			<p>To start building <a id="_idIndexMarker025"/>an application, here's a block <a id="_idIndexMarker026"/>of <em class="italic">HTML</em> you can start with:</p>
			<p class="source-code">&lt;!doctype HTML&gt;</p>
			<p class="source-code"><strong class="bold">&lt;HTML</strong> <strong class="bold">lang</strong>="en"<strong class="bold">&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;body&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;div</strong> <strong class="bold">id</strong>="root"<strong class="bold">&gt;&lt;/div&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;/body&gt;</strong>  </p>
			<p class="source-code"><strong class="bold">&lt;/HTML&gt;</strong></p>
			<p>These days, we have more and more <strong class="bold">SPAs</strong> that update parts of pages <a id="_idIndexMarker027"/>on the fly, which makes using the website feel like a native application. A quick response time is what we are aiming for. JavaScript is the language to deliver this goal, from displaying the user interface to running application logic and communicating with the web server. </p>
			<p>To add logic, React takes over one section of the HTML to start a component:</p>
			<p class="source-code"><strong class="bold">&lt;script&gt;</strong></p>
			<p class="source-code">  const App = () =&gt; {</p>
			<p class="source-code">    <strong class="bold">return &lt;h1&gt;</strong>Hello World.<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">  }</p>
			<p class="source-code">  const rootEl = document.getElementById("root")</p>
			<p class="source-code">  ReactDOM.render(&lt;App /&gt;, rootEl)</p>
			<p class="source-code"><strong class="bold">&lt;/script&gt;</strong></p>
			<p>The <strong class="source-inline">render</strong> function in the preceding code, provided by <strong class="source-inline">ReactDOM</strong>, accepts two input arguments, which are a <em class="italic">React</em> element and a <em class="italic">DOM</em> element, <strong class="source-inline">rootEl</strong>. <strong class="source-inline">rootEl</strong> is where you want <em class="italic">React</em> to render, in our case, a <em class="italic">DOM</em> node tagged with the <strong class="source-inline">root</strong> ID. What <em class="italic">React</em> renders to <strong class="source-inline">rootEl</strong> can be found defined in a function component, <strong class="source-inline">App</strong>.</p>
			<p>It's important to tell the difference between <strong class="source-inline">App</strong> and <strong class="source-inline">&lt;App /&gt;</strong> in <em class="italic">React</em>. <strong class="source-inline">App</strong> is a component, and there has to be a definition out there to describe what it can do:</p>
			<p class="source-code">  <strong class="bold">const</strong> App = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">return &lt;h1&gt;</strong>Hello World<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">  }</p>
			<p>Whereas <strong class="source-inline">&lt;App /&gt;</strong> is one instance of the <strong class="source-inline">App</strong> component. A component can have lots of instances <a id="_idIndexMarker028"/>created from it, quite similar to the instance of a <a id="_idIndexMarker029"/>class in most programming languages. Creating an instance out of a component is the first step to reusability.</p>
			<p>If we launch the preceding code in a browser, we should see it display the following <strong class="bold">Hello World</strong> title:</p>
			<div>
				<div id="_idContainer004" class="IMG---Figure">
					<img src="image/Figure_1.01_B17963.jpg" alt="Figure 1.1 – Hello World&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Hello World</p>
			<p class="callout-heading">Playground – Hello World</p>
			<p class="callout">Feel free to play with this example online at <a href="https://codepen.io/windmaomao/pen/ExvYPEX">https://codepen.io/windmaomao/pen/ExvYPEX</a>.</p>
			<p>To have a fully functional application, normally we would need more than one page. Let's ta<a id="_idTextAnchor031"/>ke a look at a second page. </p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor032"/>Multiple pages</h2>
			<p>Building a <strong class="source-inline">"Hello World"</strong> component is the first step. But how does a single component like that <a id="_idIndexMarker030"/>support multiple pages so that we can navigate from one page to another? </p>
			<p>Say we have two pages, both defined in components, <strong class="source-inline">Home</strong> and <strong class="source-inline">Product</strong>:</p>
			<p class="source-code"><strong class="bold">const</strong> Home = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return &lt;h1&gt;</strong>Home Page<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p class="source-code"><strong class="bold">const</strong> Product = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return &lt;h1&gt;</strong>Product Page<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p>To display either <strong class="source-inline">Home</strong> or <strong class="source-inline">Product</strong>, we can create a helper component:</p>
			<p class="source-code"><strong class="bold">const</strong> Route = ({ home }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return</strong> home ? &lt;Home /&gt; : &lt;Product /&gt;</p>
			<p class="source-code">}</p>
			<p>The preceding <strong class="source-inline">Route</strong> component is a bit different; it carries an input argument, <strong class="source-inline">home</strong>, from the <a id="_idIndexMarker031"/>function definition. <strong class="source-inline">home</strong> holds a Boolean value and based on it, the <strong class="source-inline">Route</strong> component can switch between displaying <strong class="source-inline">&lt;Home /&gt;</strong> or <strong class="source-inline">&lt;Product /&gt;</strong>. </p>
			<p>Now it's a matter of determining what the value for <strong class="source-inline">home</strong> in <strong class="source-inline">App is</strong>:</p>
			<p class="source-code"><strong class="bold">const</strong> App = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> home = <strong class="bold">true</strong></p>
			<p class="source-code">  <strong class="bold">return </strong>&lt;Route home={home} /&gt;</p>
			<p class="source-code">}</p>
			<p>In the preceding code, the <strong class="source-inline">App</strong> component is amended to include a <strong class="source-inline">home</strong> variable, which gets passed to the <strong class="source-inline">Route</strong> component. </p>
			<p>You might have noticed that the current code will only display the Home page because we have set <strong class="source-inline">home</strong> to <strong class="source-inline">true</strong>. Don't worry. This whole book is about teaching you how to set the <strong class="source-inline">home</strong> value. For now, just imagine the value would be flipped from <strong class="source-inline">true</strong> to <strong class="source-inline">false</strong> based on a user mouse click, and for the time being, you can manually change the <strong class="source-inline">home</strong> value.</p>
			<p>The <strong class="source-inline">App</strong> component can grow bigger as more and more components are added underneath it with this routing mechanism. This is partly why the first component in a <em class="italic">React</em> application is named <strong class="source-inline">App</strong>. Although you can name it whatever you want, just remember to use a capitalized letter for the first letter.</p>
			<p class="callout-heading">Playground – Home Page</p>
			<p class="callout">Feel free to play with the example online at <a href="https://codepen.io/windmaomao/pen/porzgOy">https://codepen.io/windmaomao/pen/porzgOy</a>.</p>
			<p>Now we can <a id="_idIndexMarker032"/>see how <em class="italic">React</em> puts together an app, so without further ado, let's get to the component in <em class="italic">React</em>.</p>
			<p>There are mainly two component types that <em class="italic">React</em> supports – a class component and a function component. This book will focus on a function component. If you are interested in other component types, please check out the <em class="italic">Appendix A – How many component types does React support?</em> sect<a id="_idTextAnchor033"/>ion at the end of this chapter.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor034"/>Introducing the function component</h1>
			<p class="author-quote">"This pattern is designed to encourage the creation of these simple components that should comprise large portions of your apps." – Sophie Alpert</p>
			<p>In this section, we are going to introduce you to the function component. When the function <a id="_idIndexMarker033"/>component was first introduced in React 0.14 in August 2015, it was named as a stateless pure function:</p>
			<p class="source-code"><strong class="bold">function</strong> StatelessComponent(props) {</p>
			<p class="source-code">  <strong class="bold">return &lt;div&gt;</strong>{props.name}<strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code">}</p>
			<p>The main intention was that "stateless pure-function components give us more opportunity to make performance optimizations." </p>
			<p>A function component with no state, by default, is designed to take the following function form:</p>
			<div>
				<div id="_idContainer005" class="IMG---Figure">
					<img src="image/Figure_1.02_B17963.jpg" alt="Figure 1.2 – Function component definition &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Function component definition </p>
			<p>We are going to <a id="_idIndexMarker034"/>explore parts of a function component in d<a id="_idTextAnchor035"/>etail in the next subsections. </p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor036"/>Function props </h2>
			<p>The input argument <a id="_idIndexMarker035"/>of this function is referred to as a prop. Props take an object format under which we <a id="_idIndexMarker036"/>can define any property. Each property is referred to as a prop. For instance, <em class="italic">Figure 1.2</em> defines a <strong class="source-inline">Title</strong> component with a <strong class="source-inline">text</strong> prop.</p>
			<p>Because props are objects, there's no limitation to how many props can be defined under that object:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ name, onChange, on, url }) <strong class="bold">=&gt;</strong> {...}</p>
			<p>The job of a prop, similar to an input argument, is to pass a value to the function. There is also no limitation in terms of the type of prop. Since each prop is a property of an object, it can be a string, a number, an object, a function, an array, or anything that can be assigned using a <em class="italic">JavaScript</em> expression, as in the following example:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ obj }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return &lt;h1&gt;</strong>{obj.text}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ fn }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return &lt;h1&gt;</strong>{fn()}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p>In the preceding code, the first case passes an <strong class="source-inline">obj</strong> prop carrying a <strong class="source-inline">text</strong> property, while the second case passes an <strong class="source-inline">fn</strong> prop that gets invoked inside.</p>
			<p>Once a function component has been defined, it can be used as many times as you want in other places via its instances:</p>
			<p class="source-code"><strong class="bold">const</strong> App = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return </strong>&lt;Title text="Hello World" /&gt;  </p>
			<p class="source-code">}</p>
			<p>In the preceding code, a <strong class="source-inline">Title</strong> component instance is used in the definition of an <strong class="source-inline">App</strong> component. </p>
			<p>And when the <strong class="source-inline">App</strong> component is updated, a string, <strong class="source-inline">"Hello World"</strong>, is assigned to the <strong class="source-inline">text</strong> prop of the <strong class="source-inline">Title</strong> component. The usage of the <strong class="source-inline">Title</strong> component reminds us of the <em class="italic">HTML</em> statement, and the <strong class="source-inline">text</strong> prop reminds us of the attribute of the <em class="italic">DOM</em> element.</p>
			<p>We have <a id="_idIndexMarker037"/>actually seen the usage of an <strong class="source-inline">App</strong> component <a id="_idIndexMarker038"/>instance as well at the beginning:</p>
			<p class="source-code">  ReactDOM.render(&lt;App /&gt;, rootEl)</p>
			<p>In short, you can define a component, but to see what it displays on the sc<a id="_idTextAnchor037"/>reen, its instance needs to be used.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor038"/>Children prop</h2>
			<p>All the props of a <a id="_idIndexMarker039"/>function component should be defined explicitly, just like input arguments. But, there's a <a id="_idIndexMarker040"/>prop worth knowing early on that isn't apparent to follow this rule. This is called a <strong class="source-inline">children</strong> prop:</p>
			<p class="source-code"><strong class="bold">const</strong> App = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    &lt;Title&gt;</p>
			<p class="source-code">      Hello World</p>
			<p class="source-code">    &lt;/Title&gt;</p>
			<p class="source-code">  )  </p>
			<p class="source-code">}</p>
			<p>You might be using the preceding code without knowing how exactly the <strong class="source-inline">"Hello World"</strong> string is put under the <strong class="source-inline">Title</strong> component. Interestingly, the string is wired to the component via a <strong class="source-inline">children</strong> prop. This will become clear when we get to the definition of the <strong class="source-inline">Title</strong> component:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ children }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return &lt;h1&gt;</strong>{children}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p>Essentially, the <strong class="source-inline">App</strong> component takes <strong class="source-inline">"Hello World"</strong> and assigns it to the <strong class="source-inline">children</strong> prop before invoking the <strong class="source-inline">Title</strong> component instance. You might wonder what happens if we forget to include the <strong class="source-inline">children</strong> prop when defining the <strong class="source-inline">Title</strong> component:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return &lt;h1&gt;</strong>Haha, you got me<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p>In that case, <strong class="source-inline">"Hello World"</strong> is ignored and the <strong class="source-inline">App</strong> component reduces to the following case:</p>
			<p class="source-code"><strong class="bold">const</strong> App = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return </strong>&lt;Title /&gt;</p>
			<p class="source-code">}</p>
			<p>Apparently, this is <a id="_idIndexMarker041"/>not intended since, if you put children elements under a <a id="_idIndexMarker042"/>component, then a <strong class="source-inline">children</strong> prop has to be defined explicitly in the function definition. This means that a <strong class="source-inline">children</strong> prop still needs to be explicitly written on the function interface.</p>
			<p>In fact, the <strong class="source-inline">children</strong> prop is the reason why a component can be nested under another component. <em class="italic">React</em> uses this <strong class="source-inline">children</strong> mechanism to r<a id="_idTextAnchor039"/>eproduce how the <em class="italic">HTML</em> writes in general.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor040"/>Parent and child</h2>
			<p>In <em class="italic">React</em>, props are the mechanism for components talking to one another. We can generalize this <a id="_idIndexMarker043"/>idea by using two components normally involved in the communication to a parent and a child, as we have already seen in <strong class="source-inline">App</strong> and <strong class="source-inline">Title</strong>:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ text }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return &lt;h1&gt;</strong>{text}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p class="source-code"><strong class="bold">const</strong> App = ({ flag }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> text = flag ? "Hello" : "World"</p>
			<p class="source-code">  <strong class="bold">return </strong>&lt;Title text={text} /&gt;</p>
			<p class="source-code">}</p>
			<p>In the preceding example, a <strong class="source-inline">Title</strong> component accepts <strong class="source-inline">text</strong> as one of the props. An <strong class="source-inline">App</strong> component sends the <strong class="source-inline">"Hello"</strong> text to the <strong class="source-inline">Title</strong> component if the flag is <strong class="source-inline">true</strong>, otherwise, it sends the <strong class="source-inline">"World"</strong> text to <strong class="source-inline">Title</strong>.</p>
			<p>Who sends the <strong class="source-inline">flag</strong> info to the <strong class="source-inline">App</strong> component? That will be the parent of <strong class="source-inline">App</strong>. This can easily be constructed to form a tree, where we have branches and sub-branches, and it reaches <a id="_idIndexMarker044"/>the leaves at the ends. Notice that this formation is done solely through the usage of props on each node (component).</p>
			<p>Once a piece of info gets into a component, the prop binds its value to a local scope variable. From then on, it's the child's job to continue managing its local variable. It can be used pretty flexibly with one limitation. It's not expected to be changed! Or, if you ever change it, the change would not be reflected in the parent component. This behavior is the same as how we use a function with input arguments and its inner scope. The information passing is a one-way ticket.</p>
			<p>So now comes a big question. What if we want to reflect the change to a parent component done by a child component? How can a one-way ticket get us the information back?</p>
			<p>This is also done through a prop. As I mentioned, a prop can take any format, hence we can use a function prop:</p>
			<p class="source-code"><strong class="bold">const</strong> Child = ({ change }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> onChange = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    change()</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return &lt;input</strong> onChange={onChange} <strong class="bold">/&gt;</strong></p>
			<p class="source-code">}</p>
			<p class="source-code"><strong class="bold">const</strong> Parent = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> change = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    console.log("child notify me")</p>
			<p class="source-code">  } </p>
			<p class="source-code">  <strong class="bold">return </strong>&lt;Child change={change} /&gt;</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we sent a function defined in <strong class="source-inline">Parent</strong> through a <strong class="source-inline">change</strong> prop. Inside the <strong class="source-inline">Child</strong> component, when a user starts to type in any character to an <strong class="source-inline">input</strong> box, it fires an <strong class="source-inline">onChange</strong> event where we can invoke the <strong class="source-inline">change</strong> function. Whenever this happens, you will see the <strong class="source-inline">child notify me</strong> message in the <strong class="source-inline">Parent</strong> component. </p>
			<p>Essentially, this technique is what we refer to as a callback in JavaScript. The parent provides a <a id="_idIndexMarker045"/>mechanism to notify that something has changed using a callback function. Once the callback function is created, it can be sent to any child to gain the ability of notification to the parent.</p>
			<p>In a typical parent/child relationship in <em class="italic">React</em>, it's recommended that a prop value should not be changed by the child. Instead, it should be done through a function prop. When comparing <em class="italic">React</em> to other libraries, a "one-way" ticket is what we use to refer to this behavior. In the <em class="italic">React</em> community, we rarely use this word because this is the behavior designed at its birth.</p>
			<p>Now that we know the definition of a function component and the role props play in building a component, let's take a look at how,<a id="_idTextAnchor041"/> in general, we write a function component.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor042"/>Writing a function component</h1>
			<p>The function, representing a component, defines what to update on the screen. It returns a value <a id="_idIndexMarker046"/>composed of some <em class="italic">HTML</em>-like code. You should be quite familiar with elements such as <strong class="source-inline">&lt;ul&gt;</strong> and <strong class="source-inline">&lt;li&gt;</strong>; <em class="italic">React</em> also allows the addition of <em class="italic">JavaScript</em> expressions under these elements. When used together, it requires the <em class="italic">JavaScript</em> expression to be wrapped in a pair of brackets, <strong class="source-inline">{}</strong>. The job of this expression is to provide dynamic <em class="italic">HTML</em> content.</p>
			<p>For instance, if we have a <strong class="source-inline">text</strong> variable and would like to display it, we could do the following:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> text = "Hello World1"</p>
			<p class="source-code">  <strong class="bold">return &lt;h1&gt;</strong>{text}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p>Or, if the text is returned from a function, we can do the following:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> fn = () <strong class="bold">=&gt;</strong> "Hello World"</p>
			<p class="source-code">  <strong class="bold">return &lt;h1&gt;</strong>{fn()}<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p>We know that this <em class="italic">JavaScript</em> expression is filled in the location where the <strong class="source-inline">children</strong> prop is. </p>
			<p>The children <a id="_idIndexMarker047"/>element does not have to be a single element; it can be an array of elements as well:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> arr = ['Apple', 'Orange']</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;ul&gt;</strong></p>
			<p class="source-code">      {arr.map((v) <strong class="bold">=&gt;</strong> (</p>
			<p class="source-code">        <strong class="bold">&lt;li&gt;</strong>{v}<strong class="bold">&lt;/li&gt;</strong></p>
			<p class="source-code">      ))}</p>
			<p class="source-code">    <strong class="bold">&lt;/ul&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>It seems a bit complicated in the preceding code, so let's take a look at what the code tries to achieve by looking at the result first:</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;ul&gt;</strong></p>
			<p class="source-code">      {[<strong class="bold">&lt;li&gt;</strong>Apple<strong class="bold">&lt;/li&gt;</strong>, <strong class="bold">&lt;li&gt;</strong>Orange<strong class="bold">&lt;/li&gt;</strong>]}</p>
			<p class="source-code">    <strong class="bold">&lt;/ul&gt;</strong></p>
			<p class="source-code">  )</p>
			<p>Basically, it wants to output two <strong class="source-inline">li</strong> elements. To get there, we create an array containing two elements with a <em class="italic">JavaScript</em> expression. Once it becomes a <em class="italic">JavaScript</em> expression <a id="_idIndexMarker048"/>wrapped in brackets, <strong class="source-inline">{}</strong>, anything in <em class="italic">JavaScript</em> can be refactored and programmed however we want. We can use <strong class="source-inline">arr.map</strong> to form this array:</p>
			<p class="source-code">      {['Apple', 'Orange'].map(v <strong class="bold">=&gt;</strong> (</p>
			<p class="source-code">        <strong class="bold">&lt;li&gt;</strong>{v}<strong class="bold">&lt;/li&gt;</strong></p>
			<p class="source-code">      ))}</p>
			<p>Well done in code refactoring!</p>
			<p>There are just so many different brackets shown in the preceding statement, including <strong class="source-inline">{}</strong>, <strong class="source-inline">[]</strong>, and <strong class="source-inline">()</strong>. So, feel free to take a moment to understand what each pair does. It is hard to believe that one of the challenges of writing in <em class="italic">React</em> is brackets. </p>
			<p>This is a good example that shows you that once things are wrapped in a <em class="italic">JavaScript</em> expression, they can be refactored as we would normally program. In this case, we can  take the <strong class="source-inline">arr</strong> outside the function since <strong class="source-inline">arr</strong> is a constant that doesn't have to be defined inside the <strong class="source-inline">Title</strong> component:</p>
			<p class="source-code"><strong class="bold">const</strong> arr = ['Apple', 'Orange']</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;ul&gt;</strong></p>
			<p class="source-code">      {arr.map((v) <strong class="bold">=&gt;</strong> (</p>
			<p class="source-code">        <strong class="bold">&lt;li&gt;</strong>{v}<strong class="bold">&lt;/li&gt;</strong></p>
			<p class="source-code">      ))}</p>
			<p class="source-code">    <strong class="bold">&lt;/ul&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>Once you get a <a id="_idIndexMarker049"/>feel for using the JavaScript expression along with HTML-like code, sooner or later, you will develop your own programming style because underlying this exercise is the JavaScript language. </p>
			<p>Now that you have gotten to kno<a id="_idTextAnchor043"/>w this process, let's code an example together.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor044"/>Example of a function component</h1>
			<p>A site is made up of pages, where each page contains a sidebar, a header, a content area, and a <a id="_idIndexMarker050"/>footer. All of them can be modeled with components. The layout component can sit at the top of the tree. When you zoom in, you find its children inside with a sub-structure. Just like a spider's web (see <em class="italic">Figure 1.3</em>) the tree structure cascades down from the outer level into the inner level.</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/Figure_1.03_B17963.jpg" alt="Figure 1.3 – Web application layout&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Web application layout</p>
			<p>As <em class="italic">UI</em> engineers, we focus on the design of each component. Moreover, we pay close attention to the relationship between components. We want to know whether <strong class="source-inline">Title</strong> is built inside the main content or the sidebar. We want to know whether a header needs to be shared by multiple pages. You'll start to develop the skill to navigate between components among a tree.</p>
			<p>Say we want to display a list of navigation links at the top of the page. Each link can be disabled if required. For enabled ones, we can click to navigate to its corresponding <em class="italic">URL</em>. See <em class="italic">Figure 1.4</em>:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/Figure_1.04_B17963.jpg" alt="Figure 1.4 – Nav component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Nav component</p>
			<p>The navigation links can be predefined in an array of link objects:</p>
			<p class="source-code"><strong class="bold">const</strong> menus = [</p>
			<p class="source-code">  { key: 'home', label: 'Home' },</p>
			<p class="source-code">  { key: 'product', label: 'Product' },</p>
			<p class="source-code">  { key: 'about', label: 'About' },</p>
			<p class="source-code">  { key: 'secure', label: 'Secure', disabled: <strong class="bold">true</strong> },</p>
			<p class="source-code">]</p>
			<p>In each of the preceding links, the <strong class="source-inline">key</strong> property provides an identifier, the <strong class="source-inline">label</strong> property <a id="_idIndexMarker051"/>specifies the displayed title, and the <strong class="source-inline">disabled</strong> property indicates whether the user is allowed to click on it or not.</p>
			<p>We also want to display a line below the currently selected link. Based on these requirements, we come up with the implementation with <strong class="source-inline">selected</strong> and <strong class="source-inline">items</strong> props:</p>
			<p class="source-code"><strong class="bold">const</strong> Nav = ({ selected, items }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> isActive = item <strong class="bold">=&gt;</strong> item.key === selected</p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = item <strong class="bold">=&gt;</strong> () <strong class="bold">=&gt;</strong> { </p>
			<p class="source-code">    window.location.href = item.url</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return</strong> ...</p>
			<p class="source-code">}</p>
			<p>In the preceding <strong class="source-inline">Nav</strong> component, the <strong class="source-inline">items</strong> prop holds the list of links, and the <strong class="source-inline">selected</strong> prop holds the current selected item's key. The job of the <strong class="source-inline">Nav</strong> component is to display the list:</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;ul&gt;</strong></p>
			<p class="source-code">      {items.map(item <strong class="bold">=&gt;</strong> (</p>
			<p class="source-code">        <strong class="bold">&lt;li</strong></p>
			<p class="source-code">          key={item.key}</p>
			<p class="source-code">          className={isActive(item) ? 'active' : ''}</p>
			<p class="source-code">        <strong class="bold">&gt;</strong></p>
			<p class="source-code">          <strong class="bold">&lt;button</strong></p>
			<p class="source-code">            disabled={item.disabled}</p>
			<p class="source-code">            onClick={onClick}</p>
			<p class="source-code">          <strong class="bold">&gt;</strong></p>
			<p class="source-code">            {item.label}</p>
			<p class="source-code">          <strong class="bold">&lt;/button&gt;</strong></p>
			<p class="source-code">        <strong class="bold">&lt;/li&gt;</strong></p>
			<p class="source-code">      ))}</p>
			<p class="source-code">    <strong class="bold">&lt;/ul&gt;</strong></p>
			<p class="source-code">  )</p>
			<p>In the preceding <strong class="source-inline">return</strong> statement, <strong class="source-inline">items</strong> is iterated through one by one by following a <a id="_idIndexMarker052"/>loop and displaying links with a <strong class="source-inline">ul/li</strong> structure. Each link is displayed as a button supporting a <strong class="source-inline">disabled</strong> attribute. It also marks the link's <em class="italic">CSS</em> class as being <strong class="source-inline">active</strong> if it's the currently selected link.</p>
			<p>Watch out for the <strong class="source-inline">key</strong> attribute for each item. This attribute is required for <em class="italic">React</em> to know the position of each <strong class="source-inline">li</strong> element among the lists. With the key provided as a unique identifier, <em class="italic">React</em> can quickly find the right element to perform the comparison and update the screen. <strong class="source-inline">key</strong> is a must-have attribute when returning an array of elements.</p>
			<p class="callout-heading">Playground – Nav Component</p>
			<p class="callout">Feel free to play with the example online at <a href="https://codepen.io/windmaomao/pen/porzQjV">https://codepen.io/windmaomao/pen/porzQjV</a>.</p>
			<p>Now we can display <strong class="source-inline">Nav</strong> with the following line. Voilà:</p>
			<p class="source-code">&lt;Nav items={menus} selected="home" /&gt; </p>
			<p>To make each menu item easy to develop and maintain, we can extract lines out to form a separate component:</p>
			<p class="source-code"><strong class="bold">const</strong> NavItem = ({</p>
			<p class="source-code">  label, active, disabled, onClick</p>
			<p class="source-code">}) <strong class="bold">=&gt;</strong> (</p>
			<p class="source-code">  <strong class="bold">&lt;li</strong> className={active ? 'active' : ''}<strong class="bold">&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;button</strong> disabled={disabled} onClick={onClick}<strong class="bold">&gt;</strong></p>
			<p class="source-code">      {label}</p>
			<p class="source-code">    <strong class="bold">&lt;/button&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;/li&gt;</strong></p>
			<p class="source-code">)</p>
			<p>In the preceding <a id="_idIndexMarker053"/>code, a <strong class="source-inline">NavItem</strong> component is created to accept <strong class="source-inline">label</strong>, <strong class="source-inline">active</strong>, <strong class="source-inline">disabled</strong>, and <strong class="source-inline">onClick</strong> props. We don't need to overthink these prop names because they come in naturally, refactoring from the preceding <strong class="source-inline">Nav</strong> component. We can plug <strong class="source-inline">NavItem</strong> back to <strong class="source-inline">Nav</strong>:</p>
			<p class="source-code"><strong class="bold">const</strong> Nav = ({ selected, items }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> isActive = item <strong class="bold">=&gt;</strong> item.key === selected</p>
			<p class="source-code">  <strong class="bold">const</strong> onClick = item <strong class="bold">=&gt;</strong> () <strong class="bold">=&gt;</strong> { </p>
			<p class="source-code">    window.location.href = item.url</p>
			<p class="source-code">  }</p>
			<p class="source-code">  </p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;ul&gt;</strong></p>
			<p class="source-code">      {items.map(item <strong class="bold">=&gt;</strong> (</p>
			<p class="source-code">        &lt;NavItem </p>
			<p class="source-code">          key={item.key}</p>
			<p class="source-code">          label={item.label}</p>
			<p class="source-code">          disabled={item.disabled}</p>
			<p class="source-code">          active={isActive(item)}</p>
			<p class="source-code">          onClick={onClick(item)}</p>
			<p class="source-code">        /&gt;</p>
			<p class="source-code">      ))}</p>
			<p class="source-code">    <strong class="bold">&lt;/ul&gt;</strong></p>
			<p class="source-code">  ) </p>
			<p class="source-code">}</p>
			<p>This refactoring <a id="_idIndexMarker054"/>exercise is quite common and effective. This way, both <strong class="source-inline">Nav</strong> and <strong class="source-inline">NavItem</strong> c<a id="_idTextAnchor045"/>omponents become easier to maintain in the future.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor046"/>Summary</h1>
			<p>In this chapter, we first went over the history of UI components by looking at four libraries – <em class="italic">jQuery</em>, <em class="italic">Angular</em>, <em class="italic">React</em>, and <em class="italic">LitElement – t</em>o get an idea of having a component and how components are put together to build an application. Then, we learned what a function component is, with an introduction to its props and parent/child relationship. We then learned how to write a function component in general, and finally, we built a <strong class="source-inline">Nav</strong> component step by step.</p>
			<p>In the next chapter, we will craft a state of the function component fro<a id="_idTextAnchor047"/>m scratch and see how actions can benefit from it.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor048"/>Questions and answers</h1>
			<p>Here are som<a id="_idTextAnchor049"/>e questions and answers to refresh your knowledge:</p>
			<ol>
				<li>What is a function component?<p>A function component is a function taking props as its input argument and returning elements. For an <strong class="source-inline">App</strong> component, we can display it by using its instance form, <strong class="source-inline">&lt;App /&gt;</strong>. To build an application, it's about putting a component under another component as a child and refining this p<a id="_idTextAnchor050"/>rocess until we end up with a tree of components. </p></li>
				<li>How do you write a function component?<p>The way to become adept at writing function components is quite similar to writing functions. Ask yourself what the props specification of the component is and what is returned for display. In a typical application, half of the components are designed for business requirements, but the other half normally comes from code refactoring. A study of <strong class="bold">Functional Programming</strong> (<strong class="bold">FP</strong>) can generally bene<a id="_idTextAnchor051"/>fit you a<a id="_idTextAnchor052"/>nd take your UI skills to the next level.</p></li>
			</ol>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor053"/>Appendix</h1>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor054"/>Appendix A – How many component types does React support?</h2>
			<p>In the published <em class="italic">React</em> documentation, it supports two component types. One is a function component, and another one is a class component. <em class="italic">React</em> supported the class component from the beginning:</p>
			<p class="source-code"><strong class="bold">class</strong> ClassComponent <strong class="bold">extends</strong> React.Component {</p>
			<p class="source-code">  render() {</p>
			<p class="source-code">    <strong class="bold">const</strong> { name } = <strong class="bold">this</strong>.props;</p>
			<p class="source-code">    <strong class="bold">return &lt;h1&gt;</strong>Hello, { name }<strong class="bold">&lt;/h1&gt;</strong>;</p>
			<p class="source-code"> }</p>
			<p class="source-code">}</p>
			<p>Although the <strong class="source-inline">render</strong> function of a class component looks quite similar to what a function component returns and, most of the time, we can convert them in between, the class and function components are treated differently inside the <em class="italic">React</em> update process. Therefore, this book intentionally avoids mentioning the class component so as not to confuse any newcomer to <em class="italic">React</em>.</p>
			<p>In general, a function component can be written shorter and simpler, and it's also easier in terms of development and testing because it has plain inputs and outputs. Also, it doesn't have the <strong class="source-inline">this</strong> keyword, which can intimidate new developers or sometimes even senior developers. However, the downside of using a function component is that it's relatively new to the programming world, and there's also a mentality shift from <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>) to <strong class="bold">Functional Programming</strong> (<strong class="bold">FP</strong>), which can consume you if you are not prepared. Not to mention, being new means there can be different approaches that we need to learn and absorb before we can address the old problems. </p>
			<p>Other than the class and function components, internally, <em class="italic">React</em> actually supports more component types, as in the following example:</p>
			<p class="source-code">import { memo } from 'react'</p>
			<p class="source-code"><strong class="bold">const</strong> Title = memo(() <strong class="bold">=&gt; &lt;h1&gt;</strong>Hello<strong class="bold">&lt;/h1&gt;</strong>)</p>
			<p class="source-code"><strong class="bold">const</strong> App = () <strong class="bold">=&gt; </strong>&lt;Title /&gt;</p>
			<p>When the <strong class="source-inline">memo</strong> function is applied to the <strong class="source-inline">Title</strong> component, it creates a component with a component type, <strong class="source-inline">MemoComponent</strong>. We don't need to go into the details of these component types, but just know that each component type gets its own update algorithm when updated to the screen.</p>
		</div>
	</body></html>