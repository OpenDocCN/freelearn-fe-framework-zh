- en: Chapter 9. Client-side Templating
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 客户端模板
- en: This chapter will demonstrate some of the most widely used libraries to create
    complex HTML templates faster, while making our implementation easier to read
    and understand when compared to traditional string concatenation techniques. We
    will learn in more detail how to use the `Underscore.js` and `Handlebars.js` templating
    libraries, get a taste of their conventions, evaluate their features and find
    the one that best suits our taste.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将演示一些最常用的库，以更快速地创建复杂的HTML模板，同时使我们的实现在与传统字符串拼接技术相比更容易阅读和理解。我们将更详细地了解如何使用`Underscore.js`和`Handlebars.js`模板库，体验它们的约定，评估它们的特性，并找到最适合我们口味的。
- en: By the end of this chapter, we will be able to generate complex HTML structures
    in the browser efficiently by using readable templates and utilizing the unique
    characteristics of each templating library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，我们将能够通过可读的模板在浏览器中有效地生成复杂的HTML结构，并利用每个模板库的独特特性。
- en: 'In this chapter, we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Discuss the benefits of using a specialized templating library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论使用专门的模板库的好处
- en: Introduce the current trends in client-side templating, specifically the top
    representative of the families that use `<% %>` and `{{ }}` as their placeholders
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍当前客户端模板中的潮流，特别是使用 `<% %>` 和 `{{ }}` 作为占位符的家族中的顶级代表
- en: Introduce `Underscore.js` as an example of the family of templating engines
    that use `<% %>` placeholders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`Underscore.js`为例，介绍一族使用`<% %>`占位符的模板引擎
- en: Introduce `Handlebars.js` as an example of the family of templating engines
    that use curly braces `{{ }}` placeholders
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`Handlebars.js`为例，介绍一族使用大括号 `{{ }}` 占位符的模板引擎
- en: Introducing Underscore.js
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Underscore.js
- en: '`Underscore.js` is a JavaScript library that provides a collection of utility
    methods that help web developers work more efficiently and focus on the actual
    implementation of their application rather than bothering with repetitive algorithmic
    problems. `Underscore.js` is, by default, accessible through the "`_`" identifier
    of the global namespace and that''s exactly where its name comes from.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`Underscore.js`是一个JavaScript库，提供了一系列实用方法，帮助Web开发人员更有效地工作，专注于应用程序的实际实现，而不必为重复的算法问题烦恼。
    `Underscore.js`默认情况下通过全局命名空间的“`_`”标识符访问，这也正是它的名称的由来。'
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As with the `$` identifier in jQuery, the underscore "`_`" identifier can also
    be used as a variable name in JavaScript.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与 jQuery 中的 `$` 标识符一样，underscore "`_`" 标识符也可以在 JavaScript 中作为变量名使用。
- en: 'One of the utility functions that it provides is the `_.template()` method,
    which provides us with a convenient way of interpolating specific values into
    existing template strings that follow a specific format. The `_.template()` method
    recognizes three special placeholder notations inside templates, which are used
    to add dynamic characteristics:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 其中提供的实用程序函数之一是`_.template()`方法，它为我们提供了一种便利的方式，将特定值插入到遵循特定格式的现有模板字符串中。 `_.template()`方法在模板内部识别三种特殊的占位符符号，用于添加动态特性：
- en: The `<%= %>` notation is used as the simplest way to interpolate a value of
    a variable or an expression in a template.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<%= %>`符号用作在模板中插入变量或表达式值的最简单方式。'
- en: The `<%- %>` notation performs HTML escaping on a variable or expression and
    then interpolates it in a template.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<%- %>`符号对变量或表达式进行HTML转义，然后将其插入模板中。'
- en: The `<% %>` notation is used to execute any valid JavaScript statement as part
    of the template generation.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<% %>`标记用于执行任何有效的JavaScript语句作为模板生成的一部分。'
- en: 'The `_.template()` method accepts a template string that follows these characteristics
    and returns a plain JavaScript function, commonly referred to as the template
    function, which can be invoked with an object containing the values that are going
    to be interpolated in the template. The result of the invocation of the template
    function is a string value, which is the result of the interpolation of the provided
    values inside the template:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`_.template()`方法接受遵循这些特征的模板字符串，并返回一个纯JavaScript函数，通常称为模板函数，可以使用包含将在模板中插入的值的对象调用。模板函数的调用结果是一个字符串值，这是提供的值在模板内插值的结果：'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As an example, the above code returns `<h1>Underscore.js example</h1>` and
    is equivalent to the following shorthand invocation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上面的代码返回`<h1>Underscore.js示例</h1>`，等效于以下简写调用：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about the `_.template` method, you can read the documentation
    at: [http://underscorejs.org/#template](http://underscorejs.org/#template).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`_.template`方法的更多信息，您可以在此处阅读文档：[http://underscorejs.org/#template](http://underscorejs.org/#template)。
- en: What makes `Underscore.js` templates very flexible is the `<% %>` notation,
    which allows us to perform any method invocation and is, for example, used as
    the recommended way to create loops in a template. On the other hand, overusing
    this feature may add too much logic to your templates, which is a known anti-pattern
    found in many other frameworks, violating the principle of **Separation of Concerns**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使`Underscore.js`模板非常灵活的是`<% %>`符号，它允许我们执行任何方法调用，并且例如被用作在模板中创建循环的推荐方法。另一方面，过度使用此功能可能会向您的模板添加过多的逻辑，这是许多其他框架中的已知反模式，违反了**关注点分离**原则。
- en: Using Underscore.js templates in our applications
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用 Underscore.js 模板
- en: As an example of using `Underscore.js` for templating, we will now use it to
    refactor the HTML code generation which takes place in some modules of the dashboard
    example, as we saw in previous chapters. The modifications required to the existing
    implementation are limited to the `categories` and the `informationBox` modules,
    which manipulate the DOM tree of the page by adding new elements.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用`Underscore.js`进行模板化的示例，我们现在将其用于重构仪表板示例中一些模块中发生的 HTML 代码生成，正如我们在之前的章节中所看到的。对现有实现所需的修改仅限于`categories`和`informationBox`模块，它们通过添加新元素来操作页面的
    DOM 树。
- en: 'The first place that such a refactor can be applied is in the `init()` method
    of the `categories` module. We can modify the code that creates the available
    `<option>`s of the `<select>` category to look like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此类重构可以应用的第一个地方是`categories`模块的`init()`方法。我们可以修改创建`<select>`类别的可用`<option>`的代码如下：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we iterate over the categories of the dashboard in order to
    create and append the appropriate `<option>` elements to the `<select>` category
    element. In our template, we are using the `<%= %>` notation for the `value` attribute
    of the `<option>` since we know that it will hold an integer value that does not
    need escaping. On the other hand, we are using the `<%- %>` notation for the content
    part of each `<option>` in order to escape the title of each category for the
    case its value is not an HTML-safe string.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们遍历仪表板的类别，以创建并附加适当的`<option>`元素到`<select>`类别元素。在我们的模板中，我们使用`<%= %>`符号来表示`<option>`的`value`属性，因为我们知道它将保存一个不需要转义的整数值。另一方面，我们使用`<%-
    %>`符号来表示每个`<option>`的内容部分，以便为每个类别的标题进行转义，以防其值不是 HTML 安全字符串。
- en: We are using the `_.template()` method outside the `for` loop in order to create
    a single compiled template function that will be reused on each iteration of the
    `for` loop. In this way, the browser not only executes the `_.template()` method
    just once, but also optimizes the generated template function and makes it run
    faster on each subsequent execution inside the `for` loop. Lastly, we are using
    the `join('')` method to combine all the HTML strings of the `optionsHtmlArray`
    variable and `append()` the result to the DOM with a single operation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`for`循环之外使用`_.template()`方法来创建一个单个编译的模板函数，在`for`循环的每次迭代中重复使用。这样一来，浏览器不仅仅执行一次`_.template()`方法，而且还会优化生成的模板函数，并使其在`for`循环中的每次后续执行速度更快。最后，我们使用`join('')`方法来将`optionsHtmlArray`变量的所有
    HTML 字符串组合在一起，并通过单个操作将结果`append()`到 DOM 中。
- en: An alternative and possibly simpler way to achieve the same result is by combining
    the `<% %>` notation and the `_.each()` method that `Underscore.js` provides,
    enabling us to implement a loop inside the template itself. In this way, the template
    will be responsible for the iteration over the provided array of categories, moving
    the complexity from the implementation of the module into the template.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相同结果的另一种可能更简单的方法是结合`<% %>`符号和`Underscore.js`提供的`_.each()`方法，使我们能够在模板本身中实现循环。这样，模板将负责对提供的类别数组进行迭代，将复杂性从模块的实现转移到模板中。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see in the above code, our JavaScript implementation no longer contains
    a `for` loop, reducing its complexity and the required nesting. There is only
    a single call to the `_.template()` method, which nicely abstracts the implementation
    to an operation that generates the HTML and renders the `<option>` elements for
    all the categories. You can also see how nicely this technique fits in with the
    Composite logic that jQuery itself follows, in which the methods are designed
    to operate over collections of elements instead of single items.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的代码所示，我们的JavaScript实现不再包含`for`循环，减少了其复杂性和所需的嵌套。只有一次对`_.template()`方法的调用，很好地将实现抽象为一个生成HTML并为所有类别渲染`<option>`元素的操作。您还可以看到这种技术与jQuery自身遵循的组合逻辑非常契合，其中方法旨在处理元素集合而不是单个项目。
- en: Separating HTML templates from JavaScript code
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将HTML模板与JavaScript代码分开
- en: Even after introducing all of the above improvements, it soon starts to become
    obvious that writing templates in between your application logic might not be
    the best approach to follow. As soon as your application becomes complex enough,
    or when you need to use templates that are more than a few lines long, the implementation
    starts to feel fragmented by the mix of the application's logic and the HTML templates.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 即使引入了上述所有改进，很快就会变得显而易见，在应用逻辑之间编写模板可能不是最佳的方法。一旦您的应用变得足够复杂，或者当您需要使用超过几行的模板时，实现起来会因为应用逻辑和HTML模板的混合而感到分散。
- en: A cleaner approach to this problem is to store your templates alongside the
    rest of the HTML code of your page. This is a good step towards better **Separation
    of Concerns** since it properly isolates the presentation from the application
    logic.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的更清晰的方法是将模板存储在页面其他部分的HTML代码旁边。这是朝着更好的**关注点分离**迈出的一大步，因为它适当地将呈现与应用逻辑隔离开来。
- en: In order to include HTML templates as part of web pages in an inactive form,
    we need to use a host tag that will prevent them from being rendered, but also
    allow us to retrieve its content programmatically when needed. For this purpose,
    we can use `<script>` tags inside the `<head>` or the `<body>` of our page and
    specify any `type` other than the common `text/javascript` that we normally use
    for our JavaScript code. The operation principle behind this is that browsers
    do not try to parse, execute or render the content of `<script>` tags, in case
    their `type` attribute isn't recognized. After some experimentation, the community
    of `Underscore.js` users has largely adopted this practice and agreed to specify
    `text/template` as the preferred type for these `<script>` tags, in an attempt
    to make these implementations more uniform among developers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将HTML模板包含在不活动形式的网页中，我们需要使用一个宿主标签，这可以阻止它们被渲染，但也允许我们在需要时以程序方式检索其内容。为此，我们可以在页面的`<head>`或`<body>`内使用`<script>`标签，并指定除我们通常用于JavaScript代码的常见的`text/javascript`之外的任何`type`。这背后的操作原则是，浏览器在未识别其`type`属性的情况下不尝试解析、执行或呈现`<script>`标签的内容。经过一些实验，`Underscore.js`用户社区基本上采用了这种做法，并同意将`text/template`指定为这些`<script>`标签的首选类型，试图使这些实现在开发人员中更加统一。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Even though `Underscore.js` is neither opinionated nor contains any implementation
    specific to the way that the templates become available, using `text/template`
    `<script>` tags and/or AJAX requests have been valuable techniques that are widely
    used and are considered best practices.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`Underscore.js`既不是一个偏执的库，也不含有任何特定于模板变得可用的实现，但使用`text/template` `<script>`标签和/或Ajax请求都是有价值的技术，被广泛使用且被认为是最佳实践。
- en: 'As an example of a complex template that would be beneficial to move into a
    `<script>` tag, we will refactor to the `openNew()` method of the `informationBox`
    module. As you can see in the code below, the resulting `<script>` tag is cleanly
    formatted and we no longer need to use string concatenation for the definition
    of the multi-line template:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 作为将复杂模板移入`<script>`标签中的受益示例，我们将重新构建`informationBox`模块的`openNew()`方法。如下所示，在下面的代码中，生成的`<script>`标签格式清晰，并且我们不再需要对多行模板的定义进行字符串拼接：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A good practice when moving HTML templates out of our code is to write an abstracted
    mechanism to be responsible for retrieving them and providing the compiled template
    function. This approach not only decouples the rest of the implementation from
    the template retrieval mechanism but also makes it less repetitive and creates
    a centralized method designed to provide templates for the rest of the application.
    Moreover, as we can see below, this approach also allows us to optimize the way
    that templates are retrieved, propagating the benefits to all the places that
    they are used.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将 HTML 模板移出我们的代码时的一个好的做法是编写一个抽象的机制来负责检索它们并提供编译后的模板函数。这种方法不仅将实现的其余部分与模板检索机制解耦，而且使其更少重复，并创建了一个专门设计为为应用程序的其余部分提供模板的集中方法。此外，正如我们下面可以看到的，这种方法还允许我们优化模板的检索方式，将好处传播到所有使用它们的地方。
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As shown in the above implementation, the `openNew()` method of the `informationBox`
    module simply invokes the `getEmbeddedTemplate()` function by passing a unique
    identifier that is associated with the requested template and uses the returned
    template function to generate the new box's HTML and finally append it to the
    page. The most interesting part of the implementation is the `getEmbeddedTemplate()`
    method, which uses the `templateCache` variable as a dictionary to hold all the
    previously compiled template functions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示的实现中，`informationBox` 模块的 `openNew()` 方法只是通过传递与请求模板相关联的唯一标识符来调用 `getEmbeddedTemplate()`
    函数，并使用返回的模板函数生成新框的 HTML，最后将其附加到页面上。实现中最有趣的部分是 `getEmbeddedTemplate()` 方法，它使用 `templateCache`
    变量作为字典来保存所有先前编译的模板函数。
- en: The first step is always to check whether the requested template identifier
    exists in our template cache. If not, then the DOM tree of the page is searched
    for the `<script>` tag with the related ID and its HTML content is used to create
    the template function, which is then stored in the cache and returned to the caller.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步始终是检查请求的模板标识符是否存在于我们的模板缓存中。如果不存在，则搜索页面的 DOM 树以查找带有相关 ID 的 `<script>` 标签，并使用其
    HTML 内容创建模板函数，然后将其存储在缓存中并返回给调用方。
- en: Keep in mind that it is a good practice to use a specific prefix or suffix for
    all the identifiers of your HTML templates in order to avoid conflicts with the
    IDs of other page elements. For this purpose, in the above example we used the
    `-template` as a suffix of the identifier of our box template.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在 HTML 模板的所有标识符中使用特定的前缀或后缀是一个好的做法，以避免与其他页面元素的 ID 冲突。为此，在上面的示例中，我们使用了 `-template`
    作为我们框模板标识符的后缀。
- en: Ideally, the implementation of the template provider method should be in a separate
    module that will be used by all the parts of an application but, since in our
    dashboard this is used in only one place, we met the needs of our demonstration
    by simply using a function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，模板提供程序方法的实现应该在一个单独的模块中，该模块将被应用程序的所有部分使用，但是，由于在我们的仪表板中只使用了一次，我们通过简单地使用一个函数来满足我们演示的需求。
- en: Introducing Handlebars.js
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 Handlebars.js
- en: '**Handlebars.js**, or simply Handlebars, is a specialized client-side templating
    library that enables web developers to create semantic templates effectively.
    Using Handlebars for templating leads to the creation of logic-free templates
    which ensures that the view and the code are isolated, helping preserve the Separation
    of Concerns principle. It is largely compatible with Mustache templates, which
    are a templating language specification that have proven their effectiveness over
    time and have many implementations for all the major programming languages. Additionally,
    Handlebars provides a set of extensions on top of the Mustache template specification,
    such as helper methods and partials, as a means of extending the templating engine
    and creating more effective templates.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**Handlebars.js**，或简称 Handlebars，是一种专门的客户端模板库，使 Web 开发人员能够有效地创建语义化模板。使用 Handlebars
    进行模板化会导致创建无逻辑的模板，这确保了视图和代码的隔离，有助于保持关注点分离原则。它与 Mustache 模板基本兼容，Mustache 是一个模板语言规范，随着时间的推移已经证明了其有效性，并且有许多主要编程语言的实现。此外，Handlebars
    还提供了一组在 Mustache 模板规范之上的扩展，例如辅助方法和局部模板，作为扩展模板引擎并创建更有效模板的一种手段。'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can see all the documentation for Handlebars at: [http://handlebarsjs.com/](http://handlebarsjs.com/).
    You can get more information about Mustache in JavaScript at: [https://github.com/janl/mustache.js/](https://github.com/janl/mustache.js/).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[Handlebars 文档](http://handlebarsjs.com/)中查看所有 Handlebars 的文档。你可以在[JavaScript
    Mustache](https://github.com/janl/mustache.js/)中获取更多有关 Mustache 的信息。
- en: The main template notation that Handlebars provides is the double curly braces
    syntax `{{ }}`. As Handlebars was designed to be used for HTML templates from
    the beginning, this notation also applies HTML escaping by default, lowering the
    chances that a non-escaped value could reach the template causing potential security
    problems. If a non-escaped interpolation is required for a specific part of a
    template, we can use the triple curly braces notation `{{{ }}}`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 提供的主要模板表示法是双花括号语法 `{{ }}`。由于 Handlebars 最初是为 HTML 模板设计的，所以默认情况下也适用于
    HTML 转义，降低了未转义值可能到达模板并导致潜在安全问题的几率。如果需要特定部分的模板进行非转义的插值，我们可以使用三个花括号的表示法 `{{{ }}}`。
- en: Moreover, since Handlebars prevents us from invoking methods directly from within
    a template, it provides us with the ability to define and use helper methods and
    block expressions as a way to cover more complex use cases while also helping
    to maintain our templates as clean and readable as possible. The set of built-in
    helpers includes the `{{#if }}` and `{{#each }}` helpers which allow us to perform
    iterations over arrays and change the outcomes of a template based on conditions
    very easily.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于 Handlebars 阻止我们直接从模板中调用方法，它为我们提供了定义和使用辅助方法和块表达式的能力，以涵盖更复杂的用例，同时帮助我们尽可能地保持模板的清晰和可读性。内置助手集包括
    `{{#if }}` 和 `{{#each }}` 助手，它们允许我们非常轻松地对数组执行迭代，并根据条件更改模板的结果。
- en: 'The central method of the Handlebars library is the `Handlebars.compile()`
    method, which accepts a template string as a parameter and returns a function
    that can be used to generate string values that follow the form of the provided
    template. This function can then be invoked (as in `Underscore.js`) with an object
    as a parameter, the properties of which will be used as a context for the evaluation
    of all the Handlebars expressions (the curly braces notations) that were defined
    in the original template:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 库的中心方法是 `Handlebars.compile()` 方法，它接受模板字符串作为参数，并返回一个函数，该函数可用于生成符合所提供模板形式的字符串值。然后，可以使用一个对象作为参数调用此函数（与
    `Underscore.js` 中一样），其中的属性将用作对原始模板中定义的所有 Handlebars 表达式（花括号表示法）进行评估的上下文：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As an example, the above code returns `"<h1>!!!&gt; Handlebars example &lt;!!!</h1>"`,
    turning the interpolated title into a safe HTML string, but one which would otherwise
    render properly when attached to the DOM tree of a page. Of course, the same result
    can be achieved with the following shorthand invocation, if we don''t need to
    keep a reference to the compiled template function for future use:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，上述代码返回 `"<h1>!!!&gt; Handlebars example &lt;!!!</h1>"`，将插入的标题转换为安全的 HTML
    字符串，但是当附加到页面的 DOM 树时，它将以正确的方式呈现。当然，如果我们不需要将编译后的模板函数的引用保留以供将来使用，则可以使用以下简写调用来实现相同的结果：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using Handlebars.js in our applications
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用 Handlebars.js
- en: As an example of using `Handlebars.js` for templating and in order to demonstrate
    its differences from `Underscore.js` templates, we will now use it to refactor
    our dashboard example, like we did in the previous section. Like before, the refactoring
    is limited to the `categories` and the `informationBox` modules, which manipulate
    the DOM tree of the page by adding new elements.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用 `Handlebars.js` 进行模板化的示例，并且为了展示它与 `Underscore.js` 模板的区别，我们现在将使用它来重构我们的仪表板示例，就像我们在前一节中所做的那样。与之前一样，重构仅限于
    `categories` 和 `informationBox` 模块，这些模块通过添加新元素来操作页面的 DOM 树。
- en: 'The refactored implementation of the `init()` method of the `categories` module
    should look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`categories` 模块的 `init()` 方法的重构实现应该如下所示：'
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First of all, we have used the `Handlebars.compile()` method which generates
    and returns a template function based on the provided template string. The main
    difference with the `Underscore.js` implementation we saw in the previous section,
    is that we now use the double curly braces notation `{{ }}` to interpolate values
    in our template. Apart from the different appearance, `Handlebars.js` also does
    HTML string escaping by default in an attempt to eliminate HTML injection security
    holes by making escaping part of its primary use case.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用了`Handlebars.compile()`方法，该方法基于提供的模板字符串生成并返回模板函数。与我们在上一节中看到的`Underscore.js`的实现的主要区别在于，我们现在使用双花括号符号`{{
    }}`来插值我们的模板中的值。除了外观上的差异外，`Handlebars.js`还默认执行HTML字符串转义，以尝试通过将转义作为其主要用例之一来消除HTML注入安全漏洞。
- en: As we did earlier in this chapter, we will create the template function outside
    the `for` loop and use it to generate the HTML for each `<option>` element. All
    the generated HTML strings are gathered in an array and are finally combined and
    attached to the DOM tree with a single operation, using the `$.append()` method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面所做的那样，我们将在`for`循环之外创建模板函数，并将其用于为每个`<option>`元素生成HTML。所有生成的HTML字符串都被收集到一个数组中，最终通过一次操作使用`$.append()`方法将它们组合并附加到DOM树上。
- en: 'The next incremental step to reduce the complexity of our implementation is
    to abstract the iterations away from our JavaScript code using the looping capabilities
    of the templating engine itself:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 减少我们实现复杂性的下一个渐进步骤是使用模板引擎本身的循环能力将迭代抽象化为我们的JavaScript代码之外：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Handlebars.js` library allows us to achieve that by using the special `{{#each
    }}` notation. In between the `{{#each }}` and `{{/each}},` the context of the
    template is changed to match each individual object of the iteration, allowing
    to directly access and interpolate the `{{ title }}` of each object in the `categoryInfos`
    array. Moreover, in order to access the loop counter, Handlebars provides us with
    the special `@index` variable as part of the context of the loop.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handlebars.js`库允许我们通过使用特殊的`{{#each }}`符号来实现这一点。在`{{#each }}`和`{{/each}}`之间，模板的上下文被更改以匹配迭代的每个单独对象，允许直接访问和插值`categoryInfos`数组中每个对象的`{{
    title }}`。此外，为了访问循环计数器，Handlebars提供了特殊的`@index`变量作为循环的上下文的一部分。'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a full list of all the special notations that Handlebars provides, you
    can read the documentation at: [http://handlebarsjs.com/reference.html](http://handlebarsjs.com/reference.html)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以阅读[http://handlebarsjs.com/reference.html](http://handlebarsjs.com/reference.html)上的文档，获取
    Handlebars 提供的所有特殊符号的完整列表。
- en: Separating HTML templates from JavaScript code
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将HTML模板与JavaScript代码分离
- en: 'Like most templating engines, Handlebars also leads us to isolate our templates
    from the JavaScript implementation of our application and deliver them to the
    browser by including them in `<script>` tags, inside the HTML of our pages. Moreover,
    Handlebars is opinionated and prefers the special `text/x-handlebars-template`
    as the type attribute for all `<script>` tags that contain Handlebars templates.
    For example, here is how the template for the dashboard''s boxes should be defined
    according to the library recommendations:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数模板引擎一样，Handlebars也让我们将模板与应用程序的JavaScript实现隔离开，并通过将它们包含在页面HTML中的`<script>`标签中，在浏览器中传递它们。此外，Handlebars有一定的偏好，更喜欢特殊的`text/x-handlebars-template`作为所有包含Handlebars模板的`<script>`标签的
    type 属性。例如，这是根据库推荐的方式定义仪表板框的模板的方式：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Even though our implementation would still work if a different `type` was specified
    for the `<script>` tag, following the library's guidelines can obviously make
    implementations more uniform among developers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如果为`<script>`标签指定了不同的`type`，我们的实现仍然可以正常工作，但遵循库的指南显然可以使开发人员之间的实现更加统一。
- en: 'As we did earlier in this chapter, we will follow the best practice of creating
    a separate function to be responsible for providing the templates wherever they
    are needed in the application:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面所做的那样，我们将遵循最佳实践，创建一个单独的函数负责在应用程序中需要的任何地方提供模板：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the implementation is mostly the same as the `Undescore.js`
    example that we saw earlier in this chapter. The only difference is that we are
    now using the `Handlebars.compile()` method to generate the compiled template
    functions from the retrieved templates.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，该实现与我们在本章前面看到的`Undescore.js`示例基本相同。唯一的区别是我们现在使用`Handlebars.compile()`方法来从检索到的模板生成已编译模板函数。
- en: Pre-compiling templates
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预编译模板
- en: An extra feature of the Handlebars library is the support for template pre-compilation.
    This allows us to pre-generate all the template functions with a simple terminal
    command and then have our server deliver to them to the browser, instead of the
    actual templates. In this way, the browser will be able to use the pre-compiled
    templates directly, removing the need for the compilation of each individual template
    and making the execution of the library and our application faster.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars库的一个额外功能是支持模板预编译。这使我们可以使用一个简单的终端命令预先生成所有模板函数，然后让我们的服务器将它们传送到浏览器，而不是实际的模板。这样，浏览器就可以直接使用预编译的模板，而不需要对每个单独的模板进行编译，使得库和应用程序的执行速度更快。
- en: 'In order to pre-compile our templates, we first need to place them in separate
    files. The Handlebars documentation suggests using the `.handlebars` extension
    for our files but we can still use the `.html` extension if it is preferred. After
    installing the compilation tool on our development machine (with `npm install
    handlebars -g`), we can issue the following command in our terminal to compile
    a template:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预编译我们的模板，我们首先需要将它们放在单独的文件中。 Handlebars文档建议我们的文件使用`.handlebars`扩展名，但如果更喜欢，我们仍然可以使用`.html`扩展名。在我们的开发机器上安装编译工具（使用`npm
    install handlebars -g`），我们可以在终端中发出以下命令来编译模板：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will generate the `box-template.js` file that is actually a mini-module
    definition that adds the template to `Handlebars.templates`. The generated file
    can then be combined and minified like regular JavaScript files and, when loaded
    by a browser, the template function will become available through the `Handlebars.templates['box-template']`
    property.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成实际上是一个将模板添加到`Handlebars.templates`的迷你模块定义的`box-template.js`文件。生成的文件可以像常规JavaScript文件一样合并和最小化，并且当被浏览器加载时，模板函数将通过`Handlebars.templates['box-template']`属性可用。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that if the `.html` extension is being used for the templates,
    then the pre-compiled template function will be available through the `Handlebars.templates['box-template.html']`
    property.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果模板使用`.html`扩展名，则预编译的模板函数将通过`Handlebars.templates['box-template.html']`属性可用。
- en: 'As you can see, using a template provider function assists with the migration
    of an existing application to pre-compiled templates since it allows us to encapsulate
    the way that the templates are retrieved. Moving to pre-compiled templates only
    requires changing the `getEmbeddedTemplate()` to something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，使用模板提供者函数有助于将现有应用程序迁移到预编译模板，因为它允许我们封装模板的检索方式。只需将`getEmbeddedTemplate()`更改为以下内容即可将其迁移到预编译模板：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about template pre-compilation in Handlebars, read the
    documentation at: [http://handlebarsjs.com/precompilation.html](http://handlebarsjs.com/precompilation.html).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Handlebars中模板预编译的更多信息，请阅读：[http://handlebarsjs.com/precompilation.html](http://handlebarsjs.com/precompilation.html)。
- en: Retrieving HTML templates asynchronously
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步检索HTML模板
- en: The final step to mastering client-side templating is a development practice
    that allows us to load templates dynamically and use them in a web page that has
    already been loaded. This approach can lead to more scalable implementations than
    the approach of embedding all the available templates as `<script>` tags inside
    the HTML source of each page.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握客户端模板的最后一步是一种开发实践，该实践允许我们动态加载模板并在已加载的网页中使用它们。这种方法可以导致比在每个页面的HTML源文件中将所有可用模板嵌入为`<script>`标签的方法更具可伸缩性的实现。
- en: 'The key element of this technique is to load each template only when it is
    required for the presentation of a web page, commonly after a user action. The
    main benefits of this approach are that:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的关键要素是仅在需要呈现网页时加载每个模板，通常是在用户操作之后。这种方法的主要优点是：
- en: The initial page load time is reduced since the HTML of the page is smaller.
    The gains from the reduction of the page size become even greater if our application
    has a lot of templates that are used only under certain circumstances, for example,
    after specific user interactions.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始页面加载时间减少，因为页面的HTML更小。如果我们的应用程序有很多只在特定情况下使用的模板，例如在特定用户交互后，页面尺寸减小的收益将变得更大。
- en: The user only downloads a template if it is actually going to be used. In this
    way, the size of the total downloaded resources for each page load can be reduced.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户只在实际使用模板时才会下载模板。通过这种方式，可以减少每个页面加载的总下载资源的大小。
- en: Subsequent requests for an already loaded template will not lead to an extra
    download, since the browser's HTTP caching mechanism will return the cached resource.
    Additionally, since the browser cache is used for all HTTP requests regardless
    of the page from which they originate, users only have to download the required
    template once while using our web application.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于已经加载的模板的后续请求不会导致额外的下载，因为浏览器的HTTP缓存机制将返回缓存的资源。此外，由于浏览器缓存用于所有HTTP请求，无论它们来自哪个页面，用户在使用我们的Web应用程序时只需下载所需的模板一次。
- en: Because of its benefits to user experience and its scalability, this technique
    is widely used by the most popular webmail and social networking web sites, where
    various HTML templates and JavaScript modules are loaded dynamically, based on
    user actions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其对用户体验和可伸缩性的好处，这种技术被最流行的电子邮件和社交网络网站广泛使用，根据用户的操作动态加载各种HTML模板和JavaScript模块。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on how jQuery can be used to load JavaScript modules on
    a page dynamically, read the documentation for the `$.getScript()` method at:
    [https://api.jquery.com/jQuery.getScript/](https://api.jquery.com/jQuery.getScript/).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用jQuery在页面上动态加载JavaScript模块的更多信息，请阅读`$.getScript()`方法的文档：[https://api.jquery.com/jQuery.getScript/](https://api.jquery.com/jQuery.getScript/)。
- en: Adopting it in an existing implementation
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采用它在一个已有的实现中
- en: To illustrate this technique, we will change the `Underscore.js` and `Handlebars.js`
    implementations of the `informationBox` module so that it fetches the box template
    for our dashboard using an AJAX request.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个技术，我们将更改`informationBox`模块的`Underscore.js`和`Handlebars.js`实现，以便使用AJAX请求获取我们仪表板的盒子模板。
- en: 'Let''s proceed by analyzing the necessary changes for our `Underscore.js` implementation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过分析我们的`Underscore.js`实现所需的改变来继续：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see in the above code, we have implemented the `getAjaxTemplate()`
    function as a way of decoupling the mechanism that is responsible for fetching
    the template from the implementation that uses it. This implementation has a lot
    in common with the `getEmbeddedTemplate()` function that we used earlier, the
    main difference being that the `getAjaxTemplate()` function is asynchronous and,
    as a result, returns a **Promise**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上面的代码中所看到的，我们已经实现了`getAjaxTemplate()`函数作为一种将负责获取模板的机制与使用它的实现解耦的方式。这个实现与我们之前使用的`getEmbeddedTemplate()`函数有很多相似之处，主要区别在于`getAjaxTemplate()`函数是异步的，因此返回一个**Promise**。
- en: The `getAjaxTemplate()` function firstly checks whether or not the requested
    template already exists in its cache, as an extra attempt to reduce HTTP requests
    to the server. If the template is found in the cache, then it is returned as part
    of a Resolved Promise, otherwise we initiate an AJAX request using the `$.ajax()`
    method to retrieve it from the server. Like before, we need to have a convention
    regarding the naming of the template HTML files and the path used to store them
    in the server. In our example, we are looking in the same directory as the web
    page itself and just appending the `.html` file extension. An extra concern in
    some cases, depending on the web server used, is the definition of the `mimeType`
    of the resource as `text/html`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAjaxTemplate()`函数首先检查所请求的模板是否已经存在于其缓存中，这是为了进一步减少向服务器发出的HTTP请求。如果在缓存中找到模板，则它将作为已解决的Promise的一部分返回，否则我们将使用`$.ajax()`方法启动一个AJAX请求从服务器检索它。像以前一样，我们需要对模板HTML文件的命名和用于在服务器上存储它们的路径有一个约定。在我们的示例中，我们正在查找与网页本身相同的目录，并只附加`.html`文件扩展名。在某些情况下，根据所使用的Web服务器的不同，还需要额外考虑资源的`mimeType`定义为`text/html`。'
- en: When the AJAX request completes, the `then()` method is executed with the content
    of the template as a string parameter, which is used to generate the compiled
    template function. Our implementation finally returns the compiled template function
    as the result of the chained Promise, right after adding it to its cache. Since
    the `getAjaxTemplate()` function is asynchronous, we also had to change the implementation
    of the `openNew()` method and move all the code using the returned template function
    inside a `then()` callback. Apart from this, the implementation has remained the
    same and uses the template function in exactly the same way as before.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当 AJAX 请求完成时，`then()` 方法将以模板内容作为字符串参数执行，用于生成编译后的模板函数。我们的实现最终将编译后的模板函数作为链式 Promise
    的结果返回，直接将其添加到缓存中。由于 `getAjaxTemplate()` 函数是异步的，我们还必须更改 `openNew()` 方法的实现，并将所有使用返回的模板函数的代码移到
    `then()` 回调内部。除此之外，实现保持不变，并且与之前完全相同地使用模板函数。
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When re-implementing the `getAjaxTemplate()` function to use `Handlebars.js`,
    the resulting code is mostly the same as before. The only difference is in the
    invocation of the `Handlebars.compile()` method instead of the `Undescore.js`
    equivalent. This is an added benefit as many client-side templating engines influenced
    each other and have converged into a very similar API regarding the way that their
    template functions are used, largely because of the positive user feedback on
    the existing implementations.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当重新实现 `getAjaxTemplate()` 函数以使用 `Handlebars.js` 时，结果代码基本与以前相同。唯一的区别在于调用 `Handlebars.compile()`
    方法而不是 `Underscore.js` 的等价方法。这是一个额外的好处，因为许多客户端模板引擎彼此影响，并已经在它们的模板函数的使用方式方面收敛到非常相似的
    API，主要是因为现有实现的积极用户反馈。
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that the `$.ajax()` method might not work in some browsers when
    the page is loaded through the filesystem, but works as intended when served using
    a web server like Apache, IIS, or nginx.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当通过文件系统加载页面时，`$.ajax()` 方法可能在某些浏览器中无法工作，但在像 Apache、IIS 或 nginx 这样的 Web 服务器上加载时则能正常工作。
- en: Moderation is best in all things
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凡事适度
- en: Even though this technique reduces the overall download footprint of each web
    page, it also inevitably increases the number of HTTP requests made. Moreover,
    the practice of loading every template lazily can sometimes increase the time
    that the user will have to wait if the templates are required for the initial
    rendering of the page.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种技术减少了每个网页的总下载量，但也不可避免地增加了所发出的 HTTP 请求的数量。此外，懒加载每个模板的做法有时会增加用户等待的时间，特别是如果模板在页面的初始渲染中是必需的。
- en: Balancing the way that we load our templates between lazy loading and embedding
    them in `<script>` tags usually brings the best of both worlds. This hybrid approach
    is considered a best practice by the industry since it allows us to micromanage
    and fine tune each implementation based on its needs. According to this practice,
    the templates that are required for the presentation of the main content of a
    page are embedded in its HTML, while the rest of them are delivered lazily when
    needed, taking advantage of browser caching.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在懒加载和将模板嵌入 `<script>` 标签之间平衡加载模板的方式通常会带来最佳效果。这种混合方法被行业认为是最佳实践，因为它允许我们根据需要微观管理和微调每个实现。根据这种实践，用于页面主要内容呈现的模板被嵌入到其
    HTML 中，而其余的模板则在需要时延迟提供，利用浏览器缓存。
- en: The implementation of such a template provider function is left as an exercise
    for the reader. As a hint, such methods have to be asynchronous since, when the
    requested template is not found embedded in the `<script>` tag of the page, it
    will have to proceed and make an AJAX request to retrieve it from the server.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此类模板提供程序函数的实现留给读者作为练习。作为提示，此类方法必须是异步的，因为当页面中未找到请求的模板嵌入在 `<script>` 标签中时，它将必须继续并发出
    AJAX 请求从服务器检索它。
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Keep in mind that it is generally preferable to generate the complete initial
    HTML content of the page on the server side instead of using client-side templating.
    This not only leads to a smaller loading time of the initial page content but
    it also prevents situations in which the user is presented with an empty page
    when JavaScript is unavailable or an error has occurred.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，通常更倾向于在服务器端生成页面的完整初始 HTML 内容，而不是使用客户端模板。这不仅会导致初始页面内容的加载时间更短，而且可以防止在 JavaScript
    不可用或发生错误时向用户呈现空白页面的情况发生。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we learned how to use two of the most common client-side templating
    libraries: `Underscore.js` and `Handlebars.js`. We also learned how they allow
    us to create complex HTML templates faster while making our implementations easier
    to read and understand. We then went on to analyze their conventions and evaluate
    their features and learned by example how they can be effectively and efficiently
    used in our implementations.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了如何使用两个最常见的客户端模板库：`Underscore.js` 和 `Handlebars.js`。我们还学习了它们如何帮助我们更快地创建复杂的HTML模板，同时使我们的实现更易于阅读和理解。我们随后分析了它们的惯例，评估了它们的特性，并通过示例学习了它们如何可以有效且高效地在我们的实现中使用。
- en: After completing this chapter, we are now able to generate complex HTML structures
    in a browser efficiently by using readable templates and utilizing the unique
    characteristics of the templating libraries.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，我们现在能够通过使用可读模板和利用模板库的独特特点，在浏览器中高效生成复杂的HTML结构。
- en: In the next chapter, we will learn how to create jQuery Plugins as a way to
    abstract parts of our applications into reusable and extensible implementations.
    We will introduce the most widely used patterns for developing jQuery Plugins
    and analyze the implementation problems that each of them helps to solve.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何创建jQuery插件来将应用程序的部分抽象为可重用和可扩展的实现方式。我们将介绍开发jQuery插件最广泛使用的模式，并分析每种模式帮助解决的实现问题。
