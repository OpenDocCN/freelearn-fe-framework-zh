- en: '*Chapter 4*: Organizing the Code Base and Fetching Data in Next.js'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：组织Next.js中的代码库和获取数据'
- en: Next.js initially became popular thanks to its ability to make it easy to render
    React pages on the server instead of the client only. However, to render specific
    components, we often need some data coming from external sources such as APIs
    and databases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js之所以最初受到欢迎，是因为它能够使在服务器上而不是仅客户端渲染React页面变得容易。然而，为了渲染特定的组件，我们通常需要从外部来源（如API和数据库）获取一些数据。
- en: In this chapter, we will first see how to organize our folder structure, as
    this will be the determinant for keeping the Next.js dataflow neat when managing
    the application state (as we will see in [*Chapter 5*](B16985_05_Final_SB_epub.xhtml#_idTextAnchor068),
    *Managing Local and Global States in Next.js*), and then we will see how to integrate
    external REST and GraphQL APIs, both on client and server-side.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先了解如何组织我们的文件夹结构，因为这将是保持Next.js数据流整洁时管理应用程序状态的决定因素（正如我们将在[*第5章*](B16985_05_Final_SB_epub.xhtml#_idTextAnchor068)，*Next.js中的本地和全局状态管理*中看到的那样），然后我们将了解如何在客户端和服务器端集成外部REST和GraphQL
    API。
- en: As our application grows, its complexity will inevitably increase, and we need
    to be prepared for this since the bootstrapping phase of the project. As soon
    as we implement new features, we will need to add new components, utilities, styles,
    and pages. For that reason, we will take a closer look at organizing our components
    on the basis of the atomic design principles, utility functions, styles, and how
    to make your code base ready for handling the application state quickly and neatly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '随着我们的应用程序的增长，其复杂性不可避免地会增加，我们需要为此做好准备，因为项目的启动阶段。一旦我们实现新功能，我们就需要添加新的组件、实用工具、样式和页面。因此，我们将更详细地研究基于原子设计原则组织我们的组件，实用函数，样式，以及如何使您的代码库能够快速且整洁地处理应用程序状态。 '
- en: 'We will cover the following topics in detail:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细介绍以下主题：
- en: Organizing our components using the atomic design principle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子设计原则组织我们的组件
- en: Organizing our utility functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织我们的实用函数
- en: Organizing static assets neatly
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整洁地组织静态资源
- en: An introduction to organizing styling files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织样式文件的简介
- en: What `lib` files are and how to organize them
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib`文件是什么以及如何组织它们'
- en: Consuming REST APIs on the server side only
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在服务器端消费REST API
- en: Consuming REST APIs on the client side only
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在客户端消费REST API
- en: Setting Apollo to consume GraphQL APIs both on client and server
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Apollo以在客户端和服务器端消费GraphQL API
- en: By the end of this chapter, you will know how to organize your code base by
    following the atomic design principles for your components and how to split up
    different utility files logically. You will also learn how to consume REST and
    GraphQL APIs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何通过遵循组件的原子设计原则来组织您的代码库，以及如何逻辑地分割不同的实用文件。您还将学习如何消费REST和GraphQL API。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code examples in this chapter, you need to have both Node.js and
    npm installed on your local machine. If you prefer, you can use an online IDE
    such as [https://repl.it](https://repl.it) or [https://codesandbox.io](https://codesandbox.io),
    as they both support Next.js and you don't need to install any dependency on your
    computer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码示例，您需要在您的本地机器上安装Node.js和npm。如果您愿意，可以使用在线IDE，例如[https://repl.it](https://repl.it)或[https://codesandbox.io](https://codesandbox.io)，因为它们都支持Next.js，并且您不需要在您的计算机上安装任何依赖项。
- en: 'You can find the code base for this chapter on GitHub: [https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码库：[https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js)。
- en: Organizing the folder structure
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织文件夹结构
- en: Organizing your new project's folder structure neatly and clearly is incredibly
    important in terms of keeping your code base scalable and maintainable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 整洁且清晰地组织您的新项目文件夹结构对于保持代码库可扩展和可维护至关重要。
- en: As we've already seen, Next.js forces you to place some files and folders in
    particular locations of your code base (think of `_app.js` and `_documents.js`
    files, the `pages/` and `public/` directories, and so on), but it also provides
    a way to customize their placement inside your project repository.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，Next.js强制你将一些文件和文件夹放置在你的代码库的特定位置（想想`_app.js`和`_documents.js`文件，`pages/`和`public/`目录等），但它也提供了一种方法来自定义它们在你项目仓库中的位置。
- en: 'We''ve already seen that, but let''s do a quick recap on a default Next.js
    folder structure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了这一点，但让我们快速回顾一下默认的Next.js文件夹结构：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Reading from top to bottom, when we create a new Next.js app using `create-next-app`,
    we get the following folders:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从上到下阅读，当我们使用 `create-next-app` 创建一个新的 Next.js 应用程序时，我们会得到以下文件夹：
- en: '`node_modules/`: The default folder for Node.js project dependencies'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node_modules/`：Node.js 项目依赖项的默认文件夹'
- en: '`pages/`: The directory where we place our pages and build the routing system
    for our web app'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pages/`：放置我们的页面并构建我们的 Web 应用程序路由系统的目录'
- en: '`public/`: The directory where we place files to be served as static assets
    (compiled CSS and JavaScript files, images, and icons)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public/`：放置要作为静态资源（编译后的 CSS 和 JavaScript 文件、图像和图标）提供的文件的目录'
- en: '`styles/`: The directory where we place our styling modules, regardless of
    their format (CSS, SASS, LESS)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styles/`：放置我们的样式模块的目录，无论其格式如何（CSS、SASS、LESS）'
- en: From here, we can start customizing our repository structure to make it easier
    to navigate through. The first thing to know is that Next.js allows us to move
    our `pages/` directory inside an `src/` folder. We can also move all the other
    directories (except for the `public/` one and `node_modules`, of course) inside
    `src/`, making our root directory a bit tidier.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以开始自定义我们的仓库结构，使其更容易导航。首先要知道的是，Next.js 允许我们将 `pages/` 目录移动到 `src/` 文件夹内部。我们还可以将所有其他目录（当然不包括
    `public/` 和 `node_modules`）移动到 `src/` 内部，使我们的根目录更加整洁。
- en: Important Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember that if you have both `pages/` and `src/pages/` directories in your
    project, Next.js will ignore `src/pages/`, as the root level `pages/` directory
    takes precedence.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果您在项目中同时有 `pages/` 和 `src/pages/` 目录，Next.js 将忽略 `src/pages/`，因为根级别的 `pages/`
    目录具有优先级。
- en: We will now take a look at some popular conventions for organizing the whole
    code base, starting with React components, in the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一些组织整个代码库的流行约定，从 React 组件开始。
- en: Organizing the components
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织组件
- en: Now, let's see an example of a real-world folder structure, including some styling
    assets ([*Chapter 6*](B16985_06_Final_SB_epub.xhtml#_idTextAnchor075), *CSS and
    Built-In Styling Methods)* and test files ([*Chapter 9*](B16985_09_Final_SB_epub.xhtml#_idTextAnchor096),
    *Testing Next.js*).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个真实世界的文件夹结构示例，包括一些样式资产（[*第 6 章*](B16985_06_Final_SB_epub.xhtml#_idTextAnchor075)，*CSS
    和内置样式方法*）和测试文件（[*第 9 章*](B16985_09_Final_SB_epub.xhtml#_idTextAnchor096)，*测试 Next.js*）。
- en: As for now, we will only discuss a folder structure that can help us write and
    find configuration files, components, tests, and styles with ease. We will dig
    into the previously quoted technologies in their respective chapters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，我们将只讨论一个可以帮助我们轻松编写和查找配置文件、组件、测试和样式的文件夹结构。我们将在各自的章节中深入探讨之前引用的技术。
- en: We have different ways of setting up our folder structure. We can start by separating
    components into three different categories and then putting styles and tests in
    the same folder for each component.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有不同方式来设置我们的文件夹结构。我们可以从将组件分为三个不同的类别开始，然后将样式和测试放在每个组件的同一文件夹中。
- en: 'To do that, create a new `components/` folder inside our root directory. Then,
    by moving inside it, create the following folders:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，在我们的根目录内创建一个新的 `components/` 文件夹。然后，进入它，创建以下文件夹：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you may have noticed, we're following the *atomic design principle*, where
    we want to divide our components into different levels so as to organize our code
    base better. This is just a popular convention, and you're free to follow any
    other approach for organizing your code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，我们正在遵循 *原子设计原则*，我们希望将我们的组件划分为不同的层级，以便更好地组织我们的代码库。这只是一个流行的约定，您可以根据自己的喜好选择任何其他方法来组织您的代码。
- en: 'We will divide our components into four categories:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的组件划分为四个类别：
- en: '`atoms`: These are the most basic components that we will ever write in our
    code base. Sometimes, they act as a wrapper for standard HTML elements such as
    `button`, `input`, and `p`, but we can also add animations, color palettes, and
    so on, to this category of components.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atoms`：这是我们将在代码库中编写的最基本组件。有时，它们充当标准 HTML 元素（如 `button`、`input` 和 `p`）的包装器，但我们也可以向这类组件添加动画、调色板等。'
- en: '`molecules`: These are a small group of atoms combined to create slightly more
    complex structures with a minimum of utility. The input atom and the label atom
    together can be a straightforward example of what a molecule is.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`molecules`：这些是由原子组合而成的小组，用于创建具有最小实用性的稍微复杂一些的结构。输入原子和标签原子一起可以是一个分子是什么的简单例子。'
- en: '`organisms`: Molecules and atoms combine to create complex structures, such
    as a registration form, a footer, and a carousel.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`organisms`：分子和原子结合形成复杂结构，例如注册表单、页脚和轮播图。'
- en: '`templates`: We can think of templates as the skeleton of our pages. Here,
    we decide where to put organisms, atoms, and molecules together to create the
    final page that the user will browse.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates`：我们可以将模板视为我们页面的骨架。在这里，我们决定将有机体、原子和分子放在一起，以创建用户最终将浏览的最终页面。'
- en: 'If you''re interested in learning more about atomic design, here''s a good
    article explaining it in detail: [https://bradfrost.com/blog/post/atomic-web-design](https://bradfrost.com/blog/post/atomic-web-design).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于原子设计的信息，这里有一篇很好的文章详细解释了它：[https://bradfrost.com/blog/post/atomic-web-design](https://bradfrost.com/blog/post/atomic-web-design)。
- en: 'Now, let''s pretend that we want to create a `Button` component. When we create
    a new component, we often need at least three different files: the component itself,
    its style, and a test file. We can create those files by moving inside `components/atoms/`
    and then creating a new folder called `Button/`. Once we create this folder, we
    can move on to creating the components'' files:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们想要创建一个`Button`组件。当我们创建一个新的组件时，我们通常至少需要三个不同的文件：组件本身、其样式和一个测试文件。我们可以通过移动到`components/atoms/`并创建一个名为`Button/`的新文件夹来创建这些文件。一旦我们创建了此文件夹，我们就可以继续创建组件的文件：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Organizing our components that way will help us a lot when we need to search,
    update, or fix a given component. Let's say that we spot a bug in production that
    involves our `Button` component. We can easily find the component inside our code
    base, find its test and styling files, and fix them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式组织我们的组件将极大地帮助我们，当我们需要搜索、更新或修复给定的组件时。假设我们在生产环境中发现了一个涉及我们的`Button`组件的bug。我们可以在我们的代码库中轻松找到该组件，找到其测试和样式文件，并修复它们。
- en: Of course, following the atomic design principle is not a must, but I'd personally
    recommend it as it helps keep the project structure tidy and easy to maintain
    over time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，遵循原子设计原则不是必须的，但我个人推荐这样做，因为它有助于保持项目结构整洁且易于长期维护。
- en: Organizing utilities
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织实用工具
- en: There are specific files that don't export any component; they're just modular
    scripts used for many different purposes. We're talking here about the utility
    scripts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些文件不导出任何组件；它们只是用于许多不同目的的模块化脚本。我们在这里谈论的是实用脚本。
- en: Let's pretend that we have several components whose purpose is to check whether
    a particular hour of the day has passed to display certain information. It wouldn't
    make any sense to write the same function inside every component. We can therefore
    write a generic utility function and then import it inside every component that
    needs that kind of feature.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们有几个组件，它们的目的是检查一天中的特定小时是否已经过去以显示某些信息。在每一个组件内部编写相同的函数是没有意义的。因此，我们可以编写一个通用的实用函数，然后将其导入需要这种功能的每个组件中。
- en: 'We can put all of our utility functions inside a `utility/` folder and then
    divide our utilities into different files according to their purpose. For example,
    let''s say that we need four utility functions: the first one will make computations
    based on the current time, the second will execute certain operations on `localStorage`,
    the third will work with **JWT (JSON Web Token)**, and the last one will help
    us to write better logs for our applications.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有的实用函数放在一个`utility/`文件夹中，并根据它们的目的将我们的实用工具分成不同的文件。例如，假设我们需要四个实用函数：第一个将基于当前时间进行计算，第二个将在`localStorage`上执行某些操作，第三个将处理**JWT
    (JSON Web Token**)，最后一个将帮助我们为我们的应用程序编写更好的日志。
- en: 'We can proceed by creating four different files inside the `utilities/` directory:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`utilities/`目录内创建四个不同的文件来继续：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we''ve created our files, we can proceed by creating their respective
    test files:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了文件，我们可以通过创建它们各自的测试文件来继续：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At this point, we have our utilities grouped by their scope, which makes it
    easy to remember from which file we need to import a specific function during
    the development process.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经根据它们的范围将我们的实用工具分组，这使得在开发过程中记住在哪个文件中导入特定的函数变得容易。
- en: There might be other approaches for organizing utility files. You may want to
    create a folder for each utility file so that you can put tests, styles, and other
    stuff inside it, thereby making your code base even more organized. It's totally
    up to you!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有其他组织实用文件的方法。你可能想为每个实用文件创建一个文件夹，以便你可以在其中放置测试、样式和其他内容，从而使你的代码库更加有序。这完全取决于你！
- en: Organizing static assets
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织静态资源
- en: As seen in the previous chapter, Next.js makes it easy to serve static files,
    as you only need to put them inside the `public/` folder, and the framework will
    do the rest.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所示，Next.js 使提供静态文件变得容易，您只需将它们放在 `public/` 文件夹中，框架就会完成剩余的工作。
- en: From this point, we need to figure out which static files we need to serve from
    our Next.js application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，我们需要确定我们需要从 Next.js 应用程序中提供哪些静态文件。
- en: 'In a standard website, we may want to serve at least the following static assets:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个标准网站上，我们可能至少想要提供以下静态资源：
- en: Images
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片
- en: Compiled JavaScript files
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译后的 JavaScript 文件
- en: Compiled CSS files
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译后的 CSS 文件
- en: Icons (including favicon and web app icons)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图标（包括favicon和web应用图标）
- en: '`manifest.json`, `robot.txt`, and other static files'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manifest.json`、`robot.txt` 和其他静态文件'
- en: 'Moving inside our `public/` folder, we can create a new directory called `assets/`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 进入我们的 `public/` 文件夹，我们可以创建一个名为 `assets/` 的新目录：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And inside that newly created directory, we will be creating a new folder for
    each type of static asset:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在新创建的目录内部，我们将为每种类型的静态资源创建一个新的文件夹：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will place our compiled vendor JavaScript files inside the `js/` directory
    and do the same with compiled vendor CSS files (inside the `css/` directory, of
    course). When starting our Next.js server, we will be able to reach those public
    files under http://localhost:3000/assets/js/<any-js-file> and http://localhost:3000/assets/css/<any-css-file>.
    We will also be able to reach every public image by calling the following URL,
    http://localhost:3000/assets/image/<any-image-file>, but I suggest that you serve
    those kinds of assets using the built-in `Image` component, as seen in the previous
    chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把编译后的供应商 JavaScript 文件放在 `js/` 目录中，同样地，编译后的供应商 CSS 文件也会放在 `css/` 目录中（当然是在
    `css/` 目录中）。当我们启动 Next.js 服务器时，我们可以在 http://localhost:3000/assets/js/<任何-js 文件>
    和 http://localhost:3000/assets/css/<任何-css 文件> 下访问这些公共文件。我们还可以通过调用以下 URL 来访问每个公共图像，http://localhost:3000/assets/image/<任何图像文件>，但我建议您使用内置的
    `Image` 组件来提供这类资源，正如前一章所展示的。
- en: The `icons/` directory will primarily be used to serve our *web app manifest*
    icons. The web app manifest is a JSON file that includes some useful information
    about the progressive web app that you're building, such as the app name and the
    icons to use when installing it on a mobile device. You can learn more about the
    web app manifest on [https://web.dev/add-manifest](https://web.dev/add-manifest).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`icons/` 目录主要用于提供我们的 *web应用清单* 图标。web应用清单是一个包含有关您正在构建的渐进式网络应用的一些有用信息的JSON文件，例如应用名称和安装到移动设备时使用的图标。您可以在
    [https://web.dev/add-manifest](https://web.dev/add-manifest) 上了解更多关于web应用清单的信息。'
- en: 'We can easily create this manifest file by entering the `public/` folder and
    adding a new file called `manifest.json`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地创建这个清单文件，通过进入 `public/` 文件夹并添加一个名为 `manifest.json` 的新文件：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At this point, we can fill the JSON file with some basic information. Let''s
    take the following JSON as an example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以用一些基本信息填充JSON文件。以下是一个JSON示例：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can include that file using an HTML meta tag, as seen in [*Chapter 3*](B16985_03_Final_SB_epub.xhtml#_idTextAnchor038),
    *Next.js Basics and Built-In Components*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用HTML meta标签来包含该文件，如[第3章](B16985_03_Final_SB_epub.xhtml#_idTextAnchor038)中所示，*Next.js
    基础和内置组件*：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That way, users browsing your Next.js app from a mobile device will be able
    to install it on their smartphones or tablets.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，从移动设备浏览您的 Next.js 应用程序的用户将能够在他们的智能手机或平板电脑上安装它。
- en: Organizing styles
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样式组织
- en: Style organization can really depend on the stack you want to use to style your
    Next.js application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 样式组织实际上可以取决于您想要用于样式化 Next.js 应用的堆栈。
- en: Starting from *CSSinJS* frameworks such as *Emotion*, *styled-components*, *JSS*,
    and similar ones, one common approach is to create a specific styling file for
    each component; that way, it will be easier for us to find a particular component
    style inside our code base when we need to make some changes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *CSSinJS* 框架，如 *Emotion*、*styled-components*、*JSS* 和类似框架开始，一个常见的方法是为每个组件创建一个特定的样式文件；这样，当我们需要做出一些更改时，我们更容易在我们的代码库中找到特定的组件样式。
- en: However, even though separating styling files depending on their respective
    components can help us keep our code base organized, we may need to create some
    common styles or utility files, such as color palettes, themes, and media queries.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管根据各自的组件来分离样式文件可以帮助我们保持代码库的整洁，我们可能还需要创建一些通用样式或实用文件，例如调色板、主题和媒体查询。
- en: In that case, it can be useful to reuse the default `styles/` directory shipped
    with a default Next.js installation. We can put our common styles inside that
    folder and import them inside other styling files only when we need them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，重用默认 Next.js 安装中提供的默认 `styles/` 目录可能很有用。我们可以将我们的常用样式放在这个文件夹中，并在需要时在其他样式文件中导入它们。
- en: That said, there isn't really a standard way to organize styling files. We will
    take a closer look at those files in both [*Chapter 6*](B16985_06_Final_SB_epub.xhtml#_idTextAnchor075),
    *CSS and Built-In Styling Methods*, and [*Chapter 7*](B16985_07_Final_SB_epub.xhtml#_idTextAnchor081),
    *Using UI Frameworks*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，实际上并没有一个标准的组织样式文件的方法。我们将在 [*第6章*](B16985_06_Final_SB_epub.xhtml#_idTextAnchor075)，*CSS
    和内置样式方法*，以及 [*第7章*](B16985_07_Final_SB_epub.xhtml#_idTextAnchor081)，*使用 UI 框架*
    中更详细地查看这些文件。
- en: Lib files
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lib 文件
- en: When talking about lib files, we refer to scripts that explicitly wrap third-party
    libraries as lib files. While the utility scripts are very generic and can be
    used by many different components and libraries, the lib files are specific for
    a certain library. To make the concept clearer, let's talk about GraphQL for a
    moment.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到 lib 文件时，我们指的是明确封装第三方库的脚本作为 lib 文件。虽然实用脚本非常通用，可以被许多不同的组件和库使用，但 lib 文件是针对特定库的。为了使这个概念更清晰，让我们暂时谈谈
    GraphQL。
- en: As we're going to see in *Data fetching*, the last section of this chapter,
    we will need to initialize a GraphQL client, save some GraphQL queries and mutations
    locally, and so on. To make those scripts more modular, we will store them inside
    a new folder called `graphql/`, which lies inside a `lib/` directory, at the root
    of our project.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章的最后部分 *数据获取* 中看到的，我们需要初始化一个 GraphQL 客户端，本地保存一些 GraphQL 查询和突变，等等。为了使这些脚本更模块化，我们将它们存储在一个名为
    `graphql/` 的新文件夹中，该文件夹位于 `lib/` 目录内，位于我们项目的根目录。
- en: 'If we try to visualize the folder structure for the preceding example, we will
    end up with the following schema:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试可视化前述示例的文件夹结构，我们将得到以下模式：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Other lib scripts can include all those files connecting and making queries
    to Redis, RabbitMQ, and so on, or functions specific to any external library.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 lib 脚本可以包括所有连接和向 Redis、RabbitMQ 等进行查询的文件，或者针对任何外部库的特定函数。
- en: While an organized folder structure seems out of context when talking about
    the Next.js data flow, it can actually help us to manage the application state,
    as we will see in [*Chapter 5*](B16985_05_Final_SB_epub.xhtml#_idTextAnchor068),
    *Managing Local and Global States in Next.js*
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论 Next.js 数据流时，一个有组织的文件夹结构似乎与上下文不符，但实际上它可以帮助我们管理应用程序状态，正如我们将在 [*第5章*](B16985_05_Final_SB_epub.xhtml#_idTextAnchor068)，*在
    Next.js 中管理本地和全局状态* 中看到的。
- en: But talking about the application state, we want our components to be dynamic
    most of the time, meaning that they can render content and behave differently
    depending on the global application state or the data coming from external services.
    In fact, we need to call external APIs to retrieve our web app content dynamically
    in many cases. In the next section, we will see how to fetch data on the client
    and server sides, using both GraphQL and REST clients.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但谈到应用程序状态，我们希望大多数时候我们的组件是动态的，这意味着它们可以根据全局应用程序状态或来自外部服务的数据进行内容渲染和行为变化。实际上，在许多情况下，我们需要调用外部
    API 来动态检索我们的网络应用程序内容。在下一节中，我们将看到如何使用 GraphQL 和 REST 客户端在客户端和服务器端获取数据。
- en: Data fetching
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据获取
- en: 'As seen in the previous chapters, Next.js allows us to fetch data on both the
    client and server sides. Server-side data fetching could happen in two different
    moments: at build time (using `getStaticProps` for static pages), and at runtime
    (using `getServerSideProps` for server-side rendered pages).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，Next.js 允许我们在客户端和服务器端获取数据。服务器端数据获取可以在两个不同的时刻发生：在构建时（使用 `getStaticProps`
    为静态页面），以及在运行时（使用 `getServerSideProps` 为服务器端渲染的页面）。
- en: 'Data can come from several resources: databases, search engines, external APIs,
    filesystems, and many other sources. Even if it''s technically possible for Next.js
    to access a database and query for specific data, I''d personally discourage that
    approach as Next.js should only care about the frontend of our application.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以来自多个资源：数据库、搜索引擎、外部 API、文件系统，以及许多其他来源。尽管技术上 Next.js 可以访问数据库并查询特定数据，但我个人会劝阻这种做法，因为
    Next.js 应该只关心我们应用程序的前端。
- en: 'Let''s take an example: we''re building a blog, and we want to display an author
    page showing their name, job title, and biography. In that example, the data is
    stored in a MySQL database, and we could easily access it using any MySQL client
    for Node.js.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子：我们正在构建一个博客，我们想要显示一个作者页面，展示他们的姓名、职位和传记。在这个例子中，数据存储在 MySQL 数据库中，我们可以使用任何
    Node.js 的 MySQL 客户端轻松访问它。
- en: Even though accessing that data from Next.js can be relatively easy, it would
    make our app less secure. A malicious user could potentially find a way to exploit
    our data using an unknown framework vulnerability, injecting malicious code, and
    using other techniques to steal our data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从 Next.js 访问这些数据相对容易，但这会使我们的应用安全性降低。恶意用户可能会找到一种方法利用未知框架漏洞来利用我们的数据，注入恶意代码，并使用其他技术窃取我们的数据。
- en: For that reason, I strongly suggest delegating database connections and queries
    to external systems (in other words, CMSes such as *WordPress*, *Strapi*, and
    *Contentful*) or backend frameworks (in other words, *Spring*, *Laravel*, and
    *Ruby on Rails*), which will make sure that the data is coming from a trusted
    source, will sanitize the user input detecting potentially malicious code, and
    will establish a secure connection between your Next.js application and their
    APIs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我强烈建议将数据库连接和查询委托给外部系统（换句话说，如 *WordPress*、*Strapi* 和 *Contentful* 这样的 CMS）或后端框架（换句话说，*Spring*、*Laravel*
    和 *Ruby on Rails*），这将确保数据来自可信的来源，将检测到潜在的恶意代码的用户输入进行清理，并在您的 Next.js 应用程序和它们的 API
    之间建立安全的连接。
- en: In the following sections, we will see how to integrate *REST* and *GraphQL*
    APIs from both the client side and the server side.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到如何从客户端和服务器端集成 *REST* 和 *GraphQL* API。
- en: Fetching data on the server side
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务器端获取数据
- en: As we've seen so far, Next.js allows us to fetch data on the server side by
    using its built-in `getStaticProps` and `getServerSideProps` functions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Next.js 允许我们通过使用其内置的 `getStaticProps` 和 `getServerSideProps` 函数在服务器端获取数据。
- en: 'Given that Node.js doesn''t support JavaScript `fetch` APIs like browsers do,
    we have two options for making HTTP requests on the server:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Node.js 不支持浏览器那样的 JavaScript `fetch` API，我们在服务器上发起 HTTP 请求有两个选择：
- en: 'Using the Node.js'' built-in `http` library: We can use this module without
    installing any external dependency, but even if its APIs are really simple and
    well made, it would require a bit of extra work when compared to third-party HTTP
    clients.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Node.js 内置的 `http` 库：我们可以不安装任何外部依赖项就使用此模块，但即使它的 API 简单且制作精良，与第三方 HTTP 客户端相比，它可能需要做更多额外的工作。
- en: 'Using HTTP client libraries: There are several great HTTP clients for Next.js,
    making it really straightforward to make HTTP requests from the server. Popular
    libraries include *isomorphic-unfetch* (this renders the JavaScript `fetch` API
    available on Node.js), *Undici* (an official Node.js HTTP 1.1 client), and *Axios*
    (a very popular HTTP client that runs both on client and server with the same
    APIs).'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 HTTP 客户端库：Next.js 有几个优秀的 HTTP 客户端，使得从服务器发起 HTTP 请求变得非常简单。流行的库包括 *isomorphic-unfetch*（使
    JavaScript `fetch` API 在 Node.js 上可用）、*Undici*（官方 Node.js HTTP 1.1 客户端）和 *Axios*（一个非常流行的
    HTTP 客户端，在客户端和服务器上运行，具有相同的 API）。
- en: In the next section, we will be using *Axios* to make REST requests, as it is
    probably one of the most frequently used HTTP clients for both client and server
    (with ~17,000,000 downloads per week on npm), and there's a high chance that you
    will be using it sooner or later.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用 *Axios* 来发起 REST 请求，因为它可能是客户端和服务器上最常用的 HTTP 客户端之一（每周在 npm 上下载量约为
    ~17,000,000 次），你迟早会用到它。
- en: Consuming REST APIs on the server side
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务器端消费 REST API
- en: When discussing the integration of REST APIs, we need to divide them into *public*
    and *private* APIs. The public ones are accessible by anyone without any kind
    of authorization, and the private ones always need to be authorized to return
    some data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论 REST API 的集成时，我们需要将它们分为 *公共* 和 *私有* API。公共 API 任何人都可以无授权访问，而私有 API 总是需要授权才能返回某些数据。
- en: 'Also, the authorization method is not always the same (and different APIs might
    require different authorization methods), as it depends on who developed the APIs
    and the choices they made. For instance, if you want to consume any of the *Google*
    APIs, you would need to go into a process called *OAuth 2.0*, which is an industry
    standard for securing APIs under user authentication. You can read more about
    OAuth 2.0 in the official Google documentation: [https://developers.google.com/identity/protocols/oauth2](https://developers.google.com/identity/protocols/oauth2).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，授权方法并不总是相同的（不同的API可能需要不同的授权方法），因为它取决于谁开发了API以及他们的选择。例如，如果您想使用任何 *Google*
    API，您将需要进入一个称为 *OAuth 2.0* 的过程，这是在用户身份验证下保护API的行业标准。您可以在官方Google文档中了解更多关于OAuth
    2.0的信息：[https://developers.google.com/identity/protocols/oauth2](https://developers.google.com/identity/protocols/oauth2)。
- en: Other APIs, such as the *Pexels* APIs ([https://www.pexels.com/api/documentation](https://www.pexels.com/api/documentation)),
    allow you to consume their contents using an *API key*, which is basically an
    authorization token that you'll need to send within your request.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 其他API，如 *Pexels* API（[https://www.pexels.com/api/documentation](https://www.pexels.com/api/documentation)），允许您使用
    *API key* 消费其内容，这基本上是一个授权令牌，您需要在请求中发送它。
- en: There may be other ways in which to authorize your requests, but Oauth 2.0,
    JWT, and API Key are the most common ways that you'll likely encounter while developing
    your Next.js applications.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有其他方式可以授权您的请求，但Oauth 2.0、JWT和API Key是在开发Next.js应用程序时您可能会遇到的最常见方式。
- en: 'If, after reading this section, you want to experiment with different APIs
    and authorization methods, here''s an awesome GitHub repository containing a list
    of free REST APIs: https://github.com/public-apis/public-apis.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在阅读本节后，您想尝试不同的API和授权方法，这里有一个包含免费REST API列表的出色的GitHub仓库：https://github.com/public-apis/public-apis。
- en: 'For now, we will be using a custom API explicitly made for this book: [https://api.realworldnextjs.com](https://api.realworldnextjs.com)
    (or, if you prefer: https://api.rwnjs.com). We can start by creating a new Next.js
    project:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将使用为本书专门制作的自定义API：[https://api.realworldnextjs.com](https://api.realworldnextjs.com)（或者，如果您更喜欢：https://api.rwnjs.com）。我们可以从创建一个新的Next.js项目开始：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After running the Next.js initialization script, we can add `axios` as a dependency,
    as we''ll use it as an HTTP client for making REST requests:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Next.js初始化脚本后，我们可以添加 `axios` 作为依赖项，因为我们将其用作HTTP客户端来制作REST请求：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At this point, we can easily edit the default Next.js index page. Here, we will
    list some users using a public API exposing just their usernames and personal
    IDs. After we click on one of the usernames, we will be redirected to a detail
    page to see more personal details for our users.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以轻松地编辑默认的Next.js首页。在这里，我们将使用公开API列出一些用户，仅暴露他们的用户名和个人ID。点击其中一个用户名后，我们将被重定向到一个详情页面，以查看更多关于我们用户的个人信息。
- en: 'Let''s start by creating the `pages/index.js` page layout:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建 `pages/index.js` 页面布局开始：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we try to run the preceding code, we will see an error, as we don''t yet
    have our users'' data. We need to call a REST API from the built-in `getServerSideProps`
    and pass the request result as a prop to the `HomePage` component:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行前面的代码，我们会看到错误，因为我们还没有我们的用户数据。我们需要从内置的 `getServerSideProps` 调用一个REST
    API，并将请求结果作为prop传递给 `HomePage` 组件：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, run the server and then go to `http://localhost:3000`. We should see the
    following list of users to appear on the browser:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行服务器然后访问 `http://localhost:3000`。我们应该在浏览器中看到以下用户列表：
- en: '![Figure 4.1 – API result rendered on the browser'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.1 – API result rendered on the browser]'
- en: '](img/Figure_4.01_B16985.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.01_B16985.jpg]'
- en: Figure 4.1 – API result rendered on the browser
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 浏览器上渲染的API结果
- en: If we now try to click on one of the listed users, we will be redirected to
    a 404 page, as we haven't created a single page user yet.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试点击列表中的任何一个用户，我们将被重定向到一个404页面，因为我们还没有创建单个页面用户。
- en: We can solve that problem by creating a new file, `pages/users/[username].js`,
    and calling another REST API to get the single user data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个新的文件，`pages/users/[username].js`，并调用另一个REST API来获取单个用户数据来解决这个问题。
- en: To get the single user data, we can call the following URL, https://api.rwnjs.com/04/users/[username],
    where `[username]` is a route variable representing the user we want to get the
    data of.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取单个用户数据，我们可以调用以下URL，https://api.rwnjs.com/04/users/[username]，其中 `[username]`
    是一个路由变量，代表我们想要获取数据的用户。
- en: 'Let''s move to the `pages/users/[username].js` file and add the following content,
    starting with the `getServerSideProps` function:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到 `pages/users/[username].js` 文件，并添加以下内容，从 `getServerSideProps` 函数开始：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, inside the same file, let''s add a `UserPage` function, which will be
    the page template for our `/users/[username]` route:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在同一个文件中，让我们添加一个 `UserPage` 函数，它将是我们的 `/users/[username]` 路由的页面模板：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But there''s still a problem: if we try to render a single user page, we will
    get an error on the server side as we are not authorized to get the data from
    that API. Remember what we said at the beginning of this section? Not all APIs
    are public, which makes a lot of sense as there are times where we want to access
    very private information and companies and developers protect this information
    by restricting access to their APIs to authorized people only.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 但仍然存在一个问题：如果我们尝试渲染单个用户页面，由于我们没有权限从该API获取数据，我们将在服务器端收到错误。还记得我们在这个部分开头提到的话吗？并非所有API都是公开的，这在很多情况下是有意义的，因为有时我们想访问非常私人的信息，公司和开发人员通过仅允许授权人员访问他们的API来保护这些信息。
- en: 'In that case, we need to pass a valid token as an HTTP authorization header
    while making the API request, such that the server will know that we are authorized
    to access this information:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，我们需要在发起API请求时传递一个有效的令牌作为HTTP授权头，这样服务器就会知道我们有权限访问这些信息：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, `axios` makes it really easy to add an HTTP header to the request,
    as we only need to pass an object as the second argument of its `get` method,
    containing a property called `headers`, which is an object including all the HTTP
    headers we want to send to the server within our request.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`axios` 使得向请求中添加HTTP头变得非常简单，因为我们只需要将一个对象作为其 `get` 方法的第二个参数传递，该对象包含一个名为
    `headers` 的属性，它是一个对象，包含我们想要在请求中发送到服务器的所有HTTP头。
- en: 'You may be wondering what `process.env.API_TOKEN` stands for. While it is possible
    to pass a hardcoded string as a value for that header, it is bad practice for
    the following reasons:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道 `process.env.API_TOKEN` 是什么意思。虽然可以将硬编码的字符串作为该头部的值传递，但出于以下原因，这并不是一个好的做法：
- en: When committing your code using Git or any other version control system, everyone
    having access to that repository will be able to read private information such
    as the authorization token (even outside collaborators). Consider this as a password
    that should be kept secret.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你使用Git或其他版本控制系统提交代码时，所有有权访问该存储库的人都将能够读取私人信息，如授权令牌（即使是在外部协作者）。请将其视为应该保密的密码。
- en: 'Most of the time, API tokens change depending on the stage at which we''re
    running our application: running our app locally, we may want to access APIs using
    a test token, and use a production one when deploying it. Using an environment
    variable will make it easier for us to use different tokens depending on the environment.
    The same is valid for API endpoints, but we will see that later on in this section.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数情况下，API令牌会根据我们运行应用程序的阶段而变化：在本地运行我们的应用程序时，我们可能想使用测试令牌访问API，而在部署时使用生产令牌。使用环境变量将使我们能够根据环境使用不同的令牌。对于API端点也是如此，但我们将稍后在本文档的这一部分中看到。
- en: If an API token changes for any reason, you can easily edit it using a shared
    environment file for the whole app instead of changing the token value in every
    HTTP request.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出于任何原因API令牌发生变化，你可以轻松地使用整个应用程序的共享环境文件来编辑它，而不是在每个HTTP请求中更改令牌值。
- en: So, instead of manually writing sensitive data inside our files, we can create
    a new file called `.env` inside our project's root and add all the information
    we need for our application to run.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不必手动在我们的文件中写入敏感数据，我们可以在项目的根目录内创建一个新的文件名为 `.env`，并将我们应用程序运行所需的所有信息添加到该文件中。
- en: Never Commit Your .env File
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要提交 .env 文件
- en: The `.env` file contains sensitive and private information and should never
    be committed using any version control software. Make sure to add `.env` to your
    `.gitignore`, `.dockerignore`, and other similar files before deploying or committing
    your code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`.env` 文件包含敏感和私人信息，不应使用任何版本控制软件提交。在部署或提交代码之前，请确保将 `.env` 添加到 `.gitignore`、`.dockerignore`
    和其他类似文件中。'
- en: 'Now, let''s create and edit the `.env` file by adding the following content:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建并编辑 `.env` 文件，添加以下内容：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next.js has built-in support for `.env` and `.env.local` files, so you don't
    have to install external libraries to access those environment variables.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 内置了对 `.env` 和 `.env.local` 文件的支持，因此你不需要安装外部库来访问这些环境变量。
- en: 'After we''ve edited the file, we can restart the Next.js server and click on
    any user listed on the home page, thereby accessing the user detail page, which
    should look like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑完文件后，我们可以重启Next.js服务器，并点击主页上列出的任何用户，从而访问用户详情页面，其外观应如下所示：
- en: '![Figure 4.2 – The user detail page'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – 用户详情页面'
- en: '](img/Figure_4_02_B16985.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4_02_B16985.jpg)'
- en: Figure 4.2 – The user detail page
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 用户详情页面
- en: 'If we try to reach a page such as `http://localhost:3000/users/mitch`, we will
    get an error, as a user with `mitch` as their username does not exist, and the
    REST API will return a `404` status code. We can easily catch this error and return
    the Next.js default 404 page by just adding the following script to the `getServerSideProps`
    function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试访问像`http://localhost:3000/users/mitch`这样的页面，我们会得到一个错误，因为不存在用户名为`mitch`的用户，REST
    API将返回`404`状态码。我们可以轻松地捕获这个错误，并通过在`getServerSideProps`函数中添加以下脚本返回Next.js默认的404页面：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That way, Next.js will automatically redirect us to its default `404` page with
    no other configuration needed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，Next.js将自动将我们重定向到其默认的`404`页面，无需其他配置。
- en: So, we've seen how Next.js allows us to fetch data exclusively on the server
    side by using its built-in `getServerSideProps` function. We could have used the
    `getStaticProps` function instead, meaning that the page would have been statically
    rendered at build time, as seen in [*Chapter 2*](B16985_02_Final_SB_epub.xhtml#_idTextAnchor029),
    *Exploring Different Rendering Strategies*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了Next.js如何通过使用其内置的`getServerSideProps`函数允许我们在服务器端独家获取数据。我们本可以使用`getStaticProps`函数，这意味着页面将在构建时进行静态渲染，正如在[*第2章*](B16985_02_Final_SB_epub.xhtml#_idTextAnchor029)中看到的，*探索不同的渲染策略*。
- en: In the next section, we will see how to fetch data on the client side only.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何仅从客户端获取数据。
- en: Fetching data on the client side
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在客户端获取数据
- en: Client-side data fetching is a crucial part of any dynamic web application.
    While server-side data fetching can be relatively secure (when done with caution),
    fetching data on the browser can add some extra complexities and vulnerabilities.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端数据获取是任何动态Web应用的关键部分。虽然服务器端数据获取相对安全（当谨慎操作时），但在浏览器上获取数据可能会增加一些额外的复杂性和漏洞。
- en: Making HTTP requests on the server hides the API endpoint, parameters, HTTP
    headers, and possibly the authorization tokens from the users. However, doing
    so from the browser can reveal that private information, making it easy for malicious
    users to perform a plethora of possible attacks that exploit your data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上执行HTTP请求会隐藏API端点、参数、HTTP头信息以及可能存在的授权令牌，从而保护用户信息不被泄露。然而，从浏览器端执行此类操作可能会暴露这些私人信息，使得恶意用户能够轻易地执行一系列可能的攻击，从而利用你的数据。
- en: 'When making HTTP requests on browsers, some specific rules are not optional:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器上发起HTTP请求时，一些特定的规则是必不可少的：
- en: '*Make HTTP requests to trusted sources only*. You should always do some research
    about who is developing the APIs you''re using and their security standards.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*仅向可信来源发起HTTP请求*。你应该始终对开发你使用的API的开发者及其安全标准进行一些研究。'
- en: '*Call HTTP APIs only when secured with an SSL certificate*. If a remote API
    is not secured under HTTPS, you''re exposing yourself and your users to many attacks,
    such as man-in-the-middle, where a malicious user could sniff all the data passing
    from the client and the server using a simple proxy.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*仅当使用SSL证书加密时才调用HTTP API*。如果一个远程API没有在HTTPS下进行加密，那么你和你用户的个人信息就会暴露在许多攻击之下，例如中间人攻击，恶意用户可以通过简单的代理嗅探客户端和服务器之间传输的所有数据。'
- en: '*Never connect to a remote database from the browser*. It may seem obvious,
    but it is technically possible for JavaScript to access remote databases. This
    exposes you and your users to high risk, as anyone could potentially exploit a
    vulnerability and gain access to your database.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*永远不要从浏览器连接到远程数据库*。这看似显而易见，但从技术上讲，JavaScript可以访问远程数据库。这会使你和你用户面临高风险，因为任何人都有可能利用漏洞并访问你的数据库。'
- en: In the next section, we will take a closer look at consuming REST APIs on the
    client side.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更深入地探讨客户端如何消费REST API。
- en: Consuming REST APIs on the client side
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在客户端消费REST API
- en: Similar to the server side, fetching data on the client side is relatively easy,
    and if you already have experience in React or any other JavaScript framework
    or library, you can re-use your current knowledge for making REST requests from
    the browser without any complications.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器端类似，客户端获取数据相对简单，如果你已经具备React或其他JavaScript框架或库的经验，你可以直接利用现有知识，从浏览器端发起REST请求而无需任何复杂操作。
- en: While the server-side data fetching phase in Next.js only occurs when declared
    inside its built-in `getServerSideProps` and `getStaticProps` functions, if we
    make a fetch request inside a given component, it will be executed on the client
    side by default.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在Next.js中，服务器端数据获取阶段仅在声明在其内置的`getServerSideProps`和`getStaticProps`函数内时发生，如果我们在一个给定组件内发起fetch请求，它将默认在客户端执行。
- en: 'We usually want our client-side requests to run in two cases:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常希望客户端请求在两种情况下运行：
- en: Right after the component has mounted
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件挂载后立即
- en: After a particular event occurs
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定事件发生后
- en: In both cases, Next.js doesn't force you to execute those requests differently
    than React, so you can basically make an HTTP request using the browser's built-in
    `fetch` API or an external library such as `axios`, just like we saw in the previous
    section. Let's try to recreate the same simple Next.js application from the previous
    section, but move all the API calls to the client side.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，Next.js不会强制您以不同于React的方式执行这些请求，因此您基本上可以使用浏览器的内置`fetch` API或像`axios`这样的外部库来发起HTTP请求，就像我们在上一节中看到的那样。让我们尝试重新创建上一节中相同的简单Next.js应用程序，但将所有API调用移动到客户端。
- en: 'Create a new Next.js project and edit the `pages/index.js` file as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Next.js项目，并编辑`pages/index.js`文件，如下所示：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Can you spot the differences between this component and its SSR counterpart?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您能发现这个组件与其SSR对应组件之间的区别吗？
- en: The HTML generated on the server side contains the `Loading users...` text,
    as it is the initial state of our `HomePage` component.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端生成的HTML包含`Loading users...`文本，因为这是我们`HomePage`组件的初始状态。
- en: We will be able to see a list of users only after React hydration occurs. We
    will need to wait for the component to mount on the client side and the HTTP request
    to be spawned using the browser's `fetch` API.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在React hydration完成后，我们才能看到用户列表。我们需要等待组件在客户端挂载，并使用浏览器的`fetch` API发起HTTP请求。
- en: 'Now we need to implement the single user page as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要按照以下方式实现单用户页面：
- en: 'Let''s create a new file, `pages/users/[username].js`, and start writing the
    `getServerSideProps` function, where we fetch the `[username]` variable from the
    route and the authorization token from the `.env` file:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的文件，`pages/users/[username].js`，并开始编写`getServerSideProps`函数，其中我们从路由中获取`[username]`变量，并从`.env`文件中获取授权令牌：
- en: '[PRE21]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, inside the same file, let''s create the `UserPage` component, where we''ll
    execute the client-side data fetching function:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在同一个文件中，让我们创建`UserPage`组件，我们将在这里执行客户端数据获取函数：
- en: '[PRE22]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you may have noticed, once we set the data using the `setData` hook function,
    we render a `<UserData />` component.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，一旦我们使用`setData`钩子函数设置数据，我们就渲染一个`<UserData />`组件。
- en: 'Create that last component, always inside the same `pages/users/[username].js`
    component:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建该组件，始终在同一个`pages/users/[username].js`组件内部：
- en: '[PRE23]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we're using the same approach as we did for the home page, making
    an HTTP request as soon as the component mounts on the client side. We're also
    passing the `API_TOKEN` from the server to the client using `getServerSideProps`
    so that we can use it for making an authorized request. However, if you try to
    run the preceding code, you will see at least two problems.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用与主页相同的方法，即组件在客户端挂载后立即发起HTTP请求。我们还通过`getServerSideProps`将服务器的`API_TOKEN`传递到客户端，以便我们可以用它来发起授权请求。然而，如果您尝试运行前面的代码，您将至少看到两个问题。
- en: The first one is related to **CORS**.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个问题与**CORS**有关。
- en: '`HomePage` component, we''ve been able to call the `https://api.rwnjs.com/04/users`
    API from a different domain (localhost, a replit.co domain, CodeSandbox domain,
    and so on) as the server allowed any domain to access its resources for that specific
    route.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HomePage`组件中，我们已经能够从不同域名（localhost、replit.co域名、CodeSandbox域名等）调用`https://api.rwnjs.com/04/users`
    API，因为服务器允许任何域名访问该特定路由的资源。
- en: 'In that case, however, the browser makes some restrictions on the `https://api.rwnjs.com/04/users/[username]`
    endpoint, and we''re not able to call this API directly from the client as we
    get blocked by CORS policy. CORS can be tricky sometimes, and I encourage you
    to read more about it on the Mozilla Developer Network page dedicated to this
    security policy: [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，浏览器对`https://api.rwnjs.com/04/users/[username]`端点有一些限制，我们无法直接从客户端调用此API，因为我们被CORS策略阻止。CORS有时可能很棘手，我鼓励你阅读Mozilla开发者网络页面上的更多关于此安全策略的信息：[https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)。
- en: 'The second problem relates to exposing the authorization token to the client.
    In fact, if we open the Google Chrome developer tools and go to **Network**, we
    can select the HTTP request for the endpoint and see the authorization token in
    plain text in the **Request Headers** section:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题与向客户端暴露授权令牌有关。实际上，如果我们打开谷歌Chrome开发者工具并转到**网络**，我们可以选择端点的HTTP请求，并在**请求头**部分看到授权令牌的纯文本：
- en: '![Figure 4.3 – The HTTP Request Headers'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 – HTTP请求头](Figure 4.3 – The HTTP Request Headers)'
- en: '](img/Figure_4_03_B16985.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 – HTTP请求头](img/Figure_4_03_B16985.jpg)'
- en: Figure 4.3 – The HTTP Request Headers
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – HTTP请求头
- en: So, what's wrong with that?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这有什么问题吗？
- en: Imagine that you're paying for a service exposing live weather updates via an
    API and pretend that it costs $1 for every 100 requests.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在为通过API公开实时天气更新的服务付费，并且假设每100次请求的费用为1美元。
- en: A malicious user who wants to use that same service without paying could easily
    find your private authorization token in the request header and use it to power
    their weather web app. That way, if the malicious user makes 1,000 requests, you'll
    be paying $10 without actually using their services.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个想要免费使用相同服务的恶意用户可以轻易地在请求头中找到您的私有授权令牌，并使用它来为他们的天气网络应用供电。这样，如果恶意用户发起1,000次请求，您将支付10美元，而实际上并没有使用他们的服务。
- en: We can quickly solve both problems thanks to the Next.js API pages, which allows
    us to quickly create a REST API, making the HTTP request for use on the server
    side and returning the result to the client.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速解决这两个问题，多亏了Next.js API页面，它允许我们快速创建REST API，在服务器端使用HTTP请求，并将结果返回给客户端。
- en: 'Let''s create a new folder inside `pages/` called `api/` and a new file, `pages/api/singleUser.js`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`pages/`内部创建一个名为`api/`的新文件夹和一个新文件，`pages/api/singleUser.js`：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see, in this case, we''re exposing a simple function taking two
    arguments:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这种情况下，我们暴露了一个接受两个参数的简单函数：
- en: '`req`: An instance of Node.js'' `http.IncomingMessage` ([https://nodejs.org/api/http.html#http_class_http_incomingmessage](https://nodejs.org/api/http.html#http_class_http_incomingmessage))
    merged with some pre-built middlewares such as `req.cookies`, `req.query`, and
    `req.body`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`req`：Node.js的`http.IncomingMessage`实例([https://nodejs.org/api/http.html#http_class_http_incomingmessage](https://nodejs.org/api/http.html#http_class_http_incomingmessage))，与一些预构建的中间件合并，例如`req.cookies`、`req.query`和`req.body`。'
- en: '`res`: An instance of Node.js'' `http.serverResponse` ([https://nodejs.org/api/http.html#http_class_http_serverresponse](https://nodejs.org/api/http.html#http_class_http_serverresponse)),
    merged with some pre-built middleware such as `res.status(code)` for setting the
    HTTP status code, `res.json(json)` for returning a valid JSON, `res.send(body)`
    for sending an HTTP response containing a `string`, an `object`, or a `Buffer`,
    and `res.redirect([status,] path)` for redirecting to a specific page with a given
    (and optional) status code.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res`：Node.js的`http.serverResponse`实例([https://nodejs.org/api/http.html#http_class_http_serverresponse](https://nodejs.org/api/http.html#http_class_http_serverresponse))，与一些预构建的中间件合并，例如`res.status(code)`用于设置HTTP状态码，`res.json(json)`用于返回有效的JSON，`res.send(body)`用于发送包含`string`、`object`或`Buffer`的HTTP响应，以及`res.redirect([status,]
    path)`用于重定向到具有给定（可选）状态码的特定页面。'
- en: Every file inside the `pages/api/` directory will be considered by Next.js as
    an API route.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`pages/api/`目录中的每个文件都将被Next.js视为一个API路由。'
- en: 'Now we can refactor our `UserPage` component by changing the API endpoint to
    the newly created one:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过将API端点更改为新创建的一个来重构我们的`UserPage`组件：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we now try to run our website, we will see that both our problems are solved!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试运行我们的网站，我们将看到我们的两个问题都得到了解决！
- en: But there's still something we need to pay attention to. We've hidden the API
    token by writing a kind of *proxy* for the single user API, but a malicious user
    would still be able to use the `/api/singleUser` route to access private data
    with ease.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们仍然需要注意一些事情。我们通过编写一种为单个用户 API 的 *代理* 来隐藏了 API 令牌，但恶意用户仍然能够轻松地使用 `/api/singleUser`
    路由来访问私有数据。
- en: 'To solve that specific problem, we can act in a variety of different ways:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决那个特定的问题，我们可以采取各种不同的方式：
- en: 'Render the component list exclusively on the server, just like in the previous
    section: That way, a malicious user won''t call a private API or steal a secret
    API token. However, there are cases where you cannot run those kinds of API calls
    on the server only; if you need to make a REST request after the user clicks on
    a button, you''re forced to make it on the client side.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在服务器上渲染组件列表，就像在上一节中那样：这样，恶意用户就不会调用私有 API 或窃取秘密的 API 令牌。然而，在某些情况下，你只能在服务器上运行这些类型的
    API 调用；如果你需要在用户点击按钮后进行 REST 请求，你被迫在客户端进行。
- en: Use an authentication method to let authenticated users only access a specific
    API (JWT, API key, and so on).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一种身份验证方法，让经过身份验证的用户只能访问特定的 API（JWT、API 密钥等）。
- en: 'Use a backend framework such as **Ruby on Rails**, **Spring,** **Laravel**,
    **Nest.js**, and **Strapi**: They all provide different ways of securing your
    API calls from the client, making it way more comfortable for us to create secure
    Next.js applications.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用如 **Ruby on Rails**、**Spring**、**Laravel**、**Nest.js** 和 **Strapi** 这样的后端框架：它们都提供了不同的方法来保护你的
    API 调用免受客户端的攻击，这使得我们创建安全的 Next.js 应用程序变得更加容易。
- en: In [*Chapter 13*](B16985_13_Final_SB_epub.xhtml#_idTextAnchor131), *Building
    an E-commerce Website with Next.js and GraphCMS*, we will see how to use Next.js
    as a frontend for different CMSes and e-commerce platforms, and we'll also cover
    user authentication and secure API calls. For now, in this chapter, we will only
    focus on how to make HTTP requests from both the server and client.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 13 章*](B16985_13_Final_SB_epub.xhtml#_idTextAnchor131) *使用 Next.js 和 GraphCMS
    构建电子商务网站* 中，我们将看到如何将 Next.js 作为不同 CMS 和电子商务平台的前端使用，我们还将涵盖用户身份验证和安全的 API 调用。现在，在本章中，我们只关注如何从服务器和客户端进行
    HTTP 请求。
- en: In the next section, we will see how to adopt GraphQL as a REST alternative
    for fetching data in Next.js.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何将 GraphQL 作为 REST 的替代方案用于 Next.js 中的数据获取。
- en: Consuming GraphQL APIs
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费 GraphQL API
- en: GraphQL has been a game-changer in the API world, and it is increasing its popularity
    thanks to its ease of use, modularity, and flexibility.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 已经在 API 世界中掀起了一场革命，并且由于其易用性、模块化和灵活性，它的受欢迎程度正在不断增加。
- en: For those who are not very familiar with GraphQL, it is basically a query language
    for APIs first invented by *Facebook* back in 2012\. It improves many key aspects
    of data fetching and manipulation compared to other web service architectures
    such as REST or SOAP. In fact, it allows you to avoid data over-fetching (you
    can simply query the data fields you need), get multiple resources within a single
    request, obtain a strongly and statically typed interface for your data, avoid
    API versioning, and so on.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不太熟悉 GraphQL 的人来说，它基本上是一种查询语言，由 *Facebook* 在 2012 年首次发明。与 REST 或 SOAP 等其他网络服务架构相比，它在数据获取和处理的关键方面进行了许多改进。实际上，它允许你避免数据过度获取（你可以简单地查询你需要的字段），在单个请求中获取多个资源，为你的数据提供一个强类型和静态类型的接口，避免
    API 版本化，等等。
- en: In this section, we will be using Apollo Client ([https://www.apollographql.com/docs/react](https://www.apollographql.com/docs/react)),
    a very popular GraphQL client with built-in support for both React and Next.js
    for building a very simple online signbook.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Apollo Client ([https://www.apollographql.com/docs/react](https://www.apollographql.com/docs/react))，这是一个非常流行的
    GraphQL 客户端，内置了对 React 和 Next.js 的支持，用于构建一个非常简单的在线签名簿。
- en: 'Let''s start by creating a new project:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个新的项目：
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s add a couple of dependencies:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一些依赖项：
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will need now to create an Apollo client for our Next.js application. We
    will do that by creating a new file inside `lib/apollo/index.js` and then writing
    the following function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要为我们的 Next.js 应用程序创建一个 Apollo 客户端。我们将通过在 `lib/apollo/index.js` 内部创建一个新文件，然后编写以下函数来完成：
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can assume, by setting `ssrMode: typeof window === "undefined"`, we
    will use the same Apollo instance for both client and server. Also, `ApolloClient`
    uses the browser `fetch` API to make HTTP requests, so we''ll need to import a
    polyfill to make it work on the server side; in that case, we''ll be using `isomorphic-unfetch`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所假设，通过设置`ssrMode: typeof window === "undefined"`，我们将使用相同的Apollo实例来处理客户端和服务器。此外，`ApolloClient`使用浏览器的`fetch`
    API来发送HTTP请求，因此我们需要导入一个polyfill来使其在服务器端也能工作；在这种情况下，我们将使用`isomorphic-unfetch`。'
- en: If you try to run [https://api.realworldnextjs.com/04/signbook/graphql](https://api.realworldnextjs.com/04/signbook/graphql)
    on a browser, it will redirect you to a public *GraphCMS* GraphQL editor. In fact,
    we will be using that headless CMS as the data source for the application we're
    currently writing.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在浏览器上运行[https://api.realworldnextjs.com/04/signbook/graphql](https://api.realworldnextjs.com/04/signbook/graphql)，它将重定向您到一个公共的*GraphCMS*
    GraphQL编辑器。实际上，我们将使用那个无头CMS作为我们目前正在编写的应用程序的数据源。
- en: 'Inside the same `lib/apollo/index.js` file, let''s add a new function to initialize
    the Apollo client:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个`lib/apollo/index.js`文件中，让我们添加一个新的函数来初始化Apollo客户端：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function will allow us to avoid recreating a new Apollo client for each
    page. In fact, we will store a client instance on the server (inside the previously
    written `apolloClient` variable), where we can pass an initial state as an argument.
    If we pass that parameter to the `initApollo` function, it will be merged with
    the local cache to restore a full representation of the state once we move to
    another page.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将允许我们避免为每个页面重新创建一个新的Apollo客户端。实际上，我们将在服务器上（在之前编写的`apolloClient`变量中）存储一个客户端实例，我们可以将初始状态作为参数传递。如果我们将此参数传递给`initApollo`函数，它将与本地缓存合并，以便在移动到另一个页面时恢复状态的完整表示。
- en: 'To achieve that, we will first need to add another `import` statement to the
    `lib/apollo/index.js` file. Given that re-initializing the Apollo client with
    a complex initial state can be an expensive task in terms of performance, we will
    use the React `useMemo` hook to speed up the process:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们首先需要在`lib/apollo/index.js`文件中添加另一个`import`语句。鉴于使用复杂的初始状态重新初始化Apollo客户端在性能上可能是一个昂贵的任务，我们将使用React的`useMemo`钩子来加速这个过程：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And then, we will `export` one last function:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将导出最后一个函数：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Moving to our `pages/` directory, we can now create a new `_app.js` file, as
    seen in *Chapter 3*, *Next.js Basics and Built-In Components*. Here, we will wrap
    the whole app using the official Apollo context provider:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 转到我们的`pages/`目录，我们现在可以创建一个新的`_app.js`文件，正如在*第3章*，*Next.js基础和内置组件*中看到的。在这里，我们将使用官方的Apollo上下文提供者包裹整个应用：
- en: '[PRE32]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can finally start to write our queries!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始编写我们的查询了！
- en: We will organize our queries inside a new folder called `lib/apollo/queries/`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的查询组织在一个名为`lib/apollo/queries/`的新文件夹中。
- en: 'Let''s start by creating a new file, `lib/apollo/queries/getLatestSigns.js`,
    exposing the following GraphQL query:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的文件`lib/apollo/queries/getLatestSigns.js`开始，公开以下GraphQL查询：
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now `import` this query inside our `pages/index.js` file and try to
    make our first GraphQL request using Apollo and Next.js:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`pages/index.js`文件中导入这个查询，并尝试使用Apollo和Next.js进行我们的第一个GraphQL请求：
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, the Apollo client is incredibly easy to use. Thanks to the
    `useQuery` hook, we will have access to three different states:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Apollo客户端的使用非常简单。多亏了`useQuery`钩子，我们将能够访问三个不同的状态：
- en: '`loading`: As the name suggests, it only returns `true` or `false` when a request
    is fulfilled or is still pending.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loading`：正如其名所示，它仅在请求完成或仍在挂起时返回`true`或`false`。'
- en: '`error`: If the request fails for any reason, we will be able to catch the
    error and send a nice message to the user.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`：如果请求因任何原因失败，我们将能够捕获错误并向用户发送一条友好的消息。'
- en: '`data`: Contains the data we asked for with our query.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：包含我们通过查询请求的数据。'
- en: Now, let's move back to our home page page for a moment. For simplicity, we
    will just add a remote *TailwindCSS* dependency for styling our demo app. In [*Chapter
    6*](B16985_06_Final_SB_epub.xhtml#_idTextAnchor075), *CSS and Built-In Styling
    Methods*, and [*Chapter 7*](B16985_07_Final_SB_epub.xhtml#_idTextAnchor081), *Using
    UI Frameworks*, we will see how to optimize and integrate UI frameworks, but for
    now, we will keep things simple as we want to focus just on the data-fetching
    part of our application.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们暂时回到主页。为了简单起见，我们将只添加一个远程的*TailwindCSS*依赖项来为我们的演示应用进行样式设计。在[*第6章*](B16985_06_Final_SB_epub.xhtml#_idTextAnchor075)
    *CSS和内置样式方法*和[*第7章*](B16985_07_Final_SB_epub.xhtml#_idTextAnchor081) *使用UI框架*中，我们将看到如何优化和集成UI框架，但现在，我们将保持简单，因为我们只想关注应用的数据获取部分。
- en: 'Open the `pages/index.js` file and edit it as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`pages/index.js`文件并按照以下方式编辑它：
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we can create a new file, `components/Loading.js`. We will render it while
    we''re fetching the signs from `GraphCMS`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个新的文件，`components/Loading.js`。在我们从`GraphCMS`获取标志时，我们将渲染它：
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once we have successfully fetched the desired data, we need to display it on
    the home page. To do that, we will create a new component inside the `components/Sign.js`
    file with the following content:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们成功获取了所需的数据，我们需要在主页上显示它。为此，我们将在`components/Sign.js`文件内创建一个新的组件，内容如下：
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s integrate those two new components inside our home page:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这两个新组件集成到我们的主页中：
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If we now try to browse the home page, we will see a list of signs!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试浏览主页，我们将看到一个标志列表！
- en: 'We could also create a simple route for adding a new sign by creating a new
    page under `pages/new-sign.js`. Let''s start by adding the required `imports`
    for that page:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '我们也可以通过在`pages/new-sign.js`下创建一个新的页面来创建一个添加新标志的简单路由。让我们先为该页面添加所需的`imports`： '
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, we're importing a bunch of functions from different libraries.
    We will use the `useState` React hook to keep track of the changes in our form
    for submitting the sign, Next.js' `useRouter` hook for redirecting the user to
    the home page once they have created a new sign, and Apollo's `useMutation` hook
    for creating a new sign on GraphCMS. We also `import` a new GraphQL mutation called
    `ADD_SIGN`, and we will see this in detail after we have created this page.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在从不同的库中导入大量函数。我们将使用`useState`React钩子来跟踪我们的表单变化以便提交标志，Next.js的`useRouter`钩子用于在用户创建了一个新标志后将用户重定向到主页，以及Apollo的`useMutation`钩子用于在GraphCMS上创建一个新的标志。我们还`import`了一个名为`ADD_SIGN`的新GraphQL变异，我们将在创建此页面后详细了解它。
- en: 'Moving on, we create the page structure:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建页面结构：
- en: '[PRE40]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Reading from top to bottom, we can see that we're using Apollo's `useMutation`
    hook to create a new sign. Once the sign has been created correctly, it will run
    the `onCompleted` callback, where we will redirect the user to the home page.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 从上到下阅读，我们可以看到我们正在使用Apollo的`useMutation`钩子创建一个新的标志。一旦标志被正确创建，它将运行`onCompleted`回调，我们将在此回调中将用户重定向到主页。
- en: Moving to the next function declared inside the component body, we can clearly
    see that we'll use the `handleInput` function to dynamically set the form state
    using the React `useState` hook as soon as the user types something in any form
    input.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看组件体内声明的下一个函数，我们可以清楚地看到我们将使用`handleInput`函数，通过React的`useState`钩子动态设置表单状态，一旦用户在表单输入中输入任何内容。
- en: 'We now need to render the actual HTML containing a form with just three inputs:
    the user''s `nickname`, a message to be written in the `signbook`, and (optionally)
    the `country` where the user is writing from:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要渲染包含三个输入的实际HTML表单：用户的`nickname`，要在`signbook`中写入的消息，以及（可选的）用户写作的`country`：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s take a closer look at how we create a mutation by clicking the submit
    button:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看我们是如何通过点击提交按钮创建一个变异的：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As you can see, we''re taking the entire state stored inside the `formState`
    variable coming from the `useState` hook and passing it as a value for the `variables`
    property used by the `addSign` function:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在将来自`useState`钩子的`formState`变量中存储的整个状态传递给`addSign`函数使用的`variables`属性：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `addSign` function represents the mutation that will add a new sign to
    GraphCMS, and we can add dynamic data by passing an object matching the mutation
    variables written inside the `lib/apollo/queries/addSign.js` file:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`addSign`函数代表将新标志添加到GraphCMS的变异，我们可以通过传递一个与`lib/apollo/queries/addSign.js`文件中编写的变异变量匹配的对象来添加动态数据：'
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `ADD_SIGN` mutation, in fact, takes three argument variables: `$nickname`,
    `$content`, and `$country`. Using form field names that reflect the naming of
    the mutation variables, we can simply pass the whole form state as a value to
    our mutation.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`ADD_SIGN` 变异操作需要三个参数变量：`$nickname`、`$content` 和 `$country`。使用反映变异变量命名的表单字段名，我们可以简单地将整个表单状态作为值传递给我们的变异操作。
- en: You can now try to create a new sign. After submitting the form, you will be
    automatically redirected to the home page and you will see your sign at the top
    of the page.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以尝试创建一个新的签名。提交表单后，你将被自动重定向到主页，你将在页面顶部看到你的签名。
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we''ve taken a look at two crucial topics when talking about
    Next.js: the project structure organization and the different ways of fetching
    data. Even if these two topics seem unrelated, being able to logically separate
    components and utilities, and fetching data in different ways, are essential skills
    that will allow you to better understand the next chapter, [*Chapter 5*](B16985_05_Final_SB_epub.xhtml#_idTextAnchor068)*,*
    *Managing Local and Global States in Next.js*. As we''ve seen in this chapter,
    the complexity of any application can only grow over time as we add more features,
    bug fixes, and suchlike. Having a well-organized folder structure and a clear
    data flow can help us keep track of our application''s state.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在谈论 Next.js 时的两个关键主题：项目结构组织和获取数据的不同方式。即使这两个主题看似无关，能够逻辑上分离组件和工具，以及以不同的方式获取数据，都是让你更好地理解下一章，[*第
    5 章*](B16985_05_Final_SB_epub.xhtml#_idTextAnchor068)*，* *在 Next.js 中管理本地和全局状态*
    的基本技能。正如我们在本章中所看到的，任何应用程序的复杂性都只能随着时间的推移而增长，因为我们添加了更多功能、错误修复等等。拥有一个良好的文件夹结构和清晰的数据流可以帮助我们跟踪应用程序的状态。
- en: We've also taken a look at how to fetch data using GraphQL. This is an exciting
    topic as, in the next chapter, we will see how to use Apollo Client as a state
    manager other than a GraphQL client.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何使用 GraphQL 获取数据。这是一个令人兴奋的话题，因为在下一章中，我们将看到如何将 Apollo Client 作为除 GraphQL
    客户端之外的状态管理器来使用。
