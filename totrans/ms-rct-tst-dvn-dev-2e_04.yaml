- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test-Driving Data Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ll explore React forms and controlled components.
  prefs: []
  type: TYPE_NORMAL
- en: Forms are an essential part of building web applications, being the primary
    way that users enter data. If we want to ensure our application works, then invariably,
    that’ll mean we need to write automated tests for our forms. What’s more, there’s
    a lot of plumbing required to get forms working in React, making it even more
    important that they’re well-tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Automated tests for forms are all about the user’s behavior: entering text,
    clicking buttons, and submitting the form when complete.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build out a new component, `CustomerForm`, which we will use when adding
    or modifying customers. It will have three text fields: first name, last name,
    and phone number.'
  prefs: []
  type: TYPE_NORMAL
- en: In the process of building this form, you’ll dig deeper into testing complex
    DOM element trees. You’ll learn how to use parameterized tests to repeat a group
    of tests without duplicating code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a form element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accepting text input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting a form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicating tests for multiple form fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have a decent understanding of test-driving
    HTML forms with React.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a form element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An HTML form is a bunch of fields wrapped in a `form` element. Even though we’re
    mostly interested in the fields, we need to start with the `form` element itself.
    That’s what we’ll build in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create our first form by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `test/CustomerForm.test.js` and add the following
    scaffold. It contains all the usual imports and component test initialization
    that you’ve seen in the previous chapters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you’re ready to create your first test. Add the following test to the `describe`
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have a complete test, so let’s run it and see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The failure tells us that it can’t find the module. That’s because we haven’t
    created it yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, create a blank file named `src/CustomerForm.js`. Running your test again
    should give you the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Stack traces from test helper code
  prefs: []
  type: TYPE_NORMAL
- en: Jest’s stack trace points to a failure within our extensions code, not the test
    itself. If our code was in an npm module, Jest would have skipped those test lines
    from its output. Thankfully, the error message is helpful enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this issue, we need to add an export that matches the import we wrote
    at the top of our test file. Add the following line to `src/CustomerForm.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running some tests gives the actual expectation failure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This can be fixed by making the component return something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Before moving on, let’s pull out a helper for finding the `form` element. As
    in the previous chapter, this is arguably premature as we have only one test using
    this code right now. However, we’ll appreciate having the helper when we come
    to write our form submission tests later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `test/reactTestExtensions.js` and add the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your test file by adding the following `import`. You can leave the `element`
    import in place because we’ll use it later in the next section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, update your test to use the helper, as shown here. After this, your
    test should still be passing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That’s all there is to creating the basic `form` element. With that wrapper
    in place, we’re now ready to add our first field element: a text box.'
  prefs: []
  type: TYPE_NORMAL
- en: Accepting text input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll add a text box to allow the customer’s first name to
    be added or edited.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a text field is more complicated than adding the `form` element. First,
    there’s the element itself, which has a `type` attribute that needs to be tested.
    Then, we need to prime the element with the initial value. Finally, we’ll need
    to add a label so that it’s obvious what the field represents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by rendering an HTML text input field onto the page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test to `test/CustomerForm.test.js`. It contains three expectations
    (there’s an exercise at the end of this chapter that you can follow to pull these
    out as a single matcher):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Relying on the DOM’s Form API
  prefs: []
  type: TYPE_NORMAL
- en: 'This test makes use of the Form API: any form element allows you to access
    all of its input elements using the `elements` indexer. You give it the element’s
    `name` attribute (in this case, `firstName`) and that element is returned.'
  prefs: []
  type: TYPE_NORMAL
- en: This means we must check the returned element’s tag. We want to make sure it
    is an `<input>` element. If we hadn’t used the Form API, one alternative would
    have been to use `elements("input")[0]`, which returns the first input element
    on the page. This would make the expectation on the element’s `tagName` property
    unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move a bit faster. We’ll make all the expectations pass at once. Update
    `CustomerForm` so that it includes a single input field, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since this form will be used when modifying existing customers as well as adding
    new ones, we need to design a way to get the existing customer data into the component.
    We’ll do that by setting an `original` prop that contains the form data. Add the
    following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this test pass, change the component definition to the following. We
    will use a prop to pass in the previous `firstName` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Upon running the tests again, you’ll see that although this test now passes,
    the first two tests fail because they don’t specify the `original` prop. What’s
    more, we have a warning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To fix the initial tests, create a new constant, `blankCustomer`, that will
    act as our “base” customer. It’ll do just fine for tests that don’t care about
    specific field values, such as our first two tests. Add this definition just above
    the `beforeEach` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What about specifying an empty object for the original prop?
  prefs: []
  type: TYPE_NORMAL
- en: In this object definition, we set the `firstName` value to an empty string.
    You may think that either `undefined` or `null` would be good candidates for the
    value. That way, we could sidestep having to define an object like this and just
    pass an empty object, `{}`. Unfortunately, React will warn you when you attempt
    to set a controlled component’s initial value to `undefined`, which we want to
    avoid. It’s no big deal, and besides that, an empty string is a more realistic
    default for a text box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the first two tests so that they render with the `original` prop set,
    as shown here. With this change in place, you should have three passing tests,
    but the warning remains:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get rid of the warning, add the word `readOnly` to the input tag. You might
    be thinking: surely, we don’t want a read-only field? You’re right, but we need
    a further test, for modifying the input value, before we can avoid using the `readOnly`
    keyword. We’ll add that test a little further on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Always consider React warnings to be a test failure. Don’t proceed without first
    fixing any warnings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two tests include the following line, which reaches inside the form
    to pull out the `firstName` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s promote this to be a function in `test/reactTestExtensions.js`. Open
    that file and add the following definition after the definition for `form`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, import it into `test/CustomerForm.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the last test you wrote so that it uses the new helper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the first test in the same way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next up, we’ll add a label to the field. Add the following test, which uses
    the `element` helper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make this pass by inserting the new element into your JSX for `CustomerForm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The htmlFor attribute
  prefs: []
  type: TYPE_NORMAL
- en: The JSX `htmlFor` attribute sets the HTML `for` attribute. `for` couldn’t be
    used in JSX because it is a reserved JavaScript keyword. The attribute is used
    to signify that the label matches a form element with the given ID – in this case,
    `firstName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add some text content to that label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `label` element to make the test pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to ensure that our input has an ID that matches it with the
    label’s `htmlFor` value so that they match up. Add the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Making that pass is as simple as adding the new attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ve now created *almost* everything we need for this field: the input field
    itself, its initial value, and its label. But we don’t have any behavior for handling
    changes to the value – that’s why we have the `readOnly` flag.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change behavior only makes sense in the context of submitting the form with
    updated data: if you can’t submit the form, there’s no point in changing the field
    value. That’s what we’ll cover in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Submitting a form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we will define “submit the form” to mean “call the `onSubmit`
    callback function with the current `customer` object.” The `onSubmit` callback
    function is a prop we’ll be passing.
  prefs: []
  type: TYPE_NORMAL
- en: This section will introduce one way of testing form submission. In [*Chapter
    6*](B18423_06.xhtml#_idTextAnchor099), *Exploring Test Doubles*, we will update
    this to a call to `global.fetch` that sends our customer data to our application’s
    backend API.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll need a few different tests to specify this behavior, each test building
    up the functionality we need in a step-by-step fashion. First, we’ll have a test
    that ensures the form has a submit button. Then, we’ll write a test that clicks
    that button without making any changes to the form. We’ll need another test to
    check that submitting the form does not cause page navigation to occur. Finally,
    we’ll end with a test submission after the value of the text box has been updated.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting without any changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating a button in the form. Clicking it will cause the form
    to submit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a test to check whether a submit button exists on the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, add the following single line at the bottom of the form’s
    JSX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following test introduces a new concept, so we’ll break it down into its
    component parts. To start, create a new test, `starting`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `hasAssertions` expectation tells Jest that it should expect at least one
    assertion to occur. It tells Jest that at least one assertion must run within
    the scope of the test; otherwise, the test has failed. You’ll see why this is
    important in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following part of the test into the outline, below the `hasAssertions`
    call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function call is a mix of the`render` call itself, and the`onSubmit` handler.
    This is the handler that we want React to call on form submission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finish off the test by adding the following line just below the call to `render`.
    This is the **Act** phase of our test, which in this test is the last phase of
    the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using hasAssertions to avoid false positives
  prefs: []
  type: TYPE_NORMAL
- en: You can now see why we need `hasAssertions`. The test is written out of order,
    with the assertions defined within the `onSubmit` handler. If we did not use `hasAssertions`,
    this test would pass right now because we never call `onSubmit`.
  prefs: []
  type: TYPE_NORMAL
- en: I don’t recommend writing tests like this. In [*Chapter 6*](B18423_06.xhtml#_idTextAnchor099),
    *Exploring Test Doubles*, we’ll discover `hasAssertions`. The method we’re using
    here is a perfectly valid TDD practice; it’s just a little messy, so you will
    want to refactor it eventually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you need to import `click`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Making this test pass is straightforward, despite the complicated test setup.
    Change the component definition so that it reads as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the test with `npm test`. You’ll discover that the test passed but
    we have a new warning, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Something is not quite right. This warning is highlighting something very important
    that we need to take care of. Let’s stop here and look at it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing the default submit action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This `Not implemented` console error is coming from the JSDOM package. HTML
    forms have a default action when submitted: they navigate to another page, which
    is specified by the `form` element’s `action` attribute. JSDOM does not implement
    page navigation, which is why we get a `Not implemented` error.'
  prefs: []
  type: TYPE_NORMAL
- en: In a typical React application like the one we’re building, we don’t want the
    browser to navigate. We want to stay on the same page and allow React to update
    the page with the result of the submit operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to do that is to grab the `event` argument from the `onSubmit` prop
    and call `preventDefault` on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Since that’s production code, we need a test that verifies this behavior. We
    can do this by checking the event’s `defaultPrevented` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: So, now the question becomes, how do we get access to this `Event` in our tests?
  prefs: []
  type: TYPE_NORMAL
- en: We need to create the `event` object ourselves and dispatch it directly using
    the `dispatchEvent` DOM function on the form element. This event needs to be marked
    as `cancelable`, which will allow us to call `preventDefault` on it.
  prefs: []
  type: TYPE_NORMAL
- en: Why clicking the submit button won’t work
  prefs: []
  type: TYPE_NORMAL
- en: In the last couple of tests, we purposely built a submit button that we could
    click to submit the form. While that will work for all our other tests, for this
    specific test, it does *not* work. That’s because JSDOM will take a `click` event
    and internally convert it into a `submit` event. There is no way we can get access
    to that `submit` event object if JSDOM creates it. Therefore, we need to directly
    fire the `submit` event.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t a problem. Remember that, in our test suite, we strive to act as
    a real browser would – by clicking a submit button to submit the form – but having
    one test work differently isn’t the end of the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s put all of this together and fix the warning:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `test/reactTestExtensions.js` and add the following, just below the `click`
    definition. We’ll use this in the next test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why do we need the bubbles property?
  prefs: []
  type: TYPE_NORMAL
- en: If all of this wasn’t complicated enough, we also need to make sure the event
    *bubbles*; otherwise, it won’t make it to our event handler.
  prefs: []
  type: TYPE_NORMAL
- en: When JSDOM (or the browser) dispatches an event, it traverses the element hierarchy
    looking for an event handler to handle the event, starting from the element the
    event was dispatched on, working upwards via parent links to the root node. This
    is known as bubbling.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need to ensure this event bubbles? Because React has its *own* event
    handling system that is triggered by events reaching the React root element. The
    `submit` event must bubble up to our `container` element before React will process
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the new helper into `test/CustomerForm.test.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following test to the bottom of the `CustomerForm` test suite. It specifies
    that `preventDefault` should be called when the form is submitted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, first, update `CustomerForm` so that it has an explicit
    return:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just above the return, add a new function, `handleSubmit`, and update the form
    so that it calls that instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run your tests and ensure they are all passing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Submitting changed values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s finally the time to introduce some state into our component. We will specify
    what should happen when the text field is used to update the customer’s first
    name.
  prefs: []
  type: TYPE_NORMAL
- en: The most complicated part of what we’re about to do is dispatching the DOM `change`
    event. In the browser, this event is dispatched after every keystroke, notifying
    the JavaScript application that the text field value content has changed. An event
    handler receiving this event can query the `target` element’s `value` property
    to find out what the current value is.
  prefs: []
  type: TYPE_NORMAL
- en: Crucially, we’re responsible for setting the `value` property before we dispatch
    the `change` event. We do that by calling the `value` property setter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Somewhat unfortunately for us testers, React has change tracking behavior that
    is designed for the browser environment, not the Node test environment. In our
    tests, this change tracking logic suppresses change events like the ones our tests
    will dispatch. We need to circumvent this logic, which we can do with a helper
    function called `originalValueProperty`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you’ll see in the next section, we’ll use this function to bypass React’s
    change tracking and trick it into processing our event, just like a browser would.
  prefs: []
  type: TYPE_NORMAL
- en: Only simulating the final change
  prefs: []
  type: TYPE_NORMAL
- en: Rather than creating a `change` event for each keystroke, we’ll manufacture
    just the final instance. Since the event handler always has access to the full
    value of the element, it can ignore all intermediate events and process just the
    last one that is received.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with a little bit of refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to use the submit button to submit the form. We figured out how
    to access that button in a previous test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s move this definition into `test/reactTestExtensions.js` so that we can
    use it on our future tests. Open that file now and add this definition to the
    bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Move back to `test/CustomerForm.test.js` and add the new helper to the imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `renders a submit button` test so that it uses that new helper,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The helper extraction dance
  prefs: []
  type: TYPE_NORMAL
- en: Why are we doing this dance of writing a variable in a test (such as `const
    button = ...`) only to then extract it as a function moments later, as we just
    did with `submitButton`?
  prefs: []
  type: TYPE_NORMAL
- en: Following this approach is a systematic way of building a library of helper
    functions, meaning you don’t have to think too heavily about the “right” design.
    First, start with a variable. If it turns out that you’ll use that variable a
    second or third time, then extract it into a function. No big deal.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s time to write the next test. This is very similar to the last test, except
    now, we need to make use of a new `change` helper function. We’ll define this
    in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This function uses the new `change` helper that was discussed at the beginning
    of this section. Add the following definitions to `test/reactTestExtensions.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Figuring out interactions between React and JSDOM
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the `change` function shown here is not obvious. As we
    saw earlier with the `bubbles` property, React does some pretty clever stuff on
    top of the DOM’s usual event system.
  prefs: []
  type: TYPE_NORMAL
- en: It helps to have a high-level awareness of how React works. I also find it helpful
    to use the Node debugger to step through JSDOM and React source code to figure
    out where the flow is breaking.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this pass, move to `src/CustomerForm.js` and import `useState` into
    the module by modifying the existing React import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the customer constant definition to be assigned via a call to `useState`.
    The default state is the original value of `customer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new arrow function that will act as our event handler. You can put
    this just after the `useState` line that you added in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the returned JSX, modify the `input` element, as shown here. We are replacing
    the `readOnly` property with an `onChange` property and hooking it up to the handler
    we just created. Now, the `value` property also needs to be updated so that it
    can use React’s component state rather than the component prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go ahead and run the test; it should now be passing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, you’ve learned how to test-drive the `change` DOM event, and how
    to hook it up with React’s component state to save the user’s input. Next, it’s
    time to repeat the process for two more text boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicating tests for multiple form fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve written a set of tests that fully define the `firstName` text
    field. Now, we want to add two more fields, which are essentially the same as
    the `firstName` field but with different `id` values and labels.
  prefs: []
  type: TYPE_NORMAL
- en: Before you reach for copy and paste, stop and think about the duplication you
    could be about to add to both your tests and your production code. We have six
    tests that define the first name. This means we would end up with 18 tests to
    define three fields. That’s a lot of tests without any kind of grouping or abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s do both – that is, group our tests and abstract out a function that
    generates our tests for us.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting describe blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can nest `describe` blocks to break similar tests up into logical contexts.
    We can invent a convention for how to name these `describe` blocks. Whereas the
    top level is named after the form itself, the second-level `describe` blocks are
    named after the form fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we’d like them to end up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: With this structure in place, you can simplify the `it` descriptive text by
    removing the name of the field. For example, `"renders the first name field as
    a text box"` becomes `"renders as a text box"` because it has already been scoped
    by the `"first name field"` `describe` block. Because of the way Jest displays
    `describe` block names before test names in the test output, each of these still
    reads like a plain-English sentence, but without the verbiage. In the example
    just given, Jest will show us `CustomerForm first name field renders as a text
    box`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do that now for the first name field. Wrap the six existing tests in
    a `describe` block, and then rename the tests, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Be careful not to include the `preventsDefault` test out of this, as it’s not
    field-specific. You may need to adjust the positioning of your tests in your test
    file.
  prefs: []
  type: TYPE_NORMAL
- en: That covers grouping the tests. Now, let’s look at using test generator functions
    to remove repetition.
  prefs: []
  type: TYPE_NORMAL
- en: Generating parameterized tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some programming languages, such as Java and C#, require special framework support
    to build parameterized tests. But in JavaScript, we can very easily roll our own
    parameterization because our test definitions are just function calls. We can
    use this to our advantage by pulling out each of the existing six tests as functions
    that take parameter values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of change requires some diligent refactoring. We’ll do the first
    two tests together, and then you can either repeat these steps for the remaining
    five tests or jump ahead to the next tag in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with `renders as a text box`, wrap the entirety of the `it` call in
    an arrow function, and then call that function straight after, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Verify that all your tests are passing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Parameterize this function by promoting the `firstName` string to a function
    parameter. Then, you’ll need to pass in the `firstName` string into the function
    call itself, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, verify that your tests are passing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the `itRendersAsATextBox` function up one level, into the parent `describe`
    scope. That will allow you to use it in subsequent `describe` blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the same procedure for the next test, `includes the existing value`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Verify your tests are passing and then push `itIncludesTheExistingValue` up
    one level, into the parent `describe` scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat this process for the label tests, which can be included in one function.
    The second test can use a parameter within its test definition, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Repeat the same process for the three remaining tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Check the completed solution for the full listing. This can be found in the
    `Chapter04/Complete` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all that done, your `describe` block will succinctly describe what the
    first name field does:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Take a step back and look at the new form of the `describe` block. It is now
    very quick to understand the specification for how this field should work.
  prefs: []
  type: TYPE_NORMAL
- en: Solving a batch of tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we want to duplicate those six tests for the last name field. But how do
    we approach this? We do this test by test, just as we did with the first name
    field. However, this time, we should go much faster as our tests are one-liners,
    and the production code is a copy and paste job.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, the first test will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll need to update `blankCustomer` so that it includes the new field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'That test can be made to pass by adding the following line to our JSX, just
    below the `firstName` input field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This is just the start for the input field; you’ll need to complete it as you
    add the next few tests.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and add the remaining five tests, along with their implementation.
    Then, repeat this process for the phone number field. When adding the submit tests
    for the phone number, make sure that you provide a string value made up of numbers,
    such as `"012345"`. Later in this book, we’ll add validations to this field that
    will fail if you don’t use the right values now.
  prefs: []
  type: TYPE_NORMAL
- en: Jumping ahead
  prefs: []
  type: TYPE_NORMAL
- en: You might be tempted to try to solve all 12 new tests at once. If you’re feeling
    confident, go for it!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see a listing of all the tests in a file, you must invoke Jest
    with a single file. Run the `npm test test/CustomerForm.test.js` command to see
    what that looks like. Alternatively, you can run `npx jest --verbose` to run all
    the tests with full test listings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Modifying handleChange so that it works with multiple fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Time for a small refactor. After adding all three fields, you will have ended
    up with three very similar `onChange` event handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You can simplify these down into one function by making use of the `name` property
    on `target`, which matches the field ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Testing it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this stage, your the `AppointmentsDayView` instance is complete. Now is a
    good time to try it out for real.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your entry point in `src/index.js` so that it renders a new `CustomerForm`
    instance, rather than `AppointmentsDayView`. By doing so, you should be ready
    to manually test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The completed CustomerForm ](img/Figure_4.01_B18423.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The completed CustomerForm
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, you have learned one way to quickly duplicate specifications across
    multiple form fields: since `describe` and `it` are plain old functions, you can
    treat them just like you would with any other function and build your own structure
    around them.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create an HTML form with text boxes. You
    wrote tests for the `form` element, and for `input` elements of types `text` and
    `submit`.
  prefs: []
  type: TYPE_NORMAL
- en: Although the text box is about the most basic input element there is, we’ve
    taken this opportunity to dig much deeper into test-driven React. We’ve discovered
    the intricacies of raising `submit` and `change` events via JSDOM, such as ensuring
    that `event.preventDefault()` is called on the event to avoid a browser page transition.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also gone much further with Jest. We extracted common test logic into
    modules, used nested `describe` blocks, and built assertions using DOM’s Form
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll test-drive a more complicated form example: a form
    with select boxes and radio buttons.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some exercises for you to try out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract a `labelFor` helper into `test/reactTestExtensions.js`. It should be
    used like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `toBeInputFieldOfType` matcher that replaces the three expectations in
    the `itRendersAsATextBox` function. It should be used like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
