<html><head></head><body>
		<div id="_idContainer073">
			<h1 id="_idParaDest-169"><em class="italic"><a id="_idTextAnchor192"/>Chapter 11</em>: Writing Tests for React and Node.js</h1>
			<p>So far, we've written a lot of code and come across a variety of problems. We haven't yet implemented automated testing for our software; however, it's a common approach to make sure everything works after making changes to your application. Automated testing drastically improves the quality of your software and reduces errors in production.</p>
			<p>To achieve this, we will cover the following main topics in the chapter:</p>
			<ul>
				<li>How to use Mocha for testing</li>
				<li>Testing the GraphQL <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) with Mocha and Chai</li>
				<li>Testing React with Enzyme and JSDOM</li>
			</ul>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor193"/>Technical requirements</h1>
			<p>The source code for this chapter is available in the following GitHub repository:</p>
			<p><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter11">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter11</a></p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor194"/>Testing with Mocha</h1>
			<p>The problem we're facing is that we must ensure the quality of our software without increasing the amount <a id="_idIndexMarker847"/>of manual testing. It isn't possible to recheck every feature of our software when new updates are released. To solve this problem, we're going to use Mocha, which is a JavaScript testing framework that is used to run a series of asynchronous tests. If all the tests pass successfully, your application is OK and can get released to production.</p>
			<p>Many developers follow the <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>) approach. Often, when you implement <a id="_idIndexMarker848"/>tests for the first time, they fail because the business logic that's being tested is missing. After implementing all the tests, we have to write the actual application code to meet the requirements of the tests. In this book, we haven't followed this approach, but it isn't a problem as we can implement tests afterward too. Typically, I tend to write tests in parallel with the application code.</p>
			<p>To get started, we have to install all the dependencies to test our application with <strong class="source-inline">npm</strong>, as follows:</p>
			<p class="source-code">npm install --save-dev mocha chai @babel/polyfill request</p>
			<p>The <strong class="source-inline">mocha</strong> package includes almost everything to run tests. Along with Mocha, we also install <strong class="source-inline">chai</strong>, which is an assertion library. It offers excellent ways to chain tests with many variables and types for use inside a Mocha test. We also install the <strong class="source-inline">@babel/polyfill</strong> package, which allows our test to support <strong class="bold">ECMAScript 2015+</strong> (<strong class="bold">ES2015+)</strong> syntax. This package is crucial because we use this syntax everywhere throughout <a id="_idIndexMarker849"/>our React code. Finally, we install the <strong class="source-inline">request</strong> package as a library to send all the queries or mutations within our test. I recommend you set the <strong class="source-inline">NODE_ENV</strong> environment variable to <strong class="source-inline">production</strong> to test every functionality, as in a live environment. Be sure that you set the environment variable correctly so that all production features are used.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor195"/>Our first Mocha test</h2>
			<p>First, let's add a new command to <a id="_idIndexMarker850"/>the <strong class="source-inline">scripts</strong> field of our <strong class="source-inline">package.json</strong> file, as follows:</p>
			<p class="source-code">"test": "mocha --exit test/ --require babel-hook --require @babel/polyfill --recursive"</p>
			<p>If you now execute <strong class="source-inline">npm run test</strong>, we'll run the <strong class="source-inline">mocha</strong> package in the <strong class="source-inline">test</strong> folder, which we'll create in a second. The preceding <strong class="source-inline">--require</strong> option loads the specified file or package. We'll also load a <strong class="source-inline">babel-hook.js</strong> file, which we'll create as well. The <strong class="source-inline">--recursive</strong> parameter tells Mocha to run through the complete file tree of the <strong class="source-inline">test</strong> folder, not just the first layer. This behavior is useful because it allows us to structure our tests in multiple files and folders.</p>
			<p>Let's begin with the <strong class="source-inline">babel-hook.js</strong> file by adding it to the root of our project, next to the <strong class="source-inline">package.json</strong> file. Insert the following code:</p>
			<p class="source-code">require("@babel/register")({</p>
			<p class="source-code">  "plugins": [</p>
			<p class="source-code">    "require-context-hook"</p>
			<p class="source-code">  ],</p>
			<p class="source-code">  "presets": ["@babel/env","@babel/react"]</p>
			<p class="source-code">});</p>
			<p>The purpose of this file is to give us an alternative Babel configuration file to our standard <strong class="source-inline">.babelrc</strong> file. If you <a id="_idIndexMarker851"/>compare both files, you should see that we use the <strong class="source-inline">require-context-hook</strong> plugin. We already use this plugin when starting the <a id="_idIndexMarker852"/>backend with <strong class="source-inline">npm run server</strong>. It allows us to import our Sequelize models using a <strong class="bold">regular expression</strong> (<strong class="bold">regex</strong>).</p>
			<p>If we start our test with <strong class="source-inline">npm run test</strong>, we require this file at the beginning. Inside the <strong class="source-inline">babel-hook.js</strong> file, we load <strong class="source-inline">@babel/register</strong>, which compiles all the files that are imported afterward in our test according to the preceding configuration.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Notice that when running a production build or environment, the production database is also used. All changes are made to this database. Verify that you have configured the database credentials correctly in the server's <strong class="source-inline">configuration</strong> folder. You have only to set the <strong class="source-inline">host</strong>, <strong class="source-inline">username</strong>, <strong class="source-inline">password</strong>, and <strong class="source-inline">database</strong> environment variables correctly.</p>
			<p>This gives us the option to start our backend server from within our test file and render our application on the server. The preparation for our test is now finished. Create a folder named <strong class="source-inline">test</strong> inside the root of our project to hold all runnable tests. Mocha will scan all files or folders, and all tests will be executed. To get a basic test running, create an <strong class="source-inline">app.test.js</strong> file. This is the main file, which makes sure that our backend is running and in which we can subsequently define further tests. The first version of our test looks like this:</p>
			<p class="source-code">const assert = require('assert');</p>
			<p class="source-code">const request = require('request');</p>
			<p class="source-code">const expect = require('chai').expect;</p>
			<p class="source-code">const should = require('chai').should();</p>
			<p class="source-code">describe('Graphbook application test', function() {</p>
			<p class="source-code">  it('renders and serves the index page', function(done) {</p>
			<p class="source-code">    request('http://localhost:8000', function(err, res,</p>
			<p class="source-code">      body) {</p>
			<p class="source-code">      should.not.exist(err);</p>
			<p class="source-code">      should.exist(res);</p>
			<p class="source-code">      expect(res.statusCode).to.be.equal(200);</p>
			<p class="source-code">      assert.ok(body.indexOf('&lt;html') !== -1);</p>
			<p class="source-code">      done(err);</p>
			<p class="source-code">    });</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>Let's take a closer look at what's happening here, as follows:</p>
			<ol>
				<li>We import <a id="_idIndexMarker853"/>the Node.js <strong class="source-inline">assert</strong> function. This gives us the ability to verify the value or type of a variable.</li>
				<li>We import the <strong class="source-inline">request</strong> package, which we use to send queries against our backend.</li>
				<li>We import two Chai functions, <strong class="source-inline">expect</strong> and <strong class="source-inline">should</strong>, from the <strong class="source-inline">chai</strong> package. Neither of these is included in Mocha, but they both improve the test's functionality significantly.</li>
				<li>The beginning of the test starts with the <strong class="source-inline">describe</strong> function. Because Mocha executes the <strong class="source-inline">app.test.js</strong> file, we're in the correct scope and can use all Mocha functions. The <strong class="source-inline">describe</strong> function is used to structure your test and its output.</li>
				<li>We use the <strong class="source-inline">it</strong> function, which initiates the first test.</li>
			</ol>
			<p>The <strong class="source-inline">it</strong> function can be understood as a feature of our application that we want to test inside the callback function. As the first parameter, you should enter a sentence, such as <strong class="source-inline">'it does this and that'</strong>, that's easily readable. The function itself waits for the complete execution of the <strong class="source-inline">callback</strong> function in the second parameter. The result of the callback will either <a id="_idIndexMarker854"/>be that all assertions were successful or that, for some reason, a test failed or the callback didn't complete in a reasonable amount of time.</p>
			<p>The <strong class="source-inline">describe</strong> function is the header of our test's output. Then, we have a new row for each <strong class="source-inline">it</strong> function we execute. Each row represents a single test step. The <strong class="source-inline">it</strong> function passes a <strong class="source-inline">done</strong> function to the callback. The <strong class="source-inline">done</strong> function has to be executed once all assertions are finished and there's nothing left to do. If it isn't executed in a certain amount of time, the current test is marked as failed. In the preceding code snippet, the <a id="_idIndexMarker855"/>first thing we did was send a <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) <strong class="source-inline">GET</strong> request to <strong class="source-inline">http://localhost:8000</strong>, which is accepted by our backend server. The expected answer <a id="_idIndexMarker856"/>will be in the form of server-side rendered <strong class="bold">HyperText Markup Language</strong> (<strong class="bold">HTML</strong>) created through React.</p>
			<p>To prove that the response holds this information, we make some assertions in our preceding test, as follows:</p>
			<ol>
				<li value="1">We use the <strong class="source-inline">should</strong> function from Chai. The great thing is that it's chainable and represents a sentence that directly explains the meaning of what we're doing. The <strong class="source-inline">should.not.exist</strong> function chain makes sure that the given value is empty. The result is <strong class="source-inline">true</strong> if the value is <strong class="source-inline">undefined</strong> or <strong class="source-inline">null</strong>, for example. The consequence is that when the <strong class="source-inline">err</strong> variable is filled, the assertion fails and so our test, <strong class="source-inline">'renders and serves the index page'</strong>, fails too.</li>
				<li>The same goes for the <strong class="source-inline">should.exist</strong> line. It makes sure that the <strong class="source-inline">res</strong> variable, which is the response given by the backend, is filled. Otherwise, there's a problem with the backend.</li>
				<li>The <strong class="source-inline">expect</strong> function can also represent a sentence, as with both functions before. We expect <strong class="source-inline">res.statusCode</strong> to have a value of <strong class="source-inline">200</strong>. This assertion can be written as <strong class="source-inline">expect(res.statusCode).to.be.equal(200)</strong>. We can be sure that everything has gone well if the HTTP status is <strong class="source-inline">200</strong>.</li>
				<li>If nothing has failed so far, we check whether the returned <strong class="source-inline">body</strong> variable, which is the third <a id="_idIndexMarker857"/>callback parameter of the <strong class="source-inline">request</strong> function, is valid. For our test scenario, we only need to check whether it contains an <strong class="source-inline">html</strong> tag.</li>
				<li>We execute the <strong class="source-inline">done</strong> function. We pass the <strong class="source-inline">err</strong> object as a parameter. The result of this function is much like the <strong class="source-inline">should.not.exist</strong> function. If you pass a filled error object to the <strong class="source-inline">done</strong> function, the test fails. The tests become more readable when using the Chai syntax.</li>
			</ol>
			<p>If you execute <strong class="source-inline">npm run test</strong> now, you'll receive the following error:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/Figure_11.01_B17337.jpg" alt="Figure 11.1 – Failed test because no server ran&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – Failed test because no server ran</p>
			<p>Our first <strong class="source-inline">should.not.exist</strong> assertion failed and threw an error. This is because we didn't start the backend <a id="_idIndexMarker858"/>when we ran the test. Start the backend in a second terminal with the correct environment variables using <strong class="source-inline">npm run server</strong> and rerun the test. Now, the test is successful, as we can see here:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/Figure_11.02_B17337.jpg" alt="Figure 11.2 – Test passes if the server runs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Test passes if the server runs</p>
			<p>The output is good, but the process isn't very intuitive. The current workflow is hard to implement when <a id="_idIndexMarker859"/>running the tests automatically while deploying your application or pushing new commits to your <strong class="bold">version control system</strong> (<strong class="bold">VCS</strong>). We'll change this behavior next.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor196"/>Starting the backend with Mocha</h2>
			<p>When we want <a id="_idIndexMarker860"/>to run a test, the server should start automatically. There are <a id="_idIndexMarker861"/>two options to implement this behavior, as outlined here:</p>
			<ul>
				<li>We add the <strong class="source-inline">npm run server</strong> command to the <strong class="source-inline">test</strong> script inside our <strong class="source-inline">package.json</strong> file.</li>
				<li>We import all the necessary files to launch the server within our <strong class="source-inline">app.test.js</strong> file. This allows us to run further assertions or commands against the backend.</li>
			</ul>
			<p>The best option is to start the server within our test and not rely on a second command because we can run further tests on the backend. We need to import a further package to allow the server to start within our test, as follows:</p>
			<p class="source-code">require('babel-plugin-require-context-hook/register')();</p>
			<p>We use and execute this package because we load the Sequelize models using the <strong class="source-inline">require.context</strong> function. By loading the package, the <strong class="source-inline">require.context</strong> function is executable for the server-side code. Before we started the server within the test, the plugin hadn't been used, although it was loaded in the <strong class="source-inline">babel-hooks.js</strong> file.</p>
			<p>Now, we can load the server directly in the test. Add the following lines of code at the top of the <strong class="source-inline">describe</strong> function, just before the test we've just written:</p>
			<p class="source-code">var app;</p>
			<p class="source-code">this.timeout(50000);</p>
			<p class="source-code">before(function(done) {</p>
			<p class="source-code">  app = require('../src/server').default;</p>
			<p class="source-code">  app.on("listening", function() {</p>
			<p class="source-code">    done();</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>The idea is to load the server's <strong class="source-inline">index.js</strong> file inside of our test, which starts the backend automatically. To do this, we define an empty variable called <strong class="source-inline">app</strong>. Then, we use <strong class="source-inline">this.timeout</strong> to set <a id="_idIndexMarker862"/>the timeout for all tests inside Mocha to <strong class="source-inline">50000</strong> because <a id="_idIndexMarker863"/>starting our server, including Apollo Server, takes some time. Otherwise, the test will probably fail because the start time is too long for the standard Mocha timeout.</p>
			<p>We must make sure that the server has been completely started before any of our tests are executed. This logic can be achieved with Mocha's <strong class="source-inline">before</strong> function. Using this function, you can set up and configure things such as starting a backend in our scenario. To continue and process all the tests, we need to execute the <strong class="source-inline">done</strong> function to complete the callback of the <strong class="source-inline">before</strong> function. To be sure that the server has started, we do not just run the <strong class="source-inline">done</strong> function after loading the <strong class="source-inline">index.js</strong> file. We bind the <strong class="source-inline">listening</strong> event of the server using the <strong class="source-inline">app.on</strong> function. If the server emits the <strong class="source-inline">listening</strong> event, we can securely run the <strong class="source-inline">done</strong> function, and all tests can send requests to the server. We could also save the return value of the <strong class="source-inline">require</strong> function directly into the <strong class="source-inline">app</strong> variable to hold the <strong class="source-inline">server</strong> object. The problem with this order, however, is that the server may start listening before we can bind the <strong class="source-inline">listening</strong> event. The way we are doing it now makes sure the server hasn't yet started.</p>
			<p>The test, however, still isn't working. You'll see an error message that says <strong class="source-inline">'TypeError: app.on is not a function'</strong>. Take a closer look at the server's <strong class="source-inline">index.js</strong> file. At the end of the file, we aren't exporting the <strong class="source-inline">server</strong> object because we only used it to start the backend. This means that the <strong class="source-inline">app</strong> variable in our test is empty and we can't run the <strong class="source-inline">app.on</strong> function. The solution is to export the <strong class="source-inline">server</strong> object at the end of the server's <strong class="source-inline">index.js</strong> file, like this:</p>
			<p class="source-code">export default server;</p>
			<p>You can now execute the test again. Everything should look fine, and all tests should pass.</p>
			<p>There is, however, one last problem. If you compare the behavior from the test before importing the server directly in our test or starting it in a second terminal, you might notice that <a id="_idIndexMarker864"/>the test isn't finished, or at least the process isn't stopped. Previously, all steps were executed, we returned to the normal shell, and <a id="_idIndexMarker865"/>we could execute the next command. The reason for this is that the server is still running in our <strong class="source-inline">app.test.js</strong> file. Therefore, we must stop the backend after all tests have been executed. Insert the following code after the <strong class="source-inline">before</strong> function:</p>
			<p class="source-code">after(function(done) {</p>
			<p class="source-code">  app.close(done);</p>
			<p class="source-code">});</p>
			<p>The <strong class="source-inline">after</strong> function is run when all tests are finished. Our <strong class="source-inline">app</strong> object offers the <strong class="source-inline">close</strong> function, which terminates the server. As a callback, we hand over the <strong class="source-inline">done</strong> function, which is executed once the server has stopped. This means that our test has also finished.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor197"/>Verifying the correct routing</h2>
			<p>We now want to check whether all the features of our application are working as expected. One major <a id="_idIndexMarker866"/>feature of our application is that React Router redirects the user in the following two cases:</p>
			<ul>
				<li>The user visits a route that cannot be matched.</li>
				<li>The user visits a route that can be matched, but they aren't allowed to view the page.</li>
			</ul>
			<p>In both cases, the user should be redirected to the login form. In the first case, we can follow the same approach as for our first test. We send a request to a path that isn't inside our router. Add the following code to the bottom of the <strong class="source-inline">describe</strong> function:</p>
			<p class="source-code">describe('404', function() {</p>
			<p class="source-code">  it('redirects the user when not matching path is found',</p>
			<p class="source-code">    function(done) {</p>
			<p class="source-code">    request({</p>
			<p class="source-code">      url: 'http://localhost:8000/path/to/404',</p>
			<p class="source-code">    }, function(err, res, body) {</p>
			<p class="source-code">      should.not.exist(err);</p>
			<p class="source-code">      should.exist(res);</p>
			<p class="source-code">      expect(res.statusCode).to.be.equal(200);</p>
			<p class="source-code">      assert.ok(res.req.path === '/');</p>
			<p class="source-code">      assert.ok(body.indexOf('&lt;html') !== -1);</p>
			<p class="source-code">      assert.ok(body.indexOf('class="authModal"') !== -1);</p>
			<p class="source-code">      done(err);</p>
			<p class="source-code">    });</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>Let's quickly go <a id="_idIndexMarker867"/>through all the steps of the preceding test, as follows:</p>
			<ol>
				<li value="1">We add a new <strong class="source-inline">describe</strong> function to structure our test's output.</li>
				<li>We send a request inside another <strong class="source-inline">it</strong> function to an unmatched path.</li>
				<li>The checks are the same as the ones we used when starting the server.</li>
				<li>We verify that the response's path is the <strong class="source-inline">/</strong> root. That happens when the redirect is executed. Therefore, we use the <strong class="source-inline">res.req.path === '/'</strong> condition.</li>
				<li>We check whether the returned <strong class="source-inline">body</strong> variable includes an HTML tag with the <strong class="source-inline">authModal</strong> class. This should happen when the user isn't logged in, and the login or register form is rendered.</li>
			</ol>
			<p>If the assertions are successful, we know that React Router works correctly in the first scenario. The second <a id="_idIndexMarker868"/>scenario relates to private routes that can only be accessed by authenticated users. We can copy the preceding check and replace the request. The assertions <a id="_idIndexMarker869"/>we are doing stay the same, but the <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) of the request is different. Add the following test under the previous one:</p>
			<p class="source-code">describe('authentication', function() {</p>
			<p class="source-code">  it('redirects the user when not logged in', </p>
			<p class="source-code">    function(done) {</p>
			<p class="source-code">    request({</p>
			<p class="source-code">      url: 'http://localhost:8000/app',</p>
			<p class="source-code">    }, function(err, res, body) {</p>
			<p class="source-code">      should.not.exist(err);</p>
			<p class="source-code">      should.exist(res);</p>
			<p class="source-code">      expect(res.statusCode).to.be.equal(200);</p>
			<p class="source-code">      assert.ok(res.req.path === '/');</p>
			<p class="source-code">      assert.ok(body.indexOf('&lt;html') !== -1);</p>
			<p class="source-code">      assert.ok(body.indexOf('class="authModal"') !== -1);</p>
			<p class="source-code">      done(err);</p>
			<p class="source-code">    });</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>If an unauthenticated user requests the <strong class="source-inline">/app</strong> route, they're redirected to the <strong class="source-inline">/</strong> root path. The assertions <a id="_idIndexMarker870"/>verify whether the login form is displayed as before. To differentiate the tests, we add a new <strong class="source-inline">describe</strong> function so that it has a better structure.</p>
			<p>In this section, we have learned how use Mocha to assert that our application works correctly. We are now verifying whether our application starts and also whether the routing works as expected and returns the correct pages.</p>
			<p>Next, we want to <a id="_idIndexMarker871"/>test the GraphQL API that we built, not only the <strong class="bold">server-side rendering</strong> (<strong class="bold">SSR</strong>) functionality.</p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor198"/>Testing the GraphQL API with Mocha </h1>
			<p>We must verify <a id="_idIndexMarker872"/>that all the API functions we're offering <a id="_idIndexMarker873"/>work correctly. I'm going to show you how to do this with two examples, as follows:</p>
			<ul>
				<li>The user needs to sign up or log in. This is a critical feature where we should verify that the API works correctly.</li>
				<li>The user queries or mutates data via the GraphQL API. For our test case, we will request all chats the logged-in user is related to.</li>
			</ul>
			<p>Those two examples should explain all the essential techniques to test every part of your API. You can add more functions that you want to test at any point.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor199"/>Testing the authentication</h2>
			<p>We extend the authentication tests of our test with the signup functionality. We're going to send a <a id="_idIndexMarker874"/>simple GraphQL request to our backend, including all the required data to sign up a new user. We've already sent requests, so there's nothing new here. In comparison to all the requests before, however, we have to send a <strong class="source-inline">POST</strong> request, not a <strong class="source-inline">GET</strong> request. Also, the endpoint for the signup is the <strong class="source-inline">/graphql</strong> path, where our Apollo Server listens for incoming mutations or queries. Normally, when a user signs up for Graphbook, the authentication token is returned directly, and the user is logged in. We must preserve this token to make future GraphQL requests. We don't use Apollo Client for our test as we don't need to test the GraphQL API.</p>
			<p>Create a global <a id="_idIndexMarker875"/>variable next to the <strong class="source-inline">app</strong> variable, where we can store the <strong class="bold">JavaScript Object Notation (JSON) Web Token</strong> (<strong class="bold">JWT</strong>) returned after signup, as follows:</p>
			<p class="source-code">var authToken;</p>
			<p>Inside the test, we can set the returned JWT. Add the following <a id="_idIndexMarker876"/>code to the <strong class="source-inline">authentication</strong> function:</p>
			<p class="source-code">it('allows the user to sign up', function(done) {</p>
			<p class="source-code">  const json = {</p>
			<p class="source-code">    operationName: null,</p>
			<p class="source-code">    query: "mutation signup($username: String!, $email : </p>
			<p class="source-code">      String!, </p>
			<p class="source-code">    $password : String!) { signup(username: $username,</p>
			<p class="source-code">      email: $email,   </p>
			<p class="source-code">    password : $password) { token }}",</p>
			<p class="source-code">    variables: {</p>
			<p class="source-code">      "email": "mocha@test.com",</p>
			<p class="source-code">      "username": "mochatest",</p>
			<p class="source-code">      "password": "123456789"</p>
			<p class="source-code">    }</p>
			<p class="source-code">  };</p>
			<p class="source-code">  request.post({</p>
			<p class="source-code">    url: 'http://localhost:8000/graphql',</p>
			<p class="source-code">    json: json,</p>
			<p class="source-code">  }, function(err, res, body) {</p>
			<p class="source-code">    should.not.exist(err);</p>
			<p class="source-code">    should.exist(res);</p>
			<p class="source-code">    expect(res.statusCode).to.be.equal(200);</p>
			<p class="source-code">    body.should.be.an('object');</p>
			<p class="source-code">    body.should.have.property('data');</p>
			<p class="source-code">    authToken = body.data.signup.token;</p>
			<p class="source-code">    done(err);</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>We begin by creating a <strong class="source-inline">json</strong> variable. This object is sent as a JSON body to our GraphQL API. The content <a id="_idIndexMarker877"/>of it should be familiar to you—it's nearly the same format we used when testing the GraphQL API in Postman.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The JSON we send represents a manual way of sending GraphQL requests. There are libraries that you can easily use to save this and directly send the query without wrapping it inside <a id="_idIndexMarker878"/>an object, such as <strong class="source-inline">graphql-request</strong>: <a href="https://github.com/prisma-labs/graphql-request">https://github.com/prisma-labs/graphql-request</a>.</p>
			<p>The <strong class="source-inline">json</strong> object includes fake signup variables to create a user with the <strong class="source-inline">mochatest</strong> username. We'll send HTTP <strong class="source-inline">POST</strong> with the <strong class="source-inline">request.post</strong> function. To use the <strong class="source-inline">json</strong> variable, we pass it into the <strong class="source-inline">json</strong> field. The <strong class="source-inline">request.post</strong> function automatically adds the body as a JSON string and the correct <strong class="source-inline">Content-Type</strong> header for you. When the response arrives, we run the standard checks, such as checking for an error or checking an HTTP status code. We also check the format of the returned <strong class="source-inline">body</strong> variable because the response's <strong class="source-inline">body</strong> variable won't return HTML but will return JSON instead. We make sure that it's an object with the <strong class="source-inline">should.be.an('object')</strong> function. The <strong class="source-inline">should</strong> assertion can directly be used and chained to the <strong class="source-inline">body</strong> variable. If <strong class="source-inline">body</strong> is an object, we check whether there's a <strong class="source-inline">data</strong> property inside. That's enough security to read the token from the <strong class="source-inline">body.data.signup.token</strong> property.</p>
			<p>The user is now created in our database. We can use this token for further requests. Be aware that running <a id="_idIndexMarker879"/>this test a second time on your local machine is likely to result in a failure because the user already exists. In this case, you can delete it manually <a id="_idIndexMarker880"/>from your database. This problem won't occur when running this test while using <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>). We'll focus on this topic in the last chapter. Next, we'll make an authenticated query to our Apollo Server and test the result of it.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor200"/>Testing authenticated requests</h2>
			<p>We <a id="_idIndexMarker881"/>set the <strong class="source-inline">authToken</strong> variable after the signup request. You could also do this with a login request if a user already exists while testing. Only the query and the assertions we are using are going to change. Also, insert the following code into the <strong class="source-inline">before</strong> authentication function:</p>
			<p class="source-code">it('allows the user to query all chats', function(done) {</p>
			<p class="source-code">  const json = {</p>
			<p class="source-code">    operationName: null,</p>
			<p class="source-code">    query: "query {chats {id users {id avatar username}}}",</p>
			<p class="source-code">    variables: {}</p>
			<p class="source-code">  };</p>
			<p class="source-code">  request.post({</p>
			<p class="source-code">    url: 'http://localhost:8000/graphql',</p>
			<p class="source-code">    headers: {</p>
			<p class="source-code">      'Authorization': authToken</p>
			<p class="source-code">    },</p>
			<p class="source-code">    json: json,</p>
			<p class="source-code">  }, function(err, res, body) {</p>
			<p class="source-code">    should.not.exist(err);</p>
			<p class="source-code">    should.exist(res);</p>
			<p class="source-code">    expect(res.statusCode).to.be.equal(200);</p>
			<p class="source-code">    body.should.be.an('object');</p>
			<p class="source-code">    body.should.have.property('data');</p>
			<p class="source-code">     body.data.should.have.property(</p>
			<p class="source-code">       'chats').with.lengthOf(0);</p>
			<p class="source-code">    done(err);</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>As you can see in the preceding code snippet, the <strong class="source-inline">json</strong> object doesn't include any variables because we only query the chats of the logged-in user. We changed the <strong class="source-inline">query</strong> string accordingly. Compared to the login or signup request, the chat query requires the user to be <a id="_idIndexMarker882"/>authenticated. The <strong class="source-inline">authToken</strong> variable we saved is sent inside the <strong class="source-inline">Authorization</strong> header. We now verify again whether the request was successful and check for a <strong class="source-inline">data</strong> property in the <strong class="source-inline">body</strong> variable. Notice that, before running the <strong class="source-inline">done</strong> function, we verify that the <strong class="source-inline">data</strong> object has a field called <strong class="source-inline">chats</strong>. We also check the length of the <strong class="source-inline">chats</strong> field, which proves that it's an array. The length can be statically set to <strong class="source-inline">0</strong> because the user who's sending the query just signed up and doesn't have any chats yet. The output from Mocha looks like this:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/Figure_11.03_B17337.jpg" alt="Figure 11. 3 – Authentication test&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11. 3 – Authentication test</p>
			<p>This is all you need <a id="_idIndexMarker883"/>to know to test all the features of your API.</p>
			<p>Next, we are going to have a look on Enzyme, which is a great testing tool that allows you to interact with the React components that we have written and ensure that they are working as expected. </p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor201"/>Testing React with Enzyme</h1>
			<p>So far, we've managed to test our server and all GraphQL API functions. Currently, however, we're still <a id="_idIndexMarker884"/>missing the tests for our frontend code. While we <a id="_idIndexMarker885"/>render the React code when requesting any server route, such as the <strong class="source-inline">/app</strong> path, we only have access to the final result and not to each component. We should change this to execute the functions of certain components that aren't testable through the backend. First, install some dependencies before using <strong class="source-inline">npm</strong>, as follows:</p>
			<p class="source-code">npm install --save-dev enzyme @wojtekmaj/enzyme-adapter-react-17ignore-styles jsdom isomorphic-fetch</p>
			<p>The various packages are described in more detail here:</p>
			<ul>
				<li>The <strong class="source-inline">enzyme</strong> and <strong class="source-inline">@wojtekmaj/enzyme-adapter-react-17</strong> packages provide React with specific features to render and interact with the React tree. This can be through either a real <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) or shallow rendering. We are <a id="_idIndexMarker886"/>going to use a real DOM in this chapter because it allows us to test all features, while shallow rendering is limited to just the first layer of components. We need to rely on a third-party package for the React adapter because there is no official support at the moment for React 17 from Enzyme.</li>
				<li>The <strong class="source-inline">ignore-styles</strong> package <a id="_idIndexMarker887"/>strips out all <strong class="source-inline">import</strong> statements for <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>) files. This is very helpful since we don't need CSS for our tests.</li>
				<li>The <strong class="source-inline">jsdom</strong> package creates a DOM object for us, which is then used to render the React code into.</li>
				<li>The <strong class="source-inline">isomorphic-fetch</strong> package replaces the <strong class="source-inline">fetch</strong> function that all browsers provide by default. This isn't available in Node.js, so we need a polyfill.</li>
			</ul>
			<p>We start by importing the new packages directly under the other <strong class="source-inline">require</strong> statements, as follows:</p>
			<p class="source-code">require('isomorphic-fetch');</p>
			<p class="source-code">import React from 'react';</p>
			<p class="source-code">import { configure, mount } from 'enzyme';</p>
			<p class="source-code">import Adapter from @wojtekmaj/enzyme-adapter-react-17';</p>
			<p class="source-code">configure({ adapter: new Adapter() });</p>
			<p class="source-code">import register from 'ignore-styles';</p>
			<p class="source-code">register(['.css', '.sass', '.scss']);</p>
			<p>To use Enzyme, we import React. Then, we create an adapter for Enzyme that supports React 16. We insert <a id="_idIndexMarker888"/>the adapter into Enzyme's <strong class="source-inline">configure</strong> statement. Before <a id="_idIndexMarker889"/>starting with the frontend code, we import the <strong class="source-inline">ignore-styles</strong> package to ignore all CSS imports. I've also directly excluded <strong class="bold">Syntactically Awesome Style Sheets</strong> (<strong class="bold">SASS</strong>) and SCSS files. The next <a id="_idIndexMarker890"/>step is to initialize our DOM object, where all the React code is rendered. Here's the code you'll need:</p>
			<p class="source-code">const { JSDOM } = require('jsdom');</p>
			<p class="source-code">const dom = new JSDOM('&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;</p>
			<p class="source-code">  &lt;/html&gt;', { url: 'http://graphbook.test' });</p>
			<p class="source-code">const { window } = dom;</p>
			<p class="source-code">global.window = window;</p>
			<p class="source-code">global.document = window.document;</p>
			<p>We require the <strong class="source-inline">jsdom</strong> package and initialize it with a small HTML string. We don't take the template file that we're using for the server or client because we just want to render our application to any HTML, so how it looks isn't important. The second parameter is an <strong class="source-inline">options</strong> object. We specify a <strong class="source-inline">url</strong> field, which is the host URL, under which we render the React code. Otherwise, we might get an error when accessing <strong class="source-inline">localStorage</strong>. After initialization, we extract the <strong class="source-inline">window</strong> object and define two global variables that are required to mount a React component to our fake DOM. These two properties behave like the <strong class="source-inline">document</strong> and <strong class="source-inline">window</strong> objects in the browser, but instead of the browser, they are global objects inside our Node.js server.</p>
			<p>In general, it isn't a good idea to mix up the Node.js <strong class="source-inline">global</strong> object with the DOM of a browser and render a React application in it. Still, we're merely testing our application and not running it in production in this environment, so while it might not be recommended, it helps our test to be more readable. We'll begin the first frontend test with our login form. The visitor to our page can either directly log in or switch to the signup form. Currently, we don't test this switch functionality in any way. This is a complex example, but you should be able to understand the techniques behind it quickly.</p>
			<p>To render our complete React code, we're going to initialize an Apollo Client for our test. Import all the dependencies, as follows:</p>
			<p class="source-code">import { ApolloClient, InMemoryCache, from } from '@apollo/client';</p>
			<p class="source-code">import { createUploadLink } from 'apollo-upload-client';</p>
			<p class="source-code">import App from '../src/server/ssr';</p>
			<p>We also <a id="_idIndexMarker891"/>import the <strong class="source-inline">index.js</strong> component of the server-rendered <a id="_idIndexMarker892"/>React code. This component will receive our client, which we'll initialize shortly. Add a new <strong class="source-inline">describe</strong> function for all frontend tests, as follows:</p>
			<p class="source-code">describe('frontend', function() {</p>
			<p class="source-code">  it('renders and switches to the login or register form', </p>
			<p class="source-code">  function(done) {</p>
			<p class="source-code">    const httpLink = createUploadLink({</p>
			<p class="source-code">      uri: 'http://localhost:8000/graphql',</p>
			<p class="source-code">      credentials: 'same-origin',</p>
			<p class="source-code">    });</p>
			<p class="source-code">    const client = new ApolloClient({</p>
			<p class="source-code">      link: from([</p>
			<p class="source-code">        httpLink</p>
			<p class="source-code">      ]),</p>
			<p class="source-code">      cache: new InMemoryCache()</p>
			<p class="source-code">    });</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>The preceding code creates a new Apollo Client. The client doesn't implement any logic, such as authentication or WebSockets, because we don't need this to test the switch from the login form to the signup form. It's merely a required property to render our application completely. If you want to test components that are only rendered when being authenticated, you can, of course, implement <a id="_idIndexMarker893"/>it easily. Enzyme <a id="_idIndexMarker894"/>requires us to pass a real React component, which will be rendered to the DOM. Add the following code directly beneath the <strong class="source-inline">client</strong> variable:</p>
			<p class="source-code">class Graphbook extends React.Component {</p>
			<p class="source-code">  render() {</p>
			<p class="source-code">    return(</p>
			<p class="source-code">      &lt;App client={client} context={{}} loggedIn={false}</p>
			<p class="source-code">        location= {"/"}/&gt;</p>
			<p class="source-code">    )</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The preceding code is a small wrapper around the <strong class="source-inline">App</strong> variable that we imported from the server's <strong class="source-inline">ssr</strong> folder. The <strong class="source-inline">client</strong> property is filled with the new Apollo Client. Follow the given instructions to render and test your React frontend code. The following code goes directly under the <strong class="source-inline">Graphbook</strong> class:</p>
			<ol>
				<li value="1">We use the <strong class="source-inline">mount</strong> function of Enzyme to render the <strong class="source-inline">Graphbook</strong> class to the DOM, as follows:<p class="source-code">const wrapper = mount(&lt;Graphbook /&gt;);</p></li>
				<li>The <strong class="source-inline">wrapper</strong> variable provides many functions to access or interact with the DOM and the components inside it. We use it to prove that the first render displays the login form. The code is illustrated here:<p class="source-code">expect(wrapper.html()).to.contain('&lt;a&gt;Want to sign up? Click here&lt;/a&gt;');</p><p>The <strong class="source-inline">html</strong> function of the <strong class="source-inline">wrapper</strong> variable returns the complete HTML string that has been rendered by the React code. We check this string with the <strong class="source-inline">contain</strong> function of Chai. If the check is successful, we can continue.</p></li>
				<li>Typically, the user clicks on the <strong class="bold">Want to sign up?</strong> message and React re-renders the signup form. We need to handle this via the <strong class="source-inline">wrapper</strong> variable. The enzyme comes with that functionality innately, as illustrated here: <p class="source-code">wrapper.find('LoginRegisterForm').find('a').simulate('click');</p><p>The <strong class="source-inline">find</strong> function gives us access to the <strong class="source-inline">LoginRegisterForm</strong> component. Inside the markup <a id="_idIndexMarker895"/>of the component, we search for an <strong class="source-inline">a</strong> tag, of <a id="_idIndexMarker896"/>which there can only be one. If the <strong class="source-inline">find</strong> method returns multiple results, we can't trigger things such as a click because the <strong class="source-inline">simulate</strong> function is fixed to only one possible target. After running both <strong class="source-inline">find</strong> functions, we execute Enzyme's <strong class="source-inline">simulate</strong> function. The only parameter needed is the event that we want to trigger. In our scenario, we trigger a <strong class="source-inline">click</strong> event on the <strong class="source-inline">a</strong> tag, which lets React handle all the rest.</p></li>
				<li>We check whether the form was changed correctly by executing the following code:<p class="source-code">expect(wrapper.html()).to.contain('&lt;a&gt;Want to login?</p><p class="source-code">  Click here&lt;/a&gt;');</p><p class="source-code">done();</p><p>We use the <strong class="source-inline">html</strong> and <strong class="source-inline">contain</strong> functions to verify that everything was rendered correctly. The <strong class="source-inline">done</strong> method of Mocha is used to finish the test.</p><p class="callout-heading">Note</p><p class="callout">For a more detailed overview of the API and all the functions that Enzyme provides, have <a id="_idIndexMarker897"/>a look at the official documentation: <a href="https://enzymejs.github.io/enzyme/docs/api/">https://enzymejs.github.io/enzyme/docs/api/</a>.</p></li>
			</ol>
			<p>This was the easy part. How <a id="_idIndexMarker898"/>does this work when we want to verify <a id="_idIndexMarker899"/>whether the client can send queries or mutations with authentication? It's actually not that different. We already registered a new user and got a JWT in return. All we need to do is attach the JWT to our Apollo Client, and the router needs to receive the correct <strong class="source-inline">loggedIn</strong> property. The final code for this test looks like this:</p>
			<p class="source-code">it('renders the current user in the top bar', function(done) {</p>
			<p class="source-code">  const AuthLink = (operation, next) =&gt; {</p>
			<p class="source-code">    operation.setContext(context =&gt; ({</p>
			<p class="source-code">        ...context,</p>
			<p class="source-code">        headers: {</p>
			<p class="source-code">            ...context.headers,</p>
			<p class="source-code">            Authorization: authToken</p>
			<p class="source-code">        },</p>
			<p class="source-code">    }));</p>
			<p class="source-code">    return next(operation);</p>
			<p class="source-code">  };</p>
			<p class="source-code">  const httpLink = createUploadLink({</p>
			<p class="source-code">    uri: 'http://localhost:8000/graphql',</p>
			<p class="source-code">    credentials: 'same-origin',</p>
			<p class="source-code">  });</p>
			<p class="source-code">  const client = new ApolloClient({</p>
			<p class="source-code">    link: from([</p>
			<p class="source-code">      AuthLink,</p>
			<p class="source-code">      httpLink</p>
			<p class="source-code">    ]),</p>
			<p class="source-code">    cache: new InMemoryCache()</p>
			<p class="source-code">  });</p>
			<p class="source-code">  class Graphbook extends React.Component {</p>
			<p class="source-code">    render() {</p>
			<p class="source-code">      return(</p>
			<p class="source-code">        &lt;App client={client} context={{}} loggedIn={true}</p>
			<p class="source-code">          location= {"/app"}/&gt;</p>
			<p class="source-code">      )</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  const wrapper = mount(&lt;Graphbook /&gt;);</p>
			<p class="source-code">  setTimeout(function() {</p>
			<p class="source-code">    expect(wrapper.html()).to.contain(</p>
			<p class="source-code">     '&lt;div class="user"&gt;&lt;img&gt;</p>
			<p class="source-code">     &lt;span&gt;mochatest&lt;/span&gt;&lt;/div&gt;');</p>
			<p class="source-code">    done();</p>
			<p class="source-code">  },2000);</p>
			<p class="source-code">});</p>
			<p>Here, we are using the <strong class="source-inline">AuthLink</strong> function that we used in the original frontend code. We pass the <strong class="source-inline">authToken</strong> variable to every request that's made by the Apollo Client. In the <strong class="source-inline">Apollo.from</strong> method, we add it before <strong class="source-inline">httpLink</strong>. In the <strong class="source-inline">Graphbook</strong> class, we set <strong class="source-inline">loggedIn</strong> to <strong class="source-inline">true</strong> and <strong class="source-inline">location</strong> to <strong class="source-inline">/app</strong> to render the newsfeed. Because the requests are asynchronous by default and the <strong class="source-inline">mount</strong> method doesn't wait for the Apollo Client to fetch all <a id="_idIndexMarker900"/>queries, we couldn't directly check the DOM for <a id="_idIndexMarker901"/>the correct content. Instead, we wrapped the assertions and the <strong class="source-inline">done</strong> function in a <strong class="source-inline">setTimeout</strong> function. A timeout of 2,000 <strong class="bold">milliseconds</strong> (<strong class="bold">ms</strong>) should be enough for all requests to finish and React to have rendered <a id="_idIndexMarker902"/>everything. If this isn't enough time, you can increase the number. When all assertions are successful, we can be sure that the <strong class="source-inline">currentUser</strong> query has been run and the top bar has been rendered to show the logged-in user. With these two examples, you should now be able to run any test you want with your application's frontend code.</p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor202"/>Summary</h1>
			<p>In this chapter, we learned all the essential techniques to test your application automatically, including testing the server, the GraphQL API, and the user's frontend. You can apply the Mocha and Chai patterns you learned to other projects to reach a high software quality at any time. Your personal testing time will be greatly reduced.</p>
			<p>In the next chapter, we'll have a look at how to improve performance and error logging so that we're always providing a good <strong class="bold">user experience</strong> (<strong class="bold">UX</strong>).</p>
		</div>
	</body></html>