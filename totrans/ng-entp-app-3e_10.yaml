- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Releasing to Production with CI/CD
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CI/CD 发布到生产环境
- en: Ship it or it never happened! If you don’t publish your code, you create zero
    value. This motivation to ship your work is prevalent in many industries. However,
    delivering a piece of work to someone else or opening it up to public scrutiny
    can be terrifying. In software engineering, delivering anything is difficult;
    delivering something to production is even more difficult.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 发布它，否则它从未发生！如果你不发布你的代码，你创造的价值为零。这种将你的工作发布的动力在许多行业中都很普遍。然而，将一份工作交付给他人或将其公之于众可能会令人恐惧。在软件工程中，交付任何事物都是困难的；将事物部署到生产环境则更加困难。
- en: 'Check out my 2018 talk, *Ship It or It Never Happened: The Power of Docker,
    Heroku, and CircleCI*, at [https://bit.ly/ship-it-or-it-never-happened](https://bit.ly/ship-it-or-it-never-happened).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我的 2018 年演讲，*发布它，否则它从未发生：Docker、Heroku 和 CircleCI 的力量*，[https://bit.ly/ship-it-or-it-never-happened](https://bit.ly/ship-it-or-it-never-happened)。
- en: We live in an era of moving fast and breaking things. However, the latter part
    of that statement rarely works in an enterprise. You can live on the edge and
    adopt the YOLO lifestyle, but this doesn’t make good business sense.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个快速行动和破坏事物的时代。然而，这个说法的后半部分在企业中很少适用。你可以生活在边缘，采用 YOLO 生活方式，但这并不符合良好的商业逻辑。
- en: '![](img/B20960_10_01.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_10_01.png)'
- en: 'Figure 10.1: A creative CLI option for a tool'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：一个工具的创意 CLI 选项
- en: In an enterprise project, code has to go through numerous quality gates before
    it can be merged. In this chapter, we will cover **Continuous Integration** (**CI**)
    pipelines leveraging GitHub flow and CircleCI, which help teams achieve frequent,
    reliable, high-quality, and flexible releases.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业项目中，代码在合并之前必须通过多个质量关卡。在本章中，我们将介绍利用 GitHub 流和 CircleCI 的 **持续集成**（**CI**）管道，这些管道有助于团队实现频繁、可靠、高质量和灵活的发布。
- en: Frequent and reliable releases are only possible if we have a set of automated
    tests that can quickly verify the correctness of our code for us. Automated testing
    is critical to ensure your changes don’t introduce regressions. So, we will go
    over the importance of writing unit tests and **end-to-end** (**e2e**) tests with
    Cypress.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一套可以快速验证我们代码正确性的自动化测试，那么频繁且可靠的发布才成为可能。自动化测试对于确保你的更改不会引入回归至关重要。因此，我们将讨论编写单元测试和
    Cypress 的 **端到端**（**e2e**）测试的重要性。
- en: To move fast without breaking things, we need to implement **Continuous Deployment**
    (**CD**) using DevOps best practices such as **Infrastructure as Code** (**IaC**),
    so we can verify the correctness of our running code more often.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速推进而不破坏事物，我们需要通过 DevOps 最佳实践，如 **基础设施即代码**（**IaC**）来实现 **持续部署**（**CD**），这样我们就可以更频繁地验证我们运行中的代码的正确性。
- en: In this chapter, we will cover deploying Angular apps using CLI tools, then
    go over a Docker-based approach to implement IaC that can be run on most CI services
    and cloud providers, allowing you to achieve repeatable builds and deployments
    from any CI environment to any cloud provider. Working with flexible tools, you
    will avoid overspecializing in one service and keep your configuration management
    skills relevant across different CI services.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍使用 CLI 工具部署 Angular 应用，然后讨论基于 Docker 的方法来实现 IaC，该方法可以在大多数 CI 服务和云提供商上运行，允许你从任何
    CI 环境到任何云提供商实现可重复的构建和部署。使用灵活的工具，你可以避免在单一服务上过度专业化，并保持你的配置管理技能在不同 CI 服务中相关。
- en: This book leverages CircleCI as the CI server. Other notable CI servers are
    Jenkins, Azure DevOps, and the built-in mechanisms within GitLab and GitHub.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用 CircleCI 作为 CI 服务器。其他值得注意的 CI 服务器包括 Jenkins、Azure DevOps 以及 GitLab 和 GitHub
    内置的机制。
- en: 'This chapter covers:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖：
- en: Automated testing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试
- en: Continuous integration
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成
- en: Deploying to the cloud
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到云端
- en: DevOps
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps
- en: Containerizing web apps using Docker
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 容器化 Web 应用
- en: Working with containers in the cloud
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云端使用容器
- en: Continuous deployment
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续部署
- en: Code coverage reports
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码覆盖率报告
- en: Technical requirements
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following software is required to follow along with this chapter:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章内容，以下软件是必需的：
- en: Docker Desktop Community version 4+
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Desktop 社区版 4+
- en: Docker Engine CE version 24+
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 引擎 CE 版本 24+
- en: CircleCI account
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CircleCI 账户
- en: Vercel account
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vercel 账户
- en: Firebase account
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase 账户
- en: Coveralls account
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Coveralls 账户
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the repositories linked in the following list. The repository contains the final
    and completed state of the code. Follow the instructions below to find out how
    to verify your progress as you go through the sections of this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 书中示例代码的最新版本可以在以下链接的GitHub仓库中找到：[链接列表](#)。该仓库包含代码的最终和完成状态。按照以下说明进行操作，以了解如何在阅读本章各节时验证您的进度。
- en: 'For *Chapter 10*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**第10章**：
- en: Clone the repositories [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
    and [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆以下仓库：[https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
    和 [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)。
- en: Execute `npm install` on the root folder to install dependencies.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下执行`npm install`以安装依赖项。
- en: '`package.json` contains builds scripts.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`包含构建脚本。'
- en: Note that the `.circleci` folder contains extra YAML files.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`.circleci`文件夹包含额外的YAML文件。
- en: 'For **local-weather-app**:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**local-weather-app**：
- en: '`.circleci/config.stage4.yml` represents a simple CI pipeline.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.circleci/config.stage4.yml`代表一个简单的CI管道。'
- en: '`.circleci/config.stage9.yml` adds CD with target deployment to Vercel.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.circleci/config.stage9.yml`添加了CD，目标部署到Vercel。'
- en: '`.circleci/config.yml` shows an advanced pipeline with parallel builds and
    automated Cypress tests.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.circleci/config.yml`显示了一个具有并行构建和自动化Cypress测试的高级管道。'
- en: 'For **lemon-mart**:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**lemon-mart**：
- en: '`.circleci/config.stage9.yml` adds CD with target deployment to Vercel.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.circleci/config.stage9.yml`添加了CD，目标部署到Vercel。'
- en: '`.circleci/config.docker-integration.yml` demonstrates a container within a
    container setup with multi-stage Dockerfiles and an AWS ECS Fargate deployment.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.circleci/config.docker-integration.yml`演示了使用多阶段Dockerfile和AWS ECS Fargate部署的容器内容器设置。'
- en: '`.circleci/config.yml` shows an advanced pipeline with parallel builds and
    automated Cypress tests.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.circleci/config.yml`显示了一个具有并行构建和自动化Cypress测试的高级管道。'
- en: Beware that the source code provided in the book and the version on GitHub will
    likely differ. Cloud services are ever-evolving and changing. If you find errors
    or have questions, please create an issue or submit a pull request on GitHub.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，书中提供的源代码和GitHub上的版本可能会不同。云服务一直在不断发展和变化。如果您发现错误或有疑问，请创建GitHub上的问题或提交拉取请求。
- en: First, let’s understand why automated testing is critical to delivering quality
    solutions via CI/CD pipelines.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解为什么自动化测试对于通过CI/CD管道交付高质量解决方案至关重要。
- en: Automated testing
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试
- en: As developers, we integrate code from various sources into our solutions. This
    can be from coffee-fueled, long, and tiring code sessions, a copy-pasted StackOverflow
    answer, a snippet from a blog post, an npm package, or a major library like Angular.
    We are expected to deliver quality results within the confines of an estimate
    we threw out there. In these conditions, bugs inevitably end up in our code. When
    deadlines, ambition, or ill-fated architectural decisions intersect with the regular
    cadence of coding, things only get worse.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们将来自各种来源的代码集成到我们的解决方案中。这可能是来自充满咖啡、漫长且疲惫的编码会话，StackOverflow上的复制粘贴答案，博客文章的片段，npm包，或者像Angular这样的主要库。我们被期望在估算的时间内交付高质量的结果。在这些条件下，错误不可避免地会出现在我们的代码中。当截止日期、雄心壮志或不幸的架构决策与常规的编码节奏相交时，事情只会变得更糟。
- en: Automated tests ensure that the code we write is correct and it stays correct.
    We rely on CI/CD pipelines for repeatable processes that are not prone to human
    error, but the pipeline is only as good as the quality of the automated tests
    we write.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试确保我们编写的代码是正确的，并且保持正确。我们依赖于CI/CD管道进行可重复的过程，这些过程不易受到人为错误的影响，但管道的质量取决于我们编写的自动化测试的质量。
- en: 'Angular has two main categories of tests, unit and e2e tests. Unit tests are
    meant to be fast and easy to create and execute, and e2e tests are slower and
    more expensive. However, there’s a problem: Angular unit tests are not unit tests.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Angular有两个主要的测试类别，单元测试和端到端测试。单元测试旨在快速创建和执行，而端到端测试则较慢且成本更高。然而，存在一个问题：Angular的单元测试并不是真正的单元测试。
- en: To understand why, we need a deep dive into unit testing fundamentals to familiarize
    you with the benefits of test-driven development and cover principles like FIRST
    and SOLID.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解原因，我们需要深入了解单元测试基础知识，以便您熟悉测试驱动开发的好处，并涵盖像FIRST和SOLID这样的原则。
- en: Unit testing
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing is crucial to ensure that the behavior of your application doesn’t
    unintentionally change over time. Unit tests will enable you and your team to
    continue making changes to your application without introducing changes to previously
    verified functionality. Developers write unit tests, where each test is scoped
    to test only the code in the **Function Under Test** (**FUT**) or **Class Under
    Test** (**CUT**). Unit tests should be plentiful, automated, and fast. You should
    write unit tests alongside the original code. If they are separated from the implementation,
    even by a day or two, you will start forgetting the details of your code. Because
    of that, you may forget to write tests for potential edge cases.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试对于确保你的应用程序的行为不会无意中随时间改变至关重要。单元测试将使你和你的团队能够继续对你的应用程序进行更改，而不会引入先前已验证的功能的改变。开发者编写单元测试，其中每个测试的范围仅限于测试**待测试函数**（**FUT**）或**待测试类**（**CUT**）中的代码。单元测试应该很多，自动化，并且快速。你应该与原始代码一起编写单元测试。如果它们与实现分离，即使是一两天，你也会开始忘记代码的细节。正因为如此，你可能会忘记为潜在的边缘情况编写测试。
- en: 'Unit tests should adhere to the FIRST principle:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应遵循FIRST原则：
- en: '**F**ast'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速**'
- en: '**I**solated'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**'
- en: '**R**epeatable'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重复**'
- en: '**S**elf-verifying'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自我验证**'
- en: '**T**imely'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**及时**'
- en: A unit test should be fast, taking only milliseconds to run, so we can have
    thousands of them running in just a few minutes. For fast tests to be possible,
    a unit test should be isolated. It shouldn’t talk to a database, make requests
    over the network, or interact with the DOM. Isolated tests are going to be repeatable
    so that every run of the test returns the same result. Predictability means we
    can assert the correctness of a test without relying on any outside environment,
    which makes our tests self-verifying. As mentioned earlier, you should write unit
    tests promptly; otherwise, you lose the benefits of writing unit tests.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该是快速的，只需毫秒即可运行，这样我们就可以在几分钟内运行数千个测试。为了实现快速测试，单元测试应该是隔离的。它不应该与数据库通信，通过网络进行请求，或与DOM交互。隔离的测试将是可重复的，这样每次测试运行都会返回相同的结果。可预测性意味着我们可以断言测试的正确性，而不依赖于任何外部环境，这使得我们的测试可以自我验证。如前所述，你应该及时编写单元测试；否则，你会失去编写单元测试的好处。
- en: It is possible to adhere to the FIRST principle if your tests focus only on
    a single FUT/CUT. But what about other classes, services, or parameters we must
    pass into the FUT/CUT? A unit test can isolate the behavior of the FUT/CUT by
    leveraging test doubles. A test double allows us to control outside dependencies,
    so instead of injecting an `HttpService` to your component, you may inject a fake
    or mocked `HttpService`. Using test doubles, we can control the effects of outside
    dependencies and create fast and repeatable tests.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的测试只关注单个FUT/CUT，那么你可以坚持FIRST原则。但其他类、服务或我们必须传递给FUT/CUT的参数怎么办？单元测试可以通过利用测试替代表示FUT/CUT的行为。测试替代表示允许我们控制外部依赖，所以你可能会向你的组件注入一个假的或模拟的`HttpService`。使用测试替代表示，我们可以控制外部依赖的影响，并创建快速且可重复的测试。
- en: How much testing is enough testing? You should have at least as much test code
    as production code. If you don’t, then you’re nowhere near writing enough tests.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 多少测试才算足够？你应该至少有与生产代码一样多的测试代码。如果没有，那么你离编写足够的测试还远着呢。
- en: See the *Further reading* section for literature going back 20+ years on this.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*进一步阅读*部分，了解20多年前的文献。
- en: 'Unit tests aren’t the only kind of tests you can create, but they are by far
    the kind you should create the most of. Consider the three kinds of tests you
    can create: unit, integration, and UI.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试不是你可以创建的唯一类型的测试，但它们是你应该创建最多的类型。考虑你可以创建的三种测试类型：单元、集成和UI。
- en: As we’ve said, unit tests only focus on one FUT/CUT at a time. Integration tests
    test the integration of various components so that they can include database calls,
    network requests, and interaction with the DOM. Due to their nature, integration
    tests are slow to run and must be frequently maintained. Increases in runtime
    and maintenance mean that integration tests are more expensive than unit tests
    over time. UI tests test the application as if a user were using it, filling in
    fields, clicking buttons, and observing the expected outcome.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，单元测试一次只关注一个FUT/CUT。集成测试测试各种组件的集成，以便它们可以包括数据库调用、网络请求以及与DOM的交互。由于它们的性质，集成测试运行速度较慢，并且必须经常维护。运行时间和维护的增加意味着随着时间的推移，集成测试比单元测试更昂贵。UI测试就像用户在使用应用程序一样测试应用程序，填写字段、点击按钮并观察预期的结果。
- en: You may imagine that these tests are the slowest and most fragile kind of tests.
    The UI of an application changes frequently, and it is very tough to create repeatable
    tests with UI testing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想象这些测试是最慢且最脆弱的测试类型。应用程序的UI经常变化，使用UI测试创建可重复的测试非常困难。
- en: We can leverage integration and UI testing to create acceptance tests. Acceptance
    tests are written to automate the business acceptance of our functionality. Angular’s
    e2e tests are a way to create acceptance tests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用集成和UI测试来创建验收测试。验收测试是为了自动化我们的功能接受而编写的。Angular的e2e测试是创建验收测试的一种方式。
- en: 'We can visualize the pros and cons of the three major classes of automated
    testing with Mike Cohn’s testing pyramid, shown as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用Mike Cohn的测试金字塔来可视化自动化测试的三大类别的优缺点，如下所示：
- en: '![A picture containing text, screenshot, font, design  Description automatically
    generated](img/B20960_10_02.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、设计的图片，自动生成描述](img/B20960_10_02.png)'
- en: 'Figure 10.2: Mike Cohn’s testing pyramid'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：Mike Cohn的测试金字塔
- en: The testing pyramid effectively summarizes the relative amount of tests of each
    kind we should create for our applications while considering their speed and cost.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔有效地总结了在考虑速度和成本的情况下，我们应该为我们的应用程序创建的每种类型的测试的相对数量。
- en: Given the description and expectations of unit tests, you can now begin understanding
    why **Angular unit tests are not really unit tests**. As I explained in the *Component
    architecture* section of *Chapter 1*, *Angular’s Architecture and Concepts*, an
    Angular component consists of a component class and a template. To truly test
    a component, we must interact with the DOM. This is why Angular tests must utilize
    `TestBed` to execute. Further, the dependency injection can be very cumbersome
    to configure and mock. Ultimately, `TestBed` is slow and fragile compared to true
    unit tests.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 根据单元测试的描述和预期，你现在可以开始理解为什么**Angular单元测试实际上并不是真正的单元测试**。正如我在第一章“组件架构”部分中解释的，“Angular的架构和概念”，一个Angular组件由一个组件类和一个模板组成。要真正测试一个组件，我们必须与DOM交互。这就是为什么Angular测试必须利用
    `TestBed` 来执行。此外，依赖注入的配置和模拟可能会非常繁琐。最终，与真正的单元测试相比，`TestBed` 比较慢且脆弱。
- en: Consider using Spectator to simplify your Angular tests. Spectator aims to help
    you get rid of all the boilerplate grunt work, focusing on readable and streamlined
    unit tests.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用Spectator来简化你的Angular测试。Spectator旨在帮助你摆脱所有样板式的繁琐工作，专注于可读性和流畅的单元测试。
- en: More info can be found at [https://github.com/ngneat/spectator](https://github.com/ngneat/spectator).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参阅 [https://github.com/ngneat/spectator](https://github.com/ngneat/spectator)。
- en: Standalone components are much easier to configure because they define their
    dependencies, and we no longer need to introduce modules to `TestBed`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 独立组件配置起来要容易得多，因为它们定义了自己的依赖关系，我们不再需要向 `TestBed` 引入模块。
- en: What does all this mean for Angular? Within this reality, unit testing a component
    is a waste of time. You should extract all business logic into services and functions
    and test those thoroughly. Hopefully, future updates to the Angular unit testing
    setup will change this situation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这对Angular意味着什么？在这个现实情况下，对组件进行单元测试是浪费时间。你应该将所有业务逻辑提取到服务和函数中，并彻底测试它们。希望Angular单元测试设置的将来更新能改变这种情况。
- en: Cypress component tests are a great way to integration test individual components’
    functionality. Follow the instructions in the next section to set Cypress up for
    your project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress组件测试是集成测试单个组件功能的好方法。按照下一节的说明设置Cypress以适应你的项目。
- en: More information about component testing is at [https://docs.cypress.io/guides/component-testing/angular/overview](https://docs.cypress.io/guides/component-testing/angular/overview).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于组件测试的更多信息请参阅 [https://docs.cypress.io/guides/component-testing/angular/overview](https://docs.cypress.io/guides/component-testing/angular/overview)。
- en: 'Beginning with Angular 17.1, you can swap out the Karma test runner with the
    modern **Web Test Runner**. You can set it up with the following instructions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从Angular 17.1开始，你可以用现代的**Web Test Runner**替换Karma测试运行器。你可以按照以下说明进行设置：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Update `angular.json` with:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令更新 `angular.json`：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can read more at [https://modern-web.dev/docs/test-runner/overview](https://modern-web.dev/docs/test-runner/overview).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以阅读更多内容 [https://modern-web.dev/docs/test-runner/overview](https://modern-web.dev/docs/test-runner/overview)。
- en: To test UI and template logic, Angular e2e tests will deliver the best bang
    for the buck, and now you can configure Cypress as the default e2e provider for
    your application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试UI和模板逻辑，Angular e2e测试将提供最佳性价比，现在你可以将Cypress配置为应用程序的默认e2e提供者。
- en: Cypress e2e tests
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cypress端到端测试
- en: 'While unit tests focus on isolating the CUT, e2e tests are about integration
    testing. I highly recommend that you configure Cypress as your e2e provider by
    executing:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当单元测试专注于隔离CUT时，端到端测试则是关于集成测试。我强烈建议你通过执行以下命令将Cypress配置为你的端到端提供者：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can read more about the Cypress integration at [https://www.npmjs.com/package/@cypress/schematic](https://www.npmjs.com/package/@cypress/schematic).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.npmjs.com/package/@cypress/schematic](https://www.npmjs.com/package/@cypress/schematic)了解更多关于Cypress集成的信息。
- en: Cypress allows you to easily create tests for your modern web applications,
    debug them visually, and automatically run them in your CI builds. You can read
    more about Cypress at [https://www.cypress.io/](https://www.cypress.io/).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress允许你轻松创建现代Web应用程序的测试，可视化调试它们，并在CI构建中自动运行它们。你可以在[https://www.cypress.io/](https://www.cypress.io/)了解更多关于Cypress的信息。
- en: e2e tests allow you to write **Automated Acceptance Tests** (**AATs**) from
    the perspective of a user interacting with your application in a browser. Cypress
    tests are easy to create and run. By using the `data-testid` attribute on HTML
    components, you can make them less fragile.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试允许你从用户在浏览器中与应用程序交互的角度编写**自动化验收测试**（**AAT**）。Cypress测试易于创建和运行。通过在HTML组件上使用`data-testid`属性，你可以使它们更稳定。
- en: You can find sample Cypress tests for **local-weather-app** and **lemon-mart**
    under the `cypress` folder.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`cypress`文件夹下找到**local-weather-app**和**lemon-mart**的示例Cypress测试。
- en: 'You can execute the tests in development by executing:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行以下命令在开发中运行测试：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For CI, you can use the following commands:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CI，你可以使用以下命令：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In `local-weather-app`, check out the `cypress/e2e/app.cy.ts` file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`local-weather-app`中，查看`cypress/e2e/app.cy.ts`文件：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `cypress/support/commands.ts` `file`, I implemented a helper function
    called `byTestId`, which finds an HTML element containing the `data-testid` attribute
    with the given name. In this case, `cy.byTestId("title")` will find the following
    element:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cypress/support/commands.ts` `文件`中，我实现了一个名为`byTestId`的辅助函数，该函数可以找到具有给定名称的`data-testid`属性的HTML元素。在这种情况下，`cy.byTestId("title")`将找到以下元素：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The test will work even if the element moves around on the page. Using test
    IDs makes it easy and convenient to write more dependable tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 即使元素在页面上移动，测试也能正常工作。使用测试ID可以轻松方便地编写更可靠的测试。
- en: Building robust and maintainable e2e code requires some additional concepts
    like Page Objects. You can learn more about Page Objects at [https://docs.cypress.io/guides/end-to-end-testing/protractor-to-cypress#Using-Page-Objects](https://docs.cypress.io/guides/end-to-end-testing/protractor-to-cypress#Using-Page-Objects)
    and other best practices at [https://docs.cypress.io/guides/references/best-practices](https://docs.cypress.io/guides/references/best-practices).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 构建健壮且可维护的端到端代码需要一些额外的概念，如页面对象。你可以在[https://docs.cypress.io/guides/end-to-end-testing/protractor-to-cypress#Using-Page-Objects](https://docs.cypress.io/guides/end-to-end-testing/protractor-to-cypress#Using-Page-Objects)和其他最佳实践[https://docs.cypress.io/guides/references/best-practices](https://docs.cypress.io/guides/references/best-practices)中了解更多关于页面对象的信息。
- en: Next, let’s set up CI to ensure that our tests always run before we deploy the
    app to production.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们设置CI以确保在将应用程序部署到生产之前，我们的测试总是运行。
- en: Continuous integration
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: Before pushing your code to production, you should enable CI. This simple tool
    helps ensure we don’t ship broken code to production by executing automated tasks,
    including the execution of tests, every time we make changes to our code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在将代码推送到生产之前，你应该启用CI。这个简单的工具帮助我们确保在每次更改代码时执行自动化任务，包括测试执行，从而确保我们不将损坏的代码推送到生产。
- en: CircleCI
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CircleCI
- en: '**CircleCI** makes it easy to get started, with a free tier and excellent documentation
    for beginners and pros alike. If you have unique enterprise needs, CircleCI can
    be brought on-premises, behind corporate firewalls, or as a private deployment
    in the cloud.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**CircleCI**使入门变得容易，提供免费层和针对初学者和专业人士的优秀文档。如果你有独特的企业需求，CircleCI可以部署在企业内部，在防火墙后面，或在云中作为私有部署。'
- en: 'CircleCI has pre-baked build environments for the virtual configuration of
    free setups, but it can also run builds using Docker containers, making it a solution
    that scales to the user’s skills and needs:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI为免费设置提供了预配置的构建环境，但它也可以使用Docker容器运行构建，使其成为一个可以扩展到用户技能和需求解决方案：
- en: Create a CircleCI account at [https://circleci.com/](https://circleci.com/).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://circleci.com/](https://circleci.com/)创建一个CircleCI账户。
- en: Navigate to **Projects** to add a new project.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**项目**以添加新项目。
- en: Search for `local-weather-app` and click on **Set Up Project**.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索`local-weather-app`并点击**设置项目**。
- en: Follow the on-screen prompts to create a sample `.yml` file. Hello World or
    Node.js works, but you will replace the content anyway.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照屏幕提示创建一个示例 `.yml` 文件。Hello World 或 Node.js 都可以，但您最终会替换内容。
- en: This section uses the **local-weather-app** repo. The `config.yml` file for
    this section is named `.circleci/config.stage4.yml`.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本节使用 **local-weather-app** 仓库。本节的 `config.yml` 文件命名为 `.circleci/config.stage4.yml`。
- en: 'Copy the following `.yml` content into the file:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `.yml` 内容复制到文件中：
- en: '[PRE7]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Select **Commit** and **Run**.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**提交**和**运行**。
- en: CircleCI should run on a new branch.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CircleCI 应该在新的分支上运行。
- en: If everything goes well, you should have a passing, *green* build. If not, you
    will see a failed, *red* build.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该有一个通过，*绿色*的构建。如果不顺利，您将看到一个失败的，*红色*的构建。
- en: When you have a green build, you can leverage CircleCI to enforce the execution
    of your automated pipeline with every code push. GitHub flow allows us to control
    how code flows into our repositories.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有一个绿色构建时，您可以使用 CircleCI 来强制执行每次代码推送时自动管道的执行。GitHub 流程允许我们控制代码如何流入我们的仓库。
- en: GitHub flow
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub 流
- en: The main reason we’re developing software is to deliver value. In automating
    the way we deliver software, we are creating a value delivery stream. It is easy
    to deliver broken software; however, to reliably deliver value, each change to
    the code base should flow through a stream of checks and balances.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发软件的主要原因是为了交付价值。在自动化我们交付软件的方式时，我们正在创建一个价值交付流。交付有缺陷的软件很容易；然而，为了可靠地交付价值，代码库的每个更改都应该通过一系列的检查和平衡。
- en: With control gates, we can enforce standards, make our quality control process
    repeatable for every team member, and have the ability to isolate changes. If
    something goes wrong or the work doesn’t live up to your standards, you can easily
    discard the proposed changes and restart.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用控制门，我们可以强制执行标准，使我们的质量控制流程对每个团队成员都是可重复的，并且能够隔离更改。如果出现问题或工作不符合您的标准，您可以轻松地丢弃提议的更改并重新开始。
- en: GitHub flow is an essential part of defining a value delivery stream and implementing
    control gates. As GitHub puts it, “*GitHub flow is a lightweight, branch-based
    workflow that supports teams and projects where deployments are made regularly*.”
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 流程是定义价值交付流和实施控制门的关键部分。正如 GitHub 所说，“*GitHub 流是一个轻量级、基于分支的工作流程，支持定期进行部署的团队和项目*。”
- en: 'GitHub flow consists of six steps, as shown in the following graphic from GitHub:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 流程包括六个步骤，如下所示，这是来自 GitHub 的以下图形：
- en: '![](img/B20960_10_03.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_10_03.png)'
- en: 'Figure 10.3: GitHub flow diagram'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3：GitHub 流程图
- en: '**Branch** – always add new code for a bug or a feature in a new branch'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分支** – 总是在新分支中添加用于修复错误或添加新功能的代码'
- en: '**Commit** – make multiple commits to your branch'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**提交** – 对您的分支进行多次提交'
- en: '**Create a pull request** – signal the readiness of your work to your team
    members and view CI results in a pull request'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建拉取请求** – 向团队成员发出工作准备就绪的信号，并在拉取请求中查看 CI 结果'
- en: '**Discuss and review** – request a review of your code changes, address general
    or line-level comments, and make necessary modifications'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**讨论和审查** – 请求对您的代码更改进行审查，处理一般性或行级评论，并进行必要的修改'
- en: '**Deploy** – optionally test your code on a test server or staging server with
    the ability to roll back to the main branch'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部署** – 可选地在测试服务器或预发布服务器上测试您的代码，并具有回滚到主分支的能力'
- en: '**Merge** – apply your changes to the main branch'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**合并** – 将您的更改应用到主分支'
- en: You can use GitHub flow to ensure that only high-quality code ends up in the
    main branch. A solid foundation sets other team members up for success when making
    changes. You must restrict push access to the main branch to enforce GitHub flow.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 GitHub 流程来确保只有高质量的代码最终进入主分支。坚实的基础为其他团队成员在做出更改时提供了成功的基础。您必须限制对主分支的推送访问，以强制执行
    GitHub 流程。
- en: 'Let’s enable branch protection for the main branch:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为主分支启用分支保护：
- en: Navigate to the GitHub **Settings** tab for your project.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到您项目的 GitHub **设置**标签页。
- en: Select **Branches** from the left navigation pane.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧导航窗格中选择**分支**。
- en: If a rule exists for your main branch, click the **Edit** or **Add rule** button.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果主分支存在规则，请点击**编辑**或**添加规则**按钮。
- en: Enter `main` as the branch name pattern.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将分支名称模式输入为`main`。
- en: 'Enable the following options:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用以下选项：
- en: Require a pull request before merging.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在合并前要求拉取请求。
- en: Require approvals from at least one peer.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少需要一位同事的批准。
- en: Dismiss stale pull request approvals.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 撤销过时的拉取请求批准。
- en: Require status checks to pass before merging.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在合并之前需要确保状态检查通过。
- en: Require branches to be up to date before merging.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在合并之前需要确保分支是最新的。
- en: Require linear history.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要线性历史记录。
- en: 'Search for `CircleCI` and select the CI job that must succeed, in this case:
    `run_build_and_test`'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索`CircleCI`并选择必须成功的CI作业，在本例中为：`run_build_and_test`
- en: After you’ve saved your changes, you should see your new rule on the **Branches**
    page as shown:![A screenshot of a computer  Description automatically generated](img/B20960_10_04.png)
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的更改后，你应该能在**分支**页面上看到你的新规则，如下所示：![计算机屏幕截图  自动生成的描述](img/B20960_10_04.png)
- en: 'Figure 10.4: GitHub Branches'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.4：GitHub分支
- en: 'You are no longer able to commit code to your main branch directly. To commit
    code, you first need to create a branch from the main branch, commit your changes
    to the new branch, and create a pull request using the new branch when you’re
    ready. If you’re unfamiliar with `git` commands, you can use GitHub Desktop to
    assist you with these operations. See the handy **Branch** menu in GitHub Desktop
    here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在无法直接向主分支提交代码。要提交代码，你首先需要从主分支创建一个分支，将你的更改提交到新分支，并在准备好时使用新分支创建一个拉取请求。如果你不熟悉`git`命令，可以使用GitHub
    Desktop来帮助你进行这些操作。请参考GitHub Desktop中的便捷**分支**菜单：
- en: '![](img/B20960_10_05.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_10_05.png)'
- en: 'Figure 10.5: GitHub Desktop Branch menu'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：GitHub Desktop分支菜单
- en: 'After creating a pull request, you can now observe checks running against your
    branch. Now that we have CircleCI configured, if everything went well, you should
    be able to merge a pull request, as shown:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建拉取请求后，你现在可以观察针对你的分支运行的检查。现在我们已经配置了CircleCI，如果一切顺利，你应该能够合并拉取请求，如下所示：
- en: '![](img/B20960_10_06.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_10_06.png)'
- en: 'Figure 10.6: GitHub.com status checks passing'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：GitHub.com状态检查通过
- en: When the checks fail, you are forced to fix any issues before you can merge
    the new code. Also, you may run into merge conflicts if a team member merged to
    the main branch while you were working on your branch. In this case, you may use
    GitHub Desktop’s **Update from master** feature for your branch to catch up with
    the latest main branch.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查失败时，你必须修复任何问题后才能合并新的代码。此外，如果你在处理你的分支时团队成员合并到了主分支，你可能会遇到合并冲突。在这种情况下，你可以使用GitHub
    Desktop的**从主分支更新**功能来更新你的分支，以赶上最新的主分支。
- en: 'Observe the state of a failing pull request in the following image:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下图像中失败的拉取请求的状态：
- en: '![](img/B20960_10_07.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_10_07.png)'
- en: 'Figure 10.7: GitHub.com status checks failing'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：GitHub.com状态检查失败
- en: Note that I have an additional check, DeepScan, which runs additional tests
    against my code base. You can register your repository with DeepScan at [https://deepscan.io](https://deepscan.io).
    Later in the chapter, I demonstrate how you can enforce unit test code coverage
    using Coveralls.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我还有一个额外的检查，DeepScan，它会对我的代码库运行额外的测试。你可以在[https://deepscan.io](https://deepscan.io)上注册你的仓库。在章节的后面部分，我将演示如何使用Coveralls强制执行单元测试覆盖率。
- en: For more information, refer to [https://guides.github.com/introduction/flow](https://guides.github.com/introduction/flow).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅[https://guides.github.com/introduction/flow](https://guides.github.com/introduction/flow)。
- en: Now that we have ensured that our automated checks are being enforced, we can
    be reasonably sure that we won’t push a broken app to production. Next, let’s
    learn how we can deploy our app to the cloud.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确保了我们的自动化检查正在被强制执行，我们可以合理地确信我们不会推送一个损坏的应用到生产环境。接下来，让我们学习如何将我们的应用部署到云端。
- en: Deploying to the cloud
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到云端
- en: If delivering something to production is difficult from a coding perspective,
    it is very complicated to do it right from an infrastructure perspective. Deploying
    solutions in the full-fledged versions of Azure, AWS, and Google Cloud is complicated.
    To deliver quick results, we can leverage cloud services that can serve the `dist`
    folder of our Angular app within minutes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从编码角度来看交付到生产环境有困难，那么从基础设施角度来看正确地完成它将非常复杂。在Azure、AWS和Google Cloud的完整版本中部署解决方案是复杂的。为了快速得到结果，我们可以利用可以在几分钟内为我们Angular应用的`dist`文件夹提供服务的云服务。
- en: One such service is Vercel, and another is Firebase, which can leverage the
    `ng deploy` command.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一项服务是Vercel，另一项是Firebase，可以利用`ng deploy`命令。
- en: Vercel
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vercel
- en: Vercel, [https://vercel.com](https://vercel.com), is a multi-cloud service that
    enables real-time global deployments of applications directly from the CLI. Vercel
    works with static files, Node.js, PHP, Go applications, and any custom stack of
    software you’re willing to write a custom builder for, making it quite straightforward.
    Vercel has a free tier that you can use to deploy the `dist` folder of your Angular
    applications very quickly.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Vercel，[https://vercel.com](https://vercel.com)，是一个多云服务，它使您能够从CLI直接进行应用的实时全球部署。Vercel与静态文件、Node.js、PHP、Go应用以及您愿意为其编写自定义构建器的任何自定义软件栈协同工作，使其非常简单。Vercel有一个免费层，您可以使用它快速部署Angular应用的`dist`文件夹。
- en: 'Install the `vercel` package to your project and run the `login` command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将`vercel`包安装到您的项目中，并运行`login`命令：
- en: '[PRE8]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Follow the on-screen prompts to complete the login process. Now, let’s configure
    the `publish` script.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 按照屏幕上的提示完成登录过程。现在，让我们配置`publish`脚本。
- en: Deploying static files
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署静态文件
- en: After you build an Angular project, the build output resides in the `dist` folder.
    The files in this folder are considered static files; all a web server needs to
    do is deliver these files to a client browser, unmodified, and then the browser
    executes your code dynamically.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在您构建Angular项目后，构建输出将驻留在`dist`文件夹中。这个文件夹中的文件被认为是静态文件；Web服务器需要做的只是将这些文件未修改地传递给客户端浏览器，然后浏览器动态执行您的代码。
- en: This means that any web server can serve up your Angular project. However, `vercel`
    makes it exceedingly easy and free to pull off.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任何Web服务器都可以提供您的Angular项目。然而，`vercel`使得这一过程变得极其简单且免费。
- en: This section uses the **local-weather-app** repository.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本节使用**local-weather-app**仓库。
- en: 'Let’s begin deploying your Angular app using Vercel’s static file hosting capabilities:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用Vercel的静态文件托管能力部署您的Angular应用：
- en: 'Add two new scripts to `package.json`, as shown:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`package.json`中添加两个新的脚本，如下所示：
- en: '[PRE9]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Execute `npm run vercel:publish`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm run vercel:publish`。
- en: Follow the on-screen commands to accept first-use settings.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照屏幕上的命令接受首次使用设置。
- en: 'In the terminal window, observe that the Angular project is built first and
    then uploaded to `vercel`:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在终端窗口中，观察Angular项目首先构建然后上传到`vercel`：
- en: '[PRE10]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Follow the URL displayed on the screen to see that your app has been successfully
    deployed.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照屏幕上显示的URL查看，您的应用已成功部署。
- en: And you’re done! Congratulations, your Angular app is live on the internet!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！恭喜，您的Angular应用已上线互联网！
- en: Firebase
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Firebase
- en: Firebase, [https://firebase.google.com/](https://firebase.google.com/), is an
    app development platform that helps you build and grow apps and games users love.
    It is backed by Google and trusted by millions of businesses around the world.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase，[https://firebase.google.com/](https://firebase.google.com/)，是一个帮助您构建和增长用户喜爱的应用和游戏的平台。它由谷歌支持，并被全球数百万家企业所信赖。
- en: In the Firebase authentication recipe section of *Chapter 6*, *Implementing
    Role-Based Navigation*, you created a Firebase app for LemonMart and deployed
    your app using **firebase deploy**. We will leverage the account you created to
    deploy LemonMart to Firebase hosting using the new `ng` `deploy` command instead.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在第六章“实现基于角色的导航”的Firebase身份验证配方部分，您为LemonMart创建了一个Firebase应用，并使用**firebase deploy**部署了您的应用。我们将利用您创建的账户，使用新的`ng`
    `deploy`命令将LemonMart部署到Firebase托管。
- en: ng deploy
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ng deploy
- en: '`ng` `deploy` is a new CLI command that helps cloud services offer seamless
    integration with Angular, so you can easily deploy your app to the cloud.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng` `deploy`是一个新的CLI命令，它帮助云服务提供与Angular的无缝集成，因此您可以轻松地将应用部署到云端。'
- en: Now let’s configure the LemonMart project using `@angular/fire`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`@angular/fire`配置LemonMart项目。
- en: This section uses the **lemon-mart** repository.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本节使用**lemon-mart**仓库。
- en: 'Execute the following command and make sure to select `ng` `deploy` -- `hosting`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令，并确保选择`ng` `deploy` -- `hosting`：
- en: '[PRE11]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will create a `deploy` configuration in `angular.json` and add or update
    existing Firebase configuration files.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`angular.json`中创建一个`deploy`配置，并添加或更新现有的Firebase配置文件。
- en: 'For LemonMart, I modified `angular.json` so it would automatically build using
    the Firebase authentication mode:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于LemonMart，我修改了`angular.json`，使其能够自动使用Firebase身份验证模式构建：
- en: '[PRE12]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Firebase configuration is defined under the **Configurations** options,
    and it uses `environment.firebase.ts` to build the app.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase配置定义在**配置**选项下，并使用`environment.firebase.ts`构建应用。
- en: I also modified `firebase.json` to deploy `dist/lemon-mart`, because the repository
    is configured as a multi-project Angular app. However, you shouldn’t need to modify
    the auto-generated files.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command to deploy:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Follow the URL on the screen to see that your app has been successfully deployed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '`ng` `deploy` offers a better integrated and simpler option compared to using
    platform-specific CLI commands. Working with CLI commands is great, but one command
    that works on one machine can easily fail on another. IaC is the only way high-performing
    enterprise teams can deliver high-quality code with speed. However, to get there,
    we first need to understand what DevOps is.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: DevOps
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DevOps is the marriage of development and operations. It is well established
    for development that code repositories like Git track every code change. In operations,
    there has long been a wide variety of techniques to track changes to environments,
    including scripts and various tools that aim to automate the provisioning of operating
    systems and servers.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: How often have you heard the saying, “It works on my machine”? Developers often
    use that line as a joke. Still, it is often the case that software that works
    perfectly well on a test server ends up running into issues on a production server
    due to minor differences in configuration.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we discussed how GitHub flow can enable us to create a value delivery
    stream. We always branch from the main branch before making a change, enforce
    that change to go through our CI pipeline, and, once we’re reasonably sure that
    our code works, merge back to the main branch. See the following diagram:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![A line of dots and lines with a black background  Description automatically
    generated](img/B20960_10_08.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Branching and merging'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Remember, your main branch should always be deployable, and you should frequently
    merge your work with the main branch.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Docker allows us to define the software and the specific configuration parameters
    that our code depends on in a declarative manner using a special file named a
    Dockerfile. Similarly, CircleCI allows us to define the configuration of our CI
    environment in a `config.yml` file. By storing our configuration in files, we
    can check the files alongside our code. We can track changes using Git and enforce
    them to be verified by our CI pipeline.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: By storing the definition of our infrastructure in code, we achieve IaC, we
    also achieve repeatable integration, so no matter what environment we run our
    infrastructure in, we should be able to stand up our full-stack app with a one-line
    command.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'You may remember that in *Chapter 1*, *Angular’s Architecture and Concepts*,
    we covered how TypeScript covers the JavaScript feature gap. Like TypeScript,
    Docker covers the configuration gap, as demonstrated in the following diagram:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a diagram  Description automatically generated](img/B20960_10_09.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Covering the configuration gap'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: By using Docker, we can be reasonably sure that our code, which worked on our
    machine during testing, will work the same way when we ship it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: In summary, DevOps brings operations closer to development, where it is cheaper
    to make changes and resolve issues. So, DevOps is primarily a developer’s responsibility,
    but it is also a way of thinking that the operations team must be willing to support.
    Let’s dive deeper into Docker.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing web apps using Docker
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker, which can be found at [https://docker.io](https://docker.io), is an
    open platform for developing, shipping, and running applications. Docker combines
    a lightweight container virtualization platform with workflows and tooling that
    help manage and deploy applications. The most obvious difference between **Virtual
    Machines** (**VMs**) and Docker containers is that VMs are usually dozens of gigabytes
    in size and require gigabytes of memory, whereas containers take up megabytes
    in terms of disk and memory size requirements. Furthermore, the Docker platform
    abstracts away host **Operating System** (**OS**)-level configuration settings,
    so every piece of configuration that is needed to successfully run an application
    is encoded within a human-readable format.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a Dockerfile
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Dockerfile consists of four main parts:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**FROM** – where we can inherit from Docker’s minimal “scratch” image or a
    pre-existing image'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SETUP** – where we configure software dependencies to our requirements'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COPY** – where we copy our built code into the operating environment'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMD** – where we specify the commands that will bootstrap the operating environment'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrap refers to a set of initial instructions that describe how a program
    loads or starts up.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following visualization of the anatomy of a Dockerfile:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer program  Description automatically generated](img/B20960_10_10.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Anatomy of a Dockerfile'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'A concrete representation of a Dockerfile is demonstrated in the following
    code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can map the `FROM`, `COPY`, and `CMD` parts of the script to the visualization.
    We inherit from the `duluca/minimal-nginx-web-server` image using the `FROM` command.
    Then, we copy the compiled result of our app from our development machine or build
    environment into the image using the `COPY` (or, alternatively, the `ADD`) command.
    Finally, we instruct the container to execute the nginx web server using the `CMD`
    (or, alternatively, the `ENTRYPOINT`) command.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Note that the preceding `Dockerfile` doesn’t have a distinct `SETUP` part. `SETUP`
    doesn’t map to an actual `Dockerfile` command but represents a collection of commands
    you can execute to set up your container. In this case, all the necessary setup
    was done by the base image, so there are no additional commands to run.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Common `Dockerfile` commands are `FROM`, `COPY`, `ADD`, `RUN`, `CMD`, `ENTRYPOINT`,
    `ENV`, and `EXPOSE`. For the full `Dockerfile` reference, refer to [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的 `Dockerfile` 命令有 `FROM`, `COPY`, `ADD`, `RUN`, `CMD`, `ENTRYPOINT`, `ENV`,
    和 `EXPOSE`。关于完整的 `Dockerfile` 参考，请参阅 [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)。
- en: 'The `Dockerfile` describes a new container that inherits from a container named
    `duluca/minimal-nginx-web-server`. This is a container that I published on Docker
    Hub, which inherits from the `nginx:alpine` image, which itself inherits from
    the `alpine` image. The `alpine` image is a minimal Linux operating environment
    that is only 5 MB in size. The `alpine` image itself inherits from `scratch`,
    which is an empty image. See the inheritance hierarchy demonstrated in the following
    diagram:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile` 描述了一个新的容器，它从名为 `duluca/minimal-nginx-web-server` 的容器继承。这是一个我在
    Docker Hub 上发布的容器，它从 `nginx:alpine` 镜像继承，而 `nginx:alpine` 镜像本身又从 `alpine` 镜像继承。`alpine`
    镜像是一个最小化的 Linux 操作环境，大小仅为 5 MB。`alpine` 镜像本身又从 `scratch` 镜像继承，而 `scratch` 镜像是一个空镜像。以下图表展示了继承层次结构：'
- en: '![A screenshot of a computer screen  Description automatically generated](img/B20960_10_11.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B20960_10_11.png)'
- en: 'Figure 10.11: Docker inheritance'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11：Docker 继承
- en: 'The `Dockerfile` then copies the contents of the `dist` folder from your development
    environment into the container’s `www` folder, as shown in the following diagram:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile` 然后将开发环境中的 `dist` 文件夹内容复制到容器的 `www` 文件夹中，如下所示：'
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_10_12.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B20960_10_12.png)'
- en: 'Figure 10.12: Copying code into a containerized web server'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12：将代码复制到容器化的 Web 服务器
- en: 'In this case, the parent image is configured with an `nginx` server to act
    as a web server to serve the content inside the `www` folder. At this point, our
    source code is accessible from the internet but lives inside layers of secure
    environments. Even if our app has a vulnerability of some kind, it would be tough
    for an attacker to harm the systems we are operating on. The following diagram
    demonstrates the layers of security that Docker provides:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，父镜像配置了一个 `nginx` 服务器作为 Web 服务器来服务 `www` 文件夹内的内容。到这一点，我们的源代码可以从互联网上访问，但生活在安全环境的多层中。即使我们的应用程序存在某种漏洞，攻击者也很难伤害我们正在运行的系统。以下图表展示了
    Docker 提供的安全层：
- en: '![A diagram of a software development  Description automatically generated
    with medium confidence](img/B20960_10_13.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![软件开发图表  自动生成的描述](img/B20960_10_13.png)'
- en: 'Figure 10.13: Docker security'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13：Docker 安全
- en: In summary, at the base layer, our host OS, such as Windows or macOS, runs the
    Docker runtime, which will be installed in the next section. The Docker runtime
    can run self-contained Docker images, which the aforementioned Dockerfile defines.
    `duluca/minimal-nginx-web-server` is based on the lightweight Linux operating
    system, Alpine. Alpine is a completely pared-down version of Linux that doesn’t
    come with any GUI, drivers, or even most of the CLI tools you may expect from
    a Linux system. As a result, the OS is only ~5 MB in size. We then inherit from
    the `nginx` image, which installs the web server, which itself is around a few
    megabytes in size. Finally, our custom `nginx` configuration is layered over the
    default image, resulting in a tiny ~7 MB image. The `nginx` server is configured
    to serve the contents of the `/var/www` folder. In the `Dockerfile`, we merely
    copy the contents of the `/dist` folder in our development environment and place
    it into the `/var/www` folder. We will later build and execute this image, which
    will run our `nginx` web server containing the output of our `dist` folder. I
    have published a similar image named `duluca/minimal-node-web-server`, which clocks
    in at ~15 MB.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在基础层，我们的宿主操作系统，例如Windows或macOS，运行Docker运行时，这将在下一节中安装。Docker运行时可以运行自包含的Docker镜像，这些镜像由上述Dockerfile定义。`duluca/minimal-nginx-web-server`基于轻量级的Linux操作系统Alpine。Alpine是Linux的一个完全精简的版本，不包含任何GUI、驱动程序，甚至大多数您可能从Linux系统中期望的CLI工具。因此，该操作系统的大小仅为约5
    MB。然后，我们从`nginx`镜像继承，该镜像安装了网络服务器，其自身大小约为几MB。最后，我们的自定义`nginx`配置覆盖了默认镜像，结果生成一个微小的约7
    MB镜像。`nginx`服务器被配置为服务`/var/www`文件夹的内容。在`Dockerfile`中，我们仅复制我们开发环境中`/dist`文件夹的内容，并将其放置到`/var/www`文件夹中。我们稍后将构建并执行此镜像，该镜像将运行包含我们`dist`文件夹输出的`nginx`网络服务器。我已经发布了一个类似的镜像，名为`duluca/minimal-node-web-server`，其大小约为15
    MB。
- en: '`duluca/minimal-node-web-server` can be more straightforward to work with,
    especially if you’re not familiar with `nginx`. It relies on an `Express.js` server
    to serve static content. Most cloud providers provide concrete examples using
    Node and Express, which can help you narrow down any errors. In addition, `duluca/minimal-node-web-server`
    has HTTPS redirection support baked into it. You can spend a lot of time trying
    to set up an `nginx` proxy to do the same thing when all you need to do is set
    the `ENFORCE_HTTPS` environment variable in your `Dockerfile`. See the following
    sample Dockerfile:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`duluca/minimal-node-web-server`可以更直接地使用，尤其是如果您不熟悉`nginx`。它依赖于一个`Express.js`服务器来服务静态内容。大多数云提供商都提供了使用Node和Express的具体示例，这可以帮助您缩小任何错误的范围。此外，`duluca/minimal-node-web-server`内置了HTTPS重定向支持。您可能会花费大量时间尝试设置一个`nginx`代理来完成相同的事情，而您只需在您的`Dockerfile`中设置`ENFORCE_HTTPS`环境变量即可。请参阅以下示例Dockerfile：'
- en: '[PRE15]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can read more about the options `minimal-node-web-server` provides at `https://github.com/duluca/minimal-node-web-server`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`https://github.com/duluca/minimal-node-web-server`了解更多关于`minimal-node-web-server`提供的选项。
- en: As we’ve now seen, the beauty of Docker is that you can navigate to [https://hub.docker.com](https://hub.docker.com),
    search for `duluca/minimal-nginx-web-server` or `duluca/minimal-node-web-server`,
    read its `Dockerfile`, and trace its origins all the way back to the original
    base image that is the foundation of the web server. I encourage you to vet every
    Docker image you use in this manner to understand what exactly it brings to the
    table for your needs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在所看到的，Docker的美丽之处在于您可以直接导航到[https://hub.docker.com](https://hub.docker.com)，搜索`duluca/minimal-nginx-web-server`或`duluca/minimal-node-web-server`，阅读其`Dockerfile`，并追溯其起源，直至原始的基础镜像，这是网络服务器的基础。我鼓励您以这种方式检查您使用的每个Docker镜像，以了解它究竟为您带来了哪些需求。
- en: You may either find it overkill or that it has features you never knew about
    that can make your life a lot easier.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会觉得它过于强大，或者它具有您从未知晓的功能，这些功能可以使您的生活变得更加轻松。
- en: Note that the parent images should pull a specific tag of `duluca/minimal-nginx-web-server`,
    which is `1-alpine`. Similarly, `duluca/minimal-node-web-server` pulls from `lts-alpine`.
    These evergreen base packages always contain the latest version 1 of `nginx` and
    Alpine or an LTS release of Node. In Docker Hub, I have pipelines to automatically
    update both images when a new base image is published. So, you will get the latest
    bug fixes and security patches whenever you pull these images.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Having an evergreen dependency tree removes the burden on you as the developer
    to hunt down the latest version of a Docker image. Alternatively, if you specify
    a version number, your images will not be subject to any potential breaking changes.
    However, it is better to remember to test your images after a new build than never
    update your image and, potentially, deploy compromised software. After all, the
    web is ever-changing and will not slow down for you to keep your images up to
    date.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Just like npm packages, Docker can bring great convenience and value, but you
    must take care to understand the tools you are working with.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to build and run containers, you must first install the Docker execution
    environment on your computer. You can download Docker Desktop at [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
    Follow the instructions on the screen to complete the installation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Setting up npm scripts for Docker
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s configure some Docker scripts for your Angular apps that you can
    use to automate your container’s building, testing, and publishing. I have developed
    a set of scripts called **npm scripts for Docker** that works on Windows 10 and
    macOS. You can get the latest version of these scripts and automatically configure
    them in your project by executing the following command.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Run the following command on both the **local-weather-app** and **lemon-mart**
    projects now!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the npm scripts for Docker task:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After you execute the `mrm` scripts, we’re ready to take a deep dive into the
    configuration settings using the Local Weather app as an example.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Building and publishing an image to Docker Hub
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, let’s ensure that your project is configured correctly so we can containerize
    it, build an executable image, and publish it to Docker Hub, allowing us to access
    it from any build environment.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: This section uses the **local-weather-app** repository.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to take the following steps:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Sign up for a Docker Hub account at [https://hub.docker.com/](https://hub.docker.com/).
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a public (free) repository for your application.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `package.json`, add or update the `config` property with the following configuration
    properties:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`namespace` will be your Docker Hub username. You will define what your repository
    will be called during creation. An example image `repository` variable should
    look like `duluca/localcast-weather`. The image name is for easy identification
    of your container while using Docker commands such as `docker ps`. I will just
    call mine `localcast-weather`. The `imagePort` property will define which port
    should be used to expose your application from inside the container. Since we
    use port `4200` for development, pick a different one, like `8080`. `internalContainerPort`
    defines the port that your web server is mapped to. This will mostly be port `3000`
    for Node servers and, for `nginx` servers, `80`. Refer to the documentation of
    the base container you’re using.'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s review the Docker scripts added to `package.json` by the `mrm` task from
    earlier. The following section presents an annotated version of the scripts added,
    explaining each entry.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that with `npm` scripts, the `pre` and `post` keywords are used to execute
    helper scripts before or after executing a given script. Scripts are intentionally
    broken into smaller pieces to make them easier to read and maintain.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `build` script is as follows:'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the following `cross-conf-env` command ensures the script executes
    equally well in macOS, Linux, and Windows environments.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`npm run docker:build` will build your Angular application in the `pre` script,
    then build the Docker image using the `docker image build` command, and tag the
    image with a version number in the `post` script.'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In my project, the `pre` command builds my Angular application in `prod` mode
    and runs a test to ensure that I have an optimized build with no failing tests.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'My `pre` command looks like this:'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `tag` script is as follows:'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`npm run docker:tag` will tag an already built Docker image using the version
    number from the `version` property in `package.json` and the latest tag.'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `stop` script is as follows:'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`npm run docker:stop` will stop the image if it’s currently running, so the
    `run` script can execute without errors.'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `run` script is as follows:'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the `run-s` and `run-p` commands ship with the `npm-run-all` package
    to synchronize or parallelize the execution of npm scripts.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`npm run docker:run` will stop if the image is already running, and then run
    the newly built version of the image using the `docker run` command. Note that
    the `imagePort` property is used as the external port of the Docker image, which
    is mapped to the internal port of the image that the Node.js server listens to,
    port `3000`.'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `publish` script is as follows:'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that `docker:tag` adds the latest version tag on the container. When we
    push the latest tags, both tags get pushed simultaneously.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`npm run docker:publish` will publish a built image to the configured repository,
    in this case, Docker Hub, using the `docker image push` command.'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, the versioned image is published, followed by one tagged with `latest`
    in `post`. The `taillogs` script is as follows:'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`npm run docker:taillogs` will display the internal console logs of a running
    Docker instance using the `docker log -f` command, a useful tool for debugging
    your Docker instance.'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `open` script is as follows:'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`npm run docker:open` will wait for 2 seconds, accounting for latency, and
    then launch the browser with the correct URL for your application using the `imagePort`
    property.'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `debug` script is as follows:'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`npm run docker:debug` will build your image and run an instance of it in `pre`,
    open the browser, and then start displaying the internal logs of the container.'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Customize the pre-build script to build your angular app in production mode
    and execute unit tests before building the image:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that `ng build` is provided with the `--prod` argument, which achieves
    two things: the size of the app is optimized to be significantly smaller with
    **Ahead-of-Time** (**AOT**) compilation to increase runtime performance, and the
    configuration items defined in `src/environments/environment.prod.ts` are used.'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update `src/environments/environment.prod.ts` to look like you’re using your
    own `appId` from `OpenWeather`:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We are modifying how `npm test` is executed, so the tests are run only once
    and the tool stops executing. The `--watch=false` option is provided to achieve
    this behavior, as opposed to the development-friendly default continuous execution
    behavior.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new file named `Dockerfile` with no file extensions in the project
    root.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement or replace the contents of the `Dockerfile`, as shown here:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Be sure to inspect the contents of your `dist` folder to ensure you’re copying
    the correct folder, which contains the `index.html` file at its root.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Execute `npm run predocker:build` and see that it runs without errors in the
    Terminal to ensure that your application changes have been successful.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm run docker:build` and see that it runs without errors in the Terminal
    to ensure that your image builds successfully.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While you can run any of the provided scripts individually, you really only
    need to remember two of them going forward:'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm run docker:debug` will test, build, tag, run, tail, and launch your containerized
    app in a new browser window for testing.'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm run docker:publish` will publish the image you just built and test to
    the online Docker repository.'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execute `docker:debug` in your Terminal:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A successful `docker:debug` run should result in a new in-focus browser window
    with your application and the server logs being tailed in the Terminal, as follows:'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You should always run `docker ps` to check whether your image is running, when
    it was last updated, and whether it clashes with any existing images claiming
    the same port.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute `docker:publish` in your Terminal:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should observe a successful run in the Terminal window like this:'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Over time, your local Docker cache may grow significantly; for example, it’s
    reached roughly 40 GB on my laptop over two years. You can use the `docker image
    prune` and `docker container prune` commands to reduce your cache size. For more
    detailed information, refer to the documentation at [https://docs.docker.com/config/pruning](https://docs.docker.com/config/pruning).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: By defining a `Dockerfile` and scripting our use of it, we created living documentation
    in our code base. We have achieved DevOps and closed the configuration gap.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to containerize **lemon-mart** like you’ve done with **local-weather-app**
    and verify your work by executing `npm run docker:debug`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: VS Code offers a visual way to interact with npm scripts. Let’s take a look
    at VS Code’s npm script support next.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: npm scripts in VS Code
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'VS Code provides support for npm scripts out of the box. In order to enable
    npm Script Explorer, open the VS Code settings and ensure that the `"npm.enableScriptExplorer":
    true` property is present. Once you do, you will see an expandable title named
    **NPM SCRIPTS** in the **Explorer** pane, as highlighted with an arrow in the
    following screenshot:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_10_14.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.14: NPM SCRIPTS in VS Code'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: You can click on any script to launch the line that contains the script in `package.json`
    or right-click and select **Run** to execute the script.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an easier way to interact with Docker next.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Docker extensions in VS Code
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to interact with Docker images and containers is through VS Code.
    If you have installed the `ms-azuretools.vscode-docker` Docker extension from
    Microsoft, as suggested in *Chapter 2*, *Forms, Observables, Signals, and Subjects*,
    you can identify the extension by the Docker logo on the left-hand navigation
    menu in VS Code, as circled in white in the following screenshot:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_10_15.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.15: Docker extension in VS Code'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go through some of the functionality provided by the extension. Refer
    to the preceding screenshot and the numbered steps in the following list for a
    quick explanation:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '**Images** contain a list of all the container snapshots on your system.'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-clicking on a Docker image creates a context menu to run various operations
    like **Run**, **Push**, and **Tag**.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Containers** list all executable Docker containers on your system, which
    you can start, stop, or attach to.'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Registries** display the registries that you’re configured to connect to,
    such as Docker Hub or **AWS Elastic Container Registry** (**AWS ECR**).'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the extension makes it easier to interact with Docker, the **npm scripts
    for Docker** (which you configured using the `mrm` task) automate many of the
    chores related to building, tagging, and testing an image. They are both cross-platform
    and will work equally well in a CI environment.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: The `npm` `run` `docker:debug` script automates a lot of chores to verify that
    you have a good image build!
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s learn about deploying our containers to the cloud and later achieve
    CD.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Working with containers in the cloud
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of using Docker is that we can deploy it on any number
    of operating environments, from personal PCs to servers and cloud providers. In
    any case, we expect our container to function the same across the board.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in the chapter, I mentioned that working with full-fledged cloud providers
    like Azure, AWS, and Google Cloud is complicated. To deploy your containers in
    the cloud you will likely need to use one of these providers. Now and then, a
    provider that offers easy and seamless container hosting pops up, but over the
    years, these options have disappeared.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Cloud services offer a wide variety of methods for running containers ranging
    from managed to unmanaged solutions. The key difference between managed and unmanaged
    is the level of control and responsibility shared between the user and the cloud
    provider. This is referred to as the Shared Responsibility Model. In a managed
    configuration, you concede more control and responsibility of the underlying infrastructure
    to the cloud provider. This consequently results in increased security and usually
    a cheaper cloud bill.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_10_16.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.16: Shared Responsibility Model'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The figure above demonstrates the shared responsibility model for running containers
    in the cloud. In the unmanaged model, the cloud provider gives you access to a
    virtual machine. The cloud provider manages and maintains the physical machine,
    which is totally abstracted away fro user. Now it’s up to you to configure the
    **Operating System** (**OS**) and secure it. On top of the OS, you can set up
    a container runtime or a cluster that involves many virtual machines.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Read the excellent article by Kaizhe Huang on ECS Fargate Threat Modeling at
    [https://sysdig.com/blog/ecs-fargate-threat-modeling](https://sysdig.com/blog/ecs-fargate-threat-modeling).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: A container cluster is a group of hosts set up to run containerized workloads.
    Container orchestration software like Kubernetes automates and manages the containers
    across the cluster infrastructure. This allows you to scale container instances
    to respond to changes in load. Clusters also provide rich features like service
    discovery. You can learn more about Kubernetes at [https://kubernetes.io](https://kubernetes.io).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: In the managed model, the cloud provider gives you access to a container runtime
    environment with cluster-like features, including Kubernetes support. The cloud
    provider secures the runtime, and the user is only responsible for the container.
    These offerings are **serverless**. In this space, each cloud provider offers
    a variety of services that significantly differ in capabilities.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of some popular options:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS Fargate** is a serverless compute engine that runs containers without
    managing servers or clusters. Integrates with **Elastic Container Service** (**ECS**)
    and **Elastic Kubernetes Service** (**EKS**).'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Cloud Run** is a fully managed serverless platform for stateless containerized
    applications. Auto-scales and bills per request.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Container Instances** can run individual containers without adopting
    higher-level orchestration services. Per-second billing.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon ECS** offers highly scalable Docker container management across a
    cluster of **Elastic Compute Cloud** (**EC2**) instances. Tight integration with
    other AWS services. AWS EKS is the Kubernetes-flavored version of AWS ECS.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Kubernetes Engine** (**GKE**) is a managed Kubernetes environment
    running on Google Cloud. Easily deploy containers with native Google Cloud integrations.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Kubernetes Service** (**AKS**) is a fully managed Kubernetes cluster
    service hosted on Azure. Streamlined deployments to containers with auto-scaling
    capabilities.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main advantages of the serverless options (AWS Fargate, Google Cloud Run,
    Azure Container Instances) are that they are fully managed, automatically scale,
    and have payas-you-go pricing models. However, they offer limited customization
    compared to provisioned Kubernetes. The provisioned Kubernetes options (Amazon
    ECS, Google GKE, Azure AKS) offer more control, customization, and the ability
    to run stateful applications. However, they require manual scaling and managing
    of the infrastructure.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Overall, serverless options are easier to use but less flexible, while provisioned
    Kubernetes offers more customization but requires DevOps know-how to manage the
    infrastructure. Your choice depends on whether the workload fits the serverless
    constraints and how much control vs simplicity is preferred.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: So far, you’ve deployed your code to the cloud, mastered the fundamentals of
    working with Docker containers, and understood the nuances of deploying containers
    in the cloud. **Continuous Deployment** (**CD**) is the manifestation of my motto,
    ship it, or it never happened. Next, we’ll go over how you can integrate deployments
    as part of your CI pipeline to achieve CD.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: The `npm run docker:debug` script automates a lot of chores to verify that you
    have a good image build!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CD is the idea that code changes that successfully pass through your pipeline
    can be automatically deployed to a target environment. Although examples of continuously
    deploying to production exist, most enterprises prefer to target a development
    environment. A gated approach is adopted to move the changes through the various
    stages of development environment, test, staging, and, ultimately, production.
    CircleCI can facilitate gated deployment with approval workflows, which is covered
    later in this section.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'In CircleCI, you need to implement a deploy job to deploy your image. You can
    deploy to many targets in this job, such as Google Cloud Run, Docker Hub, Heroku,
    Azure, or AWS ECS. Integration with these targets will involve multiple steps.
    At a high level, these steps are as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Configure an orb for your target environment, which provides the CLI tools required
    to deploy your software.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store login credentials or access keys specific to the target environment as
    CircleCI environment variables.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a container in the CI pipeline if not using a platform-specific `build`
    command. Then use `docker push` to submit the resulting Docker image to the target
    platform’s registry.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute a platform-specific `deploy` command to instruct the target to run the
    Docker image that was just pushed.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By using a Docker-based workflow, we achieve great amounts of flexibility in
    terms of systems and target environments we can use. The following diagram illustrates
    this point by highlighting the possible permutation of choices that are available
    to us:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a structure  Description automatically generated](img/B20960_10_17.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.17: n-to-n deployment'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, in a containerized world, the possibilities are limitless. We
    will use the deployment related npm scripts we added later in this chapter to
    implement the deploy job in our CI pipeline.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Outside of Docker-based workflows, you can use purpose-built CLI tools to quickly
    deploy your app. Next, let’s see how you can deploy your app to Vercel using CircleCI.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Vercel using CircleCI
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we configured the LocalCast Weather app to be built using CircleCI.
    We can enhance our CI pipeline to take the build output and optionally deploy
    it to Vercel.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: This section uses the **local-weather-app** repository. The `config.yml` file
    for this section is named `.circleci/config.stage9.yml`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the `config.yml` file to add a new job named `deploy`. In the
    upcoming *Workflows* section, we will use this job to deploy a pipeline when approved:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Create a token from your Vercel account.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an environment variable to your CircleCI project named `VERCEL_TOKEN` and
    store your Vercel token as the value.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `config.yml`, update the `build` job with the new steps and add a new job
    named `deploy`:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the `build` job, after the build is complete, we add two new steps. First,
    we move the compiled app in the `dist` folder to a workspace and persist that
    workspace so we can use it later in another job. In a new job named `deploy`,
    we attach the workspace and use `npx` to run the `vercel` command to deploy the
    `dist` folder. This is a straightforward process.
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that `$VERCEL_TOKEN` is the environment variable we stored in the CircleCI
    project.
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement a simple CircleCI workflow to deploy the outcome of your `build`
    job continuously:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that the `deploy` job waits for the `build` job to complete before it can
    execute.
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensure that your CI pipeline executed successfully by inspecting the test results:![A
    screenshot of a computer  Description automatically generated](img/B20960_10_18.png)
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.18: Successful Vercel deployment of local-weather-app'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Most CLI commands for cloud providers need to be installed in your pipeline
    to function. Since Vercel has an npm package, this is easy to do. CLI tools for
    AWS, Google Cloud, or Microsoft Azure need to be installed using tools such as
    `brew` or `choco`. CircleCI offers orbs, reusable snippets of code that help automate
    repeated processes, speed up project setup, and make it easy to integrate with
    third-party tools.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about orbs at [https://circleci.com/orbs](https://circleci.com/orbs).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Check out the Orb registry for more information on how to use these orbs at
    [https://circleci.com/orbs/registry](https://circleci.com/orbs/registry).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: CD works great for development and testing environments. However, it is usually
    desirable to have gated deployments, where a person must approve a deployment
    before it reaches a production environment. Next, let’s see how you can implement
    this with CircleCI.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Gated CI workflows
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In CircleCI, you can define a workflow to control how and when your jobs are
    executed. Consider the following configuration, given the jobs `build` and `deploy`:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'First, the `build` job gets executed. Then, we introduce a special job named
    `hold` with type `approval`, which requires the `build` job to be successfully
    completed. Once this happens, the pipeline is put on hold. If or when a decision-maker
    approves `hold`, then the `deploy` step can execute. Refer to the following screenshot
    to see what a **hold** looks like:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_10_19.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.19: A hold in the pipeline'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this case, the `build` and `test` jobs are executed in parallel. If we’re
    on a branch, this is where the pipeline stops. Once the branch is merged with
    `main`, the pipeline is put on hold, and a decision-maker has the option to deploy
    the build or not. This type of branch filtering ensures that only code that’s
    been merged to `main` can be deployed, which is in line with GitHub flow.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go over how we can integrate code coverage reports with our CI
    runs to get better insight into our test coverage and optionally fail builds that
    don’t meet a certain threshold.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage reports
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A code coverage report is a good way to understand the amount and trends of
    unit test coverage for your Angular project.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the report for your app, execute the following command from your
    `project` folder:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The resulting report will be created as an HTML file under a folder named `coverage`;
    execute the following command to view it in your browser:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You may need to specify `--project` for the `ng` `test` command. Similarly,
    the coverage report may be generated in a sub-folder under **coverage**. You can
    select the folder to view it.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the folder-level sample coverage report generated by `istanbul` for
    LemonMart:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a spreadsheet  Description automatically generated](img/B20960_10_20.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.20: Istanbul code coverage report for LemonMart'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'You can drill down on a particular folder, such as `src/app/auth`, and get
    a file-level report, as shown here:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a data  Description automatically generated](img/B20960_10_21.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.21: Istanbul code coverage report for src/app/auth'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'You can drill down further to get line-level coverage for a given file, such
    as `cache.service.ts`, as shown here:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_10_22.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.22: Istanbul code coverage report for cache.service.ts'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see lines **5**, **12**, **17**–**18**,
    and **21**–**22** are not covered by any test. The **I** icon denotes that the
    `if` path was not taken. We can increase our code coverage by implementing unit
    tests that exercise the functions that are contained within `CacheService`. As
    an exercise, you should attempt to at least cover one of these functions with
    a new unit test and observe the code coverage report change.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage in CI
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ideally, your CI server configuration should generate and host the code coverage
    report with every test run. You can then use code coverage as another code quality
    gate to prevent pull requests from being merged if the new code reduces the overall
    code coverage percentage. This is a great way to reinforce the **Test-Driven Development**
    (**TDD**) mindset.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: You can use a service such as Coveralls, found at [https://coveralls.io](https://coveralls.io),
    to implement your code coverage checks, which can embed your code coverage levels
    directly on a GitHub pull request.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s configure Coveralls for LemonMart:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: In the **lemon-mart** repo, the `config.yml` file for this section is named
    `.circleci/config.stage9.yml`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: In your CircleCI account settings, under the **Security** section, ensure that
    you allow the execution of uncertified/unsigned orbs.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register your GitHub project at [https://coveralls.io/](https://coveralls.io/).
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the repository token and store it as an environment variable in CircleCI
    named `COVERALLS_REPO_TOKEN`.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new branch before making any code changes.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `.circleci/config.yml` file with the Coveralls orb as shown:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Update the `build` job to store code coverage results and upload them to Coveralls:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`store_test_results` and `store_artifacts` will store test results and code
    coverage data to be analyzed in other jobs or orbs. CircleCI can display XML formatted
    coverage reports in its web UI. `The` `coveralls/upload` `command` uploads the
    code coverage data we just stored for analysis.'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the orb automatically configures Coveralls for your account, so the
    `coveralls`/`upload` command can upload your code coverage results.
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Commit your changes to the branch and publish it.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a pull request on GitHub using the branch.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the pull request, verify that you can see that Coveralls is reporting your
    project’s code coverage, as shown:![A screenshot of a computer error  Description
    automatically generated](img/B20960_10_23.png)
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.23: Coveralls reporting code coverage'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Merge the pull request to your main branch.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! Now, you can modify your branch protection rules to require
    that code coverage levels be above a certain percentage before a pull request
    can be merged into the main branch.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: You can set coverage thresholds at [https://coveralls.io](https://coveralls.io).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: The LemonMart project at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
    implements a full-featured `config.yml` file. This file also implements [Cypress.io](http://Cypress.io),
    overriding Angular’s default e2e tooling. The Cypress orb can record test results
    and allow you to view them from your CircleCI pipeline.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging what you have learned in this chapter, you can incorporate the `deploy`
    scripts from LocalCast Weather for LemonMart and implement a gated deployment
    workflow.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Good engineering practices and DevOps practices are key to delivering successful
    projects and building a satisfying career. Thanks for reading this book!
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about creating a value delivery stream using CI/CD
    pipelines. We covered the importance of automated unit testing to enable the delivery
    of quality code at speed in an enterprise context. You configured a CI pipeline
    using CircleCI. You learned about trunk-based development using GitHub flow and
    enforcing quality gates. You deployed a web application to Vercel and leveraged
    `ng` `deploy` for Firebase.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Next, we covered DevOps and IaC techniques using Docker and npm scripts. You
    containerized your web app, learned about working with containers in the cloud,
    and learned how to implement gated CI workflows. Also, you became familiar with
    orbs, workflows, and code coverage tools.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: We leveraged CircleCI as a cloud-based CI service and highlighted that you can
    deploy the outcome of your builds to all major cloud hosting providers. You have
    seen how you can achieve CD. We covered an example deployment to Vercel via CircleCI
    demonstrating how you can implement continuous deployments.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: With a robust CI/CD pipeline, you can share every app build with clients and
    team members and quickly deliver bug fixes or new features to your end users.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have completed your *Angular for Enterprise Applications*
    journey. I hope you learned something new. The best way to learn and grow is by
    teaching and sharing, so I hope you keep this book around as a reference and share
    it with friends, family, and colleagues.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: If you got this far, send me a picture of yourself with the (e-)book or a note
    on how the content impacted you, and I’ll share an exclusive digital badge with
    you for your achievement.
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Continue your journey at [https://AngularForEnterprise.com](https://AngularForEnterprise.com).
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add CircleCI and Coveralls badges to the `README.md` file on your code repository.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement Cypress for e2e testing and run it in your CircleCI pipeline using
    the `Cypress orb`.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a Vercel deployment and a conditional workflow for the LemonMart app.
    The resulting `config.yml` file is in the `lemon-mart` repo, named `.circleci/config.stage9.yml`.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Working Effectively with Legacy Code*, Michael Feathers, 2004'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Three Laws of TDD*, Robert “Uncle Bob” Martin, 2005, [http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd](http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd)'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Succeeding with Agile: Software Development Using Scrum*, Mike Cohn, 2009'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TestPyramid*, Martin Fowler, 2012, [https://martinfowler.com/bliki/TestPyramid.html](https://martinfowler.com/bliki/TestPyramid.html)'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Jasmine 2 Spy Cheat Sheet*, Dave Ceddia, 2015, [https://daveceddia.com/jasmine-2-spy-cheat-sheet](https://daveceddia.com/jasmine-2-spy-cheat-sheet)'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Practical Test Pyramid*, Ham Vocke, 2018, [https://martinfowler.com/articles/practical-test-pyramid.html](https://martinfowler.com/articles/practical-test-pyramid.html)'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SOLID Principles*, Wikipedia, 2019, [https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID)'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dockerfile reference*, 2020, [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CircleCI orbs*, 2020, [https://circleci.com/orbs/](https://circleci.com/orbs/)'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deploying container images*, 2020, [https://cloud.google.com/run/docs/deploying](https://cloud.google.com/run/docs/deploying
    )'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ECS Fargate Threat Modeling*, Kaizhe Huang, 2019, [https://sysdig.com/blog/ecs-fargate-threat-modeling/](https://sysdig.com/blog/ecs-fargate-threat-modeling/
    )'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: What is the testing pyramid?
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are fixtures and matchers?
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the differences between a mock, a spy, and a stub?
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of building Angular in prod mode?
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does GitHub flow work?
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should we protect the main branch?
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the difference between a Docker image and a Docker container.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do you prefer a managed container runtime over an unmanaged one in the cloud?
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of a CD pipeline?
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of CD?
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we cover the configuration gap?
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a CircleCI orb do?
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of using a multi-stage Dockerfile?
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a code coverage report help maintain the quality of your app?
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
