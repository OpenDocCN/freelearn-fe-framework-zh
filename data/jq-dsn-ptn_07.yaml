- en: Chapter 7. Asynchronous Control Flow Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。异步控制流模式
- en: This chapter is dedicated to development patterns that are used to ease the
    programming of asynchronous and concurrent procedures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专注于用于简化异步和并发过程编程的开发模式。
- en: At first, we will have a refresher on how Callbacks are used in JavaScript programming
    and how they are an integral part of web development. We will then proceed and
    identify their benefits and limitations when used in large and complex implementations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将复习 JavaScript 编程中如何使用回调函数以及它们是网页开发的一个组成部分。然后，我们将继续识别它们在大型和复杂实现中的好处和局限性。
- en: Right after this, we will be introduced to the concept of Promises. We will
    learn how jQuery's Deferred and Promise APIs work and how they differ from ES6
    Promises. We will see where and how they are used internally by jQuery to simplify
    its implementation and lead to more readable code. We will analyze their benefits,
    classify the best matching use cases, and compare them with the classic Callback
    Pattern.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍 Promises 的概念。我们将学习 jQuery 的 Deferred 和 Promise API 的工作原理，以及它们与 ES6
    Promises 的区别。我们将看到它们在 jQuery 内部的使用方式以简化其实现并导致更可读的代码。我们将分析它们的好处，分类最匹配的用例，并将它们与经典的回调模式进行比较。
- en: By the end of this chapter, we will be able to use jQuery Deferred and Promises
    to efficiently orchestrate the execution of asynchronous procedures that run either
    in order or parallel to each other.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到达本章结束时，我们将能够使用 jQuery Deferred 和 Promises 来有效地编排按顺序或并行运行的异步过程的执行。
- en: 'In this chapter, we will:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Have a refresher on how Callbacks are used in JavaScript programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 JavaScript 编程中如何使用回调函数进行复习
- en: Get introduced to the concept of Promises
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Promises 的概念
- en: Learn how to use jQuery's Deferred and Promise APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用 jQuery 的 Deferred 和 Promise API
- en: Compare jQuery Promises with ES6 Promises
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较 jQuery Promises 和 ES6 Promises
- en: Learn how to orchestrate asynchronous tasks using Promises.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用 Promises 来编排异步任务。
- en: Programming with callbacks
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用回调函数进行编程
- en: A Callback can be defined as a function that is passed as an invocation argument
    to another function or method (which is referred to as a Higher-Order Function)
    and is expected to be executed at some later point of time. In this way, the piece
    of code that was handed our Callback will eventually invoke it, propagating the
    results of an operation or event back to the context that the Callback was defined.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数可以被定义为作为调用参数传递给另一个函数或方法（称为高阶函数）的函数，并且预计将在以后的某个时间点执行。通过这种方式，被传递给我们的回调函数的代码片段最终会调用它，将操作或事件的结果传播回定义回调函数的上下文。
- en: Callbacks can be characterized as synchronous or asynchronous, based on the
    way that the invoked method operates. A Callback is characterized as synchronous
    when it is executed by a blocking method. On the other hand, JavaScript developers
    are more familiar with **asynchronous callbacks**, also called **deferred callbacks**,
    which are set to be executed after an asynchronous procedure finishes or when
    a specific event occurs (page load, click, AJAX response arrival, and so on).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数可以根据被调用方法的操作方式分为同步或异步。当回调由阻塞方法执行时，回调被称为同步。另一方面，JavaScript 开发人员更熟悉异步回调，也称为延迟回调，它们被设置为在异步过程完成后或发生特定事件时执行（页面加载，单击，AJAX
    响应到达等）。
- en: '![Programming with callbacks](img/00028.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![使用回调进行编程](img/00028.jpeg)'
- en: Callbacks are widely used in JavaScript applications since they are an integral
    part of many core JavaScript APIs such as AJAX. Moreover, JavaScript implementations
    of this pattern are almost word for word as described by the above simple definition.
    This is a result of the way that JavaScript treats functions as objects and allows
    us to store and pass method references as simple variables.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于回调函数是许多核心 JavaScript API（如 AJAX）的组成部分，因此在 JavaScript 应用程序中广泛使用。此外，JavaScript
    对该模式的实现几乎与上述简单定义所描述的一字不差。这是 JavaScript 将函数视为对象并允许我们将方法引用存储和传递为简单变量的方式的结果。
- en: Using simple callbacks in JavaScript
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JavaScript 中使用简单回调函数
- en: 'Perhaps one of the simplest examples of asynchronous callbacks in JavaScript
    is the `setTimeout()` function. The following code demonstrates a simple use of
    it, where we invoke `setTimeout()` with the `doLater()` function as a callback
    parameter and, after 1000 milliseconds of waiting, the `doLater()` callback is
    invoked:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中使用异步回调的最简单的例子之一可能是`setTimeout()`函数。下面的代码演示了它的一个简单用法，我们将`setTimeout()`与`doLater()`函数作为回调参数一起调用，并且在等待1000毫秒后，`doLater()`回调被调用：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As seen in the simple preceding example, the callback is executed in the context
    that it was defined. The callback still has access to the variables of the context
    that it was defined by creating a closure. Even though the preceding example uses
    a named function defined earlier, the same applies for anonymous callbacks:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如简单的前面示例所示，回调在定义的上下文中执行。回调仍然可以访问定义它的上下文的变量，通过创建闭包来实现。即使前面的示例使用了之前定义的命名函数，对于匿名回调也是适用的：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In many cases, using anonymous callbacks is a more convenient way of programming,
    since it results in shorter code and also reduces the readability noise, which
    is a result of defining several different named functions that are used only once.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，使用匿名回调是一种更方便的编程方式，因为它会导致代码更短，也减少了可读性噪音，这是由定义几个只使用一次的不同命名函数而产生的。
- en: Setting callbacks as object properties
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将回调设置为对象属性
- en: 'A small variation of the above definition also exists, where the callback function
    is assigned to a property of an object instead of being passed as an argument
    of a method invocation. This is commonly used in cases where there are several
    different actions that need to take place during or after a method invocation
    is completed:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上述定义的一个小变化也存在，其中回调函数被分配给对象的属性，而不是作为方法调用的参数传递。这在需要在方法调用期间或之后执行几种不同操作的情况下通常使用：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Another use case of the above variant is to add handlers on objects that have
    already been instantiated and initialized. A good example of this case is the
    way we set up a result handler for simple (non-jQuery) AJAX calls:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述变体的另一个用例是在已实例化和初始化的对象上添加处理程序。这种情况的一个很好的例子是我们为简单（非jQuery）AJAX调用设置结果处理程序的方式：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we set an anonymous function on the `onreadystatechange`
    property of the XMLHttpRequest object. This function acts as a callback and is
    invoked every time there is a state change on the ongoing request. Inside our
    callback, we check whether the request has completed with a successful HTTP status
    code and display an alert with the response body. Like in this example, where
    we initiate the AJAX call by invoking the `send()` method without passing any
    arguments, it is common for APIs that use this variant to lead to minimal ways
    of invoking their methods.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们将一个匿名函数设置在XMLHttpRequest对象的`onreadystatechange`属性上。这个函数充当回调，每当进行中的请求状态发生变化时都会被调用。在我们的回调内部，我们检查请求是否以成功的HTTP状态码完成，并显示带有响应主体的警报。就像在这个示例中一样，我们通过调用`send()`方法而不传递任何参数来启动AJAX调用，使用这种变体的API通常导致以最小的方式调用它们的方法。
- en: Using callbacks in jQuery applications
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在jQuery应用程序中使用回调
- en: Perhaps the most common way in which callbacks are used in jQuery applications
    is for event handling. This is logical since the first thing that every interactive
    application should do is handle and respond to user actions. As we saw in earlier
    chapters, one of the most convenient ways to attach event handlers to elements
    is by using jQuery's `$.fn.on()` method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在jQuery应用程序中使用回调的最常见方式可能是用于事件处理。这是合乎逻辑的，因为每个交互式应用程序都应该首先处理和响应用户操作。正如我们在前面章节中看到的，将事件处理程序附加到元素的最便捷方式之一是使用jQuery的`$.fn.on()`方法。
- en: Another common place where callbacks are used in jQuery is for AJAX requests,
    where the `$.ajax()` method has the central role. Moreover, the jQuery library
    also provides several other convenient methods to make AJAX requests that are
    focused on the most common use cases. Since all these methods are executed asynchronously,
    they also accept a callback as a parameter, as a way to make the retrieved data
    available back to the context that initiated the AJAX request. One of these convenient
    methods is `$.getJSON()`, which is a wrapper around `$.ajax()`, and is used as
    a better matching API to execute AJAX requests that intend to retrieve JSON responses.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery中另一个常见的使用回调的地方是AJAX请求，`$.ajax()`方法起着中心作用。此外，jQuery库还提供了几个方便的方法来进行AJAX请求，这些方法都专注于最常见的用例。由于所有这些方法都是异步执行的，它们也接受一个回调作为参数，以便将检索到的数据返回给发起AJAX请求的上下文。其中一个方便的方法是`$.getJSON()`，它是`$.ajax()`的一个包装器，并且用作执行意图检索JSON响应的AJAX请求的更匹配的API。
- en: 'Other widely used jQuery APIs accepting callbacks are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 其他广泛使用的接受回调的jQuery API如下：
- en: The effects-related jQuery methods such as `$.animate()`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如`$.animate()`之类的与效果相关的jQuery方法
- en: The `$(document).ready()` method
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$(document).ready()`方法'
- en: Let's now continue by demonstrating a code example where all the above methods
    are used.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过演示一个代码示例来继续，该示例中使用了上述所有方法。
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code firstly delays its execution until the DOM tree of the page
    has been fully loaded and then adds an Observer for clicks on the `<button>` with
    ID `fetchButton` by using the jQuery''s `$.fn.on()` method. Whenever the click
    event is fired, the provided callback will be invoked and initiate an AJAX call
    to fetch the `AjaxContent.json` file. For the needs of this example, we are using
    a simple JSON file, like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码首先延迟执行，直到页面的DOM树完全加载，然后通过使用jQuery的`$.fn.on()`方法，在ID为`fetchButton`的`<button>`上添加一个点击观察器。每当点击事件触发时，提供的回调将被调用，并启动一个AJAX调用来获取`AjaxContent.json`文件。在此示例中，我们使用一个简单的JSON文件，如下所示：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When the response is received and the JSON is parsed successfully, the callback
    is invoked with the parsed object as a parameter. Finally, the callback itself
    locates the page element with the ID `newContent` in the page, hides it, and then
    sets the data field of the retrieved JSON as its text content. Right after this,
    we use the jQuery `$.fn.slideDown()` method that makes the newly set page content
    appear, by progressively increasing its height. Finally, after the animation is
    complete, we write a log message to the browser console.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到响应并成功解析JSON时，回调函数将以解析后的对象作为参数被调用。最后，回调函数本身会在页面中查找ID为`newContent`的页面元素，隐藏它，然后将检索到的JSON数据字段设置为其文本内容。紧接着，我们使用jQuery的`$.fn.slideDown()`方法，通过逐渐增加其高度使新设置的页面内容出现。最后，在动画完成后，我们向浏览器控制台输出一个日志消息。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Further documentation regarding jQuery's `$.ajax()`, `$.getJSON()`, and `$.fn.slideDown()`
    methods can be found at [http://api.jquery.com/jQuery.ajax/](http://api.jquery.com/jQuery.ajax/),
    [http://api.jquery.com/jQuery.getJSON/](http://api.jquery.com/jQuery.getJSON/),
    and [http://api.jquery.com/slideDown/](http://api.jquery.com/slideDown/).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关于jQuery的`$.ajax()`、`$.getJSON()`和`$.fn.slideDown()`方法更多的文档可以在[http://api.jquery.com/jQuery.ajax/](http://api.jquery.com/jQuery.ajax/)、[http://api.jquery.com/jQuery.getJSON/](http://api.jquery.com/jQuery.getJSON/)和[http://api.jquery.com/slideDown/](http://api.jquery.com/slideDown/)中找到。
- en: Keep in mind that the `$.getJSON()` method might not work in some browsers when
    the page is loaded through the filesystem, but works as intended when served using
    any web server such as Apache, IIS, or nginx.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当通过文件系统加载页面时，`$.getJSON()`方法可能在某些浏览器中无法工作，但在使用Apache、IIS或nginx等任何Web服务器时可以正常工作。
- en: Writing methods that accept callbacks
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写接受回调的方法
- en: When writing a function that utilizes one or more asynchronous APIs, that also
    dictates that the resulting function will be asynchronous by definition. In that
    case, it is obvious that simply returning a result value is not an option, since
    the result will probably be available after the function invocation has already
    finished.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写一个使用一个或多个异步API的函数时，这也意味着结果函数结果也是异步的。在这种情况下，很明显，简单地返回结果值不是一个选项，因为结果可能在函数调用已经完成后才可用。
- en: 'The easiest solution for asynchronous implementations is to use a callback
    as a parameter of your function, which, as we discussed earlier, is hassle-free
    in JavaScript. As an example, we will create an asynchronous function that generates
    a random number of a specified range:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 异步实现的最简单解决方案是使用一个回调函数作为函数的参数，正如我们之前讨论的那样，在 JavaScript 中这是很方便的。例如，我们将创建一个异步函数，它生成指定范围内的随机数：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `getRandomNumberAsync()` function accepts its `max` argument as the numeric
    upper bound for the generated random number and also a callback function that
    it will invoke with the generated result. It uses `setTimeout()` to emulate an
    asynchronous calculation that ranges from 1000 to 2000 milliseconds. For the generation
    of the result, it uses the `Math.random()` method, multiplying it with the maximum
    allowed value, and finally invokes the provided callback with it. A simple way
    to invoke this function will look as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRandomNumberAsync()` 函数接受其 `max` 参数作为生成的随机数的数值上限，还接受一个回调函数作为参数，它将使用生成的结果调用。它使用
    `setTimeout()` 来模拟一个范围在 1000 到 2000 毫秒之间的异步计算。为了生成结果，它使用 `Math.random()` 方法，将其乘以允许的最大值，最后使用提供的回调函数调用它。调用此函数的简单方法如下所示：'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Even though the above example uses `setTimeout()` to emulate asynchronous processing,
    the implementation principles remain the same regardless of the asynchronous API(s)
    that is used. For example, we can rewrite the above function to retrieve its result
    through an AJAX call:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 即使上面的示例使用 `setTimeout()` 来模拟异步处理，但不管使用哪种异步 API，实现原理都是相同的。例如，我们可以重写上述函数以通过 AJAX
    调用来检索其结果：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding implementation uses the `$.ajax()` method that is invoked with
    an object parameter, enclosing all the options of the request. Except for the
    URL for the request, the object also defines the expected `dataType` of the result
    and the `success` and `error` callbacks, which are wired with the respective parameters
    of our function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前述实现使用了 `$.ajax()` 方法，该方法使用一个对象参数调用，该对象封装了请求的所有选项。除了请求的 URL 外，该对象还定义了结果的预期 `dataType`
    和 `success` 和 `error` 回调函数，这些函数与我们函数的相应参数配合使用。
- en: Perhaps the only extra concern that the preceding code has to resolve is how
    to handle errors inside the success callback so that the caller of the function
    can be notified in case something goes wrong during the creation of the result.
    For example, the AJAX request might return an empty object. Adding proper handling
    for such cases is left as an exercise for the reader, after reading the rest of
    this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 或许前面的代码唯一额外需要解决的问题是如何在成功回调内处理错误，以便在创建结果过程中出现问题时通知函数的调用者。例如，AJAX 请求可能会返回一个空对象。为这些情况添加适当的处理留给读者，在阅读本章剩余部分之后。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Australian National University (ANU) provides free, truly random, numbers
    to the public, through their REST Web Service. For more information, you can visit
    [http://qrng.anu.edu.au/API/api-demo.php](http://qrng.anu.edu.au/API/api-demo.php).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 澳大利亚国立大学（ANU）通过他们的 REST Web 服务向公众提供免费的真正随机数。更多信息，请访问 [http://qrng.anu.edu.au/API/api-demo.php](http://qrng.anu.edu.au/API/api-demo.php)。
- en: Orchestrating callbacks
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调度回调函数
- en: We will now continue by analyzing some patterns that are commonly used to control
    the execution flow when dealing with asynchronous methods that accept callbacks.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续分析一些在处理接受回调函数的异步方法时常用的控制执行流程的模式。
- en: Queuing in order execution
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按顺序排队执行
- en: 'As our first example, we will create a function that demonstrates how we can
    queue the execution of several asynchronous tasks:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的第一个例子，我们将创建一个函数，演示如何排队执行多个异步任务：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding implementation, our function creates a queue of three random
    number generations. The first two random numbers are generated from our sample
    `setTimeout()` implementation and the third is retrieved from the aforementioned
    web service though an AJAX call. In this example, all the numbers are gathered
    in the `result` array, which is passed as an invocation parameter to the `callbackFn`
    after all the asynchronous tasks have completed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的实现中，我们的函数创建了一个包含三个随机数生成的队列。前两个随机数是从我们的样本 `setTimeout()` 实现中生成的，第三个是通过 AJAX
    调用从上述 Web 服务中检索的。在这个例子中，所有的数字都被收集在 `result` 数组中，在所有异步任务完成后作为调用参数传递给 `callbackFn`。
- en: The preceding implementation is quite straightforward and just applies the simple
    principles of the Callback Pattern repeatedly. For every extra or queued asynchronous
    task, we just need to nest its invocation inside the callback of the task that
    it depends on. Keep in mind that, in different use cases, we might only care to
    return the result of the final task and have the results of the intermediate steps
    be propagated as arguments for each subsequent asynchronous call.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的实现相当简单直接，并且只是反复应用了回调模式的简单原则。对于每一个额外或排队的异步任务，我们只需将其调用嵌套在它依赖的任务的回调内部即可。请记住，在不同的用例中，我们可能只关心返回最终任务的结果，并将中间步骤的结果作为参数传递给每个后续的异步调用。
- en: Avoiding the Callback Hell anti-pattern
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 避免回调地狱反模式
- en: Even though writing code as shown in the above example is easy, when applied
    to large and complex implementations, it can lead to bad readability. The triangular
    shape that is created by the white-spaces in front of our code and the stacking
    of several `});` near its end, are the two signs that our code might lead to an
    anti-pattern known as **Callback Hell**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管编写像上面示例中显示的代码很容易，但当应用于大型和复杂的实现时，可能会导致可读性较差。由代码前面的空格创建的三角形形状和接近末尾的几个`});`的堆叠是我们的代码可能会导致的反模式的两个迹象，该反模式被称为**回调地狱**。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information, you can visit [http://callbackhell.com/](http://callbackhell.com/).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问[http://callbackhell.com/](http://callbackhell.com/)。
- en: 'A way to avoid this anti-pattern is to unfold the nested callbacks, by creating
    separate named functions at the same level with the asynchronous task that they
    are used. After applying this simple tip to the above example, the resulting code
    looks a lot cleaner:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一种避免这种反模式的方法是展开嵌套的回调函数，通过在与它们使用的异步任务相同级别创建单独的命名函数。将这个简单的提示应用到上面的示例后，生成的代码看起来更清晰：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the resulting code surely does not remind us of the characteristics
    of the Callback Hell anti-pattern. On the other hand, it now needs more lines
    of code for its implementation, mostly used for the additional function declarations
    `function taskX () { }` that are now required.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，生成的代码确实不会让我们想起回调地狱反模式的特征。另一方面，现在它需要更多的代码行来实现，主要用于现在需要的额外函数声明`function
    taskX () { }`。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A middle ground solution between the above two approaches is to organize the
    related parts of such asynchronous execution queues in small and manageable functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述两种方法之间的一个中间解决方案是将这种异步执行队列的相关部分组织成小型且易于管理的函数。
- en: Running concurrently
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并行运行
- en: 'Even though JavaScript in web browsers is single-threaded, making independent
    asynchronous tasks run concurrently can make our applications work faster. As
    an example, we will rewrite the preceding implementation to fetch all three random
    numbers in parallel, which can make the result to be retrieved a lot faster than
    before:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Web 浏览器中的 JavaScript 是单线程的，但使独立的异步任务并行运行可以使我们的应用程序运行更快。例如，我们将重新编写前面的实现以并行获取所有三个随机数，这样可以使结果的检索速度比以前快得多：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we defined the `gatherResult()` helper function, which
    returns an anonymous function that is used as a callback for our random number
    generators. The returned callback function uses the `resultPos` parameter as the
    index of the array where it will store the generated or retrieved random number.
    Additionally, it tracks how many times it has been invoked, as a way to know whether
    all three concurrent tasks have ended. Finally, right after the third and final
    invocation of the callback, the `callbackFn` function is invoked with the `results`
    array as a parameter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了`gatherResult()`辅助函数，它返回一个匿名函数，该函数用作我们的随机数生成器的回调。返回的回调函数使用`resultPos`参数作为将生成或检索到的随机数存储的数组的索引。此外，它追踪它被调用的次数，以了解是否所有三个并行任务已结束。最后，在第三次和最后一次回调之后，使用`results`数组作为参数调用`callbackFn`函数。
- en: Another great application of this technique, other than AJAX calls, is to access
    data stored in **IndexedDB**. Retrieving many values from the database concurrently
    can lead to performance gains, since the data retrievals can execute in parallel
    without blocking each other.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 AJAX 调用之外，这种技术的另一个很好的应用是访问存储在**IndexedDB**中的数据。并行从数据库中检索许多值可以带来性能增益，因为数据检索可以在不互相阻塞的情况下并行执行。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on IndexedDB, you can visit [https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 IndexedDB 的更多信息，您可以访问 [https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB)。
- en: Introducing the concept of Promises
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Promise 的概念
- en: Promises, also known as Futures, are described by Computer Science as specialized
    objects that are used for synchronization of asynchronous, concurrent, or parallel
    procedures. They are also used as proxies to propagate the result of a task when
    its generation completes. This way, a Promise object is like a contract where
    an operation will eventually complete its execution, and anyone having a reference
    to this contract can declare their interest to be notified about the result.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Promise，也被计算机科学称为 Futures，被描述为专门用于同步异步、并发或并行过程的特殊对象。它们也被用作代理来在生成完成任务的结果时传播结果。这样，一个
    Promise 对象就像是一个合同，其中一项操作最终将完成其执行，任何持有这个合同引用的人都可以声明他们对结果的通知感兴趣。
- en: Since they were introduced to JavaScript developers, as part of several libraries,
    they revolutionized the way we use asynchronous functions and compose them in
    implementation with complex synchronization schemes. This way, web developers
    can create more flexible, scalable, and readable implementations, making method
    invocations with callbacks look like a primitive pattern and effectively eliminating
    the Callback Hell situations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 自从它们作为几个库的一部分被引入到 JavaScript 开发中，它们彻底改变了我们使用异步函数以及在实现中与复杂的同步方案结合使用的方式。这样，Web
    开发人员可以创建更灵活、可扩展和可读性更强的实现，使带有回调的方法调用看起来像是一个原始模式，并有效地消除了回调地狱（Callback Hell）的情况。
- en: '![Introducing the concept of Promises](img/00029.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![介绍 Promise 的概念](img/00029.jpeg)'
- en: One of the key concepts of Promises is that asynchronous methods return an object
    that represents their eventual result. Every Promise has an internal state that
    initially starts as Pending. This internal state can change only once, from Pending
    to either Resolved or Rejected, by using one of the `resolve()` or `reject()`
    methods that every implementation provides. These methods can be invoked only
    to change the state of a Pending Promise; in most cases, they are intended to
    be used only by the original creator of the Promise object and not be available
    to its consumers. The `resolve()` method can be invoked with the result of the
    operation as a single parameter, while the `reject()` method is usually invoked
    with the `Error` that caused the Promise object to get Rejected.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 的一个关键概念是，异步方法返回一个代表其最终结果的对象。每个 Promise 都有一个最初状态为 Pending 的内部状态。这个内部状态只能改变一次，从
    Pending 改变为 Resolved 或 Rejected，通过使用每个实现都提供的 `resolve()` 或 `reject()` 方法。这些方法只能调用来改变
    Pending Promise 的状态；在大多数情况下，它们只能由 Promise 对象的原始创建者使用，而不是提供给其消费者。`resolve()` 方法可以用操作的结果作为单一参数来调用，而
    `reject()` 方法通常用引起 Promise 对象被拒绝的 `Error` 来调用。
- en: Another key concept of Promises is the existence of a `then()` method, giving
    them the characterization of the "thenable", as a general term to describe promises
    among all the different implementations. Every Promise object exposes a `then()`
    method that is used by a caller in order to provide the function(s) that will
    be invoked when the Promise is settled (Resolved or Rejected). The `then()` method
    can be invoked with two functions as parameters, where the first is invoked in
    case the Promise gets Resolved, while the second is invoked when it is Rejected.
    The first argument is commonly referred to as the `onFulfilled()` callback, while
    the second is referred to as the `onRejected()`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 Promise 的关键概念是存在一个 `then()` 方法，使它们被称为“thenable”，这是一个通用术语，用来描述所有不同实现中的 promises。每个
    Promise 对象都暴露了一个 `then()` 方法，调用者可以用它来提供在 Promise 被解决（Resolved）或拒绝（Rejected）时将被调用的函数。`then()`
    方法可以用两个函数作为参数来调用，第一个函数在 Promise 被解决时被调用，而第二个函数在被拒绝时被调用。第一个参数通常被称为`onFulfilled()`
    回调，而第二个参数被称为 `onRejected()`。
- en: '![Introducing the concept of Promises](img/00030.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![介绍 Promise 的概念](img/00030.jpeg)'
- en: Every Promise preserves two internal list containing all the `onFulfilled()`
    and `onRejected()` callback functions that are passed as arguments to the `then()`
    method. The `then()` method can be invoked several times for each Promise, adding
    new entries to the appropriate internal list, as far as the respective parameter
    is actually a function. When a Promise eventually gets Resolved or Rejected, it
    iterates over the appropriate list of callbacks and invokes them in order. Moreover,
    from the point that a Promise gets settled and after, every further usage of the
    `then()` method has, as a result, the immediate invocation of the appropriate
    provided callback.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Promise 都保存着两个内部列表，其中包含作为参数传递给 `then()` 方法的所有 `onFulfilled()` 和 `onRejected()`
    回调函数。`then()` 方法可以针对每个 Promise 调用多次，向适当的内部列表添加新条目，只要相应的参数实际上是一个函数。当 Promise 最终得到解决或拒绝时，它会遍历适当的回调列表，并按顺序调用它们。此外，一旦
    Promise 被解决并且之后，每次使用 `then()` 方法都会立即调用相应的提供的回调。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Based on its characteristics, a Promise can be likened to a Broker from the
    Publish/Subscribe Pattern to some degree. Their key differences include the facts
    that it can only be used for a single Publish and that the Subscribers get notified
    of the result even if they expressed their interest after the Publish took place.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其特性，Promise在某种程度上可以被比作发布/订阅模式中的代理。它们的主要区别包括它只能用于单个发布，并且即使订阅者在发布之后表达了兴趣，他们也会收到结果通知。
- en: Using Promises
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Promises
- en: As we said earlier, the concept of Promises revolutionized programming of asynchronous
    tasks in JavaScript and, for a long time, they were the new big thing that everyone
    was enthusiastic about. At that time, many specialized libraries appeared where
    each one provided an implementation of Promises with slight differences to each
    other. Moreover, Promise implementations became available as part of utility libraries
    such as jQuery and web frameworks such as AngularJS and EmberJS. At that time,
    the "CommonJS Promises/A" specification made its appearance as a reference point
    and was the first attempt to define how Promises should actually work across all
    implementations.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，Promise的概念彻底改变了JavaScript中异步任务的编程方式，并且在很长一段时间内，它们是每个人都热情的新事物。那时，许多专门的库出现了，每个库都提供了一个稍有不同的Promise实现。此外，Promise实现也作为jQuery之类的实用程序库的一部分以及诸如AngularJS和EmberJS之类的Web框架的一部分而可用。那时，"CommonJS
    Promises/A"规范以参考点的形式出现，并且是第一个尝试定义如何跨所有实现实际工作的Promise。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the "CommonJS Promises/A" specification, you can visit
    [http://wiki.commonjs.org/wiki/Promises/A](http://wiki.commonjs.org/wiki/Promises/A).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有关"CommonJS Promises/A"规范的更多信息，您可以访问[http://wiki.commonjs.org/wiki/Promises/A](http://wiki.commonjs.org/wiki/Promises/A)。
- en: Using the jQuery Promise API
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用jQuery Promise API
- en: A Promise-based API first appeared in the jQuery library in v1.5, based on the
    "CommonJS Promises/A" design. This implementation introduced the additional concept
    of the Deferred object, which works like a **Promise Factory**. The Deferred objects
    expose a superset of the methods that Promises provide, where the additional methods
    can be used to do manipulations to the state of its internal Promise. Additionally,
    the Deferred object exposes a `promise()` method and returns the actual Promise
    object, which does not expose any way to manipulate its internal state and just
    exposes observation methods such as `then()`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基于"CommonJS Promises/A"设计，Promise-based API 首次出现在 jQuery v1.5 中。该实现引入了附加概念Deferred对象，它的工作方式类似于**Promise工厂**。Deferred对象公开了一组Promises提供的方法的超集，其中附加方法可用于对其内部Promise的状态进行操作。此外，Deferred对象公开了一个`promise()`方法，并返回实际的Promise对象，该对象不公开任何方式来操作其内部状态，只公开像`then()`这样的观察方法。
- en: 'In other words:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：
- en: Only code that has a reference to a Deferred object can actually change the
    internal state of its Promise, by either resolving or rejecting it.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有引用Deferred对象的代码才能实际更改其Promise的内部状态，无论是解决还是拒绝。
- en: Any piece of code that has a reference to a Promise object can't change its
    state but just observe for its state to change.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何具有对Promise对象的引用的代码片段都无法更改其状态，而只能观察其状态是否更改。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on jQuery's Deferred object, you can visit [http://api.jquery.com/jQuery.Deferred/](http://api.jquery.com/jQuery.Deferred/).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有关jQuery的Deferred对象的更多信息，您可以访问[http://api.jquery.com/jQuery.Deferred/](http://api.jquery.com/jQuery.Deferred/)。
- en: 'As a simple example of jQuery''s Deferred object, let''s see how we can rewrite
    the `getRandomNumberAsync()` function that we saw earlier in this chapter, to
    use Promises instead of Callbacks:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 jQuery 的 Deferred 对象的一个简单示例，让我们看看如何重写本章早些时候看到的 `getRandomNumberAsync()` 函数，以使用
    Promises 而不是回调：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our target is to make an asynchronous function that returns a Promise that is
    eventually resolved to the resulting random number. At first, a new Deferred object
    is created and then the respective Promise object is returned, by using the `promise()`
    method of the Deferred. When the asynchronous generation of the result is complete,
    our method uses the `resolve()` method of the Deferredobject to set the final
    state of the Promise that was returned earlier.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建一个返回最终解决为生成的随机数的 Promise 的异步函数。首先，创建一个新的 Deferred 对象，然后使用 Deferred 的
    `promise()` 方法返回相应的 Promise 对象。当结果的异步生成完成时，我们的方法使用 Deferred 对象的 `resolve()` 方法设置先前返回的
    Promise 的最终状态。
- en: The caller of our function uses the `then()` method of the returned Promise,
    to attach a callback that will be invoked with the result as a parameter as soon
    as the Promise gets Resolved. Moreover, a second callback can also be passed in
    order to get notified in case the Promise gets Rejected. An important thing to
    notice is that, by following the above pattern where functions always return Promises
    and never the actual Deferred objects, we can be sure that only the creator of
    the Deferred object can change the state of the Promise.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们函数的调用者使用返回的 Promise 的 `then()` 方法，附加一个回调函数，一旦 Promise 被解决，就会以结果作为参数调用该回调。此外，还可以传递第二个回调函数，以便在
    Promise 被拒绝时得到通知。需要注意的一件重要事情是，通过遵循上述模式，即函数总是返回 Promises 而不是实际的 Deferred 对象，我们可以确保只有
    Deferred 对象的创建者可以更改 Promise 的状态。
- en: Using Promises/A+
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Promises/A+
- en: After some time of hands-on experimentation with CommonJS Promises/A, the community
    identified some of their limitations and also recommended some ways to improve
    them. The result was the creation of the Promises/A+ specification, as a way to
    improve the existing specification and also as a second attempt to unify the various
    available implementations. The most important parts of the new specification focused
    on how chaining Promises should work, making them even more useful and convenient
    to work with.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行了一段时间的实践性实验后，社区确定了 CommonJS Promises/A 的一些限制，并推荐了一些改进方法。结果是创建了 Promises/A+
    规范，作为改进现有规范的一种方式，也是统一各种可用实现的第二次尝试。新规范的最重要部分关注于如何使链接 Promises 工作，使它们更加实用和方便。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the Promises/A+ specification, you can visit [https://promisesaplus.com/](https://promisesaplus.com/).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Promises/A+ 规范的更多信息，您可以访问 [https://promisesaplus.com/](https://promisesaplus.com/)。
- en: Finally, the Promises/A+ specification was published as part of the 6th version
    of JavaScript, commonly referred as ES6, that was released as a standard on June,
    2015\. As a result, Promises/A+ started to be implemented natively in browsers,
    removing the need to use custom third-party libraries and pushing most of the
    existing libraries to upgrade their semantics. As of writing of this book, native
    Promises/A+ compliant implementations have been available in most modern browsers,
    except for IE11, making them available out-of-the-box to more than 65% of web
    users.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，Promises/A+ 规范作为 JavaScript 第 6 版的一部分发布，通常称为 ES6，于 2015 年 6 月发布为标准。因此，Promises/A+
    开始在浏览器中原生实现，不再需要使用自定义的第三方库，并推动大多数现有库升级其语义。截至撰写本书时，几乎所有现代浏览器都提供了原生的 Promises/A+
    兼容实现，除了 IE11，使其可以供超过 65% 的网络用户直接使用。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the adoption of A+ Promises in browsers, you can visit
    [http://caniuse.com/#feat=promises](http://caniuse.com/#feat=promises).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 关于浏览器中采用 A+ Promises 的更多信息，您可以访问 [http://caniuse.com/#feat=promises](http://caniuse.com/#feat=promises)。
- en: 'A rewrite of the `getRandomNumberAsync()` function using the now natively implemented
    ES6 A+ Promises will look as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现在原生实现的 ES6 A+ Promises 重写 `getRandomNumberAsync()` 函数将如下所示：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, ES6 / A+ Promises are created by using the Promise constructor
    function with the `new` keyword. The constructor is invoked with a function as
    a parameter, which makes a closure that has access to both the variables of the
    context that the Promise is created, but also gets access to the `resolve()` and
    `reject()` functions as parameters, which is the only way to change the state
    of the newly created Promise. After the `setTimeout()` function fires its callback,
    the `resolve()` function is invoked with the generated random number as a parameter,
    changing the state of the Promise object to Fulfilled. Finally, the caller of
    our function uses the `then()` method of the returned Promise in exactly the same
    way as we saw in the earlier implementation that was using jQuery.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，ES6 / A+ Promises 是通过使用 Promise 构造函数和 `new` 关键字创建的。构造函数被调用时带有一个函数作为参数，这使得闭包可以访问到
    Promise 被创建的上下文的变量，同时也可以通过参数访问 `resolve()` 和 `reject()` 函数，这是改变新创建的 Promise 状态的唯一方法。在
    `setTimeout()` 函数触发其回调后，将用生成的随机数作为参数调用 `resolve()` 函数，将 Promise 对象的状态更改为已完成。最后，我们函数的调用者使用返回的
    Promise 的 `then()` 方法，方式与我们之前使用 jQuery 的实现完全相同。
- en: Comparing jQuery and A+ Promises
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较 jQuery 和 A+ Promises
- en: We will now have an in-depth step-by-step analysis of the core concepts of the
    jQuery and A+ Promise APIs, by also doing a side-by-side code comparison of the
    two. This can be a great asset to have, since you will also be able to use it
    as a reference while the implementations of Promises are gradually adapting to
    the ES6 A+ specification.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入逐步分析 jQuery 和 A+ Promise API 的核心概念，并通过两者的代码进行逐行对比。这将是一个非常有价值的资料，因为在 Promises
    的实现逐渐适应 ES6 A+ 规范时，你还可以将其作为参考。
- en: The need to understand from the beginning how the two variants differ seems
    even greater, since the jQuery team has already announced that Version 3.0 of
    the library will have Promises/A+ compliant implementation. Specifically, as of
    writing this book, the first beta version is already out, making the time that
    the migration will happen to appear even closer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始就了解这两种变体的差异的需求似乎更为重要，因为 jQuery 团队已经宣布版本 3.0 的库将具有符合 Promises/A+ 规范的实现。具体而言，在编写本书时，第一个
    beta 版本已经发布，这使得迁移的时间似乎更近了。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on jQuery v3.0 A+ Promises implementation, you can visit
    [http://blog.jquery.com/2016/01/14/jquery-3-0-beta-released/](http://blog.jquery.com/2016/01/14/jquery-3-0-beta-released/).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 jQuery v3.0 A+ Promises 实现的更多信息，请访问 [http://blog.jquery.com/2016/01/14/jquery-3-0-beta-released/](http://blog.jquery.com/2016/01/14/jquery-3-0-beta-released/)。
- en: 'One of the most obvious differences between the two implementations is the
    way that new Promises are created. As we saw, jQuery uses the `$.Deferred()` function
    like a factory of a more complex object that provides direct access to the state
    of the Promise and eventually extracts the actual Promise using a separate method.
    On the other hand, A+ Promises use the `new` keyword and a function as a parameter,
    which will be invoked by the runtime with the `resolve()` and `reject()` functions
    as parameters:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 两种实现之间最明显的区别之一是创建新 Promises 的方式。正如我们所见，jQuery 使用 `$.Deferred()` 函数像一个工厂一样创建了一个更复杂的对象，该对象直接提供对
    Promise 状态的访问，并最终使用单独的方法提取实际的 Promise。另一方面，A+ Promises 使用 `new` 关键字和一个函数作为参数，运行时将使用
    `resolve()` 和 `reject()` 函数作为参数调用该函数：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Moreover, jQuery also provides another way to create Promises that look more
    like the way that A+ Promises work. In this case, `$.Deferred()` can be invoked
    with a function as an argument that receives the Deferred object as a parameter:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，jQuery 还提供了另一种创建类似 A+ Promises 工作方式的 Promise 的方法。在这种情况下，`$.Deferred()` 可以被调用，并以函数作为参数，该函数接收
    Deferred 对象作为参数：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we discussed earlier, the second possible outcome of a Promise is to be Rejected,
    a feature that nicely pairs with the classical exceptions of JavaScript in synchronous
    programming. Rejecting a Promise is commonly used for cases where an error occurs
    during the processing of the result, or in situations where the result is not
    valid. While ES6 Promises provide a `reject()` function as an argument to the
    function passed to its constructor, in jQuery's implementation a `reject()` method
    is simply exposed on the Deferred object itself.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的那样，Promise 的第二种可能结果是被 Rejected，这个特性很好地配合了 JavaScript 在同步编程中的经典异常。拒绝一个
    Promise 通常用于在处理结果时发生错误的情况，或者在结果无效的情况下。虽然 ES6 Promises 在其构造函数传递给函数的参数中提供了一个 `reject()`
    函数，但在 jQuery 的实现中，`reject()` 方法仅简单地在 Deferred 对象本身上暴露。
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In both the implementations, the result of a Promise can be retrieved using
    the `then()` method, which can be invoked with two functions as arguments, one
    to handle the case that the Promise gets Fulfilled and one for the case where
    it is Rejected:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种实现中，可以使用 `then()` 方法检索 Promise 的结果，该方法可以用两个函数作为参数调用，一个用于处理 Promise 被 Fulfill
    的情况，另一个用于处理其被 Rejected 的情况：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Both implementations also provide convenient methods to handle the case where
    the Promise gets Rejected, but with different method names. Instead of using `p.then(null,
    fn)`, ES6 Promises provide the `catch()` method that nicely pairs with the try...catch
    JavaScript expression, while jQuery''s implementation provides, for the same purpose,
    the `fail()` method:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 两种实现还提供了方便的方法来处理 Promise 被 Rejected 的情况，但使用不同的方法名。ES6 Promises 提供了 `catch()`
    方法，很好地配合了 try...catch JavaScript 表达式，而 jQuery 的实现则为相同的目的提供了 `fail()` 方法：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Moreover, as a jQuery exclusive feature, jQuery Promises also expose a `done()`
    and an `always()` method. The callbacks provided to `done()` are invoked when
    the Promise gets Fulfilled and is equivalent to using the `then()` method with
    a single parameter, while the callbacks of the `always()` method are invoked when
    the promise gets settled in both possible outcomes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，作为 jQuery 独有的特性，jQuery Promises 还暴露了 `done()` 和 `always()` 方法。提供给 `done()`
    的回调在 Promise 被 Fulfill 时被调用，并且等同于使用带有单个参数的 `then()` 方法，而 `always()` 方法的回调在 Promise
    被 settled 时被调用，无论其结果如何。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on `done()` and `always()`, you can visit [http://api.jquery.com/deferred.done](http://api.jquery.com/deferred.done)
    and [http://api.jquery.com/deferred.always](http://api.jquery.com/deferred.always).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `done()` 和 `always()` 的信息，您可以访问 [http://api.jquery.com/deferred.done](http://api.jquery.com/deferred.done)
    和 [http://api.jquery.com/deferred.always](http://api.jquery.com/deferred.always)。
- en: 'Finally, both implementations provide an easy way to directly create Promises
    that are already Resolved or Rejected. This can be useful as a starting value
    to implement complex synchronization schemes or as an easy way to make synchronous
    functions to operate like asynchronous ones:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，两种实现都提供了一个简单的方法，直接创建已经 Resolved 或 Rejected 的 Promises。这可以作为实现复杂同步方案的起始值，或者作为使同步函数操作像异步函数一样的简单方法：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Advanced concepts
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级概念
- en: Another key concept of Promises that makes them unique and greatly increases
    their usefulness is the ability to easily create compositions of several Promises
    that in turn are Promises themselves. Composition is available in two forms, serial
    composition that chains Promises together and parallel composition that uses special
    methods to join the resolution of concurrent Promises into a new one. As we saw
    earlier in this chapter, implementing such synchronization schemes can be hard
    to implement with the traditional callback approach. Promises, on the other hand,
    try to solve this problem in a more convenient and readable way.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Promises 的另一个关键概念是使它们独特并极大地增加它们的实用性的能力，即轻松创建几个 Promise 的组合，这些 Promise 又是 Promise
    本身。组合有两种形式，串行组合将 Promises 连接在一起，而并行组合则使用特殊方法将并发 Promises 的解决方案合并为一个新的解决方案。正如我们在本章前面看到的那样，使用传统的回调方法很难实现这样的同步方案。另一方面，Promises
    试图以更方便和可读的方式解决这个问题。
- en: Chaining Promises
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接 Promises
- en: Every invocation of the `then()` method returns a new Promise, whose both final
    status and result depends on the Promise that the `then()` method was called on,
    but is also subject to the value returned by the attached callbacks. This allows
    us to chain calls of the `then()` method, enabling us to compose Promises by serially
    joining them. This way, we can easily orchestrate both asynchronous and synchronous
    code, where each chaining step propagates its result to the next one and allows
    us to construct the final result in a readable and declarative way.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`then()`方法都会返回一个新的Promise，其最终状态和结果取决于调用`then()`方法的Promise，但也取决于附加的回调返回的值。这使我们能够通过连续连接它们来组合Promise，从而使我们能够轻松地编排异步和同步代码，其中每个链接步骤将其结果传播到下一个步骤，并允许我们以可读且声明性的方式构建最终结果。
- en: 'Let''s now proceed to analyzing all the different ways that chaining of calls
    to the `then()` method works. Since we will be focusing on the concepts of Promise
    composition by chaining, which works the same as jQuery and ES6 Promises, let''s
    suppose that there is a `p` variable that is holding a Promise object created
    by either of the following lines of code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续分析调用`then()`方法的不同方式。由于我们将专注于通过链式调用进行Promise组合的概念，这与jQuery和ES6 Promises的工作方式相同，所以假设有一个`p`变量，它保存了由以下代码行之一创建的Promise对象：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The simplest use case that demonstrates the power of chaining is when the invoked
    callback returns a (non-promise) value. The newly created Promise uses the returned
    value as its result, while preserving the same state as the Promise that the `then()`
    method was called on:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 展示链接能力的最简单用例是调用的回调返回一个（非promise）值。新创建的Promise使用返回的值作为其结果，同时保留与调用`then()`方法的Promise相同的状态：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A special case to have in mind is that functions that do not return anything
    as a result are handled like returning `undefined`. This essentially removes the
    result value from the newly returned Promise, which now only preserves the parent
    settlement status:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 需要牢记的一个特殊情况是，不返回任何结果的函数会被处理为返回`undefined`。这实质上从新返回的Promise中删除了结果值，现在只保留了父级解决状态：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the case where the invoked callback returns another Promise, its state and
    result are used for the Promise returned by the `then()` method:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用回调函数返回另一个Promise的情况下，其状态和结果将用于由`then()`方法返回的Promise：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code samples demonstrate the implementations for both the jQuery
    and A+ Promises, and both have equivalent results. In both cases, **7** is logged
    into the console from the first `then()` method invocation and a new Promise is
    then returned that will be Resolved at a later time using `setTimeout()`. After
    2000 milliseconds, that `setTimeout()` will fire its callback, the returned Promise
    will be Resolved with `21` as a value and, at that point, `21` will also be logged
    into the console.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码示例演示了jQuery和A+ Promises的实现方式，两者都具有相同的结果。在两种情况下，都从第一个`then()`方法调用中将**7**记录到控制台，并返回一个新的Promise，稍后将使用`setTimeout()`解析它。
    2000毫秒后，`setTimeout()`将触发其回调，返回的Promise将以`21`作为值解析，并在此时，`21`也将记录在控制台中。
- en: 'One extra thing to note is the case where the original Promise gets settled
    and there is no appropriate callback provided to the chained `then()` method.
    In this case, the newly created Promise settles to the same state and result,
    as the Promise where the `then()` method was called on:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件额外需要注意的事情是，原始Promise已经被解决，而且没有为链接的`then()`方法提供适当的回调。在这种情况下，新创建的Promise解决为相同的状态和结果，就像在其中调用`then()`方法的Promise一样：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, the callback with the `console.error` statement that
    is passed as the second argument of the `then()` method, does not get invoked
    since the Promise is resolved with 7 as its value. As a result, the callback of
    the chain eventually receives a new Promise, which is also resolved with `7` as
    its value and logs that in the console. Something to have in mind in order to
    deeply understand how chaining of Promises works, is that `p != p.then()` in all
    cases.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，作为`then()`方法的第二个参数传递的具有`console.error`语句的回调不会被调用，因为Promise解析为7作为其值。结果，链的回调最终接收到一个新的Promise，该Promise也以`7`作为其值解析并在控制台中记录。要深入了解Promise链式调用的工作原理，有一件事需要牢记，即在所有情况下`p
    != p.then()`。
- en: Handling thrown errors
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理抛出的错误
- en: The final concept of chaining defines the case where exceptions are thrown during
    the invocation of a `then()` callback. The Promise/A+ specification defined that
    the newly created Promise is Rejected and that its result is the `Error` that
    was thrown. Moreover, the Rejection will bubble through the entire chain of Promises,
    enabling us to be notified about any error in the chain only defining the error
    handling once, near to the end of the chain.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 链接的最终概念定义了在调用 `then()` 回调时抛出异常的情况。Promise/A+ 规范定义了新创建的 Promise 被拒绝，其结果是抛出的 `Error`。此外，拒绝将在整个
    Promise 链中传播，使我们能够仅在链的末尾附近定义错误处理，就能得到有关链中任何错误的通知。
- en: 'Unfortunately, this is not consistent in the implementation of the latest stable
    version of jQuery, which as of the writing of this book is v2.2.0:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这在撰写本书时最新稳定版本的 jQuery 中并不一致，该版本为 v2.2.0：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the first case, the exception that is thrown stops the execution of the Promise
    chain. The only way around it is probably explicitly adding a try...catch statement
    inside the callback that is passed to the `then()` method, as shown in the second
    case that is demonstrated.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，抛出的异常会停止 Promise 链的执行。唯一的解决方法可能是在传递给 `then()` 方法的回调中显式添加 try...catch
    语句，如所示的第二种情况所示。
- en: Joining Promises
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入 Promise
- en: 'The other way of orchestrating Promises that run concurrently is by composing
    them together. As an example, let''s suppose the existence of two Promises, p1
    and p2, that get resolved with 7 and 11 as their values, after 2000 and 3000 milliseconds,
    respectively. Since these two Promises are executed concurrently, the composed
    Promise will only need 3000 milliseconds to get Resolved, as it is the greater
    of the two durations:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种并发执行 Promise 的编排方式是将它们组合在一起。举个例子，假设存在两个 Promise，p1 和 p2，在分别经过 2000 和 3000
    毫秒后以 7 和 11 作为它们的值被解决。由于这两个 Promise 是同时执行的，所以组合后的 Promise 只需要 3000 毫秒就能被解决，因为它是这两个持续时间中较大的一个：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Both Promise APIs provide a specialized function that allows us to easily create
    Promise compositions and also retrieve the individual results of the composition.
    A composed Promise gets Resolved when all its parts get Resolved, while it gets
    Rejected when any one of its parts gets Rejected. Unfortunately, the two Promise
    APIs differ, not only by the name of the functions, but also by the way they are
    invoked and the way they provide their results.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 两种 Promise API 都提供了一个专门的函数，允许我们轻松创建 Promise 组合并检索组合的单个结果。当所有部分都被解决时，组合后的 Promise
    被解决，而当任何一个部分被拒绝时，它被拒绝。不幸的是，这两种 Promise API 不仅在函数的名称上有所不同，而且在调用方式和提供结果的方式上也有所不同。
- en: The jQuery implementation provides the `$.when()` method that can be invoked
    with any number of arguments that we want to be composed. By using the `then()`
    method on a composed jQuery Promise, we can get notified when the composition
    gets settled as a whole and also access each individual result as arguments of
    our callback.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 实现提供了 `$.when()` 方法，可以用任意数量的参数来调用它们要组合的内容。通过在组合后的 jQuery Promise 上使用
    `then()` 方法，我们可以在组合作为整体时得到通知，并访问每个单独的结果作为回调的参数。
- en: On the other hand, the A+ Promises specification provides us the `Promise.all()`
    method that is invoked with an array as its single parameter that contains all
    the Promises that we want to get composed. The returned composed Promise does
    not differ at all from the Promises that we have seen so far and the callback
    of the `then()` method is invoked with an array as its parameter, which contains
    all the results of the Promises that are part of the composition.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，A+ Promise 规范为我们提供了 `Promise.all()` 方法，它用一个数组作为其单个参数调用，该数组包含我们要组合的所有 Promise。返回的组合
    Promise 与我们迄今为止看到的 Promise 没有任何区别，并且 `then()` 方法的回调以一个数组作为其参数被调用，该数组包含组合中所有 Promise
    的结果。
- en: How jQuery uses Promises
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery 如何使用 Promise
- en: At the time that jQuery added an implementation of Promises to its API, it also
    started to expose it through other asynchronous methods of its API. Perhaps the
    most well-known example of this kind is the method of the `$.ajax()` family that
    returns a jqXHR object, which is a specialized Promise object that also provides
    some extra methods related to the AJAX request.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jQuery 添加 Promise 实现到其 API 后，它还开始通过其 API 的其他异步方法来公开它。也许最著名的例子就是 `$.ajax()`
    系列方法，它返回一个 jqXHR 对象，这是一个专门的 Promise 对象，还提供了一些与 AJAX 请求相关的额外方法。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the jQuery's `$.ajax()` method and the jqXHR object,
    you can visit [http://api.jquery.com/jQuery.ajax/#jqXHR](http://api.jquery.com/jQuery.ajax/#jqXHR).
    The jQuery team also decided to change the implementation of several internal
    parts of the library to use Promises, in order to improve their implementations.
    First of all, the `$.ready()` method is implemented using Promises so that the
    provided callbacks fire even if the page has already been loaded a long time before
    its invocation. Also, some of the complex animations that jQuery provides use
    Promises internally as the preferred way to synchronize the execution of the sequential
    parts of the animation queue.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 jQuery 的 `$.ajax()` 方法和 jqXHR 对象的更多信息，您可以访问 [http://api.jquery.com/jQuery.ajax/#jqXHR](http://api.jquery.com/jQuery.ajax/#jqXHR)。jQuery
    团队还决定更改库的几个内部部分的实现以使用 Promises，以改进其实现。首先，`$.ready()` 方法使用 Promises 实现，以便提供的回调即使在其调用之前页面已加载很长时间也会触发。此外，jQuery
    提供的一些复杂动画内部使用 Promises 作为动画队列的顺序部分执行的首选方式。
- en: Transforming Promises to other types
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Promises 转换为其他类型
- en: Developing by using several different JavaScript libraries often makes many
    Promise implementations available to our projects that unfortunately tend to have
    different levels of compliance to the reference Promises specification. Composing
    Promises returned by the methods of different libraries can often lead to problems
    that are hard to track and resolve, as a result of their implementation inconsistencies.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个不同的 JavaScript 库进行开发往往会使得我们的项目中出现多种 Promise 实现，而不幸的是，它们往往对参考 Promises 规范的遵从程度不同。组合不同库方法返回的
    Promise 往往会导致难以跟踪和解决的问题，因为它们的实现不一致。
- en: In order to avoid confusions in such situations, it isn't considered a good
    practice to transform all the Promises to a single type before attempting to compose
    them. The suggested type for such situations is the Promises/A+ specification,
    since not only is it widely accepted by the community but it is also part of the
    newly released version of JavaScript (the ES6 language specification) that is
    already natively implemented in many browsers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在这种情况下造成混淆，不建议在尝试组合它们之前将所有 Promises 转换为单一类型。对于这种情况，建议使用 Promises/A+ 规范，因为它不仅被社区广泛接受，而且还是
    JavaScript 的新发布版本（ES6 语言规范）的一部分，已经在许多浏览器中本地实现。
- en: Transforming to Promises/A+
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换为 Promises/A+
- en: 'For example, let''s see how a jQuery Promise can be transformed to an A+ Promise
    that is available in most recent browsers:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看如何将 jQuery Promise 转换为大多数最新浏览器中可用的 A+ Promise：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding example, the `Promise.resolve()` method detects that it has
    been invoked with a "thenable" and that the newly created A+ Promise that is returned
    binds its status and result to those of the provided jQuery Promise. This is essentially
    equivalent to doing something as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`Promise.resolve()` 方法检测到它已被调用并带有一个 "thenable"，并且新创建的 A+ Promise 将其状态和结果绑定到所提供的
    jQuery Promise 的状态和结果。这本质上相当于执行以下操作：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Of course, this is not limited to Promises that are created by direct invocations
    of the `$.Deferred()` method. The above technique can also be used to transform
    Promises that are returned by any jQuery method. For example, this is how it can
    be used with the `$.getJSON()` method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不仅限于通过直接调用 `$.Deferred()` 方法创建的 Promises。上述技术也可以用于转换由任何 jQuery 方法返回的 Promises。例如，以下是它与
    `$.getJSON()` 方法的使用方式：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Transforming to jQuery Promises
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换为 jQuery Promises
- en: 'Even though I would generally not recommend this, it is also possible to transform
    any Promise to a jQuery variant. The newly created jQuery Promise receives all
    the extra functionalities that jQuery provides, but the transformation is not
    as straightforward as the previous one:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我通常不建议这样做，但也有可能将任何 Promise 转换为 jQuery 变体。新创建的 jQuery Promise 接收 jQuery 提供的所有额外功能，但转换不像前一个那么直接：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You should only use the preceding technique in cases where you need to extend
    a big web application that is already implemented using jQuery Promises. On the
    other hand, you should also consider upgrading such implementations, since the
    jQuery team has already announced that Version 3.0 of the library will have Promises/A+
    compliant implementation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在需要扩展已使用 jQuery Promises 实现的大型 Web 应用程序的情况下，才应使用上述技术。另一方面，您还应考虑升级此类实现，因为 jQuery
    团队已经宣布库的 3.0 版本将具有 Promises/A+ 兼容的实现。
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on jQuery v3.0 A+ Promises implementation, you can visit
    [http://blog.jquery.com/2016/01/14/jquery-3-0-beta-released/](http://blog.jquery.com/2016/01/14/jquery-3-0-beta-released/).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关 jQuery v3.0 A+ Promises 实现的更多信息，您可以访问 [http://blog.jquery.com/2016/01/14/jquery-3-0-beta-released/](http://blog.jquery.com/2016/01/14/jquery-3-0-beta-released/)。
- en: Summarizing the benefits of Promises
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结 Promise 的好处
- en: 'Overall, the benefits of using Promises over plain Callbacks include:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，使用 Promises 而不是简单的回调的好处包括：
- en: Having a unified way to handle the result of asynchronous invocations
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个统一的方法来处理异步调用的结果
- en: Having predictable invocation parameters for the used callbacks
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用于使用回调的可预测的调用参数
- en: The ability to attach multiple handlers for each outcome of the Promise
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Promise 的每个结果附加多个处理程序的能力
- en: The guarantee that the appropriate attached handlers will execute even if the
    Promise has already been Resolved (or Rejected)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使 Promise 已经被解析（或拒绝），也保证适当的附加处理程序将执行
- en: The ability to chain asynchronous operations, making them run in order
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接异步操作的能力，使它们按顺序运行
- en: The ability to easily create compositions of asynchronous operations, making
    them run concurrently
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松创建异步操作的组合，使它们并发运行的能力
- en: The convenient way of handling errors in Promise chains
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 Promise 链中错误的便捷方式
- en: Using a method that returns a Promise removes the need to directly pass functions
    of one context to another as an invocation argument and the question regarding
    which parameters are used as the success and the error Callbacks. Moreover, we
    already know to some degree how to retrieve the result of any operation that returns
    a Promise, by using the `then()` method, even before reading the documentation
    about the method's invocation parameters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用返回 Promise 的方法消除了直接将一个上下文的函数传递给另一个上下文作为调用参数以及哪些参数用作成功和错误回调的问题。此外，我们在阅读关于方法调用参数的文档之前，已经在一定程度上了解到了如何获取返回
    Promise 的任何操作的结果，通过使用 `then()` 方法。
- en: Less parameters often means less complexity, smaller documentation, and less
    searching every time we want to do a method invocation. Even better, there is
    a good chance that there will only be a single or a few parameters, making the
    invocation more sensible and readable. The implementation of asynchronous methods
    also becomes less complex, since there is no longer the need to accept callback
    functions as an extra argument or having to properly invoke them with the result.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 较少的参数通常意味着较少的复杂性、更小的文档和每次想要执行方法调用时的搜索量较少。更好的是，很有可能只有一个或几个参数，使得调用更加合理和可读。异步方法的实现也变得更加简单，因为不再需要接受回调函数作为额外参数或者需要正确地使用结果来调用它们。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we analyzed the development patterns that are used to program
    asynchronous and concurrent procedures. We also learned how to use them to efficiently
    orchestrate the execution of asynchronous procedures that run either in order
    or parallel to each other.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了用于编写异步和并发过程的开发模式。我们还学习了如何有效地编排执行按顺序或并行运行的异步过程。
- en: At first, we had a refresher on how Callbacks are used in JavaScript programming
    and how they are an integral part of web development. We analyzed their benefits
    and limitations when used in large and complex implementations.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们对 JavaScript 编程中如何使用回调进行了复习，并且了解了它们是 Web 开发的一个组成部分。我们分析了在大型和复杂实现中使用它们时的好处和局限性。
- en: Right after this, we were introduced to the concepts of Promises. We learned
    how jQuery's Deferred and Promise APIs work and how they differ from ES6 Promises.
    We also saw where and how they are used internally by jQuery itself, as an example
    of how they can lead to more readable code and simplify such complex implementations.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 就在这之后，我们介绍了 Promise 的概念。我们学习了 jQuery 的 Deferred 和 Promise API 的工作原理，以及它们与 ES6
    Promises 的区别。我们还看到了它们在 jQuery 内部的使用位置和方式，作为它们如何导致更可读的代码并简化这样复杂实现的一个例子。
- en: In the next chapter, we will proceed to learning how to design, create, and
    use MockObjects and Mock Services in our applications. We will analyze the characteristics
    that a proper Mock Object should have and understand how they can be used as representative
    use cases and even as test cases for our code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续学习如何在我们的应用程序中设计、创建和使用 MockObjects 和 Mock Services。我们将分析一个适当的 Mock
    对象应该具有的特征，并了解它们如何被用作代表性用例甚至是我们代码的测试用例。
