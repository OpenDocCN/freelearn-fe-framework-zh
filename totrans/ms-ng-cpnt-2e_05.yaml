- en: Component-Based Routing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于组件的路由
- en: 'Routing is an integral part of today''s frontend applications. In general,
    a router serves three main purposes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是当今前端应用程序的一个基本组成部分。一般来说，一个路由器有三个主要用途：
- en: It makes your application navigable so that users can use their browser's back
    button and store and share links within the application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使您的应用程序可导航，以便用户可以使用浏览器的后退按钮，并在应用程序中存储和共享链接
- en: It offloads parts of the application composition so that the router takes responsibility
    for composing your application, based on routes and route parameters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将应用程序组合的部分卸载，以便路由器根据路由和路由参数负责组合您的应用程序
- en: It stores part of your application state within the URL of your browser
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将您应用程序的部分状态存储在浏览器URL中
- en: The router that comes with Angular supports many different use-cases, and it
    comes with an easy-to-use API. It supports child routes that are similar to the
    Angular UI-Router nested states, Ember.js nested routes or child routers in the
    Durandal framework. Tied to the component tree, the router also makes use of its
    own tree structure to store states and to resolve requested URLs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随Angular一起提供的路由器支持许多不同的用例，并附带一个易于使用的API。它支持与Angular UI-Router嵌套状态、Ember.js嵌套路由或Durandal框架中的子路由类似的子路由。与组件树相关联的路由器还利用其自己的树结构来存储状态和解析请求的URL。
- en: In this chapter, we will refactor our code to use the component-based router
    of Angular. We will look into the core elements of the router and how to use them
    to enable routing in our application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重构我们的代码以使用Angular的基于组件的路由器。我们将探讨路由器的核心元素以及如何使用它们来在我们的应用程序中启用路由。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducting to the Angular router
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Angular路由器
- en: The router, container, and pure components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器、容器和纯组件
- en: An overview of the refactoring needed to enable the router in our application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述在应用程序中启用路由所需的重构
- en: Creating a route configuration file and look into different route configuration
    possibilities
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建路由配置文件并探讨不同的路由配置可能性
- en: Using the `RouterOutlet` directive to create insertion points that are controlled
    by the router
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RouterOutlet`指令创建由路由器控制的插入点
- en: Using the `RouterLink` directive and the router DSL to create navigation links
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RouterLink`指令和路由器DSL创建导航链接
- en: Using reactive router properties to obtain route parameters
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应式路由属性来获取路由参数
- en: Using both the `RouterActive` directive as well as the programmatic router API
    for reacting to activated route paths
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RouterActive`指令以及程序化路由器API来响应激活的路由路径
- en: Programmatically navigate using the router API
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路由器API进行编程导航
- en: Creating a route guard for the project container
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为项目容器创建路由守卫
- en: An introduction to the Angular router
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular路由器的介绍
- en: The router in Angular is closely coupled to our component tree. The design of
    the Angular router is built on the assumption that a component tree is directly
    related to our URL structure. This is certainly true for most of the cases. If
    we have a component **B**, which is nested within a component **A**, the URL to
    represent our location would very likely be `/a/b`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的路由器与我们的组件树紧密耦合。Angular路由器的设计基于这样的假设：组件树直接与我们的URL结构相关。这在大多数情况下都是正确的。如果我们有一个组件**B**，它嵌套在组件**A**中，表示我们位置的URL很可能就是`/a/b`。
- en: To specify the location in our template where we'd like to enable the router
    to instantiate components, we can use so-called `outlets`. Simply by including
    a `<router-outlet>` element, we can mark the location in our template, where the
    Angular router will instantiate components.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定模板中我们希望启用路由实例化组件的位置，我们可以使用所谓的`outlets`。只需包含一个`<router-outlet>`元素，我们就可以标记模板中的位置，Angular路由器将在该位置实例化组件。
- en: Based on some route configuration that we can provide in our main module, the
    router then decides which components need to be instantiated and placed into the
    corresponding router outlets. Routes can also be parameterized, and we can access
    these parameters within the instantiated components.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们可以在主模块中提供的某些路由配置，路由器随后决定哪些组件需要实例化并放置到相应的路由出口中。路由也可以参数化，我们可以在实例化的组件中访问这些参数。
- en: 'Using our component tree and the router configuration, we can build a hierarchical
    routing and decouple child routes from their parent routes. Such nested routes
    make it possible to compose our application layout on a meta level and reuse parent
    components for multiple child routes. By using the router we can add another layer
    of composition to our application. Take a look at the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的组件树和路由配置，我们可以构建分层路由，并使子路由与其父路由解耦。这种嵌套路由使得在元级别上组合我们的应用程序布局成为可能，并可以重用父组件以供多个子路由使用。通过使用路由器，我们可以为我们的应用程序添加另一层组合。请看以下图表：
- en: '![](img/7b7e177b-427c-4de1-b47c-ab9676a0e55f.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b7e177b-427c-4de1-b47c-ab9676a0e55f.png)'
- en: Router hierarchy established through a component tree and router outlet
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组件树和路由出口建立的路由层次
- en: 'Let''s look at the elements of the router again in more detail:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次更详细地看看路由器的元素：
- en: '**Route configuration**: The route configuration is done while importing the
    router into our application module. By configuring child routes, we can build
    decoupled nested routes easily.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由配置**：在将路由导入我们的应用程序模块时进行路由配置。通过配置子路由，我们可以轻松地构建解耦的嵌套路由。'
- en: '**Router outlets**: Outlets are the locations of components that will be managed
    by the router. Instantiated components that are based on the route configuration
    will be placed into these outlets.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由出口**：出口是路由器将管理的组件的位置。基于路由配置实例化的组件将被放置到这些出口中。'
- en: '**Router link**: These are links built with a DSL style notation that enable
    the developer to build complex links through the routing tree.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由链接**：这些是用DSL风格符号构建的链接，使开发者能够通过路由树构建复杂的链接。'
- en: Within this chapter, we'll go through these different concepts of the Angular
    router and refactor our application to implement proper routing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Angular路由的不同概念，并重构我们的应用程序以实现适当的路由。
- en: Composition using the router
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由进行组合
- en: So far, we have achieved composition by including subcomponents in component
    templates directly. However, we'd now like to give the control to the router to
    compose our main application layout.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过在组件模板中直接包含子组件来实现组合。然而，我们现在希望将控制权交给路由器来组合我们的主要应用程序布局。
- en: 'The following diagram provides an overview of the component architecture of
    our application, which we''re going to enable for the router:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表提供了我们应用程序组件架构的概述，我们将为路由器启用它：
- en: '![](img/a4a7e86b-2a32-45c7-bf63-26d0fb34d6a3.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4a7e86b-2a32-45c7-bf63-26d0fb34d6a3.png)'
- en: A component tree displaying routed container components (solid line) and components
    included via router outlets
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 显示路由容器组件（实线）和通过路由出口包含的组件的组件树
- en: After the changes that we're going to implement, the project container component
    is not directly included in our app component anymore. Instead, we use a router
    outlet in the template of our app component. This way, we can give control to
    the router and let it decide which component should be placed into the outlet.
    Currently, we only have the project component as a first-level route, but this
    will change in later chapters when we add more features to our application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们即将实施的变化之后，项目容器组件不再直接包含在我们的应用程序组件中。相反，我们在应用程序组件的模板中使用路由出口。这样，我们可以将控制权交给路由器，让它决定哪个组件应该放置到出口中。目前，我们只有项目组件作为一级路由，但在后续章节中，当我们为应用程序添加更多功能时，这将会改变。
- en: The project component will contain another router outlet, which enables us to
    do nested child routing. There, we'll be able to create child routings that enable
    us to switch between the different project detail views.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 项目组件将包含另一个路由出口，这使我们能够进行嵌套子路由。在那里，我们将能够创建子路由，使我们能够在不同的项目详情视图之间切换。
- en: Routing with container components
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器组件进行路由
- en: The composition that we've dealt with so far was purely based on instantiation
    via template inclusion. We used input and output properties to decouple and encapsulate
    components and followed nice reusable patterns.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止处理过的组合完全是基于通过模板包含的实例化。我们使用了输入和输出属性来解耦和封装组件，并遵循了良好的可重用模式。
- en: Using the router, which instantiates components dynamically, we can't use template
    bindings on routed components anymore. While we previously relied on input and
    output properties to connect our components together, we're losing this possibility
    by using the router and we can't bind to inputs or outputs any longer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态实例化组件的路由器，我们不能再在路由组件上使用模板绑定。虽然我们之前依赖于输入和输出属性来连接我们的组件，但使用路由器后，我们失去了这种可能性，不能再绑定到输入或输出。
- en: 'Luckily, we already know about the concept of container components. Container
    components connect our state and data to our user interface components. They should
    not have any input or output properties and act as top-level components. They
    are by definition the perfect candidates for routed components:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经了解了容器组件的概念。容器组件将我们的状态和数据连接到我们的用户界面组件。它们不应该有任何输入或输出属性，并作为顶级组件。它们是定义上完美的路由组件候选者：
- en: Since container components don't rely on input or output properties, they will
    work out-of-the-box when instantiated by the router
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于容器组件不依赖于输入或输出属性，它们在由路由器实例化时将直接工作。
- en: We can simply consider the router as a different source for state and pass down
    information from the URL state into our UI components
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以简单地将路由器视为一个不同的状态源，并将URL状态信息传递到我们的UI组件中
- en: Router configuration
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器配置
- en: Angular uses tree data structures to represent the router state. You can imagine
    that every navigation in your application activates a branch in this tree. Let's
    look at the following example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用树形数据结构来表示路由状态。你可以想象，在你的应用程序中，每次导航都会激活这个树中的一个分支。让我们看看以下示例。
- en: 'We have an application that consists of four possible routes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个由四个可能的路由组成的应用程序：
- en: '`/`: This is the root route of the application, which is handled in a component
    called **A**.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`：这是应用程序的根路由，由称为**A**的组件处理。'
- en: '`/b/:id`: This is the route where we can access the `b` detail view, which
    is handled in a component called **B**. In the URL, we can pass an `id` parameter
    (that is, `/b/100`).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/b/:id`：这是我们可以访问`b`详细视图的路由，该视图由称为**B**的组件处理。在URL中，我们可以传递一个`id`参数（即`/b/100`）。'
- en: '`/b/:id/c`: This is the route where the `b` detail view has another navigation
    possibility, which reveals more specific details that we call `c`. This is handled
    in a **C** component.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/b/:id/c`：这是`b`详细视图有另一个导航可能性的路由，它揭示了更具体的细节，我们称之为`c`。这由**C**组件处理。'
- en: '`/b/:id/d`: This is the route where we can also navigate to a `d` view in the
    `b` detail view. This is handled by a component called **D**:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/b/:id/d`：这是我们可以导航到`b`详细视图中的`d`视图的路由。这由称为**D**的组件处理：'
- en: '![](img/85ced9be-72d3-499c-988e-7493576774b9.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/85ced9be-72d3-499c-988e-7493576774b9.png)'
- en: A route tree consisting of an active branch of route segments for the activated
    route /b/100/d
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由激活路由 /b/100/d 的路由段组成的路由树
- en: Let's assume that we activate a route in our example by navigating the URL,
    `/b/100/d`. In this case, we'd activate a route that reflects the state that is
    outlined in the preceding diagram. Note that the route segment **B** actually
    consists of two URL segments. The reason for this is that we've specified that
    our route **B** actually consists of the `b` identifier and an `:id` route parameter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们通过导航URL `/b/100/d` 在我们的示例中激活一个路由。在这种情况下，我们会激活一个反映前面图中概述的状态的路由。请注意，路由段**B**实际上由两个URL段组成。这是因为我们指定了我们的路由**B**实际上由`b`标识符和一个`:id`路由参数组成。
- en: Using this tree data structure, we have a perfect abstraction to deal with navigation
    trees. We can compare trees, check whether certain segments exist in a tree, and
    extract parameters present on activated routes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种树形数据结构，我们有一个完美的抽象来处理导航树。我们可以比较树，检查某些段是否存在于树中，并提取激活路由上存在的参数。
- en: 'Within each routed component, we have the possibility to inject the activated
    route of that level. Let''s assume we''d want to access the `:id` parameter from
    the URL within component **B**. We can inject the `ActivatedRoute` into the constructor
    of our component and extract the route parameter from there by using the following
    code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个路由组件内部，我们有注入该级别激活路由的可能性。假设我们想在组件**B**中访问`:id`参数。我们可以将`ActivatedRoute`注入到我们组件的构造函数中，并使用以下代码从那里提取路由参数：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Angular router reuses component instances by default. This means that if
    the router is activating the same component again but with different parameters,
    Angular is not destroying the previous component instance. It re-uses the previous
    instance and provides the updated parameters to our component. That's the reason
    why the `params` property on the `ActivatedRoute` object is an observable stream.
    We can simply subscribe to this observable, which allows us to react on route
    parameter changes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular 路由器会重用组件实例。这意味着如果路由器再次激活相同的组件但带有不同的参数，Angular 不会销毁之前的组件实例。它会重用之前的实例，并将更新的参数提供给我们的组件。这就是为什么
    `ActivatedRoute` 对象上的 `params` 属性是一个可观察的流。我们可以简单地订阅这个可观察的流，这允许我们对路由参数的变化做出反应。
- en: As you can see, the router API is quite flexible, and it allows us to inspect
    route activity on a very fine granularity. The tree structures that are used in
    the router make it possible to compare complex router states in our application
    without bothering about the underlying complexity.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，路由器 API 非常灵活，它允许我们以非常细粒度的方式检查路由活动。路由器中使用的树结构使得我们可以在不担心底层复杂性的情况下比较应用程序中的复杂路由状态。
- en: Back to the routes
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到路由
- en: 'All right, now it''s time to implement routing for our application! In the
    upcoming topics, we''ll create the following routes for our application:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是我们为应用程序实现路由的时候了！在接下来的主题中，我们将为我们的应用程序创建以下路由：
- en: '| **Route path** | **Description** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **路由路径** | **描述** |'
- en: '| --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `/projects/:projectId` | This route will activate the project container component
    in the outlet of our root application component. This consists of the `projects`
    URL segment as well as the `:projectId` URL segment to specify the project ID.
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `/projects/:projectId` | 此路由将在我们的根应用程序组件的出口中激活项目容器组件。这包括 `projects` URL 段以及
    `:projectId` URL 段来指定项目 ID。|'
- en: '| `/projects/:projectId/tasks` | This route will activate the `TaskListContainer`
    component inside of our project component. While we''re currently rendering the
    task list directly within the template of the project component, we will make
    use of an other router outlet instead. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `/projects/:projectId/tasks` | 此路由将在我们的项目组件内部激活 `TaskListContainer` 组件。虽然我们目前直接在项目组件的模板中渲染任务列表，但我们将使用另一个路由出口。|'
- en: '| `/projects/:projectId/comments` | This route will activate the `ProjectCommentsContainer`
    component inside of our project component. The same router outlet within the project
    component is used to instantiate the project comments container component. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `/projects/:projectId/comments` | 此路由将在我们的项目组件内部激活 `ProjectCommentsContainer`
    组件。项目组件中的相同路由出口用于实例化项目评论容器组件。|'
- en: You can directly relate the preceding route configuration to the composition
    illustrated within the diagram of the previous topic, *Composition using the router*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接将前面的路由配置与之前主题中图示的组成联系起来，*使用路由进行组成*。
- en: 'To use the router of Angular, the first thing that we need to do is to create
    a route configuration. Let''s create a new file on the path `src/app/routes.ts`
    and add our initial route configuration, using this code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Angular 的路由器，我们首先需要做的是创建一个路由配置。让我们在路径 `src/app/routes.ts` 上创建一个新文件，并添加我们的初始路由配置，使用以下代码：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the moment we'll only configure the route for projects and add the child
    routes to project comments and tasks later.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只将为项目配置路由，稍后会将子路由添加到项目评论和任务中。
- en: The `path` property within our route configuration objects is used as a pattern
    to match against the URL in the browser. The router will observe URL changes in
    the browser and then try to match each path in our configuration against the new
    URL.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的路由配置对象中，`path` 属性被用作模式来匹配浏览器中的 URL。路由器将观察浏览器中的 URL 变化，然后尝试将我们的配置中的每个路径与新的
    URL 进行匹配。
- en: The Angular router will always match with a "first match wins" strategy. This
    means that you can have configuration scenarios where more than one configuration
    results in a match. However, only the first matching configuration within the
    list will be activated.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 路由器始终采用“首次匹配获胜”的策略。这意味着你可以有配置场景，其中多个配置结果都匹配。然而，只有列表中第一个匹配的配置会被激活。
- en: With the component property in our route configuration, we can tell Angular
    which component should be instantiated when a specific route is activated.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的路由配置中的组件属性，我们可以告诉 Angular 当激活特定路由时应实例化哪个组件。
- en: For our project route, we're also using a parameter segment to pass the ID of
    the project we want to display.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目路由，我们也使用一个参数段来传递我们想要显示的项目ID。
- en: The second route in our configuration is a special route that will redirect
    users to the first project within our project list when they enter our app on
    the root URL (`http://localhost:4200/` in the case of our development server).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置中的第二个路由是一个特殊路由，当用户在根URL（在我们的开发服务器的情况下是`http://localhost:4200/`）进入我们的应用程序时，它将用户重定向到我们的项目列表中的第一个项目。
- en: In redirect route configurations we can omit the `component` property but specify
    a `redirectTo` property to tell Angular that we'd like to redirect the user to
    a different URL. Within redirect routes, you always need to specify how you want
    to match the URL path. By default, Angular matches using a prefix match strategy.
    However, in many situations, you want to match the whole URL and not only a prefix.
    You can use the `pathMatch` property and set it to the value `'full'` for this
    purpose.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在重定向路由配置中，我们可以省略`component`属性，但指定`redirectTo`属性来告诉Angular我们希望将用户重定向到不同的URL。在重定向路由中，你始终需要指定你想要如何匹配URL路径。默认情况下，Angular使用前缀匹配策略进行匹配。然而，在许多情况下，你想要匹配整个URL，而不仅仅是前缀。你可以使用`pathMatch`属性并将其设置为`'full'`来实现这一点。
- en: By specifying an empty path pattern, we can tell Angular to activate a route
    when there's an empty path segment within the browser's URL. However, when using
    the default prefix match strategy, this pattern will always result in a match.
    It's only when we set the `pathMatch` property to `'full'`, that we can cause
    a match when the user navigates to the root URL.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定一个空路径模式，我们可以告诉Angular当浏览器URL中有空路径段时激活一个路由。然而，当使用默认的前缀匹配策略时，这个模式总是会匹配。只有当我们将`pathMatch`属性设置为`'full'`时，我们才能在用户导航到根URL时引起匹配。
- en: 'Okay, let''s move on and include the router within our application. We can
    use the router configuration that we''ve just created to initialize the Angular
    router. Let''s open up our main module located on the path `src/app/app.module.ts`
    and apply the following changes. Irrelevant code parts that did not change are
    hidden from the code excerpt and are marked with an ellipsis character. The effective
    changes within the code are marked in bold:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续，并在我们的应用程序中包含路由器。我们可以使用我们刚刚创建的路由配置来初始化Angular路由。让我们打开位于路径`src/app/app.module.ts`上的主模块，并应用以下更改。未更改的不相关代码部分在代码摘录中隐藏，并用省略号字符标记。代码中的有效更改用粗体标出：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code's changes to our main model, we're simply importing the
    routes configuration we've prepared and the Angular router module from `@angular/router`.
    By calling the module factory function `RouterModule.forRoot` we can pass our
    route configuration to the router and import the resulting router module into
    our application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在对主模型进行的前置代码更改中，我们只是简单地从`@angular/router`导入了我们准备的路由配置和Angular路由模块。通过调用模块工厂函数`RouterModule.forRoot`，我们可以将我们的路由配置传递给路由器，并将生成的路由模块导入到我们的应用程序中。
- en: That was easy! You've successfully created your first route configuration and
    included the router in your application. When you preview your changes and reload
    your browser, you should already see the redirect configuration kicking in. Your
    browser URL should be relocated to `http://localhost:4200/projects/0`. However,
    we don't leverage the compositional features of the router yet and our project
    navigation needs to be changed too.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！你已经成功创建了你的第一个路由配置，并将路由器包含在了你的应用程序中。当你预览你的更改并重新加载浏览器时，你应该已经看到重定向配置开始生效。你的浏览器URL应该被重定向到`http://localhost:4200/projects/0`。然而，我们还没有利用路由器的组合功能，我们的项目导航也需要进行更改。
- en: Composing projects using the router
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由器组合项目
- en: 'We''ve already prepared the route configuration for navigating our projects.
    The next step is to enable the router to handle the composition of projects correctly
    based on user navigation. Together, we''ll execute the following three steps to
    achieve this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为导航我们的项目准备了路由配置。下一步是使路由器能够根据用户导航正确处理项目的组合。我们将一起执行以下三个步骤来实现这一点：
- en: Using the `<router-outlet>` element within our root component to allow the router
    to place instantiated components.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的根组件中使用`<router-outlet>`元素，允许路由器放置实例化组件。
- en: Using the router link directives to make our project navigation work with the
    router.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用路由链接指令使我们的项目导航与路由器协同工作。
- en: Getting rid of the selected project state in our project service and instead
    rely on the URL state, which now includes the project ID of the navigated project.
    We can then refactor our project container component to make use of this route
    parameter.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的项目服务中移除选中的项目状态，转而依赖 URL 状态，该状态现在包括导航项目的项目 ID。然后我们可以重构我们的项目容器组件以利用这个路由参数。
- en: Let's start with the template of our root component. Currently, we're including
    the project container component within the template directly. Since we'd want
    to give control to the router to determine which component will be visible to
    the user, we need to change that and include a `<router-outlet>` in the template
    instead.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从根组件的模板开始。目前，我们直接在模板中包含项目容器组件。由于我们希望让路由决定哪个组件对用户可见，我们需要进行更改，并在模板中包含一个 `<router-outlet>`。
- en: 'Let''s open the template of our root component, which is located in `src/app/app.component.html`,
    and apply the following changes. Again, the ellipsis symbol indicates irrelevant
    code parts that remain the same:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开根组件的模板，它位于 `src/app/app.component.html`，并应用以下更改。同样，省略号符号表示保持不变的无关代码部分：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have removed the static inclusion of the project container component and
    added a router outlet element. This way the Angular router knows that it should
    instantiate activated components at this location within our template.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经移除了项目容器组件的静态包含，并添加了一个路由出口元素。这样 Angular 路由就知道它应该在模板的这个位置实例化激活的组件。
- en: 'The next thing on our list is to use the router link directives in order to
    enable project navigation. Luckily we''re already in the right place to perform
    this change. The project navigation is part of the root component template and
    we need to add the router link directives there. Within the template `src/app/app.component.html`,
    we perform the following changes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表上的下一件事是使用路由链接指令来启用项目导航。幸运的是，我们已经在正确的位置进行这个更改。项目导航是根组件模板的一部分，我们需要在那里添加路由链接指令。在模板
    `src/app/app.component.html` 中，我们执行以下更改：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The router link directive allows us to make any element act like a link, which
    activates a given route. By using the router DSL, we can specify a route as individual
    segment elements within an array. Since we're iterating over all projects to render
    navigation item components, we can use the project ID to construct links that
    activate our previously configured route path, `/projects/:projectId`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 路由链接指令允许我们使任何元素表现得像链接一样，激活一个给定的路由。通过使用路由 DSL，我们可以在数组中指定一个路由作为单独的段元素。由于我们正在遍历所有项目以渲染导航项组件，我们可以使用项目
    ID 来构建激活我们之前配置的路由路径 `/projects/:projectId` 的链接。
- en: The second change is to use the `routerLinkActive` directive on our navigation
    items. This directive is a simple helper that adds a CSS class to any element
    where a router link directive is present. If the configured router link URL matches
    the URL in the browser, then the CSS class will be added. You can specify the
    CSS class name within the `routerLinkActive` attribute value. This helps us to
    style the active navigation item so that the user always sees which project is
    currently navigated.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个更改是在我们的导航项上使用 `routerLinkActive` 指令。这个指令是一个简单的辅助工具，它将 CSS 类添加到任何存在路由链接指令的元素上。如果配置的路由链接
    URL 与浏览器中的 URL 匹配，则将添加 CSS 类。您可以在 `routerLinkActive` 属性值中指定 CSS 类名称。这有助于我们样式化活动的导航项，以便用户始终可以看到当前导航的项目。
- en: Great! You have successfully updated the navigation within our root component
    to use the Angular router directives. While previewing the changes, you can already
    see that the URL in your browser is updated when you're navigating between the
    different projects within the project navigation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您已经成功更新了根组件中的导航以使用 Angular 路由指令。在预览更改时，您已经可以看到当您在项目导航中导航到不同的项目时，浏览器中的 URL
    已经更新。
- en: 'While so far we''ve been relying on our project service to tell us which project
    is currently selected, we''re now leveraging the URL state of the router to store
    this information. Let''s remove the `selectedProject` member and the call to the
    project service from our root component located in `src/app/app.component.ts`.
    We can also get rid of the `selectProject` method since the router is now in charge
    of selecting projects:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然到目前为止我们一直依赖我们的项目服务来告诉我们哪个项目当前被选中，但现在我们正在利用路由的 URL 状态来存储这个信息。让我们从 `src/app/app.component.ts`
    中的根组件中移除 `selectedProject` 成员和对项目服务的调用。我们也可以去掉 `selectProject` 方法，因为现在路由负责选择项目：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There's still one step missing to complete the switch to the router for our
    project composition. If you have been previewing the changes we've performed so
    far, you've noticed that we're already changing the URL and that the project navigation
    items get activated correctly. However, we always see the first project title
    and description within the project component. The project container component
    is currently still relying on the project service to obtain the selected project.
    We need to change that so that we use the state from the router.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 完成切换到项目组合路由器的一步还缺失。如果你已经预览了我们迄今为止所做的更改，你会注意到我们已经在更改URL，并且项目导航项被正确激活。然而，我们总是在项目组件中看到第一个项目标题和描述。项目容器组件目前仍然依赖于项目服务来获取所选项目。我们需要改变这一点，以便我们使用路由器的状态。
- en: 'Let''s implement the changes in the container component `src/app/container/project-container/project-container.component.ts`
    in order to obtain the project ID parameter from the activated route and display
    the correct project after navigation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在容器组件`src/app/container/project-container/project-container.component.ts`中实现更改，以从激活的路由中获取项目ID参数，并在导航后显示正确的项目：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We're still using a member `selectedProject` which is of type `Observable<Project>`
    to represent the currently selected project. However, we're no longer obtaining
    this observable from the project service directly. Instead, we're using the `combineLatest`
    RxJS helper to combine two observable streams together in order to produce an
    output stream that emits the selected project.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然使用一个类型为`Observable<Project>`的成员`selectedProject`来表示当前所选项目。然而，我们不再直接从项目服务中获取这个可观察对象。相反，我们使用RxJS的`combineLatest`辅助函数将两个可观察流组合在一起，以产生一个输出流，该流发出所选项目。
- en: We are combining the observable route parameters from the activated route with
    the project list from our project service. We can then use the `map` operator
    to find the right project within the project list using the ID obtained from the
    route parameters. The resulting observable stream will emit the selected project
    and re-emit whenever the route parameter or the project list changes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将激活路由的可观察路由参数与我们的项目服务中的项目列表结合起来。然后我们可以使用`map`运算符，使用从路由参数中获得的ID在项目列表中找到正确的项目。结果的可观察流将发出所选项目，并在路由参数或项目列表更改时重新发出。
- en: Now, go ahead and preview the changes in your browser again. You should now
    see that the router navigation using the project navigation on the left should
    also cause an update on our project component. It should always display the correct
    project information depending on what project ID is present within the browser's
    URL.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请在浏览器中再次预览更改。你应该现在看到，使用左侧项目导航的路由器导航也应该更新我们的项目组件。它应该始终显示正确的项目信息，取决于浏览器URL中存在的项目ID。
- en: Child routes for project details
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目详情的子路由
- en: 'Within this section, we''re going to use the router for navigating the detail
    views on our projects. We currently have two detail views on our projects:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用路由器在项目上导航详细视图。我们目前在项目上有两个详细视图：
- en: Project tasks view using the task list container component
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任务列表容器组件的项目任务视图
- en: Project comments view using the project comments container component
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用项目评论容器组件的项目评论视图
- en: We also need to make sure that we're able to activate the sub-views using our
    tabbed interface on projects. Our current solution is to store the activated tab
    within the project container component. Based on that, we're deciding which detail
    view to show within the template of our project component. There, we're using
    a simple `ngIf` directive in order to determine which of the two child container
    components to show.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保我们能够通过项目上的标签界面激活子视图。我们的当前解决方案是在项目容器组件中存储激活的标签。基于此，我们在项目组件的模板中决定显示哪个详细视图。在那里，我们使用简单的`ngIf`指令来确定显示两个子容器组件中的哪一个。
- en: 'Let''s start with our refactoring by including child route configurations for
    both our detail views. Open up the router configuration file on the path `src/app/routes.ts`
    and perform the following changes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从包括我们详细视图的子路由配置开始重构。打开路径`src/app/routes.ts`上的路由器配置文件，并执行以下更改：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using the `children` property on route configurations, we can configure nested
    routes. It allows us to tell Angular that somewhere below the routed parent component,
    there will be another router outlet that can be used to instantiate components
    activated by child routes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过路由配置上的 `children` 属性，我们可以配置嵌套路由。它允许我们告诉 Angular，在路由父组件下方某处将有一个可以用于实例化由子路由激活的组件的路由出口。
- en: Let's say a user is navigating to the path `/projects/1/tasks` with our new
    configuration. This would activate a path in our route configuration. The project
    container component is activated and instantiated into the router outlet within
    our root component. Additionally, the route parameter `:projectId` is set to the
    value `1`. Since we've configured a matching child route with the path `tasks`,
    this child route will also be activated. The Angular router is now searching for
    a nested router outlet below the project container component so that it can instantiate
    the task list container component there.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户使用我们的新配置导航到路径 `/projects/1/tasks`。这将激活我们的路由配置中的一个路径。项目容器组件被激活并实例化到根组件内的路由出口中。此外，路由参数
    `:projectId` 被设置为值 `1`。由于我们已配置了一个匹配的子路由，路径为 `tasks`，因此此子路由也将被激活。现在 Angular 路由正在搜索项目容器组件下方的嵌套路由出口，以便在那里实例化任务列表容器组件。
- en: Let's take a look at the diagram in the previous section, *Composition using
    the router* of this chapter again. This figure reflects our end goal in terms
    of composition using router outlets and instantiated components and illustrates
    where we need to add our nested router outlet element.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看一下上一节中的图，即本章的 *使用路由进行组合*。这张图反映了我们使用路由出口和实例化组件的最终目标，并说明了我们需要添加嵌套路由出口元素的位置。
- en: '![](img/38bed4ac-6ebe-4c1d-87a0-1c3e536ad730.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38bed4ac-6ebe-4c1d-87a0-1c3e536ad730.png)'
- en: A component tree displaying routed container components (solid line) and components
    included via router outlets
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 显示路由容器组件（实线）和通过路由出口包含的组件的组件树
- en: 'Let''s now apply some changes to our project components in order to make our
    child routes work. There are three changes involved:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对项目组件应用一些更改，以便使我们的子路由工作。涉及三个更改：
- en: Remove the static inclusion of the task view and the comments view within the
    project component and use a nested router outlet instead.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目组件中移除任务视图和注释视图的静态包含，并使用嵌套路由出口代替。
- en: Update the project container component to obtain the active tab from the child
    route name. Again, we're using the router to store the state for which tab is
    currently active.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新项目容器组件，从子路由名称中获取活动标签。我们再次使用路由来存储当前哪个标签是活动的状态。
- en: Update both the project comments container components as well as the task list
    container component to obtain the selected project from the router instead of
    the project service.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新项目注释容器组件以及任务列表容器组件，从路由而不是项目服务中获取所选项目。
- en: 'Let''s start with the first step, which is quite a simple one. Let''s open
    up the file `src/app/project/project/project.component.ts` and replace the static
    inclusion of the detail views with a router outlet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一步开始，这是一个相当简单的步骤。让我们打开文件 `src/app/project/project/project.component.ts`
    并将静态包含的详情视图替换为路由出口：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Okay, now the router is in control of instantiating the right project details
    component within our nested router outlet.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在路由器控制着在我们的嵌套路由出口中实例化正确的项目详情组件。
- en: 'The second change we''re going to apply is concerning the tabbed interface
    component within our project component. Since our tabbed component is a pure component,
    it relies on the project container component to provide the active tab. Also,
    when we activate a tab, the project container component is implementing what should
    happen on an activation. Until now, the state for which of the tabs is currently
    active has been stored within the project container component directly. Now, we
    want to change this behaviour so that we use the router to store this state. An
    activation of a tab should then also trigger a route change. Let''s open the file
    `src/app/container/project-container/project-container.component.ts` and implement
    the following changes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要应用的第二个更改是关于项目组件内的标签界面组件。由于我们的标签组件是一个纯组件，它依赖于项目容器组件来提供激活的标签。此外，当我们激活一个标签时，项目容器组件正在实现激活时应发生的事情。到目前为止，哪个标签当前激活的状态一直存储在项目容器组件中。现在，我们希望改变这种行为，以便我们使用路由来存储这个状态。标签的激活应该也会触发路由更改。让我们打开文件
    `src/app/container/project-container/project-container.component.ts` 并实现以下更改：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The tabs component is a pure component and this time we don't want to use the
    router link directives in order to make our project detail tabs navigable. Keeping
    things pure and not polluting your UI components with context-specific router
    link configurations can pay off when scaling your application. Instead, we want
    to use the router programmatically within our container component to cause navigation.
    We'd also like to have a way of telling which tab should be currently active according
    to the router state.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 标签组件是一个纯组件，这次我们不希望使用路由链接指令来使我们的项目详情标签可导航。保持组件的纯净，不将特定上下文的路由链接配置污染UI组件，在扩展应用程序时可能会带来好处。相反，我们希望在容器组件中程序化地使用路由来触发导航。我们还希望有一种方法来确定哪个标签应该是当前激活的，根据路由状态。
- en: Within the preceding code changes, we're injecting the router instance within
    our component constructor. Additionally, we've changed the `activeTab` property
    to be of type `Observable<Tab>`. Now we need a way to react on router URL changes
    and figure out what of the tabs is active after the URL change. The observable
    behind `router.url` is exactly what we're looking for to start our reactive pipeline.
    On every navigation that causes the router to change the browser URL, this observable
    will emit an item. However, we're also going to need a reference to the currently
    selected project to figure out which tab is currently activated. For this purpose,
    we're combining the URL changes observables together with our `selectedProject`
    observable. Now, we have a stream that emits on URL changes and on changes of
    the selected project. Within a `map` operator, we're then using the `router.isActive`
    method in order to figure out which of the tabs is currently active. We can pass
    a URL string to the `isActive` method, and it tells us if that URL string is currently
    active within the router. We use the project ID of the selected project as well
    as the IDs of the individual tabs to construct this test URL string. At the end
    of our operator chain, the observable spits out the active tab object or null
    if none of the tabs is active.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码更改中，我们在组件构造函数中注入了路由实例。此外，我们将 `activeTab` 属性更改为 `Observable<Tab>` 类型。现在我们需要一种方法来响应路由URL更改并确定URL更改后哪个标签是激活的。`router.url`
    后面的可观察对象正是我们开始我们的响应式管道所寻找的。在每次导航导致路由更改浏览器URL时，这个可观察对象将发出一个项。然而，我们还需要一个当前所选项目的引用来确定哪个标签当前被激活。为此，我们将URL更改的可观察对象与我们的
    `selectedProject` 可观察对象结合起来。现在，我们有一个在URL更改和所选项目更改时发出项的流。然后，在 `map` 操作符中，我们使用 `router.isActive`
    方法来确定哪个标签当前是激活的。我们可以将URL字符串传递给 `isActive` 方法，它告诉我们该URL字符串是否在路由中当前是激活的。我们使用所选项目的项目ID以及各个标签的ID来构造这个测试URL字符串。在操作符链的末尾，可观察对象输出激活的标签对象或null，如果没有标签是激活的。
- en: 'Okay, we''re almost there! The last change we need to apply to make our tabs
    work again is to refactor the `activateTab` method within the project container
    component class. Instead of updating a local state to represent the active tab,
    we now need to trigger a router navigation programmatically by using this code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们几乎完成了！我们需要应用的最后一个更改是为了使我们的标签再次工作，那就是重构项目容器组件类中的 `activateTab` 方法。我们不再更新本地状态来表示激活的标签，我们现在需要通过使用以下代码来程序化地触发路由导航：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In order to navigate to a new URL programmatically, we can use the method `router.navigate`
    and use the router DSL to construct the URL segments of the desired route. Besides
    the ID of the activated tab, we also need the ID of the selected project to construct
    the target URL. Because the selected project is represented as an observable stream,
    we can transform using the take operator and subscribe to the output stream in
    order to get hold of the currently selected project object. Now, within the subscription,
    we have everything at hand to execute the programmatic navigation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以编程方式导航到新的URL，我们可以使用 `router.navigate` 方法并使用路由DSL构建所需路由的URL段。除了激活标签的ID之外，我们还需要所选项目的ID来构建目标URL。因为所选项目被表示为一个可观察的流，我们可以使用
    `take` 操作符进行转换，并订阅输出流以获取当前所选的项目对象。现在，在订阅中，我们手头有所有东西来执行编程导航。
- en: 'Since we''re now using an observable to represent the active tab, we need to
    modify our template on the path `src/app/container/project-container/project-container.component.html`
    and use the async pipe to subscribe to the observable as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在使用可观察对象来表示活动标签，我们需要修改路径 `src/app/container/project-container/project-container.component.html`
    上的模板，并使用异步管道订阅可观察对象，如下所示：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You've successfully refactored our tabs to work with the router and our configured
    child routes. If you preview your changes within the browser, you should be able
    to navigate between tabs again, and the browser URL should be updated while doing
    so. You can also try to reload your browser with a specific URL that directly
    navigates to a specific tab—the same scenario that would apply to a user using
    a bookmark to a specific tab on a project. Try, for example, to navigate to `http://localhost:4200/projects/2/comments`
    and see whether you're ending up where you'd expect to.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功重构了我们的标签页以与路由和配置的子路由一起工作。如果你在浏览器中预览你的更改，你应该能够再次在标签页之间导航，并且在导航的同时浏览器URL应该会更新。你也可以尝试使用一个直接导航到特定标签页的特定URL重新加载你的浏览器——这同样适用于一个使用书签导航到项目特定标签页的用户。尝试，例如，导航到
    `http://localhost:4200/projects/2/comments` 并看看你是否会到达你预期的位置。
- en: 'The last of the three steps to complete our child route refactoring is still
    outstanding. Currently, both of the detail views are still relying on the project
    service to determine the selected project. We need to change both of them to use
    the router instead and extract the selected project ID from the route, similarly
    as we do within the project container component already. Let''s start with the
    task list container component within the file `src/app/container/task-list-container/task-list-container.component.ts`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 完成我们的子路由重构的三个步骤中的最后一个仍然悬而未决。目前，两个详情视图仍然依赖于项目服务来确定所选项目。我们需要将它们都改为使用路由，并从路由中提取所选项目ID，就像我们在项目容器组件中已经做的那样。让我们从文件
    `src/app/container/task-list-container/task-list-container.component.ts` 中的任务列表容器组件开始：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Instead of obtaining the selected project observable from the project service,
    we're combining the project list observable, together with the route parameters,
    to find the selected project. This should look very familiar since we're using
    almost the same code as within the project container component. The only difference
    is that we need to access the parent route first. By calling `route.parent.params`,
    we can access the parent route and obtain the params from there. This is required
    since we're using nested routes and the task list container is a sub-view of the
    project container where the `:projectId` parameter is available.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再从项目服务中获取所选项目的可观察对象，而是将项目列表可观察对象与路由参数结合起来，以找到所选项目。这应该看起来非常熟悉，因为我们几乎使用了与项目容器组件中相同的代码。唯一的区别是我们需要首先访问父路由。通过调用
    `route.parent.params`，我们可以访问父路由并从那里获取参数。这是必需的，因为我们正在使用嵌套路由，而任务列表容器是项目容器的子视图，其中
    `:projectId` 参数可用。
- en: 'Let''s apply the same change to our project comments container component. Open
    up the file `src/app/container/project-comments-container/project-comments-container.component.ts`
    and update the code with the following changes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将同样的更改应用到我们的项目评论容器组件上。打开文件 `src/app/container/project-comments-container/project-comments-container.component.ts`
    并使用以下更改更新代码：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Congratulations! We''ve successfully implemented all changes necessary to provide
    a fully navigable project structure including child routes. We are no longer relying
    on the project service to store the selected project within our application. As
    the last step, we can remove the unnecessary code from the project service, since
    none of our components rely on it anymore. Let''s open up the file `src/app/project/project.service.ts`
    and remove all code related to selecting projects:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经成功实现了所有必要的更改，以提供一个包括子路由在内的完全可导航的项目结构。我们不再依赖于项目服务来存储应用中的所选项目。作为最后一步，我们可以从项目服务中移除不必要的代码，因为我们的组件不再依赖于它了。让我们打开文件
    `src/app/project/project.service.ts` 并移除所有与选择项目相关的代码：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Nothing feels better than removing abandoned code, right? It's like a reward
    for our hard work refactoring and cleaning up our code. Let's preview our changes
    within the browser and test our newly added router features. You should now be
    able to use the application the same way as before our refactoring. However, we
    now store the selected project and the active project detail tab within the browser's
    URL. Navigate across the different views and also try to use the back and forward
    buttons within your browser. It just feels so much better to be able to navigate
    like this.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比移除废弃的代码更让人感觉良好的了，这是对我们重构和清理代码的辛勤工作的回报。让我们在浏览器中预览我们的更改并测试我们新添加的路由功能。现在你应该能够像重构之前一样使用应用程序。然而，我们现在在浏览器
    URL 中存储所选项目和活动项目详情标签。在不同的视图之间导航，并尝试在浏览器中使用后退和前进按钮。能够这样导航感觉真是太好了。
- en: Guarding our projects
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护我们的项目
- en: Sometimes, it's a good idea to prevent certain routes from being navigated,
    and to provide a fallback navigation for those scenarios. This is especially true
    when your routes include dynamic route parameters, which can change over time,
    meaning users may still have outdated bookmarks to those old URLs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，防止某些路由被导航，并为这些场景提供回退导航是个好主意。这尤其适用于你的路由包括动态路由参数的情况，这些参数可能会随时间变化，意味着用户可能仍然保留着那些旧
    URL 的过时书签。
- en: Guards are the perfect helper for preventing these navigation errors. While
    guards help you to prevent access to certain routes and redirect accordingly,
    you should never rely on them to provide any kind of security for your application.
    Security always needs to come from a server. Using guards, you can just provide
    the necessary usability of a user accessing an area where he would be confronted
    with errors, maybe because of missing permissions to call a backend web service,
    or simply because a navigated detail view by an item ID no longer exists.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 守卫是防止这些导航错误的完美助手。虽然守卫可以帮助你防止访问某些路由并相应地重定向，但你永远不应该依赖它们为你的应用程序提供任何类型的保护。安全性始终需要来自服务器。使用守卫，你只需提供用户访问可能遇到错误区域的必要可用性，可能是因为缺少调用后端
    Web 服务的权限，或者简单地因为通过项目 ID 导航的详情视图不再存在。
- en: 'Within this section, we''re going to create a guard to prevent navigation to
    a non-existing project. We haven''t used the Angular CLI for a while now. Let''s
    give it a long deserved spin and use it to create the stub of our project container
    guard:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个守卫来防止导航到不存在的项目。我们已经有段时间没有使用 Angular CLI 了。让我们好好利用它，用它来创建我们的项目容器守卫的占位符：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will generate a stub guard and include it into our main app module in
    the provider section. Let''s open up the guard file located at `src/app/guards/project-container.guard.ts`
    and change its content to the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个占位符守卫并将其包含到我们的主应用模块的提供者部分。让我们打开位于 `src/app/guards/project-container.guard.ts`
    的守卫文件，并将其内容更改为以下内容：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Within this simple project guard, we're implementing the `CanActivate` interface,
    which comes from the router module. By implementing this interface we can write
    a guard that allows us to control if a user can navigate a certain route. As the
    first argument of the `canActivate` method, we're receiving the activated route
    snapshot object of the target route. The method should return an observable of
    type `Observable<boolean>`. If we'd like to prevent the navigation, we can emit
    false through the observable stream that is returned.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的项目守卫中，我们正在实现来自路由模块的 `CanActivate` 接口。通过实现这个接口，我们可以编写一个守卫，使我们能够控制用户是否可以导航到某个路由。作为
    `canActivate` 方法的第一个参数，我们接收目标路由的激活路由快照对象。该方法应返回一个类型为 `Observable<boolean>` 的可观察对象。如果我们想防止导航，我们可以通过返回的可观察流发射
    false。
- en: In our case, we're using the project list observable obtained from the project
    service as an input observable. We then map the observable in order to determine
    if the project with the ID, extracted from the target route snapshot params, is
    existing. We're using the variable `projectExists` to store this information,
    which we return as the result of our mapping function. Additionally, if the project
    with the navigated ID does not exist, we're redirecting to the first project in
    the project list. We can do that by using the `router.navigate` method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们使用从项目服务获取的项目列表可观察对象作为输入可观察对象。然后我们映射这个可观察对象，以确定从目标路由快照参数中提取的项目 ID 是否存在。我们使用变量
    `projectExists` 来存储这个信息，并将其作为映射函数的结果返回。此外，如果导航的 ID 对应的项目不存在，我们将重定向到项目列表中的第一个项目。我们可以通过使用
    `router.navigate` 方法来实现这一点。
- en: 'Now, the only thing left to activate our guard is to include it in our router
    configuration. Let''s open the file `src/app/routes.ts` and add the following
    changes:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只剩下激活我们的守卫这一步，只需将其包含在我们的路由配置中。让我们打开文件 `src/app/routes.ts` 并添加以下更改：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Every route configuration supports a `canActivate` property, which can be set
    to a list of guards that implement the `CanActivate` interface. All we need to
    do is add our guard to the project route configuration.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由配置都支持一个 `canActivate` 属性，该属性可以设置为实现 `CanActivate` 接口的守卫列表。我们所需做的只是将我们的守卫添加到项目路由配置中。
- en: That's it! We have guarded our project container component and it's no longer
    possible to cause errors because of navigations to projects that don't exist.
    You can preview your changes in the browser and try to navigate to a non-existing
    project. Just try to navigate to `http://localhost:4200/projects/100` for example.
    You should be redirected to the first project overview.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！我们已经保护了我们的项目容器组件，因此不再可能因为导航到不存在的项目而引发错误。您可以在浏览器中预览您的更改并尝试导航到一个不存在的项目。例如，尝试导航到
    `http://localhost:4200/projects/100`。您应该会被重定向到第一个项目概览。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the basic concepts of the router in Angular.
    We looked at how we can use the existing component tree to configure child routes
    in nested-router scenarios. We have learned about the router outlet element and
    the basic router link directive.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Angular 中路由的基本概念。我们探讨了如何在嵌套路由场景中使用现有的组件树来配置子路由。我们还了解了路由出口元素和基本的路由链接指令。
- en: We have refactored our existing navigation elements, such as the project navigation
    and the tabbed interface on the project view. We've used router links and programmatic
    navigation to fulfil different navigation scenarios.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经重构了现有的导航元素，例如项目导航和项目视图上的标签页界面。我们使用了路由链接和程序化导航来满足不同的导航场景。
- en: We looked into some common route configuration specifics and the basics of the
    router link DSL. We've also learned about route matching patterns as well as parameter
    placeholders and how to access these parameters in activated routes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了常见的路由配置细节以及路由链接 DSL 的基础知识。我们还了解了路由匹配模式、参数占位符以及如何在激活的路由中访问这些参数。
- en: Last but not least, we've created a simple guard which prevents our users from
    accessing project details with invalid project IDs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们创建了一个简单的守卫，防止用户使用无效的项目 ID 访问项目详情。
- en: In the next chapter, we will learn about SVG and how to use this web standard
    in order to draw graphics in our Angular applications. We will visualize an activity
    log of our application activities using SVG and see how Angular makes this technology
    even greater by enabling composability.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习 SVG 以及如何在 Angular 应用程序中使用这个网络标准来绘制图形。我们将使用 SVG 可视化应用程序活动日志，并了解 Angular
    如何通过启用可组合性使这项技术更加出色。
