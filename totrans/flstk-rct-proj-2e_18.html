<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Making the VR Game Dynamic using MERN</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will extend the <strong>MongoDB</strong>, <strong>Express.js</strong>, <strong>React.js</strong>, <strong>and Node.js</strong> (<strong>MERN</strong>) skeleton application to build the MERN VR Game application, and use it to convert the static React 360 game developed in the previous chapter into a dynamic game. We will achieve this by replacing the sample game data with game details fetched directly from the database. We will use the MERN stack technologies to implement a game model and <strong>Create, Read, Update, and Delete</strong> (<strong>CRUD</strong>) <strong>application programming interfaces</strong> (<strong>APIs</strong>) in the backend, which will allow storage and retrieval of games, and frontend views, which will allow users to make their own games besides playing any of the games on the platform in their browser. We will update and integrate the game developed with React 360 into the game platform developed with MERN technologies. After completing these implementations and integration, you will be able to design and build your own full-stack web applications with dynamic VR features.</p>
<p>To make MERN VR Game a complete and dynamic game application, we will implement the following:</p>
<ul>
<li style="font-weight: 400">A game model schema to store game details in MongoDB</li>
<li style="font-weight: 400">APIs for game CRUD operations</li>
<li style="font-weight: 400">React views for creating, editing, listing, and deleting games</li>
<li style="font-weight: 400">Updating the React 360 game to fetch data with the API</li>
<li style="font-weight: 400">Loading the VR game with dynamic game data</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the dynamic MERN VR Game application</h1>
                </header>
            
            <article>
                
<p>Throughout this chapter, we will develop the <span>MERN VR Game</span> application with MERN-stack technologies. On this platform, registered users will be able to make and modify their own games by providing an equirectangular image for the game world, and the VR object resources, including transform property values for each object to be placed in the game world. Any visitor to the application will be able to browse through all the games added by the makers and play any game, to find and collect the 3D objects in the game world that are relevant to the clue or description of each game. When a registered user signs into the application, they will see a home page with all the games listed and an option to make their own game, as pictured in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-913 image-border" src="assets/ad11f43c-0c43-4c0e-997a-f2cdbc62a86f.png" style="width:57.42em;height:34.83em;"/></div>
<div class="packt_tip"><span>The code for the complete MERN VR Game application is available on GitHub at</span> <a href="https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter14/mern-vrgame" target="_blank">https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter14/mern-vrgame</a><span>.</span><span> You can</span><span> clone this code and run the application as you go through the code explanations for the rest of this chapter. </span></div>
<p><span>The views needed for the MERN VR Game application</span><span> will be developed by extending and modifying the existing </span><span>React components</span><span> in the MERN skeleton application.</span><span> The component tree pictured in the following screenshot shows all the custom React components that make up the MERN VR Game frontend developed in this chapter:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-914 image-border" src="assets/dc786562-af28-45cf-a355-457b1f6919e2.png" style="width:32.50em;height:22.33em;"/></div>
<p>We will add new React components<span> related to </span><span>creating, editing, and listing VR games, and will also modify existing components such as the <kbd>Profile</kbd>, <kbd>Menu</kbd>, and <kbd>Home</kbd> components as we build out the features of the MERN VR Game application in the rest of the chapter. The core features in this game platform depend on the capability to store specific details of each game. In the next section, we will begin implementing the MERN VR Game application by defining a game model for storing details of each game. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining a Game model</h1>
                </header>
            
            <article>
                
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>In order to store details of each game in the platform, we will implement a Mongoose model to define a Game model, and t</span><span>he implementation will be similar to other Mongoose model implementations covered in previous chapters, such as the Course model defined in <a href="c58ac055-5a1e-4bf4-b8a6-c9b311cf267a.xhtml" target="_blank">Chapter 6</a>,</span> <em><span>Building a Web-Based Classroom Application</span></em><span>. </span><span>In</span> <a href="4f633dd6-f392-490d-b3a6-eb5430b58ec8.xhtml" target="_blank">Chapter 13</a><span>,</span> <em>Developing a Web-Based VR Game</em><span>, the </span><em>Game data structure</em><span> </span><span>section </span><span>laid out the details needed for each game in order to implement t</span><span>he scavenger-hunt features</span> <span>defined for the gameplay.</span></p>
<p><span>We will design the game schema based on these specific details about the game, its VR objects, and also a reference to the game maker. In the following sections, we will discuss the specifics of the game schema, the sub-schema for storing individual VR objects that will be a part of the game, and the validation check to ensure a minimum number of VR objects are placed in the game.</span></p>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring the game schema</h1>
                </header>
            
            <article>
                
<div class="page">
<div class="layoutArea">
<div class="column">
<p>The game schema, which defines the game model with a structure for the game data, will specify the fields to store details about each game. These details will include a game name; a link for the game world image file, text description, or clue; arrays containing details of 3D objects in the game, timestamps indicating when the game was created or updated; and a reference to the user who created the game. The schema for the game model will be defined in <kbd>server/models/game.model.js</kbd>, and the code defining these game fields is given in the following list, with explanations:</p>
</div>
</div>
</div>
<ul>
<li><strong>Game name</strong>: The <kbd>name</kbd> field will store a title for the game. It is declared to be a <span><kbd>String</kbd> type and will be a required field:</span></li>
</ul>
<pre style="padding-left: 60px">  name: {<br/>    type: String,<br/>    trim: true,<br/>    required: 'Name is required'<br/>  },</pre>
<ul>
<li><strong>World image URL</strong>: The <kbd>world</kbd> field will contain the URL pointing to the equirectangular image that makes up the 3D world of the game. <span>It is declared to be a </span><kbd>String</kbd> type and will be a required fielde:</li>
</ul>
<pre style="padding-left: 60px">  world: {<br/>    type: String, trim: true,<br/>    required: 'World image is required'<br/>  },</pre>
<ul>
<li><strong>Clue text</strong>: The <kbd>clue</kbd> field will store text of <kbd>String</kbd> type to give a description of the game or clues about how to complete the game<span>:</span></li>
</ul>
<pre style="padding-left: 60px">  clue: {<br/>    type: String,<br/>    trim: true<br/>  },</pre>
<ul>
<li><span><strong>Collectable and other VR objects</strong>: The <kbd>answerObjects</kbd> field will be an array containing details of the VR objects to be added to the game as collectable objects, whereas the <kbd>wrongObjects</kbd> field will be an array with VR objects that cannot be collected in the game. Objects in these arrays will be defined in a separate VR object schema, as discussed in the next section:</span></li>
</ul>
<pre style="padding-left: 90px">answerObjects: [VRObjectSchema],<br/>wrongObjects: [VRObjectSchema],</pre>
<ul>
<li><span><strong>Created at and updated at times</strong>: The <kbd>created</kbd> and <kbd>updated</kbd> fields will be <kbd>Date</kbd> types, with <kbd>created</kbd> generated when a new game is added, and <kbd>updated</kbd> changed when any game details are modified:</span></li>
</ul>
<pre style="padding-left: 90px">updated: Date,<br/>created: {<br/>    type: Date,<br/>    default: Date.now<br/>},</pre>
<ul>
<li><span><strong>Game maker</strong>: The <kbd>maker</kbd> field will be a reference to the user who made the game:</span></li>
</ul>
<pre style="padding-left: 90px">maker: {type: mongoose.Schema.ObjectId, ref: 'User'}</pre>
<p>These fields added in the game schema definition will capture details of each game on the platform and allow us to implement the game-related features in the MERN VR Game application. The VR objects to be stored in the<span> </span><kbd>answerObjects</kbd><span> and <kbd>wrongObjects</kbd></span> arrays in the game schema will hold details of each VR object to be placed in the game world. In the next section, we will explore the schema defining the details to be stored for each VR object. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying the VR object schema</h1>
                </header>
            
            <article>
                
<p>The <kbd>answerObjects</kbd> and <kbd>wrongObjects</kbd> fields already defined in the game schema will both be arrays of VR object documents. These documents will represent the VR objects that are a part of the game. We will define the VR object Mongoose schema for these documents separately, with fields for storing the URLs of the <strong>object</strong> (<strong>OBJ</strong>) file and <strong>Material Template Library</strong> (<strong>MTL</strong>) file, along with the React 360 transform values, the scale value, and color value for<span> each VR object</span>. </p>
<p><span>The schema for the VR object will also be defined in </span><kbd>server/models/game.model.js</kbd><span>, and the code defining these fields is given in the following list, with explanations:</span></p>
<ul>
<li><strong>OBJ and MTL file URLs</strong>: The <kbd>objUrl</kbd> and <kbd>mtlUrl</kbd> fields will store the links to the OBJ and MTL files representing the 3D object data. These fields <span>will be of </span><span><kbd>String</kbd> type and are required fields for storing a VR object:</span></li>
</ul>
<pre style="padding-left: 60px">  objUrl: {<br/>    type: String, trim: true,<br/>    required: 'OBJ file is required'<br/>  },<br/>  mtlUrl: {<br/>    type: String, trim: true,<br/>    required: 'MTL file is required'<br/>  },</pre>
<ul>
<li><strong>Translation transform values</strong>: The <kbd>translateX</kbd>, <span><kbd>translateY</kbd>, and <kbd>translateZ</kbd> fields will hold the position values of the VR object in 3D space. These fields will be of <kbd>Number</kbd> type, and the default value for each will be <kbd>0</kbd>:</span></li>
</ul>
<pre style="padding-left: 60px">translateX: {type: Number, default: 0},<br/>translateY: {type: Number, default: 0},<br/>translateZ: {type: Number, default: 0},</pre>
<ul>
<li><strong>Rotation transform values</strong>: <span>The </span><kbd>rotateX</kbd><span>, </span><span><kbd>rotateY</kbd>, and <kbd>rotateZ</kbd> fields will hold the orientation values of the VR object in 3D space. These fields will be of <kbd>Number</kbd> type, and the default value for each will be <kbd>0</kbd>:</span></li>
</ul>
<pre style="padding-left: 60px">rotateX: {type: Number, default: 0},<br/>rotateY: {type: Number, default: 0},<br/>rotateZ: {type: Number, default: 0},</pre>
<ul>
<li><strong>Scale</strong>: The <kbd>scale</kbd> field will represent the relative size appearance of the VR object. This field <span>will be of</span><span> </span><kbd>Number</kbd><span> </span><span>type, and the default value will be <kbd>1</kbd>:</span></li>
</ul>
<pre style="padding-left: 60px">scale: {type: Number, default: 1},</pre>
<ul>
<li><strong>Color</strong>: T<span>he </span><kbd>color</kbd><span> field will specify the default color of the object if it is not provided in the MTL file. This field will be of <kbd>String</kbd> type, and the default value will be <kbd>white</kbd>:</span></li>
</ul>
<pre style="padding-left: 60px">color: {type: String, default: 'white'}</pre>
<p>These fields in the VR object schema represent a VR object to be added to the game world. When a new game document is saved to the database, the <kbd>answerObjects</kbd> and <kbd>wrongObjects</kbd> arrays will be populated with <kbd>VRObject</kbd> documents that adhere to this schema definition. When a user is creating a new game using this Game model with the defined game and VR object schemas, we want to ensure the user adds at least one VR object to each array in the game data. In the next section, we will take a look at how to add this validation check to the Game model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validating array length in the game schema</h1>
                </header>
            
            <article>
                
<p>In the game schema defining the Game model, we have two arrays for adding VR objects to the game. These <kbd>answerObjects</kbd> and <kbd>wrongObjects</kbd> arrays in a game document must contain at least one VR object in each array when a game is being saved in the game collection. To add this validation for a minimum array length to the game schema, we will add the following custom validation checks to the <kbd>answerObjects</kbd> and <kbd>wrongObjects</kbd> paths in the <kbd>GameSchema</kbd> defined with Mongoose.</p>
<p>We will use <kbd>validate</kbd> to add the array length validation for the <kbd>answerObjects</kbd> field, as shown in the following code:</p>
<p><span><kbd>mern-vrgame/server/models/game.model.js</kbd>:</span></p>
<pre>GameSchema.path('answerObjects').validate(function(v) {<br/>  if (v.length == 0) {<br/>    this.invalidate('answerObjects',<br/>   'Must add alteast one VR object to collect')<br/>  }<br/>}, null) </pre>
<p>In this validation check, if the array length is found to be <kbd>0</kbd>, we throw a validation error message indicating that at least one object must be added to the array, before saving the game document in the database.</p>
<p>The same validation code is also added for the <kbd>wrongObjects</kbd> field, as shown in the following code:</p>
<p><span><kbd>mern-vrgame/server/models/game.model.js</kbd>:</span></p>
<pre>GameSchema.path('wrongObjects').validate(function(v) {<br/>  if (v.length == 0) {<br/>    this.invalidate('wrongObjects', <br/>    'Must add alteast one other VR object') <br/>  }<br/>}, null) </pre>
<p>These checks run every time a game is to be saved in the database and help ensure the game is made with at least two VR objects, including one object that can be collected and another object that cannot be collected. These schema definitions and validations used for defining the Game model will allow a game database for the application to be maintained. This game collection will cater to all the requirements for developing a dynamic VR game according to the specifications of the MERN VR Game application. In order to allow users to access the game collection, for both making their own games and retrieving games made by others, we need to implement corresponding CRUD APIs in the backend. In the next section, we will implement these CRUD APIs that will allow users to create, read, list, update, and delete games from the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing game CRUD APIs</h1>
                </header>
            
            <article>
                
<p>In order to build a game platform that allows VR games to be made, managed, and accessed, we need to extend the backend to accept requests that enable game data manipulation in the database. To make these features possible, the backend in the MERN VR Game application will expose a set of CRUD APIs for creating, editing, reading, listing, and deleting games from the database, which can be used in the frontend of the application <span>with fetch calls</span>, including in the React 360 game implementation. In the following sections, we will implement these CRUD API endpoints in the backend, along with the corresponding <kbd>fetch</kbd> methods that will be deployed in the frontend to use these APIs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new game</h1>
                </header>
            
            <article>
                
<p>A user who is signed in to the application will be able to create new games in the database with the create game API endpoint. For the implementation of this API in the backend, we will first declare a <kbd>POST</kbd> route at <kbd>/api/games/by/:userId</kbd>, as shown in the following code:</p>
<p><kbd>mern-vrgame/server/routes/game.routes.js</kbd>:</p>
<pre>router.route('/api/games/by/:userId')<br/>    .post(authCtrl.requireSignin, gameCtrl.create)</pre>
<p>A <kbd>POST</kbd> request to this route will process the <kbd>:userId</kbd> param, verify that <span>the current user is signed in, and then create a new game with the game data passed in the request. </span></p>
<p><span>The</span> <kbd>game.routes.js</kbd> <span>file containing this route declaration will be very similar to the</span> <kbd>user.routes</kbd> <span>file, and to load these new routes in the</span> Express<span> app, we need to mount the game routes in</span> <kbd>express.js</kbd><span>, just as we did for the auth and user routes. The game routes can be mounted in the Express app by adding the following line of code:</span></p>
<p><kbd>mern-vrgame/server/express.js</kbd>:</p>
<pre>app.use('/', gameRoutes)</pre>
<p>This will make the declared game routes available for receiving requests when the server is running.</p>
<p>After a request is received by this create game API, to process the<span> </span><kbd>:userId</kbd><span> </span>param and retrieve the associated user from the database we will utilize the<span> </span><kbd>userByID</kbd><span> </span>method from the user controller. We will also add the following code to the game routes, so the user is available in the<span> </span><kbd>request</kbd><span> </span>object:</p>
<p><kbd><span>mern-vrgame/server/routes/game.routes.js</span></kbd>:</p>
<pre>router.param('userId', userCtrl.userByID)</pre>
<p>Once the user authentication is verified after receiving the <kbd>POST</kbd> request containing the game data in the body, the <kbd>create</kbd> controller method is invoked next, to add the new game to the database. This <kbd>create</kbd> controller method is defined as shown in the following code:</p>
<p><kbd>mern-vrgame/server/controllers/game.controller.js</kbd></p>
<pre>const create = async (req, res, next) =&gt; {<br/>  const game = new Game(req.body)<br/>  game.maker = req.profile<br/>  try{<br/>    let result = await game.save()<br/>    res.status(200).json(result)<br/>  } catch (err) {<br/>    return res.status(400).json({<br/>    error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>In this <kbd>create</kbd> method, a new game document is created according to the game model and the data passed in the request body from the client side. Then, this document is saved in the Game collection after the user reference is set as the game maker.</p>
<p>On the frontend, we will add a corresponding <kbd>fetch</kbd> method in <kbd>api-game.js</kbd> to make a <kbd>POST</kbd> request to the create game API by passing the form data collected from the signed-in user. This <kbd>fetch</kbd> method is defined as shown in the following code:</p>
<p><kbd><span>mern-vrgame/client/game/api-game.js</span></kbd></p>
<pre>const create = async (params, credentials, game) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/games/by/'+ params.userId, {<br/>      method: 'POST',<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Content-Type': 'application/json',<br/>        'Authorization': 'Bearer ' + credentials.t<br/>      },<br/>      body: JSON.stringify(game)<br/>    })<br/>    return await response.json()<br/>  } catch(err) { <br/>    console.log(err)<br/>  }<br/>}</pre>
<p>This <kbd>fetch</kbd> method will be used in the frontend and provided the new game data with the user credentials needed to make the <kbd>POST</kbd> request to the create game API. The response from the <kbd>fetch</kbd> method will tell the user if the game was created successfully.</p>
<p>This create game API endpoint is ready to be used in a form view that can collect the new game details from the user, so new games can be added to the database. In the next section, we will implement an API endpoint that will retrieve the games already added to the database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing all games</h1>
                </header>
            
            <article>
                
<p>In the MERN VR Game application, it will be possible to retrieve a list of all the games in the Game collection from the database using a list games API in the backend. We will implement this API endpoint in the backend by adding a <kbd>GET</kbd> route to the game routes, as shown in the following code: </p>
<p><kbd><span>mern-vrgame/server/routes/game.routes.js</span></kbd>:</p>
<pre>router.route('/api/games')<br/>    .get(gameCtrl.list)</pre>
<p>A <kbd>GET</kbd> request to <kbd>/api/games</kbd> will execute the <kbd>list</kbd> controller method, which<span> will query the Game collection in the database, to return all the games in the response to the client.</span></p>
<p><span>This <kbd>list</kbd> controller method will be defined as follows:</span></p>
<p><kbd><span>mern-vrgame/server/controllers/game.controller.js</span></kbd>:</p>
<pre>const list = async (req, res) =&gt; {<br/>  try {<br/>    let games = await Game.find({}).populate('maker', '_id name').sort('-created').exec()<br/>    res.json(games)<br/>  } catch (err) {<br/>    return res.status(400).json({<br/>    error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>In this method, the results retrieved by the query to the Game collection are sorted by the date of creation, with the latest games listed first. Each game in the list will also populate the name and ID of the user who created it. The resulting list of <span>sorted</span> games is returned in the response to the requesting client. </p>
<p>In the frontend, to fetch the games using this list API, we will set up a corresponding <kbd>fetch</kbd> method in <kbd>api-game.js</kbd>, as shown in the following code:</p>
<p><kbd><span>mern-vrgame/client/game/api-game.js</span></kbd>:</p>
<pre>const list = async (signal) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/games', {<br/>      method: 'GET',<br/>      signal: signal<br/>    })<br/>    return await response.json()<br/>  } catch(err) { <br/>    console.log(err)<br/>  }<br/>}</pre>
<p>This <kbd>fetch</kbd> method can be used in any frontend interface to make a call to the list games API. The <kbd>fetch</kbd> will make a <kbd>GET</kbd> request to the API and receive the list of games in the response, which can be rendered in the interface. In the next section, we will implement another listing API that will only return the games made by a specific user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing games by the maker</h1>
                </header>
            
            <article>
                
<p><span>In the MERN VR Game application, it will also be possible to retrieve a list of games made by a specific user. To implement this, we will add another API endpoint in the backend that accepts a <kbd>GET</kbd> request at the <kbd>/api/games/by/:userId</kbd> route. This route will be declared with the other game routes, as shown in the following code:</span></p>
<p><kbd><span>mern-vrgame/server/routes/game.routes.js</span></kbd>:</p>
<pre>router.route('/api/games/by/:userId')<br/>    .get(gameCtrl.listByMaker)</pre>
<p>A <kbd>GET</kbd> request received at this route will invoke the <kbd>listByMaker</kbd> controller method, which will <span>query the Game collection in the database to get the matching games</span>. The <kbd>listByMaker</kbd> controller method will be defined as follows:</p>
<p><span><kbd>mern-vrgame/server/controllers/game.controller.js</kbd>:</span></p>
<pre>const listByMaker = async (req, res) =&gt; {<br/>  try {<br/>    let games = await Game.find({maker:<br/>      req.profile._id}).populate('maker', '_id name')<br/>    res.json(games)<br/>  } catch (err) {<br/>    return res.status(400).json({<br/>     error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>In the query to the Game collection in this method, we find all the games where the <kbd>maker</kbd> field matches the user specified in the <kbd>userId</kbd> route parameter. The retrieved games will contain the maker name and ID and will be returned in the response to the requesting client.</p>
<p>In the frontend, to fetch the games for a specific user with this list by the maker API, we will add a corresponding <kbd>fetch</kbd> method in <kbd>api-game.js</kbd>, as shown in the following code:</p>
<p><kbd><span>mern-vrgame/client/game/api-game.js</span></kbd>:</p>
<pre>const listByMaker = async (params, signal) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/games/by/'+params.userId, {<br/>      method: 'GET',<br/>      signal: signal,<br/>    })<br/>    return await response.json()<br/>  } catch(err) { <br/>    console.log(err)<br/>  }<br/>}</pre>
<p><span>This <kbd>fetch</kbd> method can be invoked in the frontend interface with the user ID to make a call to the list games by the maker API. The </span><kbd>fetch</kbd><span> method will make a <kbd>GET</kbd> request to the API and receive the list of games made by the user specified in the URL. In the next section, we will implement a similar <kbd>GET</kbd> API to retrieve details of an individual game.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading a game</h1>
                </header>
            
            <article>
                
<p>In the backend of the MERN VR Game application, we will expose an API that will retrieve the details of an individual game, specified by its ID in the game collection. To achieve this, w<span>e can add a </span><kbd>GET</kbd><span> API that queries the </span>Game<span> collection with an ID and returns the corresponding game document in the response. </span>We will start implementing this API to fetch a single game by declaring a route that accepts a <kbd>GET</kbd> request at <kbd>'/api/game/:gameId'</kbd>, as shown in the following code:</p>
<p><kbd><span>mern-vrgame/server/routes/game.routes.js</span></kbd>:</p>
<pre>router.route('/api/game/:gameId')<br/>    .get(gameCtrl.read)</pre>
<p>When a request is received at this route, the <kbd>:gameId</kbd> param in the route URL will be processed first to retrieve the individual game from the database. So, we will also add the following to the game routes:</p>
<pre>router.param('gameId', gameCtrl.gameByID)</pre>
<p>The presence of the <kbd>:gameId</kbd> param in the route will invoke the <kbd>gameByID</kbd> controller method, which is similar to the <kbd>userByID</kbd> controller method. It will retrieve the game from the database and attach it to the <kbd>request</kbd> object to be used in the <kbd>next</kbd> method. T<span>his </span><kbd>gameByID</kbd><span> controller method is defined as shown in the following code:</span></p>
<p><span><kbd>mern-vrgame/server/controllers/game.controller.js</kbd>:</span></p>
<pre>const gameByID = async (req, res, next, id) =&gt; {<br/>  try { <br/>    let game = await Game.findById(id).populate('maker', '_id name').exec()<br/>    if (!game)<br/>      return res.status('400').json({<br/>        error: "Game not found"<br/>      })<br/>    req.game = game<br/>    next()<br/>  } catch (err) {<br/>    return res.status('400').json({<br/>      error: "Could not retrieve game"<br/>    })<br/>  }<br/>}</pre>
<p>The game queried from the database will also contain the name and ID details of the maker, as specified in the <kbd>populate()</kbd> method. The <kbd>next</kbd> method—in this case, the <kbd>read</kbd> controller method—simply returns this retrieved game in response to the client. This <kbd>read</kbd><span> controller method is defined as follows:</span></p>
<p><kbd><span>mern-vrgame/server/controllers/game.controller.js</span></kbd>:</p>
<pre>const read = (req, res) =&gt; {<br/>  return res.json(req.game)<br/>}</pre>
<p>This API to read a single game's details will be used to load a game in the React 360 implementation of the game world. We can call this API in the frontend code using a <kbd>fetch</kbd> method, <span>to retrieve the details of an individual game according to its ID. A corresponding <kbd>fetch</kbd> method can be defined to call this game API, as shown in the following code:</span></p>
<p><kbd><span>mern-vrgame/client/game/api-game.js</span></kbd>:</p>
<pre>const read = async (params) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/game/' + params.gameId, {<br/>      method: 'GET'<br/>    })<br/>    return await response.json()<br/>  } catch(err) { <br/>    console.log(err)<br/>  }<br/>}</pre>
<p>This <kbd>read</kbd> method will take the game ID in the <kbd>params</kbd> and make a <kbd>GET</kbd> request to the API, using a <kbd>fetch</kbd> method.</p>
<p>This API for loading a single game will be used for the React views fetching a game detail and also the React 360 game view, which will render the game interface in the MERN VR Game application. In the next section, we will implement the API that will allow makers to update the games they already created on the platform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Editing a game</h1>
                </header>
            
            <article>
                
<p>Authorized users who are signed in—and also the maker of a specific game—will be able to edit the details of that game in the database. To enable this feature, we will implement an edit game API in the backend. We will add a <kbd>PUT</kbd> route that allows an authorized user to edit one of their games. The route will be declared as follows:</p>
<p><span><kbd>mern-vrgame/server/routes/game.routes.js</kbd>:</span></p>
<pre>router.route('/api/games/:gameId')<br/>    .put(authCtrl.requireSignin, gameCtrl.isMaker, gameCtrl.update)</pre>
<p>A <kbd>PUT</kbd> request to <kbd>'/api/games/:gameId'</kbd> will first execute the <kbd>gameByID</kbd> controller method to retrieve the specific game's details. The <kbd>requireSignin</kbd> auth controller method will also be called to ensure the current user is signed in. Then, the <kbd>isMaker</kbd> controller method will determine whether the current user is the maker of this specific game, before finally running the game <kbd>update</kbd> controller method to modify the game in the database.</p>
<p>The <kbd>isMaker</kbd> controller method ensures that the signed-in user is actually the maker of the game being edited, and it is defined as shown in the following code:</p>
<p><span><kbd>mern-vrgame/server/controllers/game.controller.js</kbd>:</span></p>
<pre>const isMaker = (req, res, next) =&gt; {<br/>  let isMaker = req.game &amp;&amp; req.auth &amp;&amp; req.game.maker._id == req.auth._id<br/>  if(!isMaker){<br/>    return res.status('403').json({<br/>      error: "User is not authorized"<br/>    })<br/>  }<br/>  next()<br/>}</pre>
<p>If the <kbd>isMaker</kbd> condition is not met, <span>that means the currently signed-in user is not the maker of the game being edited, and </span><span>an authorization error is returned in the response. </span>But if the condition is met, the <kbd>next</kbd> method is invoked instead. In this case, the update controller method is the <kbd>next</kbd> method, and it saves the changes to the game in the database. This update method is defined as shown in the following code:</p>
<p><kbd><span>mern-vrgame/server/controllers/game.controller.js</span></kbd>:</p>
<pre>const update = async (req, res) =&gt; {<br/>  try {<br/>  let game = req.game<br/>  game = extend(game, req.body)<br/>  game.updated = Date.now()<br/>  await game.save()<br/>    res.json(game)<br/>  } catch (err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p><span>This <kbd>update</kbd> method will take the existing game details and the form data received in the request body to merge the changes and save the updated game to the Game collection in the database.</span></p>
<p>This edit game API can be called in the frontend view using a <kbd>fetch</kbd> method that takes the changes as form data and sends it with the request to the backend, along with user credentials. The corresponding <kbd>fetch</kbd> method is defined as shown in the following code: </p>
<p><kbd><span>mern-vrgame/client/game/api-game.js</span></kbd>:</p>
<pre>const update = async (params, credentials, game) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/games/' + params.gameId, {<br/>      method: 'PUT',<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Content-Type': 'application/json',<br/>        'Authorization': 'Bearer ' + credentials.t<br/>      },<br/>      body: JSON.stringify(game)<br/>    })<br/>    return await response.json()<br/>  } catch(err) { <br/>    console.log(err)<br/>  }<br/>}</pre>
<p>This method makes the <kbd>PUT</kbd> request to the edit game API, providing the changes to the game in the request body, the current user's credentials in the request header, and the ID of the game to be edited in the route URL. This method can be used in the frontend, which renders a form allowing users to update the game details. In the next section, we will implement another API in the backend that will allow authorized users to delete the games that they created on the platform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting a game </h1>
                </header>
            
            <article>
                
<p>An authenticated and authorized user will be able to delete any of the games they created on the application. To enable this feature, we will implement a delete game API in the backend. We<span> will start by adding a</span> <kbd>DELETE</kbd><span> route that allows an authorized maker to delete one of their own games, as shown in the following code:</span></p>
<p><kbd><span>mern-vrgame/server/routes/game.routes.js</span></kbd>:</p>
<pre>router.route('/api/games/:gameId')<br/>    .delete(authCtrl.requireSignin, gameCtrl.isMaker, gameCtrl.remove)</pre>
<p>The flow of the controller method execution on the server, after receiving the <kbd>DELETE</kbd> request at <kbd>api/games/:gameId</kbd>, will be similar to the edit game API, with the final call made to the <kbd>remove</kbd> controller method instead of <kbd>update</kbd>.</p>
<p>The <kbd>remove</kbd> controller method deletes the specified game from the database when a <kbd>DELETE</kbd> request is received at <kbd>/api/games/:gameId</kbd>, and it has been verified that the current user is the original maker of the given game. <span>The </span><kbd>remove</kbd><span> controller method is defined as shown in the following code:</span></p>
<p><span><kbd>mern-vrgame/server/controllers/game.controller.js</kbd>:</span></p>
<pre>const remove = async (req, res) =&gt; {<br/>  try {<br/>    let game = req.game<br/>    let deletedGame = await game.remove()<br/>    res.json(deletedGame)<br/>  } catch (err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>This <kbd>remove</kbd> method permanently deletes the specified game from the game collection in the database.</p>
<p>To use this API from the frontend, we will add a corresponding <kbd>remove</kbd> method in <kbd>api-game.js</kbd> to make a fetch request to the delete game API. This <kbd>fetch</kbd> method is defined as follows:</p>
<p><span><kbd>mern-vrgame/client/game/api-game.js</kbd>:</span></p>
<pre>const remove = async (params, credentials) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/games/' + params.gameId, {<br/>      method: 'DELETE',<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Content-Type': 'application/json',<br/>        'Authorization': 'Bearer ' + credentials.t<br/>      }<br/>    })<br/>    return await response.json()<br/>  } catch(err) { <br/>    console.log(err)<br/>  }<br/>}</pre>
<p>This method uses <kbd>fetch</kbd> to make a <kbd>DELETE</kbd> request to the delete game API. It takes the game ID in the <kbd>params</kbd> and the user credentials that are needed by the API endpoint in the backend to check if this current user is the authorized maker of the specified game. If the request is successful and the corresponding game is removed from the database, a success message is returned in the response.</p>
<p>With these game CRUD APIs functional in the backend, we are ready to implement the frontend that will use these APIs to allow users to create new games, list the games, modify existing games, and load a single game in the React 360 game view. We can start building out this frontend in the next section, starting with the React views for creating and editing games in the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a form for creating and editing games</h1>
                </header>
            
            <article>
                
<p>Users registered on the MERN VR Game application will be able to make new games and modify these games from views on the application. To implement these views, we will add React components that allow users to compose and modify the game details and VR object details for each game. As the form for creating new and editing existing games will have similar form fields for composing game details and VR object details, we will make reusable components that can be used both for creating and editing purposes. In the following sections, we will discuss the form views for creating a new game and editing an existing game, and the implementation of the common form components in these views. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making a new game</h1>
                </header>
            
            <article>
                
<p>When any user signs into the application, they will be given the option to make their own VR game. They will see a <span class="packt_screen">MAKE GAME</span> link on the menu that will navigate them to a form where they can fill in the game details to create a new game on the platform. In the following sections, we will update the frontend code to add this link on the menu and implement the <kbd>NewGame</kbd> component, which will contain the form to create a new game. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the menu</h1>
                </header>
            
            <article>
                
<p>We will update the navigation menu in the application to add the <span class="packt_screen">MAKE GAME</span> button, which will appear conditionally based on whether the user is signed in, and redirect the user to a view containing the form to create a new game. The <span><span class="packt_screen">MAKE GAME</span></span> button will render on the menu, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-915 image-border" src="assets/47caf224-ac99-45ab-8338-4adccd1d6fcf.png" style="width:15.25em;height:1.75em;"/></div>
<p>To add this button to the <kbd>Menu</kbd> component, we will use a <kbd>Link</kbd> component with the route for the <kbd>NewGame</kbd> component containing the form. To make it render conditionally, we will place it right before the <span class="packt_screen">MY PROFILE</span> link shown in the preceding screenshot, in the section that renders only when the user is authenticated. The button code will be added as shown in the following code:</p>
<p><span><kbd>mern-vrgame/client/core/Menu.js</kbd>:</span></p>
<pre>&lt;Link to="/game/new"&gt;<br/>   &lt;Button style={isActive(history, "/game/new")}&gt;<br/>       &lt;AddBoxIcon color="secondary"/&gt; Make Game<br/>   &lt;/Button&gt;<br/>&lt;/Link&gt;</pre>
<p>This will show the<span class="packt_screen"> <span>MAKE GAME</span></span> option to signed-in users, and they can click on it to be redirected to the <kbd>/game/new</kbd> route containing the form view for making a new game on the platform. In the next section, we will look at the component that will render this form.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The NewGame component</h1>
                </header>
            
            <article>
                
<p>We will implement the form view for creating a new game in the <kbd>NewGame</kbd> React component. This form view will allow users to fill out the fields for a single game. The <kbd>NewGame</kbd> component will render these form elements corresponding to the game details, including VR object details,<span> as shown in the following screenshot:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-916 image-border" src="assets/1d4ce768-afba-404d-bef4-74944d75344b.png" style="width:36.75em;height:29.50em;"/></div>
<p>The <kbd>NewGame</kbd> component will use the <kbd>GameForm</kbd> component, which will contain all the rendered form fields, to compose this new game form. The <kbd>GameForm</kbd> component will be a reusable component that we will use in both the create and edit forms.</p>
<p>When added to the <kbd>NewGame</kbd> component, it takes an <kbd>onSubmit</kbd> method as a prop, along <span>with any server-returned error messages</span><span>, as shown in the following code:</span></p>
<p><span><kbd>mern-vrgame/client/game/NewGame.js</kbd>:</span></p>
<pre>&lt;GameForm onSubmit={clickSubmit} errorMsg={error}/&gt;</pre>
<p>The method passed in the <kbd>onSubmit</kbd> prop will be<span> executed when the user submits the form. </span>The <kbd>clickSubmit</kbd> method passed in this case is defined in the <kbd>NewGame</kbd> component. It uses the create game <kbd>fetch</kbd> method from <kbd>api-game.js</kbd> to make a <kbd>POST</kbd> request to the create game API with the game form data and user details. </p>
<p><span>This </span><kbd>clickSubmit</kbd><span> method is defined as shown in the following code:</span></p>
<p><span><kbd>mern-vrgame/client/game/NewGame.js</kbd>:</span></p>
<pre>  const clickSubmit = game =&gt; event =&gt; {<br/>    const jwt = auth.isAuthenticated()<br/>    create({<br/>      userId: jwt.user._id<br/>    }, {<br/>      t: jwt.token<br/>    }, game).then((data) =&gt; {<br/>      if (data.error) {<br/>        setError(data.error)<br/>      } else {<br/>        setError('')<br/>        setRedirect(true)<br/>      }<br/>    })<br/>  }</pre>
<p>If the user makes an error while entering the game details in the form, the backend sends back an error message when this <kbd>clickSubmit</kbd> method is called on form submission. If there are no errors and the game is successfully created in the database, the user is redirected to another view.</p>
<p>To load this <kbd>NewGame</kbd> component at a specified URL and only for authenticated users, we will add a <kbd>PrivateRoute</kbd> in <kbd>MainRouter</kbd>, as shown in the following code:</p>
<p><kbd><span>mern-vrgame/client/MainRouter.js</span></kbd>:</p>
<pre>&lt;PrivateRoute path="/game/new" component={NewGame}/&gt;</pre>
<p><span>This will make the </span><kbd>NewGame</kbd><span> component load in the browser at the </span><kbd>/game/new</kbd><span> path when an authenticated user is accessing it. In the next section, we will see a similar implementation for rendering the same form to edit an existing game from the database.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Editing the game</h1>
                </header>
            
            <article>
                
<p>Users will be able to edit the games they made on the platform using a form similar to the form for creating new games. We will implement this edit game view in the <kbd>EditGame</kbd> component, which will render the game form fields pre-populated with the existing game's details. We will look at the implementation of this <kbd>EditGame</kbd> component in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The EditGame component</h1>
                </header>
            
            <article>
                
<p>Just as in the <kbd>NewGame</kbd> component, the <kbd>EditGame</kbd> component will also use the <kbd>GameForm</kbd> component to render the form elements. But in this form, the fields will load the current values of the game to be edited, and users will be able to update these values, as pictured in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-972 image-border" src="assets/15fb097c-8223-4dee-ad46-79565b28ace1.png" style="width:39.92em;height:43.42em;"/></div>
<p>In the case of this <kbd>EditGame</kbd> component, the <kbd>GameForm</kbd> will take the given game's ID as a prop so that it can fetch the game details, in addition to the <kbd>onSubmit</kbd> method and server-generated error message, if any. The <kbd>GameForm</kbd> component will be added to the <kbd>EditGame</kbd> component with these props, as follows:</p>
<p><span><kbd>mern-vrgame/client/game/EditGame.js</kbd>:</span></p>
<pre>&lt;GameForm gameId={params.gameId} onSubmit={clickSubmit} errorMsg={error}/&gt;</pre>
<p>The <kbd>clickSubmit</kbd> method for the edit form will use the update game <kbd>fetch</kbd> method in <kbd>api-game.js</kbd> to make a <kbd>PUT</kbd> request to the edit game API with the form data and user details. <span>The </span><kbd>clickSubmit</kbd><span> method for this edit form submission will be defined as shown in the following code:</span></p>
<p><span><kbd>mern-vrgame/client/game/EditGame.js</kbd>:</span></p>
<pre><br/>  const clickSubmit = game =&gt; event =&gt; {<br/>    const jwt = auth.isAuthenticated()<br/>    update({<br/>      gameId: match.params.gameId<br/>    }, {<br/>      t: jwt.token<br/>    }, game).then((data) =&gt; {<br/>      if (data.error) {<br/>        setError(data.error)<br/>      } else {<br/>        setError('')<br/>        setRedirect(true)<br/>      }<br/>    })<br/>  }</pre>
<p>If the user makes an error while modifying the game details in the form, the backend sends back an error message when this<span> </span><kbd>clickSubmit</kbd><span> </span>method is called on form submission. If there are no errors and the game is successfully updated in the database, the user is redirected to another view.</p>
<p>To load this<span> </span><kbd>EditGame</kbd><span> </span>component at a specified URL and only for authenticated users, we will add a<span> </span><kbd>PrivateRoute</kbd><span> </span>in<span> </span><kbd>MainRouter</kbd>, as shown in the following code:</p>
<p><span><kbd>mern-vrgame/client/MainRouter.js</kbd>:</span></p>
<pre>&lt;PrivateRoute path="/game/edit/:gameId" component={EditGame}/&gt;</pre>
<p><span>The </span><kbd>EditGame</kbd><span> component will load in the browser at the </span><kbd>/game/edit/:gameId</kbd><span> path when an authenticated user is accessing it. Both this <kbd>EditGame</kbd> component and the <kbd>NewGame</kbd> component use the <kbd>GameForm</kbd> component to render the form elements that allow users to add the details of a game. In the next section, we will discuss the implementation of this reusable <kbd>GameForm</kbd> component.  </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the GameForm component</h1>
                </header>
            
            <article>
                
<p>The <kbd>GameForm</kbd> component is used in both the <kbd>NewGame</kbd> and <kbd>EditGame</kbd> components, and it contains the elements that allow users to enter game details and VR object details for a single game. It may start with a blank game object or load an existing game. To begin the implementation of this component, we will first initialize a blank game object in the component state, as shown in the following code:</p>
<p><kbd>mern-vrgame/client/game/GameForm.js</kbd>:</p>
<pre>const [game, setGame] = useState({ name: '', <br/>                                   clue: '', <br/>                                   world: '', <br/>                                   answerObjects: [], <br/>                                   wrongObjects: []<br/>                                 })</pre>
<p>If the <kbd>GameForm</kbd> component receives a <kbd>gameId</kbd> prop from the parent component—such as from the <kbd>EditGame</kbd> component—then it will use the load game API to retrieve the game's details and set it to the state, to be rendered in the form view. We will make this API call in an <kbd>useEffect</kbd> hook, as shown in the following code:</p>
<p><kbd><span>mern-vrgame/client/game/GameForm.js</span></kbd>:</p>
<pre>  useEffect(() =&gt; {<br/>    if(props.gameId){<br/>      const abortController = new AbortController()<br/>      const signal = abortController.signal<br/>    <br/>      read({gameId: props.gameId}, signal).then((data) =&gt; {<br/>        if (data.error) {<br/>          setReadError(data.error)<br/>        } else {<br/>          setGame(data)<br/>        }<br/>      })<br/>      return function cleanup(){<br/>        abortController.abort()<br/>      }<br/>    }<br/>  }, [])</pre>
<p>In the <kbd>userEffect</kbd> hook, we first check if the props received from the parent component contain a <kbd>gameId</kbd> prop, and then use the value to make the load game API call. If the API call returns an error, we set the error to the state; otherwise, we set the retrieved game to the state. With this code, we will have the initial values for the game details initialized accordingly, to be used in the form view.</p>
<p>The form view part in the <kbd>GameForm</kbd> component will essentially have two parts: one part that takes simple game details—such as name, world image link, and clue text—as input, and a second part that allows users to add a variable number of VR objects to either the answer objects array or the wrong objects array. In the following sections, we will look at the implementations of these two parts that will make up the game details form view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inputting simple game details</h1>
                </header>
            
            <article>
                
<p>While creating or editing a game, users will first see the form elements for the simpler details of the game, such as name, world image URL, and the clue text. This form section with the simple game details will mostly be text input elements added using the Material-UI <kbd>TextField</kbd> component, with a change handling method passed to the <kbd>onChange</kbd> handler. We will build out this section in the <kbd>GameForm</kbd> component, which is implemented in <span><kbd>mern-vrgame/client/game/GameForm.js</kbd>,</span> with the following elements, as shown in the associated code:</p>
<ul>
<li><strong>Form title</strong>: The form title will be either <kbd>New Game</kbd> <span>or</span> <kbd>Edit Game</kbd><span>, depending on whether an existing game ID is passed as a prop to</span> <kbd>GameForm</kbd><span> from the parent component to which it is added, as shown in the following code:</span></li>
</ul>
<pre style="padding-left: 60px">&lt;Typography type="headline" component="h2"&gt;<br/>    {props.gameId? 'Edit': 'New'} Game<br/>&lt;/Typography&gt;</pre>
<ul>
<li><strong>Game world image input</strong>:<strong> </strong>We will render the background image URL in an <kbd>img</kbd> <span>element at the very top of the form to show users the image they added as the game world image URL. The image URL input will be taken in a <kbd>TextField</kbd> component below the rendered image, as shown in the following code:</span></li>
</ul>
<pre style="padding-left: 60px">&lt;img src={game.world}/&gt;<br/><span>&lt;TextField id="world" label="Game World Equirectangular Image (URL)" <br/>           value={game.world} onChange={handleChange('world')}/&gt;</span></pre>
<ul>
<li><strong>Game name</strong>: The game name will be added in a single <kbd>TextField</kbd><span> of the default</span> <kbd>text</kbd><span> type, as shown in the following code: </span></li>
</ul>
<pre style="padding-left: 60px">&lt;TextField id="name" label="Name" value={game.name} onChange={handleChange('name')}/&gt;</pre>
<ul>
<li><strong>Clue text:</strong> The clue text will be added to a multiline <kbd>TextField</kbd> <span>component, as shown in the following code:</span></li>
</ul>
<pre style="padding-left: 60px">&lt;TextField id="multiline-flexible" label="Clue Text" multiline rows="2" <br/>           value={game.clue} onChange={handleChange('clue')}/&gt;</pre>
<p>In these form elements added to the <kbd>GameForm</kbd> component, the input fields also take an <kbd>onChange</kbd> handler function, which is defined as <kbd>handleChange</kbd><span>. This </span><kbd>handleChange</kbd> <span>method will update the game values in the state whenever a user changes a value in an input element. The <kbd>handleChange</kbd> method is defined as follows:</span></p>
<p><span><kbd>mern-vrgame/client/game/GameForm.js</kbd>:</span></p>
<pre>const handleChange = name =&gt; event =&gt; {<br/>    const newGame = {...game}<br/>    newGame[name] = event.target.value<br/>    setGame(newGame)<br/>}</pre>
<p>In this method, based on the specific field value being changed, we update the corresponding attribute in the game object in the state. This captures the values entered by the user as simple details for their VR game. The form will also give the option to define arrays of VR objects that will also be a part of the game. In the next section, we will look at the form implementation that will allow users to manipulate arrays of VR objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifying arrays of VR objects</h1>
                </header>
            
            <article>
                
<p>Users will be able to define a dynamic number of VR objects in two different arrays for each game. In order to allow users to modify these arrays of <kbd>answerObjects</kbd> and <kbd>wrongObjects</kbd> that they wish to add to their VR game, <kbd>GameForm</kbd> will iterate through each array and render a VR object form component for each object. With this, it will become possible to add, remove, and modify VR objects from the <kbd>GameForm</kbd> component, as pictured in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-918 image-border" src="assets/8a9c4597-e610-4e84-a023-b409b333feef.png" style="width:45.83em;height:23.42em;"/></div>
<p><span>In the following sections, w</span>e will add these array manipulation functionalities in the  <kbd>GameForm</kbd> component. We will start by rendering each item in the VR object arrays and incorporate an option to add a new item or remove an existing item from<span> an array</span>. Then, since each item in an array will essentially be a form to enter VR object details, we will also discuss how to handle the input changes made within each item from the<span> <kbd>GameForm</kbd> component</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Iterating and rendering the object details form</h1>
                </header>
            
            <article>
                
<p><span>We will add the form interface seen in the previous section with</span> Material-UI <kbd>ExpansionPanel</kbd> components to create a modifiable list of VR objects for each type of VR object array in the given game.</p>
<p>Inside the nested <kbd>ExpansionPanelDetails</kbd> component, we will iterate through the <kbd>answerObjects</kbd> array or the <kbd>wrongObjects</kbd> array to render a <kbd>VRObjectForm</kbd> component for each VR object, as shown in the following code:</p>
<p><span><kbd>mern-vrgame/client/game/GameForm.js</kbd>:</span></p>
<pre>&lt;ExpansionPanel&gt;<br/>    &lt;ExpansionPanelSummary expandIcon={&lt;ExpandMoreIcon /&gt;}&gt;<br/>        &lt;Typography&gt;VR Objects to collect&lt;/Typography&gt;<br/>    &lt;/ExpansionPanelSummary&gt;<br/>    &lt;ExpansionPanelDetails&gt; {<br/>        <strong>game.answerObjects.map((item, i) =&gt; {</strong><br/><strong>          return &lt;div key={i}&gt;</strong><br/><strong>           &lt;VRObjectForm index={i} type={'answerObjects'}<br/>              handleUpdate={handleObjectChange} <br/>                vrObject={item} <br/>                  removeObject={removeObject}/&gt;</strong><br/><strong>          &lt;/div&gt;</strong><br/><strong>        })</strong><br/>      }<br/>    ...<br/>    &lt;/ExpansionPanelDetails&gt;<br/>&lt;/ExpansionPanel&gt;</pre>
<p>To render each object in the array, we use a <span><kbd>VRObjectForm</kbd> component. </span>We will look at the specific implementation of the <kbd>VRObjectForm</kbd> component later in the chapter. While adding <kbd>VRObjectForm</kbd> in this code, we pass the single <kbd>vrObject</kbd> item as a prop, along with the current <kbd>index</kbd> in the array, the type of the array, and two methods for updating the state in <kbd>GameForm</kbd> when the array details are modified by changing details or deleting an object from within the <kbd>VRObjectForm</kbd> component. This will render a form for each VR object in the arrays associated with the game in the <kbd>GameForm</kbd> component. In the next section, we will see the implementation for including an option to add new objects to these arrays. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a new object to the array</h1>
                </header>
            
            <article>
                
<p>For each array rendered in the game form, we will add a button that will let users push new VR objects to the given array. This button to add an object will render a new <kbd>VRObjectForm</kbd> component to take the details of a new VR object. We will add this button to the<span> </span><kbd>ExpansionPanelDetails</kbd><span> component after the iteration code, as shown in the following code:</span></p>
<p><kbd><span>mern-vrgame/client/game/GameForm.js</span></kbd><span>:</span></p>
<pre>&lt;ExpansionPanelDetails&gt;<br/>...<br/><strong>      &lt;Button color="primary" variant="contained" </strong><br/><strong>              onClick={addObject('answerObjects')}&gt;</strong><br/><strong>                    &lt;AddBoxIcon color="secondary"/&gt; </strong><br/><strong>                    Add Object</strong><br/><strong>      &lt;/Button&gt;</strong><br/>&lt;/ExpansionPanelDetails&gt;</pre>
<p>This <span class="packt_screen">ADD OBJECT</span> button will render at the end of each list of VR object forms. When clicked on, it will add a new blank VR object form by invoking the <kbd>addObject</kbd> method. This <kbd>addObject</kbd> method will be defined as follows:</p>
<p><kbd><span>mern-vrgame/client/game/GameForm.js</span></kbd>:</p>
<pre>  const addObject = name =&gt; event =&gt; {<br/>    const newGame = {...game}<br/>    newGame[name].push({})<br/>    setGame(newGame)<br/>  }</pre>
<p><span>The <kbd>addObject</kbd> method is passed the array type so we know which array the user wants to add the new object to. In this method, we will just add an empty object to the array being iterated, so an empty form is rendered in its place, which users can fill out to enter new object details. In the next section, we will see how to let users remove one of these items from a list of VR object forms.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing an object from the array</h1>
                </header>
            
            <article>
                
<p>Each of the items rendered in the list of VR object forms can also be removed from the list by the user. The <kbd>VRObjectForm</kbd> component displaying an item will contain a delete option, which will remove the object from the given array.</p>
<p>To implement the remove item functionality for this <span class="packt_screen">DELETE</span> button, we will pass a <kbd>removeObject</kbd> method as a prop to the <kbd>VRObjectForm</kbd> component <span>from the parent </span><kbd>GameForm</kbd><span> component.</span> This method will allow the array to be updated in the parent component's<span> </span>state when a user clicks <span class="packt_screen">DELETE</span> on a specific <kbd>VRObjectForm</kbd>. This<span> </span><kbd>removeObject</kbd><span> method will be defined as shown in the following code:</span></p>
<p><span><kbd>mern-vrgame/client/game/GameForm.js</kbd>:</span></p>
<pre>  const removeObject = (type, index) =&gt; event =&gt; {<br/>    const newGame = {...game}<br/>    newGame[type].splice(index, 1)<br/>    setGame(newGame)<br/>  }</pre>
<p>In this method, the VR object corresponding to the item clicked will be removed by slicing at the given <kbd>index</kbd> from the array with the specified array <kbd>type</kbd>. This updated object array in the game will be reflected in the view when it is set in the state, with the deleted VR object removed from the form view. In the next section, we will look at how to handle changes to the details of a VR object when the user updates values in a VR object form, which is rendered according to items in the VR object arrays.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling the object detail change</h1>
                </header>
            
            <article>
                
<p>The details of any VR object in the game will be updated when the user changes input values in any of the fields in the corresponding VR object form. To register this update, the <kbd>GameForm</kbd> that houses the forms for the VR objects will pass the <kbd>handleObjectChange</kbd> method to the <kbd>VRObjectForm</kbd> component, which will render the VR object form. This <kbd>handleObjectChange</kbd><span> method will be defined as follows:</span></p>
<p><kbd><span>mern-vrgame/client/game/GameForm.js</span></kbd>:</p>
<pre>const handleObjectChange = (index, type, name, val) =&gt; {<br/>    var newGame = {...game}<br/>    newGame[type][index][name] = val<br/>    setGame(newGame)<br/>}</pre>
<p>This <kbd>handleObjectChange</kbd> method will be used in the <kbd>VRObjectFrom</kbd> component to capture the changed input's value and update the corresponding field of the VR object at the specified <kbd>index</kbd> in the array of the given <kbd>type</kbd>, so it is reflected in the game object stored in the state in <kbd>GameForm</kbd>.</p>
<p>The <kbd>GameForm</kbd> component renders the form elements for modifying the details of a game, including the lists of VR objects. Using this form, users can add, modify, and delete VR objects in the lists. The lists render each item in a VR object form that the users can use to compose the details of the object. In the next section, we will implement the React component that renders this VR object form for each VR object in the game.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The VRObjectForm component</h1>
                </header>
            
            <article>
                
<p>We will implement the <kbd>VRObjectForm</kbd> component to render the input fields for modifying an individual VR object's details, which are added to the <kbd>answerObjects</kbd> and <kbd>wrongObjects</kbd> arrays of the game in the <kbd>GameForm</kbd> component. The <kbd>VRObjectForm</kbd> component will render a form, as pictured in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-919 image-border" src="assets/8bc1b0fb-6fa8-4f4f-a7f2-628662e64951.png" style="width:13.25em;height:12.92em;"/></div>
<p>To begin implementation of this <kbd>VRObjectForm</kbd><span> </span>component containing a VR object form, we will start by initializing the blank details of a <span>VR object</span> in the component's state with a <kbd>useState</kbd> hook, as shown in the following code:</p>
<p><kbd>mern-vrgame/client/game/VRObjectForm.js</kbd>:</p>
<pre>  const [values, setValues] = useState({<br/>    objUrl: '',<br/>    mtlUrl: '',<br/>    translateX: 0,<br/>    translateY: 0,<br/>    translateZ: 0,<br/>    rotateX: 0,<br/>    rotateY: 0,<br/>    rotateZ: 0,<br/>    scale: 1,<br/>    color:'white'<br/>  }) </pre>
<p>These details correspond to the schema defined for storing a VR object. When a <span><kbd>VRObjectForm</kbd> component is added to the <kbd>GameForm</kbd> component, it may receive an empty VR object or a VR object populated with details, depending on whether an empty form or a form with details of an existing object is being rendered. In the case that an existing VR object is passed as a prop, we will set the details of this object in the component state using an <kbd>useEffect</kbd> hook, as shown in the following code:</span></p>
<p><span><kbd>mern-vrgame/client/game/VRObjectForm.js</kbd>:</span></p>
<pre>  useEffect(() =&gt; {<br/>    if(props.vrObject &amp;&amp; Object.keys(props.vrObject).length != 0){<br/>      const vrObject = props.vrObject<br/>      setValues({...values,<br/>        objUrl: vrObject.objUrl,<br/>        mtlUrl: vrObject.mtlUrl,<br/>        translateX: Number(vrObject.translateX),<br/>        translateY: Number(vrObject.translateY),<br/>        translateZ: Number(vrObject.translateZ),<br/>        rotateX: Number(vrObject.rotateX),<br/>        rotateY: Number(vrObject.rotateY),<br/>        rotateZ: Number(vrObject.rotateZ),<br/>        scale: Number(vrObject.scale),<br/>        color:vrObject.color<br/>      })<br/>    }<br/>  }, [])</pre>
<p>In this <kbd>useEffect</kbd><span> hook, if the <kbd>vrObject</kbd> value passed in the prop is not an empty object, we set the details of the received VR object in the state. These values will be used in the input fields that make up the VR object form. </span>We will add the input fields corresponding to a VR object's details, in the view of <span><kbd>VRObjectForm</kbd> </span>using Material-UI <kbd>TextField</kbd> components, as shown in the code explained with the following list:</p>
<ul>
<li><strong>3D object file input</strong>: The OBJ and MTL file links will be collected for each VR object as text input using the <kbd>TextField</kbd> <span>components, as shown in the following code:</span></li>
</ul>
<pre style="padding-left: 60px">&lt;TextField label=".obj url" value={values.objUrl}<br/>    onChange={handleChange('objUrl')} /&gt;<br/>&lt;TextField label=".mtl url" value={values.mtlUrl}<br/>    onChange={handleChange('mtlUrl')} /&gt;</pre>
<ul>
<li><strong>Translate value input</strong>: The translate values of the VR object across the x, y, and z axes will be input in the <kbd>TextField</kbd> <span>components of the </span><kbd>number</kbd><span> type, as shown in the following code:</span></li>
</ul>
<pre style="padding-left: 60px">&lt;TextField type="number" value={values.translateX}<br/>    label="TranslateX" onChange={handleChange('translateX')} /&gt;<br/>&lt;TextField type="number" value={values.translateY}<br/>    label="TranslateY" onChange={handleChange( 'translateY')} /&gt;<br/>&lt;TextField type="number" value={values.translateZ}<br/>    label="TranslateZ" onChange={handleChange('translateZ')} /&gt;</pre>
<ul>
<li><strong>Rotate value input</strong>: The rotation<span> values of the VR object around the x, y, and z axes will be input in the</span> <kbd>TextField</kbd> <span>components of the </span><kbd>number</kbd><span> type, as shown in the following code:</span></li>
</ul>
<pre style="padding-left: 60px">&lt;TextField type="number" value={values.rotateX}<br/>    label="RotateX" onChange={handleChange('rotateX')} /&gt;<br/>&lt;TextField type="number" value={values.rotateY}<br/>    label="RotateY" onChange={handleChange('rotateY')} /&gt;<br/>&lt;TextField type="number" value={values.rotateZ}<br/>    label="RotateZ" onChange={handleChange('rotateZ')} /&gt;</pre>
<ul>
<li><strong>Scale value input</strong>: The scale <span>value for the VR object will be input in a</span> <kbd>TextField</kbd> <span>component of the </span><kbd>number</kbd><span> type, as shown in the following code:</span></li>
</ul>
<pre style="padding-left: 60px">&lt;TextField type="number" value={values.scale} <br/>    label="Scale" onChange={handleChange('scale')} /&gt;</pre>
<ul>
<li><strong>Object color input</strong>: The color value for the VR object will be input in a <kbd>TextField</kbd> <span>component of the </span><kbd>text</kbd><span> type, as shown in the following code:</span></li>
</ul>
<pre style="padding-left: 60px">&lt;TextField value={values.color} label="Color"<br/>    onChange={handleChange('color')} /&gt;</pre>
<p>These input fields will allow the user to set the details of a VR object in a game. When any of these VR object details are changed in these input fields by the user, the <kbd>handleChange</kbd> method will be invoked. T<span>his </span><kbd>handleChange</kbd><span> method will be defined as shown in the following code:</span></p>
<p><kbd><span>m</span><span>ern-vrgame/client</span><span>/game/VRObjectForm.js</span></kbd><span>:</span></p>
<pre>const handleChange = name =&gt; event =&gt; {<br/>    setValues({...values, [name]: event.target.value})<br/>    props.handleUpdate(props.index, props.type, name, event.target.value)<br/>}</pre>
<p><span>This </span><kbd>handleChange</kbd><span> method w</span><span>ill update the corresponding value in the state of the </span><kbd>VRObjectForm</kbd><span> component, and use the </span><kbd>handleUpdate</kbd><span> method passed as a prop from </span><kbd>GameForm</kbd><span> to update the VR object in the </span><kbd>GameForm</kbd><span> state with the changed value for the specific object detail.</span></p>
<p>The<span> </span><kbd>VRObjectForm</kbd><span> </span>will also contain a<span> </span><span class="packt_screen">DELETE</span><span> </span>button that will execute the<span> </span><kbd>removeObject</kbd><span> </span>method received in the <kbd>GameForm</kbd> as a prop, which will allow the given object to be removed from the list in the game. This delete button will be added to the view with the following code:</p>
<p><span><kbd>mern-vrgame/client/game/VRObjectForm.js</kbd>:</span></p>
<pre>&lt;Button <strong>onClick</strong>={<strong>props.removeObject(props.type, props.index</strong>)}&gt;<br/>    &lt;Icon style={{marginRight: '5px'}}&gt;cancel&lt;/Icon&gt; Delete<br/>&lt;/Button&gt;</pre>
<p>The<span> </span><kbd>removeObject</kbd><span> </span>method will take the value of the object array type and the array index position, to remove the given object from the relevant VR object array in the<span> </span><kbd>GameForm</kbd><span> component's </span>state.</p>
<p>With these implementations, the forms for creating and editing games are in place, complete with VR object input forms for arrays of varying sizes. We used reusable components to compose the form elements needed for creating and editing games, along with adding the capability for modifying arrays of VR objects in a game. Any registered user can use these forms to add and edit game details on the MERN VR Game application. In the next section, we will discuss the implementation of the views that will render different lists of games on the platform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the game list views</h1>
                </header>
            
            <article>
                
<p>Visitors to MERN VR Game will access the games on the application from lists rendered on the home page and individual user profiles. The home page will list all the games on the application, and the games by a specific maker will be listed on their user profile page. These list views will iterate through game data fetched using the backend APIs for listing games, and render details of each game in a reusable React component.</p>
<p>In the following sections, we will discuss the implementation for rendering all games and games only by a specific maker, using a reusable component for rendering each game on the list. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering lists of games</h1>
                </header>
            
            <article>
                
<p>We will render all the games available on the platform on the home page of the application. To implement this feature, the <kbd>Home</kbd> component will first fetch the list of all the games from the game collection in the database using the list game API. We will achieve this in an <kbd>useEffect</kbd> hook in the <kbd>Home</kbd> component, as shown in the following code: </p>
<p><kbd>mern-vrgame/client/core/Home.js</kbd>:</p>
<pre><br/>  useEffect(() =&gt; {<br/>    const abortController = new AbortController()<br/>    const signal = abortController.signal<br/><br/>    list(signal).then((data) =&gt; {<br/>      if (data.error) {<br/>        console.log(data.error)<br/>      } else {<br/>        setGames(data)<br/>      }<br/>    })<br/>    return function cleanup(){<br/>      abortController.abort()<br/>    }<br/>  }, [])</pre>
<p>The list of games retrieved from the server in this <kbd>useEffect</kbd> hook will be set to the state and iterated over to render a <kbd>GameDetail</kbd> component for each game in the list, as shown in the following code:</p>
<p><kbd><span>mern-vrgame/client/core/Home.js</span></kbd>:</p>
<pre>{games.map((game, i) =&gt; {<br/>     return <strong>&lt;GameDetail</strong> key={i} <strong>game</strong>={game} <strong>updateGames</strong>={updateGames}<strong>/&gt;</strong><br/>})}</pre>
<p>The <kbd>GameDetail</kbd> component, which will be implemented as a reusable component that renders details of a single game, will be passed the game details and a <kbd>updateGames</kbd> method. The <kbd>updateGames</kbd> method will allow the game list in the <kbd>Home</kbd> component to be updated if any of the games on the list are deleted by the maker. <span>The </span><kbd>updateGames</kbd><span> method is defined </span>as shown in the following code:</p>
<p><kbd><span>mern-vrgame/client/core/Home.js</span></kbd>:</p>
<pre>const updateGames = (game) =&gt; {<br/>    const updatedGames = [...games]<br/>    const index = updatedGames.indexOf(game)<br/>    updatedGames.splice(index, 1)<br/>    setGames(updatedGames)<br/>}</pre>
<p>The <kbd>updateGames</kbd> method will update the list rendered in the <kbd>Home</kbd> component by slicing the specified game from the array of games. This method will be invoked when a user deletes their game using the <span class="packt_screen">EDIT</span><span> and </span><span class="packt_screen">DELETE</span><span> options rendered conditionally in the</span> <kbd>GameDetail</kbd> component for the maker of the game, as pictured in the following screenshot of games listed in the home page of the application:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1c483d30-7b85-4772-b4ba-76bfe87b7022.png" style="width:59.58em;height:22.00em;"/></div>
<p>We can render a similar list view in the user profile page, showing only the games made by the corresponding user, as pictured in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-920 image-border" src="assets/4f4bd176-f9b7-497f-9136-ee64919a021f.png" style="width:31.33em;height:27.75em;"/></p>
<p>Similar to the implementation steps in the <kbd>Home</kbd> component, in this <kbd>Profile</kbd> component, we can fetch the list of games by the given user with a call to the associated list games by the maker API in an <kbd>useEffect</kbd> hook. With the retrieved list of games set in the state, we can iterate over it to render each game in a <kbd>GameDetail</kbd> component, as discussed earlier, for rendering all games on the home page. In the next section, we will discuss the implementation of this <kbd>GameDetail</kbd> component that will render the details of a single game. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The GameDetail component</h1>
                </header>
            
            <article>
                
<p>We will implement the <kbd>GameDetail</kbd> component to render individual games in any game list view in the application. This <kbd>GameDetail</kbd> component takes the game object as a prop, and renders the details of the game, along with a <span class="packt_screen">PLAY GAME</span> button that links to the VR game view, as pictured in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-921 image-border" src="assets/8eba3c66-44fe-4242-8a58-671e20588f89.png" style="width:28.75em;height:15.92em;"/></div>
<p>This component will also conditionally render <span><span class="packt_screen">EDIT</span></span> and <span class="packt_screen">DELETE</span> buttons if the current user is the maker of the game.</p>
<p>In the view code of the <kbd>GameDetail</kbd> component, we will first add the game details—such as the name, world image, clue text, and maker name—to give users an overview of the game. We will use Material-UI components to compose the interface with these details, as shown in the following code:</p>
<p><span><kbd>mern-vrgame/client/game/GameDetail.js</kbd>:</span></p>
<pre>&lt;Typography type="headline" component="h2"&gt;<br/>     {props.game.name}<br/>&lt;/Typography&gt;<br/>&lt;CardMedia image={props.game.world} <br/>           title={props.game.name}/&gt;<br/>&lt;Typography type="subheading" component="h4"&gt;<br/>     &lt;em&gt;by&lt;/em&gt;<br/>     {props.game.maker.name}<br/>&lt;/Typography&gt;<br/><span>&lt;CardContent</span>&gt;<br/>     &lt;Typography type="body1" component="p"&gt;<br/>          {props.game.clue}<br/>     &lt;/Typography&gt;<br/>&lt;/CardContent&gt;</pre>
<p>This code will render the game world image, game name, maker name, and clue text for the game passed in the props.</p>
<p>The <span class="packt_screen">PLAY GAME</span> button rendered in the <kbd>GameDetail</kbd> component will simply be a button wrapped in an HTML link element that points to the route that opens the React 360-generated <kbd>index.html</kbd> file (implementation for this route on the server is discussed in the <em>Playing the VR game</em> section). This <span class="packt_screen">PLAY GAME</span> link is added to the <kbd>GameDetail</kbd><span> component, as follows:</span></p>
<p><span><kbd>mern-vrgame/client/game/GameDetail.js</kbd>:</span></p>
<pre>&lt;a <strong>href={"/game/play?id=" + props.game._id} target='_self'</strong>&gt;<br/>    &lt;Button variant="contained" color="secondary" <br/>        className={classes.button}&gt;<br/>    Play Game<br/>    &lt;/Button&gt;<br/>&lt;/a&gt;</pre>
<p>The route to the game view takes the game ID as a query parameter. We set <kbd>target='_self'</kbd> on the link so React Router skips transitioning to the next state and lets the browser handle this link. What this will do is allow the browser to directly make the request to the server at this route when the link is clicked, and render the <kbd>index.html</kbd> file sent by the server in response to this request, allowing the user to start playing the rendered VR game immediately.</p>
<p>In the final section of the <kbd>GameDetail</kbd> component, we will conditionally show <span class="packt_screen">EDIT</span> and <span class="packt_screen">DELETE</span> options only if the currently signed-in user is also the maker of the game being rendered. We will add these options with the following code:</p>
<p><kbd><span>mern-vrgame/client/game/GameDetail.js</span></kbd>:</p>
<pre>{auth.isAuthenticated().user <br/>    &amp;&amp; auth.isAuthenticated().user._id == props.game.maker._id &amp;&amp; <br/>    (&lt;div&gt;<br/>       &lt;Link to={"/game/edit/" + props.game._id}&gt;<br/>          &lt;Button variant="raised" color="primary" <br/>         className={classes.editbutton}&gt;<br/>              Edit<br/>          &lt;/Button&gt;<br/>       &lt;/Link&gt;<br/>       &lt;DeleteGame game={props.game} <br/>                   removeGame={props.updateGames}/&gt;<br/>    &lt;/div&gt;)}</pre>
<p>After ensuring the current user is actually authenticated, we check if the user ID of the signed-in user matches the maker ID in the game. Then, accordingly, we render the <span class="packt_screen">EDIT</span> button linking to the edit form view, and the <span class="packt_screen">DELETE</span> option with a <kbd>DeleteGame</kbd> component. </p>
<p>The implementation of this <kbd>DeleteGame</kbd> component is similar to the <kbd>DeleteShop</kbd> component discussed in <a href="03fd3b4a-b7fd-4b42-ad7e-5bc34b5612b0.xhtml" target="_blank">Chapter 7</a>, <em>Exercising MERN Skills with an Online Marketplace</em>. Instead of a shop, the <kbd>DeleteGame</kbd> component will take the game to be deleted and the <kbd>updateGames</kbd> function definition received from the parent component as props. <span>After this implementation is integrated, the maker of a game will be able to remove the game from the platform.</span></p>
<p>Users visiting the MERN VR Game application can browse through the list of games rendered in these views and select to play a game by clicking the <span class="packt_screen">PLAY GAME</span> link rendered in the corresponding <kbd>GameDetail</kbd> component. In the next section, we will see how to update the server to handle a request to play a game.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Playing the VR game</h1>
                </header>
            
            <article>
                
<p>Users on the MERN VR Game application will be able to open and play any of the VR games from within the application. To enable this, we will add an API on the server that renders the <kbd>index.html</kbd> file, which was generated with React 360, as discussed in the previous chapter, <a href="4f633dd6-f392-490d-b3a6-eb5430b58ec8.xhtml" target="_blank">Chapter 13</a>, <em>Developing a Web-Based VR Game</em>. This API on the backend will receive a <kbd>GET</kbd> request at the following path:</p>
<pre>/game/play?id=&lt;game ID&gt;</pre>
<p>This path takes a <kbd>game ID</kbd> value as a query parameter. The <kbd>game ID</kbd> in this URL will be used in the React 360 code, as elaborated on later in the chapter, to fetch the game's details using the load game API. In the following section, we will look at the implementation of the backend API that will handle this <kbd>GET</kbd> request to start playing a game when the user clicks on the <span class="packt_screen">PLAY GAME</span> button.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the API to render the VR game view</h1>
                </header>
            
            <article>
                
<p>In order to implement the API that will render the VR game in the browser, we will add a route in the backend that will receive a <kbd>GET</kbd> request and open the <kbd>index.html</kbd> page from React 360.</p>
<p>This route will be declared in <kbd>game.routes.js</kbd> with the other game routes, as follows:</p>
<p><kbd>mern-vrgame/server/routes/game.routes.js</kbd>:</p>
<pre>router.route('/game/play')<br/>  .get(gameCtrl.playGame)</pre>
<p>A <kbd>GET</kbd> request received at this route will execute the <kbd>playGame</kbd> controller method, which will return the <kbd>index.html</kbd> page in response to the incoming request. The <kbd>playGame</kbd><span> controller method will be defined as shown in the following code:</span></p>
<p><kbd>mern-vrgame/server/controllers/game.controller.js</kbd>:</p>
<pre>const playGame = (req, res) =&gt; {<br/>  res.sendFile(process.cwd()+'/server/vr/index.html')<br/>}</pre>
<p><span>The</span> <kbd>playGame</kbd> <span>controller method</span> <span>will simply send the</span> <kbd>index.html</kbd> page <span>placed in the </span><kbd>/server/vr/</kbd> <span>folder to the requesting client.</span></p>
<p>In the browser, this will render the React 360 game code, which needs to fetch the game details from the database using the load game API and render the game world, along with the VR objects that the user can interact with. In the next section, we will see how the game view we built previously with React 360 needs to be updated to load these game details dynamically.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the game code in React 360</h1>
                </header>
            
            <article>
                
<p>With the game backend all set up in the MERN application, we can update the React 360 project code we developed in <a href="4f633dd6-f392-490d-b3a6-eb5430b58ec8.xhtml" target="_blank">Chapter 13</a><span>, </span><em>Developing a Web-Based VR Game</em>, to make it render games directly from the game collection in the database.</p>
<p>We will use the game ID in the link that opens the React 360 application to fetch game details, using the load game API from within the React 360 code. Then, we will set this retrieved game data to the state so that the game loads details from the database instead of the static sample data we used in <a href="4f633dd6-f392-490d-b3a6-eb5430b58ec8.xhtml"/><a href="4f633dd6-f392-490d-b3a6-eb5430b58ec8.xhtml" target="_blank">Chapter 13</a><span>, </span><em>Developing a Web-Based VR Game</em>. Once the code is updated, we can bundle it again and place the compiled files in the MERN application before trying out the integration, as discussed in the following sections. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting the game ID from a link</h1>
                </header>
            
            <article>
                
<p>In order to render the VR game based on the game the user chose to play from the MERN VR Game application, we need to retrieve the corresponding game ID from the link that loads the VR game view. In the <kbd>index.js</kbd> file of the React 360 project folder, we will update the <kbd>componentDidMount</kbd> method to first retrieve the game ID from the incoming URL, and then make a fetch call to the load game API, as shown in the following code:</p>
<p><span><kbd>/MERNVR/index.js</kbd>:</span></p>
<pre>componentDidMount = () =&gt; {<br/>    let <strong>gameId</strong> = Location.search.split('?id=')[1]<br/>    <strong>read</strong>({<br/>          gameId: gameId<br/>      }).then((data) =&gt; {<br/>        if (data.error) {<br/>          this.setState({error: data.error});<br/>        } else {<br/>          this.setState({<br/>            vrObjects: data.answerObjects.concat(data.wrongObjects),<br/>            game: data<br/>          });<br/>          Environment.setBackgroundImage(<br/>            {uri: data.world}<br/>          )<br/>        }<br/>    })<br/>}</pre>
<p><kbd>Location.search</kbd> gives us access to the query string in the incoming URL that loads <kbd>index.html</kbd>. The retrieved query string is <kbd>split</kbd> to get the <kbd>gameId</kbd> value from the <kbd>id</kbd> query parameter attached in the URL. We use this <kbd>gameId</kbd> value to fetch the game details with the load game API on the backend and set it to the state for the game and <kbd>vrObjects</kbd> values. To be able to use the load game API in the React 360 project, we will define a corresponding <kbd>fetch</kbd> method in the project, as discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetching the game data with the load game API</h1>
                </header>
            
            <article>
                
<p>We want to fetch the game data from within the React 360 code. In the React 360 project folder, we will add an <kbd>api-game.js</kbd> file that will contain a <kbd>read</kbd> fetch method that makes a call to the load game API on the server using the provided game ID. This <kbd>fetch</kbd> method will be defined as follows:</p>
<p><kbd><span>/MERNVR/api-game.js</span></kbd>:</p>
<pre>const read = (params) =&gt; {<br/>  return fetch('/api/game/' + params.gameId, {<br/>    method: 'GET'<br/>  }).then((response) =&gt; {<br/>    return response.json() <br/>  }).catch((err) =&gt; console.log(err)) <br/>}<br/>export {<br/>  read<br/>} </pre>
<p>This <kbd>fetch</kbd> method receives the game ID in the <kbd>params</kbd> and makes the API call to retrieve the corresponding game from the database. It is used in <kbd>componentDidMount</kbd> of the React 360 entry component, which is defined in the <kbd>index.js</kbd> file, to retrieve the game details, as discussed in the previous section.</p>
<div class="packt_infobox"><span>This updated React 360 code is available in the branch named <kbd>dynamic-game-second-edition</kbd> on the GitHub repository at</span><span> </span><a href="https://github.com/shamahoque/MERNVR/tree/dynamic-game-second-edition">github.com/shamahoque/MERNVR/tree/dynamic-game-second-edition</a><span>.</span></div>
<p>With the React 360 code updated and capable of retrieving and rendering game details based on the game ID specified in the incoming URL, we can bundle and integrate this updated code with the MERN VR Game application, as discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bundling and integrating the updated code</h1>
                </header>
            
            <article>
                
<p>With the React 360 code updated to fetch and render game details dynamically from the server, we can bundle this code using the provided bundle script and place the newly compiled files in the <kbd>dist</kbd> folder of the MERN VR Game project directory.</p>
<p>To bundle the React 360 code from the command line, go to the React 360 <kbd>MERNVR</kbd> project folder and run the following code:</p>
<pre><strong>yarn bundle</strong></pre>
<p>This will generate the <kbd>client.bundle.js</kbd> and <kbd>index.bundle.js</kbd> bundle files <span>in the <kbd>build/</kbd> folder </span>with the updated React 360 code. These files, along with the <kbd>index.html</kbd> file and <kbd>static_assets</kbd> folders, need to be added to the MERN VR Game application code, <span>as discussed in <a href="4f633dd6-f392-490d-b3a6-eb5430b58ec8.xhtml" target="_blank">Chapter 13</a>, <em>Developing a Web-Based VR Game</em>, to integrate the latest VR game code</span>.</p>
<p>With this integration completed, if we run the MERN VR Game application and click the <span class="packt_screen">PLAY GAME</span> link on any of the games, it should open up the game view with the details of the specific game rendered in the VR scene, and allow interaction with the VR objects, as specified in the gameplay.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we integrated the capabilities of the MERN stack technologies with React 360 to develop a dynamic VR game application for the web.</p>
<p>We extended the MERN skeleton application to build a working backend that stores VR game details and allows us to make API calls to manipulate these details. We added React views that let users modify games and browse through the games, with the option to launch and play the VR game at a specified route rendered directly by the server.</p>
<p>Finally, we updated the React 360 project code to pass data between the MERN application and the VR game view, by retrieving query parameters from the incoming URL, and using fetch to retrieve data with the game API.</p>
<p>This integration of the React 360 code with the MERN stack application produced a fully functioning and dynamic web-based VR game application, demonstrating how MERN stack technologies can be used and extended to create unique user experiences. You can apply the capabilities revealed here to build your own VR-infused full-stack web applications.</p>
<p>In the next chapter, we will reflect on the full-stack MERN applications built in this book, discussing not just the best practices that were followed but also the scope for improvements and further development.</p>


            </article>

            
        </section>
    </body></html>