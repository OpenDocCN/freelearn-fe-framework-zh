<html><head></head><body>
<div id="_idContainer023">
<h1 class="chapter-number" id="_idParaDest-83"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.2.1">Creating Dynamic Angular Components</span></h1>
<p><span class="koboSpan" id="kobo.3.1">When we are creating components, the flexibility and reusability of those components should be top priorities. </span><span class="koboSpan" id="kobo.3.2">You don’t want unnecessary dependencies inside your component and want to ensure the component can serve as many scenarios as possible without </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">becoming overcomplicated.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This chapter will teach you how to create truly dynamic UI components using content projection, template references, and template outlets. </span><span class="koboSpan" id="kobo.5.2">We will learn how to dynamically render components using the component outlet directive and the view </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">container reference.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">By the end of this chapter, you will know when and how to project content into UI components, effectively use templates inside your components, and output code in different places, depending on certain conditions. </span><span class="koboSpan" id="kobo.7.2">You will also be able to load and render components dynamically, enhancing the flexibility and performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">This chapter will cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">A deep dive into Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">content projection</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Using template references </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">and variables</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Rendering </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">components dynamically</span></span></li>
</ul>
<h1 id="_idParaDest-85"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.17.1">A deep dive into Angular content projection</span></h1>
<p><span class="koboSpan" id="kobo.18.1">Often, when </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.19.1">creating a component, you need to display a wide variety of content inside it. </span><span class="koboSpan" id="kobo.19.2">Some good examples include a modal component, a card, or a </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">tab component.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">Let’s consider </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.22.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">modal component</span></strong><span class="koboSpan" id="kobo.24.1">; you want the component to have a visible and hidden state, a backdrop, and some shared styling so that all your modals have the same look and feel. </span><span class="koboSpan" id="kobo.24.2">Yet the content inside each instance of the modal component will be wildly different. </span><span class="koboSpan" id="kobo.24.3">Sometimes, you want to display a form inside the modal, while other times, you want to use it to display text or provide actions or configurations to the user. </span><span class="koboSpan" id="kobo.24.4">Most likely, each modal you have within your application will have different </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">content inside.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">So, a question arises: how do we facilitate this need and create a component that can house any content it needs within its </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">HTML template?</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">You could </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.29.1">hardcode all the options and use inputs to configure the component, but this becomes unmaintainable really fast! </span><span class="koboSpan" id="kobo.29.2">Using </span><strong class="bold"><span class="koboSpan" id="kobo.30.1">content projection</span></strong><span class="koboSpan" id="kobo.31.1"> is the correct way to create a component that needs to display a wide variety of content inside its template. </span><span class="koboSpan" id="kobo.31.2">Angular content projection lets you define placeholders inside the HTML template of a component. </span><span class="koboSpan" id="kobo.31.3">You can fill these placeholders with any content by projecting the content inside the placeholder from the parent component HTML template where the dynamic component is declared. </span><span class="koboSpan" id="kobo.31.4">We will explore and use content projection ourselves by creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">modal component.</span></span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.33.1">Creating a modal component using content projection</span></h2>
<p><span class="koboSpan" id="kobo.34.1">Let’s </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.35.1">start by creating a modal component inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">common-components</span></strong><span class="koboSpan" id="kobo.37.1"> library of your </span><em class="italic"><span class="koboSpan" id="kobo.38.1">Nx monorepo</span></em><span class="koboSpan" id="kobo.39.1">. </span><span class="koboSpan" id="kobo.39.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">component</span></strong><span class="koboSpan" id="kobo.41.1"> class, add an input for the shown status of the modal and an output for the close event. </span><span class="koboSpan" id="kobo.41.2">Also, add input for the </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">modal title:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.43.1">
@Input({ required: true }) title = '';
@Input({ required: true }) shown: boolean;
@Output() shownChange = new EventEmitter&lt;boolean&gt;();</span></pre> <p><span class="koboSpan" id="kobo.44.1">Now, let’s create the HTML template for the modal component. </span><span class="koboSpan" id="kobo.44.2">Start with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">ng-container</span></strong><span class="koboSpan" id="kobo.46.1"> element. </span><span class="koboSpan" id="kobo.46.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">ng-container</span></strong><span class="koboSpan" id="kobo.48.1"> element sits the modal container and the backdrop. </span><span class="koboSpan" id="kobo.48.2">We must also place a </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">*ngIf</span></strong><span class="koboSpan" id="kobo.50.1"> directive with the shown status on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">ng-container</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.52.1"> element:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.53.1">
&lt;ng-container *ngIf="shown"&gt;
  &lt;div class=»modal-container»&gt;
  &lt;/div&gt;
  &lt;div class=»backdrop»&gt;&lt;/div&gt;
&lt;/ng-container&gt;</span></pre> <p><span class="koboSpan" id="kobo.54.1">Next, you can add a modal header and modal content area inside the modal container. </span><span class="koboSpan" id="kobo.54.2">The modal header will contain the title and a “X” button to close </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">the modal:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.56.1">
&lt;div class="modal-header"&gt;
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;span (click)=»shown = false; shownChange.emit()"&gt;X
  &lt;/span&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.57.1">Lastly, you </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.58.1">have to add the modal content area. </span><span class="koboSpan" id="kobo.58.2">This is where we will create the placeholder for our </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">content projection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.60.1">
&lt;div class="modal-content"&gt;
  </span><strong class="bold"><span class="koboSpan" id="kobo.61.1">&lt;ng-content&gt;&lt;/ng-content&gt;</span></strong><span class="koboSpan" id="kobo.62.1">
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.63.1">You can find the CSS for the modal component in this book’s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">repository:</span></span><span class="No-Break"> </span><a href="https://github.com/PacktPublishing/Effective-Angular/tree/feature/chapter-five/dynamic-components"><span class="No-Break"><span class="koboSpan" id="kobo.65.1">https://github.com/PacktPublishing/Effective-Angular/tree/feature/chapter-five/dynamic-components</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.66.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">As you can see, inside the modal content area, we defined an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">ng-content</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.69.1"> element:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.70.1">
&lt;ng-content&gt;&lt;/ng-content&gt;</span></pre> <p><span class="koboSpan" id="kobo.71.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">ng-content</span></strong><span class="koboSpan" id="kobo.73.1"> element is the placeholder for the projected content. </span><span class="koboSpan" id="kobo.73.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">ng-content</span></strong><span class="koboSpan" id="kobo.75.1"> element will display everything we project from the parent component into the </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">modal component.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">You project content from the parent component into the modal component by placing content between the component’s opening and closing selector tags. </span><span class="koboSpan" id="kobo.77.2">To test the content projection of your modal, import the modal component inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">expenses-overview</span></strong><span class="koboSpan" id="kobo.79.1"> component and add a Boolean property, </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">addExpenseShown</span></strong><span class="koboSpan" id="kobo.81.1">. </span><span class="koboSpan" id="kobo.81.2">Next, add the model component to the HTML template and project </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">addExpenseForm</span></strong><span class="koboSpan" id="kobo.83.1">, which we created in the previous chapter, inside the modal component, </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.85.1">
&lt;bt-libs-modal [(shown)]="addExpenseShown" [title]="'Add expense'"&gt;
  &lt;bt-libs-ui-add-expense-form (addExpense)="addExpense($event)" /&gt;
&lt;/bt-libs-modal&gt;</span></pre> <p><span class="koboSpan" id="kobo.86.1">Now, when the modal is shown, it displays the add expense form we projected into the component. </span><span class="koboSpan" id="kobo.86.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">ng-content</span></strong><span class="koboSpan" id="kobo.88.1"> element inside the HTML template of the modal will be replaced with the add expense form we projected into the </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">modal component.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">As you can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">ng-content</span></strong><span class="koboSpan" id="kobo.92.1"> slot provides the flexibility you need for your modal component and allows you to project any content easily into the modal. </span><span class="koboSpan" id="kobo.92.2">Any logic related </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.93.1">to the projected content is handled in the parent component and not inside the modal component itself, resulting in good separations </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">of concerns.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">In the case of our projected form, if you want to handle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">addExpense</span></strong><span class="koboSpan" id="kobo.97.1"> output event of the form component, you handle the event inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">expenses-overview</span></strong><span class="koboSpan" id="kobo.99.1"> component. </span><span class="koboSpan" id="kobo.99.2">The same goes for styling the projected content. </span><span class="koboSpan" id="kobo.99.3">If you want to style your projected content, you must do so inside the CSS file of the component where you project the content. </span><span class="koboSpan" id="kobo.99.4">In our example, this would be the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">add-expense.component.scss</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.101.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">You now know how to project content into a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">ng-content</span></strong><span class="koboSpan" id="kobo.104.1"> slot. </span><span class="koboSpan" id="kobo.104.2">Next, you’ll learn how to handle more complex projection scenarios by using multiple </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">ng-content</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.106.1"> slots.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.107.1">Exploring multi-slot content projection with ng-content select</span></h2>
<p><span class="koboSpan" id="kobo.108.1">Using </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.109.1">a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">ng-content</span></strong><span class="koboSpan" id="kobo.111.1"> slot provides a lot of flexibility, but sometimes, you need multiple places to </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">project content.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">Let’s say that in some of the modal designs you have, there is custom content between the title and closing buttons of the modal. </span><span class="koboSpan" id="kobo.113.2">To cover this use case, you need two places to project content: one in the content area and one in the header. </span><span class="koboSpan" id="kobo.113.3">When using multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">ng-content</span></strong><span class="koboSpan" id="kobo.115.1"> elements in a component, you need to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">ng-content</span></strong><span class="koboSpan" id="kobo.117.1"> with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">select</span></strong><span class="koboSpan" id="kobo.119.1"> attribute defined on </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">the element:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.121.1">
&lt;div class="modal-header"&gt;
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;ng-content </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">select=»[header-content]»</span></strong><span class="koboSpan" id="kobo.123.1">&gt;&lt;/ng-content&gt;
  &lt;span (click)=»shown = false; shownChange.emit()"&gt;X&lt;/span&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.124.1">Here, we added the additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">ng-content</span></strong><span class="koboSpan" id="kobo.126.1"> element inside the modal header and assigned the select attribute with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">header-content</span></strong><span class="koboSpan" id="kobo.128.1">. </span><span class="koboSpan" id="kobo.128.2">If we added the second </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">ng-content</span></strong><span class="koboSpan" id="kobo.130.1"> element without defining the select attribute, all projected content would end up inside the last </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">ng-content</span></strong><span class="koboSpan" id="kobo.132.1"> element in the HTML template of </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">the modal.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">For </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.135.1">projected content to end up in a specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">ng-content</span></strong><span class="koboSpan" id="kobo.137.1"> element, the projected content needs to match the select attribute value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">ng-content</span></strong><span class="koboSpan" id="kobo.139.1">. </span><span class="koboSpan" id="kobo.139.2">For the header’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">ng-content</span></strong><span class="koboSpan" id="kobo.141.1"> element, this means you need to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">header-content</span></strong><span class="koboSpan" id="kobo.143.1"> attribute to the HTML you want to project to the </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">header slot:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.145.1">
&lt;bt-libs-modal [shown]="addExpenseShown" [title]="'Add expenses'"&gt;
  &lt;bt-libs-ui-add-expense-form (addExpense)="addExpense($event)" /&gt;
  &lt;div </span><strong class="bold"><span class="koboSpan" id="kobo.146.1">header-content</span></strong><span class="koboSpan" id="kobo.147.1">&gt;special header content&lt;/div&gt;
&lt;/bt-libs-modal&gt;</span></pre> <p><span class="koboSpan" id="kobo.148.1">You can project as much HTML as you want to a specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">ng-content</span></strong><span class="koboSpan" id="kobo.150.1"> element. </span><span class="koboSpan" id="kobo.150.2">There are three scenarios when Angular determines where your content will be projected. </span><span class="koboSpan" id="kobo.150.3">Let’s explore these scenarios one </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">by one:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.152.1">If the projected content matches the select attribute value of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">ng-content</span></strong><span class="koboSpan" id="kobo.154.1"> element in your template, the content is projected to </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">ng-content</span></strong><span class="koboSpan" id="kobo.156.1"> with the matching </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">select value.</span></span></li>
<li><span class="koboSpan" id="kobo.158.1">If the content matches multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">ng-content</span></strong><span class="koboSpan" id="kobo.160.1"> selectors, the content is projected into the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">ng-content</span></strong><span class="koboSpan" id="kobo.162.1"> element with a matching </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">select value.</span></span></li>
<li><span class="koboSpan" id="kobo.164.1">If the projected HTML doesn’t match any of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">ng-content</span></strong><span class="koboSpan" id="kobo.166.1"> select values, the content is projected to the fallback </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">ng-content</span></strong><span class="koboSpan" id="kobo.168.1"> element – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">ng-content</span></strong><span class="koboSpan" id="kobo.170.1"> – without a </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">select</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.172.1">attribute assigned:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.173.1">
&lt;ng-content&gt;&lt;/ng-content&gt;</span></pre></li> </ul>
<p><span class="koboSpan" id="kobo.174.1">In our modal component, the fallback slot is defined inside the content area of the modal. </span><span class="koboSpan" id="kobo.174.2">If all content slots have a select attribute defined, there is no fallback slot. </span><span class="koboSpan" id="kobo.174.3">When there </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.175.1">is no fallback </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">ng-content</span></strong><span class="koboSpan" id="kobo.177.1"> element, any projected content that doesn’t match with at least one of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">select</span></strong><span class="koboSpan" id="kobo.179.1"> attribute values will not be projected </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">and rendered.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">select</span></strong><span class="koboSpan" id="kobo.183.1"> attribute of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">ng-content</span></strong><span class="koboSpan" id="kobo.185.1"> tag allows you to create powerful selectors that can match various things. </span><span class="koboSpan" id="kobo.185.2">You can match HTML attributes like we did in our modal component, but you can also match </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">HTML tags.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">For example, let’s say we want to project all </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">div</span></strong><span class="koboSpan" id="kobo.189.1"> HTML tags into the header slot. </span><span class="koboSpan" id="kobo.189.2">We can adjust the selector </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.191.1">
&lt;ng-content </span><strong class="bold"><span class="koboSpan" id="kobo.192.1">select="div"</span></strong><span class="koboSpan" id="kobo.193.1">&gt;&lt;/ng-content&gt;</span></pre> <p><span class="koboSpan" id="kobo.194.1">Now, you can remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">header-content</span></strong><span class="koboSpan" id="kobo.196.1"> attribute from the projected content, and it will still be projected to the header slot because it’s a </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">div</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.198.1">HTML tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.199.1">
&lt;div&gt;special header content&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.200.1">If you change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">select</span></strong><span class="koboSpan" id="kobo.202.1"> attribute value to match a span HTML element, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">div</span></strong><span class="koboSpan" id="kobo.204.1"> will end up in the fallback </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">ng-content</span></strong><span class="koboSpan" id="kobo.206.1"> slot inside our content area of the modal component. </span><span class="koboSpan" id="kobo.206.2">You can also match on multiple values; for example, if you want to match all </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">div</span></strong><span class="koboSpan" id="kobo.208.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">p</span></strong><span class="koboSpan" id="kobo.210.1"> tags, you can create a selector </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.212.1">
&lt;ng-content select="div, p"&gt;&lt;/ng-content&gt;</span></pre> <p><span class="koboSpan" id="kobo.213.1">You can also match HTML elements on CSS classes, IDs, or specific attribute values. </span><span class="koboSpan" id="kobo.213.2">Here is an example </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">of each:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.215.1">
&lt;ng-content select=".header"&gt;&lt;/ng-content&gt;
&lt;ng-content select="#header"&gt;&lt;/ng-content&gt;
&lt;ng-content select="[type='text']"&gt;&lt;/ng-content&gt;</span></pre> <p><span class="koboSpan" id="kobo.216.1">Using good </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">select</span></strong><span class="koboSpan" id="kobo.218.1"> values for your </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">ng-content</span></strong><span class="koboSpan" id="kobo.220.1"> tags can significantly improve the developer’s experience within your team by preventing you and your teammates from looking up the correct selector for the slots each time they have to project content into </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">the component.</span></span></p>
<p><span class="koboSpan" id="kobo.222.1">Having </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.223.1">multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">ng-content</span></strong><span class="koboSpan" id="kobo.225.1"> slots and making good use of the select attribute on </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">ng-content</span></strong><span class="koboSpan" id="kobo.227.1"> tags allows for even more flexible components with more control over the projected content. </span><span class="koboSpan" id="kobo.227.2">But even with multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">ng-content</span></strong><span class="koboSpan" id="kobo.229.1"> elements, you might need more flexibility to cover all your component design needs. </span><span class="koboSpan" id="kobo.229.2">Sometimes, you need to output your projected content numerous times inside your UI component or conditionally display the content in different places of the </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">HTML template.</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.231.1">Displaying projected content multiple times or conditionally</span></h2>
<p><span class="koboSpan" id="kobo.232.1">When you need to display the projected content multiple times or conditionally in the HTML </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.233.1">template, your first instinct might be to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">ng-content</span></strong><span class="koboSpan" id="kobo.235.1"> inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">div</span></strong><span class="koboSpan" id="kobo.237.1"> element and apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">*ngFor</span></strong><span class="koboSpan" id="kobo.239.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">*ngIf</span></strong><span class="koboSpan" id="kobo.241.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">*ngSwitch</span></strong><span class="koboSpan" id="kobo.243.1"> directive (or the control flow syntax versions – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">@for</span></strong><span class="koboSpan" id="kobo.245.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">@if</span></strong><span class="koboSpan" id="kobo.247.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">@switch</span></strong><span class="koboSpan" id="kobo.249.1">) to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">div</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.251.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.252.1">
&lt;div *ngFor="let item of [1,2,3]"&gt;
   &lt;ng-content&gt;&lt;/ng-content&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.253.1">If you try this, you will find that your content will be projected differently than expected. </span><span class="koboSpan" id="kobo.253.2">When using </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">*ngFor</span></strong><span class="koboSpan" id="kobo.255.1">, your content will only be projected once, and when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">*ngIf</span></strong><span class="koboSpan" id="kobo.257.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">*ngSwitch</span></strong><span class="koboSpan" id="kobo.259.1"> combined with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">ng-content</span></strong><span class="koboSpan" id="kobo.261.1"> element, only the first rendered </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">ng-content</span></strong><span class="koboSpan" id="kobo.263.1"> element is displayed. </span><span class="koboSpan" id="kobo.263.2">So, the three directives (or control flow syntax) will not work in combination with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">ng-content</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.265.1"> tag.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">You can use control flow or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">*ngFor</span></strong><span class="koboSpan" id="kobo.268.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">*ngIf</span></strong><span class="koboSpan" id="kobo.270.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">*ngSwitch</span></strong><span class="koboSpan" id="kobo.272.1"> directives inside the parent component where you project </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">the content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.274.1">
&lt;bt-libs-modal [shown]="addExpenseShown" [title]="'Add expenses'"&gt;
  &lt;div *ngFor="let header of headers" </span><strong class="bold"><span class="koboSpan" id="kobo.275.1">header-content</span></strong><span class="koboSpan" id="kobo.276.1">&gt;{{header}}&lt;/div&gt;
&lt;/bt-libs-modal&gt;</span></pre> <p><span class="koboSpan" id="kobo.277.1">Using these directives or control flow in the parent component is good enough for many scenarios, but sometimes, you must use the directives inside the component where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">ng-content</span></strong><span class="koboSpan" id="kobo.279.1"> elements reside. </span><span class="koboSpan" id="kobo.279.2">You might need to use the directives inside the component receiving the projected content because of the design needs of the component or to create a better architecture with a good separation </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">of concerns.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">For scenarios where you need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">*ngFor</span></strong><span class="koboSpan" id="kobo.283.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">*ngIf</span></strong><span class="koboSpan" id="kobo.285.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">*ngSwitch</span></strong><span class="koboSpan" id="kobo.287.1"> directives or control flow in the component that’s receiving the projected content, you don’t use </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">ng-content</span></strong><span class="koboSpan" id="kobo.289.1"> as the projection slot; instead, you need to use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">ng-template</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.291.1"> element.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">In this </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.293.1">section, you learned how to project content using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">ng-content</span></strong><span class="koboSpan" id="kobo.295.1"> element and where you can run into the limits of what you can do with the projected content when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">ng-content</span></strong><span class="koboSpan" id="kobo.297.1">. </span><span class="koboSpan" id="kobo.297.2">You also learned how to effectively use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">select</span></strong><span class="koboSpan" id="kobo.299.1"> attribute and project content into multiple slots </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">ng-content</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.303.1">In the next section, we will learn about </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">ng-template</span></strong><span class="koboSpan" id="kobo.305.1">, template variables, and </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">template references.</span></span></p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.307.1">Using template references and variables</span></h1>
<p><span class="koboSpan" id="kobo.308.1">In the previous section, we projected content using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">ng-content</span></strong><span class="koboSpan" id="kobo.310.1"> element. </span><span class="koboSpan" id="kobo.310.2">Yet, we ran into </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.311.1">a limitation that didn’t allow you to use control flow </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.312.1">or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">*ngFor</span></strong><span class="koboSpan" id="kobo.314.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">*ngIf</span></strong><span class="koboSpan" id="kobo.316.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">*ngSwitch</span></strong><span class="koboSpan" id="kobo.318.1"> directives in combination with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">ng-content</span></strong><span class="koboSpan" id="kobo.320.1"> element. </span><span class="koboSpan" id="kobo.320.2">We will start by demonstrating how to resolve this </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.321.1">using the </span><strong class="bold"><span class="koboSpan" id="kobo.322.1">ng-template</span></strong><span class="koboSpan" id="kobo.323.1"> element. </span><span class="koboSpan" id="kobo.323.2">After that, we will learn about other use cases and implementations of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">ng-template</span></strong><span class="koboSpan" id="kobo.325.1"> element and how you can create and use template variables within </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">HTML templates.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">We will </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.328.1">create a </span><strong class="bold"><span class="koboSpan" id="kobo.329.1">display-scales</span></strong><span class="koboSpan" id="kobo.330.1"> component to demonstrate content projection with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">ng-template</span></strong><span class="koboSpan" id="kobo.332.1"> element and use directives on the project content. </span><span class="koboSpan" id="kobo.332.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">display-scales</span></strong><span class="koboSpan" id="kobo.334.1"> component is just a simple example to demonstrate the concept of content projection combined with structural directives such </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">*ngFor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">Start using the </span><em class="italic"><span class="koboSpan" id="kobo.339.1">Nx generator</span></em><span class="koboSpan" id="kobo.340.1"> to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">display-scales</span></strong><span class="koboSpan" id="kobo.342.1"> component next to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">modal</span></strong><span class="koboSpan" id="kobo.344.1"> component. </span><span class="koboSpan" id="kobo.344.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">display-scales</span></strong><span class="koboSpan" id="kobo.346.1"> component will receive an array of scale sizes as input and display the projected content in these different scale sizes using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">*</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">ngFor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.349.1"> directive.</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">display-scales</span></strong><span class="koboSpan" id="kobo.352.1"> component is created, add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">scales-projection.directive.ts</span></strong><span class="koboSpan" id="kobo.354.1"> file to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">display-scales</span></strong><span class="koboSpan" id="kobo.356.1"> folder. </span><span class="koboSpan" id="kobo.356.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">scales-projection.directive.ts</span></strong><span class="koboSpan" id="kobo.358.1"> file, you can add the </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">following content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.360.1">
@Directive({
  selector: ‹[btLibsScalesProjection]',
  standalone: true,
})
export class ScalesProjectionDirective {
  constructor(public templateRef: TemplateRef&lt;unknown&gt;) { }
}</span></pre> <p><span class="koboSpan" id="kobo.361.1">The scales </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.362.1">projection directive only injects the </span><strong class="bold"><span class="koboSpan" id="kobo.363.1">templateRef</span></strong><span class="koboSpan" id="kobo.364.1"> – that’s it! </span><span class="koboSpan" id="kobo.364.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">display-scales</span></strong><span class="koboSpan" id="kobo.366.1"> component uses the directive to access the </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.367.1">projected content. </span><span class="koboSpan" id="kobo.367.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">display-scales</span></strong><span class="koboSpan" id="kobo.369.1"> component class, you need to add the input for receiving the s</span><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.370.1">cale sizes and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">@ContentChild()</span></strong><span class="koboSpan" id="kobo.372.1"> decorator to access the </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">projected content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
@Input({ required: true }) scaleSizes!: number[];
@ContentChild(ScalesProjectionDirective) content!: ScalesProjectionDirective;</span></pre> <p><span class="koboSpan" id="kobo.375.1">As you can see, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">ScalesProjectionDirective</span></strong><span class="koboSpan" id="kobo.377.1"> as a value for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">@ContentChild</span></strong><span class="koboSpan" id="kobo.379.1"> decorator. </span><span class="koboSpan" id="kobo.379.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">@ContentChild</span></strong><span class="koboSpan" id="kobo.381.1"> decorator will get the projected </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">ng-template</span></strong><span class="koboSpan" id="kobo.383.1"> element from the HTML template and hold a reference to the projected content so that we can use the content within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">display-scales</span></strong><span class="koboSpan" id="kobo.385.1"> component. </span><span class="koboSpan" id="kobo.385.2">Inside the HTML template of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">display-scales</span></strong><span class="koboSpan" id="kobo.387.1"> component, you can </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">add this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.389.1">
&lt;div *ngFor="let size of scaleSizes; let i = index" [style.transform]="'scale(' + size + ')'"&gt;
  &lt;ng-container </span><strong class="bold"><span class="koboSpan" id="kobo.390.1">[ngTemplateOutlet]=»content.templateRef»</span></strong><span class="koboSpan" id="kobo.391.1">&gt;&lt;/ng-container&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.392.1">Here, we created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">div</span></strong><span class="koboSpan" id="kobo.394.1"> element that will be rendered for each size inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">scaleSizes</span></strong><span class="koboSpan" id="kobo.396.1"> array the </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.397.1">component receives as input. </span><span class="koboSpan" id="kobo.397.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">div</span></strong><span class="koboSpan" id="kobo.399.1"> element, we declared a </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">ng-container</span></strong><span class="koboSpan" id="kobo.401.1"> element with the </span><strong class="bold"><span class="koboSpan" id="kobo.402.1">ngTemplateOutlet</span></strong><span class="koboSpan" id="kobo.403.1"> directive declared on </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">the element.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">ng-container</span></strong><span class="koboSpan" id="kobo.407.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">ngTemplateOutlet</span></strong><span class="koboSpan" id="kobo.409.1"> directive will display the projected content, similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">ng-content</span></strong><span class="koboSpan" id="kobo.411.1"> element we used in the previous section. </span><span class="koboSpan" id="kobo.411.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">ngTemplateOutlet</span></strong><span class="koboSpan" id="kobo.413.1"> directive needs to receive a </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.415.1"> property; this is why we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">ng-template</span></strong><span class="koboSpan" id="kobo.417.1"> element and the directive that </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">injected </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">TemplateRef</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">We bind the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.423.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">@ContentChild</span></strong><span class="koboSpan" id="kobo.425.1"> decorator value to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">ngTemplateOutlet</span></strong><span class="koboSpan" id="kobo.427.1"> directive using </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">content.templateRef</span></strong><span class="koboSpan" id="kobo.429.1">. </span><span class="koboSpan" id="kobo.429.2">When using </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">ng-template</span></strong><span class="koboSpan" id="kobo.431.1"> to project your content, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">*ngFor</span></strong><span class="koboSpan" id="kobo.433.1"> an</span><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.434.1">d other structural directives in </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.435.1">combination with the projected content. </span><span class="koboSpan" id="kobo.435.2">We couldn’t </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.436.1">do this when using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">ng-content</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.438.1"> element.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">Next, you need to project a </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.441.1"> property into the component using </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">ScalesProjectionDirective</span></strong><span class="koboSpan" id="kobo.443.1">. </span><span class="koboSpan" id="kobo.443.2">By doing so, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">@ContentChild</span></strong><span class="koboSpan" id="kobo.445.1"> decorator can access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.447.1"> property, and we can assign the projected template reference to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">ngTemplateOutlet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.449.1"> directive.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">You can project a </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.452.1"> property by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">ng-template</span></strong><span class="koboSpan" id="kobo.454.1"> element. </span><span class="koboSpan" id="kobo.454.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">ng-template</span></strong><span class="koboSpan" id="kobo.456.1"> element is the HTML representation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.458.1"> class. </span><span class="koboSpan" id="kobo.458.2">The projected content needs to match the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">@ContentChild</span></strong><span class="koboSpan" id="kobo.460.1"> decorator, so we need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">ScalesProjectionDirective</span></strong><span class="koboSpan" id="kobo.462.1"> decorator to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">ng-template</span></strong><span class="koboSpan" id="kobo.464.1"> element we are about to project. </span><span class="koboSpan" id="kobo.464.2">Don’t forget to import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">display-scales</span></strong><span class="koboSpan" id="kobo.466.1"> component and </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">ScalesProjectionDirective</span></strong><span class="koboSpan" id="kobo.468.1"> into the standalone component where you are using the scales component </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">and directive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.470.1">
&lt;bt-libs-display-scales [scaleSizes]="[0.8, 1, 1.2, 1.4]"&gt;
  &lt;ng-template </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">btLibsScalesProjection</span></strong><span class="koboSpan" id="kobo.472.1">&gt;I scale!&lt;/ng-template&gt;
&lt;/bt-libs-display-scales&gt;</span></pre> <p><span class="koboSpan" id="kobo.473.1">After adding the preceding HTML into an HTML template (for example, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">expenses-overview.component.html</span></strong><span class="koboSpan" id="kobo.475.1"> file), you will display the scales component with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">I scale!</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.477.1">content projected.</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">When you try to project an additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">ng-template</span></strong><span class="koboSpan" id="kobo.480.1"> element, you will notice that only one </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">ng-template</span></strong><span class="koboSpan" id="kobo.482.1"> element is projected and used inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">display-scales</span></strong><span class="koboSpan" id="kobo.484.1"> component. </span><span class="koboSpan" id="kobo.484.2">Only the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">ng-template</span></strong><span class="koboSpan" id="kobo.486.1"> element is used because we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">@ContentChild</span></strong><span class="koboSpan" id="kobo.488.1"> decorator inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">display-scales</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.490.1"> component.</span></span></p>
<p><span class="koboSpan" id="kobo.491.1">If you want </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.492.1">to project multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">ng-template</span></strong><span class="koboSpan" id="kobo.494.1"> elements </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.495.1">with the same projection directive (in our case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">ScalesProjectionDirective</span></strong><span class="koboSpan" id="kobo.497.1">), you need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">@ContentChildren</span></strong><span class="koboSpan" id="kobo.499.1"> decorator instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">@ContentChild</span></strong><span class="koboSpan" id="kobo.501.1"> decorator. </span><span class="koboSpan" id="kobo.501.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">@ContentChildren</span></strong><span class="koboSpan" id="kobo.503.1"> decorator creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">QueryList</span></strong><span class="koboSpan" id="kobo.505.1"> property of template references instead of a single </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">template reference:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.507.1">
@</span><strong class="bold"><span class="koboSpan" id="kobo.508.1">ContentChildren</span></strong><span class="koboSpan" id="kobo.509.1">(ScalesProjectionDirective) content!: </span><strong class="bold"><span class="koboSpan" id="kobo.510.1">QueryList</span></strong><span class="koboSpan" id="kobo.511.1">&lt;ScalesProjectionDirective&gt;;</span></pre> <p><span class="koboSpan" id="kobo.512.1">To output all elements inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">QueryList</span></strong><span class="koboSpan" id="kobo.514.1">, you need to loop over </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">QueryList</span></strong><span class="koboSpan" id="kobo.516.1"> and create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">ng-container</span></strong><span class="koboSpan" id="kobo.518.1"> element for each node in the list. </span><span class="koboSpan" id="kobo.518.2">You can achieve this by turning </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">QueryList</span></strong><span class="koboSpan" id="kobo.520.1"> into an array and using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">*ngFor</span></strong><span class="koboSpan" id="kobo.522.1"> directive to output each item in </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">the list:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.524.1">
&lt;div *ngFor="let item of </span><strong class="bold"><span class="koboSpan" id="kobo.525.1">content.toArray()</span></strong><span class="koboSpan" id="kobo.526.1">"&gt;
  &lt;ng-container </span><strong class="bold"><span class="koboSpan" id="kobo.527.1">[ngTemplateOutlet]="item.templateRef"</span></strong><span class="koboSpan" id="kobo.528.1">&gt;&lt;/ng-container&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.529.1">If you want to project content into different slots, as we did with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">ng-content</span></strong><span class="koboSpan" id="kobo.531.1"> tags and </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">select</span></strong><span class="koboSpan" id="kobo.533.1"> attribute, you need to create multiple projection directives like </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">ScalesProjectionDirective</span></strong><span class="koboSpan" id="kobo.535.1"> and use multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">@ContentChild</span></strong><span class="koboSpan" id="kobo.537.1"> decorators to separate the project’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">ng-template</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.539.1"> elements:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.540.1">
@ContentChild(</span><strong class="bold"><span class="koboSpan" id="kobo.541.1">ScalesProjectionDirective</span></strong><span class="koboSpan" id="kobo.542.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.543.1">content</span></strong><span class="koboSpan" id="kobo.544.1">!: ScalesProjectionDirective;
@ContentChild(</span><strong class="bold"><span class="koboSpan" id="kobo.545.1">ScalesHeaderProjectionDirective</span></strong><span class="koboSpan" id="kobo.546.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.547.1">headerContent</span></strong><span class="koboSpan" id="kobo.548.1">!: ScalesHeaderProjectionDirective;</span></pre> <p><span class="koboSpan" id="kobo.549.1">In the HTML template, you can then use the different </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">@ContentChild</span></strong><span class="koboSpan" id="kobo.551.1"> elements with different </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">ng-container</span></strong><span class="koboSpan" id="kobo.553.1"> elements, </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.555.1">
&lt;ng-container [ngTemplateOutlet]="</span><strong class="bold"><span class="koboSpan" id="kobo.556.1">content</span></strong><span class="koboSpan" id="kobo.557.1">.templateRef"&gt;&lt;/ng-container&gt;
&lt;ng-container [ngTemplateOutlet]="</span><strong class="bold"><span class="koboSpan" id="kobo.558.1">headerContent</span></strong><span class="koboSpan" id="kobo.559.1">.templateRef"&gt;&lt;/ng-container&gt;</span></pre> <p><span class="koboSpan" id="kobo.560.1">With that, you know </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.561.1">how you can project </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">ng-template</span></strong><span class="koboSpan" id="kobo.563.1"> elements and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">*ngFor</span></strong><span class="koboSpan" id="kobo.565.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">*ngIf</span></strong><span class="koboSpan" id="kobo.567.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">*ngSwitch</span></strong><span class="koboSpan" id="kobo.569.1"> directives or control flow syntax in combination with </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">projected content.</span></span></p>
<p><span class="koboSpan" id="kobo.571.1">Now, let’s explore what else we can do with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">ng-template</span></strong><span class="koboSpan" id="kobo.573.1"> element, what template variables are, and how we can use them effectively in our components. </span><span class="koboSpan" id="kobo.573.2">We will start by learning about </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">template variables.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.575.1">Using template variables effectively</span></h2>
<p><span class="koboSpan" id="kobo.576.1">When building components, we often need to use one part of the HTML template in another part </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.577.1">of the HTML template. </span><span class="koboSpan" id="kobo.577.2">You can access elements from your HTML template using decorators such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">@ViewChild</span></strong><span class="koboSpan" id="kobo.579.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">@ContentChild</span></strong><span class="koboSpan" id="kobo.581.1">, but you can also use </span><strong class="bold"><span class="koboSpan" id="kobo.582.1">template variables</span></strong><span class="koboSpan" id="kobo.583.1">. </span><span class="koboSpan" id="kobo.583.2">Using template variables helps simplify your code because you can handle situations where you need one part of the template in another place, all in your HTML; there’s no need to create a property in your component class and use this variable inside your </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">HTML template.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">A template variable can refer to five </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">different elements:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.587.1">DOM elements within the </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">HTML template</span></span></li>
<li><span class="koboSpan" id="kobo.589.1">Directives used within the </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">HTML template</span></span></li>
<li><span class="koboSpan" id="kobo.591.1">Components used within the </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">HTML template</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.594.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">ng-template</span></strong><span class="koboSpan" id="kobo.596.1"> elements used within the </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">HTML template</span></span></li>
<li><span class="koboSpan" id="kobo.598.1">A </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">web component</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.600.1">Template variables are created using the hashtag (</span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">#</span></strong><span class="koboSpan" id="kobo.602.1">) sign combined with a variable name. </span><span class="koboSpan" id="kobo.602.2">For example, if you want to create a template variable from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">div</span></strong><span class="koboSpan" id="kobo.604.1"> element in your template, you can use </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">this syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.606.1">
&lt;div </span><strong class="bold"><span class="koboSpan" id="kobo.607.1">#exampleVar</span></strong><span class="koboSpan" id="kobo.608.1">&gt; ……… &lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.609.1">In the preceding example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">#exampleVar</span></strong><span class="koboSpan" id="kobo.611.1"> is the template variable, and the variable holds a reference to the DOM element it’s placed on; in this example, the DOM element is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">div</span></strong><span class="koboSpan" id="kobo.613.1"> element. </span><span class="koboSpan" id="kobo.613.2">You can now use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">exampleVar</span></strong><span class="koboSpan" id="kobo.615.1"> template variable within your HTML template. </span><span class="koboSpan" id="kobo.615.2">When you assign the template variable with a DOM element, you can access all properties of the DOM element, similar to when you access it from within your </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">component class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.617.1">
&lt;div&gt;Template var says: {{</span><strong class="bold"><span class="koboSpan" id="kobo.618.1">exampleVar.innerText</span></strong><span class="koboSpan" id="kobo.619.1">}} &lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.620.1">You can use the </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.621.1">template variable with interpolation or anywhere else that you can use component properties inside </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">your template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.623.1">
&lt;input </span><strong class="bold"><span class="koboSpan" id="kobo.624.1">#name</span></strong><span class="koboSpan" id="kobo.625.1"> placeholder="Enter your name" /&gt;
&lt;button (click)="submitName(</span><strong class="bold"><span class="koboSpan" id="kobo.626.1">name</span></strong><span class="koboSpan" id="kobo.627.1">.value)"&gt;Submit&lt;/button&gt;</span></pre> <p><span class="koboSpan" id="kobo.628.1">If you want to assign a template variable to a component, you can use the same syntax but only on the selector of a </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">custom component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.630.1">
&lt;bt-libs-modal </span><strong class="bold"><span class="koboSpan" id="kobo.631.1">#modal</span></strong><span class="koboSpan" id="kobo.632.1"> [(shown)]="addExpenseShown"&gt; ………
&lt;/bt-libs-modal&gt;</span></pre> <p><span class="koboSpan" id="kobo.633.1">When you use a template variable on a component, you can access all the public properties and methods of the component. </span><span class="koboSpan" id="kobo.633.2">Sometimes, it can be useful to access the properties of the child component in this manner, but you should avoid calling public methods </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">like so.</span></span></p>
<p><span class="koboSpan" id="kobo.635.1">It’s not advised to call methods and potentially mutate the data of child components using template variables as it’s a bit of an anti-pattern. </span><span class="koboSpan" id="kobo.635.2">It would be best if you tried to do all parent-child component communication through inputs and outputs unless there is no other way. </span><span class="koboSpan" id="kobo.635.3">Yet it’s good to know you can access the properties through template variables so that you can recognize when someone else uses it or when you have a situation where you want or need to </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">use it.</span></span></p>
<p><span class="koboSpan" id="kobo.637.1">Another common and more accepted use case of template variables is assigning a directive to a template variable. </span><span class="koboSpan" id="kobo.637.2">We did this in </span><a href="B21625_04.xhtml#_idTextAnchor072"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.638.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.639.1"> when we created template-driven forms. </span><span class="koboSpan" id="kobo.639.2">The syntax for assigning a directive to a template variable differs slightly from assigning a DOM element or component to a template variable. </span><span class="koboSpan" id="kobo.639.3">When assigning a directive to a template variable, we must create the variable as normal and assign the directive using the is </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">sign (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">=</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.643.1">
&lt;form </span><strong class="bold"><span class="koboSpan" id="kobo.644.1">#expenseForm="ngForm"</span></strong><span class="koboSpan" id="kobo.645.1">&gt; ……… &lt;/form&gt;
&lt;div *ngIf="!</span><strong class="bold"><span class="koboSpan" id="kobo.646.1">expenseForm</span></strong><span class="koboSpan" id="kobo.647.1">.form.valid"&gt;
  &lt;p&gt;Invalid form&lt;/p&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.648.1">In the preceding example, we assigned the </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">ngForm</span></strong><span class="koboSpan" id="kobo.650.1"> directive to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">expenseForm</span></strong><span class="koboSpan" id="kobo.652.1"> template variable. </span><span class="koboSpan" id="kobo.652.2">We can now access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">ngForm</span></strong><span class="koboSpan" id="kobo.654.1"> directive and all its properties through the template variable. </span><span class="koboSpan" id="kobo.654.2">Using the template variable makes it easy to use all kinds of form values </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.655.1">and statuses such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">pristine</span></strong><span class="koboSpan" id="kobo.657.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">dirty</span></strong><span class="koboSpan" id="kobo.659.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">valid</span></strong><span class="koboSpan" id="kobo.661.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">invalid</span></strong><span class="koboSpan" id="kobo.663.1">. </span><span class="koboSpan" id="kobo.663.2">There’s no need to create a variable within your component class; you can handle everything from within your </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">HTML template.</span></span></p>
<p><span class="koboSpan" id="kobo.665.1">You can also use template variables to access </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.667.1"> instances created with </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">ng-template</span></strong><span class="koboSpan" id="kobo.669.1"> elements. </span><span class="koboSpan" id="kobo.669.2">Accessing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.671.1"> instance through a template variable works similarly to assigning a template variable to a component or DOM element; you just add the template variable to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">ng-template</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.673.1"> element:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.674.1">
&lt;ng-template </span><strong class="bold"><span class="koboSpan" id="kobo.675.1">#templateOne</span></strong><span class="koboSpan" id="kobo.676.1">&gt;I am a template&lt;/ng-template&gt;</span></pre> <p><span class="koboSpan" id="kobo.677.1">What you can do with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.679.1"> element, either by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">ng-template</span></strong><span class="koboSpan" id="kobo.681.1"> element (with or without a template variable) or by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.683.1"> in your component class, is the topic of the </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">next section.</span></span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.685.1">Using TemplateRef elements effectively</span></h2>
<p><span class="koboSpan" id="kobo.686.1">Template </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.687.1">references can be defined inside your HTML templates using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">ng-template</span></strong><span class="koboSpan" id="kobo.689.1"> element. </span><span class="koboSpan" id="kobo.689.2">You can access a </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.691.1"> element in your component and directive classes using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.693.1"> class. </span><span class="koboSpan" id="kobo.693.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.695.1"> class and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">ng-template</span></strong><span class="koboSpan" id="kobo.697.1"> element are the same thing in </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">different forms.</span></span></p>
<p><span class="koboSpan" id="kobo.699.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.701.1"> element can be used for many use cases. </span><span class="koboSpan" id="kobo.701.2">As shown at the start of the </span><em class="italic"><span class="koboSpan" id="kobo.702.1">Using template references and variables</span></em><span class="koboSpan" id="kobo.703.1"> section of this chapter, </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.705.1"> can be used for content projection when you need to combine the projected content with a structural directive such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">*ngFor</span></strong><span class="koboSpan" id="kobo.707.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">*ngIf</span></strong><span class="koboSpan" id="kobo.709.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">*ngSwitch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.713.1">Another place where </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.715.1"> is used is within custom structural directives. </span><span class="koboSpan" id="kobo.715.2">Structural directives add or remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.717.1"> elements to/from the view container based on some logic. </span><span class="koboSpan" id="kobo.717.2">We added and removed template references to the view container in </span><a href="B21625_03.xhtml#_idTextAnchor058"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.718.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.719.1"> when we created our custom </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">structural directive.</span></span></p>
<p><span class="koboSpan" id="kobo.721.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.723.1"> element can also be combined with template context to build truly dynamic </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.724.1">components that can display different templates using different data sources. </span><span class="koboSpan" id="kobo.724.2">You can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.726.1"> to display content in different places on your page – for example, when you have the same piece of content located on different locations of the page for your mobile and </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">desktop designs.</span></span></p>
<p><span class="koboSpan" id="kobo.728.1">Another place where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">ng-template</span></strong><span class="koboSpan" id="kobo.730.1"> element shines is when you need to render content conditionally based on the outcome of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">*ngIf</span></strong><span class="koboSpan" id="kobo.732.1"> directive. </span><span class="koboSpan" id="kobo.732.2">Let’s continue by exploring the use cases for </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.734.1"> and create </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">some examples.</span></span></p>
<h3><span class="koboSpan" id="kobo.736.1">Combining ng-template with *ngIf</span></h3>
<p><span class="koboSpan" id="kobo.737.1">You </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.738.1">can display an </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">ng-template</span></strong><span class="koboSpan" id="kobo.740.1"> element based on the outcome of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">*ngIf</span></strong><span class="koboSpan" id="kobo.742.1"> statement. </span><span class="koboSpan" id="kobo.742.2">Often, you’ll </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.743.1">see something like this in </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.744.1">the HTML templates of </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">Angular applications:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.746.1">
&lt;div *ngIf="expenses"&gt; ……… &lt;/div&gt;
&lt;div *ngIf="!expenses"&gt;Loading...&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.747.1">You can do the same thing with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">ng-template</span></strong><span class="koboSpan" id="kobo.749.1"> element and define a template that is shown when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">*ngIf</span></strong><span class="koboSpan" id="kobo.751.1"> statement </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">isn’t met:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.753.1">
&lt;div *ngIf="expenses else loading"&gt; ……… &lt;/div&gt;
&lt;ng-template #loading&gt;
  &lt;div&gt;Loading...&lt;/div&gt;
&lt;/ng-template&gt;</span></pre> <p><span class="koboSpan" id="kobo.754.1">Instead of declaring the </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">*ngIf</span></strong><span class="koboSpan" id="kobo.756.1"> directive on both </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">div</span></strong><span class="koboSpan" id="kobo.758.1"> elements, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">*ngIf</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.760.1">else</span></strong><span class="koboSpan" id="kobo.761.1"> syntax. </span><span class="koboSpan" id="kobo.761.2">We referenced the template variable that was placed on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">ng-template</span></strong><span class="koboSpan" id="kobo.763.1"> element for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">else</span></strong><span class="koboSpan" id="kobo.765.1"> statement. </span><span class="koboSpan" id="kobo.765.2">Now, when there are no expenses, the loading template is shown. </span><span class="koboSpan" id="kobo.765.3">This is just a simple example, but if you have large templates to display conditionally, using templates helps separate the HTML. </span><span class="koboSpan" id="kobo.765.4">Also, when your </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">*ngIf</span></strong><span class="koboSpan" id="kobo.767.1"> statement uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">async</span></strong><span class="koboSpan" id="kobo.769.1"> pipe, which is often the case, you cannot use the </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">first approach:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.771.1">
&lt;div *ngIf="!expensesVm$ | async"&gt;Loading...&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.772.1">When </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.773.1">you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">async</span></strong><span class="koboSpan" id="kobo.775.1"> pipe inside your </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">*ngIf</span></strong><span class="koboSpan" id="kobo.777.1"> directive, you cannot use the logical not operator (</span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">!</span></strong><span class="koboSpan" id="kobo.779.1">) in your template. </span><span class="koboSpan" id="kobo.779.2">You could set a value inside your component class using an RxJS pipe </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.780.1">operator on your observable </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.781.1">value. </span><span class="koboSpan" id="kobo.781.2">Still, it would be a lot simpler and cleaner to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">*ngIf</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.783.1">else</span></strong><span class="koboSpan" id="kobo.784.1"> statement and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">ng-template</span></strong><span class="koboSpan" id="kobo.786.1"> element, </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.788.1">
&lt;div *ngIf="expensesVm$ | async as expense; else loading"&gt;……&lt;/div&gt;
&lt;ng-template #loading&gt;
  &lt;div&gt;Loading...&lt;/div&gt;
&lt;/ng-template&gt;</span></pre> <p><span class="koboSpan" id="kobo.789.1">Using the syntax mentioned previously lets you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">async</span></strong><span class="koboSpan" id="kobo.791.1"> pipe to handle your observable and display an alternative template, so long as no value has been resolved by the observable or the result of the observable has been mapped to a false, null, or </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">undefined value.</span></span></p>
<p><span class="koboSpan" id="kobo.793.1">You can even take it a step further and split up all your HTML into separate templates using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">*ngIf</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.795.1">then-else</span></strong><span class="koboSpan" id="kobo.796.1"> syntax combined with </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">ng-template</span></strong><span class="koboSpan" id="kobo.798.1"> elements. </span><span class="koboSpan" id="kobo.798.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">if-then-else</span></strong><span class="koboSpan" id="kobo.800.1"> syntax gives you a clear separation in your HTML and helps improve maintainability when you have large templates where you have to display multiple blocks of </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">content conditionally:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.802.1">
&lt;ng-container *ngIf="expensesVm$ | async; then expenses; else loading"&gt;&lt;/ng-container&gt;
&lt;ng-template #expenses&gt; &lt;div&gt;……&lt;/div&gt; &lt;/ng-template&gt;
&lt;ng-template #loading&gt; &lt;div&gt;Loading...&lt;/div&gt; &lt;/ng-template&gt;</span></pre> <p><span class="koboSpan" id="kobo.803.1">What solution you use is primarily up to your preference and your team’s preference. </span><span class="koboSpan" id="kobo.803.2">There is no real convention or best practice. </span><span class="koboSpan" id="kobo.803.3">When working with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">async</span></strong><span class="koboSpan" id="kobo.805.1"> pipe, I like to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">ng-template</span></strong><span class="koboSpan" id="kobo.807.1"> syntax instead of using a pipe operator on my observable to assign a component property, which can be used for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">*ngIf</span></strong><span class="koboSpan" id="kobo.809.1"> statement with the logical </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">not operator.</span></span></p>
<p><span class="koboSpan" id="kobo.811.1">For </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.812.1">simple scenarios </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.813.1">with synchronous values, I mostly </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.814.1">use </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">*ngIf</span></strong><span class="koboSpan" id="kobo.816.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">*ngIf</span></strong><span class="koboSpan" id="kobo.818.1"> with the logical not operator to display the correct HTML content – unless there are two large blocks of HTML content, in which case I prefer </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">using templates.</span></span></p>
<p><span class="koboSpan" id="kobo.820.1">Now that you know how you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">ng-template</span></strong><span class="koboSpan" id="kobo.822.1"> element combined with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">*ngIf</span></strong><span class="koboSpan" id="kobo.824.1"> directive to display templates conditionally, let’s explore how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">ng-template</span></strong><span class="koboSpan" id="kobo.826.1"> to display templates in different locations on the </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">same page.</span></span></p>
<h3><span class="koboSpan" id="kobo.828.1">Displaying content in the correct spot using ng-template</span></h3>
<p><span class="koboSpan" id="kobo.829.1">Often, you </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.830.1">have a design where the same block of content is placed on a different location of the page for your mobile and </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">desktop view:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.832.1"><img alt="Figure 5.1: Content placement for the mobile and desktop views" src="image/B21625_05_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.833.1">Figure 5.1: Content placement for the mobile and desktop views</span></p>
<p><span class="koboSpan" id="kobo.834.1">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.835.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.836.1">.1</span></em><span class="koboSpan" id="kobo.837.1">, on mobile, the content blocks, </span><em class="italic"><span class="koboSpan" id="kobo.838.1">C</span></em><span class="koboSpan" id="kobo.839.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.840.1">D</span></em><span class="koboSpan" id="kobo.841.1">, are shown below element </span><em class="italic"><span class="koboSpan" id="kobo.842.1">B</span></em><span class="koboSpan" id="kobo.843.1">; on the desktop view, the same content is shown above element </span><em class="italic"><span class="koboSpan" id="kobo.844.1">B</span></em><span class="koboSpan" id="kobo.845.1">. </span><span class="koboSpan" id="kobo.845.2">The same goes for </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.846.1">block </span><em class="italic"><span class="koboSpan" id="kobo.847.1">A</span></em><span class="koboSpan" id="kobo.848.1">, only in reverse. </span><span class="koboSpan" id="kobo.848.2">You don’t want to duplicate the HTML for blocks </span><em class="italic"><span class="koboSpan" id="kobo.849.1">A</span></em><span class="koboSpan" id="kobo.850.1">, </span><em class="italic"><span class="koboSpan" id="kobo.851.1">C</span></em><span class="koboSpan" id="kobo.852.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.853.1">D</span></em><span class="koboSpan" id="kobo.854.1"> and place it once above and once below block </span><em class="italic"><span class="koboSpan" id="kobo.855.1">B</span></em><span class="koboSpan" id="kobo.856.1">. </span><span class="koboSpan" id="kobo.856.2">Duplicating the HTML would break the </span><strong class="bold"><span class="koboSpan" id="kobo.857.1">Don’t Repeat Yourself</span></strong><span class="koboSpan" id="kobo.858.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.859.1">DRY</span></strong><span class="koboSpan" id="kobo.860.1">) principle and result in a harder-to-maintain and read </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">HTML template.</span></span></p>
<p><span class="koboSpan" id="kobo.862.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">ng-template</span></strong><span class="koboSpan" id="kobo.864.1"> element comes to the rescue in this scenario and lets you display the same template in different places on the page without duplicating </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">the HTML:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.866.1">
&lt;ng-container *ngIf="isMobile" [ngTemplateOutlet]="A"&gt;&lt;/ng-container&gt;
&lt;ng-container *ngIf="!isMobile" [ngTemplateOutlet]="CD"&gt;&lt;/ng-container&gt;
&lt;div&gt;Block B&lt;/div&gt;
&lt;ng-container *ngIf="!isMobile" [ngTemplateOutlet]="A"&gt;&lt;/ng-container&gt;
&lt;ng-container *ngIf="isMobile" [ngTemplateOutlet]="CD"&gt;&lt;/ng-container&gt;
&lt;ng-template #A&gt;
  &lt;div&gt; …… &lt;/div&gt;
&lt;/ng-template&gt;
&lt;ng-template #CD&gt;
  &lt;div&gt; …… &lt;/div&gt;
&lt;/ng-template&gt;</span></pre> <p><span class="koboSpan" id="kobo.867.1">As you </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.868.1">can see in the preceding HTML snippet, we used one </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">ng-template</span></strong><span class="koboSpan" id="kobo.870.1"> element to define the HTML for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">A</span></strong><span class="koboSpan" id="kobo.872.1"> block and one </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">ng-template</span></strong><span class="koboSpan" id="kobo.874.1"> element to define the HTML for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">C</span></strong><span class="koboSpan" id="kobo.876.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">D</span></strong><span class="koboSpan" id="kobo.878.1"> blocks combined. </span><span class="koboSpan" id="kobo.878.2">We display the templates using </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">ng-container</span></strong><span class="koboSpan" id="kobo.880.1"> elements with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">ngTemplateOutlet</span></strong><span class="koboSpan" id="kobo.882.1"> directive referencing the template variables declared on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">ng-template</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.884.1"> elements.</span></span></p>
<p><span class="koboSpan" id="kobo.885.1">In this example, we used an </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">isMobile</span></strong><span class="koboSpan" id="kobo.887.1"> Boolean to hide or show the correct </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">ng-container</span></strong><span class="koboSpan" id="kobo.889.1"> elements, but you can also wrap them inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">div</span></strong><span class="koboSpan" id="kobo.891.1"> element and hide them with CSS. </span><span class="koboSpan" id="kobo.891.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">ng-template</span></strong><span class="koboSpan" id="kobo.893.1"> element combined with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">ng-container</span></strong><span class="koboSpan" id="kobo.895.1"> element, we only have to create the HTML for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">A</span></strong><span class="koboSpan" id="kobo.897.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">C</span></strong><span class="koboSpan" id="kobo.899.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">D</span></strong><span class="koboSpan" id="kobo.901.1"> blocks once, resulting in a cleaner and more maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">HTML template.</span></span></p>
<p><span class="koboSpan" id="kobo.903.1">You can clean up the HTML even more and assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">aboveB</span></strong><span class="koboSpan" id="kobo.905.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">belowB</span></strong><span class="koboSpan" id="kobo.907.1"> templates inside your component class. </span><span class="koboSpan" id="kobo.907.2">I don’t like to add the additional logic for this inside my component class, but it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">a preference.</span></span></p>
<p><span class="koboSpan" id="kobo.909.1">Here’s an example of how you can handle this in your component class. </span><span class="koboSpan" id="kobo.909.2">First, adjust your HTML </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">to this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.911.1">
&lt;ng-container [ngTemplateOutlet]="aboveB"&gt;&lt;/ng-container&gt;
&lt;div&gt;Block B&lt;/div&gt;
&lt;ng-container [ngTemplateOutlet]="belowB"&gt;&lt;/ng-container&gt;</span></pre> <p><span class="koboSpan" id="kobo.912.1">Now, inside your component class, get a reference to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">A</span></strong><span class="koboSpan" id="kobo.914.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">CD</span></strong><span class="koboSpan" id="kobo.916.1"> templates by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">@ViewChild()</span></strong><span class="koboSpan" id="kobo.918.1"> decorator and create a variable for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">aboveB</span></strong><span class="koboSpan" id="kobo.920.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">belowB</span></strong> <span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">TemplateRef</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.923.1"> elements:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.924.1">
@ViewChild('A') templateA!: TemplateRef&lt;unknown&gt;;
@ViewChild('CD') templateCD!: TemplateRef&lt;unknown&gt;;
aboveB!: TemplateRef&lt;unknown&gt;;
belowB!: TemplateRef&lt;unknown&gt;;</span></pre> <p><span class="koboSpan" id="kobo.925.1">Inside </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.926.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">ngAfterViewInit</span></strong><span class="koboSpan" id="kobo.928.1"> life cycle hook, you can assign the variables with the </span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">correct template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.930.1">
this.aboveB = this.isMobile ? </span><span class="koboSpan" id="kobo.930.2">this.templateA : this.templateCD;
this.belowB = this.isMobile ? </span><span class="koboSpan" id="kobo.930.3">this.templateCD : this.templateA;</span></pre> <p><span class="koboSpan" id="kobo.931.1">If your component is set to the </span><em class="italic"><span class="koboSpan" id="kobo.932.1">OnPush</span></em><span class="koboSpan" id="kobo.933.1"> change detection strategy, you need to manually trigger change detection for the view to update and display the templates. </span><span class="koboSpan" id="kobo.933.2">If you don’t use the </span><em class="italic"><span class="koboSpan" id="kobo.934.1">OnPush</span></em><span class="koboSpan" id="kobo.935.1"> change detection strategy, your view will be </span><span class="No-Break"><span class="koboSpan" id="kobo.936.1">updated automatically.</span></span></p>
<p><span class="koboSpan" id="kobo.937.1">Something similar can be done when you have a page with multiple modals. </span><span class="koboSpan" id="kobo.937.2">Instead of defining multiple modal components and projecting the correct content into each modal, you can create one modal that contains an </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">ng-container</span></strong><span class="koboSpan" id="kobo.939.1"> element with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">ngTemplateOutlet</span></strong><span class="koboSpan" id="kobo.941.1"> directive and set the correct template when the modal </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">is opened:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.943.1">
showModal = false;
modalTitle = '';
modalContent!: TemplateRef&lt;unknown&gt;;
openModal(title: string, content: TemplateRef&lt;unknown&gt;) {
  this.modalTitle = title;
  this.modalContent = content;
  this.showModal = true;
}</span></pre> <p><span class="koboSpan" id="kobo.944.1">In the </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.945.1">preceding code snippet, we created an </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">openModel</span></strong><span class="koboSpan" id="kobo.947.1"> function, which will be called from the HTML template when one of the modal components needs to be opened. </span><span class="koboSpan" id="kobo.947.2">We will pass along a title for the modal and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.949.1"> element for </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">the content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.951.1">
&lt;button (click)="openModal('Title A', modalA)"&gt;Open modal A&lt;/button&gt;
&lt;button (click)="openModal('Title B', modalB)"&gt;Open modal B&lt;/button&gt;
&lt;bt-libs-modal [(shown)]="showModal" [title]="modalTitle"&gt;
  &lt;ng-container [ngTemplateOutlet]="modalContent"&gt;&lt;/ng-container&gt;
&lt;/bt-libs-modal&gt;
&lt;ng-template #modalA&gt;
  &lt;div&gt;A...&lt;/div&gt;
&lt;/ng-template&gt;
&lt;ng-template #modalB&gt;
  &lt;div&gt;B...&lt;/div&gt;
&lt;/ng-template&gt;</span></pre> <p><span class="koboSpan" id="kobo.952.1">In the HTML, we now only display one modal and display the </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.954.1"> element inside, which is set in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">openModal</span></strong><span class="koboSpan" id="kobo.956.1"> method in our component class. </span><span class="koboSpan" id="kobo.956.2">When the corresponding button is clicked, we send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.958.1"> element from the HTML template to our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">openModal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.960.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.961.1">As you </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.962.1">may have noticed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">ng-template</span></strong><span class="koboSpan" id="kobo.964.1"> element and </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">ngTemplateOutlet</span></strong><span class="koboSpan" id="kobo.966.1"> can bring a lot of flexibility to your components and let you easily display different templates in different locations. </span><span class="koboSpan" id="kobo.966.2">But </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">ng-template</span></strong><span class="koboSpan" id="kobo.968.1"> can offer us even more flexibility by adding context and using </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.970.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">an input.</span></span></p>
<h3><span class="koboSpan" id="kobo.972.1">Creating dynamic components using templates and context</span></h3>
<p><span class="koboSpan" id="kobo.973.1">We </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.974.1">have already </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.975.1">seen how we can combine content projection and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">ng-template</span></strong><span class="koboSpan" id="kobo.977.1"> element. </span><span class="koboSpan" id="kobo.977.2">In this section, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.979.1"> as a component input and provide additional context to </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.981.1"> to make it even more dynamic. </span><span class="koboSpan" id="kobo.981.2">A good example to showcase </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">ng-template</span></strong><span class="koboSpan" id="kobo.983.1"> with context is by creating a dynamic select component, so go ahead and create a select component inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">common-components</span></strong><span class="koboSpan" id="kobo.985.1"> library, next to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">modal</span></strong><span class="koboSpan" id="kobo.987.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">display-scales</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.989.1"> components.</span></span></p>
<p><span class="koboSpan" id="kobo.990.1">Once you’ve created the </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">select</span></strong><span class="koboSpan" id="kobo.992.1"> component, start by adding an input for the select options and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.994.1"> element. </span><span class="koboSpan" id="kobo.994.2">Also, add an input for the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">selectedIndex</span></strong><span class="koboSpan" id="kobo.996.1"> options and an output for when the selection changes. </span><span class="koboSpan" id="kobo.996.2">Lastly, add a function to set the selected index when a selection is made and emit the selected value using </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">the output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.998.1">
@Input({ required: true }) options!: unknown[];
@Input() optionTemplate?: TemplateRef&lt;unknown&gt;;
@Input() selectedIndex?: number;
@Input() labelKey?: string;
@Output() selectedChange = new EventEmitter&lt;unknown&gt;();
onOptionChange(index: any) {
  this.selectedIndex = index.target.value;
  this.selectedChange.emit(this.options[index.target.value]);
}</span></pre> <p><span class="koboSpan" id="kobo.999.1">Next, we will add the HTML for our dynamic select component. </span><span class="koboSpan" id="kobo.999.2">Start by creating a select element and an option for when there is no selected value. </span><span class="koboSpan" id="kobo.999.3">Next, add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">ng-container</span></strong><span class="koboSpan" id="kobo.1001.1"> element with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">*ngFor</span></strong><span class="koboSpan" id="kobo.1003.1"> directive looping over each option that’s received in </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.1004.1">the options input. </span><span class="koboSpan" id="kobo.1004.2">We will also track the index of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">for</span></strong><span class="koboSpan" id="kobo.1006.1"> loop because we will use the index </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.1007.1">for the option value. </span><span class="koboSpan" id="kobo.1007.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">*ngFor</span></strong><span class="koboSpan" id="kobo.1009.1"> element, we’ll define an option element and another </span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">ng-container</span></strong><span class="koboSpan" id="kobo.1011.1"> element that defines the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">ngTemplateOutlet</span></strong><span class="koboSpan" id="kobo.1013.1"> directive to either display a default template or the template received as input. </span><span class="koboSpan" id="kobo.1013.2">The default template can be used when the select options have no special display needs. </span><span class="koboSpan" id="kobo.1013.3">In all other scenarios, a template can be provided through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">optionTemplate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1"> input:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1016.1">
&lt;select (change)="onOptionChange($event)"&gt;
  &lt;option [value]=»null» [selected]=»!selectedIndex"&gt;Make selection&lt;/option&gt;
  &lt;ng-container *ngFor="let option of options; index as i"&gt;
    &lt;option [value]=»i" [selected]="i === selectedIndex"&gt;
      &lt;ng-container </span><strong class="bold"><span class="koboSpan" id="kobo.1017.1">[ngTemplateOutlet]=»optionTemplate || defaultTemplate»</span></strong><span class="koboSpan" id="kobo.1018.1">
        [</span><strong class="bold"><span class="koboSpan" id="kobo.1019.1">ngTemplateOutletContext</span></strong><span class="koboSpan" id="kobo.1020.1">]="{ </span><strong class="bold"><span class="koboSpan" id="kobo.1021.1">$implicit</span></strong><span class="koboSpan" id="kobo.1022.1">: option}"&gt;
      &lt;/ng-container&gt;
    &lt;/option&gt;
  &lt;/ng-container&gt;
&lt;/select&gt;
&lt;ng-template #defaultTemplate let-option&gt;
  {{ labelKey ? </span><span class="koboSpan" id="kobo.1022.2">option[labelKey] : option }}
&lt;/ng-template&gt;</span></pre> <p><span class="koboSpan" id="kobo.1023.1">As </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.1024.1">you can see, we </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.1025.1">also added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">ngTemplateOutletContext</span></strong><span class="koboSpan" id="kobo.1027.1"> directive to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">ng-container</span></strong><span class="koboSpan" id="kobo.1029.1"> element, which will display the template. </span><span class="koboSpan" id="kobo.1029.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">ngTemplateOutletContext</span></strong><span class="koboSpan" id="kobo.1031.1"> directive is assigned to an object containing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">$implicit</span></strong><span class="koboSpan" id="kobo.1033.1"> property. </span><span class="koboSpan" id="kobo.1033.2">The object you assign to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">ngTemplateOutletContext</span></strong><span class="koboSpan" id="kobo.1035.1"> directive can be used within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">ng-template</span></strong><span class="koboSpan" id="kobo.1037.1"> element, as we did in the preceding code snippet. </span><span class="koboSpan" id="kobo.1037.2">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">$implicit</span></strong><span class="koboSpan" id="kobo.1039.1"> value from the preceding code example inside an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">ng-template</span></strong><span class="koboSpan" id="kobo.1041.1"> element. </span><span class="koboSpan" id="kobo.1041.2">To use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">$implicit</span></strong><span class="koboSpan" id="kobo.1043.1"> value, you must use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">let-propertyName</span></strong><span class="koboSpan" id="kobo.1045.1"> syntax, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1046.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1047.1">
&lt;ng-template </span><strong class="bold"><span class="koboSpan" id="kobo.1048.1">let-option</span></strong><span class="koboSpan" id="kobo.1049.1">&gt;&lt;/ng-template&gt;</span></pre> <p><span class="koboSpan" id="kobo.1050.1">You can also assign an object with multiple properties to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">ngTemplateOutletContext</span></strong><span class="koboSpan" id="kobo.1052.1"> directive. </span><span class="koboSpan" id="kobo.1052.2">When you have other context properties besides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">$implicit</span></strong><span class="koboSpan" id="kobo.1054.1"> property, you must use a slightly different syntax to use the additional property. </span><span class="koboSpan" id="kobo.1054.2">Let’s say you have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">shown</span></strong><span class="koboSpan" id="kobo.1056.1"> property inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">ngTemplateOutletContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1058.1"> directive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1059.1">
[</span><strong class="bold"><span class="koboSpan" id="kobo.1060.1">ngTemplateOutletContext</span></strong><span class="koboSpan" id="kobo.1061.1">]="{ </span><strong class="bold"><span class="koboSpan" id="kobo.1062.1">$implicit</span></strong><span class="koboSpan" id="kobo.1063.1">: option, shown: option.shown}"</span></pre> <p><span class="koboSpan" id="kobo.1064.1">You must declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">shown</span></strong><span class="koboSpan" id="kobo.1066.1"> property so that it can be used in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">ng-template</span></strong><span class="koboSpan" id="kobo.1068.1"> element using </span><span class="No-Break"><span class="koboSpan" id="kobo.1069.1">this syntax:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1070.1">let-show</span></strong><span class="koboSpan" id="kobo.1071.1">="shown"</span></pre> <p><span class="koboSpan" id="kobo.1072.1">The left-hand side can have any name and is the name you use inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">ng-template</span></strong><span class="koboSpan" id="kobo.1074.1"> element; the right-hand side needs to match the property you declared in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1075.1">ngTemplateOutletContext</span></strong><span class="koboSpan" id="kobo.1076.1"> directive. </span><span class="koboSpan" id="kobo.1076.2">For example, you can replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.1077.1">let-shown</span></strong><span class="koboSpan" id="kobo.1078.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">let-shownValue</span></strong><span class="koboSpan" id="kobo.1080.1"> or anything else you desire, so long as it starts </span><span class="No-Break"><span class="koboSpan" id="kobo.1081.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">let-</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1083.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1084.1">
&lt;ng-template </span><strong class="bold"><span class="koboSpan" id="kobo.1085.1">let-shownValue</span></strong><span class="koboSpan" id="kobo.1086.1">="shown"&gt;
  &lt;div&gt;{{shownValue}}&lt;/div&gt;
&lt;/ng-template&gt;</span></pre> <p><span class="koboSpan" id="kobo.1087.1">Now that you know how to use the context inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">ng-template</span></strong><span class="koboSpan" id="kobo.1089.1"> elements, let’s test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1090.1">select</span></strong><span class="koboSpan" id="kobo.1091.1"> component and see how we can provide a custom template for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1092.1">select</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1"> component.</span></span></p>
<p><span class="koboSpan" id="kobo.1094.1">If </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.1095.1">you’re using </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.1096.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">select</span></strong><span class="koboSpan" id="kobo.1098.1"> component in another standalone component, you must import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">select</span></strong><span class="koboSpan" id="kobo.1100.1"> component before you can declare it in the HTML template. </span><span class="koboSpan" id="kobo.1100.2">Once you’ve imported the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">select</span></strong><span class="koboSpan" id="kobo.1102.1"> component, you can use it in the template </span><span class="No-Break"><span class="koboSpan" id="kobo.1103.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1104.1">
&lt;bt-libs-select (selectedChange)="onOptionChange($event)" [options]="['Test', 'Test 2']"&gt;
&lt;/bt-libs-select&gt;</span></pre> <p><span class="koboSpan" id="kobo.1105.1">In a real-world scenario, you should define the input for the options inside the component class, but I’ve added it directly in the HTML for demonstration purposes. </span><span class="koboSpan" id="kobo.1105.2">The default </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">ng-template</span></strong><span class="koboSpan" id="kobo.1107.1"> element will be used because we didn’t provide a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1108.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.1109.1"> element for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">optionTemplate</span></strong><span class="koboSpan" id="kobo.1111.1"> input of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">select</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1"> component.</span></span></p>
<p><span class="koboSpan" id="kobo.1114.1">Now, let’s create a custom template to provide to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">select</span></strong><span class="koboSpan" id="kobo.1116.1"> component. </span><span class="koboSpan" id="kobo.1116.2">Let’s say you have an array of expenses that looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1118.1">
[{expense: 'Food',amount: 10},{expense: 'Gas',amount: 20}]</span></pre> <p><span class="koboSpan" id="kobo.1119.1">Now, we can create a template to display the expense and amount inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">select</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1122.1">
&lt;ng-template #expenseSelect let-expense&gt;
  &lt;span&gt;Product: {{ expense.expense }}, Amount: {{ expense.amount }}&lt;/span&gt;
&lt;/ng-template&gt;</span></pre> <p><span class="koboSpan" id="kobo.1123.1">When the template is created, you need to assign the template to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">optionTemplate</span></strong><span class="koboSpan" id="kobo.1125.1"> input of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">select</span></strong><span class="koboSpan" id="kobo.1127.1"> component, </span><span class="No-Break"><span class="koboSpan" id="kobo.1128.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1129.1">
&lt;bt-libs-select (selectedChange)="onOptionChange($event)" </span><strong class="bold"><span class="koboSpan" id="kobo.1130.1">[optionTemplate]="expenseSelect"</span></strong><span class="koboSpan" id="kobo.1131.1"> [options]="expenses"&gt;
&lt;/bt-libs-select&gt;</span></pre> <p><span class="koboSpan" id="kobo.1132.1">After providing the custom template to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1133.1">optionSelect</span></strong><span class="koboSpan" id="kobo.1134.1"> input, the select component will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1135.1">expenseSelect</span></strong><span class="koboSpan" id="kobo.1136.1"> template instead of the default template. </span><span class="koboSpan" id="kobo.1136.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1137.1">expenseSelect</span></strong><span class="koboSpan" id="kobo.1138.1"> template receives the expense object that’s used inside the template through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1139.1">ngTemplateOutletContext</span></strong><span class="koboSpan" id="kobo.1140.1"> directive. </span><span class="koboSpan" id="kobo.1140.2">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">ng-template</span></strong><span class="koboSpan" id="kobo.1142.1"> element and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1143.1">ngTemplateOutletContext</span></strong><span class="koboSpan" id="kobo.1144.1"> directive, you can display any content you want inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">select</span></strong><span class="koboSpan" id="kobo.1146.1"> component and use any array of objects that’s necessary to provide the data for the template, giving you all the flexibility you need for a truly </span><span class="No-Break"><span class="koboSpan" id="kobo.1147.1">dynamic component.</span></span></p>
<p><span class="koboSpan" id="kobo.1148.1">We </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.1149.1">covered a lot </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.1150.1">in this section. </span><span class="koboSpan" id="kobo.1150.2">First, you learned about </span><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.1152.1"> and how to use it inside the component class or HTML. </span><span class="koboSpan" id="kobo.1152.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">ng-template</span></strong><span class="koboSpan" id="kobo.1154.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">ng-content</span></strong><span class="koboSpan" id="kobo.1156.1"> elements, you learned how to use structural directives combined with projected content. </span><span class="koboSpan" id="kobo.1156.2">You also learned how to provide context to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">ng-template</span></strong><span class="koboSpan" id="kobo.1158.1"> elements using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1159.1">ngTemplateOutletContext</span></strong><span class="koboSpan" id="kobo.1160.1"> directive to build truly dynamic components. </span><span class="koboSpan" id="kobo.1160.2">Finally, you learned about template variables and how to use them to access values inside your templates or display </span><span class="No-Break"><span class="koboSpan" id="kobo.1161.1">content conditionally.</span></span></p>
<p><span class="koboSpan" id="kobo.1162.1">In the next and last section of this chapter, you will learn about rendering </span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1">components dynamically.</span></span></p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.1164.1">Rendering components dynamically</span></h1>
<p><span class="koboSpan" id="kobo.1165.1">In some scenarios, you might want to load and render components dynamically. </span><span class="koboSpan" id="kobo.1165.2">You might </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.1166.1">want to load and render components dynamically because you don’t know the layout or exact components of the page upfront or because you have data and resource-intensive components that you only want to load and render if the user needs them in </span><span class="No-Break"><span class="koboSpan" id="kobo.1167.1">the view.</span></span></p>
<p><span class="koboSpan" id="kobo.1168.1">Here are </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.1169.1">some common examples of when dynamically loading components </span><span class="No-Break"><span class="koboSpan" id="kobo.1170.1">is useful:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1171.1">When building a website builder where customers can build up web pages based on a set of components you provide. </span><span class="koboSpan" id="kobo.1171.2">With a website builder, you don’t know how the user will create the page’s layout and what components will be used. </span><span class="koboSpan" id="kobo.1171.3">You want to load components dynamically whenever the user adds them to </span><span class="No-Break"><span class="koboSpan" id="kobo.1172.1">the page.</span></span></li>
<li><span class="koboSpan" id="kobo.1173.1">When you have a multi-step wizard where the content of the next steps differs based on the users’ choices during each step of </span><span class="No-Break"><span class="koboSpan" id="kobo.1174.1">the wizard.</span></span></li>
<li><span class="koboSpan" id="kobo.1175.1">Tabs, modals, and popups with resource-intensive components or where different components can be displayed based on the user interaction. </span><span class="koboSpan" id="kobo.1175.2">You only want to load and render the components if the user </span><span class="No-Break"><span class="koboSpan" id="kobo.1176.1">requests them.</span></span></li>
<li><span class="koboSpan" id="kobo.1177.1">When you </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.1178.1">allow users to configure a list of widgets in your application. </span><span class="koboSpan" id="kobo.1178.2">You don’t know what widgets the user will activate, and in what order they want them displayed, so it would make little sense to load and render them before the user </span><span class="No-Break"><span class="koboSpan" id="kobo.1179.1">configures them.</span></span></li>
<li><span class="koboSpan" id="kobo.1180.1">An ad banner component with different ads cycling through the ad banner component. </span><span class="koboSpan" id="kobo.1180.2">When different teams frequently add new ad components for the banner, a static component structure would make </span><span class="No-Break"><span class="koboSpan" id="kobo.1181.1">little sense.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1182.1">When you need to load and render components dynamically, there are three approaches: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">ngComponentOutlet</span></strong><span class="koboSpan" id="kobo.1184.1"> directive, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">ViewContainerRef</span></strong><span class="koboSpan" id="kobo.1186.1"> class, and, since Angular 17, the defer control flow. </span><span class="koboSpan" id="kobo.1186.2">First, we’ll use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1187.1">ngComponentOutlet</span></strong><span class="koboSpan" id="kobo.1188.1"> as this is the most straightforward solution that works for any Angular version. </span><span class="koboSpan" id="kobo.1188.2">Next, we will show you how to render and load components dynamically with the defer control flow that was introduced in </span><span class="No-Break"><span class="koboSpan" id="kobo.1189.1">Angular 17.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.1190.1">Rendering components dynamically using ngComponentOutlet</span></h2>
<p><span class="koboSpan" id="kobo.1191.1">To demonstrate dynamic component rendering using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1192.1">ngComponentOutlet</span></strong><span class="koboSpan" id="kobo.1193.1"> directive, we </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.1194.1">will create a widget component that can render different widgets with their own custom functionality and design. </span><span class="koboSpan" id="kobo.1194.2">Let’s say the widget container can receive widget data as input and render the widget it receives as input; this way, you can display a different widget for each page </span><span class="No-Break"><span class="koboSpan" id="kobo.1195.1">if needed.</span></span></p>
<p><span class="koboSpan" id="kobo.1196.1">Start by generating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">widget-container</span></strong><span class="koboSpan" id="kobo.1198.1"> component inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1199.1">common-components</span></strong><span class="koboSpan" id="kobo.1200.1"> library. </span><span class="koboSpan" id="kobo.1200.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.1201.1">widget-container</span></strong><span class="koboSpan" id="kobo.1202.1"> component will dynamically render widget components using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1203.1">ngComponentOutlet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1204.1"> directive.</span></span></p>
<p><span class="koboSpan" id="kobo.1205.1">Next, create two more components: a weather widget and a clock widget component. </span><span class="koboSpan" id="kobo.1205.2">For demonstration purposes, we will leave the weather and clock widget templates as Nx generated them </span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1">by default.</span></span></p>
<p><span class="koboSpan" id="kobo.1207.1">Now, in the widget container component, define an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">ng-container</span></strong><span class="koboSpan" id="kobo.1209.1"> element in the template and add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">ngComponentOutlet</span></strong><span class="koboSpan" id="kobo.1211.1"> directive to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">ng-container</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1213.1"> element:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1214.1">
&lt;ng-container *ngComponentOutlet="widget.component" /&gt;</span></pre> <p><span class="koboSpan" id="kobo.1215.1">As you can see, we assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1216.1">ngComponentOutlet</span></strong><span class="koboSpan" id="kobo.1217.1"> directive with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">widget.component</span></strong><span class="koboSpan" id="kobo.1219.1">. </span><span class="koboSpan" id="kobo.1219.2">So, let’s create an interface for the widget and add the widget property to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1220.1">component class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1221.1">
export interface widget { component: Type&lt;any&gt; | null };</span></pre> <p><span class="koboSpan" id="kobo.1222.1">Make the </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.1223.1">widget property an input so that the widget container can receive this widget property from the parent where you declare the widget </span><span class="No-Break"><span class="koboSpan" id="kobo.1224.1">container component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1225.1">
@Input() widget: widget = {component: null};</span></pre> <p><span class="koboSpan" id="kobo.1226.1">As a simple example, this is all you need to render a component dynamically. </span><span class="koboSpan" id="kobo.1226.2">We will extend this example quite a bit, but to showcase the dynamically rendered component, you can now use the widget container by adding the following to the HTML template of one of </span><span class="No-Break"><span class="koboSpan" id="kobo.1227.1">your components:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1228.1">
&lt;bt-libs-widget-container *ngIf="activeWidget" [widget]="activeWidget"&gt;&lt;/bt-libs-widget-container&gt;</span></pre> <p><span class="koboSpan" id="kobo.1229.1">In the component class, you need to add the active widget property that’s used for the input of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1230.1">widget container:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1231.1">
activeWidget!: widget;</span></pre> <p><span class="koboSpan" id="kobo.1232.1">Let’s say we want to alternate between the clock and the weather widget every 5 seconds. </span><span class="koboSpan" id="kobo.1232.2">We can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">setInterval</span></strong><span class="koboSpan" id="kobo.1234.1"> for this and assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1235.1">activeWidget</span></strong><span class="koboSpan" id="kobo.1236.1"> property with the clock or </span><span class="No-Break"><span class="koboSpan" id="kobo.1237.1">weather widget:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1238.1">
protected readonly cd = inject(ChangeDetectorRef);
showWeather = true;
ngOnInit() {
  setInterval(() =&gt; {
    this.activeWidget = { component: this.showWeather ? </span><span class="koboSpan" id="kobo.1238.2">WeatherWidgetComponent : ClockWidgetComponent };
    this.showWeather = !this.showWeather;
    this.cd.detectChanges();
  }, 5000)
}</span></pre> <p><span class="koboSpan" id="kobo.1239.1">When you open your component in the browser, you will see that after 5 seconds, the weather </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.1240.1">widget is shown, and the widget will alternate with the clock widget every 5 seconds after that. </span><span class="koboSpan" id="kobo.1240.2">This is, of course, just a simple example and can be improved upon a lot, but it shows how to render the widgets dynamically </span><span class="No-Break"><span class="koboSpan" id="kobo.1241.1">quite well.</span></span></p>
<p><span class="koboSpan" id="kobo.1242.1">Let’s continue and see how we can improve the widget container and add additional flexibility. </span><span class="koboSpan" id="kobo.1242.2">In some scenarios, your widget components might need data or access to a service to function properly. </span><span class="koboSpan" id="kobo.1242.3">When the widget needs to do this, you can add an injector to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1243.1">ngComponentOutlet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1244.1"> directive.</span></span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.1245.1">Using an injector with ngComponentOutlet</span></h2>
<p><span class="koboSpan" id="kobo.1246.1">You can </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.1247.1">provide additional data to your dynamically loaded components using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1248.1">injector</span></strong><span class="koboSpan" id="kobo.1249.1"> property of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1250.1">ngComponentOutlet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1251.1"> directive.</span></span></p>
<p><span class="koboSpan" id="kobo.1252.1">Let’s start by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">injector</span></strong><span class="koboSpan" id="kobo.1254.1"> property to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1255.1">ngComponentOutlet</span></strong><span class="koboSpan" id="kobo.1256.1"> directive inside the HTML template of the widget </span><span class="No-Break"><span class="koboSpan" id="kobo.1257.1">container component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1258.1">
&lt;ng-container *ngComponentOutlet="widget.component; </span><strong class="bold"><span class="koboSpan" id="kobo.1259.1">injector</span></strong><span class="koboSpan" id="kobo.1260.1">: widget.injector;" /&gt;</span></pre> <p><span class="koboSpan" id="kobo.1261.1">Next, you need to update the widget interface so that it contains the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">injector</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1263.1"> property:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1264.1">
export interface widget { component: Type&lt;any&gt; | null; </span><strong class="bold"><span class="koboSpan" id="kobo.1265.1">injector: Injector | any</span></strong><span class="koboSpan" id="kobo.1266.1"> };</span></pre> <p><span class="koboSpan" id="kobo.1267.1">When the widget container can handle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">injector</span></strong><span class="koboSpan" id="kobo.1269.1"> property, you must adjust the widget and the input the widget container component receives. </span><span class="koboSpan" id="kobo.1269.2">First, we will adjust the widget. </span><span class="koboSpan" id="kobo.1269.3">As an example, we will adjust the weather widget so that it can receive a city and a message that we will display in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1270.1">HTML template.</span></span></p>
<p><span class="koboSpan" id="kobo.1271.1">Create a new file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1272.1">widget-tokens.ts</span></strong><span class="koboSpan" id="kobo.1273.1"> and add an interface for the weather widget data and an injection token, </span><span class="No-Break"><span class="koboSpan" id="kobo.1274.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1275.1">
export interface WeatherWidgetData {city: string; message: string;}
export const WEATHERWIDGET = new InjectionToken&lt;WeatherWidgetData&gt;('weather widgets');</span></pre> <p><span class="koboSpan" id="kobo.1276.1">Inside </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.1277.1">the weather widget component class, you need to inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1278.1">WEATHERWIDGET</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1279.1">injection token:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1280.1">
widgetData = inject(WEATHERWIDGET);</span></pre> <p><span class="koboSpan" id="kobo.1281.1">Now, adjust the HTML template of the weather widget component so that it uses the values of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1282.1">WeatherWidgetData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1283.1"> interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1284.1">
&lt;p&gt;{{widgetData.city}}: {{widgetData.message}}&lt;/p&gt;</span></pre> <p><span class="koboSpan" id="kobo.1285.1">That is everything you need to do inside the weather widget component itself. </span><span class="koboSpan" id="kobo.1285.2">So, to reiterate, you created an interface and injection tokens, you injected the injection token, and you will receive the injector from the widget container’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1286.1">ngComponentOutlet</span></strong><span class="koboSpan" id="kobo.1287.1"> injector property. </span><span class="koboSpan" id="kobo.1287.2">To close the circle and make everything work, you need to provide the correct input to the widget container and include the injector that will provide the city and </span><span class="No-Break"><span class="koboSpan" id="kobo.1288.1">message data.</span></span></p>
<p><span class="koboSpan" id="kobo.1289.1">Before you added the injector, you provided the following as input to the widget container to display the </span><span class="No-Break"><span class="koboSpan" id="kobo.1290.1">weather widget:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1291.1">
{ component: WeatherWidgetComponent }</span></pre> <p><span class="koboSpan" id="kobo.1292.1">To provide the city and message data for the weather widget, you need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1293.1">injector</span></strong><span class="koboSpan" id="kobo.1294.1"> property to the input so that the widget container can include it in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1295.1">ngComponentOutlet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1296.1"> d</span><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.1297.1">irective.</span></span></p>
<p><span class="koboSpan" id="kobo.1298.1">You can create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1299.1">injector</span></strong><span class="koboSpan" id="kobo.1300.1"> property by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1301.1">create()</span></strong><span class="koboSpan" id="kobo.1302.1"> method on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1303.1">Injector</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1304.1"> c</span><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.1305.1">lass:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1306.1">
Injector.create()</span></pre> <p><span class="koboSpan" id="kobo.1307.1">Inside this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">create</span></strong><span class="koboSpan" id="kobo.1309.1"> method, there’s a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1310.1">providers</span></strong><span class="koboSpan" id="kobo.1311.1"> object. </span><span class="koboSpan" id="kobo.1311.2">This is similar to the provider objects you added inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1312.1">providers</span></strong><span class="koboSpan" id="kobo.1313.1"> array to a component, module, or your application configuration object in your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1314.1">app.config.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1315.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1316.1">
{ providers: [{ provide: WEATHERWIDGET, useValue: { city: 'Amsterdam', message: 'Sunny' } }] }</span></pre> <p><span class="koboSpan" id="kobo.1317.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1318.1">provide</span></strong><span class="koboSpan" id="kobo.1319.1"> property, use the injection token you created inside the weather widget component file. </span><span class="koboSpan" id="kobo.1319.2">For our example, you’ll use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1320.1">useValue</span></strong><span class="koboSpan" id="kobo.1321.1"> property and assign it to </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.1322.1">the city and message value you want to use. </span><span class="koboSpan" id="kobo.1322.2">You can create any valid provider object here, so you can also provide services or factory classes instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1323.1">useValue</span></strong><span class="koboSpan" id="kobo.1324.1"> property. </span><span class="koboSpan" id="kobo.1324.2">The entire </span><strong class="source-inline"><span class="koboSpan" id="kobo.1325.1">Injector.create()</span></strong><span class="koboSpan" id="kobo.1326.1"> method looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1327.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1328.1">
Injector.create({ providers: [{ provide: WEATHERWIDGET, useValue: { city: 'Amsterdam', message: 'Sunny' } }] })</span></pre> <p><span class="koboSpan" id="kobo.1329.1">The entire input object for the widget container looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1330.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1331.1">
{ component: WeatherWidgetComponent, injector: Injector.create({ providers: [{ provide: WEATHERWIDGET, useValue: { city: 'Amsterdam', message: 'Sunny' } }] }) }</span></pre> <p><span class="koboSpan" id="kobo.1332.1">Now, when the weather widget is displayed through the widget container, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">injector</span></strong><span class="koboSpan" id="kobo.1334.1"> property is passed along, and the city and message values are used within the HTML template of the weather widget. </span><span class="No-Break"><span class="koboSpan" id="kobo.1335.1">Cool stuff!</span></span></p>
<p><span class="koboSpan" id="kobo.1336.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1337.1">inject</span></strong><span class="koboSpan" id="kobo.1338.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1339.1">ngComponentOutlet</span></strong><span class="koboSpan" id="kobo.1340.1"> directive allows you to provide any service, factory method, or static data to the dynamically rendered components, making that dynamically rendered component as flexible as any </span><span class="No-Break"><span class="koboSpan" id="kobo.1341.1">other component.</span></span></p>
<p><span class="koboSpan" id="kobo.1342.1">Since Angular version 16.2.0-next.4, you can simplify providing (simple) values to dynamic components a bit by using the inputs property on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1343.1">ngComponentOutlet</span></strong><span class="koboSpan" id="kobo.1344.1"> directive instead of the injector property. </span><span class="koboSpan" id="kobo.1344.2">To u</span><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.1345.1">se the inputs property on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1346.1">ngComponentOutlet</span></strong><span class="koboSpan" id="kobo.1347.1">, you need to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1348.1">@Input()</span></strong><span class="koboSpan" id="kobo.1349.1"> propertie</span><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.1350.1">s to the widget. </span><span class="koboSpan" id="kobo.1350.2">In our example, we can add</span><a id="_idTextAnchor101"/> <strong class="source-inline"><span class="koboSpan" id="kobo.1351.1">city</span></strong><span class="koboSpan" id="kobo.1352.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1353.1">message</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1354.1">@Inpu</span><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.1355.1">t()</span></strong><span class="koboSpan" id="kobo.1356.1"> properties to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1357.1">weather widget:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1358.1">
@Input() c</span><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.1359.1">ity: string;
@Input() message: string;</span></pre> <p><span class="koboSpan" id="kobo.1360.1">Once you’ve adde</span><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.1361.1">d the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1362.1">@Input()</span></strong><span class="koboSpan" id="kobo.1363.1"> properties to the widget, you can provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1364.1">@Input()</span></strong><span class="koboSpan" id="kobo.1365.1"> properties with values through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1366.1">ngComponentOutlet</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1367.1">inputs</span></strong><span class="koboSpan" id="kobo.1368.1"> property, </span><span class="No-Break"><span class="koboSpan" id="kobo.1369.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1370.1">
&lt;ng-container *ngCom</span><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.1371.1">ponentOutlet="widget.component; </span><strong class="bold"><span class="koboSpan" id="kobo.1372.1">inputs</span></strong><span class="koboSpan" id="kobo.1373.1">: widgetInputs;" /&gt;</span></pre> <p><span class="koboSpan" id="kobo.1374.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1375.1">inputs</span></strong><span class="koboSpan" id="kobo.1376.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1377.1">ngComponentOutlet</span></strong><span class="koboSpan" id="kobo.1378.1"> directive needs to receive an object; in our case, we named the object </span><strong class="source-inline"><span class="koboSpan" id="kobo.1379.1">widgetInputs</span></strong><span class="koboSpan" id="kobo.1380.1">. </span><span class="koboSpan" id="kobo.1380.2">The object has a key for each </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.1381.1">input property of the component and a corresponding value. </span><span class="koboSpan" id="kobo.1381.2">So, in our case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1382.1">widgetInputs</span></strong><span class="koboSpan" id="kobo.1383.1"> object looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1384.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1385.1">
widgetInput</span><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.1386.1">s = {
  'city': 'Amsterdam',
  'message': 'Sunny',
}</span></pre> <p><span class="koboSpan" id="kobo.1387.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">inputs</span></strong><span class="koboSpan" id="kobo.1389.1"> property is a lot easier, but it can only provide objects with simple values. </span><span class="koboSpan" id="kobo.1389.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">injector</span></strong><span class="koboSpan" id="kobo.1391.1"> property provides more flexibility because it can provide simple values but also classes, services, and everything else you can inject within </span><span class="No-Break"><span class="koboSpan" id="kobo.1392.1">Angular applications.</span></span></p>
<p><span class="koboSpan" id="kobo.1393.1">Our widget system can already render components dynamically and provide injectors to the dynamically created components. </span><span class="koboSpan" id="kobo.1393.2">But the dynamically rendered components are still loaded eagerly, so we still need to improve a bit so that we only load the widget components when they need to </span><span class="No-Break"><span class="koboSpan" id="kobo.1394.1">be rendered.</span></span></p>
<h2 id="_idParaDest-95"><span class="koboSpan" id="kobo.1395.1">Laz</span><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.1396.1">y loading dynamic components</span></h2>
<p><span class="koboSpan" id="kobo.1397.1">To improve </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.1398.1">things further, we can lazy load our dynamic components. </span><span class="koboSpan" id="kobo.1398.2">Currently, when you load the page, all widgets will be loaded upfront. </span><span class="koboSpan" id="kobo.1398.3">It would be better if we only loaded the widget components if we needed them, or in other terms lazy loaded the components. </span><span class="koboSpan" id="kobo.1398.4">We need to change our widget container component so that it lazy loads our dynamically </span><span class="No-Break"><span class="koboSpan" id="kobo.1399.1">rendered components.</span></span></p>
<p><span class="koboSpan" id="kobo.1400.1">Let’s start by creating a new file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1401.1">widget-loaders.ts</span></strong><span class="koboSpan" id="kobo.1402.1">. </span><span class="koboSpan" id="kobo.1402.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1403.1">widget-loaders.ts</span></strong><span class="koboSpan" id="kobo.1404.1"> file will list some types and an object with the import statements for the lazy loaded widgets, a bit like lazy loading components with </span><span class="No-Break"><span class="koboSpan" id="kobo.1405.1">the router:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1406.1">
const widgetKeys = ['weatherWidget', 'clockWidget'] as const;
type WidgetKey = typeof widgetKeys[number];
export type WidgetLoader = { [key in WidgetKey]: () =&gt; Promise&lt;any&gt; };
export const widgetLoaders: WidgetLoader = {
  weatherWidget: () =&gt; import('../weather-widget/weather-widget.component'),
  clockWidget: () =&gt; import('../clock-widget/clock-widget.component'),
};
export type WidgetOption = WidgetLoader[keyof WidgetLoader];</span></pre> <p><span class="koboSpan" id="kobo.1407.1">We started </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.1408.1">by creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1409.1">widgetKeys</span></strong><span class="koboSpan" id="kobo.1410.1"> constant; here, you define all the keys you can use inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1411.1">widgetLoaders</span></strong><span class="koboSpan" id="kobo.1412.1"> obj</span><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.1413.1">ect. </span><span class="koboSpan" id="kobo.1413.2">Next, we make a type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1414.1">widgetKeys</span></strong><span class="koboSpan" id="kobo.1415.1"> constant to create a type-safe </span><strong class="source-inline"><span class="koboSpan" id="kobo.1416.1">WidgetLoader</span></strong><span class="koboSpan" id="kobo.1417.1"> type. </span><span class="koboSpan" id="kobo.1417.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1418.1">WidgetLoader</span></strong><span class="koboSpan" id="kobo.1419.1"> type defines a key-value pair where the keys can only be values declared inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1420.1">widgetKeys</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1421.1"> constant.</span></span></p>
<p><span class="koboSpan" id="kobo.1422.1">Next, we created the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1423.1">widgetLoaders</span></strong><span class="koboSpan" id="kobo.1424.1"> object, which types with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1425.1">WidgetLoader</span></strong><span class="koboSpan" id="kobo.1426.1"> type. </span><span class="koboSpan" id="kobo.1426.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1427.1">widgetLoaders</span></strong><span class="koboSpan" id="kobo.1428.1"> object will hold key-value pairs where the keys are values from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">widgetKeys</span></strong><span class="koboSpan" id="kobo.1430.1"> constant and the values import statements for the lazy </span><span class="No-Break"><span class="koboSpan" id="kobo.1431.1">loaded widgets.</span></span></p>
<p><span class="koboSpan" id="kobo.1432.1">Lastly, we created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1433.1">WidgetOption</span></strong><span class="koboSpan" id="kobo.1434.1"> type, which allows you to take a single value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1435.1">widgetLoaders</span></strong><span class="koboSpan" id="kobo.1436.1"> object and nothing else. </span><span class="koboSpan" id="kobo.1436.2">Now that we’ve created a type-safe way to define and select widget loaders, we can start to adjust the widget </span><span class="No-Break"><span class="koboSpan" id="kobo.1437.1">container component.</span></span></p>
<p><span class="koboSpan" id="kobo.1438.1">First, we must remove the widget input we had and replace it with a regular input property. </span><span class="koboSpan" id="kobo.1438.2">Then, we can add an input for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1439.1">injector</span></strong><span class="koboSpan" id="kobo.1440.1"> property and one for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1441.1">WidgetOption</span></strong><span class="koboSpan" id="kobo.1442.1"> property from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1443.1">widgetLoaders</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1444.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1445.1">
@Input() injector!: Injector;
@Input({ required: true }) widgetLoader!: WidgetOption;
widget: widget = { component: null, injector: null };</span></pre> <p><span class="koboSpan" id="kobo.1446.1">You also need to inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.1447.1">ChangeDetectorRef</span></strong><span class="koboSpan" id="kobo.1448.1"> because we have to trigger change </span><span class="No-Break"><span class="koboSpan" id="kobo.1449.1">detection manually:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1450.1">
protected readonly cd = inject(ChangeDetectorRef);</span></pre> <p><span class="koboSpan" id="kobo.1451.1">Next, you </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.1452.1">must add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1453.1">ngOnChanges</span></strong><span class="koboSpan" id="kobo.1454.1"> life cyc</span><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.1455.1">le hook with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1456.1">async</span></strong><span class="koboSpan" id="kobo.1457.1"> keyword in front because we will use async </span><strong class="source-inline"><span class="koboSpan" id="kobo.1458.1">await</span></strong><span class="koboSpan" id="kobo.1459.1"> to load the </span><span class="No-Break"><span class="koboSpan" id="kobo.1460.1">dynamic component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1461.1">
async ngOnChanges(changes: SimpleChanges) {}</span></pre> <p><span class="koboSpan" id="kobo.1462.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1463.1">ngOnChanges</span></strong><span class="koboSpan" id="kobo.1464.1"> life cycle hook, we will get the current value of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1465.1">widgetLoader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1466.1"> input:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1467.1">
const widgetLoader: WidgetOption = changes['widgetLoader'].currentValue;</span></pre> <p><span class="koboSpan" id="kobo.1468.1">Next, we’ll use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1469.1">widgetLoader</span></strong><span class="koboSpan" id="kobo.1470.1"> value to lazy load the widget component. </span><span class="koboSpan" id="kobo.1470.2">When the widget component is loaded, we will assign the widget property using the lazy-loaded component and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1471.1">injector</span></strong><span class="koboSpan" id="kobo.1472.1"> property. </span><span class="koboSpan" id="kobo.1472.2">Lastly, we need to trigger change detection to reflect the changes within </span><span class="No-Break"><span class="koboSpan" id="kobo.1473.1">the UI:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1474.1">
const widget = await widgetLoader();
this.widget = { component: widget[Object.keys(widget)[0]], injector: this.injector };
this.cd.detectChanges();</span></pre> <p><span class="koboSpan" id="kobo.1475.1">With the preceding changes added to th</span><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.1476.1">e widget container component, everything is in place, and you can lazy load and render widget components dynamically. </span><span class="koboSpan" id="kobo.1476.2">To test this, we need to use the widget container component inside another component and give it a widget loader and injector </span><span class="No-Break"><span class="koboSpan" id="kobo.1477.1">as input:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1478.1">
&lt;bt-libs-widget-container [widgetLoader]="widget" [injector]="injector"&gt;&lt;/bt-libs-widget-container&gt;</span></pre> <p><span class="koboSpan" id="kobo.1479.1">As an example, if you want to alternate between the clock and weather widget, you can add the </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.1480.1">following code to the component class where you’ve added the widget container in </span><span class="No-Break"><span class="koboSpan" id="kobo.1481.1">the template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1482.1">
widget: WidgetOption = widgetLoaders.weatherWidget;
injector: Injector | null = Injector.create({ providers: [{ provide: WEATHERWIDGET, useValue: { city: 'Amsterdam', message: 'Sunny' } }] });
protected readonly cd = inject(ChangeDetectorRef);
ngOnInit() {
  setInterval(() =&gt; {
    this.widget = this.widget === widgetLoaders.clockWidget ? </span><span class="koboSpan" id="kobo.1482.2">widgetLoaders.weatherWidget : widgetLoaders.clockWidget;
    this.injector = this.widget === widgetLoaders.clockWidget ? </span><span class="koboSpan" id="kobo.1482.3">null : Injector.create({ providers: [{ provide: WEATHERWIDGET, useValue: { city: 'Amsterdam', message: 'Sunny' } }] });
    this.cd.detectChanges();
  }, 5000)
}</span></pre> <p><span class="koboSpan" id="kobo.1483.1">When you inspect the </span><strong class="bold"><span class="koboSpan" id="kobo.1484.1">Network</span></strong><span class="koboSpan" id="kobo.1485.1"> tab of your browser’s developer tools, you will see the weather and clock widget components being loaded when they enter the view for the first time. </span><span class="koboSpan" id="kobo.1485.2">When the widgets are displayed again, and the components are alr</span><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.1486.1">eady loaded, the browser won’t load them again because the browser caches them </span><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.1487.1">for you. </span><span class="koboSpan" id="kobo.1487.2">Now, you have a truly dynamic widget system where you can lazy load and render widgets </span><span class="No-Break"><span class="koboSpan" id="kobo.1488.1">on demand.</span></span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.1489.1">Rendering components dynamically using the defer control flow</span></h2>
<p><span class="koboSpan" id="kobo.1490.1">In Angular 17, the </span><strong class="bold"><span class="koboSpan" id="kobo.1491.1">defer control flow</span></strong><span class="koboSpan" id="kobo.1492.1"> was added, which allows you to load and render components </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.1493.1">easily based on specific triggers. </span><span class="koboSpan" id="kobo.1493.2">Using the defer control flow can be useful in many scenarios, such as rendering components when they enter the </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.1494.1">viewport or dynamically rendering components based on conditions. </span><span class="koboSpan" id="kobo.1494.2">To showcase the defer control flow, we will create a new component </span><span class="No-Break"><span class="koboSpan" id="kobo.1495.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1496.1">defer-widget</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1497.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1498.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.1499.1">DeferWidgetComponent</span></strong><span class="koboSpan" id="kobo.1500.1"> will have the same functionality as our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1501.1">widget-container</span></strong><span class="koboSpan" id="kobo.1502.1"> component, only it will use the defer control flow instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1503.1">ngComponentOutlet</span></strong><span class="koboSpan" id="kobo.1504.1"> directive. </span><span class="koboSpan" id="kobo.1504.2">You can start by creating a component named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1505.1">defer-widget</span></strong><span class="koboSpan" id="kobo.1506.1">, next to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1507.1">widget-container</span></strong><span class="koboSpan" id="kobo.1508.1"> component. </span><span class="koboSpan" id="kobo.1508.2">Once you’ve created the component. </span><span class="koboSpan" id="kobo.1508.3">create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1509.1">widgets.enum.ts</span></strong><span class="koboSpan" id="kobo.1510.1"> file in the newly created </span><strong class="source-inline"><span class="koboSpan" id="kobo.1511.1">defer-widget</span></strong><span class="koboSpan" id="kobo.1512.1"> folder. </span><span class="koboSpan" id="kobo.1512.2">Add the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.1513.1">enum</span></strong><span class="koboSpan" id="kobo.1514.1"> inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1515.1">widgets.enum.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1516.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1517.1">
export enum Widgets {
  Clock,
  Weather
}</span></pre> <p><span class="koboSpan" id="kobo.1518.1">Next, you need to add an input for the active widget, the widget data, and a property with a reference to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1519.1">Widgets</span></strong><span class="koboSpan" id="kobo.1520.1"> enum </span><span class="No-Break"><span class="koboSpan" id="kobo.1521.1">inside </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1522.1">DeferWidgetComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1523.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1524.1">
@Input() activeWidget!: Widgets;
@Input() activeData!: any;
widgets = Widgets;</span></pre> <p><span class="koboSpan" id="kobo.1525.1">Inside the HTML template of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1526.1">DeferWidgetComponent</span></strong><span class="koboSpan" id="kobo.1527.1">, you need to add your widget components inside a defer block. </span><span class="koboSpan" id="kobo.1527.2">Defer blocks receive a trigger as a parameter. </span><span class="koboSpan" id="kobo.1527.3">When the defer trigger is triggered, the defer block will load and render the content that is inside the defer block. </span><span class="koboSpan" id="kobo.1527.4">For your widget component, you need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1528.1">when</span></strong><span class="koboSpan" id="kobo.1529.1"> trigger. </span><span class="koboSpan" id="kobo.1529.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1530.1">when</span></strong><span class="koboSpan" id="kobo.1531.1"> trigger loads and renders the content when the provided condition resolves </span><span class="No-Break"><span class="koboSpan" id="kobo.1532.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1533.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1534.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1535.1">We also want our content to hide again when the condition is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1536.1">false</span></strong><span class="koboSpan" id="kobo.1537.1"> again. </span><span class="koboSpan" id="kobo.1537.2">To hide your content when the condition is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1538.1">false</span></strong><span class="koboSpan" id="kobo.1539.1">, you also need to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1540.1">*ngIf</span></strong><span class="koboSpan" id="kobo.1541.1"> directive or use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1542.1">if</span></strong><span class="koboSpan" id="kobo.1543.1"> control flow. </span><span class="koboSpan" id="kobo.1543.2">I will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1544.1">*</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1545.1">ngIf</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1546.1"> directive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1547.1">
@defer (when activeWidget === widgets.Clock) {
  &lt;bt-libs-clock-widget *ngIf="activeWidget === widgets.Clock" /&gt;
}
@defer (when activeWidget === widgets.Weather) {
  &lt;bt-libs-weather-widget *ngIf="activeWidget === widgets.Weather" [widgetData]="widgetData" /&gt;
}</span></pre> <p><span class="koboSpan" id="kobo.1548.1">Without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1549.1">*ngIf</span></strong><span class="koboSpan" id="kobo.1550.1"> directive or if control flow syntax, the widget will not disappear if the condition returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1551.1">false</span></strong><span class="koboSpan" id="kobo.1552.1">. </span><span class="koboSpan" id="kobo.1552.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1553.1">when</span></strong><span class="koboSpan" id="kobo.1554.1"> statement of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1555.1">defer</span></strong><span class="koboSpan" id="kobo.1556.1"> syntax will not evaluate the condition again after it has resolved </span><span class="No-Break"><span class="koboSpan" id="kobo.1557.1">to true.</span></span></p>
<p><span class="koboSpan" id="kobo.1558.1">The </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.1559.1">aforementioned code is everything you need to lazy load and render widgets. </span><span class="koboSpan" id="kobo.1559.2">As you can see, this is a lot easier compared to using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1560.1">ngComponentOutlet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1561.1"> directive.</span></span></p>
<p><span class="koboSpan" id="kobo.1562.1">Because we already had some code in place, we still need to make some changes to the weather widget for our new defer solution to work. </span><span class="koboSpan" id="kobo.1562.2">Inside the weather widget component, you have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1563.1">widgetData</span></strong><span class="koboSpan" id="kobo.1564.1"> property. </span><span class="koboSpan" id="kobo.1564.2">You can place this under </span><strong class="source-inline"><span class="koboSpan" id="kobo.1565.1">comment</span></strong><span class="koboSpan" id="kobo.1566.1"> and replace it with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1567.1">@Input()</span></strong><span class="koboSpan" id="kobo.1568.1"> property, </span><span class="No-Break"><span class="koboSpan" id="kobo.1569.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1570.1">
// widgetData: WeatherWidgetData = inject(WEATHERWIDGET);
@Input() widgetData!: WeatherWidgetData | null;</span></pre> <p><span class="koboSpan" id="kobo.1571.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1572.1">widgetData</span></strong><span class="koboSpan" id="kobo.1573.1"> property we commented out is used for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1574.1">ngComponentOutlet</span></strong><span class="koboSpan" id="kobo.1575.1"> directive approach. </span><span class="koboSpan" id="kobo.1575.2">For our new defer approach, we will use a regular component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1576.1">@Input()</span></strong><span class="koboSpan" id="kobo.1577.1">. </span><span class="koboSpan" id="kobo.1577.2">You can also update the HTML template of the weather component and only render the city and message if we receive the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1578.1">widgetData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1579.1"> property:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1580.1">
&lt;p *ngIf="widgetData"&gt;{{widgetData.city}}: {{widgetData.message}}&lt;/p&gt;</span></pre> <p><span class="koboSpan" id="kobo.1581.1">Now, everything should work! </span><span class="koboSpan" id="kobo.1581.2">To test </span><strong class="source-inline"><span class="koboSpan" id="kobo.1582.1">DeferWidgetComponent</span></strong><span class="koboSpan" id="kobo.1583.1">, we can use it in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1584.1">expensesOverviewComponent</span></strong><span class="koboSpan" id="kobo.1585.1">, where we now use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1586.1">widgetContainerComponent</span></strong><span class="koboSpan" id="kobo.1587.1">. </span><span class="koboSpan" id="kobo.1587.2">In the HTML template, you can swap the old widget container with the new </span><span class="No-Break"><span class="koboSpan" id="kobo.1588.1">defer widget:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1589.1">
&lt;bt-libs-defer-widget [activeWidget]="widget" [widgetData]="widgetData" /&gt;</span></pre> <p><span class="koboSpan" id="kobo.1590.1">Now, we only need </span><strong class="source-inline"><span class="koboSpan" id="kobo.1591.1">widget</span></strong><span class="koboSpan" id="kobo.1592.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1593.1">widgetData</span></strong><span class="koboSpan" id="kobo.1594.1"> properties inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1595.1">expensesOverviewComponent</span></strong><span class="koboSpan" id="kobo.1596.1"> and must set their values. </span><span class="koboSpan" id="kobo.1596.2">You can comment out the old </span><strong class="source-inline"><span class="koboSpan" id="kobo.1597.1">widget</span></strong><span class="koboSpan" id="kobo.1598.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1599.1">injector</span></strong><span class="koboSpan" id="kobo.1600.1"> properties we used for the widget container and add these two </span><span class="No-Break"><span class="koboSpan" id="kobo.1601.1">properties instead:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1602.1">
widget!: Widgets;
widgetData: any = null;</span></pre> <p><span class="koboSpan" id="kobo.1603.1">Lastly, we have to change the logic inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1604.1">setInterval</span></strong><span class="koboSpan" id="kobo.1605.1">. </span><span class="koboSpan" id="kobo.1605.2">Once again, you can comment </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.1606.1">out the old code we used to alternate the weather and clock widgets for the widgets container and replace it with </span><span class="No-Break"><span class="koboSpan" id="kobo.1607.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1608.1">
this.widget = this.widget === Widgets.Clock ? </span><span class="koboSpan" id="kobo.1608.2">Widgets.Weather : Widgets.Clock;
this.widgetData = this.widget === Widgets.Clock ? </span><span class="koboSpan" id="kobo.1608.3">null : { city: 'Amsterdam', message: 'Sunny' };
this.cd.detectChanges();</span></pre> <p><span class="koboSpan" id="kobo.1609.1">Now, when you save everything, the new defer widget component should work identically to the widget container component. </span><span class="koboSpan" id="kobo.1609.2">After 5 seconds, the clock widget will be lazy loaded and rendered, and 5 seconds after that, the weather widget will be lazy loaded and rendered. </span><span class="koboSpan" id="kobo.1609.3">The two widgets will alternate every </span><span class="No-Break"><span class="koboSpan" id="kobo.1610.1">5 seconds.</span></span></p>
<p><span class="koboSpan" id="kobo.1611.1">With that, you’ve created a widget component with lazy loaded widgets using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1612.1">ngComponentOutlet</span></strong><span class="koboSpan" id="kobo.1613.1"> directive and the defer control flow syntax. </span><span class="koboSpan" id="kobo.1613.2">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1614.1">ngComponentOutlet</span></strong><span class="koboSpan" id="kobo.1615.1"> directive, you can provide injectors and you don’t have to remove the widgets with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1616.1">*ngIf</span></strong><span class="koboSpan" id="kobo.1617.1"> directive, but overall, the defer control flow syntax feels a lot cleaner </span><span class="No-Break"><span class="koboSpan" id="kobo.1618.1">and easier.</span></span></p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.1619.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1620.1">We learned a lot in this chapter! </span><span class="koboSpan" id="kobo.1620.2">First, you learned how to make components more flexible using content projection. </span><span class="koboSpan" id="kobo.1620.3">We created a modal component and showcased content projection with a single slot and multiple slots. </span><span class="koboSpan" id="kobo.1620.4">We also learned that you can’t combine structural directives on </span><span class="No-Break"><span class="koboSpan" id="kobo.1621.1">projected content.</span></span></p>
<p><span class="koboSpan" id="kobo.1622.1">Next, we did a deep dive into template variables and template references. </span><span class="koboSpan" id="kobo.1622.2">You learned how to create flexible and dynamic components using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1623.1">ng-template</span></strong><span class="koboSpan" id="kobo.1624.1">, how to access the values of components and input properties using template variables, and how to display different templates based on specific conditions. </span><span class="koboSpan" id="kobo.1624.2">You also learned how to provide context to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1625.1">ng-template</span></strong><span class="koboSpan" id="kobo.1626.1"> elements to build truly dynamic components that can fit almost all design needs you could have for </span><span class="No-Break"><span class="koboSpan" id="kobo.1627.1">a component.</span></span></p>
<p><span class="koboSpan" id="kobo.1628.1">Lastly, you learned about dynamic component rendering and loading. </span><span class="koboSpan" id="kobo.1628.2">You learned when you should use dynamically rendered or loaded components and how you can dynamically render and lazy load components at runtime using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1629.1">ngComponentOutlet</span></strong><span class="koboSpan" id="kobo.1630.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1631.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1632.1">defer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1633.1"> syntax.</span></span></p>
<p><span class="koboSpan" id="kobo.1634.1">In the next chapter, we will start to learn about conventions and design patterns within Angular so that we can improve the setup and implementation of </span><span class="No-Break"><span class="koboSpan" id="kobo.1635.1">our code.</span></span></p>
</div>
</body></html>