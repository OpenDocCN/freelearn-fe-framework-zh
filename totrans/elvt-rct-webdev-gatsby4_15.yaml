- en: '*Chapter 12*: Using Real-Time Data'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever ordered food and watched as it made its way closer to your destination
    without you having to refresh the page? You may have also seen this with package
    deliveries or ride-hailing apps. All of these make use of **real-time data**.
    This is a form of data that is presented as soon as it is acquired. So, in these
    examples, as soon as the service you are using has the food, package, or car's
    location, it will relay that information to you. The most common way that convenience
    sites and messaging applications enable real-time data is by using **web sockets**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to web sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Socket.io in action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live site visitor count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gaining further insights with rooms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, you will need to have completed [*Chapter 11*](B15983_11_ePub_RK.xhtml#_idTextAnchor152),
    *Creating Authenticated Experiences*.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter12](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to web sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web socket is a bi-directional communication channel between a client and
    a server. Unlike **REST** requests, the socket connection's channel remains open
    for the client and the server to push messages to and from each other whenever
    they need, instead of closing when a response is received. This kind of communication
    is commonly associated with low latency, which means it can handle high volumes
    of data with minimal delay.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does it work? To start, the client sends an HTTP request to a server,
    asking it to open a connection. If the server agrees, it will send back a response
    with a status of 101, indicating that it will be switching protocols. At this
    point, the handshake is complete and a **TCP/IP** connection is left open, allowing
    messages to pass back and forth between the two devices. This connection will
    remain open until one of the devices disconnects or loses its connection.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular socket implementations in the JavaScript world is *socket.io*,
    which consists of two parts – a Node.js server and a JavaScript client library.
    We'll look at socket.io in action by creating a minimal demo in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Quick Tip
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are also several other implementations of the *socket.io* server
    and client libraries available in languages other than JavaScript. This may be
    helpful if you want to combine a socket server (which we will create in this chapter)
    with more than just your Gatsby site.
  prefs: []
  type: TYPE_NORMAL
- en: Socket.io in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this demo, we will make a server that accepts a socket connection. When
    it receives a message from the client, it will log it to the console. Let''s start
    by creating the server and then move on to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `server` in your root directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a terminal in the `server` folder and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will set up an empty npm package in the folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same terminal, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `app.js` file in the `server` folder and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates a minimal Express server that listens for requests on port `3000`.
    As we have already learned, this socket connection is established with an HTTP
    request, and it requires an HTTP server to do this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that the server is working by opening a terminal within the `server`
    folder and running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `app.js` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before moving on, we must add a `server` folder and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, update your `app.js` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have set up our socket server, let''s interact with it from our
    Gatsby site by using Gatsby as the socket client. Navigate back to the root of
    your Gatsby site. Open a terminal here and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As the name of the library might suggest, this installs the socket.io client
    library that we will be using to communicate with our web socket server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new file within your `pages` folder called `socket.js` and add the
    following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continue editing `socket.js` and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start your Gatsby development server and ensure your socket server is also running.
    Navigate to `localhost:8000/socket`, type in a message, and click **Send message**.
    With any luck, the contents of your message should now be logged within your server's
    terminal. Congratulations – you've just sent your first message via sockets!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s expand this demo so that the client can receive communication back
    from the server. As an example, let''s make the server return one of three random
    greetings when it receives a message:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to modify how our server handles messages. Modify the socket
    server''s connection configuration with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, as well as logging the messages that are received from a client, we emit
    something back to that same client. In this case, we are choosing a random greeting
    to send back.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With our Gatsby page, we need to tell it to expect and handle messages of a
    certain type. This works like event listeners, so this should feel familiar to
    you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the render of the `page` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Within the render, we can map through the server messages and render them to
    the screen in a bulleted list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start your Gatsby development server and ensure your socket server is also
    running. Navigate to `localhost:8000/socket`, type in a message, and click **Send
    message**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Socket demonstration page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.1_B15983.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – Socket demonstration page
  prefs: []
  type: TYPE_NORMAL
- en: Your message should be logged within the server's terminal, but additionally,
    the server should have also sent a message back. It should be visible underneath
    the **Send Message** button. The speed at which this happens can feel crazy. And
    when the connection is good, it can almost feel like the server message is being
    triggered by your button press.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a clear understanding of how socket connections work and we have
    managed to send messages between the client and the server. Now, let's apply what
    we have learned and build something useful for our Gatsby site with this technology
    – a live visitor count in our site footer.
  prefs: []
  type: TYPE_NORMAL
- en: Live site visitor count
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The setup for this will need to be a little different from the previous example
    since, in the *Socket.io in action* section, the socket connection was isolated
    to a single page. However, our site footer is not on a single page but every page!
    An implementation of this that would work well is wrapping the site in some context.
    By doing this, we would be able to access the count in other parts of the application
    if we needed to. Let''s try this approach together:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the socket server''s connection configuration with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We've changed this configuration quite a bit, so let's break it down. When a
    new socket connects to the server, we use `io.emit`. This function sends a message
    to all the connected clients instead of a single socket. The socket type is `count`
    and the body contains `io.engine.clientsCount`, which is a count of the number
    of connected clients. If you use this whenever a new client connects, everyone
    will know that the count has changed. Then, we have to make sure that the count
    for clients is updated on disconnect too. For that, we trigger the same `io.emit`
    when the server has seen a client drop off.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new folder inside `src` called `context` if you don't already have
    one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file called `stats-context.js` and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are setting up the boilerplate of our stat's context. We create a `useStats`
    hook to access the context values that we will be defining in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code within `StatsProvider`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Within the page level demo, we set up the socket using a `useEffect`. We do
    the same thing here to ensure it only happens one time. Then, we create a second
    `useEffect` that, when connected to the server, will listen for messages of the
    `count` type. If one is received, it updates the count in state, which will then
    be available throughout the application via the `useStats` hook.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update your `gatsby-browser.js` and `gatbsy-ssr.js` files with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want to ensure that the count's context is available throughout the application.
    By adding this file to both the `gatsby-browser.js` and `gatsby-ssr.js` files,
    we can be sure it is accessible everywhere.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `VisitorCountBadge.js` file in `src/components/layout` and add the
    following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are making use of the `useStats` hook to retrieve `liveVistorCount`
    and the connected status. The color of the badge is dependent on the connection's
    status – if it is blue, then we are connected to the server; if not, it will be
    red. Then, we render `liveVistorCount` within this badge so that it is visible
    to the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we are using colors to signify the application state as an example only.
    Color alone should never be used to signify application state in production as
    it can leave your application inaccessible to colorblind users. It is better to
    combine color with another visual indicator, such as text, or at the very least
    an `aria-label`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update your `Footer` component file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start your Gatsby development server and ensure your socket server is also running.
    Navigate to `localhost:8000` and you should see the visitor count. If you duplicate
    your browser tab, the visitor count will rise, while if you close a tab, the count
    will fall. Finally, if you close the terminal with the socket server running,
    you should see the badge change to red, indicating it has lost connection to the
    server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now implemented a working current visitor count. Let's build on this
    feature by using rooms.
  prefs: []
  type: TYPE_NORMAL
- en: Gaining further insights with rooms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one element to socket.io events that we have not talked about yet but
    could be of great benefit in our application – `join` and `leave`. The server
    can emit messages to a room to broadcast an event to a subset of the clients connected
    to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the concept of rooms, we will be breaking down our visitor count
    into more granular stats. Not only will we display to the user the count of total
    users on the site, but we will also provide them with the details of how many
    people are on their current page of the site. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `server/app.js` file''s socket code so that it includes a new event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now expect clients to send us a new event of the `page-update` type. The
    body contains a `currentPage` and an optional `previousPage` for the client. We
    will use these two pieces of information to make them join the room for their
    current page and remove them from the room for their previous page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have defined a function called `pathToRoom` that we use to take the path
    where the user is and turn it into a string that we can use as a room identifier.
    If the client has sent a previous page, we know that this is not the first page
    on the site they have visited, so they need to be removed from the `previousPage`
    room. To do this, we can call the `socket.leave` function with the room identifier
    as the argument. We can then use `io.to(previousRoom).emit` to emit the new reduced
    count to users still on that page. After that, we can use `currentPage` to determine
    the new room that the user should join and emit the new count to users in that
    room (including the new user).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Quick Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`socket.leave` and `socket.join` are server-side only. Sockets cannot leave
    and join rooms on the client site.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `disconnect` event with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When a socket disconnects, we loop through all open rooms and emit the new number
    of clients to each of them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update your `gatsby-browser.js` and `gatbsy-ssr.js` files with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to your `stats-context.js` file and update the `StatsProvider` arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will need to use the location that we are now passing in, so let's de-structure
    it with props.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add two new React hooks to the top of `StatsProvider`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `useEffect` that''s related to incoming socket events within `StatsProvider`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `useEffect` inside `StatsProvider`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here is one of the most crucial parts of the code. We add the location to the
    `useEffect` dependency array so that this code runs whenever the user navigates
    between a page. Within `useEffect`, we check that the socket is available in the
    state and that the location update does not match the current location. If both
    conditions are met, we emit a `page-update` to the server, telling it where we
    have moved to so that it can keep track of the locations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the render of the `StatsProvider.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `components/VistorCountBadge.js` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are retrieving `pageVisitorCount` from the `useStats` hook and rendering
    it to the screen so that the user can see the value within the badge.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start your Gatsby development server and ensure your socket server is also running.
    Navigate to `localhost:8000`; you should see the visitor and page count. If you
    duplicate your browser tab, both numbers should rise, and if you navigate one
    of these tabs to another page on the site, you should see both tabs' page visitor
    counts update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have implemented an entire feature using sockets, let's summarize
    what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned all about web sockets and how we can use them to
    utilize real-time data within our Gatsby applications. Then, we implemented a
    working visitor count that shows the number of people on the current page, as
    well as the site as a whole. Visitor count statistics is one of a whole host of
    possible applications for web sockets within a personal site. Perhaps you could
    take what you have learned here and try and implement article reactions, polls,
    or even a chat application?
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about our final advanced concept – localization.
    We will learn how we can make our Gatsby site support multiple languages for an
    international audience.
  prefs: []
  type: TYPE_NORMAL
