<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Testing and Continuous Integration</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>Now that we have scaffolded and developed our e-commerce application, it's time to make it ready for deployment to our production environment. Before that, there are two important aspects of engineering that we need to look at, <em>quality</em> and <em>stability</em>. In this chapter, we will see how this can be achieved using modern DevOps practices, such as continuous integration and automated testing.</span></p>
<p>We will also see the following:</p>
<ul>
<li>Fixing and running tests</li>
<li><strong>CI</strong>/<strong>CD</strong> (<strong>continuous integration</strong>/<strong>continuous deployment</strong>) tools</li>
<li><span>Setting up CI with Jenkins using the JHipster CI-CD sub-generator</span></li>
</ul>
<div class="packt_infobox"><strong>DevOps</strong> is a software engineering practice that unifies software development (Dev) and software operation (Ops). The main focus of DevOps is automation and monitoring at all stages of software engineering, such as development, integration, testing, deployment, and infrastructure management. DevOps is one of the most trending engineering practices of this decade, and continuous integration and continuous deployment are two of its core aspects.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fixing and running tests</h1>
                </header>
            
            <article>
                
<p>Before we dive into continuous integration tools, let's first make sure that our tests are working and still pass after the changes we made in the previous chapter. In an ideal world, where software development is done using practices such as <strong>TDD</strong> (<strong>Test-driven development</strong>), writing and fixing tests is done along with the development of the code, and specs are written before you develop the actual code. You should try to follow this practice so that you write failing tests first for an expected result, and then develop code that will make the tests pass. Since our tests were autogenerated by JHipster we can at least make sure that they are working when we make changes to the generated code.</p>
<div class="packt_tip">JHipster can also generate performance tests using Gatling for the entities. It is very useful, and a must if you are developing a high-availability and high-volume website. This can be enabled when creating the application. See <a href="http://www.jhipster.tech/running-tests/">http://www.jhipster.tech/running-tests/</a><span> </span>for more details. </div>
<p>Let's run our unit and integration tests to see if any of them fail:</p>
<ol>
<li>Head over to your terminal and navigate to the online-store folder first.</li>
<li>Let's first run the server-side tests using Gradle:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; ./gradlew test</strong></pre>
<div class="packt_infobox">Note that JHipster generates both unit tests and integration tests for the server side. The unit tests, files named <kbd>*UnitTest.java</kbd>, are simple JUnit tests intended for unit testing functions. The integration tests, files named <kbd>*IntTest.java</kbd>, are intended for testing a Spring component using the entire Spring environment. They are run with the <kbd>SpringRunner</kbd> class and normally start up the Spring environment, configure all the required beans, and run the test.</div>
<p>Some of our tests failed with the following error trace:</p>
<pre><strong>com.mycompany.store.web.rest.ProductOrderResourceIntTest &gt; getProductOrder FAILED</strong><br/><strong>    java.lang.AssertionError at ProductOrderResourceIntTest.java:229</strong><br/><br/><strong>com.mycompany.store.web.rest.ProductOrderResourceIntTest &gt; getAllProductOrders FAILED</strong><br/><strong>    java.lang.AssertionError at ProductOrderResourceIntTest.java:213</strong><br/><br/><strong>com.mycompany.store.web.rest.ProductOrderResourceIntTest &gt; getNonExistingProductOrder FAILED</strong><br/><strong>    java.lang.AssertionError at ProductOrderResourceIntTest.java:242</strong><br/><br/><strong>com.mycompany.store.web.rest.ShipmentResourceIntTest &gt; getAllShipments FAILED</strong><br/><strong>    java.lang.AssertionError at ShipmentResourceIntTest.java:176</strong><br/><br/><strong>com.mycompany.store.web.rest.ShipmentResourceIntTest &gt; getShipment FAILED</strong><br/><strong>    java.lang.AssertionError at ShipmentResourceIntTest.java:192</strong><br/><br/><strong>com.mycompany.store.web.rest.ShipmentResourceIntTest &gt; getNonExistingShipment FAILED</strong><br/><strong>    java.lang.AssertionError at ShipmentResourceIntTest.java:205</strong><br/><br/><strong>com.mycompany.store.web.rest.InvoiceResourceIntTest &gt; getInvoice FAILED</strong><br/><strong>    java.lang.AssertionError at InvoiceResourceIntTest.java:309</strong><br/><br/><strong>com.mycompany.store.web.rest.InvoiceResourceIntTest &gt; getNonExistingInvoice FAILED</strong><br/><strong>    java.lang.AssertionError at InvoiceResourceIntTest.java:326</strong><br/><br/><strong>com.mycompany.store.web.rest.InvoiceResourceIntTest &gt; getAllInvoices FAILED</strong><br/><strong>    java.lang.AssertionError at InvoiceResourceIntTest.java:289</strong><br/><br/><strong>com.mycompany.store.web.rest.OrderItemResourceIntTest &gt; getNonExistingOrderItem FAILED</strong><br/><strong>    java.lang.AssertionError at OrderItemResourceIntTest.java:247</strong><br/><br/><strong>com.mycompany.store.web.rest.OrderItemResourceIntTest &gt; getAllOrderItems FAILED</strong><br/><strong>    java.lang.AssertionError at OrderItemResourceIntTest.java:218</strong><br/><br/><strong>com.mycompany.store.web.rest.OrderItemResourceIntTest &gt; getOrderItem FAILED</strong><br/><strong>    java.lang.AssertionError at OrderItemResourceIntTest.java:234</strong><br/><strong>2018-02-11 13:55:55.693 INFO 27458 --- [ Thread-10] c.m.store.config.CacheConfiguration : Closing Cache Manager</strong><br/><br/><strong>217 tests completed, 12 failed</strong></pre>
<div class="packt_tip">You could also run the tests from your IDE so that you have a better error message and failure report. Select the entire <kbd>src/test</kbd> folder, right-click, and select <span class="packt_screen">Run all tests</span>.</div>
<ol start="3">
<li class="mce-root">These are expected to fail as we changed the <kbd>Resource</kbd> classes for these entities in the previous chapter to handle authorizations, and the failure means that it's working perfectly. Fortunately, it's not difficult to fix the tests using Spring. We can use the <kbd>@WithMockUser</kbd> annotation provided by the Spring test context to provide a mock user for our tests. Add the annotation with user details as highlighted in the following code to all the failing test classes:</li>
</ol>
<pre style="padding-left: 60px">@RunWith(SpringRunner.class)<br/>@SpringBootTest(classes = StoreApp.class)<br/><strong>@WithMockUser(username="admin", authorities={"ROLE_ADMIN"}, password = "admin")</strong><br/>public class InvoiceResourceIntTest {<br/>...<br/>}</pre>
<ol start="4">
<li>We are providing a mock user with the <kbd>ADMIN</kbd> role here. Add the same to <kbd>OrderItemResourceIntTest</kbd>, <kbd>ProductOrderResourceIntTest</kbd>, and <kbd>ShipmentResourceIntTest</kbd>. Run the tests again and they should pass.</li>
<li><span>Commit the changes made by running </span><kbd>git commit -am "fix server side tests with<span> </span>mockUser"</kbd>.</li>
<li>Now let's make sure our client-side Karma unit tests are working. Since we didn't make any logic changes on the client-side there shouldn't be any failures. Run the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; yarn test</strong></pre>
<ol start="7">
<li><span>All tests should pass. Let's head over to</span> <kbd>src/test<span>/</span>javascript<span>/</span>spec<span>/</span>app<span>/</span>entities<span>/</span>product<span>/</span>product.component.spec.ts</kbd>. We use the Jasmine Framework for our tests. The existing test has the following structure. The <kbd>beforeEach</kbd> block sets up the Angular <kbd>TestBed</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/><br/>describe('Component Tests', () =&gt; {<br/>    describe('Product Management Component', () =&gt; {<br/>        ...<br/>        beforeEach(() =&gt; {<br/>            TestBed.configureTestingModule({<br/>                ...<br/>            })<br/>            .overrideTemplate(ProductComponent, '')<br/>            .compileComponents();<br/>            ...<br/>        });<br/><br/><br/>        it('Should call load all on init', () =&gt; {<br/>           ...<br/>        });<br/>        ...<br/>    });<br/><br/>});</pre>
<ol start="8">
<li>Now let's make sure our protractor <kbd>e2e</kbd> tests are working. Run the following commands in two separate terminals. Start the server first. Let's clear the database as well by a running clean task so that tests run on a fresh setup. Since we are running a clean task we also need to run the <kbd>webpackBuildDev</kbd> task to rebuild the client side:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; ./gradlew clean webpackBuildDev bootRun</strong></pre>
<ol start="9">
<li>Now run the e2e tests:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; yarn e2e</strong></pre>
<div class="packt_tip">If you prefer not to run scripts via Yarn or NPM, you could also run them via Gradle using the node integration provided by JHipster. For example, instead of <kbd>yarn e2e</kbd>, you could run <kbd>./gradlew yarn_e2e</kbd>, and instead of <kbd>yarn test</kbd> you could run <kbd>./gradlew yarn_test</kbd>. This is useful if you do not want to install NodeJS and Yarn and want everything to be managed for you by Gradle. If you choose Maven instead of Gradle the same feature is available for that as well.</div>
<ol start="10">
<li><span>All tests should pass here as well. But if you look at the generated <kbd>e2e</kbd> tests, for example, look at</span> <kbd>src/test/javascript/e2e/entities/customer.spec.ts</kbd>, <span>you will see that a test is commented out. Some tests are commented out during generation if an entity has a required relationship field, as we would have to create a relationship first and set its value for the test to work. </span>Let's focus on only the <kbd>Customer</kbd> page test. Uncomment the test named <span class="packt_screen">should create and save Customers</span> and change the <kbd>describe</kbd> function to <kbd>fdescribe</kbd> on the test file, so that only this test file is executed:</li>
</ol>
<pre style="padding-left: 60px">fdescribe('Customer e2e test', () =&gt; {<br/>   ...<br/>});</pre>
<ol start="11">
<li>Now execute <kbd>yarn e2e</kbd> and we should see one failing test. First, let's fix the email field by providing a valid email format:</li>
</ol>
<pre style="padding-left: 60px">    it('should create and save Customers', () =&gt; {<br/>        ...<br/>        customerDialogPage.setEmailInput('email@email.com');<br/>        expect(customerDialogPage.getEmailInput()).toMatch('email@email.com');<br/>        ...<br/>    });</pre>
<ol start="12">
<li>Run <kbd>yarn e2e</kbd> again and this time it should pass. But since we have a one-to-one relationship between user and customer the test will fail if we run it again, hence we need to delete the row created after it. Let's add a test case for a delete action. In the <kbd>CustomerComponentsPage</kbd> class defined in the file (if you are using JHipster 5, this class will be available under <kbd>src/test/javascript/e2e/page-objects/customer-page-object.ts</kbd>), add a new property and methods as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>    </span><span>table</span><span> </span><span>=</span><span> </span><span>element</span><span>.</span><span>all</span><span>(</span><span>by</span><span>.</span><span>css</span><span>(</span><span>'.table-responsive tbody tr'</span><span>));<br/>    getTable() {<br/>        return this.table;<br/>    }<br/><br/>    deleteFirstItem() {<br/>        this.table.first().element(by.css('button.btn-<br/>        danger')).click();<br/>    }<br/></span></pre>
<ol start="13">
<li>Now add <kbd>expect(customerComponentsPage.getTable().isPresent()).toBeTruthy();</kbd> as the last line in our previous test to confirm if the row was created. Then add the following test to delete the row:</li>
</ol>
<pre style="padding-left: 60px">it('should create and save Customers', () =&gt; {<br/>        ...<br/>        expect(customerComponentsPage.getTable().isPresent()).toBeTruthy();<br/>    });<br/><br/>    it('should delete Customers', () =&gt; {<br/>        customerComponentsPage.deleteFirstItem();<br/>        const deleteBtn = element.all(by.css('.modal-footer <br/>        .btn.btn-danger'));<br/>        deleteBtn.click();<br/>        expect(customerComponentsPage.getTable().isPresent()).toBeFalsy();<br/>    });</pre>
<ol start="14">
<li>Run <kbd>yarn e2e</kbd> again to verify. Do not forget to remove the <kbd>fdescribe</kbd> from the file so that all tests get executed. Congratulations! You added you first protractor <kbd>e2e</kbd> tests.</li>
<li>Similarly, fix the commented out <kbd>e2e</kbd> tests in other files under <kbd>src/test/javascript/e2e/entities</kbd> as well. This is part of the <em>next steps</em> assignment.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Continuous integration</h1>
                </header>
            
            <article>
                
<p>Having automated testing ensures that we are creating bug-free code, and also ensures that there are no regressions introduced from new code. JHipster helps to an extent, by creating unit and integration tests for the generated code, but in real use cases, it won't be sufficient. We would have to add server-side unit tests for the business logic that we introduce and integration tests for new APIs we add. You<span> will also have to add more unit tests for business logic handled on the client side and <kbd>e2e</kbd> tests, as JHipster only generates a few sample tests for you and doesn't know anything about your business logic.</span></p>
<div class="packt_tip">The more tests you have, more confident you will be changing code, with fewer chances of regression.</div>
<p>Testing and continuous integration is an integral part of full-stack development and is an important aspect of DevOps. Testing should be considered as important as developing features to build a quality product. Continuous integration is nothing more than continuously merging and testing your new code changes in an isolated environment against your master/main/stable codebase to identify potential bugs and regression. It is achieved by running automated unit, integration, end-to-end, and other test suites against the code. For example, if you are working with Git, these are typically run for every commit you make to your master branch and/or for every pull request, you create.</p>
<p>Once we have automated tests, we can make use of continuous integration practices to make sure that any new code we introduce doesn't cause any regression in our stable code base. This will give us the confidence to merge new code and deploy that to production.</p>
<p>Modern DevOps teams often go a step further and do continuous delivery (continuous integration + continuous deployment). They often define CI/CD pipelines, which continuously integrate, test, and deploy code to production in a fully automated way.</p>
<div class="packt_tip">Teams with a good continuous integration and continuous deployment setup can deliver more features more frequently with fewer bugs.</div>
<p>Have I stressed the importance of continuous integration enough?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CI/CD tools</h1>
                </header>
            
            <article>
                
<p class="mce-root">JHipster provides excellent support for the well-known CI/CD tools. Let's take a look at the options available first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Jenkins</h1>
                </header>
            
            <article>
                
<p>Jenkins (<a href="https://jenkins.io/">https://jenkins.io/</a>) is one of the leading CI/CD tools out there. It is free and open source. It is an automation server written in Java and supports integration with various version control tools, such as Git, CVS, SVN, and so on. Jenkins has a huge plugin ecosystem and this makes it one of the most flexible platforms. Jenkins can be used for building projects, running automated tests, automating deployment, and so on. It is available as an executable binary for various platforms and as Docker images. <span>Blue Ocean is the latest UI interface for Jenkins giving it a much-needed breath of fresh air. Jenkins has the concept of a pipeline, achieved by using multiple plugins and a Groovy DSL to define the CI/CD pipeline. </span><span>Jenkins pipeline plugins provide a comprehensive DSL-based configuration that can be defined in a file called a </span><kbd>Jenkinsfile</kbd><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Travis CI</h1>
                </header>
            
            <article>
                
<p>Travis CI (<a href="https://travis-ci.org/">https://travis-ci.org/</a>) is an open source hosted <strong>PaaS</strong> (<strong>Platform as a Service</strong>) solution for CI/CD. It is free for public/OSS projects and needs a subscription for use by private/enterprise projects. It supports applications written in a variety of languages and platforms, and is heavily used by open source projects, including JHipster, for their continuous integration needs. It has excellent integration with version control tools and offers an enterprise version as well. It is very easy to set up and use, and has a simple YAML-based configuration. Advanced setups are typically done using shell scripts that can be triggered by the YAML configuration using hooks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GitLab CI</h1>
                </header>
            
            <article>
                
<p>GitLab CI (<a href="https://about.gitlab.com/features/gitlab-ci-cd/">https://about.gitlab.com/features/gitlab-ci-cd/</a>) is a CI/CD solution available as part of GitLab, a web UI on top of Git. It is well integrated into the platform and is an excellent choice when using GitLab. It is free and open source for use by public projects and has an enterprise version as well. It has both a hosted solution and binaries to be used on-premises.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CircleCI </h1>
                </header>
            
            <article>
                
<p class="mce-root">CircleCI (<a href="https://circleci.com/">https://circleci.com/</a>) is another open source CI/CD solution that offers both a hosted PaaS and on-premises option. It has free options for small teams and subscription plans for bigger teams and enterprises. The configuration is simple and YAML-based, similar to Travis CI. It provides options to choose different OS environments for the builds and is very easy to set up.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up Jenkins</h1>
                </header>
            
            <article>
                
<p>Let's use Jenkins as the CI tool for our application. We first need to set up a local Jenkins instance: </p>
<div class="packt_tip">If you are already familiar with Docker, you can use the official Docker image provided by Jenkins and can skip the following steps.  The Docker image will be automatically generated by JHipster when creating the CD/CI pipeline in the following section. Visit <a href="http://www.jhipster.tech/setting-up-ci-jenkins2/">http://www.jhipster.tech/setting-up-ci-jenkins2/</a> for more details.</div>
<ol>
<li>Let's download the latest binary from <a href="http://mirrors.jenkins.io/war-stable/latest/jenkins.war">http://mirrors.jenkins.io/war-stable/latest/jenkins.war</a>.</li>
<li>Now open a terminal and navigate to the folder where the file was downloaded.</li>
<li>Execute <kbd>java -jar jenkins.war --httpPort=8989</kbd> from the terminal to start a Jenkins server. The port should not conflict with our application port. The default password will be printed on the console. Make a copy of it.</li>
<li>Navigate to <a href="http://localhost:8989">https://localhost:8989</a> and paste the password copied before.</li>
<li>Click on the <span class="packt_screen">Install suggested plugins</span> button on the next page and wait for the plugin installation to complete.</li>
<li>Create an admin user on the next page and complete.</li>
</ol>
<p>Now that our Jenkins server is ready, let's go ahead and create a Jenkins pipeline for our project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Jenkins pipeline using JHipster</h1>
                </header>
            
            <article>
                
<p>We can create the <kbd>Jenkinsfile</kbd> for our project using the <kbd>ci-cd sub-generator</kbd> from JHipster:</p>
<ol>
<li>In a terminal, navigate to the online-store folder first. Now run the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; jhipster ci-cd</strong></pre>
<ol start="2">
<li>You will be asked to select from a list of options as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>Welcome to the JHipster CI/CD Sub-Generator</strong><br/><strong>? What CI/CD pipeline do you want to generate? (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)<br/></strong><strong>&gt;</strong><strong>◯ </strong><strong>Jenkins pipeline</strong><br/><strong> ◯ Travis CI</strong><br/><strong> ◯ GitLab CI</strong><br/><strong> ◯ CircleCI</strong></pre>
<ol start="3">
<li>Let's select <span class="packt_screen">Jenkins pipeline</span> from it. Next, we will have an option to choose additional stages:</li>
</ol>
<pre style="padding-left: 60px"><strong>? What CI/CD pipeline do you want to generate? Jenkins pipeline</strong><br/><strong>? Jenkins pipeline: what tasks/integrations do you want to include?<br/></strong><strong>&gt;</strong><strong>◯ Perform the build in a Docker container</strong><br/><strong> ◯ Analyze code with Sonar</strong><br/><strong> ◯ Send build status to GitLab</strong><br/><strong> ◯ Build and publish a Docker image</strong></pre>
<ol start="4">
<li>Let's skip this, as we won't be needing these for now, and proceed. Next, we will be asked if we need to automatically deploy to Heroku from our CI/CD pipeline:</li>
</ol>
<pre style="padding-left: 60px"><strong>? What CI/CD pipeline do you want to generate? Jenkins pipeline</strong><br/><strong>? Jenkins pipeline: what tasks/integrations do you want to include?</strong><br/><strong>? Deploy to heroku?<br/></strong><strong>&gt;</strong><strong>◯ </strong><strong>In Jenkins pipeline</strong></pre>
<ol start="5">
<li>Let's choose this option as we will need it later. Once the option is selected JHipster will generate the files and log the following output on the console.</li>
</ol>
<pre style="padding-left: 60px">   create <strong>Jenkinsfile</strong><br/>   create src/main/docker/jenkins.yml<br/>   create src/main/resources/idea.gdsl<br/>Congratulations, JHipster execution is complete!</pre>
<div class="packt_tip"><span>If you want to use Travis instead of Jenkins you can do so by choosing the <span class="packt_screen">Travis</span> option and then publishing the repository to GitHub as a public repository. Once published go to </span><kbd>https://github.com/&lt;username&gt;/&lt;repoName&gt;/settings/installations</kbd> <span>and add Travis CI as a service and follow the instructions. You can now see automated builds when you make commits. Refer to <a href="https://docs.travis-ci.com/user/getting-started/">https://docs.travis-ci.com/user/getting-started/</a> for details.</span></div>
<p>As you can see, we got a <kbd>Jenkinsfile</kbd> generated at the root and Docker image for Jenkins created in the <kbd>src/main/docker</kbd> directory. We also got an <kbd>idea.gdsl</kbd> file, which is used by IntelliJ Idea for autocompletion.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Jenkinsfile and its stages</h1>
                </header>
            
            <article>
                
<p>Let's take a look at the generated <kbd>Jenkinsfile</kbd>, which has our pipeline definitions using the Groovy DSL:</p>
<pre style="padding-left: 60px">#!/usr/bin/env groovy<br/><br/>node {<br/>    stage('<strong>checkout</strong>') {<br/>        checkout scm<br/>    }<br/><br/>    stage('<strong>check java</strong>') {<br/>        sh "java -version"<br/>    }<br/><br/>    stage('<strong>clean</strong>') {<br/>        sh "chmod +x gradlew"<br/>        sh "./gradlew clean --no-daemon"<br/>    }<br/><br/>    stage('<strong>install tools</strong>') {<br/>        sh "./gradlew yarn_install -PnodeInstall --no-daemon"<br/>    }<br/><br/>    stage('<strong>backend tests</strong>') {<br/>        try {<br/>            sh "./gradlew test -PnodeInstall --no-daemon"<br/>        } catch(err) {<br/>            throw err<br/>        } finally {<br/>            junit '**/build/**/TEST-*.xml'<br/>        }<br/>    }<br/><br/>    stage('<strong>frontend tests</strong>') {<br/>        try {<br/>            sh "./gradlew yarn_test -PnodeInstall --no-daemon"<br/>        } catch(err) {<br/>            throw err<br/>        } finally {<br/>            junit '**/build/test-results/karma/TESTS-*.xml'<br/>        }<br/>    }<br/><br/>    stage('<strong>packaging</strong>') {<br/>        sh "./gradlew bootRepackage -x test -Pprod -PnodeInstall --<br/>        no-daemon"<br/>        archiveArtifacts artifacts: '**/build/libs/*.war', <br/>        fingerprint: true<br/>    }<br/><br/>    stage('<strong>deployment</strong>') {<br/>        sh "./gradlew deployHeroku --no-daemon"<br/>    }<br/>}</pre>
<p>We have multiple stages defined running in a sequence, highlighted in bold; there are eight to be exact. It starts with a checkout of the branch from version control ending with deployment to Heroku (we will see more about this in the following chapter).</p>
<p>The steps are quite straightforward as most of it is just triggering a Gradle task. Let's look at each of them:</p>
<pre style="padding-left: 30px">    stage('<strong>checkout</strong>') {<br/>        checkout scm<br/>    }</pre>
<p>The <kbd>checkout</kbd> stage does a local checkout of the source code revision that triggered the build:</p>
<pre style="padding-left: 30px">    stage('<strong>check java</strong>') {<br/>        sh "java -version"<br/>    }</pre>
<p>This <kbd>check java</kbd> stage just prints the Java version installed on the Jenkins environment:</p>
<pre style="padding-left: 60px">    stage('<strong>clean</strong>') {<br/>        sh "chmod +x gradlew"<br/>        sh "./gradlew clean --no-daemon"<br/>    }</pre>
<p>The <kbd>clean</kbd> stage first grants execution permission for the Gradle wrapper on a Unix-like OS and then executes the Gradle clean task. The <kbd>--no-daemon</kbd> flag disables the Gradle daemon feature, which is not required in a CI environment:</p>
<pre>    stage('<strong>install tools</strong>') {<br/>        sh "./gradlew yarn_install -PnodeInstall --no-daemon"<br/>    }</pre>
<p>The <kbd>install tools</kbd> stage makes sure that NodeJS and all the NPM modules are installed by running <kbd>yarn</kbd> install via Gradle.</p>
<p>The <kbd>-PnodeInstall</kbd> flag ensures that NodeJS is installed first if not done already:</p>
<pre>    stage('<strong>backend tests</strong>') {<br/>        try {<br/>            sh "./gradlew test -PnodeInstall --no-daemon"<br/>        } catch(err) {<br/>            throw err<br/>        } finally {<br/>            junit '**/build/**/TEST-*.xml'<br/>        }<br/>    }</pre>
<p>The <strong>backend tests</strong> stage runs all the server-side integration and unit tests by triggering the Gradle test task. It will fail the Jenkins pipeline when there is an error and register the test reports on the Jenkins web UI using the JUnit plugin after the test run is complete:</p>
<pre>    stage('<strong>frontend tests</strong>') {<br/>        try {<br/>            sh "./gradlew yarn_test -PnodeInstall --no-daemon"<br/>        } catch(err) {<br/>            throw err<br/>        } finally {<br/>            junit '**/build/test-results/karma/TESTS-*.xml'<br/>        }<br/>    }</pre>
<p>Similar to previously, the frontend tests stage runs the client-side unit tests by triggering the yarn test command via a <kbd>Gradle</kbd> task. It will also fail the pipeline on an error and register the test reports on the Jenkins web UI:</p>
<pre>    stage('<strong>packaging</strong>') {<br/>        sh "./gradlew bootRepackage -x test -Pprod -PnodeInstall --no-<br/>        daemon"<br/>        archiveArtifacts artifacts: '**/build/libs/*.war', fingerprint: <br/>        true<br/>    }</pre>
<p>The <kbd>packaging</kbd> stage triggers the <kbd>Gradle bootRepackage</kbd> task with the <kbd>prod</kbd> profile and archives the created WAR files with a unique fingerprint:</p>
<pre>    stage('<strong>deployment</strong>') {<br/>        sh "./gradlew deployHeroku --no-daemon"<br/>    }</pre>
<p>The final stage is for <kbd>deployment</kbd> and it also uses a Gradle task for this. We will see this in detail in the following chapter. For now, let's comment out this stage. We will re-enable it later.</p>
<p>Now let's commit everything to <kbd>git</kbd> by running these commands. Make sure you are on the master branch, else <kbd>commit</kbd> and merge the branch with the master:</p>
<pre><strong>&gt; git add --all</strong><br/><strong>&gt; git commit -am "add Jenkins pipeline for ci/cd"</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the Jenkinsfile in a Jenkins server</h1>
                </header>
            
            <article>
                
<p>Now that our <kbd>Jenkinsfile</kbd> is ready, let's set up CI/CD for our application. First, we need to upload our application to a GIT server, such as GitHub, GitLab, or BitBucket. Let's use GitHub (<a href="https://github.com/">https://github.com/</a>) for this. Make sure you have an account created in GitHub first:</p>
<ol>
<li>In GitHub, create a new repository (<a href="https://github.com/new">https://github.com/new</a>); let's call it online-store. <em>Do not</em> check the <span class="packt_screen">Initialize this repository with a README</span> option. Once created, you will see instructions to add code. Let's go with the option of <span class="packt_screen">push an existing repository from the command line</span> by running the following commands inside our online-store application folder. Do not forget to replace <kbd>&lt;username&gt;</kbd> with your actual GitHub username:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; cd online-store</strong><br/><strong>&gt; git remote add origin https://github.com/&lt;username&gt;/online-store.git</strong><br/><strong>&gt; git push -u origin master</strong></pre>
<ol start="2">
<li>Now go to the Jenkins server web UI by visiting <kbd>http://localhost:8989/</kbd> and create a new job using the <span class="packt_screen"><strong>create new jobs</strong></span> link.</li>
</ol>
<ol start="3">
<li>Enter a name, select <span class="packt_screen">Pipeline</span> from the list, and click <span class="packt_screen">OK</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2e80a96e-257c-42c0-afe3-5098de2242fa.png"/></div>
<ol start="4">
<li>Then, on the next page, do the following:
<ol>
<li>Scroll down or click on the <span class="packt_screen">Build Triggers</span><span> </span>section.</li>
<li>Select the <span class="packt_screen">Poll SCM</span> checkbox.</li>
<li>Enter <span class="packt_screen">H/01 * * * *</span> as the cron schedule value so that Jenkins polls our repository every minute and builds if there are new commits:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/16196b14-9c88-475d-a0b2-ec7e545fd80f.png"/></div>
</li>
</ol>
<ol start="5">
<li>Next, on the same page:
<ol>
<li>Scroll down or click on the <span class="packt_screen">Pipeline</span> section.</li>
<li>Select <span class="packt_screen">Pipeline script from SCM</span> for the <span class="packt_screen">Definition</span> field from the drop-down menu.</li>
<li>Select <span class="packt_screen">Git</span> for the <span class="packt_screen">SCM</span> field from the drop-down menu.</li>
<li>Add the <span class="packt_screen">Repository URL</span> for the application.</li>
<li>Finally, click <span class="packt_screen">S</span><span class="packt_screen"><span class="packt_screen">ave</span></span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><span class="packt_screen"><span class="packt_screen"><img src="assets/7bd7ba52-fc98-4b40-924f-2a5a1bde738e.png" style="text-align: center;font-size: 1em"/></span></span></div>
<ol start="6">
<li>Click on <span class="packt_screen">Build Now</span> to trigger a new build to test our pipeline:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="192" src="assets/f4f6e27f-024e-4e2f-92be-a748bb6dc0fe.png" width="461"/></div>
</li>
</ol>
<p>We should now see a build has started and its progress on the web UI as in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3df6580a-8ea4-44ed-b74f-1289d8bc3377.png"/></div>
<p><span>Congratulations! We have successfully set up CI/CD for our application. The builds will get triggered when you make new commits as well.</span></p>
<p class="mce-root">You can also the view the pipeline status using the new UI from the Jenkins Blue Ocean plugin. Install the plugin from the Plugin Manager (Click on <span class="packt_screen">Jenkins</span> in the top menu and go to <span class="packt_screen">Manage Jenkins</span> | <span class="packt_screen">Manage Plugins</span>  | <span class="packt_screen">Available</span> and search for <kbd>Blue Ocean</kbd> and install it). The <span class="packt_screen">Open Blue Ocean</span> link is available on the left-hand side menu. The builds will look as follows:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/d289958e-4b4b-4fa5-b99d-c75e7030ad27.png"/></div>
<p>Click on a build to view the pipeline. You can click on each stage on the progress indicator to list the steps from that stage, and then expand the list items to view the logs from that step:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/f2e88d7e-18eb-4f74-b4be-89c222a07b61.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at what CI/CD is, and the tools supported by JHipster. We also learned how to set up Jenkins and created our CI/CD pipeline using JHipster and Jenkins. We also fixed our automated tests and made them run on the CI server.</p>
<p>In the next chapter, we will see how to deploy our application to <em>production</em> using a cloud-hosting provider such as Heroku.</p>


            </article>

            
        </section>
    </body></html>