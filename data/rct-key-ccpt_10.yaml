- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Behind the Scenes of React and Optimization Opportunities
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React背后的场景和优化机会
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够做到以下事项：
- en: Avoid unnecessary code execution via the `useMemo()` and `useCallback()` Hooks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`useMemo()`和`useCallback()`钩子避免不必要的代码执行
- en: Load optional code lazily, only when it’s needed, via React’s `lazy()` function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过React的`lazy()`函数按需加载可选代码，仅在需要时
- en: Use React’s developer tools to analyze and optimize your app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React的开发者工具分析和优化你的应用
- en: Explore the React Compiler for automatic performance improvements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索React编译器以实现自动性能提升
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Using all the features covered up to this point, you can build non-trivial React
    apps and therefore highly interactive and reactive UIs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用到目前为止所涵盖的所有功能，你可以构建非平凡的React应用，因此可以构建高度交互和响应式的UI。
- en: This chapter, while introducing some new functions and concepts, will not provide
    you with tools that will enable you to build even more advanced web apps. You
    will not learn about groundbreaking, key concepts such as state or props (though
    you will learn about more advanced concepts in later chapters).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章虽然介绍了一些新的函数和概念，但不会提供让你能够构建更高级Web应用的工具。你将不会学习到像状态或属性这样的突破性、关键概念（尽管你将在后面的章节中学习到更高级的概念）。
- en: Instead, this chapter allows you to look behind the scenes of React. You will
    learn how React calculates required DOM updates, and how it ensures that such
    updates happen without impacting performance in an unacceptable way. You will
    also learn about some other optimization techniques employed by React—all with
    the goal of ensuring that your React app runs as smoothly as possible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，本章让你能够深入了解React背后的场景。你将学习React如何计算所需的DOM更新，以及它是如何确保这些更新不会以不可接受的方式影响性能。你还将了解React使用的其他一些优化技术——所有这些技术都是为了确保你的React应用尽可能流畅地运行。
- en: Besides this look behind the scenes, you will learn about various built-in functions
    and concepts that can be used to further optimize app performance. This chapter
    will not only introduce those concepts but also explain **why** they exist, **how**
    they should be used, and **when** to use which feature.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个幕后场景之外，你还将了解各种内置函数和概念，这些函数和概念可以用来进一步优化应用性能。本章不仅将介绍这些概念，还将解释**为什么**它们存在，**如何**使用它们，以及**何时**使用哪个功能。
- en: Revisiting Component Evaluations and Updates
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视组件评估和更新
- en: Before exploring React’s internal workings, it makes sense to briefly revisit
    React’s logic for executing component functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索React的内部工作原理之前，简要回顾React执行组件函数的逻辑是有意义的。
- en: Component functions are executed whenever some state (managed via `useState()`
    ) changes or their parent component function is executed again. The latter happens
    because, if a parent component function is called, its entire JSX code (which
    points at the child component function) is re-evaluated. Any component functions
    referenced in that JSX code are therefore also invoked again.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 组件函数会在某些状态（通过`useState()`管理）改变或其父组件函数再次执行时执行。后者发生是因为，如果调用父组件函数，其整个JSX代码（指向子组件函数）将被重新评估。因此，在该JSX代码中引用的任何组件函数也将再次被调用。
- en: 'Consider a component structure like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下组件结构：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example structure, the `Parent` component renders a `<div>` with two
    paragraphs, a button, and another component: the `Child` component. That component
    in turn outputs a `<div>` with a paragraph and yet another component: the `NestedChild`
    component (which then only outputs a paragraph).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例结构中，`Parent`组件渲染一个包含两个段落、一个按钮和另一个组件的`<div>`：`Child`组件。该组件随后输出一个包含一个段落和另一个组件的`<div>`：`NestedChild`组件（然后只输出一个段落）。
- en: The `Parent` component also manages some state (a dummy counter), which is changed
    whenever the button is clicked. All three components print a message via `console.log()`
    , simply to make it easy to spot when each component is called by React.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parent`组件还管理一些状态（一个虚拟计数器），每当按钮被点击时，该状态就会改变。所有三个组件通过`console.log()`打印一条消息，只是为了方便在React调用每个组件时识别。'
- en: 'The following screenshot shows those components in action—after the button
    was clicked:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了这些组件在按钮点击后的动作：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_10_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![计算机的截图 自动生成描述](img/B31339_10_01.png)'
- en: 'Figure 10.1: Each component function is executed'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：每个组件函数都会执行
- en: In this screenshot, you can not only see how the components are nested into
    each other but also how they are all invoked by React when the `Increment` button
    is clicked. `Child` and `NestedChild` are invoked even though they don’t manage
    or use any state. But since they are a child ( `Child` ) or descendent ( `NestedChild`
    ) of the `Parent` component, which did receive a state change, the nested component
    functions are called as well.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕截图中，你可以不仅看到组件是如何嵌套在一起的，还可以看到当点击“增加”按钮时，React是如何调用所有组件的。即使“子”和“嵌套子”组件没有管理或使用任何状态，它们也会被调用。但既然它们是“父”组件（`Child`）或后代组件（`NestedChild`），而“父”组件确实接收到了状态变化，因此嵌套的组件函数也会被调用。
- en: Understanding this flow of component function execution is important because
    this flow implies that any component function invocation also influences its descendent
    components. It also shows you how frequently component functions may be invoked
    by React and how many component functions may be affected by a single state change.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 理解组件函数执行流程的重要性在于，这个流程意味着任何组件函数的调用也会影响其子组件。它还展示了React如何频繁地调用组件函数，以及单个状态变化可能影响多少组件函数。
- en: 'Therefore, there’s one important question that should be answered: what happens
    to the actual page DOM (i.e., to the loaded and rendered website in the browser)
    when one or more component functions are invoked? Is the DOM recreated? Is the
    rendered UI updated?'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有一个重要的问题需要回答：当调用一个或多个组件函数时，实际的页面DOM（即浏览器中加载和渲染的网站）会发生什么？DOM是否被重新创建？渲染的UI是否被更新？
- en: What Happens When a Component Function Is Called
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件函数被调用时会发生什么
- en: Whenever a component function is executed, React evaluates whether or not the
    rendered UI (i.e., the DOM of the loaded page) must be updated.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每当组件函数执行时，React都会评估渲染的UI（即加载页面的DOM）是否需要更新。
- en: 'This is important: React **evaluates** whether an update is needed. It’s not
    forcing an update automatically!'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要：React会**评估**是否需要更新。它不会自动强制更新！
- en: Internally, React does not take the JSX code returned by a component (or multiple
    components) and replace the page DOM with it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，React不会用组件（或多个组件）返回的JSX代码替换页面DOM。
- en: That could be done, but it would mean that every component function execution
    would lead to some form of DOM manipulation—even if it’s just a replacement of
    the old DOM content with a new, similar version. In the example shown above, the
    `Child` and `NestedChild` JSX code would be used to replace the currently rendered
    DOM every time those component functions were executed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以做到的，但这意味着每次组件函数执行都会导致某种形式的DOM操作——即使只是用新的、类似的内容替换旧的DOM内容。在上面的示例中，每次执行那些组件函数时，都会使用“子”和“嵌套子”JSX代码来替换当前渲染的DOM。
- en: As you can see in the example above, those component functions are executed
    quite frequently. But the returned JSX code is always the same because it’s static.
    It does not contain any dynamic values (e.g., state or props).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上面的示例中看到的，那些组件函数执行得相当频繁。但返回的JSX代码始终相同，因为它是静态的。它不包含任何动态值（例如状态或属性）。
- en: If the actual page DOM were replaced with the DOM elements implied by the returned
    JSX code, the visual result would always be the same. But there still would be
    some DOM manipulation behind the scenes. And that’s a problem because manipulating
    the DOM is quite a performance-intensive task—especially when done with a high
    frequency. Removing and adding or updating DOM elements should therefore only
    be done when needed—not unnecessarily.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实际的页面DOM被替换为返回JSX代码所表示的DOM元素，视觉结果将始终相同。但幕后仍然会有一些DOM操作。这是一个问题，因为操作DOM是一项性能密集型任务——尤其是在高频操作时。因此，只有在需要时才应该进行DOM的删除、添加或更新——而不是不必要的操作。
- en: Because of this, React does not throw away the current DOM and replace it with
    the new DOM (implied by the JSX code) just because a component function was executed.
    Instead, React first checks whether an update is needed. And if it’s needed, only
    the parts of the DOM that need to change are replaced or updated.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，React不会因为组件函数的执行而丢弃当前的DOM并替换成新的DOM（由JSX代码表示）。相反，React首先检查是否需要更新。如果需要，只有需要更改的DOM部分才会被替换或更新。
- en: To determine whether an update is needed (and where), React uses a concept called
    the **virtual DOM** .
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定是否需要更新（以及在哪里），React使用了一个称为**虚拟DOM**的概念。
- en: The Virtual DOM vs the Real DOM
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟DOM与真实DOM
- en: To determine whether (and where) a DOM update might be needed, React (specifically,
    the `react-dom` package) compares the current DOM structure to the structure implied
    by the JSX code returned by the executed component functions. If there’s a difference,
    the DOM is updated accordingly; otherwise, it’s left untouched.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定是否（以及在哪里）可能需要DOM更新，React（特别是`react-dom`包）将当前DOM结构与由执行组件函数返回的JSX代码隐含的结构进行比较。如果有差异，DOM将相应更新；否则，保持不变。
- en: However, just as manipulating the DOM is relatively performance-intensive, reading
    the DOM is as well. Even without changing anything in the DOM, reaching out to
    it, traversing the DOM elements, and deriving the structure from it is something
    you typically want to reduce to a minimum.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如操作DOM相对性能开销较大一样，读取DOM也是如此。即使不更改DOM中的任何内容，访问它、遍历DOM元素并从中推导结构也是您通常希望减少到最小的事情。
- en: If multiple component functions are executed and each triggers a process where
    the rendered DOM elements are read and compared to the JSX structure implied by
    the invoked component functions, the rendered DOM will be hit with read operations
    multiple times within a very short time frame.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个组件函数被执行，并且每个函数都触发一个过程，其中渲染的DOM元素被读取并与由调用组件函数隐含的JSX结构进行比较，那么在非常短的时间内，渲染的DOM将被多次执行读取操作。
- en: For bigger React apps that are made up of dozens, hundreds, or even thousands
    of components, it’s highly probable that dozens of component function executions
    might occur within a single second. If that were to lead to the same amount of
    DOM read operations, there’s a quite high chance that the web app would feel slow
    or laggy to the user.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于由数十、数百甚至数千个组件组成的较大React应用，在单个秒内可能发生数十次组件函数执行的可能性非常高。如果这导致相同数量的DOM读取操作，那么web应用对用户来说可能会感觉缓慢或滞后。
- en: That’s why React does not use the real DOM to determine whether any UI updates
    are needed. Instead, it constructs and manages a virtual DOM internally—an in-memory
    representation of the DOM that’s rendered in the browser. The virtual DOM is not
    a browser feature, but a React feature. You can think of it as a deeply nested
    JavaScript object that reflects the components of your web app, including all
    the built-in HTML components such as `<div>` , `<p>` , etc. (that is, the actual
    HTML elements that should show up on the page in the end).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么React不使用真实DOM来确定是否需要任何UI更新。相反，它内部构建并管理一个虚拟DOM——这是在浏览器中渲染的DOM的内存表示。虚拟DOM不是浏览器功能，而是React功能。您可以将它想象为一个深度嵌套的JavaScript对象，它反映了您的web应用的组件，包括所有内置的HTML组件，如`<div>`、`<p>`等。（即最终应在页面上显示的实际HTML元素）。
- en: '![A diagram of a computer program  Description automatically generated](img/B31339_10_02.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序图  自动生成描述](img/B31339_10_02.png)'
- en: 'Figure 10.2: React manages a virtual representation of the expected element
    structure'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：React管理预期元素结构的虚拟表示
- en: In the figure above, you can see that the expected element structure (in other
    words, the expected final DOM) is actually stored as a JavaScript object (or an
    array with a list of objects). This is the virtual DOM, which is managed by React
    and used for identifying required DOM updates.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的图中，您可以看到预期的元素结构（换句话说，预期的最终DOM）实际上存储为一个JavaScript对象（或一个包含对象列表的数组）。这是虚拟DOM，由React管理并用于识别所需的DOM更新。
- en: '**Note**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Please note that the actual structure of the virtual DOM is more complex than
    the structure shown in the image. The chart above aims to give you an idea of
    what the virtual DOM is and how it might look. It’s not an exact technical representation
    of the JavaScript data structure managed by React.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虚拟DOM的实际结构比图中显示的结构更复杂。上面的图表旨在让您了解虚拟DOM是什么以及它可能看起来像什么。它不是React管理的JavaScript数据结构的精确技术表示。
- en: React manages this virtual DOM because comparing this virtual DOM to the expected
    UI state is much less performance-intensive than reaching out to the real DOM.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: React管理这个虚拟DOM，因为将这个虚拟DOM与预期的UI状态进行比较，比访问真实DOM要少得多，性能开销更小。
- en: Whenever a component function is called, React compares the returned JSX code
    to the respective virtual DOM nodes stored in the virtual DOM. If differences
    are detected, React will determine which changes are needed to update the DOM.
    Once the required adjustments are derived, these changes are applied to both the
    virtual and the real DOM. This ensures that the real DOM reflects the expected
    UI state without having to reach out to it or update it all the time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用组件函数时，React会将返回的JSX代码与虚拟DOM中存储的相关虚拟DOM节点进行比较。如果检测到差异，React将确定需要更新的DOM更改。一旦推导出所需的调整，这些更改将应用于虚拟和真实DOM。这确保了真实DOM反映了预期的UI状态，而无需不断访问或更新它。
- en: '![A diagram of a computer program  Description automatically generated](img/B31339_10_03.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序图  自动生成的描述](img/B31339_10_03.png)'
- en: 'Figure 10.3: React detects required updates via the virtual DOM'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：React通过虚拟DOM检测所需的更新
- en: In the figure above, you can see how React compares the current DOM and the
    expected structure with the help of the virtual DOM first, before reaching out
    to the real DOM to manipulate it accordingly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的图中，你可以看到React如何首先使用虚拟DOM比较当前的DOM和预期的结构，然后再去操作真实的DOM。
- en: As a React developer, you don’t need to actively interact with the virtual DOM.
    Technically, you don’t even need to know that it exists and that React uses it
    internally. But it’s always helpful to understand the tool (React, in this case)
    you’re working with. It’s good to know that React does various performance optimizations
    for you and that you get those on top of the many other features that make your
    life as a developer (hopefully) easier.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为React开发者，你不需要主动与虚拟DOM交互。技术上，你甚至不需要知道它的存在以及React在内部使用它。但了解你正在使用的工具（在这种情况下是React）总是有帮助的。了解React为你做了各种性能优化，并且你可以在许多其他使你的开发者生活（希望）更轻松的功能之上获得这些优化，这是很好的。
- en: State Batching
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态批处理
- en: Since React uses the concept of a virtual DOM, frequent component function executions
    aren’t a huge problem. But of course, even if comparisons are only conducted virtually,
    there is still some internal code that must be executed. Even with the virtual
    DOM, performance could degrade if lots of unnecessary (and at the same time quite
    complex) virtual DOM comparisons must be made.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于React使用虚拟DOM的概念，频繁的组件函数执行并不是一个大问题。但当然，即使比较是在虚拟层面上进行的，仍然有一些内部代码必须执行。即使在虚拟DOM的情况下，如果必须进行大量的不必要的（同时相当复杂的）虚拟DOM比较，性能可能会下降。
- en: One scenario where unnecessary comparisons are performed is in the execution
    of multiple sequential state updates. Since each state update causes the component
    function to be executed again (as well as all potential nested components), multiple
    state updates that are performed together (for example, in the same event handler
    function) will cause multiple component function invocations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行多个连续状态更新时，进行不必要的比较的一个场景是。由于每个状态更新都会导致组件函数再次执行（以及所有潜在的嵌套组件），一起执行（例如，在同一个事件处理函数中）的多个状态更新将导致多次组件函数调用。
- en: 'Consider this example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This component contains two state values: `counter` and `showCounter` . When
    the button is clicked, the counter is incremented by `1` . In addition, `showCounter`
    is set to `true` . Therefore, the first time the button is clicked, both the `counter`
    and the `showCounter` states are changed (because `showCounter` is `false` initially).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件包含两个状态值：`counter`和`showCounter`。当按钮被点击时，计数器增加`1`。此外，`showCounter`被设置为`true`。因此，第一次点击按钮时，`counter`和`showCounter`状态都会发生变化（因为`showCounter`最初为`false`）。
- en: Since two state values are changed, the expectation would be that the `App`
    component function is called twice by React—because every state update causes
    the connected component function to be invoked again.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有两个状态值被更改，预期React会调用`App`组件函数两次——因为每次状态更新都会导致连接的组件函数再次被调用。
- en: 'However, if you add a `console.log()` statement to the `App` component function
    (to track how often it’s executed), you will see that it’s only invoked once,
    when the `Increment` button is clicked:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你在`App`组件函数中添加一个`console.log()`语句（用于跟踪其执行频率），你会看到它只被调用一次，当点击`Increment`按钮时：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_10_04.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  自动生成的描述](img/B31339_10_04.png)'
- en: 'Figure 10.4: Only one console log message is displayed'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：只显示一条控制台日志消息
- en: '**Note**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: If you see two log messages instead of one, make sure you’re not using React’s
    “Strict Mode.” When running in Strict Mode during development, React executes
    component functions more often than it normally would.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到两条日志消息而不是一条，请确保你没有使用 React 的“严格模式”。在开发期间运行严格模式时，React 会比通常情况下更频繁地执行组件函数。
- en: If necessary, you can disable Strict Mode by removing the `<React.StrictMode>`
    component from your `main.jsx` file. You will learn more about React’s Strict
    Mode toward the end of this chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以通过从你的 `main.jsx` 文件中移除 `<React.StrictMode>` 组件来禁用严格模式。你将在本章的末尾了解更多关于
    React 严格模式的内容。
- en: This behavior is called **state batching** . React performs state batching when
    multiple state updates are initiated from the same place in your code (e.g., from
    inside the same event handler function).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为被称为 **状态批处理**。当你的代码中的同一位置（例如，在同一个事件处理函数内部）发起多个状态更新时，React 会执行状态批处理。
- en: It’s a built-in functionality that ensures that your component functions are
    not called more often than needed. This prevents unnecessary virtual DOM comparisons.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个内置的功能，确保你的组件函数不会被调用得比需要的更频繁。这防止了不必要的虚拟 DOM 比较。
- en: 'State batching is a very useful mechanism. But there is another kind of unnecessary
    component evaluation that it does not prevent: child component functions that
    get executed when the parent component function is called.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 状态批处理是一个非常有用的机制。但是，它无法防止另一种不必要的组件评估：当父组件函数被调用时执行的子组件函数。
- en: Avoiding Unnecessary Child Component Evaluations
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免不必要的子组件评估
- en: Whenever a component function is invoked (because its state changed, for example),
    any nested component functions will be called as well. See the first section of
    this chapter for more details.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每当组件函数被调用（例如，因为其状态改变），任何嵌套的组件函数也将被调用。请参阅本章的第一部分以获取更多详细信息。
- en: As you saw in the example in the first section of this chapter, it is often
    the case that those nested components don’t actually need to be evaluated again.
    They might not depend on the state value that changed in the parent component.
    They might not even depend on any values of the parent component at all.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章第一部分的例子中所看到的，通常情况下，那些嵌套的组件实际上并不需要再次评估。它们可能不依赖于父组件中改变的状态值。它们甚至可能不依赖于父组件的任何值。
- en: 'Here’s an example where the parent component function contains some state that
    is not used by the child component:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，其中父组件函数包含一些子组件不使用的状态：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Note**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the complete example code on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/examples/03-memo](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/examples/03-memo)
    .
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到完整的示例代码：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/examples/03-memo](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/examples/03-memo)。
- en: In this example, the `Error` component relies on the `message` prop, which is
    set to the value stored in the `errorMessage` state of the `Form` component. However,
    the `Form` component also manages an `enteredEmail` state, which is not used (not
    received via props) by the `Error` component. Therefore, changes to the `enteredEmail`
    state will cause the `Error` component to be executed again, despite the component
    not needing that value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Error` 组件依赖于 `message` 属性，该属性设置为 `Form` 组件中 `errorMessage` 状态存储的值。然而，`Form`
    组件还管理一个 `enteredEmail` 状态，该状态没有被 `Error` 组件使用（未通过属性接收）。因此，`enteredEmail` 状态的更改将导致
    `Error` 组件再次执行，尽管该组件不需要那个值。
- en: 'You can track the unnecessary `Error` component function invocations by adding
    a `console.log()` statement to that component function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向该组件函数添加 `console.log()` 语句来跟踪不必要的 `Error` 组件函数调用：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_10_05.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B31339_10_05.png)'
- en: 'Figure 10.5: The Error component function is executed for every keystroke'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5：`Error` 组件函数在输入字段上的每次按键都会执行
- en: In the preceding screenshot, you can see that the `Error` component function
    is executed for every keystroke on the input field (that is, once for every `enteredEmail`
    state change).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到 `Error` 组件函数在输入字段上的每次按键都会执行（即，每次 `enteredEmail` 状态改变时执行一次）。
- en: This is in line with what you have learned previously, but it is also unnecessary.
    The `Error` component does depend on the `errorMessage` state and should certainly
    be re-evaluated whenever that state changes, but executing the `Error` component
    function because the `enteredEmail` state value was updated is clearly not required.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前你所学的相符，但这也是不必要的。`Error`组件确实依赖于`errorMessage`状态，并且每当该状态发生变化时，都应该重新评估该组件，但显然不需要因为`enteredEmail`状态值更新而执行`Error`组件函数。
- en: 'That’s why React offers another built-in function that you can use to control
    (and prevent) this behavior: the `memo()` function.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，React提供了一个内置的函数，你可以用它来控制（并防止）这种行为：`memo()`函数。
- en: '`memo` is imported from `react` and is used like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`memo`是从`react`导入的，并像这样使用：'
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You wrap the component function that should be protected from unnecessary, parent-initiated
    re-evaluations with `memo()` . This causes React to check whether the component’s
    props did change, compared to the last time the component function was called.
    If prop values are equal, React knows that the component function does not need
    to be executed again.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你用`memo()`包裹应该避免不必要的、由父组件触发的重新评估的组件函数。这会导致React检查组件的props是否与上一次调用组件函数时有所不同。如果prop值相等，React知道组件函数不需要再次执行。
- en: 'By adding `memo()` , the unnecessary component function invocations are avoided,
    as shown below:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`memo()`，可以避免不必要的组件函数调用，如下所示：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_10_06.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  自动生成的描述](img/B31339_10_06.png)'
- en: 'Figure 10.6: No console log messages appear'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：控制台没有出现日志消息
- en: 'As you can see in the figure, no messages are printed to the console. This
    proves that unnecessary component executions are avoided (remember: before adding
    `memo()` , many messages were printed to the console).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，没有消息打印到控制台。这证明了避免了不必要的组件执行（记住：在添加`memo()`之前，许多消息都打印到了控制台）。
- en: '`memo()` also takes an optional second argument that can be used to add your
    own logic to determine whether prop values have changed or not. This can be useful
    if you’re dealing with more complex prop values (e.g., objects or arrays) where
    custom comparison logic might be needed, as in the following example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`memo()`还接受一个可选的第二个参数，可以用来添加自己的逻辑以确定prop值是否已更改。如果你处理的是更复杂的prop值（例如，对象或数组），并且可能需要自定义比较逻辑，这可能会很有用，如下面的示例所示：'
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The (optional) second argument passed to `memo()` must be a function that automatically
    receives the previous props object and the next props object. The function then
    must return `true` if the component ( `SomeComponent` , in this example) should
    be re-evaluated and `false` if it should not.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`memo()`的（可选）第二个参数必须是一个函数，该函数自动接收前一个props对象和下一个props对象。然后，该函数必须返回`true`，如果组件（例如，本例中的`SomeComponent`）应该重新评估，如果不应重新评估则返回`false`。
- en: Often, the second argument is not needed because the default behavior of `memo()`
    (where it compares all props for inequality) is exactly what you need. But if
    more customization or control is needed, `memo()` allows you to add your custom
    logic.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，第二个参数是不需要的，因为`memo()`的默认行为（比较所有props的不等性）正是你所需要的。但如果需要更多的定制或控制，`memo()`允许你添加自己的逻辑。
- en: With `memo()` in your toolbox, it’s tempting to wrap every React component function
    with `memo()` . Why wouldn’t you do it? After all, it avoids unnecessary component
    function executions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的工具箱中有`memo()`后，你会倾向于用`memo()`包裹每一个React组件函数。为什么不这样做呢？毕竟，它避免了不必要的组件函数执行。
- en: 'You definitely can use it on all components—but it’s not necessarily helpful
    to do that because avoiding unnecessary component re-evaluations by using `memo()`
    comes at a cost: comparing props (old versus new) also requires some code to run.
    It’s not “free.” It’s not a huge cost, though. Using `memo()` on many (or all)
    components will likely not slow down your app significantly. But it’s still unnecessary
    if you have components that do need to be re-evaluated a lot. Using `memo()` on
    components that receive props that change a lot simply does not do anything useful.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以在所有组件上使用它——但这并不一定有帮助，因为使用`memo()`避免不必要的组件重新评估是有代价的：比较props（旧值与新值）也需要运行一些代码。它不是“免费的”。但这并不是一个巨大的成本。在许多（或所有）组件上使用`memo()`可能不会显著减慢你的应用程序。但如果你有需要大量重新评估的组件，这仍然是多余的。对于接收大量变化的props的组件使用`memo()`没有任何实际作用。
- en: Hence `memo()` makes the most sense if you have relatively simple props (i.e.,
    props with no deeply nested objects that you need to compare manually with a custom
    comparison function) and most parent component state changes don’t affect those
    props of the child component. And even in those cases, if you have a relatively
    simple component function (i.e., without any complex logic in it), using `memo()`
    still might not yield any measurable benefit.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你有相对简单的属性（即没有需要手动与自定义比较函数比较的深度嵌套对象的属性）并且大多数父组件的状态变化不会影响这些子组件的属性，那么 `memo()`
    就非常有意义。即使在那些情况下，如果你有一个相对简单的组件函数（即没有复杂逻辑的函数），使用 `memo()` 仍然可能不会带来任何可衡量的好处。
- en: 'The example code above (the `Error` component) is a good example: in theory,
    using `memo()` makes sense here. Most state changes in the parent component won’t
    affect `Error` , and the prop comparison will be very simple because it’s just
    one prop (the `message` prop, which holds a string) that must be compared. But
    despite that, using `memo()` to wrap `Error` will very likely not be worth it.
    `Error` is an extremely basic component with no complex logic in it. It simply
    doesn’t matter if the component function gets invoked frequently. Hence, using
    `memo()` in this spot would be absolutely fine—but so is not using it.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例代码（`Error` 组件）是一个很好的例子：从理论上讲，在这里使用 `memo()` 是有意义的。父组件中的大多数状态变化不会影响 `Error`，而且属性比较将会非常简单，因为它只涉及一个属性（`message`
    属性，它包含一个字符串）需要比较。但尽管如此，使用 `memo()` 包装 `Error` 很可能并不值得。`Error` 是一个非常基础的组件，其中没有任何复杂的逻辑。如果组件函数频繁调用，这根本无关紧要。因此，在这个位置使用
    `memo()` 完全是可以接受的——同样，不使用它也是可以的。
- en: 'A great spot to use `memo()` , on the other hand, is a component that’s relatively
    close to the top of the component tree (or of a deeply nested branch of components
    in the component tree). If you are able to avoid unnecessary executions of that
    one component via `memo()` , you’ll also implicitly avoid unnecessary executions
    of all nested components beneath that one component. This is illustrated in the
    diagram below:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常适合使用 `memo()` 的地方是位于组件树顶部（或组件树中深度嵌套的组件分支）的组件。如果你能够通过 `memo()` 避免执行该组件的不必要调用，那么你也会隐式地避免执行该组件下所有嵌套组件的不必要调用。这一点在下图中得到了说明：
- en: '![img](img/B31339_10_07.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_10_07.png)'
- en: 'Figure 10.7: Using memo at the start of a component tree branch'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：在组件树分支的起始处使用 `memo()`
- en: In the preceding figure, `memo()` is used on the `Shop` component, which has
    multiple nested descendent components. Without `memo()` , whenever the `Shop`
    component function gets invoked, `Products` , `ProdItem` , `Cart` , etc. would
    also be executed. With `memo()` , assuming that it’s able to avoid some unnecessary
    executions of the `Shop` component function, all those descendent components are
    no longer evaluated.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，`memo()` 被用于 `Shop` 组件，它有多个嵌套的子组件。没有 `memo()` 的情况下，每当 `Shop` 组件函数被调用时，`Products`、`ProdItem`、`Cart`
    等也会被执行。有了 `memo()`，假设它能够避免一些 `Shop` 组件函数的不必要调用，所有这些子组件就不再需要评估。
- en: Avoiding Costly Computations
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免昂贵的计算
- en: The `memo()` function can help avoid unnecessary component function executions.
    As mentioned in the previous section, this is especially valuable if a component
    function performs a lot of work (e.g., sorting a long list).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`memo()` 函数可以帮助避免不必要的组件函数执行。正如前文所述，如果组件函数执行了大量工作（例如，对长列表进行排序），这一点尤其有价值。'
- en: But as a React developer, you will also encounter situations in which you have
    a work-intensive component that needs to be executed again because some prop value
    changed. In such cases, using `memo()` won’t prevent the component function from
    executing again. However, the prop that changed might not be needed for the performance-intensive
    task that is performed as part of the component.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但作为一个 React 开发者，你也会遇到一些情况，其中你有一个需要因为某些属性值变化而再次执行的工作密集型组件。在这种情况下，使用 `memo()`
    无法阻止组件函数再次执行。然而，变化的属性可能并不需要用于组件中作为性能密集型任务执行的部分。
- en: 'Consider the following example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `List` component receives two prop values: `items` and `maxNumber` . It
    then calls `sortItems()` to sort the items by `id` . Thereafter, the sorted list
    is limited to a certain amount ( `maxNumber` ) of items. As a last step, the sorted
    and shortened list is then rendered to the screen via `map()` in the JSX code.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`组件接收两个prop值：`items`和`maxNumber`。然后它调用`sortItems()`按`id`对项目进行排序。之后，排序后的列表限制为一定数量的项目（`maxNumber`）。最后一步，通过JSX代码中的`map()`将排序和缩短后的列表渲染到屏幕上。'
- en: '**Note**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: A full example app can be found on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/examples/04-usememo](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/examples/04-usememo)
    .
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的示例应用程序可以在GitHub上找到，地址为[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/examples/04-usememo](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/examples/04-usememo)。
- en: Depending on the number of items passed to the `List` component, sorting it
    can take a significant amount of time (for very long lists, even up to a few seconds).
    It’s definitely not an operation you want to perform unnecessarily or too frequently.
    The list needs to be sorted whenever `items` changes, but it should not be sorted
    if `maxNumber` changes—because this does not impact the items in the list (i.e.,
    it doesn’t affect the order). But with the code snippet shared above, `sortItems()`
    will be executed whenever either of the two prop values changes, no matter whether
    it’s `items` or `maxNumber` .
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 根据传递给`List`组件的项目数量，排序可能需要相当长的时间（对于非常长的列表，甚至可能长达几秒钟）。这绝对不是你希望不必要或过于频繁执行的操作。每当`items`发生变化时，都需要对列表进行排序，但如果`maxNumber`发生变化，则不应进行排序——因为这不影响列表中的项目（即，不影响顺序）。但是，根据上面共享的代码片段，`sortItems()`将在两个prop值中的任何一个发生变化时执行，无论它是`items`还是`maxNumber`。
- en: As a result, when running the app and changing the number of displayed items,
    you can see multiple `"Sorting"` log messages—implying that `sortItems()` was
    executed every time the number of items was changed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当运行应用程序并更改显示的项目数量时，你可以看到多个`"Sorting"`日志消息——这意味着每次更改项目数量时都会执行`sortItems()`。
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_10_08.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B31339_10_08.png)'
- en: 'Figure 10.8: Multiple “Sorting” log messages appear in the console'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：控制台中出现多个“Sorting”日志消息
- en: The `memo()` function won’t help here because the `List` component function
    should (and will) execute whenever `items` or `maxNumber` changes. `memo()` does
    not help control partial code execution inside the component function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`memo()`函数在这里无济于事，因为`List`组件函数应该在（并且将会）`items`或`maxNumber`发生变化时执行。`memo()`不能帮助控制组件函数内部的局部代码执行。'
- en: 'For that, you can use another feature provided by React: the `useMemo()` Hook.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你可以使用React提供的另一个功能：`useMemo()` Hook。
- en: '`useMemo()` can be used to wrap a compute-intensive operation. For it to work
    correctly, you also must define a list of dependencies that should cause the operation
    to be executed again. To some extent, it’s similar to `useEffect()` (which also
    wraps an operation and defines a list of dependencies), but the key difference
    is that `useMemo()` runs at the same time as the rest of the code in the component
    function, whereas `useEffect()` executes the wrapped logic after the component
    function execution has finished. `useEffect()` should not be used for optimizing
    compute-intensive tasks but for side effects.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo()`可以用来包装计算密集型操作。为了正确工作，你还必须定义一个列表，其中包含应导致操作再次执行依赖项。在某种程度上，它与`useEffect()`（它也包装操作并定义依赖项列表）类似，但关键区别在于`useMemo()`与组件函数中的其余代码同时运行，而`useEffect()`在组件函数执行完成后执行包装逻辑。不应使用`useEffect()`来优化计算密集型任务，而应用于副作用。'
- en: '`useMemo()` , on the other hand, exists to control the execution of performance-intensive
    tasks. Applied to the example mentioned above, the code can be adjusted like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`useMemo()`存在是为了控制性能密集型任务的执行。应用于上述示例，代码可以调整如下：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`useMemo()` wraps an anonymous function (the function that previously existed
    as a named function, `sortItems` ), which contains the entire sorting code. The
    second argument passed to `useMemo()` is the array of dependencies for which the
    function should be executed again (when a dependency value changes). In this case,
    `items` is the only dependency of the wrapped function, and so that value is added
    to the array.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo()` 包装了一个匿名函数（之前作为命名函数 `sortItems` 存在的函数），其中包含整个排序代码。传递给 `useMemo()`
    的第二个参数是函数应再次执行的依赖项数组（当依赖项值发生变化时）。在这种情况下，`items` 是包装函数的唯一依赖项，因此该值被添加到数组中。'
- en: 'With `useMemo()` used like this, the sorting logic will only execute when items
    change, not when `maxNumber` (or anything else) changes. As a result, you see
    `"` `Sorting"` being output in the developer tools console only once:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `useMemo()` 如此，排序逻辑仅在项目发生变化时执行，而不是在 `maxNumber`（或任何其他内容）发生变化时执行。因此，你会在开发者工具控制台中只看到一次输出“`Sorting`”：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_10_09.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B31339_10_09.png)'
- en: 'Figure 10.9: Only one “Sorting” output in the console'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9：控制台只有一个“排序”输出
- en: '`useMemo()` can be very useful for controlling code execution inside of your
    component functions. It can be a great addition to `memo()` (which controls the
    overall component function execution). But, also like `memo()` , you should not
    start wrapping all your logic with `useMemo()` . Only use it for very performance-intensive
    computations since checking for dependency changes and storing and retrieving
    past computation results (which `useMemo()` does internally) also comes at a performance
    cost.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo()` 在控制组件函数内部的代码执行方面非常有用。它可以作为 `memo()`（控制整体组件函数执行）的一个很好的补充。但是，就像 `memo()`
    一样，你不应该开始用 `useMemo()` 包装所有的逻辑。仅在使用非常性能密集的计算时使用它，因为检查依赖项变化以及存储和检索过去计算结果（`useMemo()`
    内部执行的操作）也会带来性能成本。'
- en: Utilizing useCallback()
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用 `useCallback()`
- en: In the previous chapters, you learned about `useCallback()` . Just like `useMemo()`
    can be used for “expensive” calculations, `useCallback()` can be used to prevent
    unnecessary function re-creations. In the context of this chapter, `useCallback()`
    can be helpful because, in conjunction with `memo()` or `useMemo()` , it can help
    you avoid unnecessary code execution. It can help you in cases where a function
    is passed as a prop (i.e., where you might use `memo()` ) or is used as a dependency
    in some “expensive” computation (i.e., possibly solved via `useMemo()` ).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了关于 `useCallback()` 的内容。就像 `useMemo()` 可以用于“昂贵”的计算一样，`useCallback()`
    可以用来防止不必要的函数重新创建。在本章的上下文中，`useCallback()` 可能很有帮助，因为与 `memo()` 或 `useMemo()` 结合使用时，它可以帮助你避免不必要的代码执行。它可以帮助你处理函数作为属性传递的情况（即你可能使用
    `memo()` 的情况）或作为某些“昂贵”计算中的依赖项（即可能通过 `useMemo()` 解决）。
- en: 'Here’s an example where `useCallback()` can be combined with `memo()` to prevent
    unnecessary component function executions:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，说明 `useCallback()` 可以与 `memo()` 结合使用，以防止不必要的组件函数执行：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Error` component is wrapped with the `memo()` function and so will only
    execute if one of the received prop values changes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error` 组件被 `memo()` 函数包装，因此只有在接收到的属性值之一发生变化时才会执行。'
- en: 'The `Error` component is used by another component, the `Form` component, like
    this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error` 组件被另一个组件，即 `Form` 组件，这样使用：'
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this component, the `Error` component receives a pointer to the `handleClearError`
    function (as a value for the `onClearError` prop). You might recall a very similar
    example from earlier in this chapter (from the *Avoiding Unnecessary Child Component
    Evaluations* section). There, `memo()` was used to ensure that the `Error` component
    function was not invoked when `enteredEmail` changed (because its value was not
    used in the `Error` component function at all).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中，`Error` 组件接收对 `handleClearError` 函数的指针（作为 `onClearError` 属性的值）。你可能还记得本章早期（在
    *避免不必要的子组件评估* 部分中）的一个非常类似的例子。在那里，`memo()` 被用来确保当 `enteredEmail` 发生变化时，`Error`
    组件函数不会被调用（因为它的值在 `Error` 组件函数中根本未使用）。
- en: Now, with the adjusted example and the `handleClearError` function pointer passed
    to `Error` , `memo()` unfortunately isn’t preventing component function executions
    anymore. Why? Because functions are objects in JavaScript and the `handleClearError`
    function is recreated every time the `Form` component function is executed (which
    happens on every state change, including changes to the `enteredEmail` state).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着调整后的示例和将 `handleClearError` 函数指针传递给 `Error`，`memo()` 很遗憾不再阻止组件函数的执行了。为什么？因为在
    JavaScript 中，函数是对象，而 `handleClearError` 函数在每次 `Form` 组件函数执行时都会被重新创建（这发生在每次状态变化时，包括
    `enteredEmail` 状态的变化）。
- en: Since a new function object is created for every state change, `handleClearError`
    is technically a different value for every execution of the `Form` component.
    Therefore, the `Error` component receives a new `onClearError` prop value whenever
    the `Form` component function is invoked. To `memo()` , the old and new `handleClearError`
    function objects are different from each other, and it therefore will not stop
    the `Error` component function from running again.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每次状态变化都会创建一个新的函数对象，因此 `handleClearError` 在技术上对于 `Form` 组件的每次执行都是一个不同的值。因此，每当
    `Form` 组件函数被调用时，`Error` 组件都会接收到一个新的 `onClearError` 属性值。对于 `memo()` 来说，旧的和新旧的 `handleClearError`
    函数对象是不同的，因此它不会阻止 `Error` 组件函数再次运行。
- en: 'That’s exactly where `useCallback()` can help:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 `useCallback()` 可以帮助的地方：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By wrapping `handleClearError` with `useCallback()` , the re-creation of the
    function is prevented, and so no new function object is passed to the `Error`
    component. Hence, `memo()` is able to detect equality between the old and new
    `onClearError` prop value and prevents unnecessary function component executions
    again.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `useCallback()` 包装 `handleClearError`，可以防止函数的重新创建，因此不会将新的函数对象传递给 `Error`
    组件。因此，`memo()` 能够检测旧的和新的 `onClearError` 属性值之间的相等性，并再次防止不必要的函数组件执行。
- en: Similarly, `useCallback()` can be used in conjunction with `useMemo()` . If
    the compute-intensive operation wrapped with `useMemo()` uses a function as a
    dependency, you can use `useCallback()` to ensure that this dependent function
    is not recreated unnecessarily.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`useCallback()` 可以与 `useMemo()` 结合使用。如果 `useMemo()` 包装的计算密集型操作使用函数作为依赖项，你可以使用
    `useCallback()` 来确保这个依赖函数不会被不必要地重新创建。
- en: Using the React Compiler
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 React 编译器
- en: Considering and using `memo()` , `useMemo()` , and `useCallback()` to prevent
    unnecessary component re-evaluations can be a chore. Even though performance optimization
    is important, as a React developer, you typically want to focus on building great
    UIs and implementing helpful features in them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑和使用 `memo()`、`useMemo()` 和 `useCallback()` 来防止不必要的组件重新评估可能是一项繁琐的工作。尽管性能优化很重要，但作为一名
    React 开发者，你通常希望专注于构建出色的 UI 并在其中实现有用的功能。
- en: That’s why the React team developed a compiler that aims to optimize code for
    you – a standalone tool that can be added to React projects that will automatically
    wrap your components with `memo()` , use `useMemo()` when needed, and wrap functions
    with `useCallback()` .
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因此，React 团队开发了一个旨在为你优化代码的编译器——一个可以添加到 React 项目中的独立工具，该工具将自动使用 `memo()` 包装你的组件，在需要时使用
    `useMemo()`，并使用 `useCallback()` 包装函数。
- en: Therefore, when using this compiler, you don’t have to think about or use these
    optimization functions and Hooks anymore.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当使用此编译器时，你不必再考虑或使用这些优化函数和 Hook 了。
- en: In other words, the React compiler will optimize your code for you. At least,
    that’s the theory.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，React 编译器会为你优化代码。至少，这是理论上的。
- en: However, at the time of writing, this compiler is only available in experimental
    mode. This means that you shouldn’t use it for production and that there may be
    bugs or suboptimal compilation results.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在撰写本文时，此编译器仅以实验模式提供。这意味着你不应该将其用于生产，并且可能存在错误或次优编译结果。
- en: Nonetheless, you can give it a try when working on a project that uses React
    19 or higher (the compiler won’t work with older React versions).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，你可以在使用 React 19 或更高版本的项目上尝试它（编译器不适用于旧版本的 React）。
- en: 'Adding the compiler to a project is easy since it’s just an extra dependency
    that must be installed in your project:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将编译器添加到项目中很容易，因为它只是一个额外的依赖项，必须在你的项目中安装：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Note**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Since the compiler is not stable yet, it’s possible that installation steps
    and usage instructions will change over time.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器尚未稳定，安装步骤和使用说明可能会随时间而变化。
- en: 'Therefore, you should visit the official React compiler documentation page
    for the latest details and instructions: [https://react.dev/learn/react-compiler](https://react.dev/learn/react-compiler)
    .'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你应该访问官方React编译器文档页面以获取最新细节和说明：[https://react.dev/learn/react-compiler](https://react.dev/learn/react-compiler)。
- en: 'With the compiler plugin installed, you must adjust your build process configuration
    such that the compiler is used. When working on a Vite-based project, you just
    have to edit the `vite.config.js` file, which should exist in your root project
    folder:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了编译器插件后，你必须调整你的构建过程配置，以便使用编译器。当在一个基于Vite的项目上工作时，你只需编辑`vite.config.js`文件，该文件应位于你的根项目文件夹中：
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you’re using another project setup, you can follow the installation instructions
    on the official compiler documentation page.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是其他项目设置，可以遵循官方编译器文档页面上的安装说明。
- en: With the compiler installed, it will automatically be executed to analyze and
    adjust your code to include optimizations like `memo()` or `useMemo()` . Keep
    in mind that those optimizations are performed as part of the build process that’s
    invoked by running `npm run dev` or `npm run build` . Therefore, your original
    source code will not change—instead, the compiler optimizes your code *“behind
    the scenes.”*
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了编译器后，它将自动执行以分析和调整你的代码，包括`memo()`或`useMemo()`等优化。请记住，这些优化是在运行`npm run dev`或`npm
    run build`触发的构建过程中执行的。因此，你的原始源代码不会改变——相反，编译器会在幕后优化你的代码。
- en: Once the React compiler is stable, it will very likely be a standard tool that’s
    part of every React project’s build process. Therefore, you won’t have to use
    `memo()` , `useMemo()` , or `useCallback()` manually in your code anymore. But
    until that’s the case, or in React projects that can’t use the compiler, you’ll
    still have to optimize the code manually.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦React编译器稳定，它很可能成为每个React项目构建过程的一部分的标准工具。因此，你将不再需要在代码中手动使用`memo()`、`useMemo()`或`useCallback()`。但在那之前，或者在无法使用编译器的React项目中，你仍然需要手动优化代码。
- en: Avoiding Unnecessary Code Download
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免不必要的代码下载
- en: Thus far, this chapter has mostly discussed strategies for avoiding unnecessary
    code execution. But it’s not just the execution of code that can be an issue.
    It’s also not great if your website visitors have to download lots of code that
    might never be executed at all. Because every kilobyte of JavaScript code that
    has to be downloaded will slow down the initial loading time of your web page—not
    just because of the time it takes to download the code bundle (which can be significant,
    if users are on a slow network and code bundles are big) but also because the
    browser has to parse all the downloaded code before your page becomes interactive.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这一章主要讨论了避免不必要的代码执行的战略。但问题不仅在于代码的执行。如果你的网站访客需要下载大量可能根本不会执行的代码，那也不是什么好事。因为每下载一千字节JavaScript代码都会减慢你网页的初始加载时间——这不仅是因为下载代码包所需的时间（如果用户在慢速网络且代码包很大，这可能会非常显著），而且因为浏览器必须在你的页面变得交互之前解析所有下载的代码。
- en: For this reason, a lot of community and ecosystem effort is spent on reducing
    JavaScript code bundle sizes. Minification (automatic shortening of variable names
    and other measures to reduce the final code) and compression can help a lot and
    is therefore a common technique. Actually, projects created with Vite already
    come with a build workflow (initiated by running `npm run build` ), which will
    produce a production-optimized code bundle that is as small as possible.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，社区和生态系统投入了大量努力来减少JavaScript代码包的大小。最小化（自动缩短变量名和其他减少最终代码的措施）和压缩可以极大地帮助，因此这是一种常见的技巧。实际上，使用Vite创建的项目已经自带了构建工作流程（通过运行`npm
    run build`启动），这将生成尽可能小的生产优化代码包。
- en: 'But there also are steps that can be taken by you, the developer, to reduce
    the overall code bundle size:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但你也可以采取一些步骤来减少整体代码包的大小：
- en: Try to write short and concise code.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽量编写简短和简洁的代码。
- en: Be thoughtful about including third-party libraries and don’t use them unless
    you really need to.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含第三方库时要深思熟虑，除非你真的需要，否则不要使用它们。
- en: Consider using code-splitting techniques.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑使用代码拆分技术。
- en: The first point should be fairly obvious. If you write less code, your website
    visitors have less code to download. Therefore, trying to be concise and write
    optimized code makes sense.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点应该是相当明显的。如果你写的代码越少，你的网站访客需要下载的代码也就越少。因此，尽量简洁并编写优化后的代码是有意义的。
- en: The second point should also make sense. For some tasks, you will actually save
    code by including third-party libraries that may be much more elaborate than the
    code solution you might come up with. But there are also situations and tasks
    in which you might get away with writing your own code or using some built-in
    function instead of including a third-party library. You should at least always
    think about this alternative and only include third-party libraries you absolutely
    need.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点也应该是有意义的。对于某些任务，你实际上可以通过包含可能比你自己编写的代码更复杂的第三方库来节省代码。但也有一些情况和任务，你可能可以通过编写自己的代码或使用一些内置函数来避免包含第三方库。你至少应该始终考虑这种替代方案，并且只包含你绝对需要的第三方库。
- en: The last point is something React can help with.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点是 React 可以帮助解决的问题。
- en: Reducing Bundle Sizes via Code Splitting (Lazy Loading)
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过代码拆分（懒加载）减少包大小
- en: React exposes a `lazy()` function that can be used to load component code conditionally—meaning
    only when it’s actually needed (instead of upfront).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供了一个 `lazy()` 函数，可以用来有条件地加载组件代码——这意味着只有在实际需要时（而不是一开始）才会加载。
- en: Consider the following example, consisting of two components working together.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下由两个组件协同工作的例子。
- en: 'A `DateCalculator` component is defined like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateCalculator` 组件的定义如下：'
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This `DateCalculator` component is then rendered conditionally by the `App`
    component:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`DateCalculator` 组件由 `App` 组件有条件地渲染：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, the `DateCalculator` component uses a third-party library (the
    `date-fns` library) to access various date-related utility functions (for example,
    a function for calculating the difference between two dates, or `differenceInDays`
    ).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`DateCalculator` 组件使用第三方库（`date-fns` 库）来访问各种日期相关实用函数（例如，计算两个日期之间差异的函数，或
    `differenceInDays`）。
- en: The component then accepts two date values and calculates the difference between
    those dates in days—though the actual logic of the component isn’t too important
    here. What is important is the fact that a third-party library and various utility
    functions are used. This adds quite a bit of JavaScript code to the overall code
    bundle, and all that code must be downloaded when the entire website is loaded
    for the first time, even though the date calculator isn’t even visible at that
    point in time (because it is rendered conditionally).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件接受两个日期值，并计算这两个日期之间的天数差异——尽管组件的实际逻辑在这里并不重要。重要的是，使用了第三方库和各种实用函数。这给整体代码包增加了相当多的
    JavaScript 代码，并且所有这些代码都必须在第一次加载整个网站时下载，即使那时日期计算器甚至都不可见（因为它是有条件渲染的）。
- en: 'After building the app for production (via `npm run build` ), when previewing
    that production version (via `npm run preview` ), you can see one main code bundle
    file being downloaded in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建用于生产的应用程序（通过 `npm run build`）后，当预览该生产版本（通过 `npm run preview`）时，你可以在以下屏幕截图中看到下载了一个主要的代码包文件：
- en: '![img](img/B31339_10_10.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_10_10.png)'
- en: 'Figure 10.10: One main bundle file is downloaded'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10：下载了一个主要的包文件
- en: The `Network` tab in the browser’s developer tools reveals outgoing network
    requests. As you can see in the screenshot, one main JavaScript bundle file is
    downloaded. You won’t see any extra requests being sent when the button is clicked.
    This implies that all the code, including the code needed for `DateCalculator`
    , was downloaded upfront.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器开发者工具中的“网络”选项卡揭示了发出的网络请求。正如你在屏幕截图中看到的，下载了一个主要的 JavaScript 包文件。当点击按钮时，你不会看到任何额外的请求被发送。这表明所有代码，包括
    `DateCalculator` 所需的代码，都是一开始就下载的。
- en: That’s where code splitting with React’s `lazy()` function becomes useful.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 React 的 `lazy()` 函数进行代码拆分变得有用的地方。
- en: This function can be wrapped around a dynamic import to load the imported component
    only once it’s needed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以围绕动态导入包装，以便仅在需要时加载导入的组件。
- en: '**Note**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Dynamic imports are a native JavaScript feature that allows for dynamically
    importing JavaScript code files. For further information on this topic, visit
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import)
    .
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 动态导入是原生 JavaScript 功能，允许动态导入 JavaScript 代码文件。有关此主题的更多信息，请访问 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import)。
- en: 'In the preceding example, it would be used like this in the `App` component
    file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，它将在 `App` 组件文件中这样使用：
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This alone won’t do the trick though. You must also wrap the conditional JSX
    code, where the dynamically imported component is used, with another component
    provided by React – the `<Suspense>` component – like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 仅此还不够。你还必须将条件 JSX 代码（其中使用了动态导入的组件）包装在 React 提供的另一个组件 `<Suspense>` 中，如下所示：
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Note**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the finished example code on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/examples/06-code-splitting](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/examples/06-code-splitting)
    .
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到完成的示例代码：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/examples/06-code-splitting](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/examples/06-code-splitting)。
- en: '`Suspense` is a component built into React that aims to display fallback content
    while some resource or data is loading. Therefore, when using it for lazy loading,
    you must wrap it around any conditional code that uses React’s `lazy()` function.
    `Suspense` also has one mandatory prop that must be provided, the `fallback` prop,
    which expects a JSX value that will be rendered as fallback content until the
    dynamically loaded content is available.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Suspense` 是 React 内置的一个组件，旨在在加载某些资源或数据时显示回退内容。因此，当用于懒加载时，你必须将其包装在任何使用 React
    的 `lazy()` 函数的条件的代码周围。`Suspense` 还有一个必须提供的强制属性，即 `fallback` 属性，它期望一个 JSX 值，该值将在动态加载的内容可用之前作为回退内容渲染。'
- en: '`lazy()` leads to the overall JavaScript code being split up into multiple
    bundles. The bundle that contains the `DateCalculator` component (and its dependencies,
    such as the `date-fns` library code) is only downloaded when it’s needed—that
    is, when the button in the `App` component is clicked. If that download were to
    take a bit longer, the `fallback` content of `Suspense` would be shown on the
    screen in the meantime.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy()` 导致整体 JavaScript 代码被拆分为多个包。包含 `DateCalculator` 组件（及其依赖项，如 `date-fns`
    库代码）的包只有在需要时才会下载——也就是说，当在 `App` 组件中点击按钮时。如果下载需要更长的时间，那么在 `Suspense` 的同时，屏幕上会显示回退内容。'
- en: '**Note**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: React’s `Suspense` component is not limited to being used in conjunction with
    the `lazy()` function. *Chapter 14* , *Managing Data with React Router* , and
    *Chapter 17* , *Understanding React Suspense & The use() Hook* , will explore
    how the `Suspense` component may be used to show fallback content while fetching
    data.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: React 的 `Suspense` 组件不仅限于与 `lazy()` 函数一起使用。第 14 章，*使用 React Router 管理数据*，和第
    17 章，*理解 React Suspense 与 use() 钩子*，将探讨如何使用 `Suspense` 组件在加载数据时显示回退内容。
- en: 'After adding `lazy()` and the `Suspense` component as described, a smaller
    bundle is initially downloaded. In addition, if the button is clicked, more code
    files are downloaded:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `lazy()` 和 `Suspense` 组件后，最初下载的包会更小。此外，如果点击按钮，还会下载更多的代码文件：
- en: '![img](img/B31339_10_11.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_10_11.png)'
- en: 'Figure 10.11: After clicking the button, an extra code file is downloaded'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11：点击按钮后，会下载额外的代码文件
- en: Just as with all the other optimization techniques described thus far, the `lazy()`
    function is not a function you should start wrapping around all your imports.
    If an imported component is very small and simple (and doesn’t use any third-party
    code), splitting the code isn’t really worth it, especially since you have to
    consider that the additional HTTP request required for downloading the extra bundle
    also comes with some overhead.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就像迄今为止描述的所有其他优化技术一样，`lazy()` 函数并不是你应该开始围绕所有导入进行包装的函数。如果一个导入的组件非常小且简单（并且不使用任何第三方代码），拆分代码实际上并不值得，尤其是考虑到下载额外包所需的额外
    HTTP 请求也带来了一些开销。
- en: It also doesn’t make sense to use `lazy()` on components that will be loaded
    initially anyway. Only consider using it on conditionally loaded components.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些一开始就会加载的组件上使用 `lazy()` 也没有意义。只有考虑在条件加载的组件上使用它。
- en: Strict Mode
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Strict Mode
- en: Throughout this chapter, you have learned a lot about React’s internals and
    various optimization techniques. Not really an optimization technique, but still
    related, is another feature offered by React, called **Strict Mode** .
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了关于 React 内部结构和各种优化技术的很多内容。虽然这不是一种优化技术，但仍然相关，React 还提供了一个名为 **Strict
    Mode** 的功能。
- en: 'You may have stumbled across code like this before:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前遇到过这样的代码：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`<React.StrictMode>` is another built-in component provided by React. It doesn’t
    render a visual element, but it will enable some extra checks that are performed
    behind the scenes by React.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`<React.StrictMode>` 是 React 提供的另一个内置组件。它不会渲染视觉元素，但它将启用一些额外的检查，这些检查由 React
    在幕后执行。'
- en: Most checks are related to identifying the use of unsafe or legacy code (i.e.,
    features that will be removed in the future). But there are also some checks that
    aim to help you identify potential problems with your code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数检查都与识别不安全或过时代码（即未来将被移除的功能）的使用相关。但也有一些检查旨在帮助你识别代码中可能存在的问题。
- en: For example, when using Strict Mode, React will execute component functions
    twice and also unmount and remount every component whenever it mounts for the
    first time. This is done to ensure that you’re managing your state and side effects
    in a consistent and correct way (for example, that you do have cleanup functions
    in your effect functions).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当使用严格模式时，React 将执行组件函数两次，并在组件首次挂载时卸载和重新挂载每个组件。这样做是为了确保你以一致和正确的方式管理你的状态和副作用（例如，确保你的副作用函数中有清理函数）。
- en: '**Note**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Strict Mode only affects your app and its behavior during development. It does
    not influence your app once you build it for production. Extra checks of effects
    such as double component function execution will not be performed in production.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式（Strict Mode）仅影响你的应用程序及其在开发过程中的行为。一旦你为生产环境构建了应用程序，它就不会再影响你的应用程序。在生产环境中，不会执行额外的检查，例如双重组件函数执行。
- en: Building React apps with Strict Mode enabled can sometimes lead to confusion
    or annoying error messages. You might, for example, wonder why your component
    effects are executing too often.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 启用严格模式构建 React 应用程序有时可能会导致混淆或令人烦恼的错误消息。例如，你可能会想知道为什么你的组件副作用执行得太频繁。
- en: Therefore, it’s your personal decision whether you want to use Strict Mode or
    not. Enabling it can help you catch and fix errors early though.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，是否使用严格模式是你个人的决定。启用它可以帮助你及早捕获和修复错误。
- en: Debugging Code and the React Developer Tools
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试代码和 React 开发者工具
- en: Earlier in this chapter, you learned that component functions may execute quite
    frequently and that you can prevent unnecessary executions using `memo()` and
    `useMemo()` (and that you shouldn’t always prevent them).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，你了解到组件函数可能会非常频繁地执行，并且你可以使用 `memo()` 和 `useMemo()`（以及你不应该总是阻止它们）来防止不必要的执行。
- en: Identifying component executions by adding `console.log()` inside the component
    functions is one way of gaining insight into a component. It’s the approach used
    throughout this chapter. However, for large React apps with dozens, hundreds,
    or even thousands of components, using `console.log()` can get tedious.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在组件函数内部添加 `console.log()` 来识别组件执行是获取组件洞察的一种方法。这是本章使用的方法。然而，对于拥有数十、数百甚至数千个组件的大型
    React 应用程序，使用 `console.log()` 可能会变得繁琐。
- en: That’s why the React team also built an official tool to help with gaining app
    insights. React Developer Tools is an extension that can be installed on all major
    browsers (Chrome, Firefox, and Edge). You can find and install the extension by
    simply searching the web for `"<your browser> react developer tools"` (e.g., *chrome
    react developer tools* ).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，React 团队也构建了一个官方工具来帮助获取应用程序洞察。React 开发者工具是一个可以安装在所有主要浏览器（Chrome、Firefox
    和 Edge）上的扩展程序。你可以通过在网络上搜索 `"<你的浏览器> react 开发者工具"`（例如，*chrome react 开发者工具*）来查找并安装该扩展程序。
- en: Once you have installed the extension, you can access it directly from inside
    the browser. For example, when using Chrome, you can access the React Developer
    Tools extension directly from inside Chrome’s developer tools (which can be opened
    via the menu in Chrome). Explore the specific extension documentation (in your
    browser’s extensions store) for details on how to access it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 安装扩展程序后，你可以直接从浏览器内部访问它。例如，当使用 Chrome 时，你可以直接从 Chrome 的开发者工具（可以通过 Chrome 的菜单打开）中访问
    React 开发者工具扩展程序。探索特定扩展程序的文档（在你的浏览器扩展商店中）以获取有关如何访问它的详细信息。
- en: 'The React Developer Tools extension offers two areas: a `Components` page and
    a `Profile` page:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: React 开发者工具扩展提供了两个区域：一个 `Components` 页面和一个 `Profile` 页面：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_10_12.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B31339_10_12.png)'
- en: 'Figure 10.12: React Developer Tools can be accessed via browser developer tools'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12：React 开发者工具可以通过浏览器开发者工具访问
- en: The `Components` page can be used to analyze the component structure of the
    currently rendered page. You can use this page to understand the structure of
    your components (i.e., the “tree of components”), how components are nested into
    each other, and even the configuration (props, state) of components.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`Components`页面可以用来分析当前渲染页面的组件结构。你可以使用这个页面来了解你的组件结构（即“组件树”），组件是如何嵌套在一起的，甚至组件的配置（属性、状态）。'
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_10_13.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B31339_10_13.png)'
- en: 'Figure 10.13: Component relations and data are shown'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13：组件关系和数据展示
- en: This page can be very useful when attempting to understand the current state
    of a component, how a component is related to other components, and which other
    components may therefore influence a component (e.g., cause it to be re-evaluated).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试理解组件的当前状态、组件与其他组件的关系以及哪些其他组件可能因此影响组件（例如，导致它重新评估）时，这个页面非常有用。
- en: 'However, in the context of this chapter, the more useful page is the `Profiler`
    page:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章的上下文中，更有用的页面是`Profiler`页面：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_10_14.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B31339_10_14.png)'
- en: 'Figure 10.14: The Profiler page (without any data gathered)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14：分析器页面（没有收集任何数据）
- en: On this page, you can begin recording component evaluations (i.e., component
    function executions). You can do this by simply clicking the `Record` button in
    the top-left corner (the blue circle). This button will then be replaced by a
    `Stop` button, which you can click to end the recording.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，你可以开始记录组件评估（即组件函数执行）。你可以通过简单地点击左上角的`Record`按钮（蓝色圆圈）来完成此操作。然后，此按钮将被`Stop`按钮替换，你可以点击它来结束记录。
- en: 'After recording the React app for a couple of seconds (and interacting with
    it during that period), an example result could look like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录React应用几秒钟（并在该期间与之交互）后，一个示例结果可能看起来像这样：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_10_15.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B31339_10_15.png)'
- en: 'Figure 10.15: The Profiler page shows various bars after recording has finished'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15：记录完成后，分析器页面显示了各种条形图
- en: 'This result consists of two main areas:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果由两个主要区域组成：
- en: A list of bars, indicating the number of component re-evaluations (every bar
    reflects one re-evaluation cycle that affected one or more components). You can
    click these bars to explore more details about a specific cycle.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列条形图，表示组件重新评估的次数（每个条形图反映一个影响了零个或多个组件的重新评估周期）。你可以点击这些条形图来探索特定周期更详细的信息。
- en: For the selected evaluation cycle, a list of the affected components is presented.
    You can identify affected components easily as their bars are colored and timing
    information is displayed for them.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所选的评估周期，会显示受影响组件的列表。你可以很容易地识别受影响的组件，因为它们的条形图被着色，并且会显示它们的计时信息。
- en: You can select any render cycle from *1* (in this case, there are two for this
    recording session) to view which components were affected. The bottom part of
    the window ( *2* ) shows all affected components by highlighting them with some
    color and outputting the overall amount of time taken by the components to be
    re-evaluated (for example, `0.1ms of 0.3ms` ).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从*1*（在这种情况下，这个记录会话有两个）选择任何渲染周期来查看哪些组件受到了影响。窗口的底部部分（*2*）通过突出显示它们并用某种颜色标记，显示了所有受影响的组件，并输出了组件重新评估所花费的总时间（例如，`0.1ms
    of 0.3ms`）。
- en: '**Note**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: It’s worth noting that this tool also proves that component evaluation is extremely
    fast— `0.1ms` for re-evaluating a component is way too fast for any human to realize
    that something happened behind the scenes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这个工具还证明组件评估非常快——重新评估一个组件的`0.1ms`对于任何人类来说都太快，以至于无法意识到幕后发生了什么。
- en: On the right side of the window, you also learn more about this component evaluation
    cycle. For example, you learn where it was triggered. In this case, it was triggered
    by the `Form` component (it’s the same example as discussed earlier in this chapter,
    in the *Avoiding Unnecessary Child Component Evaluations* section).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口的右侧，你还可以了解更多关于这个组件评估周期的信息。例如，你可以了解它是如何被触发的。在这种情况下，它是由`Form`组件触发的（这与本章前面在*避免不必要的子组件评估*部分讨论的例子相同）。
- en: 'The `Profiler` page can therefore also help you to identify component evaluation
    cycles and determine which components are affected. In this example, you can see
    a difference if the `memo()` function is wrapped around the `Error` component:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Profiler`页面也可以帮助你识别组件评估周期并确定哪些组件受到影响。在这个例子中，如果你将`memo()`函数包裹在`Error`组件周围，你可以看到差异：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_10_16.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图 自动生成的描述](img/B31339_10_16.png)'
- en: 'Figure 10.16: Only the Form component is affected, not the Error component'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16：只有表单组件受到影响，而不是错误组件
- en: After re-adding the `memo()` function as a wrapper around the `Error` component
    (as explained earlier in this chapter), you can use the `Profiler` page of React
    Developer Tools to confirm that the `Error` component is no longer unnecessarily
    evaluated. To do this, you should start a new recording session and reproduce
    the situation, where previously, without `memo()` , the `Error` component would’ve
    been called again.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`memo()`函数作为包装器重新添加到`Error`组件（如本章前面所述）之后，你可以使用React开发者工具的`Profiler`页面来确认`Error`组件不再被不必要地评估。为此，你应该开始一个新的录制会话并重现之前没有`memo()`时`Error`组件会被再次调用的情景。
- en: The diagonal grayed-out lines across the `Error` component in the `Profiler`
    window signal that this component was not affected by some other component function
    invocation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Profiler`窗口中，`Error`组件上对角线的灰色线条表示该组件未受到其他组件函数调用的任何影响。
- en: React Developer Tools can therefore be used to gain deeper insights into your
    React app and your components. You can use them in addition or instead of calling
    `console.log()` in a component function.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以使用React开发者工具来深入了解你的React应用和组件。你可以在组件函数中调用`console.log()`的同时使用它们，或者完全替代调用`console.log()`。
- en: Summary and Key Takeaways
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和关键要点
- en: React components are re-evaluated (executed) whenever their state changes or
    the parent component is evaluated.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当React组件的状态发生变化或父组件被评估时，它们会被重新评估（执行）。
- en: React optimizes component evaluation by calculating required UI changes with
    the help of a virtual DOM first.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React通过首先使用虚拟DOM来计算所需的UI更改，从而优化组件评估。
- en: Multiple state updates that occur at the same time and in the same place are
    batched together by React. This ensures that unnecessary component evaluations
    are avoided.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时在同一位置发生的多个状态更新会被React批处理在一起。这确保了避免不必要的组件评估。
- en: The `memo()` function can be used to control component function executions.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memo()`函数可以用来控制组件函数的执行。'
- en: '`memo()` looks for prop value differences (old props versus new props) to determine
    whether a component function must be executed again.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memo()`函数会查找属性值的变化（旧属性与新属性之间的差异），以确定组件函数是否需要再次执行。'
- en: '`useMemo()` can be used to wrap performance-intensive computations and only
    perform them if key dependencies changed.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useMemo()`可以用来包装性能密集型计算，并且只有在关键依赖项发生变化时才执行这些计算。'
- en: Both `memo()` and `useMemo()` should be used carefully since they also come
    at a cost (the comparisons performed).
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`memo()`和`useMemo()`也会带来成本（比较操作），因此应谨慎使用它们。
- en: When working with React 19 or higher, you can install and enable the (experimental)
    React compiler to automatically optimize your code during the build process.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用React 19或更高版本时，你可以安装并启用（实验性的）React编译器，以在构建过程中自动优化你的代码。
- en: The initial code download size can be reduced with the help of code splitting
    via the `lazy()` function (in conjunction with the built-in `Suspense` component)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过`lazy()`函数（与内置的`Suspense`组件结合使用）的帮助，通过代码拆分来减少初始代码下载的大小。
- en: React’s Strict Mode can be enabled (via the built-in `<React.StrictMode>` component)
    to perform various extra checks and detect potential bugs in your application.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过内置的`<React.StrictMode>`组件启用React的严格模式，以执行各种额外检查并检测应用程序中的潜在错误。
- en: React Developer Tools can be used to gain deeper insights into your React app
    (for example, component structure and re-evaluation cycles).
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用React开发者工具来深入了解你的React应用（例如，组件结构和重新评估周期）。
- en: What’s Next?
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: As a developer, you should always know and understand the tool you’re working
    with—in this case, React.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，你应该始终了解并理解你所使用的工具——在本例中是React。
- en: This chapter allowed you to get a better idea of how React works under the hood
    and which optimizations are implemented automatically. In addition, you also learned
    about various optimization techniques that can be implemented by you.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使您更好地了解了React在底层的工作原理以及自动实现的优化。此外，您还了解了您可以实施的多种优化技术。
- en: The next chapter will go back to solving actual problems you might face when
    trying to build React apps. Instead of optimizing React apps, you will learn more
    about techniques and features that can be used to solve more complex problems
    related to component and application state management.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将回到解决您在尝试构建React应用程序时可能遇到的实际问题。您将学习更多关于可以用于解决与组件和应用状态管理相关的更复杂问题的技术和功能，而不是优化React应用程序。
- en: Test Your Knowledge!
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试您的知识！
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to examples that can be
    found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/10-behind-scenes/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/10-behind-scenes/exercises/questions-answers.md)
    :'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试您对本章涵盖的概念的了解。然后，您可以比较您的答案与可在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/10-behind-scenes/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/10-behind-scenes/exercises/questions-answers.md)找到的示例：
- en: Why does React use a virtual DOM to detect required DOM updates?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么React使用虚拟DOM来检测所需的DOM更新？
- en: How is the real DOM affected when a component function is executed?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件函数执行时，真实DOM会受到什么影响？
- en: Which components are great candidates for the `memo()` function? Which components
    are bad candidates?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些组件是`memo()`函数的优秀候选者？哪些组件是不合适的候选者？
- en: How is `useMemo()` different from `memo()` ?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useMemo()`与`memo()`有何不同？'
- en: What’s the idea behind code splitting and the `lazy()` function?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码拆分和`lazy()`函数背后的理念是什么？
- en: Apply What You Learned
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用您所学到的知识
- en: With your newly gained knowledge about React’s internals and some of the optimization
    techniques you can employ in order to improve your apps, you can now apply this
    knowledge in the following activity.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在您对React内部结构和可以用于改进您的应用程序的一些优化技术有了新的了解之后，您现在可以在以下活动中应用这些知识。
- en: 'Activity 10.1: Optimize an Existing App'
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十.1：优化现有应用程序
- en: In this activity, you’re handed an existing React app that could be optimized
    in various places. Your task is to identify optimization opportunities and implement
    appropriate solutions. Keep in mind that too much optimization can actually lead
    to a worse result.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将获得一个可以优化多个位置的现有React应用程序。您的任务是识别优化机会并实施适当的解决方案。请记住，过多的优化实际上可能导致结果更差。
- en: '**Note**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the starting code for this activity at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/activities/practice-1-start)
    . When downloading this code, you’ll always download the entire repository. Make
    sure to then navigate to the subfolder with the starting code ( `activities/practice-1-start`
    in this case) to use the right code snapshot.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/activities/practice-1-start)找到这个活动的起始代码。在下载此代码时，您将始终下载整个仓库。请确保然后导航到包含起始代码的子文件夹（在本例中为`activities/practice-1-start`），以使用正确的代码快照。
- en: The provided project also uses many features covered in earlier chapters. Take
    the time to analyze it and understand the provided code. This is a great practice
    and allows you to see many key concepts in action.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的项目还使用了之前章节中介绍的一些许多功能。花时间分析它并理解提供的代码。这是一个很好的实践，让您看到许多关键概念的实际应用。
- en: 'Once you have downloaded the code and run `npm install` in the project folder
    (to install all required dependencies), you can start the development server via
    `npm run dev` . As a result, upon visiting `localhost:5173` , you should see the
    following UI:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 下载代码并在项目文件夹中运行`npm install`（安装所有必需的依赖项）后，您可以通过`npm run dev`启动开发服务器。结果，当访问`localhost:5173`时，您应该看到以下UI：
- en: '![img](img/B31339_10_17.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_10_17.png)'
- en: 'Figure 10.17: The running starting project'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17：运行中的起始项目
- en: Take your time to get acquainted with the provided project. Experiment with
    the different buttons in the UI, fill in some dummy data in the form input fields,
    and analyze the provided code. Please note that this dummy project does not send
    any HTTP requests to any server. All entered data is discarded the moment it is
    entered.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细熟悉提供的项目。在UI中尝试不同的按钮，在表单输入字段中填写一些示例数据，并分析提供的代码。请注意，此示例项目不会向任何服务器发送任何HTTP请求。所有输入的数据一旦输入即被丢弃。
- en: 'To complete the activity, the solution steps are as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此活动，解决方案步骤如下：
- en: Find optimization opportunities by looking for unnecessary component function
    executions.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过寻找不必要的组件函数执行来寻找优化机会。
- en: Also, identify unnecessary code execution inside of component functions (where
    the overall component function invocation can’t be prevented).
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还应识别组件函数内部不必要的代码执行（其中无法阻止整个组件函数的调用）。
- en: Determine which code could be loaded lazily instead of eagerly.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定哪些代码可以懒加载而不是立即加载。
- en: Use the `memo()` function, the `useMemo()` Hook, and React’s `lazy()` function
    to improve the code.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`memo()`函数、`useMemo()` Hook和React的`lazy()`函数来改进代码。
- en: 'You can tell that you came up with a good solution and sensible adjustments
    if you can see extra code fetching network requests (in the **Network** tab of
    your browser developer tools) for clicking on the **Reset password** or **Create
    a new account** buttons:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能在浏览器开发者工具的**网络**标签页中看到点击**重置密码**或**创建新账户**按钮时额外的代码获取网络请求，那么你可以知道你提出了一个好的解决方案和合理的调整：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_10_18.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  自动生成的描述](img/B31339_10_18.png)'
- en: 'Figure 10.18: In the final solution, some code is lazy loaded'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18：在最终解决方案中，一些代码是懒加载的
- en: 'In addition, you should see no `Validated password.` console message when typing
    into the email input fields ( **Email** and **Confirm Email** ) of the signup
    form (that is, the form you switch to when clicking **Create a new account** ):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当在注册表单（即点击**创建新账户**时切换到的表单）的电子邮件输入字段（**电子邮件**和**确认电子邮件**）中输入时，不应看到任何`Validated
    password.`控制台消息：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_10_19.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  自动生成的描述](img/B31339_10_19.png)'
- en: 'Figure 10.19: No “Validated password.” output in the console'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19：控制台没有“验证密码。”输出
- en: 'You also shouldn’t get any console outputs when clicking the **More Information**
    button:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**更多信息**按钮时，也不应该有任何控制台输出：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_10_20.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  自动生成的描述](img/B31339_10_20.png)'
- en: 'Figure 10.20: No console messages when clicking “More Information”'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20：点击“更多信息”时没有控制台消息
- en: '**Note**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: All code files used for this activity, and the solution, can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/activities/practice-1)
    .
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于此活动的代码文件和解决方案都可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/10-behind-scenes/activities/practice-1)找到。
