- en: '*Chapter 6*: Reactive State Management with NgRx'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：使用NgRx进行响应式状态管理'
- en: Angular and Reactive programming are best buddies, and handling an app's state
    reactively is one of the best things you can do with your app. NgRx is a framework
    that provides a set of libraries as reactive extensions for Angular. In this chapter,
    you'll learn how to use the NgRx ecosystem to manage your app's state reactively,
    and you'll also learn a couple of cool things the NgRx ecosystem will help you
    with.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Angular和响应式编程是最好的朋友，以响应式方式处理应用程序的状态是您可以为应用程序做的最好的事情之一。NgRx是一个为Angular提供一组库作为响应式扩展的框架。在本章中，您将学习如何使用NgRx生态系统以响应式地管理应用程序的状态，并且您还将学习NgRx生态系统将帮助您完成的一些很酷的事情。
- en: 'Here are the recipes we''re going to cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章我们将要涵盖的食谱：
- en: Creating your first NgRx store with actions and reducer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动作和减速器创建你的第一个NgRx存储
- en: Using `@ngrx/store-devtools` to debug the state changes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@ngrx/store-devtools`来调试状态变化
- en: Creating an effect to fetch third-party **application programming interface**
    (**API**) data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个效果来获取第三方**应用程序编程接口**（**API**）数据
- en: Using selectors to fetch data from stores in multiple components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选择器从多个组件中的存储中获取数据
- en: Using `@ngrx/component-store` for local state management within a component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@ngrx/component-store`来在组件内进行本地状态管理
- en: Using `@ngrx/router-store` to work with route changes reactively
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@ngrx/router-store`以响应式方式处理路由更改
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the recipes in this chapter, make sure you have **Git** and **Node.js**
    installed on your machine. You also need to have the `@angular/cli` package installed,
    which you can do with `npm install -g @angular/cli` from your terminal. The code
    for this chapter can be found at https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter06.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的食谱，请确保您的计算机上已安装**Git**和**Node.js**。您还需要安装`@angular/cli`包，可以在终端中使用`npm install
    -g @angular/cli`来安装。本章的代码可以在https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter06找到。
- en: Creating your first NgRx store with actions and reducer
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动作和减速器创建你的第一个NgRx存储
- en: In this recipe, you'll work your way through understanding NgRx's basics by
    setting up your first NgRx store. You'll also create some actions along with a
    reducer, and to see the changes in the reducer, we'll be putting in appropriate
    console logs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将通过设置您的第一个NgRx存储来逐步了解NgRx的基础知识。您还将创建一些动作以及一个减速器，并且为了查看减速器中的变化，我们将放入适当的控制台日志。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter06/start_here/ngrx-actions-reducer`,
    inside the cloned repositor:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的项目位于`chapter06/start_here/ngrx-actions-reducer`中，位于克隆存储库内：
- en: Open the project in **Visual Studio Code** (**VS Code**).
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Visual Studio Code** (**VS Code**)中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab. Tap the **Login as Admin** button
    and you should see the following screen:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签中打开应用程序。点击**以管理员身份登录**按钮，您应该会看到以下屏幕：
- en: '![Figure 6.1 – ngrx-actions-reducers app running on http://localhost:4200'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – ngrx-actions-reducers应用程序在http://localhost:4200上运行'
- en: '](image/Figure_6.1_B15150.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.1_B15150.jpg)'
- en: Figure 6.1 – ngrx-actions-reducers app running on http://localhost:4200
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – ngrx-actions-reducers应用程序在http://localhost:4200上运行
- en: Now that we have the app running, we'll move on to the steps for the recipe.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序正在运行，我们将继续进行食谱的步骤。
- en: How to do it…
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have an existing Angular app that we used in the prior recipes as well.
    If you log in as an Admin user, you can add and remove items from the bucket.
    However, if you log in as an Employee, you can only add items and not remove them.
    We''ll now start integrating NgRx into the app and create a reducer and some actions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个现有的Angular应用程序，我们在之前的示例中也使用过。如果您以管理员用户身份登录，您可以向购物篮中添加和移除物品。但是，如果您以员工身份登录，您只能添加物品而不能移除物品。现在我们将开始将NgRx集成到应用程序中，并创建一个reducer和一些动作：
- en: 'Begin by installing the `@ngrx/store package` via **Node Package Manager**
    (**npm**) in your project. Open Terminal (Mac/Linux) or Command Prompt (Windows),
    navigate to the project root, and run the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先通过**Node Package Manager** (**npm**)在您的项目中安装`@ngrx/store package`。打开终端（Mac/Linux）或命令提示符（Windows），导航到项目根目录，并运行以下命令：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Make sure to rerun the `ng-serve` command if you already have it running.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在运行，请确保重新运行`ng-serve`命令。
- en: 'Update the `app.module.ts` file to include `StoreModule`, as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`app.module.ts`文件以包括`StoreModule`，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that we've passed an empty object `{}` to the `forRoot` method; we'll
    change that going forward.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经向`forRoot`方法传递了一个空对象`{}`；我们将在以后进行更改。
- en: 'Now, we''ll create some actions. Create a folder named `store` inside the `app`
    folder. Then, create a file named `app.actions.ts` inside the `store` folder,
    and finally, add the following code to the newly created file:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一些动作。在`app`文件夹内创建一个名为`store`的文件夹。然后，在`store`文件夹内创建一个名为`app.actions.ts`的文件，并最后向新创建的文件中添加以下代码：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since we have the actions in place now, we have to create a reducer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在已经有了动作，我们必须创建一个reducer。
- en: 'Create a new file inside the `store` folder, name it `app.reducer.ts`, and
    add the following code to it to define the necessary imports:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`store`文件夹内创建一个新文件，命名为`app.reducer.ts`，并向其中添加以下代码以定义必要的导入：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, define an `AppState` interface to reflect the app''s state, and an `initialState`
    variable to reflect what the app''s state will look like when the app starts.
    Add the following code to the `app.reducer.ts` file:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个`AppState`接口以反映应用程序的状态，并定义一个`initialState`变量以反映应用程序启动时应用程序状态的外观。在`app.reducer.ts`文件中添加以下代码：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It''s time to actually create a reducer now. Add the following code to the
    `app.reducer.ts` file to create a reducer:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候实际创建一个reducer了。在`app.reducer.ts`文件中添加以下代码以创建一个reducer：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ll also add some sweet little `console.logs` calls into the `reducer` method
    to see all the actions firing up on our console. Add a log as follows to the `app.reducer.ts`
    file:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将在`reducer`方法中添加一些`console.logs`调用，以查看控制台上所有动作的触发情况。在`app.reducer.ts`文件中添加如下日志：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, let''s register this reducer in the `app.module.ts` file using the
    `StoreModule.forRoot()` method as follows so that we can see things working:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`app.module.ts`文件中使用`StoreModule.forRoot()`方法注册此reducer，以便我们可以看到事情的运行情况：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you refresh the app now, you should see the following logs on the console
    as soon as the app starts:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在刷新应用程序，您应该在应用程序启动时立即在控制台上看到以下日志：
- en: '![Figure 6.2 – Logs showing initial state and @ngrx/store/init action on app
    start'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 - 显示应用启动时的初始状态和@ngrx/store/init动作的日志'
- en: '](image/Figure_6.2_B15150.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.2_B15150.jpg)'
- en: Figure 6.2 – Logs showing initial state and @ngrx/store/init action on app start
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 - 显示应用启动时的初始状态和@ngrx/store/init动作的日志
- en: 'Now that we can see that the reducer works, let''s dispatch our actions on
    adding and removing items from the basket. For that, dispatch the actions as follows
    in the `shared/components/bucket`/`bucket.component.ts` file:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以看到reducer起作用了，让我们在添加和移除购物篮中的物品时分派我们的动作。为此，在`shared/components/bucket`/`bucket.component.ts`文件中按以下方式分派动作：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Log in to the app as Admin, add a few items to the bucket, and then remove
    some items. You''ll see something like this on the console:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以管理员身份登录应用程序，向桶中添加一些项目，然后删除一些项目。您会在控制台上看到类似这样的内容：
- en: '![Figure 6.3 – Logs showing the actions for adding and removing items from
    a bucket'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 - 显示从桶中添加和删除项目的操作日志'
- en: '](image/Figure_6.3_B15150.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.3_B15150.jpg)'
- en: Figure 6.3 – Logs showing the actions for adding and removing items from a bucket
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 - 显示从桶中添加和删除项目的操作日志
- en: And that covers it all for this recipe! You now know how to integrate an NgRx
    store into an Angular app and how to create NgRx actions and dispatch them. You
    also know how to create a reducer, define its state, and listen to the actions
    to act on the ones dispatched.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，这个教程就结束了！您现在知道如何将NgRx存储集成到Angular应用程序中，以及如何创建NgRx操作并分发它们。您还知道如何创建一个reducer，定义它的状态，并监听操作以对分发的操作进行操作。
- en: See also
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: NgRx reducers documentation ([https://ngrx.io/guide/store/reducers](https://ngrx.io/guide/store/reducers))
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NgRx reducer文档（[https://ngrx.io/guide/store/reducers](https://ngrx.io/guide/store/reducers)）
- en: NgRx actions documentation ([https://ngrx.io/guide/store/actions](https://ngrx.io/guide/store/actions))
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NgRx操作文档（[https://ngrx.io/guide/store/actions](https://ngrx.io/guide/store/actions)）
- en: RxJS merge operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/combination/merge](https://www.learnrxjs.io/learn-rxjs/operators/combination/merge))
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS合并操作符文档（[https://www.learnrxjs.io/learn-rxjs/operators/combination/merge](https://www.learnrxjs.io/learn-rxjs/operators/combination/merge)）
- en: Using @ngrx/store-devtools to debug the state changes
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@ngrx/store-devtools调试状态更改
- en: In this recipe, you'll learn how to set up and use `@ngrx/store-devtools` to
    debug your app's state, the actions dispatch, and the difference in the state
    when the actions dispatch. We'll be using an existing app we're familiar with
    to learn about the process.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将学习如何设置和使用`@ngrx/store-devtools`来调试应用程序的状态、操作分发以及操作分发时状态的差异。我们将使用一个我们熟悉的现有应用程序来了解这个过程。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter06/start_here/using-ngrx-store-devtool`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程的项目位于`chapter06/start_here/using-ngrx-store-devtool`：
- en: Open the project in VS Code.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: This should open the app in a new browser tab.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器选项卡中打开应用程序。
- en: 'Login as an Admin user, and you should see a screen like this:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以管理员用户身份登录，并且您应该看到这样的屏幕：
- en: '![Figure 6.4 – Using ngrx-store-devtools app running on http://localhost:4200'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 - 在http://localhost:4200上运行的使用ngrx-store-devtools应用程序'
- en: '](image/Figure_6.4_B15150.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.4_B15150.jpg)'
- en: Figure 6.4 – Using ngrx-store-devtools app running on http://localhost:4200
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 - 在http://localhost:4200上运行的使用ngrx-store-devtools应用程序
- en: Now that we have the app set up, let's see the steps of the recipe in the next
    section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了应用程序，让我们在下一节中看看这个教程的步骤。
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have an Angular app that already has the `@ngrx/store` package integrated.
    We also have a reducer set up and some actions in place that are logged on the
    console as soon as you add or remove an item. Let''s move toward configuring the
    store dev tools for our ap:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个Angular应用程序，已经集成了`@ngrx/store`包。我们还设置了一个reducer，并且有一些操作，当您添加或删除项目时，这些操作会立即在控制台上记录。让我们开始配置应用程序的存储开发工具：
- en: 'Begin with installing the `@ngrx/store-devtools` package in the project, as
    follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在项目中安装`@ngrx/store-devtools`包，如下所示：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, update your `app.module.ts` file to include a `StoreDevtoolsModule.instrument`
    entry, as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新您的`app.module.ts`文件，包括`StoreDevtoolsModule.instrument`条目，如下所示：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: And now, download the Redux DevTools extension from [https://github.com/zalmoxisus/redux-devtools-extension/](https://github.com/zalmoxisus/redux-devtools-extension/)
    for your particular browser and install it. I'll be consistently using the Chrome
    browser in this book.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从[https://github.com/zalmoxisus/redux-devtools-extension/](https://github.com/zalmoxisus/redux-devtools-extension/)下载Redux
    DevTools扩展，安装到您特定的浏览器上。在本书中，我将一直使用Chrome浏览器。
- en: Open Chrome DevTools. There should be a new tab named **Redux**. Tap it and
    refresh the page. You'll see something like this:![Figure 6.5 – Redux DevTools
    showing the initial Redux action dispatched
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Chrome DevTools。应该会有一个名为**Redux**的新标签。点击它并刷新页面。您会看到类似于这样的内容：![图6.5 - Redux
    DevTools显示初始的Redux动作已经分发
- en: '](image/Figure_6.5_B15150.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.5_B15150.jpg)'
- en: Figure 6.5 – Redux DevTools showing the initial Redux action dispatched
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 - Redux DevTools显示初始的Redux动作已经分发
- en: 'To see the state of the app right now, tap the **State** button, as shown in
    the following screenshot, and you should see that we have `app > bucket: []` as
    the current state:![Figure 6.6 – Viewing current state in the Redux DevTools extension'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '要查看当前应用程序状态，请点击**State**按钮，如下截图所示，您应该会看到我们当前的状态是`app > bucket: []`：![图6.6 -
    在Redux DevTools扩展中查看当前状态'
- en: '](image/Figure_6.6_B15150.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.6_B15150.jpg)'
- en: Figure 6.6 – Viewing current state in the Redux DevTools extension
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 - 在Redux DevTools扩展中查看当前状态
- en: 'Now, add a cherry 🍒 and a banana 🍌 to the bucket, and then remove the banana
    🍌 from the bucket. You should see all the relevant actions being dispatched, as
    follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向桶里加入一个樱桃🍒和一个香蕉🍌，然后从桶里移除香蕉🍌。您应该看到所有相关的动作被分发，如下所示：
- en: '![Figure 6.7 – Redux DevTools showing addItemToBucket and removeItemFromBucket
    actions'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7 - Redux DevTools显示addItemToBucket和removeItemFromBucket动作'
- en: '](image/Figure_6.7_B15150.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.7_B15150.jpg)'
- en: Figure 6.7 – Redux DevTools showing addItemToBucket and removeItemFromBucket
    actions
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 - Redux DevTools显示addItemToBucket和removeItemFromBucket动作
- en: 'If you expand the bucket array from the state, you''ll see that it reflects
    the current state of the bucket, as we can see in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您展开状态中的桶数组，您会看到它反映了桶的当前状态，就像我们在以下截图中看到的那样：
- en: '![Figure 6.8 – Redux DevTools showing bucket''s current state'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8 - Redux DevTools显示桶的当前状态'
- en: '](image/Figure_6.8_B15150.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.8_B15150.jpg)'
- en: Figure 6.8 – Redux DevTools showing bucket's current state
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 - Redux DevTools显示桶的当前状态
- en: Great! You've just learned how to use the Redux DevTools extension to see your
    NgRx state and the actions being dispatched.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您刚刚学会了如何使用Redux DevTools扩展来查看您的NgRx状态和已分发的动作。
- en: How it works…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It is important to understand that NgRx is a combination of Angular and Redux
    (using RxJS). By using the Store Devtools package and the Redux DevTools extension,
    we're able to debug the app really easily, which helps us find potential bugs,
    predict state changes, and be more transparent about what's happening behind the
    scenes in the `@ngrx/store` package.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解NgRx是Angular和Redux（使用RxJS）的组合。通过使用Store Devtools包和Redux DevTools扩展，我们能够轻松调试应用程序，这有助于我们发现潜在的错误，预测状态变化，并且更透明地了解`@ngrx/store`包后台发生的情况。
- en: There's more…
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can also see the difference that an action caused within an app''s state.
    That is, we have an addition of an item in the bucket when we dispatch the `addItemToBucket`
    action with the fruit, and we have an item removed from the bucket when we dispatch
    the `removeItemFromBucket` action. See the following screenshot and *Figure 6.10*
    for each cases:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到动作在应用程序状态中引起的差异。也就是说，当我们使用水果分发`addItemToBucket`动作时，桶中会增加一个项目，当我们分发`removeItemFromBucket`动作时，桶中会移除一个项目。请参见以下截图和*图6.10*：
- en: '![Figure 6.9 – addItemToBucket action causing the addition of an item to the
    bucket'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9 - addItemToBucket 操作导致向桶中添加项目'
- en: '](image/Figure_6.9_B15150.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.9_B15150.jpg)'
- en: Figure 6.9 – addItemToBucket action causing the addition of an item to the bucket
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 - addItemToBucket 操作导致向桶中添加项目
- en: 'Notice the green background around the data `{id:1605205728586,name:''Banana`
    `🍌``''}` in *Figure 6.9*. This represents an addition to the state. You can see
    the `removeItemFromBucket` action depicted here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意*图6.9*中数据`{id:1605205728586,name:'Banana` `🍌``'}`周围的绿色背景。这代表对状态的添加。您可以在这里看到`removeItemFromBucket`操作：
- en: '![Figure 6.10 – removeItemFromBucket action causing the removal of an item
    from the bucket'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.10 - removeItemFromBucket 操作导致从桶中移除项目'
- en: '](image/Figure_6.10_B15150.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.10_B15150.jpg)'
- en: Figure 6.10 – removeItemFromBucket action causing the removal of an item from
    the bucket
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 - removeItemFromBucket 操作导致从桶中移除项目
- en: Similarly, notice the red background and a strikethrough around the data `{id:16052057285…`
    `🍌``'}` in *Figure 6.10*. This represents removal from the state.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，注意*图6.10*中数据`{id:16052057285…` `🍌``'}`周围的红色背景和删除线。这代表从状态中移除。
- en: See also
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: NgRx Store Devtools documentation ([https://ngrx.io/guide/store-devtools](https://ngrx.io/guide/store-devtools))
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NgRx Store Devtools 文档 ([https://ngrx.io/guide/store-devtools](https://ngrx.io/guide/store-devtools))
- en: Creating an effect to fetch third-party API data
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个用于获取第三方API数据的效果
- en: In this recipe, you'll learn how to use NgRx effects using the `@ngrx/effects`
    package. You'll create and register an effect, and that effect will be listening
    for an event. Then, we'll react to that action to fetch third-party API data,
    and in response, we'll either dispatch a success or a failure action. This is
    gonna be fun.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将学习如何使用`@ngrx/effects`包来使用NgRx效果。您将创建并注册一个效果，该效果将监听一个事件。然后，我们将对该操作做出反应，以获取第三方API数据，并作出成功或失败的响应。这将会很有趣。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter06/start_here/using-ngrx-effect`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的项目位于`chapter06/start_here/using-ngrx-effect`中：
- en: Open the project in VS Code.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`以安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see the app,
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签中打开应用程序，并且您应该会看到应用程序，如下所示：
- en: '![Figure 6.11 – Using ngrx-effects app running on http://localhost:4200'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11 - 使用 ngrx-effects 应用程序在 http://localhost:4200 上运行'
- en: '](image/Figure_6.11_B15150.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.11_B15150.jpg)'
- en: Figure 6.11 – Using ngrx-effects app running on http://localhost:4200
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 - 使用 ngrx-effects 应用程序在 http://localhost:4200 上运行
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们在下一节中看看食谱的步骤。
- en: How to do it…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have an app with a single route named **Home** page. In the `HomeComponent`
    class, we''re using the `UserService` to send a **HyperText Transfer Protocol**
    (**HTTP**) call to get users and are then showing that on the browser. We already
    have the `@ngrx/store` and `@ngrx/store-devtools` packages integrated, as you
    can see in *Figure 6.1*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为**Home**页面的单一路由的应用程序。在`HomeComponent`类中，我们使用`UserService`发送**超文本传输协议**（**HTTP**）调用以获取用户，然后在浏览器上显示出来。正如您在*图6.1*中所看到的，我们已经集成了`@ngrx/store`和`@ngrx/store-devtools`包。
- en: 'Install the `@ngrx/effects` package in the project, as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中安装`@ngrx/effects`包，如下所示：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We''ll now create actions to get the users from the HTTP call. We''ll have
    one action to get the users, one to dispatch on successfully getting the users,
    and one action to dispatch in case we get an error. Add the following code to
    the `store/app.actions.ts` file:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建用于从HTTP调用获取用户的动作。我们将有一个动作用于获取用户，一个用于成功获取用户时分派，以及一个用于在出现错误时分派的动作。将以下代码添加到`store/app.actions.ts`文件中：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's create an effect now so that we can listen to the `GET_USERS` action,
    perform the API call, and dispatch the success action in case of successful data
    fetch.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个效果，以便我们可以监听`GET_USERS`动作，执行API调用，并在成功获取数据时分派成功动作。
- en: 'Create a file in the `store` folder named `app.effects.ts` and add the following
    code to it:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`store`文件夹中创建一个名为`app.effects.ts`的文件，并将以下代码添加到其中：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''ll create a new effect in the `app.effects.ts` file now to register a listener
    for the `GET_USERS` action, as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在`app.effects.ts`文件中创建一个新的效果，以注册`GET_USERS`动作的监听器，如下所示：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ll now register our effect as the root effects for the app in the `app.module.ts`
    file, as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在`app.module.ts`文件中将我们的效果注册为应用程序的根效果，如下所示：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As soon as we''ve registered the effects, you should see an additional action
    named `@ngrx/effects/init` firing in the Redux DevTools extension, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们注册了效果，您应该在Redux DevTools扩展中看到一个名为`@ngrx/effects/init`的额外动作触发，如下所示：
- en: '![Figure 6.12 – @ngrx/effects/init action fired on app launch'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12 - @ngrx/effects/init动作在应用启动时触发'
- en: '](image/Figure_6.12_B15150.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.12_B15150.jpg)'
- en: Figure 6.12 – @ngrx/effects/init action fired on app launch
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 - @ngrx/effects/init动作在应用启动时触发
- en: 'Now that we have the effects listening to the actions, let''s dispatch the
    `GET_USERS` action from the `HomeComponent` class, and we should see the `GET_USERS_SUCCESS`
    action fired in return on the successful call fetch. Add the following code to
    dispatch the action from `home/home.component.ts`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经让效果监听动作，让我们从`HomeComponent`类中分派`GET_USERS`动作，我们应该看到成功调用后返回`GET_USERS_SUCCESS`动作。添加以下代码以从`home/home.component.ts`中分派动作：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you refresh the app now, you should see the `[Users] Get Users` action dispatched,
    and in return, the `[Users] Get Users Success` action dispatches on the successful
    HTTP call:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在刷新应用程序，您应该看到`[Users] Get Users`动作被分派，并且作为成功HTTP调用的返回，`[Users] Get Users
    Success`动作也被分派：
- en: '![Figure 6.13 – GET_USERS and GET_USERS_SUCCESS actions being dispatched'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.13 - 分派GET_USERS和GET_USERS_SUCCESS动作'
- en: '](image/Figure_6.13_B15150.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.13_B15150.jpg)'
- en: Figure 6.13 – GET_USERS and GET_USERS_SUCCESS actions being dispatched
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 - 分派GET_USERS和GET_USERS_SUCCESS动作
- en: Notice in *Figure 6.13* that the `Diff` is nothing after the `GET_USERS_SUCCESS`
    action is dispatched. This is because we haven't updated the state using the reducer
    so far.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意*图6.13*中，在分派`GET_USERS_SUCCESS`动作后，`Diff`为空。这是因为到目前为止我们还没有使用reducer更新状态。
- en: 'Let''s update the state in the `app.reducer.ts` file to listen to the `GET_USERS_SUCCESS`
    action and assign the users to the state accordingly. The code should look like
    this:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`app.reducer.ts`文件中更新状态，以监听`GET_USERS_SUCCESS`动作并相应地将用户分配到状态中。代码应该如下所示：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you refresh the app now, you should see the users being assigned to the
    state, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在刷新应用程序，您应该看到用户被分配到状态中，如下所示：
- en: '![Figure 6.14 – GET_USERS_SUCCESS action adding users to the state'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.14 - GET_USERS_SUCCESS动作将用户添加到状态'
- en: '](image/Figure_6.14_B15150.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.14_B15150.jpg)'
- en: Figure 6.14 – GET_USERS_SUCCESS action adding users to the state
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 - GET_USERS_SUCCESS动作将用户添加到状态
- en: 'If you look at the app''s state right now, you should see something like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在查看应用程序的状态，您应该看到类似于这样的内容：
- en: '![Figure 6.15 – App state containing users after the GET_USERS_SUCCESS action'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.15 - 在GET_USERS_SUCCESS动作后包含用户的应用程序状态'
- en: '](image/Figure_6.15_B15150.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.15_B15150.jpg)'
- en: Figure 6.15 – App state containing users after the GET_USERS_SUCCESS action
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 - 在GET_USERS_SUCCESS操作后包含用户的应用程序状态
- en: Right now, we're sending two calls to the server—one through the effect, and
    one through the `ngOnInit` method of the `HomeComponent` class using the `UserService`
    instance directly. Let's remove the `UserService` from the `HomeComponent` class.
    We won't see any data right now, but that's what we're going to do in the next
    recipe.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们向服务器发送了两个调用 - 一个通过effect，另一个通过`HomeComponent`类的`ngOnInit`方法，直接使用`UserService`实例。让我们从`HomeComponent`类中删除`UserService`。现在我们看不到任何数据，但这是我们将在下一个示例中要做的事情。
- en: 'Remove the `UserService` from the `HomeComponent` class and your `home.component.ts`
    file should now look like this:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`HomeComponent`类中删除`UserService`，你的`home.component.ts`文件现在应该是这样的：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Great! You now know how to use NgRx effects in your Angular apps. See the next
    section to understand how NgRx effects work.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你知道如何在你的Angular应用程序中使用NgRx效果。请查看下一节，了解NgRx效果的工作原理。
- en: Important note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: We now have an output, as shown in *Figure 6.15*—that is, we keep showing the
    loader even after the users' data has been set in the store. The recipe's main
    purpose is to use `@ngrx/effects`, and that has been done. We'll show the appropriate
    data in the next recipe, *Using selectors to fetch data from stores in multiple
    components*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个输出，如*图6.15*所示 - 也就是说，即使用户数据已经设置在存储中，我们仍然保持显示加载程序。这个示例的主要目的是使用`@ngrx/effects`，这已经完成了。我们将在下一个示例中显示适当的数据，*使用选择器从多个组件中的存储中获取数据*。
- en: How it works…
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order for the NgRx effects to work, we needed to install the `@ngrx/effects`
    package, create an effect, and register it as an array of effects (root effects)
    in the `AppModule` class. When you create an effect, it has to listen to an action.
    When an action is dispatched to the store from any component or even from another
    effect, the registered effect triggers, does the job you want it to do, and is
    supposed to dispatch another action in return. For API calls, we usually have
    three actions—that is, the main action, and the following success and failure
    actions. Ideally, on the success action (and perhaps on the failure action too),
    you would want to update some of your state variables.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使NgRx效果起作用，我们需要安装`@ngrx/effects`包，创建一个效果，并在`AppModule`类中将其注册为一组效果（根效果）。当你创建一个效果时，它必须监听一个动作。当从任何组件甚至另一个效果向存储分派一个动作时，注册的效果会触发，执行你希望它执行的工作，并应该返回另一个动作。对于API调用，通常有三个动作
    - 即主要动作，以及以下成功和失败动作。理想情况下，在成功动作（也许在失败动作上），你会想要更新一些状态变量。
- en: See also
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: NgRx effects documentation ([https://ngrx.io/guide/effects](https://ngrx.io/guide/effects))
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NgRx效果文档([https://ngrx.io/guide/effects](https://ngrx.io/guide/effects))
- en: Using selectors to fetch data from stores in multiple components
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多个组件中使用选择器从存储中获取数据
- en: In the previous recipe, we created an NgRx effect to fetch third-party API data
    as users, and we saved it in the Redux store. That's what we have as a starting
    point in this recipe. We have an effect that fetches the users from `api.randomuser.me`
    and stores it in the state, and we don't currently show anything on the **user
    interface** (**UI**). In this recipe, you'll create some NgRx selectors to show
    users on the **Home** page as well as on the **User Detail** page with similar
    users.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们创建了一个NgRx效果来获取第三方API数据作为用户，并将其保存在Redux存储中。这是我们在这个示例中的起点。我们有一个效果，从`api.randomuser.me`获取用户并将其存储在状态中，目前在**用户界面**（**UI**）上没有显示任何内容。在这个示例中，你将创建一些NgRx选择器，以在**主页**和**用户详细信息**页面上显示相似的用户。
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'The project for this recipe resides in `chapter06/start_here/using-ngrx-selector`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的项目位于`chapter06/start_here/using-ngrx-selector`中：
- en: Open the project in VS Code.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab. As soon as the page is opened,
    you should see the app, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签中打开应用程序。一旦页面打开，你应该能够看到应用程序，如下所示：
- en: '![Figure 6.16 – Using ngrx-selectors app running on http://localhost:4200'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.16 - 在http://localhost:4200上运行的ngrx-selectors应用程序'
- en: '](image/Figure_6.16_B15150.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.16_B15150.jpg)'
- en: Figure 6.16 – Using ngrx-selectors app running on http://localhost:4200
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 - 在http://localhost:4200上运行的ngrx-selectors应用程序
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们在下一节中看看食谱的步骤。
- en: How to do it…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: All we have to do in this recipe is to work with NgRx selectors, the reducer
    we have, and the Redux state in general. Easy peasy. Let's get started!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们所要做的就是使用NgRx选择器、我们已经有的reducer和Redux状态。非常简单。让我们开始吧！
- en: 'We''ll first show the users on the **Home** page and, in order to do that,
    we have to create our first NgRx selecto:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在**主页**上显示用户，并为此创建我们的第一个NgRx选择器：
- en: 'Create a new file inside the `store` folder. Name it `app.selectors.ts` and
    add the following code to it:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`store`文件夹中创建一个新文件。命名为`app.selectors.ts`并添加以下代码：
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we have the selector in place, let's use it in the `HomeComponent`
    class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了选择器，让我们在`HomeComponent`类中使用它。
- en: 'Modify the `ngOnInit` method in the `home.component.ts` file. It should look
    like this:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`home.component.ts`文件中的`ngOnInit`方法。它应该是这样的：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As soon as you refresh the app now, you should be able to see the users. And
    if you click on any one of the users, you''ll navigate to the user details, but
    won''t see any valuable date. The page should look like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在刷新应用程序，你应该能够看到用户。如果你点击任何一个用户，你将导航到用户详情，但看不到任何有价值的数据。页面应该是这样的：
- en: '![Figure 6.17 – Unable to display the current user and similar users'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.17 - 无法显示当前用户和相似用户'
- en: '](image/Figure_6.17_B15150.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.17_B15150.jpg)'
- en: Figure 6.17 – Unable to display the current user and similar users
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 - 无法显示当前用户和相似用户
- en: 'In order to see the current user and similar users, we''ll first create two
    Observables in the `UserDetailComponent` class so that we can subscribe to their
    respective store selectors later on. Add the Observables to the `user-detail.component.ts`
    file, as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看当前用户和相似用户，我们首先在`UserDetailComponent`类中创建两个Observables，以便稍后订阅它们各自的store选择器。在`user-detail.component.ts`文件中添加Observables，如下所示：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Update the `user-detail.component.html` template to use the new Observable
    properties, as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`user-detail.component.html`模板以使用新的Observable属性，如下所示：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Update the `app.selectors.ts` file to add both the selectors, as follows:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`app.selectors.ts`文件以添加两个选择器，如下所示：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since we navigated to the **User Detail** page with the user's **universally
    unique identifier** (**UUID**), we will listen to the active route's `paramsMap`
    and assign the appropriate selectors.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用用户的**通用唯一标识符**（**UUID**）导航到**用户详情**页面，我们将监听活动路由的`paramsMap`并分配适当的选择器。
- en: 'First, add the correct imports to the `user-detail.component.ts` file, as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`user-detail.component.ts`文件中添加正确的导入，如下所示：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, in the same `user-detail.component.ts` file, use the `Store` service and
    update the `ngOnInit` method, as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在相同的`user-detail.component.ts`文件中，使用`Store`服务并更新`ngOnInit`方法，如下所示：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We'll add another method to the `UserDetailComponent` class that'll fetch the
    users if they haven't been fetched already in the app.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`UserDetailComponent`类中添加另一个方法，如果应用程序中还没有获取用户，它将获取用户。
- en: 'Add the `getUsersIfNecessary` method to the `user-detail.component.ts` file,
    as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式向 `user-detail.component.ts` 文件添加 `getUsersIfNecessary` 方法：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Refresh the app… and boom! You now see the current user and similar users as
    well. See the next section to understand how it all works.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新应用程序… 突然！您现在可以看到当前用户和相似用户。请查看下一节以了解它是如何工作的。
- en: How it works…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we already had a reducer and an effect that fetches the third-party
    API data as users. We started by creating a selector for the users for the home
    screen. That was easy—we just needed to create a simple selector. Note that the
    reducer''s state is in the following form:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们已经有了一个 reducer 和一个从第三方 API 获取用户数据的 effect。我们首先创建了一个用于主屏幕用户的选择器。这很容易——我们只需要创建一个简单的选择器。请注意，reducer
    的状态如下所示：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That's why we first used `createFeatureSelector` to fetch the `app` state, and
    then we used `createSelector` to get the `users` state.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们首先使用 `createFeatureSelector` 来获取 `app` 状态，然后使用 `createSelector` 来获取
    `users` 状态。
- en: The hard part was getting the current users and similar users. For that, we
    created selectors that could take the `uuid` as input. Then, we listened to the
    `paramMap` in the `UserDetailComponent` class for the `uuid`, and as soon as it
    changed, we fetched it. We then used it with the selectors by passing the `uuid`
    into them so that the selectors could filter the current user and similar users.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 困难的部分是获取当前用户和相似用户。为此，我们创建了可以以 `uuid` 作为输入的选择器。然后，我们在 `UserDetailComponent` 类中监听
    `paramMap` 的 `uuid`，一旦它发生变化，我们就会获取它。然后，我们通过将 `uuid` 传递给选择器来使用它们，以便选择器可以过滤当前用户和相似用户。
- en: Finally, we had the issue that if someone lands directly on the **User Detail**
    page with the `uuid`, they won't see anything because we wouldn't have fetched
    the users. This is due to the fact that we only fetch the users on the home page,
    so anyone landing directly on a user's detail page wouldn't cause the effect to
    be triggered. That's why we created a method named `getUsersIfNecessary` so that
    it can check the state and fetch the users if they're not already fetched.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们遇到了一个问题，即如果有人直接着陆到**用户详情**页面并带有 `uuid`，他们将看不到任何东西，因为我们没有获取用户。这是因为我们只在主页上获取用户，所以任何直接着陆到用户详情页面的人都不会触发
    effect。这就是为什么我们创建了一个名为 `getUsersIfNecessary` 的方法，以便它可以检查状态并在没有获取用户时获取用户。
- en: See also
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: NgRx selectors documentation ([https://ngrx.io/guide/store/selectors](https://ngrx.io/guide/store/selectors))
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NgRx 选择器文档 ([https://ngrx.io/guide/store/selectors](https://ngrx.io/guide/store/selectors))
- en: Using @ngrx/component-store for local state management within a component
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 @ngrx/component-store 在组件内进行本地状态管理
- en: In this recipe, you'll learn how to use the NgRx Component Store and how to
    use it instead of the push-based Subject/BehaviorSubject pattern with services
    for maintaining a component's state locally.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将学习如何使用 NgRx Component Store，以及如何使用它来代替基于推送的 Subject/BehaviorSubject
    模式与服务一起维护组件的本地状态。
- en: Remember that `@ngrx/component-store` is a stand-alone library and doesn't correlate
    with `Redux` or `@ngrx/store`, and so on.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`@ngrx/component-store` 是一个独立的库，与 `Redux` 或 `@ngrx/store` 等没有关联。
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter06/start_here/ngrx-component-store`,
    inside the cloned repositor:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的项目位于克隆存储库中的 `chapter06/start_here/ngrx-component-store` 目录中：
- en: Open the project in VS Code.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `ng serve -o`。
- en: 'This should open the app in a new browser tab. Log in as Admin and you should
    see it, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序。以管理员身份登录，您应该能看到它，如下所示：
- en: '![Figure 6.18 – ngrx-component-store app running on http://localhost:4200'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.18 - ngrx-component-store应用程序运行在http://localhost:4200'
- en: '](image/Figure_6.18_B15150.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.18_B15150.jpg)'
- en: Figure 6.18 – ngrx-component-store app running on http://localhost:4200
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 - ngrx-component-store应用程序运行在http://localhost:4200
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们在下一节中看一下这个配方的步骤。
- en: How to do it…
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have our favorite bucket app that we''ve used in a lot of recipes so far.
    The state of the buckets right now is stored in the `BucketService`, which uses
    a `BehaviorSubject` pattern. We''re going to replace it with the NgRx Component
    Store. Let''s begin:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在许多配方中使用了我们喜爱的桶应用程序。目前桶的状态存储在`BucketService`中，它使用了`BehaviorSubject`模式。我们将用NgRx
    Component Store替换它。让我们开始吧：
- en: 'Add the `@ngrx/component-store` package to the project''s dependencies by running
    the following command in the project root:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在项目根目录中运行以下命令，将`@ngrx/component-store`包添加到项目的依赖项中：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We first have to make our `BucketService` compatible with a `ComponentStore`.
    In order to do that, we''ll create an interface for the bucket state, extend the
    `BucketService` from `ComponentStore`, and initialize the service by calling the
    `super` method. Update the `file services/bucket.service.ts` file, as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先要使我们的`BucketService`与`ComponentStore`兼容。为了做到这一点，我们将为桶状态创建一个接口，将`BucketService`从`ComponentStore`扩展，并通过调用`super`方法来初始化服务。更新`file
    services/bucket.service.ts`文件，如下所示：
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: None of this will make sense until we actually show the data from the `ComponentStore`.
    Let's work on that now.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际显示`ComponentStore`中的数据之前，这一切都没有意义。现在让我们来做这件事。
- en: 'Modify the `bucket$` Observable to use the `ComponentStore` state rather than
    relying on the `BehaviorSubject` pattern, as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`bucket$` Observable，使用`ComponentStore`状态，而不是依赖于`BehaviorSubject`模式，如下所示：
- en: '[PRE30]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You should potentially see that none of the bucket items show anymore, or that
    even if you add an item, it won't show. That's because it still requires some
    work.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够看到没有桶项目显示了，或者即使你添加了一个项目，它也不会显示。这是因为它仍然需要一些工作。
- en: 'First, let''s make sure that instead of initializing the `bucket` from the
    Component Store with an empty array, we initialize it with the values from `localStorage`.
    Just try adding a few items, even if they don''t show up yet. Then, modify the
    `loadItems()` method to use the `setState` method on `BucketService`. The code
    should look like this:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们确保不是用空数组从组件存储中初始化`bucket`，而是用`localStorage`中的值来初始化它。即使它们还没有显示出来，也试着添加一些项目。然后，修改`loadItems()`方法，使用`BucketService`上的`setState`方法。代码应该如下所示：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that we've removed the `this.bucketSource.next(bucket);` line from the
    code. This is because we're not going to work with the `bucketSource` property
    anymore, which is a `BehaviorSubject` pattern. We'll do the same for the next
    set of functions.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经从代码中删除了`this.bucketSource.next(bucket);`行。这是因为我们不再使用`bucketSource`属性，它是一种`BehaviorSubject`模式。我们将对下一组函数执行相同的操作。
- en: Also, you should now see the items that you added previously and that weren't
    shown.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你现在应该能够看到之前添加的项目，但没有显示出来。
- en: 'Let''s replace the `addItem` method in the `BucketService` now so that it updates
    the state correctly and shows the new items on view, as intended. For this, we''ll
    use the `updater` method of the `ComponentStore` and modify our `addItem` method
    to be an updater, as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们替换`BucketService`中的`addItem`方法，以便它可以正确更新状态并显示新的项目在视图中，如我们所期望的那样。为此，我们将使用`ComponentStore`的`updater`方法，并修改我们的`addItem`方法为一个更新器，如下所示：
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you add an item now, you should see it appearing on the view.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在添加一个项目，你应该能够在视图中看到它。
- en: 'We can now replace the `removeItem` method as well to be an `updater` method
    in the `BucketService` as well. The code should look like this:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在也可以将`BucketService`中的`removeItem`方法替换为`updater`方法。代码应该如下所示：
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this change, you should see the app working. But we do have an issue to
    fix, and that is that the `EmployeeService` also needs to be updated to make the
    `removeItem` method an `updater` method.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个改变，您应该看到应用程序正在工作。但是我们确实有一个需要解决的问题，那就是`EmployeeService`也需要更新，使`removeItem`方法成为`updater`方法。
- en: 'Let''s replace the `removeItem` method in the `EmployeeBucketService` to be
    an `updater` method as well. Modify the `employee/services/employee-bucket.service.ts`
    file, as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`EmployeeBucketService`中的`removeItem`方法替换为`updater`方法。修改`employee/services/employee-bucket.service.ts`文件如下：
- en: '[PRE34]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And voilà! Everything should actually be fine right now, and you shouldn't see
    any errors.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 而且！现在一切应该都很好，您不应该看到任何错误。
- en: 'Since we''ve got rid of all usages of the `BehaviorSubject` pattern in the
    `BucketService` property named `bucketSource`, we can remove the property itself
    from the `BucketService`. The final code should look like this:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经摆脱了`BucketService`属性`bucketSource`中`BehaviorSubject`模式的所有用法，我们可以从`BucketService`中删除该属性本身。最终代码应该如下所示：
- en: '[PRE35]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Congratulations! You finished the recipe. See the next section to understand
    how it works.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已完成该教程。请查看下一节以了解其工作原理。
- en: How it works…
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As mentioned earlier, `@ngrx/component-store` is a standalone package that can
    easily be installed in your Angular apps without having to use `@ngrx/store`,
    `@ngrx/effects`, and so on. It is supposed to replace the usage of `BehaviorSubject`
    in Angular services, and that's what we did in this recipe. We covered how to
    initialize a `ComponentStore` and how to set the initial state using the `setState`
    method when we already had the values without accessing the state, and we learned
    how to create `updater` methods that can be used to update the state, as they
    can access the state and allow us to even pass arguments for our own use cases.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`@ngrx/component-store`是一个独立的包，可以轻松安装在您的Angular应用程序中，而无需使用`@ngrx/store`、`@ngrx/effects`等。它应该替换Angular服务中`BehaviorSubject`的使用方式，这就是我们在本教程中所做的。我们介绍了如何初始化`ComponentStore`以及如何使用`setState`方法设置初始状态，当我们已经有值而无需访问状态时，我们学会了如何创建`updater`方法，它们可以用于更新状态，因为它们可以访问状态并允许我们甚至为我们自己的用例传递参数。
- en: See also
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '`@ngrx/component-store` documentation ([https://ngrx.io/guide/component-store](https://ngrx.io/guide/component-store))'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/component-store`文档（[https://ngrx.io/guide/component-store](https://ngrx.io/guide/component-store)）'
- en: Effects in `@ngrx/component-store` documentation ([https://ngrx.io/guide/component-store/effect](https://ngrx.io/guide/component-store/effect))
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/component-store`文档中的Effects（[https://ngrx.io/guide/component-store/effect](https://ngrx.io/guide/component-store/effect)）'
- en: Using @ngrx/router-store to work with route changes reactively
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@ngrx/router-store来以响应式方式处理路由更改
- en: NgRx is awesome because it allows you to have your data stored in a centralized
    place. However, listening to route changes is still something that is out of the
    NgRx scope for what we've covered so far. We did rely on the `ActivatedRoute`
    service to watch for route changes, and when we want to test such components,
    the `ActivatedRoute` service becomes a dependency. In this recipe, you'll install
    the `@ngrx/router-store` package and will learn how to listen to the route changes
    using some actions built into the package.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx很棒，因为它允许您将数据存储在一个集中的位置。然而，监听路由更改仍然是我们目前所涵盖的NgRx范围之外的事情。我们确实依赖于`ActivatedRoute`服务来监听路由更改，当我们想要测试这样的组件时，`ActivatedRoute`服务就成了一个依赖项。在本教程中，您将安装`@ngrx/router-store`包，并学习如何使用该包中内置的一些操作来监听路由更改。
- en: Getting ready
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter06/start_here/ngrx-router-store`,
    inside the cloned repositor:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的项目位于`chapter06/start_here/ngrx-router-store`中，位于克隆存储库内：
- en: Open the project in VS Code.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see something
    like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签页中打开应用程序，你应该会看到类似这样的东西：
- en: '![Figure 6.19 – ngrx-router-store app running on http://localhost:4200'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.19 - ngrx-router-store应用程序运行在http://localhost:4200'
- en: '](image/Figure_6.19_B15150.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.19_B15150.jpg)'
- en: Figure 6.19 – ngrx-router-store app running on http://localhost:4200
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 - ngrx-router-store应用程序运行在http://localhost:4200
- en: Now that the app is running, see the next section for the steps of the recipe.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序正在运行，请查看下一节的步骤。
- en: How to do it…
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: In order to utilize the power of NgRx even for route changes, we'll utilize
    the `@ngrx/router-store` package to listen to route changes. Let's begin!
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用NgRx甚至对路由更改的强大功能，我们将利用`@ngrx/router-store`包来监听路由更改。让我们开始吧！
- en: 'First, install the `@ngrx/router-store` package by running the following command
    in your project root:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在项目根目录中运行以下命令安装`@ngrx/router-store`包：
- en: '[PRE36]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, import `StoreRouterConnectingModule` and `routerReducer` from the `@ngrx/router-store`
    package in your `app.module.ts` file and set up the `imports`, as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你的`app.module.ts`文件中导入`StoreRouterConnectingModule`和`routerReducer`，并设置`imports`，如下所示：
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As soon as you refresh the app now and inspect it via the Redux DevTools extension,
    you should see some additional actions named `@ngrx/router-store/*` being dispatched
    as well. You should also see that the `router` property in the state has the current
    routes'' information, as depicted in the following screenshot:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在刷新应用程序并通过Redux DevTools扩展进行检查，你应该还会看到一些额外的名为`@ngrx/router-store/*`的操作被分发。你还应该看到状态中的`router`属性具有当前路由的信息，如下截图所示：
- en: '![Figure 6.20 – @ngrx/router-store actions and the router state reflected in
    the NgRx store'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.20 - @ngrx/router-store操作和路由器状态在NgRx存储中的反映'
- en: '](image/Figure_6.20_B15150.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.20_B15150.jpg)'
- en: Figure 6.20 – @ngrx/router-store actions and the router state reflected in the
    NgRx store
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20 - @ngrx/router-store操作和路由器状态在NgRx存储中的反映
- en: 'We now have to modify our reducer—or, more precisely, the `AppState` interface—to
    reflect that we have the `router` property as well from the `@ngrx/router-store`
    package. To do so, modify the `store/app.reducer.ts` file, as follows:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在必须修改我们的reducer，或者更准确地说，修改`AppState`接口，以反映我们还有来自`@ngrx/router-store`包的`router`属性。为此，请修改`store/app.reducer.ts`文件，如下所示：
- en: '[PRE38]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Essentially, we have to get rid of the `ActivatedRoute` service''s usage from
    our `UserDetailComponent` class. In order to do so, we''ll first modify our selectors
    to get the params from the router state directly. Modify the `app.selectors.ts`
    file, as follows:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本上，我们必须摆脱`UserDetailComponent`类中对`ActivatedRoute`服务的使用。为了做到这一点，我们首先修改我们的选择器，直接从路由器状态中获取参数。修改`app.selectors.ts`文件，如下所示：
- en: '[PRE39]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You should see some errors on the console right now. That's because we changed
    the signature of the `selectSimilarUsers` and `selectCurrentUser` selectors, but
    it'll be fixed in the next step.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该在控制台上看到一些错误。那是因为我们改变了`selectSimilarUsers`和`selectCurrentUser`选择器的签名，但它将在下一步中被修复。
- en: 'Modify the `user-detail/user-detail.component.ts` file to use the updated selectors
    correctly, as follows:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`user-detail/user-detail.component.ts`文件以正确使用更新后的选择器，如下所示：
- en: '[PRE40]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This change should have resolved the errors on the console, and you should actually
    see the app working perfectly fine, even though we're not passing any `uuid` from
    the `UserDetailComponent` class anymore.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改应该已经解决了控制台上的错误，你应该能够看到应用程序完美地运行，即使我们不再从`UserDetailComponent`类中传递任何`uuid`。
- en: 'With the changes from the previous step, we can now safely remove the usage
    of the `ActivatedRoute` service from the `UserDetailComponent` class, and the
    code should now look like this:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过上一步的更改，我们现在可以安全地从`UserDetailComponent`类中删除`ActivatedRoute`服务的使用，代码现在应该是这样的：
- en: '[PRE41]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Woohoo! You've finished the recipe now. See the next section to find out how
    this works.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！你现在已经完成了这个食谱。查看下一节，了解这是如何运作的。
- en: How it works…
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`@ngrx/router-store` is an amazing package that does a lot of magic to make
    our development a lot easier with NgRx. You saw how we could remove the `ActivatedRoute`
    service completely from the `UserDetailComponent` class by using the selectors
    from the package. Essentially, this helped us get the **route params** right in
    the selectors, and we could use it in our selectors to get and filter out the
    appropriate data. Behind the scenes, the package listens to the route changes
    in the entire Angular app and fetches from the route itself. It then stores the
    respective information in the NgRx Store so that it remains in the Redux state
    and can be selected via the package-provided selectors easily. In my opinion,
    it''s freaking awesome! I say this because the package is doing all the heavy
    lifting that we would have to do otherwise. As a result, our `UserDetailComponent`
    class now relies only on the `Store` service, which makes it even easier to test
    because of fewer dependencies.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ngrx/router-store`是一个了不起的包，它通过许多魔法使我们在NgRx中的开发变得更加容易。你看到了我们如何通过使用该包中的选择器，完全删除了`UserDetailComponent`类中的`ActivatedRoute`服务。基本上，这帮助我们在选择器中正确获取**路由参数**，并且我们可以在选择器中使用它来获取和过滤出适当的数据。在幕后，该包监听整个Angular应用程序中的路由更改，并从路由本身获取数据。然后将相应的信息存储在NgRx
    Store中，以便它保留在Redux状态中，并且可以通过该包提供的选择器轻松选择。在我看来，这太棒了！我这么说是因为该包正在做我们否则必须做的所有繁重工作。因此，我们的`UserDetailComponent`类现在只依赖于`Store`服务，这使得测试变得更加容易，因为依赖更少。'
- en: See also
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '`@ngrx/router-store` documentation ([https://ngrx.io/guide/router-store/](https://ngrx.io/guide/router-store/))'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/router-store`文档（[https://ngrx.io/guide/router-store/](https://ngrx.io/guide/router-store/)）'
