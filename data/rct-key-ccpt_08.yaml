- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Handling Side Effects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理副作用
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下几件事情：
- en: Identify side effects in your React apps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别你的 React 应用程序中的副作用
- en: Understand and use the `useEffect()` Hook
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和使用 `useEffect()` 钩子
- en: Utilize the different features and concepts related to the `useEffect()` Hook
    to avoid bugs and optimize your code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用与 `useEffect()` 钩子相关的不同特性和概念，以避免错误并优化你的代码
- en: Handle side effects related and unrelated to state changes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理与状态变化相关和无关的副作用
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: While all React examples previously covered in this book have been relatively
    straightforward, and many key React concepts were introduced, it is unlikely that
    many real apps could be built with those concepts alone.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书之前涵盖的所有 React 示例都相对简单，并且介绍了许多关键 React 概念，但仅凭这些概念很难构建出许多真实的应用程序。
- en: Most real apps that you will build as a React developer also need to send HTTP
    requests, access the browser storage and log analytics data, or perform any other
    kind of similar task, and with components, props, events, and state alone, you’ll
    often encounter problems when trying to add such features to your app. Detailed
    explanations and examples will be discussed later in this chapter, but the core
    problem is that tasks like this will often interfere with React’s component rendering
    cycle, leading to unexpected bugs or even breaking the app.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你作为 React 开发者将构建的大多数真实应用程序也需要发送 HTTP 请求，访问浏览器存储和日志分析数据，或执行任何其他类似任务，而仅凭组件、属性、事件和状态，你通常在尝试向应用程序添加此类功能时会遇到问题。详细的解释和示例将在本章后面讨论，但核心问题是这类任务通常会干扰
    React 的组件渲染周期，导致意外的错误，甚至破坏应用程序。
- en: This chapter will take a closer look at those kinds of actions, analyze what
    they have in common, and most importantly, teach you how to correctly handle such
    tasks in React apps.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将更深入地探讨这类操作，分析它们的共同点，最重要的是，教你如何在 React 应用程序中正确处理这类任务。
- en: What’s the Problem?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题是什么？
- en: Before exploring a solution, it’s important to first understand the concrete
    problem.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索解决方案之前，首先理解具体问题是重要的。
- en: Actions that are not directly related to producing a (new) user interface state
    often clash with React’s component rendering cycle. They may introduce bugs or
    even break the entire web app.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与生成（新）用户界面状态无关的操作通常与 React 的组件渲染周期冲突。它们可能会引入错误，甚至破坏整个 Web 应用程序。
- en: 'Consider the following example code snippet (important: don’t execute this
    code as it will cause an infinite loop and send a large number of HTTP requests
    behind the scenes):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例代码片段（重要：不要执行此代码，因为它将导致无限循环并在幕后发送大量 HTTP 请求）：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So what’s the problem with this code? Why does it create an infinite loop?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这段代码有什么问题？为什么它会创建一个无限循环？
- en: In this example, a React component ( `BlogPosts` ) is created. In addition,
    a non-component function ( `fetchPosts()` ) is defined. That function uses the
    built-in `fetch()` function (provided by the browser) to send an HTTP request
    to an external **application programming interface** ( **API** ) and fetch some
    data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，创建了一个 React 组件（`BlogPosts`）。此外，还定义了一个非组件函数（`fetchPosts()`）。该函数使用浏览器提供的内置
    `fetch()` 函数发送 HTTP 请求到外部 **应用程序编程接口**（**API**）并获取一些数据。
- en: '**Note**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The `fetch()` function is made available by the browser (all modern browsers
    support this function). You can learn more about `fetch()` at [https://academind.com/tutorials/xhr-fetch-axios-the-fetch-api](https://academind.com/tutorials/xhr-fetch-axios-the-fetch-api)
    .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` 函数由浏览器提供（所有现代浏览器都支持此功能）。你可以在[https://academind.com/tutorials/xhr-fetch-axios-the-fetch-api](https://academind.com/tutorials/xhr-fetch-axios-the-fetch-api)了解更多关于
    `fetch()` 的信息。'
- en: The `fetch()` function yields a **promise** , which, in this example, is handled
    via `async` / `await` . Just like `fetch()` , promises are a key web development
    concept, which you can learn more about (along with `async` / `await` ) at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
    .
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` 函数返回一个 **promise**，在这个例子中，它通过 `async` / `await` 来处理。就像 `fetch()`
    一样，promises 是一个关键的 Web 开发概念，你可以在这里了解更多信息（包括 `async` / `await`）：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)。'
- en: An API, in this context, is a site that exposes various paths to which requests
    can be sent—either to submit or to fetch data. [jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)
    is a dummy API, responding with dummy data. It can be used in scenarios like the
    preceding example, where you just need an API to send requests to. You can use
    it to test some concept or code without connecting or creating a real backend
    API. In this case, it’s used to explore some React problems and concepts. Basic
    knowledge about sending HTTP requests with `fetch()` and APIs is expected for
    this chapter and the book overall. If needed, you can use pages such as MDN (
    [https://developer.mozilla.org/](https://developer.mozilla.org/) ) to strengthen
    your knowledge of such core concepts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，API 是一个公开各种路径的网站，可以发送请求——无论是提交还是获取数据。[jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)
    是一个模拟 API，响应模拟数据。它可以用于像前面的例子那样的场景，你只需要一个 API 来发送请求。你可以用它来测试一些概念或代码，而无需连接或创建真实的后端
    API。在这种情况下，它被用来探索一些 React 问题和解。对于本章和本书整体，预期你将具备使用 `fetch()` 发送 HTTP 请求和了解 API
    的基本知识。如果需要，你可以使用 MDN（[https://developer.mozilla.org/](https://developer.mozilla.org/)）等页面来加强你对这些核心概念的了解。
- en: In the preceding code snippet, the `BlogPosts` component utilizes `useState()`
    to register a `loadedPosts` state value. The state is used to output a list of
    blog posts. Those blog posts are not defined in the app itself though. Instead,
    they are fetched from the external API mentioned in the note box.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`BlogPosts` 组件使用 `useState()` 注册了一个 `loadedPosts` 状态值。这个状态用于输出一系列博客帖子。尽管这些帖子并没有在应用本身中定义，而是从注释框中提到的外部
    API 中获取的。
- en: '`fetchPosts()` , which is the utility function that contains the code for fetching
    blog posts data from that backend API using the built-in `fetch()` function, is
    called directly in the component function body. Since `fetchPosts()` is an `async`
    function (using `async` / `await` ), it returns a promise. In `BlogPosts` , the
    code that should be executed once the promise resolves is registered via the built-in
    `then()` method.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchPosts()`，这是一个包含使用内置 `fetch()` 函数从后端 API 获取博客帖子数据的代码的实用函数，在组件函数体中被直接调用。由于
    `fetchPosts()` 是一个 `async` 函数（使用 `async` / `await`），它返回一个承诺。在 `BlogPosts` 中，一旦承诺解决，应该执行的代码是通过内置的
    `then()` 方法注册的。'
- en: '**Note**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '`async` / `await` is not used directly in the component function body because
    regular React components must not be `async` functions. Such functions automatically
    return a promise as a value (even without an explicit `return` statement), which
    is an invalid return value for a React component.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` / `await` 不会直接在组件函数体中使用，因为常规的 React 组件不能是 `async` 函数。这样的函数会自动返回一个承诺作为值（即使没有显式的
    `return` 语句），这对于 React 组件来说是一个无效的返回值。'
- en: That being said, there are indeed React components that are allowed to use `async`
    / `await` and return a promise. So-called **React Server Components** are not
    restricted to returning JSX code, strings, etc. This feature will be discussed
    in detail in *Chapter 16* , *React Server Components & Server Actions* .
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，确实存在允许使用 `async` / `await` 并返回承诺的 React 组件。所谓的 **React 服务器组件** 并不局限于返回
    JSX 代码、字符串等。这一特性将在 *第 16 章* ，*React 服务器组件与服务器操作* 中详细讨论。
- en: Once the `fetchPosts()` promise resolves, the extracted posts data ( `fetchedPosts`
    ) is set as the new `loadedPosts` state (via `setLoadedPosts(fetchedPosts)` ).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `fetchPosts()` 的承诺得到解决，提取的帖子数据（`fetchedPosts`）就被设置为新的 `loadedPosts` 状态（通过
    `setLoadedPosts(fetchedPosts)`）。
- en: If you were to run the preceding code (which you should not do!), it would at
    first seem to work. But behind the scenes, it would actually start an infinite
    loop, hammering the API with HTTP requests. This is because, as a result of getting
    a response from the HTTP request, `setLoadedPosts()` is used to set a new state.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码（你不应该这样做！），它最初似乎可以工作。但实际上，它会在幕后启动一个无限循环，不断地用 HTTP 请求打击 API。这是因为，由于从
    HTTP 请求中得到了响应，`setLoadedPosts()` 被用来设置新的状态。
- en: Earlier in this book (in *Chapter 4* , *Working with Events and State* ), you
    learned that whenever the state of a component changes, React re-evaluates the
    component to which the state belongs. “Re-evaluating” simply means that the component
    function is executed again (by React, automatically).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期（在第 *第 4 章* ，*处理事件和状态* 中），你了解到每当组件的状态发生变化时，React 会重新评估该状态所属的组件。“重新评估”简单来说就是组件函数再次被执行（由
    React 自动执行）。
- en: Since this `BlogPosts` component calls `fetchPosts()` (which sends an HTTP request)
    directly inside the component function body, this HTTP request will be sent every
    time the component function is executed. And as the state ( `loadedPosts` ) is
    updated as a result of getting a response from that HTTP request, this process
    begins again, and an infinite loop is created.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个`BlogPosts`组件在组件函数体内直接调用`fetchPosts()`（它发送HTTP请求），因此每次执行组件函数时都会发送这个HTTP请求。并且由于从该HTTP请求中获取响应而更新状态（`loadedPosts`），这个过程再次开始，从而创建了一个无限循环。
- en: The root problem, in this case, is that sending an HTTP request is a side effect—a
    concept that will be explored in greater detail in the next section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，根本问题是发送HTTP请求是一个副作用——一个将在下一节中更详细探讨的概念。
- en: Understanding Side Effects
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解副作用
- en: Side effects are actions or processes that occur in addition to another *main
    process* . At least, this is a concise definition that helps with understanding
    side effects in the context of a React app.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用是指除了另一个*主要过程*之外发生的动作或过程。至少，这是一个简洁的定义，有助于在React应用程序的上下文中理解副作用。
- en: '**Note**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'If you want to dive deeper into the concept of *side effects* , you can also
    explore the following discussion about side effects on Stack Overflow: [https://softwareengineering.stackexchange.com/questions/40297/what-is-a-side-effect](https://softwareengineering.stackexchange.com/questions/40297/what-is-a-side-effect)
    .'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解*副作用*的概念，你还可以探索Stack Overflow上的以下关于副作用的讨论：[https://softwareengineering.stackexchange.com/questions/40297/what-is-a-side-effect](https://softwareengineering.stackexchange.com/questions/40297/what-is-a-side-effect)
    。
- en: In the case of a React component, the main process would be the component render
    cycle in which the main task of a component is to render the user interface that
    is defined in the component function (the returned JSX code). The React component
    should return the final JSX code, which is then translated into DOM-manipulating
    instructions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在React组件的情况下，主过程将是组件渲染周期，其中组件的主要任务是渲染在组件函数中定义的用户界面（返回的JSX代码）。React组件应该返回最终的JSX代码，然后将其转换为DOM操作指令。
- en: For this, React considers state changes as the trigger for updating the user
    interface. Registering event handlers such as `onClick` , adding refs, or rendering
    child components (possibly by using props) would be other elements that belong
    to this main process—because all these concepts are directly related to the main
    task of rendering the desired user interface.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，React将状态变化视为更新用户界面的触发器。注册事件处理器（如`onClick`）、添加refs或渲染子组件（可能通过使用props）将是属于这个主过程的另一个元素——因为这些概念都与渲染所需用户界面的主要任务直接相关。
- en: Sending an HTTP request, as in the preceding example, is not part of this main
    process, though. It doesn’t directly influence the user interface. While the response
    data might eventually be output on the screen, it definitely won’t be used in
    the exact same component render cycle in which the request is sent (because HTTP
    requests are asynchronous tasks).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前例所示，发送HTTP请求并不属于这个主过程，它不会直接影响用户界面。虽然响应数据最终可能会显示在屏幕上，但它肯定不会在发送请求的同一个组件渲染周期中被使用（因为HTTP请求是异步任务）。
- en: Since sending the HTTP request is not part of the main process (rendering the
    user interface) that’s performed by the component function, it’s considered a
    side effect. It’s invoked by the same function (the `BlogPosts` component function),
    which primarily has a different goal.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于发送HTTP请求不是由组件函数（渲染用户界面）执行的主过程的一部分，因此它被认为是副作用。它是由同一个函数（`BlogPosts`组件函数）调用的，而这个函数的主要目标不同。
- en: 'If the HTTP request were sent upon a click of a button rather than as part
    of the main component function body, it would not be a side effect. Consider this
    example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTTP请求是在点击按钮时发送，而不是作为主组件函数体的一部分，那么它就不会是副作用。考虑以下示例：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code is almost identical to the previous example, but it has one important
    difference: a `<button>` was added to the JSX code. And it’s this button that
    invokes a newly added `handleFetchPosts()` function, which then sends the HTTP
    request (and updates the state).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码几乎与前一个示例相同，但它有一个重要的区别：JSX代码中添加了一个`<button>`。正是这个按钮调用了新添加的`handleFetchPosts()`函数，然后发送HTTP请求（并更新状态）。
- en: With this change made, the HTTP request is *not* sent every time the component
    function re-renders (that is, is executed again). Instead, it’s only sent whenever
    the button is clicked, and therefore, this does not create an infinite loop. The
    HTTP request, in this case, also doesn’t postulate a side effect, because the
    primary goal of `handleFetchPosts()` (i.e., the main process) is to fetch new
    posts and update the state.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 进行了此更改后，每次组件函数重新渲染（即，再次执行）时，都不会发送 HTTP 请求。相反，只有在按钮被点击时才会发送，因此，这不会创建无限循环。在这种情况下，HTTP
    请求也不假设存在副作用，因为 `handleFetchPosts()`（即，主要过程）的主要目标是获取新帖子并更新状态。
- en: Side Effects Are Not Just about HTTP Requests
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 副作用不仅仅是关于 HTTP 请求
- en: 'In the previous example, you learned about one potential side effect that could
    occur in a component function: an HTTP request. You also learned that HTTP requests
    are not always side effects. It depends on where they are created.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，你了解到了组件函数中可能发生的一种潜在副作用：HTTP 请求。你也了解到 HTTP 请求并不总是副作用，这取决于它们是在哪里创建的。
- en: In general, any action that’s started upon the execution of a React component
    function is a side effect if that action is not directly related to the main task
    of rendering the component’s user interface.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，任何在执行 React 组件函数时启动的动作，如果该动作与渲染组件用户界面的主要任务没有直接关系，则是一个副作用。
- en: 'Here’s a non-exhaustive list of examples of side effects:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个副作用示例的非详尽列表：
- en: Sending an HTTP request (as shown previously)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送 HTTP 请求（如前所述）
- en: Storing data to or fetching data from browser storage (for example, via the
    built-in `localStorage` object)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据存储到或从浏览器存储中获取数据（例如，通过内置的 `localStorage` 对象）
- en: Setting timers (via `setTimeout()` ) or intervals (via `setInterval()` )
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置定时器（通过 `setTimeout()`）或间隔（通过 `setInterval()`）
- en: Logging data to the console via `console.log()`
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `console.log()` 将数据记录到控制台
- en: Not all side effects cause infinite loops, however. Such loops only occur if
    the side effect leads to a state update.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有副作用都会导致无限循环。只有当副作用导致状态更新时，才会发生这样的循环。
- en: 'Here’s an example of a side effect that would not cause an infinite loop:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个不会导致无限循环的副作用示例：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, `console.log(…)` is a side effect because it’s executed as
    part of every component function execution and does not influence the rendered
    user interface (neither for this specific render cycle nor indirectly for any
    future render cycles in this case, unlike the previous example with the HTTP request).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`console.log(…)` 是一个副作用，因为它作为每个组件函数执行的一部分执行，并且不会影响渲染的用户界面（在这种情况下，既不是针对这个特定的渲染周期，也不是间接地针对任何未来的渲染周期，与之前带有
    HTTP 请求的例子不同）。
- en: Of course, using `console.log()` like this is not causing any problems. During
    development, it’s quite normal to log messages or data for debugging purposes.
    Side effects aren’t necessarily a problem and, indeed, side effects like this
    can be used or tolerated.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，像这样使用 `console.log()` 不会引起任何问题。在开发过程中，为了调试目的记录消息或数据是非常正常的。副作用并不一定是问题，实际上，这种副作用可以被使用或容忍。
- en: But you also often need to deal with side effects such as the HTTP request from
    before. Sometimes, you need to fetch data when a component renders—probably not
    for every render cycle, but typically the first time it is executed (that is,
    when its generated user interface appears on the screen for the first time).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但你也经常需要处理如之前所述的 HTTP 请求等副作用。有时，当组件渲染时需要获取数据——可能不是每个渲染周期，但通常是第一次执行时（即，当其生成的用户界面首次出现在屏幕上时）。
- en: React offers a solution for this kind of problem as well.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: React 也为此类问题提供了一个解决方案。
- en: Dealing with Side Effects with the useEffect() Hook
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 useEffect() Hook 处理副作用
- en: 'In order to deal with side effects such as the HTTP request shown previously
    in a safe way (that is, without creating an infinite loop), React offers another
    core Hook: the `useEffect()` Hook.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以安全的方式（即，不创建无限循环）处理如前所述的 HTTP 请求等副作用，React 提供了另一个核心 Hook：`useEffect()` Hook。
- en: 'The first example can be fixed and rewritten like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子可以修复并重写如下：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, the `useEffect()` Hook is imported and used to control the
    side effect (hence the name of the Hook, `useEffect()` , as it deals with side
    effects in React components). The exact syntax and usage will be explored in the
    next section, but if you use this Hook, you can safely run the example and get
    some output like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，导入了 `useEffect()` 钩子并使用它来控制副作用（因此钩子的名字叫 `useEffect()`，因为它处理 React 组件中的副作用）。确切的语法和用法将在下一节中探讨，但如果你使用这个钩子，你可以安全地运行示例并得到一些类似以下的输出：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_08_01.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B31339_08_01.png)'
- en: 'Figure 8.1: A list of dummy blog posts and no infinite loop of HTTP requests'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：一组示例博客文章列表，没有无限循环的 HTTP 请求
- en: In the preceding screenshot, you can see the list of dummy blog post titles,
    and most importantly, when inspecting the sent network requests, you find no infinite
    list of requests.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到示例博客文章标题的列表，最重要的是，在检查发送的网络请求时，你找不到无限请求列表。
- en: '`useEffect()` is therefore the solution for problems like the one outlined
    previously. It helps you deal with side effects so that you can avoid infinite
    loops and extract them from your component function’s main process.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`useEffect()` 是解决之前概述的问题的解决方案。它帮助你处理副作用，以便你可以避免无限循环并将它们从组件函数的主要流程中提取出来。
- en: But how does `useEffect()` work, and how is it used correctly?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `useEffect()` 是如何工作的，以及如何正确使用它？
- en: How to Use useEffect()
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用 useEffect()
- en: As shown in the previous example code snippet, `useEffect()` , like all React
    Hooks, is executed as a function inside the component function ( `BlogPosts` ,
    in this case).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例代码片段所示，`useEffect()`，像所有 React 钩子一样，作为组件函数（在这种情况下是 `BlogPosts`）内部的一个函数执行。
- en: Although, unlike `useState()` or `useRef()` , `useEffect()` does not return
    a value, though it does accept an argument (or, actually, two arguments) like
    those other Hooks. The first argument is *always* a function. In this case, the
    function passed to `useEffect()` is an anonymous function, created via the `function`
    keyword.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然，与 `useState()` 或 `useRef()` 不同，`useEffect()` 不返回值，尽管它接受一个参数（或者实际上，两个参数）像那些其他钩子一样。第一个参数
    *总是* 一个函数。在这种情况下，传递给 `useEffect()` 的函数是一个匿名函数，通过 `function` 关键字创建的。
- en: Alternatively, you could also provide an anonymous function created as an arrow
    function ( `useEffect(() => { … })` ) or point at some named function ( `useEffect(doSomething)`
    ). The only thing that matters is that the first argument passed to `useEffect()`
    *must* be a function. It must not be any other kind of value.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以提供一个作为箭头函数创建的匿名函数（`useEffect(() => { … })`）或指向某个命名函数（`useEffect(doSomething)`）。唯一重要的是，传递给
    `useEffect()` 的第一个参数 *必须* 是一个函数。它不能是任何其他类型的值。
- en: 'In the preceding example, `useEffect()` also receives a second argument: an
    empty array ( `[]` ). The second argument must be an array, but providing it is
    *optional* . You could also omit the second argument and just pass the first argument
    (the function) to `useEffect()` . However, in most cases, the second argument
    is needed to achieve the correct behavior. Both arguments and their purpose will
    be explored in greater detail as follows.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`useEffect()` 还接收第二个参数：一个空数组（`[]`）。第二个参数必须是一个数组，但提供它是 *可选的*。你也可以省略第二个参数，只传递第一个参数（函数）给
    `useEffect()`。然而，在大多数情况下，第二个参数是必要的，以实现正确的行为。以下将更详细地探讨这两个参数及其用途。
- en: The first argument is a function that will be executed by React. It will be
    executed *after* every component render cycle (that is, after every component
    function execution).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个函数，它将由 React 执行。它将在每个组件渲染周期之后执行（即，在每个组件函数执行之后）。
- en: 'In the preceding example, if you only provide this first argument and omit
    the second, you will therefore still create an infinite loop. There will be an
    (invisible) timing difference because the HTTP request will now be sent after
    every component function execution (instead of as part of it), but you will still
    trigger a state change, which will still trigger the component function to execute
    again. Therefore, the effect function will run again, and an infinite loop will
    be created. In this case, the side effect will be extracted out of the component
    function technically, but the problem with the infinite loop will not be solved:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果你只提供这个第一个参数并省略第二个，你仍然会创建一个无限循环。由于HTTP请求现在将在每次组件函数执行后发送（而不是作为它的一部分），因此会有一个（不可见的）时间差，但你仍然会触发状态变化，这仍然会触发组件函数再次执行。因此，效果函数将再次运行，并创建一个无限循环。在这种情况下，副作用在技术上是从组件函数中提取出来的，但无限循环的问题并没有得到解决：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Extracting side effects out of React component functions is the main job of
    `useEffect()` , and so only the first argument (the function that contains the
    side effect code) is mandatory. But, as mentioned previously, you will also typically
    need the second argument to control the frequency with which the effect code will
    be executed, because that’s what the second argument (an array) will do.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将副作用从React组件函数中提取出来是`useEffect()`的主要任务，因此只有第一个参数（包含副作用代码的函数）是必需的。但是，如前所述，你通常还需要第二个参数来控制效果代码执行的频率，因为这就是第二个参数（一个数组）的作用。
- en: 'The second parameter received by `useEffect()` is *always* an array (unless
    it’s omitted). This array specifies the dependencies of the effect function. Any
    dependency specified in this array will, once it changes, cause the effect function
    to execute again. If no array is specified (that is, if the second argument is
    omitted), the effect function will be executed again for every component function
    execution:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect()`接收到的第二个参数*总是*一个数组（除非省略）。这个数组指定了效果函数的依赖项。任何在这个数组中指定的依赖项，一旦它发生变化，就会导致效果函数再次执行。如果没有指定数组（即省略第二个参数），效果函数将在每次组件函数执行时再次执行：'
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, the second argument was not omitted, but it’s an empty
    array. This informs React that this effect function has no dependencies. Therefore,
    the effect function will never be executed again. Instead, it will only be executed
    once, when the component is rendered for the first time. If you set no dependencies
    (by providing an empty array), React will execute the effect function *once* —directly
    after the component function was executed for the first time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，第二个参数没有被省略，但它是一个空数组。这告诉React这个效果函数没有依赖项。因此，效果函数将不会再次执行。相反，它只会在组件首次渲染时执行一次。如果你设置没有依赖项（通过提供一个空数组），React将只执行一次效果函数——直接在组件函数首次执行之后。
- en: It’s important to note that specifying an empty array is very different from
    omitting it. If it is omitted, no dependency information is provided to React.
    Therefore, React executes the effect function after every component re-evaluation.
    If an empty array is provided instead, you explicitly state that this effect has
    no dependencies and therefore should only run once.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，指定一个空数组与省略它非常不同。如果省略了它，就不会向React提供任何依赖信息。因此，React会在每次组件重新评估后执行效果函数。如果提供了空数组，你明确表示这个效果没有依赖项，因此应该只运行一次。
- en: 'This brings up another important question, though: when should you add dependencies?
    And how exactly are dependencies added or specified?'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这又引出了另一个重要的问题：你何时应该添加依赖项？以及依赖项是如何添加或指定的？
- en: Effects and Their Dependencies
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 影响及其依赖关系
- en: Omitting the second argument to `useEffect()` causes the effect function (the
    first argument) to execute after every component function execution. Providing
    an empty array causes the effect function to run only once (after the first component
    function invocation). But is that all you can control?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 省略`useEffect()`的第二个参数会导致效果函数（第一个参数）在每次组件函数执行后执行。提供一个空数组会导致效果函数只运行一次（在首次调用组件函数之后）。但这是你能控制的全部吗？
- en: No, it isn’t.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不，不是的。
- en: The array passed to `useEffect()` can and should contain all variables, constants,
    or functions that are used inside the effect function—if those variables, constants,
    or functions were defined inside the component function (or in some parent component
    function, passed down via props).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`useEffect()`的数组可以也应该包含在效果函数内部使用的所有变量、常量或函数——如果这些变量、常量或函数是在组件函数内部（或在某些父组件函数中，通过props传递下来）定义的。
- en: 'Consider this example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This example is based on the previous example, but was adjusted in one important
    place: `BlogPosts` now accepts a `url` prop.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子基于前面的例子，但在一个重要地方进行了调整：`BlogPosts`现在接受一个`url`属性。
- en: Therefore, this component can now be used and configured by other components.
    Of course, if some other component sets a URL that doesn’t return a list of blog
    posts, the app won’t work as intended. This component therefore might be of limited
    practical use, but it does show the importance of effect dependencies quite well.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个组件现在可以被其他组件使用和配置。当然，如果其他组件设置了一个不会返回博客文章列表的URL，应用程序将无法按预期工作。因此，这个组件可能在实际应用中有限制，但它确实很好地展示了效果依赖的重要性。
- en: But if that other component changes the URL (e.g., due to some user input there),
    a new request should be sent, of course. So `BlogPosts` should send another fetch
    request every time the `url` prop value changes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果其他组件更改了URL（例如，由于某些用户输入），当然应该发送一个新的请求。因此，每当`url`属性值发生变化时，`BlogPosts`应该发送另一个获取请求。
- en: That’s why `url` was added to the dependencies array of `useEffect()` . If the
    array had been kept empty, the effect function would only run once (as described
    in the previous section). Therefore, any changes to `url` wouldn’t have any effect
    (no pun intended) on the effect function or the HTTP request executed as part
    of that function. No new HTTP request would be sent.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么将`url`添加到`useEffect()`的依赖项数组中的原因。如果数组保持为空，效果函数将只运行一次（如前节所述）。因此，对`url`的任何更改都不会对效果函数或作为该函数一部分执行的HTTP请求产生影响。不会发送新的HTTP请求。
- en: By adding `url` to the dependencies array, React registers this value (in this
    case, a prop value, but any value can be registered) and re-executes the effect
    function whenever that value changes (that is, whenever a new `url` prop value
    is set by the component that uses `BlogPosts` ).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`url`添加到依赖项数组中，React注册了这个值（在这种情况下，是一个属性值，但任何值都可以注册），并且每当该值发生变化时（即，每当使用`BlogPosts`的组件设置新的`url`属性值时），都会重新执行效果函数。
- en: The most common types of effect dependencies are state values, props, and functions
    that might be executed inside of the effect function. The latter will be analyzed
    in greater depth later in this chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的效果依赖类型是状态值、属性以及可能在效果函数内部执行的函数。后者将在本章后面进行更深入的分析。
- en: As a rule, you should add all values (including functions) that are used inside
    an effect function to the effect dependencies array.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规则，你应该将效果函数内部使用的所有值（包括函数）添加到效果依赖项数组中。
- en: 'With this new knowledge in mind, if you take another look at the preceding
    `useEffect()` example code, you might spot some missing dependencies:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新知识的基础上，如果你再次查看前面的`useEffect()`示例代码，可能会发现一些缺失的依赖项：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Why are `fetchPosts` , `fetchedPosts` , and `setLoadedPosts` not added as dependencies?
    These are, after all, values and functions used inside of the effect function.
    The next section will address this in detail.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`fetchPosts`、`fetchedPosts`和`setLoadedPosts`没有被添加为依赖项？毕竟，这些都是效果函数内部使用的值和函数。下一节将详细说明这一点。
- en: Unnecessary Dependencies
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不必要的依赖项
- en: 'In the previous example, it might seem as if `fetchPosts` , `fetchedPosts`
    , and `setLoadedPosts` should be added as dependencies to `useEffect()` , as shown
    here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，可能会觉得应该将`fetchPosts`、`fetchedPosts`和`setLoadedPosts`作为依赖项添加到`useEffect()`中，如下所示：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, for `fetchPosts` and `fetchedPosts` , this would be incorrect. And
    for `setLoadedPosts` , it would be unnecessary.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于`fetchPosts`和`fetchedPosts`，这将是不正确的。对于`setLoadedPosts`，这将是不必要的。
- en: '`fetchedPosts` should not be added because it’s not an external dependency.
    It’s a local variable (or argument, to be precise), defined and used inside the
    effect function. It’s not defined in the component function to which the effect
    belongs. If you try to add it as a dependency, you’ll get an error:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不应该将`fetchedPosts`添加，因为它不是一个外部依赖。它是一个局部变量（或更准确地说，是参数），在效果函数内部定义和使用。它没有在属于效果函数的组件函数中定义。如果你尝试将其作为依赖项添加，你会得到一个错误：
- en: '![A screen shot of a computer  Description automatically generated](img/B31339_08_02.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图 自动生成的描述](img/B31339_08_02.png)'
- en: 'Figure 8.2: An error occurred—fetchedPosts could not be found'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：发生错误——无法找到fetchedPosts
- en: '`fetchPosts` , the function that sends the actual HTTP request, is not a function
    defined inside of the effect function. But it still shouldn’t be added because
    it is defined outside the component function.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 发送实际HTTP请求的 `fetchPosts` 函数不是在effect函数内部定义的函数。但仍然不应该添加，因为它是在组件函数外部定义的。
- en: Therefore, there is no way for this function to change. It’s defined once (in
    the `BlogPosts.jsx` file), and it can’t change. That said, this would not be the
    case if it were defined inside the component function. In that case, whenever
    the component function executes again, the `fetchPosts` function would be recreated
    as well. This is a scenario that will be discussed later in this chapter (in the
    *Functions as Dependencies* section).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个函数无法改变。它只定义了一次（在 `BlogPosts.jsx` 文件中），并且无法改变。话虽如此，如果它在组件函数内部定义，情况就不同了。在这种情况下，每当组件函数再次执行时，`fetchPosts`
    函数也会被重新创建。这种情况将在本章后面的部分（在 *函数作为依赖* 部分中）进行讨论。
- en: In this example though, `fetchPosts` can’t change. Therefore, it doesn’t have
    to be added as a dependency (and consequently should not be). The same would be
    true for functions, or any kind of values, provided by the browser or third-party
    packages. Any value that’s not defined inside a component function shouldn’t be
    added to the dependencies array.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个例子中，`fetchPosts` 无法改变。因此，不需要将其作为依赖项添加（并且因此不应该添加）。对于浏览器或第三方包提供的函数，或任何类型的值，只要不是在组件函数内部定义的，都不应该添加到依赖项数组中。
- en: '**Note**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: It may be confusing that a function could change—after all, the logic is hardcoded,
    right? But in JavaScript, functions are actually just objects and therefore may
    change. When the code that contains a function is executed again (e.g., a component
    function being executed again by React), a new function object will be created
    in memory.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让人困惑，一个函数可能会改变——毕竟，逻辑是硬编码的，对吧？但在JavaScript中，函数实际上只是对象，因此可能会改变。当包含函数的代码再次执行时（例如，React再次执行组件函数），内存中会创建一个新的函数对象。
- en: 'If this is not something you’re familiar with, the following resource should
    be helpful: [https://academind.com/tutorials/javascript-functions-are-objects](https://academind.com/tutorials/javascript-functions-are-objects)
    .'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个不熟悉，以下资源可能会有所帮助：[https://academind.com/tutorials/javascript-functions-are-objects](https://academind.com/tutorials/javascript-functions-are-objects)
    .
- en: So `fetchedPosts` and `fetchPosts` should both not be added (for different reasons).
    What about `setLoadedPosts` ?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`fetchedPosts` 和 `fetchPosts` 都不应该添加（出于不同的原因）。那么 `setLoadedPosts` 呢？
- en: '`setLoadedPosts` is the state updating function returned by `useState()` for
    the `loadedPosts` state value. Therefore, like `fetchPosts` , it’s a function.
    Unlike `fetchPosts` , though, it’s a function that’s defined inside the component
    function (because `useState()` is called inside the component function). It’s
    a function created by React (since it’s returned by `useState()` ), but it’s still
    a function. Theoretically, it should therefore be added as a dependency. And indeed,
    you can add it without any negative consequences.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`setLoadedPosts` 是由 `useState()` 返回用于更新 `loadedPosts` 状态值的函数。因此，像 `fetchPosts`
    一样，它是一个函数。不过，与 `fetchPosts` 不同的是，它是一个在组件函数内部定义的函数（因为 `useState()` 是在组件函数内部调用的）。它是由React创建的函数（因为它是由
    `useState()` 返回的），但它仍然是一个函数。因此，理论上应该将其添加为依赖项。实际上，你可以添加它而不会产生任何负面影响。'
- en: 'But state updating functions returned by `useState()` are a special case: React
    guarantees that those functions will never change or be recreated. When the surrounding
    component function ( `BlogPosts` ) is executed again, `useState()` also executes
    again. However, a new state updating function is only created the first time a
    component function is called by React. Subsequent executions don’t lead to a new
    state updating function being created.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `useState()` 返回的状态更新函数是一个特殊情况：React保证这些函数永远不会改变或被重新创建。当周围的组件函数（`BlogPosts`）再次执行时，`useState()`
    也会再次执行。然而，只有在组件函数第一次被React调用时才会创建一个新的状态更新函数。随后的执行不会导致创建新的状态更新函数。
- en: Because of this special behavior (i.e., React guaranteeing that the function
    itself never changes), state updating functions may (and actually should) be omitted
    from the dependencies array.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种特殊行为（即，React保证函数本身永远不会改变），状态更新函数可以（实际上也应该）省略在依赖项数组中。
- en: For all these reasons, `fetchedPosts` , `fetchPosts` , and `setLoadedPosts`
    should all not be added to the dependencies array of `useEffect()` . `url` is
    the only dependency used by the effect function that may change (that is, when
    the user enters a new URL into the input field) and therefore should be listed
    in the array.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些原因，`fetchedPosts`、`fetchPosts` 和 `setLoadedPosts` 都不应添加到 `useEffect()`
    的依赖项数组中。`url` 是效果函数使用的唯一可能变化的依赖项（即，当用户在输入字段中输入新的URL时），因此应列在数组中。
- en: 'To sum it up, when it comes to adding values to the effect dependencies array,
    there are three kinds of exceptions:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，当涉及到向效果依赖项数组添加值时，有三种类型的异常：
- en: Internal values (or functions) that are defined and used inside the effect (such
    as `fetchedPosts` )
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在效果内部定义并使用的内部值（或函数）（例如 `fetchedPosts`）
- en: External values that are not defined inside a component function (such as `fetchPosts`
    )
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件函数内部未定义的外部值（例如 `fetchPosts`）
- en: State updating functions (such as `setLoadedPosts` )
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态更新函数（例如 `setLoadedPosts`）
- en: In all other cases, if a value is used in the effect function, it *must be added*
    to the dependencies array! Omitting values incorrectly can lead to unexpected
    effect executions (that is, an effect executing too often or not often enough).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有其他情况下，如果效果函数中使用了某个值，*必须将其添加* 到依赖项数组中！错误地省略值可能导致意外的效果执行（即，效果执行得太频繁或不够频繁）。
- en: Cleaning Up after Effects
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 效果后的清理
- en: To perform a certain task (for example, sending an HTTP request), many effects
    should simply be triggered when their dependencies change. While some effects
    can be re-executed multiple times without issue, there are also effects that,
    if they execute again before the previous task has finished, are an indication
    that the task performed needs to be canceled. Or, maybe there is some other kind
    of cleanup work that should be performed when the same effect executes again.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行特定任务（例如，发送HTTP请求），许多效果应该在它们的依赖项发生变化时简单地触发。虽然某些效果可以多次重新执行而不会出现问题，但也有效果，如果在之前的任务完成之前再次执行，则表明执行的任务需要取消。或者，也许在相同的效果再次执行时，应该执行一些其他类型的清理工作。
- en: 'Here’s an example, where an effect sets a timer:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，其中效果设置了一个计时器：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This `Alert` component is used in the `App` component:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `Alert` 组件在 `App` 组件中使用：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `App` component, the `Alert` component is shown conditionally. The `showAlert`
    state is toggled via the `handleShowAlert` function (which is triggered upon a
    button click).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App` 组件中，`Alert` 组件是条件性地显示的。`showAlert` 状态通过 `handleShowAlert` 函数切换（该函数在按钮点击时触发）。
- en: In the `Alert` component, a timer is set using `useEffect()` . Without `useEffect()`
    , an infinite loop would be created, since the timer, upon expiration, changes
    some component state (the `alertDone` state via the `setAlertDone` state updating
    function).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Alert` 组件中，使用 `useEffect()` 设置了一个计时器。如果没有 `useEffect()`，将会创建一个无限循环，因为计时器在到期时通过
    `setAlertDone` 状态更新函数更改了一些组件状态（`alertDone` 状态）。
- en: The dependency array is an empty array because this effect function does not
    use any component values, variables, or functions. `console.log()` and `setTimeout()`
    are functions built into the browser (and therefore external functions), and `setAlertDone()`
    can be omitted because of the reasons mentioned in the previous section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项数组是一个空数组，因为此效果函数没有使用任何组件值、变量或函数。`console.log()` 和 `setTimeout()` 是浏览器内置的函数（因此是外部函数），而
    `setAlertDone()` 可以省略，因为前文提到的理由。
- en: 'If you run this app and then start toggling the alert (by clicking the button),
    you’ll notice strange behavior. The timer is set every time the `Alert` component
    is rendered. But it’s not clearing the existing timer. This is due to the fact
    that multiple timers are running simultaneously, as you can clearly see if you
    look at the JavaScript console in your browser’s developer tools:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此应用并开始切换警报（通过点击按钮），你会注意到奇怪的行为。计时器每次 `Alert` 组件渲染时都会设置。但它没有清除现有的计时器。这是因为同时运行了多个计时器，如果你查看浏览器开发者工具中的JavaScript控制台，可以清楚地看到这一点：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_08_03.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B31339_08_03.png)'
- en: 'Figure 8.3: Multiple timers are started'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：启动了多个计时器
- en: This example is deliberately kept simple, but there are other scenarios in which
    you may have an ongoing HTTP request that should be aborted before a new one is
    sent. There are cases like that, where an effect should be cleaned up first before
    it runs again.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例故意保持简单，但还有其他场景，你可能需要在发送新的请求之前取消当前的 HTTP 请求。在这种情况下，应该先清理效果再重新运行。
- en: 'React also provides a solution for those kinds of situations: the effect function
    passed as a first argument to `useEffect()` can return an optional cleanup function.
    If you do return a function inside your effect function, React will execute that
    function every time *before* it runs the effect again.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: React 也为这些情况提供了一个解决方案：传递给 `useEffect()` 的第一个参数的效果函数可以返回一个可选的清理函数。如果你在效果函数内部返回一个函数，React
    将在每次再次运行效果之前执行该函数。
- en: 'Here’s the `useEffect()` call of the `Alert` component with a cleanup function
    being returned:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有返回清理函数的 `useEffect()` 调用的 `Alert` 组件：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this updated example, a new `timer` variable (a local variable that is only
    accessible inside the effect function) is added. That variable stores a reference
    to the timer that’s created by `setTimeout()` . This reference can then be used
    together with `clearTimeout()` to remove a timer.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更新的示例中，添加了一个新的 `timer` 变量（一个仅在效果函数内部可访问的局部变量）。该变量存储由 `setTimeout()` 创建的计时器的引用。然后可以使用这个引用与
    `clearTimeout()` 一起使用来移除一个计时器。
- en: The timer is removed in a function returned by the effect function—which is
    the cleanup function that will be executed automatically by React before the effect
    function is called the next time.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器是在效果函数返回的函数中被移除的——这就是将在 React 下一次调用效果函数之前自动执行清理函数的清理函数。
- en: 'You can see the cleanup function in action if you add a `console.log()` statement
    to it:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给它添加一个 `console.log()` 语句，你就可以看到清理函数的实际效果：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In your JavaScript console, this looks as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 JavaScript 控制台中，这看起来如下所示：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_08_04.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B31339_08_04.png)'
- en: 'Figure 8.4: The cleanup function is executed before the effect runs again'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4：清理函数在效果再次运行之前执行
- en: 'In the preceding screenshot, you can see that the cleanup function is executed
    (indicated by the `Cleanup!` log) right before the effect function is executed
    again. You can also see that the timer is cleared successfully: the first timer
    never expires (there is no `Timer expired!` log for the first timer in the screenshot).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到清理函数是在效果函数再次执行之前执行的（由 `Cleanup!` 日志表示）。你还可以看到计时器已被成功清除：第一个计时器永远不会过期（屏幕截图中第一个计时器没有
    `Timer expired!` 日志）。
- en: The cleanup function is not executed when the effect function is called for
    the first time. However, it will be called by React whenever a component that
    contains an effect unmounts (that is, when it’s removed from the DOM).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当效果函数第一次被调用时，清理函数不会被执行。然而，每当包含效果的组件卸载（即从 DOM 中移除）时，React 都会调用它。
- en: If an effect has multiple dependencies, the effect function will be executed
    whenever any of the dependency values change. Therefore, the cleanup function
    will also be called every time some dependency changes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个效果有多个依赖项，那么每当任何依赖项值发生变化时，效果函数都会被执行。因此，清理函数也会在每次某些依赖项发生变化时被调用。
- en: Dealing with Multiple Effects
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理多个效果
- en: Thus far, all the examples in this chapter have dealt with only one `useEffect()`
    call. You are not limited to only one call per component though. You can call
    `useEffect()` as often as needed—and can therefore register as many effect functions
    as needed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章中的所有示例都只处理了一个 `useEffect()` 调用。尽管如此，你并不局限于每个组件只调用一次。你可以根据需要多次调用 `useEffect()`——因此可以注册所需数量的效果函数。
- en: But how many effect functions do you need?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但你需要多少个效果函数呢？
- en: You could start putting every side effect into its own `useEffect()` wrapper.
    You could put every HTTP request, every `console.log()` statement, and every timer
    into separate effect functions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将每个副作用都放入它自己的 `useEffect()` 包装器中。你可以将每个 HTTP 请求、每个 `console.log()` 语句和每个计时器放入单独的效果函数中。
- en: That said, as you can see in some of the previous examples—specifically, the
    code snippet in the previous section—that’s not necessary. There, you have multiple
    effects in one `useEffect()` call (three `console.log()` statements and one timer).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，正如你在一些之前的示例中看到的那样——特别是前一个部分中的代码片段——这并不是必要的。在那里，你可以在一个 `useEffect()` 调用中实现多个效果（三个
    `console.log()` 语句和一个计时器）。
- en: 'A better approach would be to split your effect functions by dependencies.
    If one side effect depends on state A and another side effect depends on state
    B, you could put them into separate effect functions (unless those two states
    are related), as shown here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更好的方法是按照依赖关系拆分你的效果函数。如果一个副作用依赖于状态 A，而另一个副作用依赖于状态 B，你可以将它们放入不同的效果函数中（除非这两个状态相关），如下所示：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: But the best approach is to split your effect functions by logic. If one effect
    deals with fetching data via an HTTP request and another effect is about setting
    a timer, it will often make sense to put them into different effect functions
    (that is, different `useEffect()` calls).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但最好的方法是按照逻辑拆分你的效果函数。如果一个效果涉及通过 HTTP 请求获取数据，而另一个效果是设置计时器，那么将它们放入不同的效果函数（即不同的
    `useEffect()` 调用）通常是有意义的。
- en: Functions as Dependencies
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为依赖项的函数
- en: Different effects have different kinds of dependencies, and one common kind
    of dependency is functions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的效果有不同的依赖类型，其中一种常见的依赖类型是函数。
- en: As mentioned previously, functions in JavaScript are just objects. Therefore,
    whenever some code that contains a function definition is executed, a new function
    object is created and stored in memory. When calling a function, it’s that specific
    function object in memory that is executed. In some scenarios (for example, for
    functions defined in component functions), it’s possible that multiple objects
    based on the same function code exist in memory.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，JavaScript 中的函数只是对象。因此，每当执行包含函数定义的代码时，就会创建一个新的函数对象并将其存储在内存中。调用函数时，执行的是内存中特定的函数对象。在某些情况下（例如，对于在组件函数中定义的函数），可能存在基于相同函数代码的多个对象在内存中。
- en: Because of this behavior, functions that are referenced in code are not necessarily
    equal, even if they are based on the same function definition.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种行为，即使在基于相同的函数定义，代码中引用的函数也不一定是相等的。
- en: 'Consider this example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, instead of creating a timer directly inside the effect function,
    a separate `setAlert()` function is created in the component function. That `setAlert()`
    function is then used in the effect function passed to `useEffect()` . Since that
    function is used there, and because it’s defined in the component function, it
    should be added as a dependency to `useEffect()` .
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，不是在效果函数内部直接创建计时器，而是在组件函数中创建一个单独的 `setAlert()` 函数。然后，在传递给 `useEffect()`
    的效果函数中使用该 `setAlert()` 函数。由于该函数在那里使用，并且因为它是在组件函数中定义的，所以它应该被添加为 `useEffect()` 的依赖项。
- en: Another reason for this is that every time the `Alert` component function is
    executed again (e.g., because some state or prop value changes), a new `setAlert`
    function object will be created. In this example, that wouldn’t be problematic
    because `setAlert` only contains static code. A new function object created for
    `setAlert` would work exactly in the same way as the previous one; therefore,
    it would not matter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是，每当 `Alert` 组件函数再次执行（例如，因为某些状态或属性值发生变化）时，就会创建一个新的 `setAlert` 函数对象。在这个例子中，这不会成为问题，因为
    `setAlert` 只包含静态代码。为 `setAlert` 创建的新函数对象将像上一个一样工作；因此，这不会产生影响。
- en: 'But now consider this adjusted example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在考虑这个调整后的示例：
- en: '**Note**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The complete app can be found on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/examples/function-dependencies](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/examples/function-dependencies)
    .
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用可以在 GitHub 上找到：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/examples/function-dependencies](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/examples/function-dependencies)。
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, a new `alertMsg` state is used for setting the actual alert message that’s
    logged to the console. In addition, the `setAlert` dependency was removed from
    `useEffect()` .
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用一个新的 `alertMsg` 状态来设置实际记录到控制台的警告消息。此外，`setAlert` 依赖关系已从 `useEffect()` 中移除。
- en: 'If you run this code, you’ll get the following output:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此代码，你会得到以下输出：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_08_05.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B31339_08_05.png)'
- en: 'Figure 8.5: The console log does not reflect the entered value'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5：控制台日志没有反映输入的值
- en: In this screenshot, you can see that, despite a different value being entered
    into the input field, the original alert message is output.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕截图中，你可以看到，尽管输入字段中输入了不同的值，但仍然输出了原始的警告消息。
- en: The reason for this behavior is that the new alert message is not picked up.
    It’s not used because, despite the component function being executed again (because
    the state changed), the effect is not executed again. And the original execution
    of the effect still uses the old version of the `setAlert` function—the old `setAlert`
    function object, which has the old alert message locked in. That’s how JavaScript
    functions work, and that’s why, in this case, the desired result is not achieved.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的原因是新警报消息没有被捕获。它没有被使用，因为尽管组件函数再次执行（因为状态发生了变化），但效果并没有再次执行。并且原始的效果执行仍然使用旧的`setAlert`函数版本——旧的`setAlert`函数对象，其中锁定了旧的警报消息。这就是JavaScript函数的工作方式，这就是为什么在这种情况下，期望的结果没有实现。
- en: 'The solution to the problem is simple though: add `setAlert` as a dependency
    to `useEffect()` . You should always add all values, variables, or functions used
    in an effect as dependencies, and this example shows *why* you should do that.
    Even functions can change.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法很简单：将`setAlert`作为依赖项添加到`useEffect()`中。你应该始终将效果中使用的所有值、变量或函数作为依赖项添加，这个例子展示了*为什么*你应该这样做。即使是函数也可以改变。
- en: 'If you add `setAlert` to the effect dependency array, you’ll get a different
    output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`setAlert`添加到效果依赖数组中，你会得到不同的输出：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Please note that only a pointer to the `setAlert` function is added. You don’t
    execute the function in the dependencies array (that would add the return value
    of the function as a dependency, which is typically not the goal).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只添加了`setAlert`函数的指针。你不需要在依赖项数组中执行函数（这会将函数的返回值作为依赖项添加，这通常不是目标）。
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_08_06.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  自动生成的描述](img/B31339_08_06.png)'
- en: 'Figure 8.6: Multiple timers are started'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：启动多个计时器
- en: Now, a new timer is started for every keystroke, and as a result, the entered
    message is output in the console.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每按一个键都会启动一个新的计时器，因此输入的消息会在控制台输出。
- en: 'Of course, this might also not be the desired result. You might only be interested
    in the final error message that was entered. This can be achieved by adding a
    cleanup function to the effect (and adjusting `setAlert` a little bit):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这可能也不是你期望的结果。你可能只对最后输入的最终错误消息感兴趣。这可以通过向效果添加清理函数（并对`setAlert`进行一点调整）来实现：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As shown in the *Cleaning Up after Effects* section, the timer is cleared with
    the help of a timer reference and `clearTimeout()` in the effect’s cleanup function.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如*效果清理*部分所示，计时器是通过计时器引用和效果清理函数中的`clearTimeout()`来清除的。
- en: After adjusting the code like this, only the final alert message that was entered
    will be output.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 调整代码后，只有最后输入的最终警报消息会被输出。
- en: Seeing the cleanup function in action again is helpful; the main takeaway is
    the importance of adding all dependencies, though—including function dependencies.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看到清理函数的作用是有帮助的；主要的启示是添加所有依赖项的重要性——包括函数依赖项。
- en: 'An alternative to including the function as a dependency would be to move the
    entire function definition into the effect function, because any value that’s
    defined and used inside of an effect function must not be added as a dependency:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数作为依赖项包括的替代方案是将整个函数定义移动到效果函数中，因为任何在效果函数内部定义并使用的值都不应该作为依赖项添加：
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Of course, you could also get rid of the `setAlert` function altogether then
    and just move the function’s code into the effect function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以完全去掉`setAlert`函数，然后将函数的代码移动到效果函数中。
- en: 'Either way, you will have to add a new dependency, `alertMsg` , which is now
    used inside of the effect function. Even though the `setAlert` function isn’t
    a dependency anymore, you still must add any values used (and `alertMsg` is used
    in the effect function now):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，你都需要添加一个新的依赖项，`alertMsg`，现在它被用于效果函数内部。即使`setAlert`函数不再是依赖项，你仍然必须添加任何使用的值（现在`alertMsg`被用于效果函数）：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Hence, this alternative way of writing the code just comes down to personal
    preferences. It does not reduce the number of dependencies.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这种编写代码的替代方法只是个人偏好的问题。它并不会减少依赖项的数量。
- en: You would get rid of a function dependency if you were to move the function
    out of the component function. This is because, as mentioned in the *Unnecessary
    Dependencies* section, external dependencies (for example, those built into the
    browser or defined outside of component functions) should not be added as dependencies.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将函数移出组件函数，你就可以消除函数依赖。这是因为，如 *不必要的依赖项* 部分所述，外部依赖项（例如，内置在浏览器中或定义在组件函数之外的）不应作为依赖项添加。
- en: However, in the case of the `setAlert` function, this is not possible because
    `setAlert` uses `alertMsg` . Since `alertMsg` is a component state value, the
    function that uses it must be defined inside the component function; otherwise,
    it won’t have access to that state value.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于 `setAlert` 函数来说，这是不可能的，因为 `setAlert` 使用了 `alertMsg`。由于 `alertMsg` 是组件状态值，使用它的函数必须在组件函数内部定义；否则，它将无法访问该状态值。
- en: 'This can all sound quite confusing, but it comes down to two simple rules:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能相当复杂，但归结为两个简单的规则：
- en: Always add all non-external dependencies—no matter whether they’re variables
    or functions.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是添加所有非外部依赖项——无论它们是变量还是函数。
- en: Functions are just objects and can change if their surrounding code executes
    again.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数只是对象，如果它们的周围代码再次执行，它们可能会发生变化。
- en: Avoiding Unnecessary Effect Executions
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免不必要的副作用执行
- en: Since all dependencies should be added to `useEffect()` , you sometimes end
    up with code that causes an effect to execute unnecessarily.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有依赖项都应该添加到 `useEffect()` 中，有时你最终会得到一些导致不必要的副作用执行的代码。
- en: 'Consider the example component below:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例组件：
- en: '**Note**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The complete example can be found on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/examples/unnecessary-executions](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/examples/unnecessary-executions)
    .
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可以在 GitHub 上找到：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/examples/unnecessary-executions](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/examples/unnecessary-executions)。
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This component contains a form with two inputs. The entered values are stored
    in two different state values ( `enteredEmail` and `enteredPassword` ). The `validateEmail()`
    function then performs some email validation and, if the email address is invalid,
    logs a message to the console. `validateEmail()` is executed with the help of
    `useEffect()` .
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件包含一个带有两个输入字段的形式。输入的值存储在两个不同的状态值中（`enteredEmail` 和 `enteredPassword`）。然后 `validateEmail()`
    函数执行一些电子邮件验证，如果电子邮件地址无效，则将消息记录到控制台。`validateEmail()` 是通过 `useEffect()` 执行的。
- en: The problem with this code is that the effect function will be executed whenever
    `validateEmail` changes because, correctly, `validateEmail` was added as a dependency.
    But `validateEmail` will change whenever the component function is executed again.
    And that’s not just the case for state changes to `enteredEmail` but also whenever
    `enteredPassword` changes—even though that state value is not used at all inside
    of `validateEmail` .
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的问题在于，每当 `validateEmail` 发生变化时，副作用函数都会执行，因为正确地，`validateEmail` 被添加为依赖项。但是，每当组件函数再次执行时，`validateEmail`
    都会发生变化。这不仅适用于 `enteredEmail` 的状态变化，也适用于 `enteredPassword` 的任何变化——即使这个状态值在 `validateEmail`
    内部根本未使用。
- en: 'This unnecessary effect execution can be avoided with various solutions:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过各种解决方案避免这种不必要的副作用执行：
- en: You could move the code inside of `validateEmail` directly into the effect function
    ( `enteredEmail` would then be the only dependency of the effect, avoiding effect
    executions when any other state changes).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将 `validateEmail` 中的代码直接移动到副作用函数中（这样 `enteredEmail` 就会成为副作用的唯一依赖项，避免在任何其他状态变化时执行副作用）。
- en: You could avoid using `useEffect()` altogether since you could perform email
    validation inside of `handleUpdateEmail` . Having `console.log()` (a side effect)
    in there would be acceptable since it wouldn’t cause any harm.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以完全避免使用 `useEffect()`，因为你可以将电子邮件验证放在 `handleUpdateEmail` 中执行。其中包含 `console.log()`（副作用）是可以接受的，因为它不会造成任何伤害。
- en: You could call `validateEmail()` directly in the component function—since it
    doesn’t change any state, it wouldn’t trigger an infinite loop.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以直接在组件函数中调用 `validateEmail()`——因为它不会改变任何状态，所以不会触发无限循环。
- en: '**Note**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'There is an article in the official React documentation that highlights scenarios
    where you might not need `useEffect()` : [https://react.dev/learn/you-might-not-need-an-effect](https://react.dev/learn/you-might-not-need-an-effect)
    .'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 官方 React 文档中有一篇文章强调了可能不需要 `useEffect()` 的场景：[https://react.dev/learn/you-might-not-need-an-effect](https://react.dev/learn/you-might-not-need-an-effect)。
- en: 'In addition, I created a video that summarizes the most important situations
    in which you do or do not need `useEffect()` : [https://www.youtube.com/watch?v=V1f8MOQiHRw](https://www.youtube.com/watch?v=V1f8MOQiHRw)
    .'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我创建了一个视频，总结了你需要或不需要 `useEffect()` 的最重要的情况：[https://www.youtube.com/watch?v=V1f8MOQiHRw](https://www.youtube.com/watch?v=V1f8MOQiHRw)。
- en: 'Of course, in some other scenarios, you might need to use `useEffect()` . Fortunately,
    React also offers a solution for situations like this: you can wrap the function
    that’s used as a dependency with another React Hook, the `useCallback()` Hook.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在某些其他场景中，你可能需要使用 `useEffect()`。幸运的是，React 也为这种情况提供了解决方案：你可以用另一个 React Hook，即
    `useCallback()` Hook，包裹用作依赖项的函数。
- en: 'The adjusted code would look like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 调整后的代码将看起来像这样：
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`useCallback()` , like all React Hooks, is a function that’s executed directly
    inside the component function. Like `useEffect()` , it accepts two arguments:
    another function (which can be anonymous or a named function) and a dependencies
    array.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback()`，像所有 React Hooks 一样，是一个在组件函数内部直接执行的功能。像 `useEffect()` 一样，它接受两个参数：另一个函数（可以是匿名函数或命名函数）和一个依赖项数组。'
- en: Unlike `useEffect()` , though, `useCallback()` does not execute the received
    function. Instead, `useCallback()` ensures that a function is only recreated if
    one of the specified dependencies has changed. The default JavaScript behavior
    of creating a new function object whenever the surrounding code executes again
    is (synthetically) disabled.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与 `useEffect()` 不同，`useCallback()` 不会执行接收到的函数。相反，`useCallback()` 确保只有在指定的依赖项之一发生变化时，函数才会被重新创建。默认的
    JavaScript 行为是在周围代码再次执行时创建一个新的函数对象（合成地）被禁用。
- en: '`useCallback()` returns the latest saved function object. Hence, that returned
    value (which is a function) is saved in a variable or constant ( `validateEmail`
    in the previous example).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback()` 返回最新的保存的函数对象。因此，返回的值（它是一个函数）被保存在一个变量或常量中（在前面的例子中是 `validateEmail`）。'
- en: Since the function wrapped by `useCallback()` now only changes when one of the
    dependencies changes, the returned function can be used as a dependency for `useEffect()`
    without executing that effect for all kinds of state changes or component updates.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `useCallback()` 包装的函数现在只有在依赖项之一发生变化时才会改变，因此返回的函数可以用作 `useEffect()` 的依赖项，而无需为所有类型的州变化或组件更新执行该效果。
- en: In the case of the preceding example, the effect function would then only execute
    when `enteredEmail` changes—because that’s the only change that will lead to a
    new `validateEmail` function object being created.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个例子的情况下，副作用函数只有在 `enteredEmail` 发生变化时才会执行——因为这是唯一会导致创建新的 `validateEmail`
    函数对象的变化。
- en: 'Another common reason for unnecessary effect execution is the usage of objects
    as dependencies, like in this example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个导致不必要的副作用执行的原因是使用对象作为依赖项，如下例所示：
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This `Error` component is used in another component, the `Form` component,
    like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Error` 组件被用于另一个组件，即 `Form` 组件，如下所示：
- en: '[PRE23]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Error` component receives an error message via props ( `props.message`
    ) and displays it on the screen. In addition, with the help of `useEffect()` ,
    it does some error logging. In this example, the error is simply output to the
    JavaScript console. In a real app, the error might be sent to some analytics API
    via an HTTP request. Either way, a side effect that depends on the error message
    is performed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error` 组件通过 props（`props.message`）接收错误消息并在屏幕上显示它。此外，借助 `useEffect()`，它进行一些错误记录。在这个例子中，错误只是简单地输出到
    JavaScript 控制台。在实际应用中，错误可能会通过 HTTP 请求发送到某个分析 API。无论如何，都会执行一个依赖于错误消息的副作用。'
- en: The `Form` component contains two state values, tracking the entered email address
    as well as the error status of the input. If an invalid input value is submitted,
    `errorMessage` is set and the `Error` component is displayed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form` 组件包含两个状态值，跟踪输入的电子邮件地址以及输入的错误状态。如果提交了无效的输入值，`errorMessage` 将被设置，并且会显示
    `Error` 组件。'
- en: The interesting part about this example is the dependency array of `useEffect()`
    inside the `Error` component. It contains the `props` object as a dependency (
    `props` is always an object, grouping all prop values together). When using objects
    (props or any other object; it does not matter) as dependencies for `useEffect()`
    , unnecessary effect function executions can be the result.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中有趣的部分是`Error`组件内部的`useEffect()`的依赖数组。它包含`props`对象作为依赖项（`props`始终是一个对象，将所有属性值组合在一起）。当使用对象（props或任何其他对象；这并不重要）作为`useEffect()`的依赖项时，可能会出现不必要的效果函数执行。
- en: You can see this problem in this example. If you run the app and enter an invalid
    email address (e.g., `test@test.de` ), you’ll notice that subsequent keystrokes
    in the email input field will cause the error message to be logged (via the effect
    function) for every keystroke.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个例子中看到这个问题。如果你运行应用程序并输入一个无效的电子邮件地址（例如，`test@test.de`），你会注意到在电子邮件输入字段中的后续按键会导致错误信息被记录（通过效果函数）。
- en: '**Note**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The full code can be found on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/examples/objects-as-dependencies](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/examples/objects-as-dependencies)
    .
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码可以在GitHub上找到：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/examples/objects-as-dependencies](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/examples/objects-as-dependencies)。
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_08_07.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图 自动生成描述](img/B31339_08_07.png)'
- en: 'Figure 8.7: A new error message is logged for every keystroke'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：每次按键都会记录一条新的错误信息
- en: Those extra executions can occur because component re-evaluations (i.e., component
    functions being invoked again by React) will produce brand-new JavaScript objects.
    Even if the values of properties of those objects did not change (as in the preceding
    example), technically, a brand-new object in memory is created by JavaScript.
    Since the effect depends on the entire object, React only “sees” that there is
    a new version of that object and hence runs the effect again.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的执行可能发生，因为组件重新评估（即，组件函数再次被React调用）将产生全新的JavaScript对象。即使这些对象的属性值没有改变（如前例所示），技术上，JavaScript会创建一个新的对象。由于效果依赖于整个对象，React只“看到”该对象有一个新版本，因此会再次运行效果。
- en: In the preceding example, a new props object (for the `Error` component) is
    created whenever the `Form` component function is called by React—even if the
    error message (the only prop value that’s set) did not change.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，每当React调用`Form`组件函数时，就会创建一个新的`props`对象（用于`Error`组件）——即使错误信息（唯一设置的属性值）没有改变。
- en: In this example, that’s just annoying since it clutters the JavaScript console
    in the developer tools. However, if you were sending an HTTP request to some analytics
    backend API, it could cause bandwidth problems and make the app slower. Therefore,
    it’s best if you get into the habit of avoiding unnecessary effect executions
    as a general rule.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，这只会让人感到烦恼，因为它会弄乱开发者工具中的JavaScript控制台。然而，如果你向某个分析后端API发送HTTP请求，这可能会引起带宽问题并使应用程序变慢。因此，最好养成避免不必要的效果执行的惯例。
- en: 'In the case of object dependencies, the best way to avoid unnecessary executions
    is to simply destructure the object so that you can pass only those object properties
    as dependencies that are needed by the effect:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象依赖的情况下，避免不必要的执行的最佳方法是将对象解构，以便只传递那些效果所需的属性作为依赖项：
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the case of props, you could also destructure the object right in the component
    function parameter list:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性的情况下，你还可以在组件函数参数列表中直接解构对象：
- en: '[PRE25]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using this approach, you ensure that only the required property values are set
    as dependencies. Therefore, even if the object gets recreated, the property value
    (in this case, the value of the `message` property) is the only thing that matters.
    If it doesn’t change, the effect function won’t be executed again.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你可以确保只有所需的属性值被设置为依赖项。因此，即使对象被重新创建，属性值（在这种情况下，`message`属性的值）是唯一重要的事情。如果它没有改变，效果函数将不会再次执行。
- en: Effects and Asynchronous Code
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 效果和异步代码
- en: 'Some effects deal with asynchronous code (sending HTTP requests is a typical
    example). When performing asynchronous tasks in effect functions, there is one
    important rule to keep in mind, though: the effect function itself should not
    be asynchronous and should not return a promise. This does not mean that you can’t
    work with promises in effects—you just must not return a promise.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一些副作用处理异步代码（发送HTTP请求是一个典型的例子）。在效果函数中执行异步任务时，有一个重要的规则需要记住：效果函数本身不应该异步，也不应该返回承诺。这并不意味着你无法在副作用中处理承诺——你只是不能返回承诺。
- en: 'You might want to use `async` / `await` to simplify asynchronous code, but
    when doing so inside of an effect function, it’s easy to accidentally return a
    promise. For example, the following code would work but does not follow best practices:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想使用`async` / `await`来简化异步代码，但在效果函数内部这样做时，很容易意外地返回一个承诺。例如，以下代码可以工作，但不符合最佳实践：
- en: '[PRE26]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Adding the `async` keyword in front of `function` unlocks the usage of `await`
    inside the function—which makes dealing with asynchronous code (that is, with
    promises) more convenient.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在`function`前添加`async`关键字可以解锁函数内`await`的使用——这使得处理异步代码（即，处理承诺）更加方便。
- en: 'But the effect function passed to `useEffect()` should only return a normal
    function, if anything. It should not return a promise. Indeed, React actually
    issues a warning when trying to run code like the preceding snippet:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但传递给`useEffect()`的效果函数应该只返回一个普通函数，如果有的话。它不应该返回承诺。实际上，当尝试运行前面代码片段中的代码时，React会发出警告：
- en: '*![A screenshot of a computer code  Description automatically generated](img/B31339_08_08.png)*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*![计算机代码的截图  自动生成的描述](img/B31339_08_08.png)*'
- en: 'Figure 8.8: React shows a warning about async being used in an effect function'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：React显示关于在效果函数中使用异步的警告
- en: 'To avoid this warning, you can use promises without `async` / `await` , like
    this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个警告，你可以像这样使用承诺而不使用`async` / `await`：
- en: '[PRE27]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This works because the effect function doesn’t return the promise.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为效果函数没有返回承诺。
- en: 'Alternatively, if you want to use `async` / `await` , you can create a separate
    wrapper function inside of the effect function, which is then executed in the
    effect:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想使用`async` / `await`，你可以在效果函数内部创建一个单独的包装函数，然后在该效果中执行：
- en: '[PRE28]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By doing that, the effect function itself is not asynchronous (it does not return
    a promise), but you can still use `async` / `await` .
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，效果函数本身不是异步的（它不返回承诺），但你仍然可以使用`async` / `await`。
- en: Rules of Hooks
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hooks规则
- en: 'In this chapter, two new Hooks were introduced: `useEffect()` and `useCallback()`
    . Both Hooks are very important— `useEffect()` especially, as this is a Hook you
    will typically use a lot. Together with `useState()` (introduced in *Chapter 4*
    , *Working with Events and State* ) and `useRef()` (introduced in *Chapter 7*
    , *Portals and Refs* ), you now have a solid set of key React Hooks.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，介绍了两个新的Hooks：`useEffect()`和`useCallback()`。这两个Hooks都非常重要——`useEffect()`尤其重要，因为这是你通常会大量使用的Hooks。与在*第4章*，*处理事件和状态*中引入的`useState()`和*第7章*，*Portals和Refs*中引入的`useRef()`一起，你现在有一套坚实的核心React
    Hooks。
- en: 'When working with React Hooks, there are two rules (the so-called **rules of
    Hooks** ) you must follow:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用React Hooks时，你必须遵循两条规则（所谓的**Hooks规则**）：
- en: Only call Hooks at the top level of component functions. Don’t call them inside
    of `if` statements, loops, or nested functions.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只在组件函数的最顶层调用Hooks。不要在`if`语句、循环或嵌套函数内部调用它们。
- en: Only call Hooks inside of React components or custom Hooks (custom Hooks will
    be covered in *Chapter 12* , *Building Custom React Hooks* ).
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能在React组件或自定义Hook（自定义Hook将在*第12章*，*构建自定义React Hook*）内部调用Hooks。
- en: These rules exist because React Hooks won’t work as intended if used in a non-compliant
    way. Fortunately, React will generate a warning message if you violate one of
    these rules; hence, you will notice if you accidentally do so.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则存在的原因是，如果以不符合规定的方式使用，React Hooks将无法按预期工作。幸运的是，如果你违反了这些规则之一，React会生成一个警告消息；因此，如果你不小心这样做，你会注意到。
- en: Summary and Key Takeaways
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和关键要点
- en: Actions that are not directly related to the main process of a function can
    be considered side effects.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与函数的主要流程不直接相关的操作可以被认为是副作用。
- en: Side effects can be asynchronous tasks (for example, sending an HTTP request),
    but can also be synchronous (for example, `console.log()` or accessing browser
    storage).
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副作用可以是异步任务（例如，发送HTTP请求），但也可以是同步的（例如，`console.log()` 或访问浏览器存储）。
- en: Side effects are often needed to achieve a certain goal, but it’s a good idea
    to separate them from the main process of a function.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副作用通常是为了实现某个目标而需要的，但将它们从函数的主要流程中分离出来是个好主意。
- en: Side effects can become problematic if they cause infinite loops (because of
    the update cycles between effect and state).
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果副作用导致无限循环（因为效果和状态之间的更新周期），它们可能会变得有问题。
- en: '`useEffect()` is a React Hook that should be used to wrap side effects and
    perform them in a safe way.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useEffect()` 是一个 React 钩子，应该用于包装副作用并以安全的方式执行它们。'
- en: '`useEffect()` takes an effect function and an array of effect dependencies.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useEffect()` 接收一个效果函数和一个效果依赖项数组。'
- en: The effect function is executed directly after the component function is invoked
    (not simultaneously).
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效果函数在组件函数调用后直接执行（不是同时执行）。
- en: Any value, variable, or function used inside of an effect should be added to
    the dependencies array.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在效果内部使用的任何值、变量或函数都应该添加到依赖数组中。
- en: Dependency array exceptions are external values (defined outside of a component
    function), state updating functions, or values defined and used inside of the
    effect function.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖数组异常是外部值（在组件函数外部定义的）、状态更新函数或在效果函数内部定义和使用的值。
- en: If no dependency array is specified, the effect function executes after every
    component function invocation.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有指定依赖数组，效果函数在每次组件函数调用后执行。
- en: If an empty dependency array is specified, the effect function runs once when
    the component first mounts (that is, when it is created for the first time).
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指定了一个空的依赖数组，效果函数将在组件首次挂载时运行一次（即，当它第一次被创建时）。
- en: Effect functions can also return optional cleanup functions that are called
    right before an effect function is executed again (and right before a component
    is removed from the DOM).
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效果函数还可以返回可选的清理函数，这些函数在效果函数再次执行之前（以及组件从 DOM 中移除之前）被调用。
- en: Effect functions must not return promises.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效果函数不得返回承诺。
- en: For function dependencies, `useCallback()` can help reduce the number of effect
    executions.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于函数依赖项，`useCallback()` 可以帮助减少效果执行的次数。
- en: For object dependencies, destructuring can help reduce the number of effect
    executions.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于对象依赖项，解构可以有助于减少效果执行的次数。
- en: What’s Next?
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: Dealing with side effects is a common problem when building apps because most
    apps need some kind of side effects (for example, sending an HTTP request) to
    work correctly. Therefore, side effects aren’t a problem themselves, but they
    can cause problems (for example, infinite loops) if handled incorrectly.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时处理副作用是一个常见问题，因为大多数应用程序需要某种形式的副作用（例如，发送 HTTP 请求）才能正确工作。因此，副作用本身并不是问题，但如果处理不当，它们可能会引起问题（例如，无限循环）。
- en: With the knowledge gained in this chapter, you know how to handle side effects
    efficiently with `useEffect()` and related key concepts.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章获得的知识，你知道如何使用 `useEffect()` 和相关关键概念高效地处理副作用。
- en: Many side effects are triggered because of user input or interaction—for example,
    because some form was submitted. The next chapter will revisit the concept of
    form submissions by exploring React’s **form actions** feature.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 许多副作用都是由于用户输入或交互触发的——例如，因为某个表单已提交。下一章将通过探索 React 的 **表单操作** 功能来回顾表单提交的概念。
- en: Test Your Knowledge!
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你的知识！
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to examples that can be
    found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/08-effects/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/08-effects/exercises/questions-answers.md)
    :'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你对本章涵盖的概念的了解。然后，你可以将你的答案与可以在 [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/08-effects/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/08-effects/exercises/questions-answers.md)
    找到的示例进行比较。：
- en: How would you define a side effect?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何定义副作用？
- en: What’s a potential problem that could arise with some side effects in React
    components?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 React 组件中，某些副作用可能会出现什么潜在问题？
- en: How does the `useEffect()` Hook work?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useEffect()` 钩子是如何工作的？'
- en: Which values should *not* be added to the `useEffect()` dependencies array?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该将哪些值**不**添加到 `useEffect()` 依赖项数组中？
- en: Which value can be returned by the effect function? And which kind of value
    *must not* be returned?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 效果函数可以返回哪种值？以及哪种类型的值**不得**返回？
- en: Apply What You Learned
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用你所学的知识
- en: Now that you know about effects, you can add even more exciting features to
    your React apps. Fetching data via HTTP upon rendering a component is just as
    easy as accessing browser storage when some state changes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了效果，你可以在你的React应用中添加更多令人兴奋的功能。在组件渲染时通过HTTP获取数据与在状态变化时访问浏览器存储一样简单。
- en: In the following section, you’ll find an activity that allows you to practice
    working with effects and `useEffect()` . As always, you will need to employ some
    of the concepts covered in earlier chapters (such as working with state).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将找到一个活动，让你练习使用效果和`useEffect()`。像往常一样，你需要应用前面章节中介绍的一些概念（例如，处理状态）。
- en: 'Activity 8.1: Building a Basic Blog'
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第8.1节：构建基本博客
- en: In this activity, you must add logic to an existing React app to render a list
    of blog post titles fetched from a backend web API and submit newly added blog
    posts to that same API. The backend API used is [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    , which is a dummy API that doesn’t actually store any data you send to it. It
    will always return the same dummy data, but it’s perfect for practicing sending
    HTTP requests.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你必须向现有的React应用添加逻辑，以渲染从后端Web API获取的博客文章列表，并将新添加的博客文章提交到同一个API。使用的后端API是[https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)，这是一个模拟API，实际上不会存储你发送给它的任何数据。它总是会返回相同的模拟数据，但它非常适合练习发送HTTP请求。
- en: As a bonus, you can also add logic to change the text of the submit button while
    the HTTP request to save the new blog post is on its way.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 作为奖励，你还可以添加逻辑来在保存新博客文章的HTTP请求进行时更改提交按钮的文本。
- en: Use your knowledge about effects and browser-side HTTP requests to implement
    a solution.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你关于效果和浏览器端HTTP请求的知识来实现解决方案。
- en: '**Note**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the starting code for this activity at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/activities/practice-1-start)
    . When downloading this code, you’ll always download the entire repository. Make
    sure to then navigate to the subfolder with the starting code ( `activities/practice-1-start`
    , in this case) to use the right code snapshot.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下位置找到这个活动的起始代码：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/activities/practice-1-start)。下载此代码时，你将始终下载整个仓库。请确保然后导航到包含起始代码的子文件夹（在这个例子中是`activities/practice-1-start`），以使用正确的代码快照。
- en: 'For this activity, you need to know how to send HTTP requests ( `GET` , `POST`
    , and so on) via JavaScript (for example, via the `fetch()` function or with the
    help of a third-party library). If you don’t have that knowledge yet, this resource
    can get you started: [http://packt.link/DJ6Hx](http://packt.link/DJ6Hx) .'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个活动，你需要知道如何通过JavaScript发送HTTP请求（例如，通过`fetch()`函数或使用第三方库）。如果你还没有这方面的知识，这个资源可以帮助你入门：[http://packt.link/DJ6Hx](http://packt.link/DJ6Hx)。
- en: 'After downloading the code and running `npm install` in the project folder
    to install all required dependencies, the solution steps are as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下载代码并在项目文件夹中运行`npm install`以安装所有必需的依赖项后，解决方案步骤如下：
- en: Send a `GET` HTTP request to the dummy API to fetch blog posts inside the `App`
    component (when the component is first rendered).
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向模拟API发送`GET` HTTP请求，在`App`组件内部获取博客文章（当组件首次渲染时）。
- en: Display the fetched dummy blog posts on the screen.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕上显示获取到的模拟博客文章。
- en: Handle form submissions and send a `POST` HTTP request (with some dummy data)
    to the dummy backend API.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理表单提交并向模拟后端API发送`POST` HTTP请求（带有一些模拟数据）。
- en: 'Bonus: Set the button caption to `Saving…` while the request is on its way
    (and to `Save` when it’s not).'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 奖励：在请求进行时将按钮标题设置为`Saving…`（当请求完成时设置为`Save`）。
- en: 'The expected result should be a user interface that looks like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的结果应该是一个看起来像这样的用户界面：
- en: '![img](img/B31339_08_09.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_08_09.png)'
- en: 'Figure 8.9: The final user interface'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：最终用户界面
- en: '**Note**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You will find a full example solution here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/activities/practice-1)
    .'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下位置找到完整的示例解决方案：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/activities/practice-1)。
