<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer026">
			<h1 id="_idParaDest-53"><em class="italic"><a id="_idTextAnchor055"/>Chapter 4</em>: Exploring Angular Components Features</h1>
			<p>In <a href="B16295_03_ePub_RK.xhtml#_idTextAnchor047"><em class="italic">Chapter 3</em></a>, <em class="italic">Introducing CSS Custom Properties and New Provider Scopes,</em> we explored new platform and framework features in depth to prepare for <em class="italic">Part 2, Build a Real-World Application with the Angular Ivy Features You Learned</em>. Let's continue, but this time focus on brand new APIs introduced in the Angular component packages.</p>
			<p>With Angular Ivy, the two first official Angular packages for Google products were introduced: YouTube Player and embedded Google Maps. We will explore both of these packages in this chapter.</p>
			<p>Finally, we will cover two new APIs introduced by the Angular CDK: the Clipboard API and component testing harnesses. The Angular CDK clipboard directive, service, and domain object interact with the operating system's native clipboard. A component harness is a testing API wrapping one or more Angular components using the test-as-a-user approach. It is usable in the context of unit tests and end-to-end tests.</p>
			<p>This chapter covers the following topics:</p>
			<ul>
				<li>Angular YouTube Player</li>
				<li>Angular Google Maps components</li>
				<li>The Clipboard API</li>
				<li>Testing as a user with component harnesses</li>
			</ul>
			<p>Learning about these topics will enable you to use these powerful features for our existing application in <em class="italic">Part 2, Build a Real-World Application with the Angular Ivy Features You Learned</em>.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor056"/>Technical requirements</h1>
			<p>To proceed with this chapter, you will need the following:</p>
			<ul>
				<li>Angular 9.0</li>
				<li>TypeScript 3.6</li>
			</ul>
			<p>You can find the complete code for the video and map examples in this book's companion GitHub repository at <a href="https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter4">https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter4</a>.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor057"/>Angular YouTube Player</h1>
			<p>As part of Angular Ivy, the Angular team published official Angular components for Google products. One of them is the Angular YouTube Player. As the name suggests, it is used to embed <a id="_idIndexMarker188"/>a YouTube video player in your Angular application while getting the convenience of Angular data binding as well as programmatic access to the YouTube Player API through a component reference.</p>
			<p>In this section, we will go through the setup needed to start using the Angular YouTube Player. We will then look at its entire API to get familiar with its capabilities and usage.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor058"/>Getting started</h2>
			<p>First, make sure to install the <strong class="source-inline">@angular/youtube-player</strong> package by using the following command:</p>
			<p class="source-code">ng add @angular/youtube-player</p>
			<p>Now add <strong class="source-inline">YouTubePlayerModule</strong> to the module that declares the component that is going to use the YouTube Player component, as shown in the following code:</p>
			<p class="source-code">import { NgModule } from '@angular/core';</p>
			<p class="source-code">import { YouTubePlayerModule } from '@angular/youtube-player';</p>
			<p class="source-code">import { VideoComponent } from './video.component';</p>
			<p class="source-code">@NgModule({</p>
			<p class="source-code">  declarations: [VideoComponent],</p>
			<p class="source-code">  exports: [VideoComponent],</p>
			<p class="source-code">  imports: [YouTubePlayerModule],</p>
			<p class="source-code">})</p>
			<p class="source-code">export class VideoModule {}</p>
			<p>Before using the Angular YouTube Player component for the first time, we must load the YouTube IFrame API script. It is a 100 KB script, so depending on your priorities, there are several <a id="_idIndexMarker189"/>ways to load it. You could load it as part of the <strong class="source-inline">scripts</strong> option in your application project configuration in <strong class="source-inline">angular.json</strong>, but then the user would always pay the price upfront for loading, parsing, and executing this script.</p>
			<p>Instead, we can load it in when the component using it is activated, as we will see in the following tutorial:</p>
			<ol>
				<li>First, we import the Angular core and common APIs we need and declare component metadata and the component name, in this case, <strong class="source-inline">VideoComponent</strong>:<p class="source-code">import { DOCUMENT } from '@angular/common';</p><p class="source-code">import { Component, Inject, OnDestroy, OnInit } from '@angular/core';</p><p class="source-code">@Component({</p><p class="source-code">  selector: 'app-video',</p><p class="source-code">  templateUrl: './video.component.html',</p><p class="source-code">})</p><p class="source-code">export class VideoComponent implements OnDestroy, OnInit {</p></li>
				<li>Next, we add a private property to keep a reference to the script we are going to dynamically load:<p class="source-code">  #youtubeIframeScript: HTMLScriptElement;</p></li>
				<li>Now, we inject the <strong class="source-inline">Document</strong> object of our platform, that is, the browser or the server:<p class="source-code">  constructor(@Inject(DOCUMENT) private document: </p><p class="source-code">   Document) {</p></li>
				<li>We create an <strong class="source-inline">async</strong> script element that points to the https://www.youtube.com/iframe_api URL. This is a loader script for the initialization script, which sets up the YouTube API needed to embed YouTube videos. The Angular YouTube Player component is a convenient wrapper around this API:<p class="source-code">    this.#youtubeIframeScript = </p><p class="source-code">     this.document.createElement('script');</p><p class="source-code">    this.#youtubeIframeScript.src = </p><p class="source-code">     'https://www.youtube.com/iframe_api';</p><p class="source-code">    this.#youtubeIframeScript.async = true;</p><p class="source-code">  }</p></li>
				<li>When <strong class="source-inline">VideoComponent</strong> is initializing, add the YouTube IFrame API script element to <a id="_idIndexMarker190"/>the body element of the HTML document:<p class="source-code">  ngOnInit(): void {</p><p class="source-code">    this.document.body.appendChild(</p><p class="source-code">     this.#youtubeIframeScript);</p><p class="source-code">  }</p></li>
				<li>We remove the script element when <strong class="source-inline">VideoComponent</strong> is deactivated:<p class="source-code">  ngOnDestroy(): void {</p><p class="source-code">    this.document.body.removeChild(</p><p class="source-code">     this.#youtubeIframeScript);</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>Do not worry about loading the script multiple times. The browser will cache it and the YouTube IFrame API script will detect that it has already been loaded. For an even more robust setup solution, we can listen for the <strong class="source-inline">loaded</strong> event on the script element, set a loaded flag in our code, and add a condition not to load the script the next time this component is activated.</p>
			<p>This is all the <a id="_idIndexMarker191"/>setup we need to use the Angular YouTube Player component. The full example is available in this book's companion GitHub repository, as mentioned in the introduction of this chapter. Now, let's move on to usage instructions.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor059"/>Usage</h2>
			<p>The simplest <a id="_idIndexMarker192"/>example of using the Angular YouTube Player is to put the following code snippet in a component template:</p>
			<p class="source-code">&lt;youtube-player videoId="8NQCgmAQEdE"&gt;&lt;/youtube-player&gt;</p>
			<p>We pass a YouTube video ID to the <strong class="source-inline">videoId</strong> input property and the Angular YouTube Player will take care of everything else. Of course, it also allows for more customization. Let's start by looking at the <strong class="source-inline">YouTubePlayer</strong> component's data binding API.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor060"/>API reference</h2>
			<p>As of Angular version 12, the YouTube Player has no API reference. This is provided for you in this <a id="_idIndexMarker193"/>section so that you do not have to look <a id="_idIndexMarker194"/>up the source code and cross-reference it with the online YouTube JavaScript API reference to use it.</p>
			<h3>The data binding API</h3>
			<p>With the <a id="_idIndexMarker195"/>data binding API, we can declaratively configure the <a id="_idIndexMarker196"/>Angular YouTube Player component. The input properties are used to configure settings while the output properties emit events about user interactions and the video environment.</p>
			<p>First, we will look at the input properties.</p>
			<h4>Input properties</h4>
			<p>The input <a id="_idIndexMarker197"/>properties are used to configure the playback and visuals of the embedded player:</p>
			<ul>
				<li><strong class="source-inline">@Input() endSeconds: number | undefined;</strong><p>To set a playback ending point of the YouTube video, pass the offset in the number of seconds from the beginning of the video.</p></li>
				<li><strong class="source-inline">@Input() height: number | undefined;</strong><p>The height of the YouTube Player is specified using the <strong class="source-inline">height</strong> input property, in the number of CSS pixels. It defaults to <strong class="source-inline">390</strong>.</p></li>
				<li><strong class="source-inline">@Input() playerVars: YT.PlayerVars | undefined;</strong><p>Many additional options can be passed to the <strong class="source-inline">playerVars</strong> input property, for example, we can pass <strong class="source-inline">{ modestbranding: YT.ModestBranding.Modest }</strong> to hide the YouTube logo. For a full reference, see <a href="https://developers.google.com/youtube/player_parameters.html?playerVersion=HTML5#Parameters">https://developers.google.com/youtube/player_parameters.html?playerVersion=HTML5#Parameters</a>.</p></li>
				<li><strong class="source-inline">@Input() showBeforeIframeApiLoads: boolean | undefined;</strong><p>The <strong class="source-inline">showBeforeIframeApiLoads</strong> input property defaults to <strong class="source-inline">false</strong> but can be set to <strong class="source-inline">true</strong> to make the YouTube Player component throw an error if it is loaded before the YouTube IFrame API is loaded.</p></li>
				<li><strong class="source-inline">@Input() startSeconds: number | undefined;</strong><p>To set a playback starting point for the YouTube video, pass the offset in the number of seconds from the beginning of the video.</p></li>
				<li><strong class="source-inline">@Input() suggestedQuality: YT.SuggestedVideoQuality | undefined;</strong><p>The <strong class="source-inline">suggestedQuality</strong> input property accepts one of the following quality identifiers: <strong class="source-inline">'default'</strong>, <strong class="source-inline">'small'</strong>, <strong class="source-inline">'medium'</strong>, <strong class="source-inline">'large'</strong>, <strong class="source-inline">'hd720'</strong>, <strong class="source-inline">'hd1080'</strong>, <strong class="source-inline">'highres'</strong>.</p></li>
				<li><strong class="source-inline">@Input() videoId: string | undefined;</strong><p>The <strong class="source-inline">videoId</strong> input property accepts the YouTube video ID of the video to be played back.</p></li>
				<li><strong class="source-inline">@Input() width: number | undefined;</strong><p>The width of the YouTube Player is specified using the <strong class="source-inline">width</strong> input property, in the number of CSS pixels. It defaults to <strong class="source-inline">640</strong>.</p></li>
			</ul>
			<p>Next, we will <a id="_idIndexMarker198"/>look at the output properties, which emit events about the user interactions and video environment.</p>
			<h4>Output properties</h4>
			<p>The output <a id="_idIndexMarker199"/>properties expose the events that are emitted by the YouTube IFrame API. For a full reference of the events, see https://developers.google.com/youtube/iframe_api_reference#Events:</p>
			<ul>
				<li><strong class="source-inline">@Output() apiChange: Observable&lt;YT.PlayerEvent&gt;;</strong><p>When the closed captioning module is loaded or unloaded, an event is emitted by the <strong class="source-inline">apiChange</strong> output property.</p></li>
				<li><strong class="source-inline">@Output() error: Observable&lt;YT.OnErrorEvent&gt;;</strong><p>The <strong class="source-inline">error</strong> output property emits an event when one of the following errors occurs, all of which are accessible through the <strong class="source-inline">YT.PlayerError</strong> enum: <strong class="source-inline">EmbeddingNotAllowed</strong>, <strong class="source-inline">EmbeddingNotAllowed2</strong>, <strong class="source-inline">Html5Error</strong>, <strong class="source-inline">InvalidParam</strong>, <strong class="source-inline">VideoNotFound</strong>.</p></li>
				<li><strong class="source-inline">@Output() playbackQualityChange: Observable&lt;YT.OnPlaybackQualityChangeEvent&gt;;</strong><p>When the playback quality changes, one of the following quality identifiers is emitted through the <strong class="source-inline">playbackQualityChange</strong> output property: <strong class="source-inline">'default'</strong>, <strong class="source-inline">'small'</strong>, <strong class="source-inline">'medium'</strong>, <strong class="source-inline">'large'</strong>, <strong class="source-inline">'hd720'</strong>, <strong class="source-inline">'hd1080'</strong>, <strong class="source-inline">'highres'</strong>.</p></li>
				<li><strong class="source-inline">@Output() playbackRateChange:Observable&lt;YT.OnPlaybackRateChangeEvent&gt;;</strong><p>When the video playback rate is changed, the <strong class="source-inline">playbackRateChange</strong> output property emits an event where its <strong class="source-inline">data</strong> property is a number such as <strong class="source-inline">1.0</strong> signifying the playback speed.</p></li>
				<li><strong class="source-inline">@Output() ready: Observable&lt;YT.PlayerEvent&gt;;</strong><p>This event is emitted when the YouTube Player is fully loaded and ready to be controlled.</p></li>
				<li><strong class="source-inline">@Output() stateChange: Observable&lt;YT.OnStateChangeEvent&gt;;</strong><p>An event is output every time the YouTube Player state changes to one of the following, which are all accessible through the <strong class="source-inline">YT.PlayerState</strong> enum: <strong class="source-inline">BUFFERING</strong>, <strong class="source-inline">CUED</strong>, <strong class="source-inline">ENDED</strong>, <strong class="source-inline">PAUSED</strong>, <strong class="source-inline">PLAYING</strong>, <strong class="source-inline">UNSTARTED</strong>.</p></li>
			</ul>
			<p>Our components <a id="_idIndexMarker200"/>can send commands or read information from the YouTube Player using its components methods, which we will discuss next.</p>
			<h3>Component methods</h3>
			<p>The <strong class="source-inline">YouTubePlayer</strong> component <a id="_idIndexMarker201"/>has several public <a id="_idIndexMarker202"/>methods that we can use to control the embedded video player:</p>
			<ul>
				<li><strong class="source-inline">getAvailablePlaybackRates(): number[];</strong><p>Determines the supported playback rate for the current active or queued video. For a video supporting only normal playback speed, <strong class="source-inline">[1.0]</strong> is returned. Something like <strong class="source-inline">[0.25, 0.5, 1.0, 1.5, 2.0]</strong> might be returned.</p></li>
				<li><strong class="source-inline">getCurrentTime(): number;</strong><p>Determines the number of seconds elapsed since the beginning of the video.</p></li>
				<li><strong class="source-inline">getDuration(): number;</strong><p>Determines the duration in seconds of the current active video. If the video's metadata has not been loaded, it will return <strong class="source-inline">0</strong>.</p><p>For live streams, it will return the number of seconds since the stream started, was reset, or interrupted.</p></li>
				<li><strong class="source-inline">getPlaybackRate(): number;</strong><p>Determines the playback rate of the current active or queued video where <strong class="source-inline">1.0</strong> is the normal playback speed.</p></li>
				<li><strong class="source-inline">getPlayerState(): YT.PlayerState | undefined;</strong><p>Determines <a id="_idIndexMarker203"/>the current player state between <a id="_idIndexMarker204"/>one of the following, which are all accessible through the <strong class="source-inline">YT.PlayerState</strong> enum: <strong class="source-inline">BUFFERING</strong>, <strong class="source-inline">CUED</strong>, <strong class="source-inline">ENDED</strong>, <strong class="source-inline">PAUSED</strong> , <strong class="source-inline">PLAYING</strong>, <strong class="source-inline">UNSTARTED</strong>. Returns the latest value represented by an event emitted by the <strong class="source-inline">stateChange</strong> output property.</p></li>
				<li><strong class="source-inline">getVideoEmbedCode(): string;</strong><p>Determines the HTML markup needed to embed the video in an HTML page, for example:</p><p class="source-code">&lt;iframe id="ytplayer" type="text/html" width="720" height="405"</p><p class="source-code">src="https://www.youtube.com/embed/8NQCgmAQEdE"</p><p class="source-code">frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</p></li>
				<li><strong class="source-inline">getVideoLoadedFraction(): number;</strong><p>Determines the percentage of the video that has been buffered by the player where <strong class="source-inline">0.0</strong> is 0% and <strong class="source-inline">1.0</strong> is 100%.</p></li>
				<li><strong class="source-inline">getVideoUrl(): string;</strong><p>Determines the video's full URL on <a href="http://youtube.com">youtube.com</a>.</p></li>
				<li><strong class="source-inline">getVolume(): number;</strong><p>Determines the volume level between <strong class="source-inline">0</strong> and <strong class="source-inline">100</strong>. Only returns integers. When muted, this method will return the level that was active when the audio was muted.</p></li>
				<li><strong class="source-inline">isMuted(): boolean;</strong><p>Checks whether the audio is muted. <strong class="source-inline">true</strong> means muted, <strong class="source-inline">false</strong> means unmuted.</p></li>
				<li><strong class="source-inline">mute(): void;</strong><p>Mutes the audio.</p></li>
				<li><strong class="source-inline">pauseVideo(): void;</strong><p>Pauses the video. An event is emitted through <strong class="source-inline">stateChange</strong>.</p></li>
				<li><strong class="source-inline">playVideo(): void;</strong><p>Starts playing the video. Does not count towards the video's view count on YouTube. An event is emitted through <strong class="source-inline">stateChange</strong>.</p></li>
				<li><strong class="source-inline">seekTo(seconds: number, allowSeekAhead: boolean): void;</strong><p>Goes to the <a id="_idIndexMarker205"/>specified timestamp. The video will <a id="_idIndexMarker206"/>keep being paused if paused before seeking. Setting <strong class="source-inline">allowSeekAhead</strong> to <strong class="source-inline">false</strong> keeps the player from downloading unbuffered content from the server. This can be used in combination with a progress bar.</p></li>
				<li><strong class="source-inline">setPlaybackRate(playbackRate: number): void;</strong><p>Adjusts the playback speed. Only affects the current active or queued video. Passing <strong class="source-inline">1.0</strong> to <strong class="source-inline">playbackRate</strong> sets the playback speed to normal.</p><p>We should first call <strong class="source-inline">getAvailablePlaybackRates</strong> to check which playback rates are supported for the video. Listen to events emitted by the <strong class="source-inline">playbackRateChange</strong> output property to verify that the playback speed was successfully adjusted.</p><p>If the passed <strong class="source-inline">playbackRate</strong> does not exactly match supported playback speeds, the nearest rate will be matched, rounding to <strong class="source-inline">1.0</strong>.</p></li>
				<li><strong class="source-inline">setVolume(volume: number): void;</strong><p>Adjusts the volume to a level between <strong class="source-inline">0</strong> and <strong class="source-inline">100</strong>. Only accepts integers.</p></li>
				<li><strong class="source-inline">stopVideo(): void;</strong><p>Stops loading or playing the video. We can use this if we know that the user will not be watching additional videos in the YouTube Player. It's not necessary to call it before playing a different video. An event is emitted through <strong class="source-inline">stateChange</strong>, but the state could be any of <strong class="source-inline">CUED</strong>, <strong class="source-inline">ENDED</strong>, <strong class="source-inline">PAUSED</strong>, or <strong class="source-inline">UNSTARTED</strong>.</p></li>
				<li><strong class="source-inline">unMute(): void;</strong><p>Unmutes the audio.</p></li>
			</ul>
			<p>With the knowledge of the full component API of the <strong class="source-inline">YouTubePlayer</strong> component, you can build your <a id="_idIndexMarker207"/>own controls on top of it, configure <a id="_idIndexMarker208"/>default settings across all YouTube Players in our application, control many YouTube Players at the same time or implement a YouTube video snippet widget using Angular.</p>
			<p>We have discussed how to install and set up your application for the Angular YouTube Player. We have seen a simple example usage, listed its full API, and discussed its use cases. You are now ready to use the Angular YouTube Player in <em class="italic">Part 2, Build a Real-World Application with the Angular Ivy Features You Learned.</em></p>
			<p>Next, we will look at the official Angular components for Google Maps.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor061"/>Angular Google Maps components</h1>
			<p>In this section, we will <a id="_idIndexMarker209"/>look at the official Google <a id="_idIndexMarker210"/>product component package called Angular Google Maps. The Google Maps API is large, so this package includes both a <strong class="source-inline">GoogleMap</strong> component and several other components used to configure and control its many features.</p>
			<p>It consists of the following Angular components and directives:</p>
			<ul>
				<li><strong class="source-inline">GoogleMap</strong></li>
				<li><strong class="source-inline">MapBicyclingLayer</strong></li>
				<li><strong class="source-inline">MapCircle</strong></li>
				<li><strong class="source-inline">MapGroundOverlay</strong></li>
				<li><strong class="source-inline">MapInfoWindow</strong></li>
				<li><strong class="source-inline">MapKmlLayer</strong></li>
				<li><strong class="source-inline">MapMarker</strong></li>
				<li><strong class="source-inline">MapMarkerClusterer</strong></li>
				<li><strong class="source-inline">MapPolygon</strong></li>
				<li><strong class="source-inline">MapRectangle</strong></li>
				<li><strong class="source-inline">MapTrafficLayer</strong></li>
				<li><strong class="source-inline">MapTransitLayer</strong></li>
			</ul>
			<p>We will <a id="_idIndexMarker211"/>explore the necessary component, <strong class="source-inline">GoogleMap</strong>, and the <a id="_idIndexMarker212"/>commonly used components <strong class="source-inline">MapInfoWindow</strong>, <strong class="source-inline">MapMarker</strong>, and <strong class="source-inline">MapMarkerClusterer</strong>.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor062"/>Getting started</h2>
			<p>To use the Angular Google Maps components, we first must load the Google Maps JavaScript API. This example wrapper component illustrates how to conditionally render the Google Maps component after the Google Maps JavaScript API has been initialized:</p>
			<p class="source-code">import { Component, ViewChild } from '@angular/core';</p>
			<p class="source-code">import { HttpClient } from '@angular/common/http';</p>
			<p class="source-code">import { GoogleMap }from '@angular/google-maps';</p>
			<p class="source-code">import { Observable, of } from 'rxjs';</p>
			<p class="source-code">import { catchError, mapTo } from 'rxjs/operators';</p>
			<p class="source-code">import { AppConfig } from '../app-config';</p>
			<p class="source-code">@Component({</p>
			<p class="source-code">  selector: 'app-map',</p>
			<p class="source-code">  templateUrl: './map.component.html',</p>
			<p class="source-code">})</p>
			<p class="source-code">export class MapComponent {</p>
			<p class="source-code">  @ViewChild(GoogleMap, { static: false })</p>
			<p class="source-code">map?: GoogleMap;</p>
			<p class="source-code">isGoogleMapsApiLoaded$: Observable&lt;boolean&gt; = this.http.jsonp('https://maps.googleapis.com/maps/api/js?key=${this.config.googleMapsApiKey}','callback').pipe(</p>
			<p class="source-code">mapTo(true),</p>
			<p class="source-code">   catchError(() =&gt; of(false)),</p>
			<p class="source-code">  );</p>
			<p class="source-code">  constructor(</p>
			<p class="source-code">    private config: AppConfig,</p>
			<p class="source-code">    private http: HttpClient,</p>
			<p class="source-code">  ) {}</p>
			<p class="source-code">}</p>
			<p>Our <strong class="source-inline">MapComponent</strong> has <a id="_idIndexMarker213"/>an observable UI property <a id="_idIndexMarker214"/>called <strong class="source-inline">isGoogleMapsApiLoaded$</strong>, which loads the Google Maps JavaScript API with a pre-configured API key. We use this to conditionally render the <strong class="source-inline">GoogleMap</strong> component in the component template, as shown in the following code:</p>
			<p class="source-code">&lt;google-map *ngIf="isGoogleMapsApiLoaded$ | async; else spinner"&gt;&lt;/google-map&gt;</p>
			<p class="source-code">&lt;ng-template #spinner&gt;</p>
			<p class="source-code">&lt;mat-spinner&gt;&lt;/mat-spinner&gt;</p>
			<p class="source-code">&lt;/ng-template&gt;</p>
			<p>Until the Google Maps JavaScript API is loaded, an Angular Material Spinner component is shown.</p>
			<p>Notice that <a id="_idIndexMarker215"/>we created a view child query for <strong class="source-inline">GoogleMap</strong> and stored <a id="_idIndexMarker216"/>it in the <strong class="source-inline">map</strong> property. This can be used to programmatically control the map from the component model.</p>
			<p>For reference, here is the Angular module that declares our example <strong class="source-inline">MapComponent</strong>:</p>
			<p class="source-code">import { CommonModule } from '@angular/common';</p>
			<p class="source-code">import { HttpClientModule, HttpClientJsonpModule } from '@angular/common/http';</p>
			<p class="source-code">import { NgModule } from '@angular/core';</p>
			<p class="source-code">import { GoogleMapsModule } from '@angular/google-maps';</p>
			<p class="source-code">import { MatProgressSpinnerModule } from'@angular/material/progress-spinner';</p>
			<p class="source-code">import { MapComponent } from './map.component';</p>
			<p class="source-code">@NgModule({</p>
			<p class="source-code">  declarations: [MapComponent],</p>
			<p class="source-code">  exports: [MapComponent],</p>
			<p class="source-code">  imports: [</p>
			<p class="source-code">    HttpClientModule,</p>
			<p class="source-code">    HttpClientJsonpModule,</p>
			<p class="source-code">    GoogleMapsModule,</p>
			<p class="source-code">    MatProgressSpinnerModule,</p>
			<p class="source-code">  ],</p>
			<p class="source-code">})</p>
			<p class="source-code">export class MapModule {}</p>
			<p>Now that we <a id="_idIndexMarker217"/>have all the setup needed to work with <a id="_idIndexMarker218"/>the Angular Google Maps API, let's take a closer look at the most common components included in the <strong class="source-inline">@angular/google-maps</strong> package.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor063"/>The GoogleMap component</h2>
			<p>The <strong class="source-inline">GoogleMap</strong> component <a id="_idIndexMarker219"/>is the primary entry point to the Angular Google Maps package. It is the top-level component that can contain other components from this package.</p>
			<p>This component is a declarative, Angular-specific wrapper for the <strong class="source-inline">google.maps.Map</strong> class from the Google Maps JavaScript API. Refer to the API reference for more details on the <strong class="source-inline">Map</strong> class (https://developers.google.com/maps/documentation/javascript/reference/map).</p>
			<p>The Google map component has the <strong class="source-inline">center</strong>, <strong class="source-inline">height</strong>, <strong class="source-inline">mapTypeId</strong>, <strong class="source-inline">width</strong>, and <strong class="source-inline">zoom</strong> input properties. It also accepts an <strong class="source-inline">options</strong> input of the <strong class="source-inline">google.maps.MapOptions</strong> type. It has 19 different output properties, all matching DOM events described in the Google Maps JavaScript API reference for the <strong class="source-inline">Map</strong> class. It also has a wide range of methods available for controlling the map.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor064"/>The MapMarker component</h2>
			<p>The <strong class="source-inline">MapMarker</strong> component's <a id="_idIndexMarker220"/>element, <strong class="source-inline">&lt;map-marker&gt;</strong>, is either nested inside the <strong class="source-inline">&lt;google-map&gt;</strong> element or a <strong class="source-inline">&lt;map-marker-clusterer&gt;</strong> element.</p>
			<p>This component represents a marker on a Google map. We can use a label, a marker icon, or a marker symbol to customize it.</p>
			<p><strong class="source-inline">MapMarker</strong> is an Angular-specific wrapper for the <strong class="source-inline">google.maps.Marker</strong> class. It has the <strong class="source-inline">clickable</strong>, <strong class="source-inline">label</strong>, <strong class="source-inline">position</strong>, and <strong class="source-inline">title</strong> input properties. It also accepts an <strong class="source-inline">options</strong> input of the <strong class="source-inline">google.maps.MarkerOptions</strong> type.</p>
			<p>We can pass a custom icon through the marker options, for example, as follows where we use a beach flag icon:</p>
			<p class="source-code">&lt;google-map</p>
			<p class="source-code">  [center]="{ lat: 56.783778, lng: 8.228937 }"</p>
			<p class="source-code">&gt;</p>
			<p class="source-code">  &lt;map-marker</p>
			<p class="source-code">    [options]="{ icon: 'https://developers.google.com/</p>
			<p class="source-code">     maps/documentation/javascript/examples/full/</p>
			<p class="source-code">     images/beachflag.png' }"</p>
			<p class="source-code">    [position]="{ lat: 56.783778, lng: 8.228937 }"</p>
			<p class="source-code">  &gt;&lt;/map-marker&gt;</p>
			<p class="source-code">&lt;/google-map&gt;</p>
			<p>Refer to <a id="_idIndexMarker221"/>the API reference for more details on the <strong class="source-inline">Marker</strong> class (<a href="https://developers.google.com/maps/documentation/javascript/reference/marker">https://developers.google.com/maps/documentation/javascript/reference/marker</a>).</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor065"/>The MapMarkerClusterer component</h2>
			<p>The <strong class="source-inline">MapMarkerClusterer</strong> component is an Angular-specific wrapper around the <strong class="source-inline">MarkerClusterer</strong> class <a id="_idIndexMarker222"/>from the <strong class="source-inline">@googlemaps/markerclustererplus</strong> package. Its element, <strong class="source-inline">&lt;map-marker-clusterer&gt;</strong>, is nested inside of <strong class="source-inline">&lt;google-map&gt;</strong> and contains multiple <strong class="source-inline">&lt;map-marker&gt;</strong> elements.</p>
			<p>This component is used to group many map markers into clusters when zoomed out on a map.</p>
			<p>Before we can use it, we must load it into a global variable by inserting the following script tag at an appropriate place, for simplicity's sake in the template of the component using it:</p>
			<p class="source-code">&lt;script src="https://unpkg.com/@googlemaps/markerclustererplus/dist/index.min.js"&gt;&lt;/script&gt;</p>
			<p>The <strong class="source-inline">MapMarkerClusterer</strong> component has 18 different input properties, such as <strong class="source-inline">minimumClusterSize</strong>, <strong class="source-inline">maxZoom</strong>, and <strong class="source-inline">zoomOnClick</strong>. The <strong class="source-inline">imagePath</strong> input property can be used to specify custom map marker cluster images where this path is automatically suffixed with <strong class="source-inline">[1-5].png</strong> by default.</p>
			<p>Two output <a id="_idIndexMarker223"/>properties are available: <strong class="source-inline">clusteringbegin</strong> and <strong class="source-inline">clusteringend</strong>. They are emitted whenever markers first cluster and when they are split into individual markers, respectively.</p>
			<p>Refer to the API reference for more details on the <strong class="source-inline">MarkerClusterer</strong> class (https://developers.google.com/maps/documentation/javascript/marker-clustering).</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor066"/>The MapInfoWindow component</h2>
			<p>The <strong class="source-inline">MapInfoWindow</strong> component is an Angular-specific wrapper for the <strong class="source-inline">google.maps.InfoWindow</strong> class. Its element, <strong class="source-inline">&lt;map-info-window&gt;</strong>, is nested inside of <strong class="source-inline">&lt;google-map&gt;</strong>.</p>
			<p>It is an <a id="_idIndexMarker224"/>overlay used to display notifications or metadata on top of a map, usually near a map marker.</p>
			<p>Its <strong class="source-inline">position</strong> input property declares where on the map it appears. Additionally, it accepts an <strong class="source-inline">options</strong> input of type <strong class="source-inline">google.maps.InfoWindowOptions</strong>. It has five different output properties – <strong class="source-inline">closeClick</strong>, <strong class="source-inline">contentChanged</strong>, <strong class="source-inline">domready</strong>, <strong class="source-inline">positionChanged</strong>, and <strong class="source-inline">zindexChanged</strong> – all matching DOM events described in the Google Maps JavaScript API reference for the <strong class="source-inline">InfoWindow</strong> class.</p>
			<p>The <strong class="source-inline">MapInfoWindow</strong> component uses content projection, which means that the content we put inside of its custom element tags is rendered in its overlay when opened.</p>
			<p>To display a <strong class="source-inline">MapInfoWindow</strong> component, call its <strong class="source-inline">open</strong> method, which optionally accepts <strong class="source-inline">MapMarker</strong> that the info window will be attached to. The <strong class="source-inline">close</strong> method hides the <strong class="source-inline">MapInfoWindow</strong> component.</p>
			<p>Refer to the API reference for more details on the <strong class="source-inline">InfoWindow</strong> class (https://developers.google.com/maps/documentation/javascript/reference/info-window).</p>
			<p>Now that <a id="_idIndexMarker225"/>you have an overview of the most used parts of the official Google Maps Angular components, you are prepared to use Google Maps in the Angular application in <em class="italic">Part 2, Build a Real-World Application with the Angular Ivy Features You Learned</em>.</p>
			<p>In the next section, we will learn about the Angular CDK's Clipboard API.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor067"/>The Clipboard API</h1>
			<p>The Angular CDK's Clipboard API offers a directive and a service to interact with the operating system's <a id="_idIndexMarker226"/>clipboard through the browser. The <strong class="source-inline">CdkCopyToClipboard</strong> directive can be used declaratively while the <strong class="source-inline">Clipboard</strong> service is used for use cases where a programmatic API is a better fit. The Clipboard API additionally takes care of long texts through the <strong class="source-inline">PendingCopy</strong> class.</p>
			<p>In this section, you will learn how to use each of these classes from the Angular CDK package.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor068"/>The CdkCopyToClipboard directive</h2>
			<p>The <strong class="source-inline">CdkCopyToClipboard</strong> directive is exported by <strong class="source-inline">ClipboardModule</strong>, which is in the <strong class="source-inline">@angular/cdk/clipboard</strong> sub-package. Its directive selector is <strong class="source-inline">[cdkCopyToClipboard]</strong>. The directive has an input property of the same name as the directive, which accepts the text <a id="_idIndexMarker227"/>that is copied when the element it is attached to is clicked.</p>
			<p>Because of browser security concerns, copying text to the clipboard must be done following a click event triggered by a user.</p>
			<p>The copy to clipboard directive additionally has an input property named <strong class="source-inline">cdkCopyToClipboardAttempts</strong>. It accepts a number, which is the number of macrotask cycles the directive will attempt to copy the text for before giving up. This is relevant in the case of bigger text because of an implementation detail that ensures cross-browser compatibility until the upcoming Clipboard API is supported across all major browsers. We will discuss this caveat further when exploring the <strong class="source-inline">PendingCopy</strong> class.</p>
			<p>The copy <a id="_idIndexMarker228"/>to clipboard directive and its retry parameter is demonstrated in the following code snippet:</p>
			<p class="source-code">&lt;button</p>
			<p class="source-code">  [cdkCopyToClipboard]="transactionLog"</p>
			<p class="source-code">  [cdkCopyToClipboardAttempts]="5"</p>
			<p class="source-code">&gt;</p>
			<p class="source-code">  Copy transaction log</p>
			<p class="source-code">&lt;/button&gt;</p>
			<p>Finally, the <strong class="source-inline">CdkCopyToClipboard</strong> directive has an output property named <strong class="source-inline">cdkCopyToClipboardCopied</strong>, which emits a Boolean value every time copying to the clipboard is attempted and indicates whether copying succeeded.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor069"/>The Clipboard service</h2>
			<p>The <strong class="source-inline">Clipboard</strong> service is useful when we want to perform other operations before or after copying <a id="_idIndexMarker229"/>text to the clipboard, if the text is not easily accessible from a component template, or if we want more fine-grained control when copying big texts.</p>
			<p>The clipboard service has two methods. The <strong class="source-inline">Clipboard#copy</strong> method accepts the text to copy to the clipboard and returns a Boolean value indicating whether the copy operation was successful.</p>
			<p>For some large texts, the <strong class="source-inline">Clipboard#copy</strong> method fails and we have to use the <strong class="source-inline">Clipboard#beginCopy</strong> method instead. This method also accepts the text that we want to copy to the clipboard but returns an instance of the <strong class="source-inline">PendingCopy</strong> class that we must interact further with to follow through on the copy to clipboard operation. This class is discussed next.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor070"/>The PendingCopy class</h2>
			<p>An instance of the <strong class="source-inline">PendingCopy</strong> class is returned from the <strong class="source-inline">Clipboard#beginCopy</strong> method. As mentioned earlier in this section, this has to do with implementation details ensuring <a id="_idIndexMarker230"/>cross-browser compatibility for copying large texts.</p>
			<p>The first thing we must learn about the <strong class="source-inline">PendingCopy</strong> class is that we must tear down all instances by calling the <strong class="source-inline">PendingCopy#destroy</strong> method once we have finished using them or our application will leak resources.</p>
			<p>The <strong class="source-inline">PendingCopy#copy</strong> method accepts no arguments and returns a Boolean value indicating whether the copy to clipboard operation succeeded. If <strong class="source-inline">false</strong> is returned, we should schedule another attempt for later.</p>
			<p>As described earlier in this section, the <strong class="source-inline">CdkCopyToClipboard</strong> directive supports a retry strategy for copying large texts by passing a maximum number of attempts to its <strong class="source-inline">cdkCopyToClipboardAttempts</strong> input property.</p>
			<p>Now that we have discussed all parts of the Angular CDK's Clipboard API, we are ready to implement a feature for the hands-on application in <em class="italic">Part 2, Build a Real-World Application with the Angular Ivy Features You Learned.</em></p>
			<p>In the next section, you will learn about component testing harnesses, an innovative API for testing components, and authoring testing APIs for components exposed in library packages.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor071"/>Testing as a user with component harnesses</h1>
			<p>The Angular CDK's API for authoring and using component testing harnesses is a fresh approach <a id="_idIndexMarker231"/>with the test-as-a-user philosophy in mind. Each component or related set of components can have a component <a id="_idIndexMarker232"/>harness for tests. A component harness is a testing API for interacting with those components that can be used in unit, integration, and end-to-end tests.</p>
			<p>Component testing harnesses internally rely only on a single selector for the component they wrap. Library authors can publish component harnesses for their Angular components. In this way, their consumers' tests, which depend on the library's components, will not have dependencies on the DOM structure except for that one selector, which the library authors are able to change if needed.</p>
			<p>This is exactly what the Angular Components team do for Angular CDK and Angular Material. They release and maintain component harnesses for all their Angular components.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor072"/>Harness environments and harness loaders</h2>
			<p>A harness environment represents the context tests using component harnesses are run in. For unit <a id="_idIndexMarker233"/>and integration tests using test runners such as Karma, Jasmine, or Jest, we <a id="_idIndexMarker234"/>use <strong class="source-inline">TestbedHarnessEnvironment</strong>, which is bundled with the Angular CDK. For Protractor end-to-end tests, we use <strong class="source-inline">ProtractorHarnessEnvironment</strong>, which is also released as part of the Angular CDK.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Protractor support is either deprecated or removed, depending on your Angular version.</p>
			<p>If you want to use component harnesses with other end-to-end testing frameworks, you will have to extend the <strong class="source-inline">HarnessEnvironment</strong> base class and implement the <strong class="source-inline">TestElement</strong> interface to work in a different testing environment. Of course, first make sure to look for existing solutions in the Angular ecosystem.</p>
			<p>Only one harness environment can be active at any time. We use the harness environment to create a harness loader. A harness loader has the context of a certain DOM element and is used to query for and create component harnesses based on selectors.</p>
			<p>We will walk through simple code examples featuring harness environments and harness loaders after discussing the API of component harnesses that are distributed as part of Angular Material.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor073"/>Component harnesses</h2>
			<p>A component harness <a id="_idIndexMarker235"/>can technically represent any DOM element and a set of user interactions and traits.</p>
			<p>To get the feel for a component harness, let's first look at the testing harness for the Angular Material Button component.</p>
			<p>The following is the API of <strong class="source-inline">MatButtonHarness</strong>, which is not inherited from the common component harness base classes:</p>
			<ul>
				<li><strong class="source-inline">blur(): Promise&lt;void&gt;;</strong></li>
				<li><strong class="source-inline">click(relativeX: number, relativeY: number): Promise&lt;void&gt;;</strong><p><strong class="source-inline">click('center'): Promise&lt;void&gt;;</strong></p><p><strong class="source-inline">click(): Promise&lt;void&gt;;</strong></p></li>
				<li><strong class="source-inline">focus(): Promise&lt;void&gt;;</strong></li>
				<li><strong class="source-inline">getText(): Promise&lt;string&gt;;</strong></li>
				<li><strong class="source-inline">isDisabled(): Promise&lt;boolean&gt;;</strong></li>
				<li><strong class="source-inline">isFocused(): Promise&lt;boolean&gt;;</strong></li>
			</ul>
			<p>It has a few other methods that it inherits from an Angular CDK base class, but we will not discuss those for now.</p>
			<p>I trust that <a id="_idIndexMarker236"/>you can guess what the methods do, based on their names, parameters, and return values. Notice that they are all asynchronous, that is, they all return a <strong class="source-inline">Promise</strong>.</p>
			<p>Every method except <strong class="source-inline">getText</strong> represents a user interaction. The <strong class="source-inline">getText</strong> method reads content from the DOM, which is displayed to the user, the text of the button to be precise.</p>
			<p>Next, let's explore the API of the testing harness for the Angular Material Select component.</p>
			<p>The following is the API that is specific to <strong class="source-inline">MatSelectHarness</strong>:</p>
			<ul>
				<li><strong class="source-inline">blur(): Promise&lt;void&gt;;</strong></li>
				<li><strong class="source-inline">clickOptions(filter?: OptionFilters): Promise&lt;void&gt;;</strong><p>Pick the drop-down option(s) matching the specified filter. For multi-option selects, multiple options can be picked. For single-option selects, the first matching option is picked.</p></li>
				<li><strong class="source-inline">close(): Promise&lt;void&gt;;</strong><p>Closes the drop-down panel.</p></li>
				<li><strong class="source-inline">focus(): Promise&lt;void&gt;;</strong></li>
				<li><strong class="source-inline">getOptionGroups(filter?: OptionGroupFilters): Promise&lt;OptionGroup[]&gt;;</strong><p>Read drop-down option groups matching the specified filter.</p></li>
				<li><strong class="source-inline">getOptions(filter?: OptionFilters): Promise&lt;Option[]&gt;;</strong><p>Read drop-down options matching the specified filter.</p></li>
				<li><strong class="source-inline">getValueText(): Promise&lt;string&gt;;</strong><p>Read the value of the chosen drop-down option.</p></li>
				<li><strong class="source-inline">isDisabled(): Promise&lt;boolean&gt;;</strong></li>
				<li><strong class="source-inline">isEmpty(): Promise&lt;boolean&gt;;</strong><p>Resolves <strong class="source-inline">false</strong> if no value has been picked. Resolves <strong class="source-inline">true</strong> if a value has been picked.</p></li>
				<li><strong class="source-inline">isFocused(): Promise&lt;boolean&gt;;</strong></li>
				<li><strong class="source-inline">isMultiple(): Promise&lt;boolean&gt;;</strong><p>Resolves <strong class="source-inline">true</strong> if the harness wraps a multi-option select component. Resolves <strong class="source-inline">false</strong> if it wraps a single-option select component.</p></li>
				<li><strong class="source-inline">isOpen(): Promise&lt;boolean&gt;;</strong></li>
				<li><strong class="source-inline">isRequired(): Promise&lt;boolean&gt;;</strong></li>
				<li><strong class="source-inline">isValid(): Promise&lt;boolean&gt;;</strong></li>
				<li><strong class="source-inline">open(): Promise&lt;void&gt;;</strong></li>
			</ul>
			<p>These methods <a id="_idIndexMarker237"/>correspond to our expectations about the behavior and information represented by a drop-down picker such as the Angular Material <strong class="bold">Select</strong> component.</p>
			<p>Now that we have discussed the most important concepts of a component harness and seen a few component harness APIs, it is time to look at a test case that combines these concepts.</p>
			<p>The following is an example of a test for an online clothing store. You will have to imagine the implementation of the <strong class="source-inline">ShirtComponent</strong> and collaborating services. In fact, this is what <a id="_idIndexMarker238"/>the test-as-a-user approach is all about. It is component- and implementation-agnostic:</p>
			<ol>
				<li value="1">First, we import the necessary Angular packages:<p class="source-code">import { HarnessLoader } from '@angular/cdk/testing';</p><p class="source-code">import { TestbedHarnessEnvironment } from '@angular/cdk/testing/testbed';</p><p class="source-code">import { TestBed } from '@angular/core/testing';</p><p class="source-code">import { MatButtonModule } from '@angular/material/button';</p><p class="source-code">import { MatButtonHarness } from '@angular/material/button/testing';</p><p class="source-code">import { MatSelectModule } from '@angular/material/select';</p><p class="source-code">import { MatSelectHarness } from '@angular/material/select/testing';</p></li>
				<li>Next, we import the <strong class="source-inline">ShirtComponent</strong> component, the collaborating <strong class="source-inline">OrderService</strong>, and the <strong class="source-inline">OrderSpyService</strong> class to replace it:<p class="source-code">import { OrderService } form './order.service';</p><p class="source-code">import { OrderSpyService } form './order-spy.service';</p><p class="source-code">import { ShirtComponent } from './shirt.component';</p></li>
				<li>Before we can implement test cases, we configure the Angular testing module by setting up the necessary declarables and replacing <strong class="source-inline">OrderService</strong> with a spy service for testing purposes:<p class="source-code">describe('ShirtComponent', () =&gt; {</p><p class="source-code">beforeEach(() =&gt; {</p><p class="source-code">    TestBed.configureTestingModule({</p><p class="source-code">declarations: [ShirtComponent],</p><p class="source-code">      imports: [MatButtonModule, MatSelectModule],</p><p class="source-code">      providers: [</p><p class="source-code">        { provide: OrderService, useClass:          OrderSpyService },</p><p class="source-code">      ],</p><p class="source-code">    });</p><p class="source-code">    const fixture = TestBed.createComponent(</p><p class="source-code">     ShirtComponent);</p></li>
				<li>We use the component fixture from the previous step to create a harness loader for unit tests:<p class="source-code">    loader = TestbedHarnessEnvironment.</p><p class="source-code">     loader(fixture);</p></li>
				<li>Finally, we store <a id="_idIndexMarker239"/>the order spy service in the shared <strong class="source-inline">orderSpy</strong> variable:<p class="source-code">    orderSpy = TestBed.inject(OrderService) as </p><p class="source-code">     OrderSpyService;</p><p class="source-code">});</p><p class="source-code">  let loader: HarnessLoader;</p><p class="source-code">  let orderSpy: OrderSpyService;</p></li>
				<li>Now we load the component harness for the shirt size picker, which is implemented using an Angular Material Select component as seen in this step:<p class="source-code">it('orders a Large shirt', async () =&gt; {</p><p class="source-code">const shirtSizePicker = await loader.getHarness(MatSelectHarness);</p></li>
				<li>For this test case, we also have to load a component harness for the <strong class="bold">purchase</strong> button, which is implemented using the Angular Material Button component:<p class="source-code">    constpurchaseButton = awaitloader.getHarness(</p><p class="source-code">     MatButtonHarness.with({ text: '1-click purchase' });</p></li>
				<li>Next, we perform a sale as the user by picking a <strong class="source-inline">Large</strong> shirt and clicking the <strong class="bold">purchase</strong> button:<p class="source-code">await shirtSizePicker.clickOptions({ text: 'Large' });</p><p class="source-code">    await purchaseButton.click('center');</p></li>
				<li>Finally, we assert that the order service spy has been called as expected:<p class="source-code">    expect(orderSpy.purchase).</p><p class="source-code">     toHaveBeenCalledTimes(1);</p><p class="source-code">  });</p><p class="source-code">});</p></li>
			</ol>
			<p>We see that the test is relatively straightforward because of it using Angular Material's component harnesses. First, the <em class="italic">large</em> shirt size is picked, then the one-click <strong class="bold">purchase </strong>button is clicked, and we expect our order service spy to have been called with an order.</p>
			<p>Notice how we <a id="_idIndexMarker240"/>start out by configuring the Angular testing module as usual in a component test. After creating the component fixture, we use it to create a harness loader. The harness loader is then used to query for component harnesses for Angular Material Select and Button components. A filter is passed to make sure we interact with the correct button.</p>
			<p>We use the component harnesses instead of interacting with component instances or passing selectors to DOM queries. Our test is decoupled from structural DOM changes and implementation details of Angular Material's components.</p>
			<p>Now that we have explored the most important concepts of component harnesses, you are ready to implement your own and use them to test as a user in <em class="italic">Part 2, Build a Real-World Application with the Angular Ivy Features You Learned</em>.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor074"/>Summary</h1>
			<p>In this chapter, we have explored the APIs of the Angular YouTube Player, the Google Maps Angular components, the Angular CDK's Clipboard API, as well as the Angular CDK's component harnesses and how they are used by Angular Material, which we in turn can use in our applications.</p>
			<p>The YouTube Player component is an Angular-specific wrapper around the embedded YouTube Player. We learned how to initialize it and explored its API in detail.</p>
			<p>Many official Angular component wrappers are available to create and interact with the rich API of Google Maps. We learned about the <strong class="source-inline">GoogleMap</strong>, <strong class="source-inline">MapMarker</strong>, <strong class="source-inline">MapMarkerClusterer</strong>, and <strong class="source-inline">MapInfoWindow</strong> components, which are used for common <strong class="bold">Geographic Information System</strong> (<strong class="bold">GIS</strong>) use cases.</p>
			<p>The Angular CDK's Clipboard API is a cross-browser and cross-platform compatible API for interacting with the native clipboard. We learned about the <strong class="source-inline">CdkCopyToClipboard</strong> directive, the <strong class="source-inline">Clipboard</strong> service, and the <strong class="source-inline">PendingCopy</strong> class.</p>
			<p>Finally, we discussed the main concepts of Angular component harnesses introduced by the Angular CDK. We saw examples of component harness APIs exposed by Angular Material and how we can use them to test our own components without relying on implementation details or DOM structures, which might change in a future version of the package.</p>
			<p>With all these exciting new features and APIs fresh in our minds, let's move on to <em class="italic">Part 2, Build a Real-World Application with the Angular Ivy Features You Learned</em>, in which we add new functionality to an existing Angular application. Surely, this knowledge will come in handy.</p>
			<p><a href="B16295_05_ePub_RK.xhtml#_idTextAnchor075"><em class="italic">Chapter 5</em></a>, <em class="italic">Using CSS Custom Properties,</em> starts off <em class="italic">Part 2, Build a Real-World Application with the Angular Ivy Features You Learned</em> by combining CSS Custom Properties and Angular to add a theme picker to the Angular Academy application.</p>
		</div>
	</div></body></html>