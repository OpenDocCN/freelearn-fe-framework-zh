- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Portfolio with Nuxt.js and Storyblok
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve been checking off the topics from the to-do list of applications from
    [*Chapter 1*](B19563_01.xhtml#_idTextAnchor015), you may have noticed that we’ve
    reached the final chapter. To celebrate our achievements, we’ll create a portfolio
    where we can showcase our completed projects from the past, with the flexibility
    to add future projects as well. We’ll also look into deploying the portfolio to
    an online space via an automated process.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll build the portfolio using Nuxt ([https://nuxt.com/](https://nuxt.com/)),
    which will greatly speed up our development process. The content will be stored
    in a Storyblok ([https://www.storyblok.com/](https://www.storyblok.com/)) space.
    For publication, we’ll make use of Netlify ([https://www.netlify.com/](https://www.netlify.com/)),
    which is a very developer-friendly platform for hosting modern web apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Refresher on using Nuxt and using Nuxt as a static site renderer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to apply a headless CMS to organize and manage content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting Nuxt and Storyblok using existing integrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying proven patterns to optimize a website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating deployment to a public host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we’re going to focus on building the essentials of a portfolio website,
    you should be able to make modifications to further personalize the final product
    so that it can continue serving as your personal portfolio website to showcase
    your talents.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Parts of the project in this chapter are based on a guide published by Storyblok:
    [https://www.storyblok.com/tp/add-a-headless-CMS-to-nuxt-3-in-5-minutes](https://www.storyblok.com/tp/add-a-headless-CMS-to-nuxt-3-in-5-minutes).'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like in [*Chapter 8*](B19563_08.xhtml#_idTextAnchor233), we’ll use Nuxt ([https://nuxt.com/](https://nuxt.com/))
    as the framework to build our portfolio website. For our styling and interactions,
    we’ll use a UI library that is part of the Nuxt ecosystem: Nuxt UI ([https://ui.nuxt.com/](https://ui.nuxt.com/)).
    We need to run our local development in SSL mode, for which we will use `mkcert`
    ([https://github.com/FiloSottile/mkcert](https://github.com/FiloSottile/mkcert))
    to generate a locally trusted development certificate.'
  prefs: []
  type: TYPE_NORMAL
- en: Our content will be managed and stored using Storyblok ([https://www.storyblok.com/](https://www.storyblok.com/)),
    which offers an excellent headless **Content Management System** (**CMS**) solution
    with a free tier we can use. A headless CMS is a system that focuses primarily
    on the content and aims to separate the content from the presentation. In our
    case, our presentation is handled by Nuxt, but it could be any application that
    we grant access to the content. This separation of concerns is a concept that
    helps in building scalable applications. Once we have built our portfolio, we
    will use Netlify ([https://www.netlify.com/](https://www.netlify.com/)) to publish
    our portfolio on a public URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'When developing this project, it will help if you have some data prepared beforehand
    to prevent switching contexts during development. Let’s go through previous completed
    projects. For each project we want to display, we prefer a couple of screenshots
    (*Screenshot.rocks* is an excellent browser plugin for creating styled screenshots
    from your window: [https://screenshot.rocks/](https://screenshot.rocks/)) and
    have descriptions prepared.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete code for this chapter here: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/10.portfolio](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/10.portfolio).'
  prefs: []
  type: TYPE_NORMAL
- en: With several projects prepared, we can get started with the initial content
    setup!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Storyblok
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Registering on the Storyblok website is pretty self-explanatory. After the
    initial registration, you will end up in a demo space. We will skip the demo (you
    can always revisit this as part of **Spaces**) and choose to **Create a new space**,
    where we will choose the appropriate name and server location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Creating a new Storyblok space for our portfolio](img/B19563_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Creating a new Storyblok space for our portfolio
  prefs: []
  type: TYPE_NORMAL
- en: After creation, you may encounter a modal referring to a trial period. You can
    select the free community plan directly or after the 14-day trial period.
  prefs: []
  type: TYPE_NORMAL
- en: 'The welcome screen will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The Storyblok dashboard](img/B19563_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The Storyblok dashboard
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of our portfolio, we can close and ignore the **Get Started** section.
    We’ll mainly focus on the **Settings**, **Content**, **Block Library**, and **Assets**
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the **Content** section, we’ll see an entry titled **Home**. Let’s
    open it and take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – The initial wizard on the Home entry](img/B19563_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – The initial wizard on the Home entry
  prefs: []
  type: TYPE_NORMAL
- en: This screen lets us know that we can preview our content in what Storyblok refers
    to as an **in-context preview**. This means we can load our portfolio in the Storyblok
    environment to offer a very realistic preview of our portfolio!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s set this up to see what this means in practice. We will need (you may
    have guessed it by this point) the **Access token** value to connect the CMS to
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Nuxt portfolio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll use the `nuxi` Nuxt CLI tool to create a new project, similar to what
    we did in [*Chapter 8*](B19563_08.xhtml#_idTextAnchor233):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we’ll choose `npm` as our package manager. If you haven’t installed
    the `mkcert` tool ([https://github.com/FiloSottile/mkcert](https://github.com/FiloSottile/mkcert))
    to generate SSL certificates, you need to follow the appropriate installation
    instructions to proceed: [https://github.com/FiloSottile/mkcert#installation](https://github.com/FiloSottile/mkcert#installation).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the installation is done, we can generate a localhost certificate using
    the following command in the command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should result in an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Successfully generated SSL certificate](img/B19563_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Successfully generated SSL certificate
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we need to do is update the development script in the `package.json`
    file so that we can run the Nuxt development servers in SSL mode. Find the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following line, which adds the certificate and points the
    process to a `.``env` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also create a `.env` file containing the following information (the **Access
    token** value can be found on the **Welcome** page in Storyblok):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you have skipped the Storyblok **Welcome** page, you can review the token
    via the Storyblok menu. Navigate to **Settings**, then **Access tokens** – it
    should be listed there.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we must run the `npm run dev` command from the terminal to start the development
    server. Note that you can access the server now via the HTTPS protocol!
  prefs: []
  type: TYPE_NORMAL
- en: On the Storyblok **Welcome** page, we can now fill in the **Set up preview URL**
    field so that it contains the local URL (this should be similar to the prefilled
    placeholder). Don’t forget the trailing slash!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get an error in Storyblok, you may need to open the URL in your browser
    first as the browser might flag the local certificate as not private. If you accept
    the certificate in your browser, you can reload the Storyblok interface; it should
    show the Nuxt welcome page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – The Nuxt welcome screen loaded in the Storyblok interface!](img/B19563_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – The Nuxt welcome screen loaded in the Storyblok interface!
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty neat! You’re able to see a locally run preview from an online
    CMS interface! Nothing is editable yet, but we’ll work on this next.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Nuxt modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For now, we can stop the Nuxt server to install some Nuxt modules we’ll be
    using. In the terminal, use the following command to install the Storyblok module
    ([https://github.com/storyblok/storyblok-nuxt](https://github.com/storyblok/storyblok-nuxt)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The *Storyblok Nuxt* module is an SDK that has opinionated, and therefore low-code,
    integration with Nuxt. It supports auto-importing and can map Vue components directly
    to Storyblok entities with very little effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add a little configuration before the *Storyblok Nuxt* module can
    function properly, so let’s open the `nuxt.config.ts` file and modify it so that
    it has the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you’re operating from a different region, be sure to pick the corresponding
    region.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we’re setting up the modules, we can add the UI library ([https://ui.nuxt.com/](https://ui.nuxt.com/))
    at this point too. We’ll install the library from the terminal with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation is done, we need to register the module by adding the
    module’s name to the `modules` property in `nuxt.config.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Before we start adding our own content to the CMS, let’s test whether we can
    show the contents from Storyblok in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll open the **Home** entry in the **Content** section. Using **Entry
    configuration**, we’ll tell Storyblok that this page is published on the root
    of the domain, using the **Real** **path** property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Updating the Real path value for our home page](img/B19563_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Updating the Real path value for our home page
  prefs: []
  type: TYPE_NORMAL
- en: This change makes the contents of the **Home** page available on the main URL
    of our application. As mentioned previously, Storyblok offers a low-code SDK to
    integrate the CMS with our application. “Low-code” often means that we need to
    adopt certain patterns.
  prefs: []
  type: TYPE_NORMAL
- en: One of the things that the SDK does for us, for instance, is map the contents
    from the Block library to Vue components.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this to work, we need to place those components in a `./storyblok` folder
    at the root of our project. For our test, we need to create two files. First,
    we’ll start with `Page.vue` in the `./``storyblok` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll create a `Teaser.vue` file in the same folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `v-editable` directives are important to note in these files since they
    signal back to Storyblok that the contents of these blocks are indeed editable.
    We can now start creating a `./pages` folder in our application and temporarily
    create an `index.vue` file with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create a simple layout for our website. First, we’ll place a `Header.vue`
    file in a `./components` folder: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.1-Header.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.1-Header.vue).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also create another file called `Footer.vue` in the same folder: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.2-Footer.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.2-Footer.vue).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In both of these templates, we’re using some Nuxt UI components, but other
    than that, nothing special is going on. We’ll complete the base layout by creating
    a `default.vue` file in the `./``layouts` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With the page structure (albeit limited) in place, we can remove the `app.vue`
    file from our project’s root. In the Storyblok interface, you will see a **Hello
    world!** message, replacing the Nuxt welcome view. Opening the development server
    in a browser window will yield the same result. Now, if you change the text in
    Storyblok and save the change, you will see it reflected in both the Storyblok
    interface as well as directly in the browser!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Updating and saving the contents of the home page](img/B19563_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Updating and saving the contents of the home page
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see how very little we needed to manually configure and set up
    to establish a connection! If we use the correct naming convention for our Storyblok
    components, the SDK can automatically populate the components with the content
    from Storyblok using the slug. On top of that, those components are editable in
    the Storyblok editor view.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from automatically mapping contents to components, the SDK also helps
    in identifying the URL and providing the corresponding contents. In the next section,
    we’ll add more content to the CMS so that we can start to explore this connection
    a bit better!
  prefs: []
  type: TYPE_NORMAL
- en: What we’ve done so far is set up pages. With Storyblok, you can easily create
    and modify pages using predetermined components. These are the **bloks**. Having
    a collection of reusable blocks allows editors to create a page and compose the
    contents by adding bloks and configuring them. Having the preview option available
    allows editors to see the changes before they’re deployed, which is a valuable
    feature of Storyblok.
  prefs: []
  type: TYPE_NORMAL
- en: Working with multiple content types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To define the types and content to use on our pages, we can navigate to **Block
    library** in Storyblok. By default, you will see four existing blocks: **feature**,
    **grid**, **page**, and **teaser**. Between the blocks, there are two different
    types. **page** is of the **Content** type, while the rest are of the **Nestable**
    type. The key difference is that **Content type** is a top-level type of content.
    You can consider it a sort of page with a unique URL. You use this to hold different
    compositions of the lower level of content type – that is, **Nestable**. These
    are the building blocks of the pages: you can add them to a page to build the
    content you like.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s also **Universal type**, which can act as either of the aforementioned
    types. We won’t use it in our example, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new block for our portfolio purposes by clicking on the `portfolio`
    since lowercase is preferred in this case. This will be a **Content type** block,
    and we’ll configure the type by clicking on the **Add Block** button. Next, we’ll
    add the minimum fields we’ll need to present a project in our portfolio. Let’s
    go with the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `title` field name of the **Text** type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an `image` field name of the **Asset** type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After creation, configure the field to only allow **Images**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `description` field name of the `150` characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `body` field name of the **Richtext** type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we’ll start to add some entries to the portfolio by navigating to the **Content**
    section of the Storyblok interface.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the portfolio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want our portfolio to be published on a `/portfolio` path, where the slug
    is added to the URL. On the `/portfolio` path, eventually, we will want to show
    an overview of projects. In the `Portfolio`. The slug will be filled in automatically.
    Note the **Content type** field, where we can restrict what types of content can
    be shown as part of the folder. We’ll keep the default settings for now, but we’ll
    circle back to that option in a few steps. Click **Create** to add the folder
    to our content.
  prefs: []
  type: TYPE_NORMAL
- en: Because we want to present an overview of projects on the root section of the
    portfolio, we’ll navigate to the folder and create a new entry, but this time,
    we’ll choose `Home`, and we must check the **Define as root for the folder** checkbox
    when creating it. For the content type, we’ll use the default, which is **Page**.
    Storyblok will attempt to open the page, which will result in either the server
    being unavailable if you haven’t started it or a **404 not found** error since
    we have not defined a target for this route. That’s okay – we’ll solve that in
    the *Mapping content to code* section. We need to configure this page using **Entry
    configuration** and check the **Define as root for the folder** checkbox. This
    option removes the slug value, which is precisely what we will need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we added a type page here, we want to restrict the rest of the content
    so that it exclusively has `Portfolio` entries. For that, we’ll move to the root
    of the `Portfolio` folder entry so that we can edit the folder properties once
    more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Updating the settings for the Portfolio folder](img/B19563_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Updating the settings for the Portfolio folder
  prefs: []
  type: TYPE_NORMAL
- en: 'This opens the same modal as when we created the folder. We’ll use this to
    restrict further additions to the contents of the `Portfolio` folder by checking
    the **Restrict content types** option and selecting the **Portfolio** type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Restricting the content type for the Portfolio folder](img/B19563_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Restricting the content type for the Portfolio folder
  prefs: []
  type: TYPE_NORMAL
- en: This doesn’t affect our previously created home page, but it will affect future
    entries. So, let’s create a couple of portfolio entries. You can choose what you
    want to showcase – I recommend adding *at least two items* for the sake of this
    section. We will add more later to showcase the preview’s capabilities!
  prefs: []
  type: TYPE_NORMAL
- en: Mapping content to code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we’ll focus on regular pages since we have more than one to deal with
    now. We can remove the `./pages/index.vue` file completely and replace it with
    a file called `./pages/[...slug].vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With this code in place, we should be able to render a simplistic page. Let’s
    take a look at the home page for the **portfolio** section. If we open it in Storyblok,
    we’ll see a blank page. In the **Content** panel on the right-hand side, we can
    add a new block – for instance, the **Teaser** block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s drag the **Teaser** block in and give it a fitting title for a portfolio
    overview page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Rendering a Teaser block on the page in preview mode](img/B19563_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Rendering a Teaser block on the page in preview mode
  prefs: []
  type: TYPE_NORMAL
- en: Again, the preview we’re seeing is immediately visible when we access the development
    URL in the browser as well!
  prefs: []
  type: TYPE_NORMAL
- en: So, what’s happening here? We’ve used the Nuxt capability of file-based routing
    to land our application on the `[...slug].vue` page. On this page, we’re reading
    the `slug` route parameter to query the Storyblok content using the `useAsyncStoryblok`
    composable. In the template, we’re relying on the `<StoryBlokComponent />` component
    that the Storyblok SDK exposes to dynamically load the corresponding components
    from the `./storyblok` folder to reflect items in the Block library from the CMS.
    Because of the auto-imports by the Nuxt framework, we have a very clean setup
    for our page!
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that the `./storyblok` folder’s contents do not match
    the number of blocks in the library. Let’s quickly fix that: you will need to
    make sure these are always aligned to support the different scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll fix this with a minimal setup for the components. First, we’ll create
    a `Feature.vue` component in the `./storyblok` folder with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the same folder, we’ll create a `Grid.vue` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this file is slightly different from a `Feature.vue` file since
    it can contain nested Storyblok components. We can simply feed those to `<StoryblokComponent
    />` to render the correct component for every possible level of recursiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting the portfolio section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our **portfolio** section consists of roughly two cases: we want to present
    an overview of all portfolio items on the home page for the section and we want
    to present an individual case on its own page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create the overview by creating a new block in `portfolio-all`
    and make it a nestable block. In the field editor, add the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `title` field name of the **Text** type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `description` field name of the `150` characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `body` field name of the **Richtext** type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After saving, we can update the **portfolio** home page. We can remove the
    **Headline** block since we don’t need it anymore. Drag in the new **Portfolio
    All** component and add some sensible text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Configuring the Portfolio All block](img/B19563_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Configuring the Portfolio All block
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve learned, we need to make sure we have a counterpart component in our
    `./storyblok` folder. The naming convention follows camel case, so we need to
    create a `PortfolioAll.vue` component in the folder ([https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.3-PortfolioAll.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.3-PortfolioAll.vue)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `<PortfolioAll />` component is a bit more complicated. While it has a lot
    in common with the `Page` component in the sense that it is getting props, we
    also manually request additional data using the `useStoryblokApi` composable (lines
    11-16). We’re getting all the stories on the portfolio path. `is_startpage` signals
    that we want to exclude the home page of the portfolio section. On receiving the
    data, we store it in the `projects` reference (lines 9 and 20) so that we can
    iterate over it in the template and we use Nuxt UI’s `<ULink />` component to
    render a link to the project’s page.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s another addition: since we’ve defined a rich-text field for the *body*
    of the home page, we need to make sure it gets rendered properly. We can use the
    `renderRichText` function from Storyblok (*line 18*) as a computed value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build the portfolio detail page as well, to close this section for now.
    Again, we need to create the corresponding component in the `./storyblok` folder
    to have it automatically mapped to the URL. Since we’re displaying the `Portfolio.vue`
    component: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.4-Portfolio.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.4-Portfolio.vue).'
  prefs: []
  type: TYPE_NORMAL
- en: '`Portfolio.vue /` is a pretty straightforward component. Because we’ve pre-defined
    the fields that are part of the `./pages/[…slug.vue]` component, or more specifically,
    the `useAsyncStoryblok` composable, which feeds `<``StoryblokComponent />`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more visual representation, the following model helps explain how the
    components are rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – From data in Storyblok to a component in the browser](img/B19563_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – From data in Storyblok to a component in the browser
  prefs: []
  type: TYPE_NORMAL
- en: When the data is coming from Storyblok, it bears a description of the component
    type. Using the slug page, we always land on a Storyblok component, which then
    attempts to match the type to the corresponding Vue component in the `./storyblok`
    folder. That component, in turn, could be a nested type, which means it contains
    another instance of the Storyblok component, and so on. Once you get the hang
    of this mental model, it’s pretty straightforward. The amount of automation and
    assumption that Nuxt and the Storyblok module take care of can obfuscate the mechanics
    a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With our portfolio in place, let’s have a closer look at the content model and
    how we can better tune it to our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the content model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our headless CMS is now able to present basic layouts and contents to our portfolio.
    It’s still very limited this way, so let’s find out how we can work with the content
    model so that it supports new features.
  prefs: []
  type: TYPE_NORMAL
- en: Updating existing types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s assume that our **Teaser** block is a **Heading** block. I would recommend
    trying to keep blocks as static as possible, but let’s see what we need to do
    to change a name. If we navigate to the **Block library** in CMS and hover over
    the **Teaser** block, we can enter edit mode with the context menu. In the **Config**
    tab, we have the option to update the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Updating an existing block’s name](img/B19563_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Updating an existing block’s name
  prefs: []
  type: TYPE_NORMAL
- en: The next step is simply renaming the `Teaser.vue` component to `Heading.vue`
    in the `./storyblok` folder. To keep stability in mind, I would strongly recommend
    planning ahead with content modeling instead of relying on rewrites of existing
    content types.
  prefs: []
  type: TYPE_NORMAL
- en: A rule of thumb
  prefs: []
  type: TYPE_NORMAL
- en: With a growing application, it becomes increasingly risky to introduce model
    updates that require existing components to be renamed or deleted. These are considered
    breaking changes and can cause your application to (momentarily) break. Storyblok
    will warn you that changes can take time to propagate throughout the content and
    that this can affect or prevent the app from generating all the pages. These sorts
    of warnings or errors should be treated with some caution.
  prefs: []
  type: TYPE_NORMAL
- en: Changing or removing functionalities always introduces some risks in code. It’s
    much safer to add new features, as we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the block properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Changes that add functionality are easier to implement, so let’s see how we
    can expand the **Feature** block. Again, we’ll open the edit view. We’re going
    to add a couple of fields:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an `image` field name of the **Asset** type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After creation, configure the field to only allow **Images**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `link` field name of the **Link** type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we save these changes, we’ll update the component so that we can experience
    the changes in the preview editor. Let’s open the `./storyblok/Feature.vue` file
    and replace its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can update the default feature block on the home page of the website to,
    for instance, link to some portfolio items. You can also remove existing features
    if you don’t want to use them. Having updated the component, Storyblok gives you
    a good visualization of what the result will look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pages are still a bit empty now, and that’s because we have no means of
    adding text. Let’s create the component first this time, and then implement it
    in the CMS. We’ll create a `RichText.vue` component in the `./storyblok` folder
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then, in Storyblok, we’ll add a new block called `rich-text` as a nestable block.
    As part of the fields, we’ll only add a single field called `body` of the **Richtext**
    type. Now, you can immediately add the content block and start adding additional
    content to the website!
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll do a bit of refactoring with our blocks because the individual elements
    don’t allow us to create a good-looking visual representation, especially when
    dealing with text pages. First, we’ll create a Vue component in the `./storyblok`
    folder called `Article.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll flip over to the CMS to create a new block called `article` as
    a nestable block with the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `title` field name of the **Text** type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `content` field name of the **Block** type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second field allows us to compose the article type with many different blocks
    that are available. It would be good practice to try and set up something such
    as a contact card block for yourself, for instance!
  prefs: []
  type: TYPE_NORMAL
- en: Taking a hint from the layout we’ve set up, we’re still missing a page. With
    Storyblok, you should be able to create a **Me** story at the root of the project.
    You can use this space to introduce yourself and share your journey.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping meta fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you remember the **Description** fields we added to the **Portfolio All**
    and **Portfolio** blocks in the *Presenting the portfolio* section? We haven’t
    mapped those! These fields are meant to provide some metadata to the page for
    **Search Engine Optimisation** (**SEO**) purposes. Using semantic HTML tags, we
    can describe the page contents specifically for indexing by search engines. Nuxt
    offers an out-of-the-box solution for controlling these tags and provides a composable
    ([https://nuxt.com/docs/getting-started/seo-meta#usehead](https://nuxt.com/docs/getting-started/seo-meta#usehead))
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both cases, since the field name is the same, we can add the `meta` field
    by inserting the following code into the script tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you look at the source of the website, you will see the tag and contents
    rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – The meta field has been rendered in the source code of the
    HTML](img/B19563_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – The meta field has been rendered in the source code of the HTML
  prefs: []
  type: TYPE_NORMAL
- en: It’s good to remember that we can use the content from the CMS not just for
    the visible parts of the website – we can process any content as a variable in
    our application. We could provide toggles or themes – anything really – where
    we can change the website without deploying new code. That’s what makes a headless
    CMS a powerful tool when developing applications.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With these steps completed, you could try to add some more features to your
    portfolio. How about a nicely formatted contact sheet? Or a manageable resume
    section? With what we’ve built, you should be able to figure this out by yourself!
  prefs: []
  type: TYPE_NORMAL
- en: Generating a standalone website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have a functional portfolio. This type of website has very static content:
    it doesn’t change depending on the visitor and will probably not receive daily
    updates in terms of code! This means that we can optimize the output of what we
    will deploy to the public.'
  prefs: []
  type: TYPE_NORMAL
- en: The portfolio we’ve created is a perfect use case for static site generation.
    Normally, Nuxt would run as an active process on a server, where it can respond
    directly to requests and fetch data in real time. A good example is the *Quiz
    server* we built in [*Chapter 8*](B19563_08.xhtml#_idTextAnchor233). But since
    we don’t need real-time data when publishing, we can leverage another capability
    of Nuxt. When generating a static site, Nuxt runs as an application initially
    and indexes all of the internal links. For every internal link, it will retrieve
    the data from the server once and then write the output to a static collection
    of files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see this in action! The command is already part of our `package.json`
    scripts, but we need to slightly modify it so that we can pass the API key we
    need to access the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can just run the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that the required files for a static site are being generated.
    On completion, the *Nuxt* generation process will return a command you can use
    to test the website as a static site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Running this command will start a simple HTTP web server. There is no Nuxt process
    running! This is just the browser running HTML, CSS, and JavaScript files. All
    of the contents from the CMS are now bundled as part of the website. Well, except
    for the images – they are served from the Storyblok CDN, which is optimized for
    doing just that.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll see how we can make our static site public in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the static site
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any web host would be capable of serving these static files now. That’s one
    of the benefits of a static-generated website: the amount of freedom when it comes
    to hosting them. We do have some requirements down the line, however, so we’re
    choosing Netlify ([https://app.netlify.com/](https://app.netlify.com/)) for our
    use case. If you register, you should be able to enter the free tier without any
    cost. While signing up, pick the categories that suit you best and pick a name
    for your team.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen, we’ll go with the Netlify Drop way of deploying:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Choosing your first method of deployment](img/B19563_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Choosing your first method of deployment
  prefs: []
  type: TYPE_NORMAL
- en: Choosing `./output/public` folder. Make sure you drop the `public` folder and
    not the separate contents!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve finished uploading everything, you will enter the dashboard for
    the first time. Clicking the **Open production deploy** button will send you to
    your published portfolio! The subdomain is generated by Netlify and contains random
    wording. You can opt to change it via the **Domain** **management** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – The Netlify dashboard after the first deployment](img/B19563_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – The Netlify dashboard after the first deployment
  prefs: []
  type: TYPE_NORMAL
- en: The free tier of Netlify offers capabilities for processing domain names, pointing
    your own domain to this space.
  prefs: []
  type: TYPE_NORMAL
- en: The drawback of a statically generated site is that the website we deployed
    is completely detached from the content and our Nuxt server. This means that if
    we update the content or change a feature in the code, we need to regenerate the
    website and manually upload the output to Netlify. This works but is not ideal!
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, with some extra effort and configuration, we can automate deployments
    when either the content changes or the code changes!
  prefs: []
  type: TYPE_NORMAL
- en: Automating the build and deployment on code change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our Netlify environment does not know about our application. Netlify is a tool
    for deploying web apps. We can’t connect Netlify to our local development environment.
    We need to host the source online as well.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub ([https://github.com/](https://github.com/)) has excellent integrations
    with Netlify and is very suitable for hosting and versioning code. Without diving
    into the details, GitHub can detect when code has been updated on the repository
    and can trigger certain actions when that happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll set up a repository where we can publish the code. Let’s create
    a new empty repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Creating a new repository in GitHub](img/B19563_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Creating a new repository in GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the repository has been created, you can follow the next steps to attach
    our code to the repository using the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This pushes our code to GitHub, which means we can connect it to Netlify! On
    the dashboard, navigate to **Site Configuration** | **Build & Deploy** and click
    the **Link repository** button. Then, you need to authorize Netlify on your GitHub
    account. Once you’ve done this, you’ll see an overview of your repositories. Select
    the portfolio repository you just created to continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might automatically detect that it’s a Nuxt repository and Netlify will
    try and make some suggestions. We need to change three settings:'
  prefs: []
  type: TYPE_NORMAL
- en: Change `npm` `run generate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change `./output/public`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to add environment variables to add the contents of our `.env` file,
    with `NUXT_STORYBLOK_ACCESS_TOKEN` and **Value** being what matches your access
    token. Make sure that it’s saved!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The changes you’ve made should match these settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – Our new Netlify deployment settings](img/B19563_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – Our new Netlify deployment settings
  prefs: []
  type: TYPE_NORMAL
- en: Deploying this will allow Netlify to read from the repository and pull in the
    latest version on a change. It will do this automatically. Then, it will run the
    `npm run generate` script to do the static site rendering on a virtual environment.
    The final step will be to deploy the contents of the output folder to the web
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: It’s that easy! If you work on your local code and commit and push the code
    to the repository, the change will automatically be deployed! It is good to note
    that we are not verifying whether our code is functional since we have no tests
    running on our application. It would be best practice to make sure that critical
    features of your code work.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the build on content change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It would be perfect if we could do something similar on a content change rather
    than a code change, right? Luckily, there’s a very convenient way of doing this:
    we can use webhooks to trigger actions. Storyblok will keep track of when content
    is ready to be published and it can trigger an action on the Netlify platform
    that executes a build just like with a code change. This time, however, Nuxt will
    fetch the latest version of the content during the generation process.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we can set this up. First, we need to create a webhook in Netlify.
    This webhook is nothing more than a unique URL that triggers an internal action
    when it’s being called.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to `Deploy on Content Change`. The settings default to building the
    *main* branch, which is perfect. After a moment of saving, you will receive a
    unique URL with a pattern such as [https://api.netlify.com/build_hooks/UNIQUE_IDENTIFIER](https://api.netlify.com/build_hooks/UNIQUE_IDENTIFIER).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can move to Storyblok to configure calling this webhook. If we navigate
    to the **Settings** and **Webhook** sections, we can manage webhooks! We’ll create
    a new one, again with a meaningful name. In the **Endpoint URL** area, we can
    paste the endpoint from Netlify.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *triggers* determine which events we want to call the webhook on. You can
    experiment a bit with the settings, but I recommend starting with this set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19 – Selecting event triggers to call the webhook](img/B19563_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19 – Selecting event triggers to call the webhook
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, you want to select as few triggers as possible, simply because every
    build process takes time. Calling the webhook consecutive times just puts requests
    in a queue, which can lead to longer waiting times for your change to be visible.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s save these settings and change some content in our portfolio.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re not running the Nuxt development server, you can still edit the content
    using the panel on the right-hand side. You can even expand it to fill the screen
    using the **Show form** **view** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.20 – Expanding the editing capabilities using the form view](img/B19563_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 – Expanding the editing capabilities using the form view
  prefs: []
  type: TYPE_NORMAL
- en: Not having the development server just means that you don’t have a live preview.
    It’s not mandatory to access the content.
  prefs: []
  type: TYPE_NORMAL
- en: After saving, you can go over to the **Deploys** section on the Netlify dashboard
    to see that it triggered a new build.
  prefs: []
  type: TYPE_NORMAL
- en: You made it!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve been working with different platforms and systems to
    connect them into a single application that renders a static website. One of the
    key takeaways is that we can combine the strengths of many specialized solutions
    to build a robust product we can deploy. I highly recommend checking out more
    resources on both Storyblok and Netlify since they work well with this type of
    web stack.
  prefs: []
  type: TYPE_NORMAL
- en: The combination of the live preview of Storyblok and the developer experience
    of using Nuxt as a framework makes these sorts of projects very easy to get started
    with and build something we can use! We’ve seen that Nuxt doesn’t always have
    to run as a server – it can be used to generate the data from the server once
    and store the output. This approach is more sustainable and offers better performance
    than real-time data fetching.
  prefs: []
  type: TYPE_NORMAL
- en: With the way we’ve set up Storyblok and integrated it with Nuxt, it’s a very
    accessible way for anybody to build a website. We’ve built a relatively simple
    example, but with an increasing number of blocks, the possibilities you can create
    scale up massively while still being very easy to understand for non-technical
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Every configuration we’ve set up in this chapter was aimed at managing the website
    as easily as possible. Even the publication mechanisms add to that goal by both
    automating code deployments as well as automatically generating a new version
    when content is changed.
  prefs: []
  type: TYPE_NORMAL
- en: On top of all of this, we’ve created a platform where you can log your journey
    while working through the chapters of this book. I recommend completing the portfolio
    with projects or achievements you’re proud of.
  prefs: []
  type: TYPE_NORMAL
- en: One of the goals of this book was to present real-world code. Real-world code
    is often pragmatic and may not always be optimized to perfection. Similarly, the
    examples in this book are not flawless. However, they effectively achieve the
    intended goals. Embracing pragmatism enables you to validate features with users
    and shorten feedback loops, which is a very valuable aspect. I’ve illustrated
    that refactoring and optimization are integral parts of a continuous process.
    I want to stress that, as you gain deeper insights into projects, you’ll naturally
    prioritize which aspects require optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back, I hope you are proud of the work you’ve put in with all the different
    types of topics, technologies, and apps we’ve built throughout this book. I have
    tried to paint a broad picture of possible real-world scenarios while continuously
    increasing your level of Vue.js knowledge and experience. I would like to thank
    you for your interest in these topics and for following along during our journey.
    The investigating, building, and documenting process has also been very valuable
    for me, and I am grateful for the opportunity I’ve had to teach and share my knowledge
    and approach when writing code.
  prefs: []
  type: TYPE_NORMAL
