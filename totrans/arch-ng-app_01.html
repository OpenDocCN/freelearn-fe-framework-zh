<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Quick Look Back at Data Services for Simple Apps</h1>
                </header>
            
            <article>
                
<p>Welcome to the first chapter of this book. You have hopefully picked up this book because you have experienced issues setting up the architecture of your Angular application. Your application has grown and in that process you slowly feel your are losing track of what your application knows at a given point, what we call the state of the application. There might be other issues, such as parts of your application not being in agreement with what they know. An update that happened in one part may not have been applied to some other part and you scratch your head, thinking should it be this hard and is there a better answer?</p>
<p>It's entirely possible you are just picking up this book as you have heard about NgRx as the way to structure your application and you are curious and want to know more.</p>
<p>Regardless of which motivation drives you to read this book, this book is about learning to structure your application and learning how to set up and communicate your application's state, and its changes, in a way that all parts of your application are in agreement on what is happening. The underlying architectural pattern for NgRx is Redux, which constrains data to live in only one place and ensures data is flowing in only one direction. We will have a chance to cover Redux<span> </span><span>in</span><span> more depth in a dedicated chapter in this book.</span></p>
<p>To get to a point where we have learned to master NgRx, we first need to pick up some paradigms and patterns along the way. We need to build a good foundation of knowledge.  A good foundation consists of learning concepts such as <strong>Functional Reactive Programming</strong> (<strong>FRP</strong>), the architectural pattern Flux, and a new and exciting way of thinking about async concepts, Observables.</p>
<p>So why are these relevant for our learning journey of mastering NgRx? The Flux pattern has a lot in common with Redux and it is its shortcomings that led to Redux being created. NgRx itself is implemented using RxJS, which promotes a functional reactive style of programming. So you see, the foundations we are about to explore all help us grasp the theory and motivations behind NgRx. </p>
<p class="mce-root">In this chapter, we lay the foundations for the book by discussing the well-known <strong>Model-View-Controller</strong> (<strong>MVC</strong>)<span> </span><span>pattern</span><span>. To verify we understand the MVC pattern, we use the Angular</span><span> </span><span>framework</span><span> to make things easier. As interesting as it is to talk about architecture, if you don't see it applied to something real, it might be hard to grasp.  </span></p>
<p class="mce-root">We continue diving into an application workflow in Angular and its Dependency Injection machinery. Before concluding the chapter, we will also have a look at how to fetch data through an API because, after all, that is where the data comes from and should flow to. </p>
<p>In this chapter, we will:</p>
<ul>
<li>Describe the building blocks of the MVC pattern</li>
<li>Describe MVC in Angular and the core constructs that help support it</li>
<li>Review the HTTP service and how to deal with Ajax</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Model-View-Controller – the pattern we all know</h1>
                </header>
            
            <article>
                
<p>Regardless of whether you have been a programmer for a year or 20 years, you have almost certainly encountered the MVC pattern in some way, shape, or form. The pattern itself, MVC, consists of three interconnected parts: model, view, and controller. More important than knowing all its parts is knowing what problem it solves. It solves the problem of separation of concerns by decoupling view logic, data logic, and business logic. The MVC pattern has given rise to, among others:</p>
<ul>
<li><strong>Model-View-Adapter</strong> (<strong>MVA</strong>)</li>
<li><strong>Model-View-Presenter</strong> (<strong>MVP</strong>)</li>
<li><strong>Model-View-ViewModel</strong> (<strong>MVVM</strong>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cohesion and coupling – establishing a common language</h1>
                </header>
            
            <article>
                
<p>Without a pattern like MVC, your code could turn out to be hard to maintain as it could have low cohesion and high coupling. Those are fancy words, so what do we mean? Cohesion is about focus and what the class should do. The lower the cohesion, the more different things are performed by a class and therefore it has no clear intention of what it should perform.</p>
<p>The following code shows what happens when a class has low cohesion; it does a lot more than storing data about an invoice, such as being able to log to a file or talk to a database:</p>
<pre>Invoice<br/>  details<br/>  total<br/>  date<br/>  validate()<br/>  print()<br/>  log()<br/>  saveToDatabase()</pre>
<p>Now we have introduced new dedicated classes and moved methods out of the <kbd>Invoice</kbd> class to make sure that each and every class <span>now</span><span> </span><span>has high cohesion, that is, is more focused on doing one thing well. We therefore now have the classes </span><kbd>Invoice</kbd><span>, </span><kbd>Printer</kbd><span>, </span><kbd>Logger</kbd><span>, and </span><kbd>InvoiceRepository</kbd><span>:</span></p>
<pre>Invoice<br/>  details<br/>  total<br/>  date<br/>  validate()<br/><br/>Printer<br/>  print(document)<br/><br/>Logger<br/>  log()<br/><br/>InvoiceRepository<br/>  saveToDatabase(invoice)</pre>
<p>The point I am trying to make here is that a class should only do one thing well. This is illustrated by the unfocused <kbd>Invoice</kbd> class being split into four different classes that each do only one focused thing well. </p>
<p>So that deals with cohesion/focus. What about coupling? Coupling is about how strongly connected a software element is to another software element. Ultimately, the higher the coupling, the harder/more tedious it is to change. Let's look at the following example of high coupling written in Java:</p>
<pre>// cohesion-and-coupling/invoice-system.java<br/><br/>class<span> </span><span>Printer</span><span> {<br/></span>  print<span>(</span><span>Invoice</span><span> </span><span>invoice</span><span>) {<br/>    </span>String<span> total </span><span>=</span><span>""</span><span>;<br/>    </span>total <span>+=</span><span> invoice</span><span>.</span><span>getTitle();<br/>    </span>total <span>+=</span><span> invoice</span><span>.</span><span>getDetails();<br/>    </span>total <span>+=</span><span> invoice</span><span>.</span><span>getDate();<br/>    </span>//print 'total'<br/>  }<br/>}<br/><br/>class<span> </span><span>Invoice</span><span> {<br/></span>  String<span> title;<br/>    </span>String<span> details;<br/>    </span>int<span> total;<br/>    </span>Date<span> date;<br/>    </span>public<span> String </span><span>getTitle</span><span>() { </span><span>return</span><span> </span><span>this</span><span>.</span><span>title; }<br/>    </span>public<span> String </span><span>getDetails</span><span>() { </span><span>return</span><span> </span><span>this</span><span>.</span><span>details; }<br/>    </span>public<span> String </span><span>getDate</span><span>() { </span><span>return</span><span> </span><span>this</span><span>.</span><span>date; }<br/></span>}<br/><br/>public<span> </span><span>class</span><span> </span><span>Program</span><span> {<br/></span>  private<span> </span><span>Printer</span><span> </span><span>printer</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Printer</span><span>();<br/>  </span>public<span> </span><span>void</span><span> </span><span>run</span><span>(</span><span>ArrayList</span><span> </span><span>list</span><span>) {<br/>    </span>for<span>(</span><span>int</span><span> i</span><span>=</span><span>0</span><span>; i</span><span>&lt;</span><span> list</span><span>.</span><span>length; i</span><span>++</span><span>) {<br/>      </span>Object<span> item </span><span>=</span><span> list</span><span>.</span><span>getItem(i);<br/>      </span>if<span>(item </span><span>instanceof</span><span> </span><span>Invoice</span><span>) {<br/>        </span>Invoice<span> invoice </span><span>=</span><span> (</span><span>Invoice</span><span>) item;<br/>        </span>printer<span>.</span><span>print(invoice);<br/>      </span>}<br/>    }<br/>  }<br/><br/>  public<span> </span><span>static</span><span> </span><span>void</span><span> </span><span>main</span><span>(</span><span>String</span><span> [] </span><span>args</span><span>) {<br/></span>    ArrayList<span> list </span><span>=</span><span> </span><span>new</span><span> </span><span>ArrayList</span><span>();<br/>    </span>list<span>.</span><span>add(</span><span>new</span><span> </span><span>Invoice</span><span>());<br/>    </span>Program<span> program </span><span>=</span><span> </span><span>new</span><span> </span><span>Program</span><span>();<br/>    </span>program<span>.</span><span>run( list );<br/></span>  }<br/>}</pre>
<p>There are multiple problems with this code, especially if you aim to change the code in any way. Let's say we wanted to print an email as well. It is tempting to think we would need an <kbd>Email</kbd> class and need to add another <kbd>print()</kbd> method override to the <kbd>Printer</kbd> class.  We would also need to add branching logic to the <kbd>Program</kbd> class. Furthermore, testing the <kbd>Program</kbd> class cannot be achieved without causing a side-effect: calling the <kbd>run()</kbd> method would cause an actual call to a printer. The way we tend to work with tests nowadays is to run our tests every time the code changes, which it might do quite a lot as we are developing our program. We might end up with thousands of printed papers just developing our code. For that reason, we need to isolate ourselves from side effects when developing code and tests. What we want to test at the end of the day is that our code behaves correctly, not that the physical printer seems to work.</p>
<p>In the following code, we see an example of high coupling. We add another type, <kbd>Email</kbd>. The purpose of doing that is to see the effects of doing so, which is that we need to add code to several places at once. Having to do so is a sign of a code smell. The fewer changes you need to make, the better it usually is:</p>
<pre>// cohesion-and-coupling/invoice-systemII.java<br/><br/><strong>class Email {<br/>  String from;<br/>  String to;<br/>  String subject;<br/>  String body;<br/>  String getSubject() { return this.subject; }<br/>  String getFrom() { return this.from; }<br/>  String getTo() { return this.to; }<br/>  String getBody() { return this.body; }<br/>}</strong><br/><br/>class<span> </span><span>Invoice</span><span> {<br/></span>  String<span> title;<br/></span>  String<span> details;<br/></span>  int<span> total;<br/></span>  Date<span> date;<br/></span>  String<span> </span><span>getTitle</span><span>(){ </span><span>return</span><span> </span><span>this</span><span>.</span><span>title; }<br/></span>  String<span> </span><span>getDetails</span><span>() { </span><span>return</span><span> </span><span>this</span><span>.</span><span>details; }<br/></span>  Date<span> </span><span>getDate</span><span>() { </span><span>return</span><span> </span><span>this</span><span>.</span><span>date; }<br/></span>}<br/><br/>class<span> </span><span>Printer</span><span> {<br/></span>  print<span>(</span><span>Invoice</span><span> </span><span>invoice</span><span>) {<br/></span>    String<span> total </span><span>=</span><span>""</span><span>;<br/></span>    total <span>+=</span><span> invoice</span><span>.</span><span>getTitle();<br/></span>    total <span>+=</span><span> invoice</span><span>.</span><span>getDetails();<br/></span>    total <span>+=</span><span> invoice</span><span>.</span><span>getDate();<br/></span>    //print 'total'<br/>  }<br/><br/>  print<span>(</span><span>Email</span><span> </span><span>email</span><span>) {<br/></span>    String<span> total </span><span>=</span><span>""</span><span>;<br/>    </span>total <span>+=</span><span> email</span><span>.</span><span>getSubject();<br/>    </span>total <span>+=</span><span> email</span><span>.</span><span>getFrom();<br/>    </span>total <span>+=</span><span> email</span><span>.</span><span>getTo();<br/>    </span>total <span>+=</span><span> email</span><span>.</span><span>getBody();<br/></span>  }<br/>}<br/><br/>class<span> </span><span>Program</span><span> {<br/></span>  private<span> </span><span>Printer</span><span> </span><span>printer</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Printer</span><span>();<br/>  </span>run<span>(</span><span>ArrayList</span><span> </span><span>list</span><span>) {<br/>    </span>for<span>(</span><span>int</span><span> i</span><span>=</span><span>0</span><span>; i</span><span>&lt;</span><span> list</span><span>.</span><span>length; i</span><span>++</span><span>) {<br/>      </span>Object<span> item </span><span>=</span><span> list</span><span>.</span><span>getItem(i);<br/>      </span>if<span>(item </span><span>instanceof</span><span> </span><span>Invoice</span><span>) {<br/>        </span>Invoice<span> invoice </span><span>=</span><span> (</span><span>Invoice</span><span>) item;<br/>        </span>printer<span>.</span><span>print( invoice );<br/>      </span>} <span>else</span><span> </span><span>if</span><span>( item </span><span>instanceof</span><span> </span><span>Email</span><span> ) {<br/>        </span>Email<span> email </span><span>=</span><span> (</span><span>Email</span><span>) item;<br/>        </span>printer<span>.</span><span>print( email );<br/>      </span>}<br/>    }<br/>  }<br/><br/>  public<span> </span><span>static</span><span> </span><span>void</span><span> </span><span>main</span><span>(</span><span>String</span><span> [] </span><span>args</span><span>) {<br/></span>    ArrayList<span> list </span><span>=</span><span> </span><span>new</span><span> </span><span>ArrayList</span><span>();<br/>    </span>list<span>.</span><span>add( </span><span>new</span><span> </span><span>Invoice</span><span>() );<br/>    </span>list<span>.</span><span>add( </span><span>new</span><span> </span><span>Email</span><span>() );<br/>    </span>Program<span> program </span><span>=</span><span> </span><span>new</span><span> </span><span>Program</span><span>();<br/>    </span>program<span>.</span><span>run( list );<br/></span>  }<br/>}</pre>
<p>So let's rearrange the code a bit:</p>
<pre>// cohesion-and-coupling/invoice-systemIII.java<br/><br/>class<span> </span><span>Email</span><span> </span><span>implements</span><span> </span><span>IPrintable</span><span> {<br/></span>  String<span> from;<br/>  </span>String<span> to;<br/>  </span>String<span> subject;<br/>  </span>String<span> body;<br/>  </span>String<span> </span><span>getSubject</span><span>() { </span><span>return</span><span> </span><span>this</span><span>.</span><span>subject; }<br/>  </span>String<span> </span><span>getFrom</span><span>() { </span><span>return</span><span> </span><span>this</span><span>.</span><span>from; }<br/>  </span>String<span> </span><span>getTo</span><span>() { </span><span>return</span><span> </span><span>this</span><span>.</span><span>to; }<br/></span>  String<span> </span><span>getBody</span><span>() { </span><span>return</span><span> </span><span>this</span><span>.</span><span>body; }<br/></span><span>  public </span>String<span> </span><span>getContent</span><span>() {<br/>    </span>String<span> total </span><span>= </span><span>""</span><span>;<br/>    </span>total <span>+=</span><span> email</span><span>.</span><span>getSubject();<br/>    </span>total <span>+=</span><span> email</span><span>.</span><span>getFrom();<br/>    </span>total <span>+=</span><span> email</span><span>.</span><span>getFrom();<br/>    </span>total <span>+=</span><span> email</span><span>.</span><span>getBody();<br/>    </span>return<span> total;<br/>  </span>}<br/>}<br/><br/>class<span> </span><span>Invoice</span><span> </span><span>implements</span><span> </span><span>IPrintable</span><span> {<br/></span>  String<span> title;<br/>  </span>String<span> details;<br/>  </span>int<span> total;<br/>  </span>Date<span> date;<br/>  </span>String<span> </span><span>getTitle</span><span>() { </span><span>return</span><span> </span><span>this</span><span>.</span><span>title; }<br/>  </span>String<span> </span><span>getDetails</span><span>() { </span><span>return</span><span> </span><span>this</span><span>.</span><span>details; }<br/>  </span>String<span> </span><span>getDate</span><span>() { </span><span>return</span><span> </span><span>this</span><span>.</span><span>date; }<br/>  public </span>String<span> </span><span>getContent</span><span>() {<br/>    </span>String<span> total </span><span>= </span><span>""</span><span>;<br/>    </span>total <span>+=</span><span> invoice</span><span>.</span><span>getTitle();<br/>    </span>total <span>+=</span><span> invoice</span><span>.</span><span>getDetails();<br/>    </span>total <span>+=</span><span> invoice</span><span>.</span><span>getDate();<br/>    </span>return<span> total;<br/>  </span>}<br/>}<br/><br/><strong>interface IPrintable {<br/>  String getContent();<br/>}</strong><br/><br/>interface<span> </span><span>IPrinter</span><span> {<br/></span>  print<span>(</span><span>IPrintable</span><span> </span><span>printable</span><span>);<br/></span>}<br/><br/>class<span> </span><span>Printer</span><span> </span><span>implements</span><span> </span><span>IPrinter</span><span> {<br/></span>  print<span>( </span><span>IPrintable</span><span> </span><span>printable</span><span> ) {<br/>    </span>String<span> content </span><span>=</span><span> printable</span><span>.</span><span>getContent();<br/>    </span>// print content<br/>  }<br/>}<br/><br/>class<span> </span><span>Program</span><span> {<br/></span>  private<span> </span><span>IPrinter</span><span> printer;<br/>  public </span>Program<span>(</span><span>IPrinter</span><span> </span><span>printer</span><span>) {<br/>    </span>this<span>.</span><span>printer </span><span>=</span><span> printer;<br/>  </span>}<br/>  <br/>  run<span>(</span><span>ArrayList&lt;IPrintable&gt;</span><span> </span><span>list</span><span>) {<br/></span>    for<span>(</span><span>int</span><span> i</span><span>=</span><span>0</span><span>; i</span><span>&lt;</span><span> list</span><span>.</span><span>length; i</span><span>++</span><span>) {<br/>      </span>IPrintable<span> item </span><span>=</span><span> list</span><span>.</span><span>getItem(i);<br/>      </span>printer<span>.</span><span>print(item);<br/>    </span>}<br/>  }<br/>  <br/>  public<span> </span><span>static</span><span> </span><span>void</span><span> </span><span>main</span><span>(</span><span>String</span><span> [] </span><span>args</span><span>) {<br/>    </span>ArrayList&lt;IPrintable&gt;<span> list </span><span>=</span><span> </span><span>new</span><span> </span><span>ArrayList&lt;IPrintable&gt;</span><span>();<br/>    </span>Printer<span> printer </span><span>=</span><span> </span><span>new</span><span> </span><span>Printer</span><span>();<br/>    </span>list<span>.</span><span>add(</span><span>new</span><span> </span><span>Invoice</span><span>());<br/>    </span>list<span>.</span><span>add(</span><span>new</span><span> </span><span>Email</span><span>());<br/>    </span>Program<span> program </span><span>=</span><span> </span><span>new</span><span> </span><span>Program</span><span>(printer);<br/>  </span>}<br/>}</pre>
<p>At this point, we have made our program open to extension. How can we say that, you ask? Clearly, we have removed the <kbd>printer</kbd> methods from <kbd>printer</kbd>. We also removed the switch logic from the method run in the <kbd>Program</kbd> class. We have also added the abstraction <kbd>IPrintable</kbd>, which makes anything printable responsible for telling a printer what the printable content is.</p>
<p>You can clearly see how we went from high coupling to low coupling when we introduced the types <kbd>Document</kbd> and <kbd>Note</kbd>. The only change they cause is themselves being added and implementing the <kbd>IPrintable</kbd> interface. Nothing else has to change. Success!</p>
<pre>// invoice-systemIV.java<br/><br/>class Document implements IPrintable {<br/>  String title;<br/>  String body; <br/><br/>  String getContent() {<br/>    return this.title + this.body;<br/>  }<br/>}<br/><br/>class Note implements IPrintable {<br/>  String message;<br/><br/>  String getContent() {<br/>    return this.message;<br/>  }<br/>}<br/><br/>// everything else stays the same<br/><br/>// adding the new types to the list<br/>class Program {<br/>  public static void main(String[] args) {<br/>    list.add(new Note());<br/>    list.add(new Document());<br/>  }<br/>}</pre>
<p>OK, so to sum up our changes:</p>
<ul>
<li>We added the <kbd>IPrintable</kbd> interface </li>
<li>We simplified/removed the branching logic in the <kbd>Program.run()</kbd> method</li>
<li>We made each printable class implement <kbd>IPrintable</kbd></li>
<li>We added some code at the end of the previous snippet to demonstrate how easy it would be to add new types</li>
<li>We injected an <kbd>IPrinter</kbd> through the <kbd>Program</kbd> class constructor to ensure that we can easily test the <kbd>Program</kbd> class </li>
</ul>
<p>In particular note that we did not need to change any logic in either <kbd>Printer</kbd> or <kbd>Program</kbd>, when adding the <kbd>Document</kbd> and <kbd>Note</kbd><span> types</span><span>. The only thing we needed to do was add </span><kbd>Document</kbd><span> and </span><kbd>Notes</kbd><span> as classes and ensure they implemented the</span> <kbd>IPrintable</kbd> <span>interface. To put emphasis on this,</span> <em>any addition to a program should not lead to an overall system change in the code</em><span>. </span></p>
<p>Let's reiterate the last bullet of adding <kbd>IPrinter</kbd>. Testability is a very good measurement to see whether your code has low coupling. If you depend on abstractions rather than actual classes, you are able to easily switch out one concrete class for another, while maintaining high-level behavior.</p>
<p>Another reason for switching <kbd>Printer</kbd> to <kbd>IPrinter</kbd> is so that we remove side effects from the program when we test our code. Side effects are when we talk to files, mutate states, or talk over the network for example. Testing the <kbd>Program</kbd> class means we want to get rid of a side effect such as actual printing and have it call something fake, or we would have a large stack of papers every time we run our tests. So to instantiate our <kbd>Program</kbd> class for the purposes of testing, we would write something like this instead:</p>
<pre>// cohesion-and-coupling/invoice-systemV.java<br/><br/>class FakePrinter implements IPrinter {<br/>  print(IPrintable printable) { System.out.println("printing"); }<br/>}<br/><br/>class Program {<br/>  FakePrinter fakePrinter;<br/>  Program(FakePrinter fakePrinter) {<br/>    this.fakePrinter = fakePrinter;<br/>  }<br/>  <br/>  public<span> </span><span>static</span><span> </span><span>void</span><span> main(</span><span>String</span><span>[] args) {<br/></span>    ArrayList<span>&lt;</span><span>IPrintable</span><span>&gt; list </span><span>=</span><span> </span><span>new</span><span> </span><span>ArrayList</span><span>&lt;</span><span>IPrintable</span><span>&gt;();<br/></span>    <strong>Printer printer = new</strong><span><strong> FakePrinter();</strong><br/></span>    list.add(<span>new</span><span> Invoice());<br/></span>    list.add(<span>new</span><span> Email());<br/></span>    <strong>Program program = new</strong><span><strong> Program(printer);</strong><br/></span>  }<br/>}</pre>
<p>What we see from this code is how we shift from instantiating the <kbd>Printer</kbd><span> </span><span>class</span><span> (which prints to a real printer) to the</span> <kbd>Program</kbd><span> class using an instance of </span><kbd>FakePrinter</kbd><span>. In a testing scenario, this is exactly what you would do, if wanting to test the <kbd>Program</kbd> class. What you most likely care about is the </span><kbd>print()</kbd><span> method being called with the correct arguments.</span></p>
<p>OK, so this was a pretty long way of expressing what low coupling is about. It is, however, important to establish what crucial terms such as coupling and cohesion are, especially when talking about patterns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Explaining the components of MVC</h1>
                </header>
            
            <article>
                
<p>Back to the MVC pattern. Using said pattern means we get high cohesion and low coupling; this is due to code being split into different layers with different responsibilities. View logic belongs in views, controller logic in controllers, and model logic in models. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The model</h1>
                </header>
            
            <article>
                
<p>This is the crucial part of the application. This does not rely on any specific user interface but more defines the domain in which you operate. Rules, logic, and data live here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The view</h1>
                </header>
            
            <article>
                
<p>This can be anything from a native app view to a bar chart, or even a web page. The point is that it ultimately displays data from the model. There can be different views displaying the same thing, but depending on for whom they are designed, they might look different. An admin might see a totally different view than a user for the same information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The controller</h1>
                </header>
            
            <article>
                
<p>This is really the spider in the web. It is able to take input from the view or from the data and turn it into commands.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interactions – the behavior between the components</h1>
                </header>
            
            <article>
                
<p>All these three mentioned components act in different ways when talking to each other. A model stores data it is being given from the controller based on commands. A view changes its appearance based on changes happening in the model. A controller can send a command to the model based on a user interaction. One such example is a user deciding to browse between page-based records. A new set of data will need to be retrieved based on the new visual position.</p>
<p>These two basic flows are what <span>mostly</span><span> </span><span>happens in an application-based on MVC:</span></p>
<ul>
<li>User interaction: Controller sends command to Model =&gt; Model changes =&gt; View is updated</li>
<li>View asks for data: Controller sends command to Model =&gt; Model is created/changed  =&gt; View is updated</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MVC summary</h1>
                </header>
            
            <article>
                
<p>A lot can be said about MVC and its many variants, but let's be content with what we have for now by summarizing the properties of the pattern that we identified:</p>
<ul>
<li>Low coupling</li>
<li>High cohesion, separating presentation concerns from the model</li>
<li>Simultaneous development is possible; due to the existence of many layers, people can work in parallel on a task</li>
<li>Ease of change; because of how things are separated, adding future concepts or making alterations becomes easier </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An MVC flow in Angular</h1>
                </header>
            
            <article>
                
<p>Let's look at the following problems and how we solve them in Angular:</p>
<ul>
<li>Creating and rendering model data to the screen</li>
<li>Learning how the MVC pattern maps to the Angular framework</li>
<li>Learning how we can structure an Angular application in different building blocks</li>
<li>Fetching data/persisting data</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The model</h1>
                </header>
            
            <article>
                
<p>The model in Angular is a plain class, as we are using TypeScript. It can look like the following code:</p>
<pre>// mvc/MvcExample/src/app/product.model.ts<br/><br/>export class Product {<br/>  constructor(<br/>    private id: number,<br/>    private title: string,<br/>    private description: string,<br/>    private created: Date<br/>  ) {}<br/><br/>  method() {}<br/><br/>  anotherMethod() {}<br/>}</pre>
<p>It is a plain TypeScript file, or rather an ES2015 module, not to be confused with an Angular module. We will discuss in the next main section what an Angular module is, in terms of setup and how it is consumed. For now, remember the model is a simple thing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The component – a controller and a building block</h1>
                </header>
            
            <article>
                
<p>In the context of MVC, the component is the V and C, the view and the controller. The component allows you to define either a separate template file or an inline template. The template is the view part.</p>
<p>The controller in this context is a component class file that handles user interactions and also fetches the necessary data for the template to display.</p>
<p>Components have come to be a central concept for a lot of frameworks that are popular today, such as React, Vue.js, and Polymer. A component can take inputs, which are either data or methods. It consists of a piece of code and an HTML template, which render interesting data, living on the component. A component in Angular consists of three major parts:</p>
<ul>
<li>A decorator function</li>
<li>A class</li>
<li>A template</li>
</ul>
<p>A component consists of a controller class and a template. It can play two different roles in an Angular application: either it can be the responder to the route or it can serve as a building block. In the first case, Angular will instantiate it when a new route happens and respond with that component. In the latter case, the component is created directly by existing as a child component within another component.</p>
<p>We will explain next what we meant by the previous paragraph.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">First responder to a route</h1>
                </header>
            
            <article>
                
<p>As mentioned, a component can be used as a responder to a route. So let's say the application routes to the <kbd>/products</kbd> <span>route </span><span>as a result of a user interaction, or programmatically. Angular's way of dealing with this is to associate the <kbd>/products</kbd> route with a component. With the help of a component's class and HTML markup, we </span><span>are </span><span>able to produce a piece of HTML containing our markup and data rendered together. Pointing out a component as a responder to a route, is done when defining the so-called route map, like so:</span></p>
<pre>// example of what routing might look like<br/><br/>export<span> </span><span>const</span><span> </span><span>appRoutes</span><span>:</span><span> </span><span>Routes</span><span> </span><span>=</span><span> [<br/>  </span>{ <br/><span>    path:</span><span> </span><span>''</span><span>, <br/></span><span>    component:</span><span> </span><span>HomeComponent<br/></span><span>  },<br/>  </span>{<br/>    path:<span> </span><span>'payments'</span><span>,<br/>    </span>component:<span> </span><span>ProductsComponent</span><span>,<br/>    </span>data:<span> { </span><span>title:</span><span> </span><span>'Products'</span><span> }<br/>  }<br/>]</span></pre>
<p>Essentially, a route is defined as an object with <kbd>path</kbd> properties, pointing out our route, and a <kbd>component</kbd><span> property pointing to the responding component. We can attach other properties to the route, such as <kbd>data</kbd>, to give the responding components some initial data to render.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Used as a building block</h1>
                </header>
            
            <article>
                
<p>Using a component as a building block means it will be part of another component's template. Essentially, it will be seen as that component's child. This line of thinking is quite natural and means that we can think of our application as a hierarchical tree of components. A component in Angular consists of a controller class and a template as we have mentioned previously. A typical component looks like so:</p>
<pre>// an example component<br/><br/>@Component({<br/>  selector: 'example-component'<br/>})<br/>export class ExampleComponent {}</pre>
<p><span>The </span><kbd>@Component</kbd><span> </span><span>decorator function</span><span> adds metadata to the class. This instructs Angular on how to create the component so that Angular can place the component in the DOM. This enables you to use it as a responder to a route or as your own custom element. The property <kbd>selector</kbd> is what decides what your component should be called, if used as a custom element. Example usage looks like the following:</span></p>
<pre>// an example container component<br/>@Component({<br/>  selector: `<br/>  {{ title }}<br/>  <strong>&lt;example-component&gt;</strong><br/>  `<br/>})<br/>export class ContainerComponent {<br/>  title ="container component";<br/>}</pre>
<p>The fact that components can be used this way makes it easy to think about an app as consisting of a hierarchical tree of components. A Todo application could therefore look like the following:</p>
<pre>AppComponent<br/>  TodoList<br/>    TodoItem<br/>    TodoItem<br/>    TodoItem<br/>    ...</pre>
<p>Let's start to create this app, starting with the <kbd>AppComponent</kbd>. As this is the topmost component, it is also referred to as the root component. The <kbd>AppComponent</kbd> should render the <kbd>TodoListComponent</kbd> in its own template, like so:</p>
<pre>// mvc/MvcExample/src/app/app.component.ts<br/><br/>import<span> { Component } </span><span>from</span><span> </span><span>"@angular/core"</span><span>;<br/></span><br/>@Component({<br/>  selector: <span>"app-root"</span><span>,<br/></span>  template: <span>`<br/></span>  <strong>&lt;todo-list&gt;&lt;/todo-list</strong><span><strong>&gt;</strong><br/></span>`<span>,<br/></span>  styleUrls: [<span>"./app.component.css"</span><span>]<br/></span>})<br/>export<span> </span><span>class</span><span> AppComponent {<br/></span>  title <span>=</span><span> </span><span>"app"</span><span>;<br/></span>}<span><br/></span></pre>
<p>The next step is defining the <kbd>TodoListComponent</kbd> and knowing that it should be able to render a number of <kbd>TodoItemComponent</kbd> instances within its template. The size of a list is usually unknown. This is exactly what the structural directive <kbd>*ngFor</kbd> is for. So that is what we will utilize in the following code as we define the <kbd>TodoListComponent</kbd>:</p>
<pre>// mvc/MvcExample/src/app/todo-list.component.ts<br/><br/>import<span> { Component } </span><span>from</span><span> </span><span>"@angular/core"</span><span>;<br/></span><br/>@Component({<br/>selector: <span>"todo-list"</span><span>,<br/></span>template: <span>`<br/></span>  &lt;<span>h1</span><span>&gt;</span><span>{{title}}</span><span>&lt;/</span><span>h1</span><span>&gt;</span><span> </span><span>&lt;</span><span>custom</span><span>&gt;&lt;/</span><span>custom</span><span>&gt;<br/></span>  <strong>&lt;div *ngFor="let todo of todos"&gt;<br/>    &lt;todo-item [todo]="todo" &gt;&lt;/todo-item&gt;<br/>  &lt;/div</strong><span><strong>&gt;</strong><br/></span>`<span> . </span><span>// the view<br/></span>})<br/>export<span> </span><span>class</span><span> TodoListComponent { </span><span>// the controller class<br/></span>  title<span>:</span><span> string;<br/></span>  todos <span>=</span><span> [{<br/></span>    title: <span>"todo1"<br/></span>  },{<br/>    title: <span>"todo1"<br/></span>  }]<br/>}</pre>
<p>Here, we can see that we render out a list of <kbd>todo</kbd> items by looping out the todos array in the template, like so:</p>
<pre><strong>&lt;div *ngFor="let todo of todos"&gt;<br/>    &lt;todo-item [todo]="todo" &gt;&lt;/todo-item&gt;<br/>&lt;/div&gt;</strong></pre>
<p>We can see in the preceding code that we are rendering out the <kbd>todo-item</kbd> selector, which points to a <kbd>TodoItemComponent</kbd> that we are yet to define. Worth noting is how we pass it a <kbd>todo</kbd> object and assign it to an input property on the <kbd>TodoItemComponent</kbd>. The definition for said component is as follows:</p>
<pre>// mvc/MvcExample/src/app/todo-item.component.ts<br/><br/>import<span> { Component, Input } </span><span>from</span><span> </span><span>"@angular/core"</span><span>;<br/></span>@Component({<br/>  selector: <span>"todo-item"</span><span>,<br/></span>  template: <span>`</span><span>&lt;</span><span>h1</span><span>&gt;</span><span>{{todo.title}}</span><span>&lt;/</span><span>h1</span><span>&gt;</span><span>`</span><span> </span><span><br/></span>})<br/>export<span> </span><span>class</span><span> TodoItemComponent {</span><br/>  @Input() todo;<br/>}</pre>
<p>Reasoning about which components should exist as part of which other components is something you are going to dedicate a lot of time to.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Components from an architectural standpoint</h1>
                </header>
            
            <article>
                
<p>You are encouraged to create a lot of components in your Angular application. With the former section's example of creating a <kbd><span>todo</span></kbd> list application it was tempting to create an application that just consisted of one component, the <kbd>AppComponent</kbd>. This would have meant that one component would have been responsible for a ton of things, such as displaying <kbd><span>todo</span></kbd> items, saving said items, removing them and so on. Components are meant to be used to solve one thing well. That's why we created a <kbd>TodoItemComponent</kbd> which only job in life was to display a <kbd><span>todo</span></kbd> item. Same thing goes for the <kbd>TodoListComponent</kbd>. It should only care about displaying a list, nothing else. The more you split down your applications into small and focused areas the better. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">NgModule – our new facade (and some other bits)</h1>
                </header>
            
            <article>
                
<p>So far, we have talked about components in terms of them being dedicated to solving one task well. However, there are other constructs that can be used in Angular, such as pipes, directives, and services. A lot of our components will find themselves belonging to a common theme, such as products or user management and so on. When we realize what constructs belong to the same theme, we also realize that some of these constructs are constructs we want to use elsewhere in the application. Conversely, some constructs are only meant to be used in the context of the mentioned theme. To protect the latter constructs from unintended use, we would like to group them in a facade-like way and put a protective layer between the constructs and the rest of the application. The way to do that in pure ES2015 modules is to create a facade file, in which public constructs are exported and others are not, like so:</p>
<pre>// an old facade file, index.ts<br/><br/>import { MyComponent } from 'my.component';<br/>import { MyService } from 'my.service';<br/><br/>export MyComponent;<br/>export MyService;</pre>
<p>Imagine we have a directory consisting of the following files:</p>
<pre>/my<br/>  MyComponent.ts<br/>  MyService.ts<br/>  MyOtherService.ts<br/>  index.ts</pre>
<p>The intent of creating a facade file here is to ensure there is only one place from where you import all the constructs you need. In this case that would be the <kbd>index.ts</kbd> file. A consumer of the preceding directory would do the following:</p>
<pre>// consumer.ts<br/><br/>import * as my from './my';<br/>let component = new my.MyComponent();<br/>let service = new MyService();</pre>
<p><kbd>MyOtherService</kbd> is not being exposed by the <kbd>index.ts</kbd> file though, so attempting to access it like we do in <kbd>consumer.ts</kbd> would lead to an error. You could theoretically specify the full path to the construct but you are supposed to be using the barrel. Barrels are usually meant to be used to easily access your constructs without having to write import statements that are five miles long, like so:</p>
<pre>// index.ts<br/>import { Service } from '../../../path-to-service';<br/>import { AnotherService } from '../../path-to-other-service';<br/>export Service;<br/>export AnotherService;<br/><br/>// consumer.ts<br/><br/>// the long and tedious way<br/>import { Service } from '../../../path-to-service';<br/>import { AnotherService } from '../../path-to-other-service';<br/><br/>// the easier way using a barrel<br/>import * as barrel from './index';<br/>let service = new barrel.Service();<br/>let anotherService = new barrel.AnotherService();<br/><br/></pre>
<p>As you can see that barrel, <kbd>index.ts</kbd> is the one that is responsible for knowing where all your constructs are located. This also means that were you to move files around, changing directories for certain constructs, the barrel file is the only one where updating the paths to these constructs is needed. </p>
<p>The Angular way of dealing with this is to use Angular modules. An Angular module looks like the following:</p>
<pre>// mvc/MvcExample/src/app/my/my.module.ts<br/><br/>import<span> { NgModule } </span><span>from</span><span> </span><span>"@angular/core"</span><span>;<br/></span>import<span> { MyComponent } </span><span>from</span><span> </span><span>"./my.component"</span><span>;<br/></span>import<span> { MyPipe } </span><span>from</span><span> </span><span>"./my.pipe"</span><span>;<br/></span><br/>@NgModule({<br/>  imports: [],<br/>  exports: [MyComponent],<br/>  declarations: [MyComponent, MyPipe],<br/>  providers: []<br/>})<br/>export<span> </span><span>class</span><span> MyModule {}</span></pre>
<p>The effect of putting <kbd>MyComponent</kbd> and <kbd>MyPipe</kbd> into the declarations property of the module is so that these components can be freely used within <kbd>MyModule</kbd>. For example, you can use <kbd>MyPipe</kbd> within the <kbd>MyComponent</kbd> template. However, if you want to use <kbd>MyComponent</kbd> outside of this module, in a component belonging to another module, you will need to export it. We do that by placing it in the array belonging to the <kbd>exports</kbd> property:</p>
<pre>exports: [MyComponent]</pre>
<p>Angular takes the concept of a module way beyond grouping. Some instructions in our <kbd>NgModule</kbd> are meant for the compiler so that it knows how to assemble the components. Some other instructions we give it are meant for the Dependency Injection tree. Think of the Angular module as a configuration point, but also as the place where you logically divide up your application in to cohesive blocks of code.</p>
<p>On the object sent to the <kbd>@NgModule</kbd> decorator, there are properties you can set that have different meanings. The most important properties are:</p>
<ul>
<li>The <kbd>declarations</kbd> property is an array that states what belongs to our module</li>
<li>The <kbd>imports</kbd> property is an array that states what other Angular modules we are dependent on; it could be basic Angular directives or common functionality that we want to use inside of our module</li>
<li>The <kbd>exports</kbd> property is an array stating what should be made available for any module importing this module; <kbd>MyComponent</kbd> is made public whereas <kbd>MyPipe</kbd> would become private for this module only</li>
<li>The <kbd>providers</kbd> property is an array stating what services should be injectable into constructs belonging to this module, that is, to constructs that are listed in the declarations array</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using ES2015 modules</h1>
                </header>
            
            <article>
                
<p>So far, we have mentioned that models are just plain classes. An ES2015 module is just one file. Within that file lives both public and private constructs. Things that are private are only visible within that file. Things that are public can be used outside said file. In Angular, Es2015 modules aren't used only for models but for all imaginable constructs such as components, Directives, Pipes, Services, and so on. This is because ES2015 modules are an answer to how we split our project into smaller parts, which provides us with the following benefits:</p>
<ul>
<li>Many small files makes it easier to parallelize the work you do and have many developers work on it at the same time</li>
<li>The ability to hide data by, making some parts of your application public and some other private</li>
<li>Code reuse</li>
<li>Better maintainability</li>
</ul>
<p>We have to remember what web development used to look like to understand these statements. When the web was young our JavaScript code more often than not consisted of one file. That quickly became a huge mess. There have been different techniques over the years to find a way to split up our app into many small files. Many small files have made it easier to maintain and also to get a good overview of what is going on, among many other benefits. There have been other issues though. As all these small files had to be stitched back together before being shipped with the app, a process called bundling, we suddenly had one giant file where functions and variables could by mistake affect each other due to naming collisions. A way to attack that problem is to deal with something called information hiding. This to ensure the variables and functions we created are only visible to certain other constructs. There are multiple ways, of course, to address this issue. ES2015 has a private by default way about them. Everything declared in an ES2015 is private by default unless you explicitly export it, thereby making it publicly accessible to other modules that import the aforementioned module. </p>
<p>So how does this connect to the previous statements? Any module system really allows us to maintain visibility in our project as it grows with us. The alternative is one file which is complete chaos. As for several developers working at the same time, any way of logically dividing up the app makes it easier to divide up the workstreams between developers. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consuming a module</h1>
                </header>
            
            <article>
                
<p>In ES2015, we use the <kbd>import</kbd> and <kbd>from</kbd> keywords to import one or several constructs like so:</p>
<pre>import { SomeConstruct } from './module';</pre>
<p>The imported file looks like this:</p>
<pre>export let SomeConstruct = 5;</pre>
<p>The basic operations involved, working with ES2015 modules, can be summarized as follows:</p>
<ul>
<li>Define a module and write the business logic of the module</li>
<li>Export the constructs you want to make public</li>
<li>Consume said module with an <kbd>import</kbd> keyword from a consumer file </li>
</ul>
<p>Of course there is a bit more to it than that, so let's look at what else you can do in the next subsection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An Angular example</h1>
                </header>
            
            <article>
                
<p>We have been using ES2015 imports extensively throughout this chapter already, but let's emphasize when that was. As mentioned, all constructs used ES2015 modules, models, services, components, and modules. For the module, this looked like this:</p>
<pre><strong>import { NgModule } from '@angular/core';</strong><br/><br/>@NgModule({<br/>  declarations: [],<br/>  imports: [],<br/>  exports: [],<br/>  providers: []<br/>})<br/><strong>export class FeatureModule {}</strong></pre>
<p>Here, we see that we import the functionality we need and we end up exporting this class, thereby making it available for other constructs to consume. It's the same thing with modules, like so:</p>
<pre><strong>import { Component } from '@angular/core';</strong><br/><br/>@Component({<br/>  selector: 'example'<br/>})<br/><strong>export class ExampleComponent {}</strong></pre>
<p>The pipe, directive, and filter all follow the same pattern of importing what they need and exporting themselves to be included as part of an <kbd>NgModule</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple exports</h1>
                </header>
            
            <article>
                
<p>So far, we have only shown how to export one construct. It is possible to export multiple things from one module by adding an <kbd>export</kbd> keyword next to all constructs that you wish to export, like so:</p>
<pre>export class Math {<br/>  add() {}<br/>  subtract() {}<br/>}<br/><br/>export const PI = 3.14 </pre>
<p>Essentially, for everything you want to make public you need to add an <kbd>export</kbd> keyword at the start of it. There is an alternate syntax, where instead of adding an <kbd>export</kbd> keyword to every construct, we can instead define within curly brackets what constructs should be exported. It looks like this:</p>
<pre>class Math {<br/>  add() {}<br/>  subtract() {}<br/>}<br/><br/>const PI = 3.14 <br/><br/>export {<br/>  Math, PI<br/>}</pre>
<p>Whether you put <kbd>export</kbd> in front of every construct or you place them all in an <kbd>export {}</kbd>, then end result is the same, it's just a matter of taste which one to use. To consume constructs from this module, we would type: </p>
<pre>import { Math, PI } from './module';</pre>
<p>Here, we have the option of specifying what we want to <kbd>import</kbd>. In the previous example, we have opted to export both <kbd>Math</kbd> and <kbd>PI</kbd>, but we could be content with only exporting <kbd>Math</kbd>, for example; it is up to us.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The default import/export</h1>
                </header>
            
            <article>
                
<p>So far, we have been very explicit with what we import and what we export. We can, however, create a so-called default export, which looks somewhat different to consume:</p>
<pre>export default class Player {<br/>  attack() {}<br/>  move() {}<br/>}<br/><br/>export const PI = 3.13;</pre>
<p>To consume this, we can write the following:</p>
<pre>import Player from './module';<br/>import { PI } from './module'</pre>
<p>Note especially the first row where we no longer use the curly brackets, <kbd>{}</kbd>, to import a specific construct. We just use a name that we make up. In the second row, we have to name it correctly as   <kbd>PI</kbd>, but in the first row we can choose the name. The player points to what we exported as default, that is, the <kbd>Player</kbd> <span>class</span><span>. As you can see, we can still use the normal curly brackets, <kbd>{}</kbd>, to import specific constructs if we want to.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Renaming imports</h1>
                </header>
            
            <article>
                
<p>Sometimes we may get a collision, with constructs being named the same. We could have this happening:</p>
<pre>import { productService } from './module1/service'<br/>import { productService } from './module2/service'; // name collision</pre>
<p>This is a situation we need to resolve. We can resolve it using the <kbd>as</kbd> keyword, like so:</p>
<pre>import { productService as m1_productService }<br/>import { productService as m2_productService }</pre>
<p>Thanks to the <kbd>as</kbd> keyword, the compiler now has no problem differentiating what is what.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The service</h1>
                </header>
            
            <article>
                
<p>We started this main section talking about how ES2015 modules are for all constructs in Angular. This section is about services, and services are no different when it comes to using ES2015 modules. Services we use should be declared in a separate file. If we intend to use a service, we need to import it. It needs to be imported for different reasons though, depending on what type of service it is. Services can be of two types:</p>
<ul>
<li>Services without dependencies</li>
<li>Services with dependencies</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service without dependencies</h1>
                </header>
            
            <article>
                
<p>A service without dependencies is a service whose constructor is empty:</p>
<pre>export Service {<br/>  constructor(){}<br/>  getData() {}<br/>}</pre>
<p>To use it, you simply type:</p>
<pre>import { Service } from './service'<br/>let service = new Service();<br/>service.getData();</pre>
<p>Any module that consumes this service will get their own copy of the code, with this kind of code. If you, however, want consumers to share a common instance, you change the <kbd>service</kbd> module definition slightly to this:</p>
<pre>class Service {<br/>  constructor() {}<br/>  getData() {}<br/>}<br/>const service = new Service();<br/>export default service;</pre>
<p>Here, we export an instance of the service rather than the service declaration. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service with dependencies</h1>
                </header>
            
            <article>
                
<p>A service with dependencies has dependencies in the constructor that we need help resolving. Without this resolution process, we can't create the service. Such a service may look like this:</p>
<pre>export class Service {<br/>  constructor(<br/>    Logger logger: Logger, <br/>    repository:Repository<br/>  ) {}<br/>}</pre>
<p>In this code, our service has two dependencies. Upon constructing a service, we need one <kbd>Logger</kbd> instance and one <kbd>Repository</kbd> instance. It would be entirely possible for us to find the <kbd>Logger</kbd> instance and <kbd>Repository</kbd> instance by typing something like this:</p>
<pre>import { Service } from './service'<br/>import logger from './logger';<br/>import { Repository } from './repository';<br/><br/>// create the service<br/>let service = new Service( logger, new Repository() )</pre>
<p>This is absolutely possible to do. However, the code is a bit tedious to write every time I want a service instance. When you start to have 100s of classes with deep object dependencies, a DI system quickly pays off.</p>
<p>This is one thing a Dependency Injection library helps you with, even if it is not the main motivator behind its existence. The main motivator for a DI system is to create loose coupling between different parts of the system and rely on contracts rather than concrete implementations. Take our example with the service. There are two things a DI can help us with:</p>
<ul>
<li>Switch out one concrete implementation for another </li>
<li>Easily test our construct</li>
</ul>
<p>To show what I mean, let's first assume <kbd>Logger</kbd> and <kbd>Repository</kbd> are interfaces. Interfaces may be implemented differently by different concrete classes, like so:</p>
<pre>import { Service } from './service'<br/>import logger from './logger';<br/>import { Repository } from './repository';<br/><br/>class FileLogger implements Logger {<br/>  log(message: string) {<br/>    // write to a file<br/>  }<br/>}<br/><br/>class ConsoleLogger implements Logger {<br/>  log(message: string) {<br/>    console.log('message', message);<br/>  }<br/>}<br/><br/>// create the service<br/>let service = new Service( new FileLogger(), new Repository() )</pre>
<p>This code shows how easy it is to switch out the implementation of <kbd>Logger</kbd> by just choosing <kbd>FileLogger</kbd> over <kbd>ConsoleLogger</kbd> or vice versa. The test case is also made a lot easier if you only rely on dependencies coming from the outside, so that everything can therefore be mocked.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependency Injection</h1>
                </header>
            
            <article>
                
<p>Essentially, when we ask for a construct instance, we want help constructing it. A DI system can act in one of two ways when asked to resolve an instance:</p>
<ul>
<li><strong>Transient mode</strong>: The dependency is always created anew</li>
<li><strong>Singleton mode</strong>: The dependency is reused</li>
</ul>
<p>Angular only creates singletons though which means every time we ask for a dependency it will only be created once and we will be given an already existing dependency if we are not the first construct to ask for that dependency.</p>
<p>The default behavior of any DI framework is to use the default constructor on a class and create an instance from a class. If that class has dependencies, then it has to resolve those first. Imagine we have the following case:</p>
<pre>export<span> </span><span>class</span><span> </span><span>Logger</span><span> { }<br/><br/></span>export<span> </span><span>class</span><span> </span><span>Service</span><span> {<br/>  </span>constructor<span>(</span><span>logger</span><span>:</span><span> </span><span>Logger</span><span>) { }<br/></span>}<span><br/></span></pre>
<p>The DI framework would crawl the chain of dependencies, find the construct that does not have any dependencies, and instantiate that first. Then it would crawl upwards and finally resolve the construct you asked for. So with this code:</p>
<pre>import<span> { </span><span>Service</span><span> } </span><span>from</span><span> </span><span>'./service'</span><span>;<br/></span><br/>export<span> </span><span>class</span><span> </span><span>ExampleComponent</span><span> {<br/></span><span>  </span>constructor<span>(</span><span>srv</span><span>:</span><span> </span><span>Service</span><span>) { }<br/></span>}<span><br/></span></pre>
<p>The DI framework would:</p>
<ul>
<li>Instantiate the logger first</li>
<li>Instantiate the service second</li>
<li>Instantiate the component third</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependency Injection in Angular using providers</h1>
                </header>
            
            <article>
                
<p>So far we have only discussed Dependency Injection in general, but Angular has some constructs, or decorators, to ensure that Dependency Injection does its job. First imagine a simple scenario, a service with no dependencies:</p>
<pre>export class SimpleService {}</pre>
<p>If a component exists that requires an instance of the service, like so:</p>
<pre>@Component({<br/>  selector: 'component'<br/>})<br/>export class ExampleComponent {<br/>  constructor(srv: Service) {}<br/>}</pre>
<p>The Angular Dependency Injection system comes in and attempts to resolve it. Because the service has no dependencies, the solution is as simple as instantiating <kbd>Service</kbd>, and Angular does this for us. However, we need to tell Angular about this construct for the DI machinery to work. The thing that needs to know this is called a provider. Both Angular modules and components have access to a providers array that we can add the <kbd>Service</kbd> construct to. A word on this though. Since the arrival of Angular modules, the recommendation is to not use the providers array for components. The below paragraphs are merely there to inform you how providers for components work. </p>
<p>This will ensure that a <kbd>Service</kbd> instance is being created and injected at the right place, when asked for. Let's tell an Angular module about a service construct:</p>
<pre>import<span> { </span><span>Service</span><span> } </span><span>from</span><span> </span><span>"./Service"</span><span>;<br/></span><br/>@<span>NgModule</span><span>({<br/></span>  providers:<span> [</span><span>Service</span><span>]<br/></span>})<br/>export<span> </span><span>class</span><span> </span><span>FeatureModule</span><span>{}</span></pre>
<p>This is usually enough to make it work. You can, however, register the <kbd>Service</kbd> construct with the <kbd>component</kbd> class instead. It looks identical:</p>
<pre>@Component({<br/>  providers: [Service]<br/>})<br/>export ExampleComponent {}</pre>
<p>This has a different effect though. You will tell the DI machinery about this construct and it will be able to resolve it. There is a limitation, however. It will only be able to resolve it for this component and all its view child components. Some may see this as a way of limiting what components can see what services and therefore see it as a feature. Let me explain that by showing when the DI machinery can figure out our provided service<span>:</span></p>
<p><strong>Everybody's parent – it works</strong>: Here, we can see that as long as the component highest up declares <kbd>Service</kbd> as a provider, all the following components are able to inject <kbd>Service</kbd>:</p>
<pre>AppComponent // Service added here, Can resolve Service<br/>  TodosComponent // Can resolve Service<br/>    TodoComponent // Can resolve Service</pre>
<p>Let's exemplify this with some code:</p>
<pre>// example code on how DI for works for Component providers, there is no file for it<br/>// app.component.ts<br/>@Component({<br/>  <strong>providers: [Service] // &lt; - provided,<br/></strong>  template : `&lt;todos&gt;&lt;/todos&gt;`<br/>})<br/>export class AppComponent {}<br/><br/>// todos.component.ts<br/>@Component({<br/>  template : `&lt;todo&gt;&lt;/todo&gt;`,<br/>  selector: 'todos'<br/>})<br/>export class TodosComponent {<br/>  <strong>// this works</strong><br/>  constructor(<strong>private service: Service</strong>) {}<br/>}<br/><br/>// todo.component.ts<br/>@Component({<br/>  selector: 'todo',<br/>  template: `todo component ` <br/>})<br/>export class TodoComponent {<br/>  <strong>// this works</strong><br/>  constructor(<strong>private service: Service</strong>) {}<br/>}</pre>
<p><strong>TodosComponent – will work for its children but not higher up</strong>: Here, we provide Service one level down, to <kbd>TodosComponent</kbd>. This makes <kbd>Service</kbd> available to the child components of <kbd>TodosComponent</kbd> but <kbd>AppComponent</kbd>, its parent, misses out:</p>
<pre>AppComponent // Does not know about Service<br/>  TodosComponent // Service added here, Can resolve Service<br/>    TodoComponent // Can resolve Service</pre>
<p>Let's try to show this in code:</p>
<pre>// this is example code on how it works, there is no file for it<br/>// app.component.ts<br/>@Component({<br/>  selector: 'app',<br/>  template: `&lt;todos&gt;&lt;/todos&gt;`<br/>})<br/>export class AppComponent {<br/>  <strong>// does NOT work,</strong> <strong>only TodosComponent and below knows about Service</strong><br/>  constructor(<strong>private service: Service</strong>) {}<br/>}<br/><br/>// todos.component.ts<br/>@Component({<br/>  selector: 'todos',<br/>  template: `&lt;todo&gt;&lt;/todo&gt;`<br/>  <strong>providers: [Service]</strong><br/>})<br/>export class TodosComponent {<br/>  <strong>// this works</strong><br/>  constructor(<strong>private service: Service</strong>) {}<br/>}<br/><br/>// todo.component.ts<br/>@Component({<br/>  selector: 'todo',<br/>  template: `a todo`<br/>})<br/>export class TodoComponent {<br/>  <strong>// this works</strong><br/>  constructor(<strong>private service: Service</strong>) {}<br/>}</pre>
<p>We can see here that adding our <kbd>Service</kbd> to a component's <kbd>providers</kbd> array has limitations. Adding it to an Angular module is the sure way to ensure it can be resolved by all constructs residing inside of that array. This is not all though. Adding our <kbd>Service</kbd> to an Angular module's providers array ensures it is accessible throughout our entire application. How is that possible, you ask? It has to do with the module system itself. Imagine we have the following Angular modules in our application:</p>
<pre>AppModule<br/>SharedModule</pre>
<p>For it to be possible to use our <kbd>SharedModule</kbd>, we need to import it into <kbd>AppModule</kbd> by adding it to the <kbd>imports</kbd> array of <kbd>AppModule</kbd>, like so:</p>
<pre>//app.module.ts<br/><br/>@NgModule({<br/>  imports: [ SharedModule ],<br/>  providers: [ AppService ]<br/>})<br/>export class AppModule{}</pre>
<p>We know this has the effect of pulling all constructs from the <kbd>exports</kbd> array in <kbd>SharedModule</kbd>, but this will also concatenate the providers array from <kbd>SharedModule</kbd> to that of <kbd>AppModule</kbd>. Imagine <kbd>SharedModule</kbd> looking something like this:</p>
<pre>//shared.module.ts<br/><br/>@NgModule({<br/>  providers : [ SharedService ]<br/>})<br/>export class SharedModule {} </pre>
<p>After the import has taken place, the combined providers array now contains:</p>
<ul>
<li><kbd>AppService</kbd></li>
<li><kbd>SharedService</kbd></li>
</ul>
<p>So the rule of thumb here is if you want to expose a service to your application, then put it in the Angular module's <kbd>providers</kbd> array. If you want to limit access to the service, then place it into a component's <kbd>providers</kbd> array. Then, you will ensure it can only be reached by that component and its view children.</p>
<p>Up next, let's talk about cases when you want to override the injection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overriding an existing construct</h1>
                </header>
            
            <article>
                
<p>There are cases when you want to override the default resolution of your construct. You can do so at the module level, but also at the component level. What you do is simply express which construct you are overriding and with which other construct. It looks like this:</p>
<pre>@Component({<br/>  providers: [<br/>    { provide: Service, useClass : FakeService }<br/>  ]<br/>})</pre>
<p>The <kbd>provide</kbd> is our known construct and <kbd>useClass</kbd> is what it should point to instead. Let's imagine we implemented our <kbd>Service</kbd> like so:</p>
<pre>export<span> </span><span>class</span><span> </span><span>Service</span><span> {<br/>  </span>no<span>:</span><span> </span><span>number = 0</span><span>;<br/>  </span>constructor<span>() {</span>}<br/>}</pre>
<p>And we added the following override to a component:</p>
<pre>@Component({<br/>  providers: [{ provide : Service, useClass: <strong>FakeService</strong> }]<br/>})</pre>
<p>The <kbd>FakeService</kbd> class has the following implementation:</p>
<pre>export<span> </span><span>class</span><span> </span><span>FakeService</span><span> {<br/>  </span>set<span> </span><span>no</span><span>(</span><span>value</span><span>) {<br/>    </span>// do nothing<br/>  }<br/><br/>  get<span> </span><span>no</span><span>() {<br/>    </span>return<span> </span><span>99</span><span>;<br/>  </span>}<br/>}</pre>
<p>Now the component and all its view child components will always get <kbd>FakeService</kbd> when asking for the Service construct.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overriding at runtime</h1>
                </header>
            
            <article>
                
<p>There is a way to decide what to inject for/into a construct at runtime. So far, we have been very explicit about when to override, but we can do this with a bit of logic added to it by using the <kbd>useFactory</kbd> keyword. It works like the following:</p>
<pre>let factory = () =&gt; {<br/>  if(<strong>condition</strong>) {<br/>    return new FakeService();<br/>  } else {<br/>    return new Service();<br/>  }<br/>}<br/><br/>@Component({<br/> providers : [<br/>   { provide : Service, <strong>useFactory : factory</strong> }<br/> ]<br/>})</pre>
<p>This factory can in itself have dependencies; we specify those dependencies with the <kbd>deps</kbd> keyword like so:</p>
<pre>let factory = (auth:AuthService, logger: Logger) =&gt; {<br/>  if(<strong>condition</strong>) {<br/>    return new FakeService();<br/>  } else {<br/>    return new Service();<br/>  }  <br/>}<br/><br/>@Component({<br/>  providers : [<br/>   { provide : Service, useFactory : factory, <br/><strong>     deps: [AuthService, Logger]</strong> }<br/>  ]<br/>})</pre>
<p>Here, we highlighted the <kbd>condition</kbd> variable, which is a Boolean. There can be a ton of reasons why we would want to be able to switch the implementation. One good case is when the endpoint don't exist yet and we want to ensure it calls our <kbd>FakeService</kbd> instead. Another reason could be that we are in testing mode and by just changing this one variable we can make all our services rely on a fake version of themselves.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overriding constants</h1>
                </header>
            
            <article>
                
<p>Not everything, though, is a class that needs to be resolved; sometimes it is a constant. For those cases, instead of using <kbd>useClass</kbd>, we can use <kbd>useValue</kbd>, like so:</p>
<pre>providers: [ { provide: 'a-string-token', useValue: 12345678 } ]</pre>
<p>This is not really a class type, so you can't write this in a constructor:</p>
<pre>constructor(a-string-token) . // will not compile</pre>
<p>That wouldn't compile. What we can do instead is to use the <kbd>@Inject</kbd> decorator in the following way:</p>
<pre>constructor( @Inject('a-string-token') token) // token will have value 12345678</pre>
<p>The <kbd>useValue</kbd> is no different from <kbd>useClass</kbd> when it comes to how to override it. The difference is of course that we need to type  <kbd>useValue</kbd> in our instruction to override rather than <kbd>useClass</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resolving your dependencies with @Injectable</h1>
                </header>
            
            <article>
                
<p>We took a little deep dive into DI in the previous section, but almost forgot about a very important decorator, <kbd>@Injectable</kbd>. <kbd>@Injectable</kbd> is not strictly mandatory to use for services in general. However, if that service has dependencies, then it needs to be used. Failure to decorate a service with <kbd>@Injectable</kbd> that has dependencies leads to an error where the compiler complains that it doesn't know how to construct the mentioned service. Let's look at a case where we need to use the   <kbd>@Injectable</kbd> decorator:</p>
<pre>import { Injectable } from '@angular/core';<br/><br/>@Injectable() <br/>export class Service {<br/>  constructor(logger:Logger) {}<br/>}</pre>
<p>In this case, Angular's DI machinery will look up <kbd>Logger</kbd> and inject it into the <kbd>Service</kbd> constructor. So, providing we have done this:</p>
<pre>providers: [Service, Logger]</pre>
<p>In a component or module, it should work. Remember, when in doubt, add <kbd>@Injectable</kbd> to your service if it has dependencies in the constructor or will have in the near future. If your service lacks the <kbd>@Injectable</kbd> keyword and you try to inject it into a component's constructor, then it will throw an error and your component will not be created. </p>
<p>This section set out to explain how DI works from a general standpoint and how it works in Angular. For the latter, it covered how to register constructs to work with Angular's DI machinery, but also how to override it. It is clear that the DI machinery is quite sophisticated. It can be scoped to the application level, by adding constructs to the providers array of Angular modules, but also to the component level and its view children. The main reason for describing the DI machinery was to teach you the possibilities of it, so you know how to best use it to your advantage when you define the architecture of your app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetching and persisting data with HTTP – introducing services with Observables</h1>
                </header>
            
            <article>
                
<p>So far, we have gone through a data flow where the component is our view to the outside world, but also the controller. The component uses a service to get the data, but also to persist it. The data, however, has up until this point lived in the service and that's not a very likely place for it to reside. Almost certainly, that data should be fetched and persisted to an endpoint. That endpoint is an exposed URL to a backend system published somewhere on the internet. We can use HTTP to reach said endpoint. Angular has created a wrapper on top of the vanilla way of fetching data through HTTP. The wrapper is a class that wraps the functionality of an object called   <kbd>XmlHttpRequest</kbd>. The Angular wrapper class is called the  <kbd>HttpClient</kbd>   service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetching data with the HTTP service</h1>
                </header>
            
            <article>
                
<p>There is more than one way to communicate over HTTP. One way is using the <kbd>XmlHttpRequest</kbd> object, but that is a quite cumbersome and low-level way of doing it. Another way is to use the new fetch API, which you can read more about here: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API</a>.</p>
<p>Angular has its own abstraction, the HTTP service, which can be found in the <kbd>HTTPModule</kbd>. To use it, simply import the <kbd>HttpModule</kbd>:</p>
<pre><span>import</span><span> { </span><span>HttpClientModule</span><span> } </span><span>from</span><span> </span><span>'@angular/common/http'</span><span>;<br/><br/>@NgModule({<br/>  imports: [HttpClientModule]<br/>})</span></pre>
<p>Then, inject the   <kbd>HttpClient</kbd>   service where you want to use it, like so:</p>
<pre>import { HttpClient } from '@angular/common/http';<br/><br/>@Component({<br/>  selector: 'consumer',<br/>  template: ``<br/>})<br/>export class ConsumerComponent {<br/>  constructor(private http:HttpClient) {}<br/>}</pre>
<p>At this point, we are ready to use it. Let's see a quick overview of what methods this HTTP service has:</p>
<ul>
<li><kbd>get('url', &lt;optional options param&gt;)</kbd> fetches the data for us</li>
<li><kbd>post('url', payload,&lt;optional options param&gt;)</kbd> creates a resource</li>
<li><kbd>put('url', payload,&lt;optional options param&gt;)</kbd> updates a resource</li>
<li><kbd>delete('url',&lt;optional options param&gt;)</kbd> removes a resource</li>
<li><kbd>request</kbd> is a raw request where you can configure exactly what call you want to make, what headers you want to add, and so on</li>
</ul>
<p><span>When we use <kbd>http.get()</kbd> we get a construct back called an Observable. An Observable is just like the <kbd>Promise</kbd>, an asynchronous concept that enables us to attach callbacks to when the data arrives some time in the future, as well as attaching callbacks to an error when an error occurs. The RxJS implementation of the Observable comes packed with a number of operators that help us transform the data and interact with other Observables. One such operator is called <kbd>toPromise()</kbd> and enables us to convert an Observable to a Promise. With this, we can make HTTP calls in two different ways, or flavors. The first way is where we use the <kbd>toPromise()</kbd> operator and convert our <kbd>Observable</kbd> to a <kbd>Promise</kbd>, and the other is using our Observable and dealing with the data that way. </span></p>
<p>A typical call comes in two different flavors:</p>
<ul>
<li><strong>Using promises</strong></li>
</ul>
<pre>// converting an Observable to a Promise using toPromise()<br/>http<br/>  .get('url')<br/>  <strong>.toPromise()</strong><br/>  .then(x =&gt; x.data)<br/>  .then(data =&gt; console.log('our data'))<br/>  .catch(error =&gt; console.error('some error happened', error));</pre>
<p>This version feels familiar. If you need to brush up on Promises, have a look at the following link before continuing: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</a>.  We recognize the <kbd>.then()</kbd> method as the method that is called when the data arrives and the <kbd>.catch()</kbd> method that is called when something goes wrong with our request. This is what we expect when, dealing with promises.</p>
<ul>
<li><strong>Using RxJS</strong></li>
</ul>
<pre>// calling http.get() and gets an Observable back<br/>http<br/>  .get('url')<br/>  .map( x =&gt; x.data ) <br/>  .subscribe( data =&gt; console.log('our data', data))<br/>  .catch( error =&gt; console.error('some error happened', error))</pre>
<p>The second version looks different. Here, we are using the <kbd>.map()</kbd> method in much the same way as we used the <kbd>.then()</kbd> method. This statement needs some explanation. Let's have a look at the promise flavor code one more time and highlight what we are saying:</p>
<pre>http<br/>  .get('url')<br/>  .toPromise()<br/>  <strong>.then(x =&gt; x.data)</strong><br/>  .then(data =&gt; console.log('our data'))<br/>  .catch(error =&gt; console.error('some error happened', error));</pre>
<p>The highlighted portion is the method that is called when the data first arrives from the service. What we do inside of this call is to create a projection of the data, like so: </p>
<pre><strong>.then(x =&gt; x.data)</strong></pre>
<p>The subsequent call to <kbd>then()</kbd> just deals with printing the data to the console:</p>
<pre>.then(data =&gt; console.log('our data'))</pre>
<p>Let's now have a look at how the RxJS version differs by highlighting the projection part and the part where we print out our result:</p>
<pre>http<br/>  .get('url')<br/>  <strong>.map( x =&gt; x.data )</strong> <br/>  .<strong>subscribe( data =&gt; console.log('our data', data) )</strong><br/>  .catch( error =&gt; console.error('some error happened', error) )</pre>
<p>The first line of our <span>highlighted</span> portion of the code indicates our projection:</p>
<pre><strong>.map( x =&gt; x.data )</strong></pre>
<p>The call to subscribe is where we print our data, like so:</p>
<pre>.subscribe( data =&gt; console.log('our data', data) )</pre>
<p>When we use <kbd>http.get()</kbd>, we get a construct back called an Observable. An Observable is just like the Promise, an asynchronous concept that enables us to attach callbacks to when the data arrives some time in the future, as well as attaching callbacks to when an error happens.</p>
<p><span>The Observable is part of a library called RxJS and this is what is powering the <kbd>HttpClient</kbd> service. It is a powerful library meant for more than just a simple request/response pattern. We will spend future chapters exploring the RxJS library </span><span>further</span><span> </span><span>and discover what a powerful paradigm the Observable really is, what other important concepts it brings, and the fact that it isn't really only about working with HTTP anymore, but all async concepts.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We started this chapter by trying to explain how important it was to get a good foundation in application architecture in general, and for that reason we had a look at the MVC pattern. We then continued describing how the MVC pattern was somewhat used in Angular, even though it was called MVW, model view whatever. We did this to understand that the Angular framework consists of a lot of constructs that help us organize our application in a way that makes it easy to extend, maintain, and parallelize the work.</p>
<p>Angular brought a lot of new things to it though, such as ES2015 modules, which attempted to solve the problem of how to split up the code in a manageable way. After that, we argued that although ES2015 modules were great, there was a lot of ceremony attached to them when it came to creating complex objects. To help relieve us of that ceremony, we described how Angular Dependency Injection could be the solution to said problem. In reality, you will use ES2015 to import your constructs. What Angular DI helps us with is creating the dependencies needed for our constructs.</p>
<p>Lastly, we tied the knot of explaining the MVC pattern by simply stating that data doesn't really live permanently, in either the model, the controller, or the view, but can be retrieved and persisted by talking to an endpoint, reachable through HTTP. We concluded the chapter by describing how the Angular 4.x HTTP service can help us with just that.</p>
<p>All of this is interesting from an educational standpoint. It doesn't describe the elephant in the room, how do we manage our data when things gets complicated? The concerns we have to deal with are:</p>
<ul>
<li>Bidirectional data flow</li>
<li>Lack of predictability (a change can lead to cascading changes)</li>
<li>Spread out state (there is no one source of truth and our components can sit on a state that is partially updated)</li>
</ul>
<p>Let's keep these concerns in mind as we move on to <a href="81d377c1-aafe-4eff-a7cd-a1b64629454c.xhtml">Chapter 2</a>, <em>1.21 Gigawatt – The Flux Pattern Explained</em>.</p>


            </article>

            
        </section>
    </body></html>