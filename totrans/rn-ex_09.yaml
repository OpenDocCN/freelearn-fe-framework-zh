- en: Additional React Native Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, we touched on a lot of React Native SDKs. However, there
    were some components where their additions didn't fit with the apps we built.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover some of them so that you will gain some extended
    practice with the React Native framework. You will learn to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a playground application where we will add components and parts of the
    React Native API that we did not get to work with in the prior projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Fetch API to make network calls to a third-party resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize the Vibration API to physically vibrate the user's phone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make use of the Linking API have your app open a third-party app with a registered
    link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a slider that can slide around to set a value between a defined minimum
    and maximum number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use the Action sheet and Share sheet in iOS to share details from
    your app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtain a user's location data with the Geolocation polyfill
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, the end of this chapter includes a tutorial on how we would build
    `Expenses` in [Chapter 4](94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml), *Advanced
    Functionality with the Expenses App* for Android.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a boilerplate project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the React Native command-line tools, I created a project titled `AdditionalComponents`.
    In it, the structure is a lot more simplified than our previous projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In each platform-specific index file at the root of the project, it imports
    an `App` component from our `app` folder and registers it to `AppRegistry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will be using the `index.js` file found in the `app` folder to contain the
    code for the examples that we'll be building.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this step, we have an `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we have a file that holds our styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Making Fetch happen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we will do is make a request to a third-party API during the
    `componentDidMount` life cycle. Our intention is to grab a set of JSON data from
    that API and use it to populate the `Picker` component that we'll be creating
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The third-party API that I will be using is a nifty one that produces JSON placeholder
    data--[https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'To grab data from this third-party API, we''ll be using the `fetch` API. `fetch`
    is a JavaScript API that does not need to be specifically imported into our file.
    It returns a promise that contains a response. If we want to use promises, we
    can call `fetch` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also call `fetch` using the `async`/`await` keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first argument that `fetch` accepts is the API `endpoint`. The second is
    an optional `object`. By default, `fetch` assumes that you are making a `GET`
    request. In order to make a `POST`, you will have to pass in this object with
    the `POST` property as a string to a key titled `method`. This object can also
    accept any headers you wish to include along with all other parameters to be sent
    in your request.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, an object can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In your `App` component, let''s create a `componentDidMount` life cycle event
    to fetch data from our `JSONPlaceholder` API using the following `endpoint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When data is fetched, go ahead and save it to your component''s `state` and
    log it in the `console` to show that it''s been populated. The code you write
    may end up looking like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is all you need to do to make a `GET` request from an `endpoint` using
    `fetch` in your React Native apps! Next up, we will use the `Vibration` API to
    send a vibration to the user's device whenever our `fetch` function successfully
    resolves.
  prefs: []
  type: TYPE_NORMAL
- en: Vibration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Vibration` API allows us to tap into the vibration motor for our user's
    mobile devices and send a vibration to it.
  prefs: []
  type: TYPE_NORMAL
- en: This demo will require the use of actual hardware to test, but it is worth the
    setup if you have one to play with. On devices that don't support vibration, including
    the simulator, there will be no effect.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of caveats to using the Vibration API that you should be
    aware of.
  prefs: []
  type: TYPE_NORMAL
- en: From a user experience standpoint, the use of vibration in your apps should
    be as a feedback mechanism to let your users know that some sort of interaction
    has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, extended use of the vibration motor on a user's phone will lead
    to larger stress on their device's battery performance.
  prefs: []
  type: TYPE_NORMAL
- en: It's very easy to abuse this API and include vibrations on all aspects of your
    app, but I would heavily recommend that this feature is reserved to acknowledge
    key interactions that a user may have with your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also has access to two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method is `Vibration.vibrate()`, which accepts two arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first is either a number or an array of numbers. The number (or numbers)
    is considered the pattern for which vibrations occur.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If a number is passed, an Android device will behave by vibrating for that number
    of milliseconds. On iOS, it will always result in a 1 vibration.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If an array of numbers is passed to this function, the vibration motor will
    follow a different pattern. An Android device will wait the number of milliseconds
    equal to the first index, and then vibrate a number of milliseconds equal to the
    second index. This pattern where the vibration motor switches between wait and
    vibrate continues for the length of the array.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, an array of `[100, 200, 300, 400]` means that the Android device
    will wait for `100` milliseconds, then vibrate for `200` milliseconds, followed
    by waiting `300` milliseconds before finally vibrating for `400` milliseconds.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The vibration motor's behavior on iOS is different. Rather than alternating
    between waiting and vibrating based on each index, the iOS functionality will
    always vibrate for a fixed one-second interval and wait between vibrations based
    on the next number in the array. Additionally, iOS ignores the first index of
    the array if it is set to zero.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, an array of `[0, 100, 200, 300]` means that the iOS device will
    skip that first index and vibrate for 1 second, then wait `100` milliseconds before
    vibrating for another second. After that, it waits `200` milliseconds and then
    vibrates for 1 second again. Finally, it waits `300` milliseconds after that vibration
    and then vibrates one final time for 1 second.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument that `Vibration.vibrate()` accepts is a Boolean that tells
    the motor whether to restart the vibration pattern once it completes (indefinitely)
    or to stop after one iteration.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second method is `Vibration.cancel()`, which cancels the vibration that
    is currently in place. This is important to build in if you're setting the repeat
    Boolean to `true` in your `vibrate` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, for Android devices, you will need to add the following line
    to your `AndroidManifest.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, let''s create a callback that is fired when data becomes available
    for the `Picker` to access and vibrates the device a few times. This is the code
    that I came up with; yours may be similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is simple and straightforward! In the next section, we will look at how to
    open a link to another installed app on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Linking apps with a button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deep linking allows us to interact with incoming and outgoing links to and from
    other apps. By creating a deep link for your app, you can enable other apps to
    talk to it directly and pass arguments to it, if desired.
  prefs: []
  type: TYPE_NORMAL
- en: You can also access other apps' deep links, opening them with custom arguments.
    In this chapter, we will learn how to access other apps using their deep links.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a `Button` component that, on press, finds out whether Facebook
    is installed on the user's device and if it is, launches the app and tells it
    to open the Notifications page. If Facebook is not installed, it will open the
    React Native documentation on the device's default browser.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that you can call Linking as part of any callback you
    wish. It does not have to be tied to the `Button` component at all!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the two methods that we will use with `Linking`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`canOpenURL`: This is a function that accepts a URL as an argument. It returns
    a promise containing a Boolean as its result, stating whether or not the URL you
    provided can be opened. This URL can either be a deep link to another application
    or a web-based URL to open a web page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openURL`: This is a method that also accepts a URL as an argument and attempts
    to open it with an installed app. This method fails if your user''s device does
    not know how to open the URL passed, which is why it''s best to use `canOpenURL`
    to first check for the ability to open it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On iOS devices, we need to tweak the Xcode project file a bit to allow `Linking`
    to open custom URL schemes. First, we need to link the React Native `Linking`
    binary with our project. Open your project in Xcode and then, in the left-hand
    navigator, expand the `Libraries` folder, then `RCTLinking.xcodeproj` within it,
    followed by the `Products` folder within that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_001-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go back to the root project file for `AdditionalComponents`, into Build Phases,
    and drag the libRCTLinking.a file under Link Binary With Libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_002-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Afterward, head over to the Build Settings tab and add an entry to the Header
    Search Paths array pointing to the `Linking` library. For this specific project,
    the path is `$(SRCROOT)/../node_modules/react-native/Linking`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can keep the search non-recursive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_003.png)'
  prefs: []
  type: TYPE_IMG
- en: There's one last step to perform. As of iOS 9, we have to register our intent
    to access Facebook's URL scheme within the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `Info.plist` file in the sidebar and create an array entry called
    `LSApplicationQueriesSchemes`. Add a string to this array with the value of the
    URL scheme you wish to access. Facebook''s URL scheme is simply `fb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_004.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you have completed this, your app should be linked to iOS!
  prefs: []
  type: TYPE_NORMAL
- en: On Android, no further action is necessary; you should already have access to
    other URL schemes by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this knowledge, let''s create a `Button` component that launches either
    the Facebook app, if installed, or links to the React Native documentation on
    the user''s device, if it isn''t. Here''s how I wrote it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Button` component in our `render` method fires the `_onButtonPress` callback
    when pressed. It checks the `Linking` API to check whether the Facebook app can
    be opened on the device, and if so, opens it. If not, it will open a link to the
    React Native documentation website in the device's default browser.
  prefs: []
  type: TYPE_NORMAL
- en: Slider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sliders are common UI components found on the Web. In this section, you will
    see how easy it is to create one in your React Native applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'While `Slider` has access to at least nine different props, we will use just
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`maximumValue`: This is a number that sets the starting maximum value of the
    `Slider`. It defaults to `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minimumValue`: This is a number that sets the starting minimum value of the
    `Slider`. It defaults to `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSlidingComplete`: This is a callback that is fired when the user finishes
    interacting with the `Slider`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onValueChange`: This is a callback that is fired continuously as the user
    is dragging the `Slider`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step`: This is a number that sets the step value of the slider. Each tick
    of the `Slider` moves it by this number of steps. It defaults to `0` and ranges
    between `0` and the difference between the maximum value and minimum value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a moment to create a `Slider` component. Give it any minimum and maximum
    values you like, any step count, and create some text that shows the current value
    of the slider whenever either movement happens or interaction stops. This is how
    I implemented it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This renders a new `Slider` component on the page with a value range from `0`
    to `100`. It changes the value of the `Slider` whenever the user is either in
    the process of dragging the slider or has completed the dragging action. Each
    movement of the slider increases the value by `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This callback handles setting the `sliderValue` property in state. The code
    for the `sliderValue` property is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using ActionSheetIOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ActionSheetIOS` API lets us display either an action sheet or share sheet
    for the user to interact with.
  prefs: []
  type: TYPE_NORMAL
- en: The action sheet is an overlay of options that the user can interact with in
    the app.
  prefs: []
  type: TYPE_NORMAL
- en: The Share sheet allows the user to share almost anything, anywhere, using the
    built-in sharing system. This could mean sending content in the form of a text
    message, e-mail, or to a third-party app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an action sheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two methods that `ActionSheetIOS` makes available are `showActionSheetWithOptions`
    and `showShareActionSheetWithOptions`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method, `showActionSheetWithOptions`, accepts two arguments: an `options`
    object and a `callback` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `options` object must contain at least one of the following properties.
    We use all five in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`options`: This is an array of strings that map to the multiple options that
    appear in the overlay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cancelButtonIndex`: This is a number that points to the `index` where the
    Cancel button, if it exists, is located in the `options` array. This sends the
    Cancel button to the very bottom of the overlay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`destructiveButtonIndex`: This is a number that points to the `index` where
    a destructive button, if it exists, is located in the `options` array. This turns
    the color of the destructive option''s text to red.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: This is a string that shows above the action sheet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: This is a string that shows right below the title.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The callback that `showActionSheetWithOptions` takes in will have one argument
    passed to it, which is the index of the option that is selected by the user when
    the action sheet is interacted with. If the user taps outside the action sheet
    in order to hide it, it has the exact same effect as if the Cancel button''s index
    were selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_005.png)'
  prefs: []
  type: TYPE_IMG
- en: Try creating an action sheet of your own. Have some sort of interaction to toggle
    it, followed by any sort of interaction you can think of when an index is selected.
    Make sure to give your action sheet a `title`, `message`, some `options`, a `cancel`
    index, and a `destructive` index.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code I came up with. Call a function to render the `ActionSheetIOS`
    and `ShareSheetIOS` components. I added the reference to `ShareSheetIOS` in the
    function name in anticipation of the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alert the selected index of the `ActionSheetIOS` component to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `ActionSheetIOS` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t render anything if the user is on an Android device, since these components
    are iOS-exclusive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Return a `Button` that calls `_openActionSheet` when pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Sharing content with ShareSheetIOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The share sheet, on the other hand, is a different type of interaction. As
    I mentioned earlier, the Share sheet lets our app share content with it. To open
    it, we call `showShareActionSheetWithOptions`. It accepts three arguments: an
    `options` object, a `failureCallback` function, and a `successCallback` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Share sheet''s `options` object is different from the one that the action
    sheet accepted. It can contain the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`url`: This is a stringified URL to share. The `url` property is required if
    the message property is not available. The url can point to a local file or base-64
    encoded `url`; it can share images, videos, PDFs, and other types of files this
    way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: This is a string that contains a message for the user to share.
    The message property is required if the `url` property is not available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subject`: This is a string that contains a subject for the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `failureCallback` is fired when a Share sheet action fails or is canceled
    by the user, while the `successCallback` is fired when a Share sheet action is
    successfully carried through by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s modify the index file to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify `_renderActionAndShareSheets` to return a second button, directly underneath
    the first, that will open the ShareSheet when tapped on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a function, called `_openShareSheet`, to handle the opening of that Share
    sheet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how my version came about. Call the `showShareActionSheetWithOptions`
    method of `ActionSheetIOS`, giving it a link to open and a message to share, along
    with a `subject` and `error`/`success` callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Grabbing user geolocation data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Geolocation` API for React Native is an extension of the `Web Geolocation`
    API. It's available by calling `navigator.geolocation` and does not need to be
    imported.
  prefs: []
  type: TYPE_NORMAL
- en: Location data is a very important part of the mobile experience and as a best
    practice, this data should not be requested from your users until there is an
    explicit benefit for the user to provide the said information.
  prefs: []
  type: TYPE_NORMAL
- en: As location data is private until the user consents to share it with you, treat
    the sharing of this information as a bond of trust between the user and your app.
  prefs: []
  type: TYPE_NORMAL
- en: Always make the assumption that your users will select No when asked to share
    their location, and devise a strategy for how to handle that rejection when it
    inevitably happens.
  prefs: []
  type: TYPE_NORMAL
- en: On iOS, if you created your project using React Native in it, Geolocation will
    be enabled by default. If not, you will need to go to your `Info.plist` file and
    add the `NSLocationWhenInUsageDescription` key to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Android devices, you will need to add the following line to the `AndroidManifest.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Geolocation` API has access to four different methods. These are the three
    we will be covering in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getCurrentPosition`: This is a function that gets the current location of
    the device. It accepts up to three arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first, a `success` callback, is mandatory and is called with the current
    location information.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second, an `error` callback, is optional.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third is an optional options array that can contain the following supported
    options: `timeout` (in milliseconds), `maximumAge` (in milliseconds), and `enableHighAccuracy`
    (a Boolean).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`watchPosition`: This is a function that watches the device''s location and
    returns a watch ID number. It accepts up to three arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first is a mandatory `success` callback that is fired whenever the location
    changes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is an optional callback to handle errors.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The third is another optional options object that can contain the `timeout`,
    `maximumAge`, and `enableHighAccuracy` properties with the same types as the options
    object of `getCurrentPosition` as well as a `distanceFilter` property that accepts
    a number in meters.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clearWatch`: This is a function that accepts a watch ID number and stops watching
    that position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a sample of the current location object that the `Geolocation` API
    returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `Geolocation` API, let''s modify the index file so that we can do
    the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Grab the user's location during the `componentDidMount` life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show their latitude and longitude on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, create a button that watches the device's location and updates
    it whenever it changes on press
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, create a button that clears it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code that I wrote for this section. Make a call to the `getCurrentPosition`
    method of the `Geolocation` API during the `componentDidMount` life cycle, saving
    the location to state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Render the latitude and longitude of the user in `Text` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Render one button to start and another to stop the watch process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the location of the user when they begin watching their position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the ID of the `watchPosition` call to state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `clearWatch` when the user presses the Cancel Watching Position button
    and erase the `watchID` in state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Great job! You finished the playground section of this chapter. In the next
    section, we will switch gears and revisit the `Expenses` app from [Chapter 4](94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml),
    *Advanced Functionality with the Expenses App*.
  prefs: []
  type: TYPE_NORMAL
- en: Expenses for Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml), *Advanced Functionality
    with the Expenses App*, we completed building the iOS version of Expenses, our
    budget tracking application. Due to the page count of the chapter, I thought it
    would be best to place the Android portion at the end of this chapter instead.
  prefs: []
  type: TYPE_NORMAL
- en: This section picks up immediately from where we left off at the end of [*Chapter
    4*](94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml), *Advanced Functionality with
    the Expenses App*.
  prefs: []
  type: TYPE_NORMAL
- en: An example code for the Android version of Expenses can still be found in the
    code repository for [*Chapter 4*](94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml),
    *Advanced Functionality with the Expenses App*.
  prefs: []
  type: TYPE_NORMAL
- en: Android modifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Android support, we want to do the following things to our code base:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `react-native-vector-icons` library via Gradle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swap out the `TabBarIOS` component for an Android-based solution using the `DrawerLayoutAndroid`
    and `ToolbarAndroid` components to create a navigation bar that contains a drawer
    that slides out to toggle between the current and previous months' expenses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace any `NavigatorIOS` instances with `Navigator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove `ProgressViewIOS`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the `ExpandableCell` components in `AddExpensesModal` and replace `DatePickerIOS`
    with `DatePickerAndroid`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add any Android-specific files to components that require them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the vector icon library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should not need to do anything extra to have the `react-native-vector-icons`
    library installed for Android since React Native link should have taken care of
    the entire process for you.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you decided to link the library manually for iOS, the readme file
    for `react-native-vector-icons` has the latest, up-to-date instructions for importing
    the library manually for Android devices. As these instructions can change with
    newer releases to the library, I heavily recommend you follow them directly from
    the `README` file.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have the package installed in your project's `node_modules` folder,
    you can read the instructions from there without requiring further Internet access.
  prefs: []
  type: TYPE_NORMAL
- en: The instructions on importing with Gradle are very straightforward. You will
    also want to follow the instructions for integrating the library for `getImageSource`
    and `ToolbarAndroid` support.
  prefs: []
  type: TYPE_NORMAL
- en: ToolbarAndroid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On Android, the preferred way to navigate the UI is through its top-placement
    toolbar. This differs from the iOS experience because rather than having all the
    available tabs at the bottom of the screen, navigation is hidden inside a drawer
    that the user taps to expose.
  prefs: []
  type: TYPE_NORMAL
- en: '`ToolbarAndroid` is a React Native, Android-specific component that wraps around
    the Android SDK''s native toolbar widget. Like `TabBarIOS`, we have access to
    a `react-native-vector-icons`-specific version of the component that we render
    by calling `<Icon.ToolbarAndroid />`. We will be using the following props when
    using `Icon.ToolbarAndroid` in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`: This is a string that is displayed at the top of the toolbar showing
    the name of the app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`titleColor`: This sets the color of the `title` string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`navIconName`: This is a string that sets the icon of the navigation menu in
    the toolbar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height`: This is a number to set the height of the toolbar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backgroundColor`: This sets the background color of the toolbar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onIconClicked`: This is a callback that is executed when the navigation icon
    is tapped on by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, you may have noted that there's no room for the actual `Navigation`
    drawer that this Navigation icon traditionally opens. That's because we will use
    `Icon.ToolbarAndroid` in conjunction with `DrawerLayoutAndroid`, the component
    that handles the actual navigation drawer.
  prefs: []
  type: TYPE_NORMAL
- en: DrawerLayoutAndroid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This component is typically used for navigation. Think of this as the place
    where the tabs in TabBarIOS will be made available.
  prefs: []
  type: TYPE_NORMAL
- en: The `DrawerLayoutAndroid` component has access to the `openDrawer` and `closeDrawer`
    methods responsible for its visibility. To use it, pass a ref to the component
    and use it to call either method.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this component has many props available to it, we will be using just
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`drawerLockMode`: This is one of the three strings that determine whether the
    drawer responds to touch gestures, such as sliding the drawer open/closed. This
    does not disable the toolbar''s navigation icon from opening and closing the drawer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unlocked`: the drawer responds to touch gestures'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`locked-closed`: the drawer stays closed and does not respond to touch gestures'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`locked-open`: the drawer stays open and does not respond to touch gestures'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ref`: This is a reference string to pass to the drawer. This is so that we
    can reference the drawer within its child components, which will be necessary
    to open and close it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`renderNavigationView`: This is a function responsible for the rendering of
    your drawer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting ToolbarAndroid and DrawerLayoutAndroid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way we connect these two components together is to start by writing an
    `Icon.ToolbarAndroid` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a `DrawerLayoutAndroid` component and wrap it around two children:
    the `Icon.ToolbarAndroid` component you just created along with the `Navigator`
    following it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When integrating the three components, we want to ensure that the following
    is always true:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DrawerLayoutAndroid` is always positioned above everything else so that the
    drawer doesn''t get tucked underneath `Icon.ToolbarAndroid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using the options of `DrawerLayoutAndroid` to navigate from one view to
    another, the same instance of `Icon.ToolbarAndroid` should be present so that
    we are not rendering a whole new `Icon.ToolbarAndroid` component every single
    time, nor will it contain an animation of the said toolbar ever *leaving* the
    screen to be replaced by *another*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we'll do here is nest `Icon.ToolbarAndroid` and `Navigator` within `DrawerLayoutAndroid`,
    and set a `ref` for `Navigator` so that we can use that `Navigator` to push new
    scenes into the app, as needed within our root file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have implemented both the `Icon.ToolbarAndroid` and `DrawerLayoutAndroid`
    components, you will be able to have in-app navigation that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_007-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is how the big picture looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: These are the four components that this index file will work with. The `App`,
    `EnterBudget`, and `PreviousMonthsList` components will be part of our navigation
    routes. The `Drawer` component is used to render the navigation view for `DrawerLayoutAndroid`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As Android software has a different design language from iOS apps, I imported
    the `MaterialIcons` pack instead of `FontAwesome` since it''s built with Google''s
    Material Design guidelines in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A property titled `expenses` is set to be undefined. This is to pass over to
    `PreviousMonthsList` since it expects the list of expenses as a prop.
  prefs: []
  type: TYPE_NORMAL
- en: Visible routes are passed to the `Drawer` component. I purposefully omit the
    route that handles entering a budget for the month because it isn't one that the
    user should be able to manually navigate to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WillMount` component life cycle, I call the `_updateExpenses` method
    to set the `expenses` key in state to the expenses object. Check out the code
    for the explanation given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `DrawerLayoutAndroid` component, I am nesting both `Icon.ToolbarAndroid`
    and `Navigator`. Like I mentioned earlier, this is to physically place the drawer
    on a layer above the rest of the app. Check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Having given `DrawerLayoutAndroid` a ref of `drawer` earlier, I can use it to
    open the drawer when the navigation icon is tapped on by the user. I also gave
    `Navigator` a ref of `navigator` so that I can push to it at the root `index.android.js`
    level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DrawerLayoutAndroid` component''s `render` method returns this `Drawer`
    component that I import from a custom component I wrote. I pass it a callback
    under the prop name of `navigateTo`, whose function pushes the index of the `navigator`
    and closes `DrawerLayoutAndroid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The rendering of `PreviousMonthsList` with `_renderScene` is configured to pass
    in the `expenses` object and `updateExpenses` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_updateExpenses` function passed into `PreviousMonthsList` as the prop
    titled `updateExpenses` is a modified version of the `_updateExpenses` function
    found in the `App` component. We only care about the `expenses` object in this
    component, so we will not bother setting any other data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, I built the `Drawer` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `DrawerRow` component that `Drawer` imports is responsible for rendering
    individual rows of data for the `ListView` component of  `Drawer`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `render` method of `Drawer` returns a simple `ListView` that uses the routes
    array passed to it as a prop to generate each row of data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, I created a basic `StyleSheet` for this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, I wrote the `DrawerRow` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `DrawerRow` is a custom component and the `TouchableHighlight` component
    that wraps around it from the `_renderDrawerRow` method of the `Drawer` component
    does not call `setNativeProps` for user-created components automatically, I manually
    called it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DrawerRow` component also has its own `StyleSheet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Android-specific app component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, I created an Android-specific version of `App.js`, renaming the original
    `App.ios.js`. Only two components are imported to `App.android.js` because any
    components being navigated to are handled in the root `index.android.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The state of the `App` component does not need a `selectedTab` property since
    we are not using tabbed navigation on Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'There are no changes to `componentWillMount` from its iOS counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result of removing tabbed navigation, the `render` method of this component
    has been simplified to just render the `CurrentMonthExpenses` and `AddExpenses`
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `componentWillMount`, `_renderCurrentMonthExpenses` has retained the exact
    same logic from the iOS version of the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_renderEditBudgetComponent` method has been changed to account for how
    `Navigator` handles its `push` method differently from the `push` method of `NavigatorIOS`
    as mentioned in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'While the iOS App component''s `_renderPreviousMonthsList` method has been
    removed on Android, the logic for `_saveAndUpdateBudget`, `_updateBudget`, and
    `_updateExpenses` remains the same, as mentioned in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, I added a simple `flex` container style for the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: EnterBudget styling changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Android text fields normally do not contain a border, I used some conditional
    logic with the `Platform` API to remove it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The styling for the `TextInput` component in the `render` method of `EnterBudget`
    now checks to see whether the user's operating system is iOS or Android. If it
    is iOS, it keeps the original `textInput` style from before; if it is Android,
    it sets it to a new `androidTextInput` style.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we will make some changes to `CurrentMonthExpenses`.
  prefs: []
  type: TYPE_NORMAL
- en: CurrentMonthExpenses for Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `CurrentMonthExpenses` component, I am rendering a `ProgressViewIOS`
    component that visually tracks the amount spent by the user using a colored, horizontal
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: The React Native SDK for Android has a similar component, `ProgressBarAndroid`,
    and we will swap out `ProgressViewIOS` for it.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we want to add a back button event listener for this component
    that is only fired when the user navigates to `CurrentMonthExpenses` by way of
    `PreviousMonthsList` with `BackAndroid`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProgressBarAndroid` component is similar to `ProgressViewIOS`. I''m using
    the following props in mine:'
  prefs: []
  type: TYPE_NORMAL
- en: '`color`: This determines the color of `ProgressBarAndroid`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indeterminate`: This is a Boolean that, when set to true, keeps the progress
    bar animated indefinitely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`progress`: Just like `ProgressViewIOS`, this determines how far along the
    progress bar should move.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`styleAttr`: This is a string to tell how `ProgressBarAndroid` should be rendered.
    For mine, I used `horizontal`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `render` method for `CurrentMonthExpenses` now calls a `_renderProgressIndicator`
    method to determine which progress indicator to render: `ProgressViewIOS` is to
    be rendered for iOS devices, and `ProgressBarAndroid` for Android ones.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ListView` is now wrapped around a `View` to give it some separation from
    the progress indicator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'I am only calling `pop` on the `navigator` if it is a previous month''s data
    the user is looking at. Otherwise, they will run into an error when attempting
    to call `pop` without any other routes visited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'There have been no changes to the iOS progress indicator logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The Android progress indicator is returned at the end of the function. I am
    reusing the `_getProgressViewAmount` method here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: No other code for this component was changed, and its Android-specific version
    was not necessary because of the minimal changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The styling for `CurrentMonthExpenses` has been changed to add the `listViewContainer`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Removing ExpandableCell from AddExpensesModal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the `DatePickerAndroid` and `Picker` components render as a modal on an Android
    device, I made some modifications to the `AddExpensesModal` component to remove
    the instances of `ExpandableCell`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This resulted in a new Android-specific file because of the large number of
    changes. I removed the `categoryPickerExpanded` and `datePickerExpanded` properties
    in state, as well as the importing of `DatePickerIOS` and `ExpandableCell`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'These two constants previously started with the prefix of `expandableCell`,
    but that prefix has been removed since the `ExpandableCell` component is not being
    used in the Android version of this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onRequestClose` callback is a required prop for `Modal` components on
    Android. The callback is executed when the user presses the back button on an
    Android device while the modal is open. In this case, I perform the same action
    as if the user pressed the Cancel button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Android-specific styles for the two `TextInput` components were made to accommodate
    stylistic differences between Android and iOS applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `View` that was previously styled to `expandableCellContainer` have been
    changed to `androidPickerContainers`. The preceding `Button` component calls `_renderDatePicker`
    when pressed, which handles the rendering of `DatePickerAndroid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the regular `Picker` component is not opened with an asynchronous function
    like `DatePickerAndroid`, I kept its logic intact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_clearFieldsAndCloseModal` method was modified to remove the setting of
    the now-removed `ExpandableCell`-specific properties in state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Finally, `_renderDatePicker` was created to handle the asynchronous nature of
    the `DatePickerAndroid` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Android version of the `AddExpensesModal` component, none of the iOS
    version''s methods were removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Modifying Navigation for PreviousMonthsList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing to do is modify the `push` method of `navigator` for Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: I made a styling adjustment for the `View` container that wraps around the rest
    of `PreviousMonthsList` for Android devices to keep the `ListView` just below
    the navigation bar on Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'There have been no changes to the original rendering method if on iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The Android method pushes to an `index` instead of a component, and the props
    passed to it are the exact same ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: After this section, we have successfully converted `Expenses` into an Android
    app that looks, feels, and behaves just like one!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! You've finished the final chapter of *React Native by Example*.
    In this chapter, you learned to use more of the React Native library by working
    on components and APIs that we did not fit into previous apps in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, you built a playground app where you learned how to use the `fetch`
    API to make requests to external resources for data and gained control of the
    `Vibration` API to control the vibration motor of a user's device.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, you used the `Linking` API to open third-party applications on both
    iOS and Android, which allowed your app to talk to others. Then, you built a `Slider`
    component that lets users select a value between two predetermined ones.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the playground app, you created `Buttons` to open an `ActionSheetIOS`
    overlay that presents options for your users to interact with and allowed your
    users to share content from your app using the Share sheet. As a finishing touch,
    you made use of the `Geolocation` API to grab your user's location data.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, we converted the app to Android. We started by ensuring
    that the vector icon library was imported via Gradle, swapped out the iOS-specific
    tabbed navigation for Android's drawer and toolbar combination, replaced `NavigatorIOS`-specific
    logic with `Navigator`, replaced the progress indicator with an Android-specific
    one, and then tweaked the rest of our components to have the look and feel of
    an Android app.
  prefs: []
  type: TYPE_NORMAL
