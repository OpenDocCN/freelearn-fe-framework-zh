<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" style="font-size:1.200rem;">
<head><title>Chapter&#160;1.&#160;Introducing Web Components</title>
<link rel="stylesheet" href="../Styles/style0001.css" type="text/css"/>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
</head>
<body id="page">
<div class="chapter" title="Chapter&#160;1.&#160;Introducing Web Components" id="aid-DB7S1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"></a>Chapter&#160;1.&#160;Introducing Web Components</h1>
</div>
</div>
</div>
<p>In this chapter, we will learn about the web component specification in detail. Web component is changing the web application development process. It comes with standard and technical features, such as templates, custom elements, Shadow DOM, and HTML Imports.</p>
<p>The main topics that we will cover in this chapter about web component specification are as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">What are web components?</li>
<li class="listitem">Benefits and challenges of web components</li>
<li class="listitem">The web component architecture</li>
<li class="listitem">Template element</li>
<li class="listitem">HTML Import</li>
<li class="listitem">Shadow DOM</li>
<li class="listitem">Custom elements</li>
<li class="listitem">Building a digital clock component</li>
<li class="listitem">The X-Tag library</li>
<li class="listitem">web component libraries</li>
</ul>
</div>
<div class="section" title="What are web components?"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"></a>What are web components?</h1>
</div>
</div>
</div>
<p>Web components<a id="id0" class="indexterm"></a> are a W3C specification to build a standalone component for web applications. It helps developers leverage the development process to build reusable and reliable widgets. A web application can be developed in various ways, such as page focus development and navigation-based development, where the developer writes the code based on the requirement. All of these approaches fulfil the present needs of the application, but may fail in the reusability perspective. This problem leads to component-based development.</p>
</div>
</div>


<div class="section" title="Benefits and challenges of web components" id="aid-E9OE1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"></a>Benefits and challenges of web components</h1>
</div>
</div>
</div>
<p>There are many<a id="id1" class="indexterm"></a> benefits of web components:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A web component can be used in multiple applications. It provides interoperability between frameworks, developing the web component ecosystem. This makes it <span class="emphasis"><em>reusable</em></span>.</li>
<li class="listitem">A web component has a template that can be used to put the entire markup separately, making it more <span class="emphasis"><em>maintainable</em></span>.</li>
<li class="listitem">As web components are developed using HTML, CSS, and JavaScript, it can run on different browsers. This makes it <span class="emphasis"><em>platform independent</em></span>.</li>
<li class="listitem">Shadow DOM provides <span class="emphasis"><em>encapsulation mechanism</em></span> to style, script, and HTML markup. This encapsulation mechanism provides <a id="id2" class="indexterm"></a><span class="strong"><strong>private scope</strong></span> and prevents the content of the component being affected by the external document.</li>
</ul>
</div>
<p>Equally, some of the<a id="id3" class="indexterm"></a> challenges for a web component include:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Implementation</strong></span>: The W3C web component specification is very new to the browser technology and not completely implemented by the browsers.</li>
<li class="listitem"><span class="strong"><strong>Shared resource</strong></span>: A web component has its own scoped resources. There may be cases where some of the resources between the components are common.</li>
<li class="listitem"><span class="strong"><strong>Performance</strong></span>: Increase in the number of web components takes more time to get used inside the DOM.</li>
<li class="listitem"><span class="strong"><strong>Polyfill size</strong></span>: The polyfill are a workaround for a feature that is not currently implemented by the browsers. These polyfill files have a large memory foot print.</li>
<li class="listitem"><span class="strong"><strong>SEO</strong></span>: As the HTML markup present inside the template is inert, it creates problems in the search engine for the indexing of web pages.</li>
</ul>
</div>
</div>


<div class="section" title="The web component architecture" id="aid-F8901"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"></a>The web component architecture</h1>
</div>
</div>
</div>
<p>The <a id="id4" class="indexterm"></a>W3C web component specification has four main building blocks for component development. Web component development is made possible by template, HTML Imports, Shadow DOM, and custom elements and decorators. However, decorators do not have a proper specification at present, which results in the four pillars of web component paradigm. The following diagram shows the building blocks of web component:</p>
<div class="mediaobject"><img src="../Images/image00197.jpeg" alt="The web component architecture"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>These four pieces of technology power a web component that can be reusable across the application. In the <a id="id5" class="indexterm"></a>coming section, we will explore these features in detail and understand how they help us in web component development.</p>
</div>


<div class="section" title="Template element"><div class="titlepage" id="aid-G6PI2"><div><div><h1 class="title"><a id="ch01lvl1sec11"></a>Template element</h1>
</div>
</div>
</div>
<p>The <a id="id6" class="indexterm"></a>HTML <code class="literal">&lt;template&gt;</code> element contains the HTML markup, style, and script, which can be used multiple times. The templating process is nothing new to a web developer. Handlebars, Mustache, and Dust are the templating libraries that are already present and heavily used for web application development. To streamline this process of template use, W3C web component specification has included the <code class="literal">&lt;template&gt;</code> element.</p>
<p>This template element is very new to web development, so it lacks features compared to the templating libraries such as Handlebars.js that are present in the market. In the near future, it will be equipped with new features, but, for now, let's explore the present template specification.</p>
<div class="section" title="Template element detail"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"></a>Template element detail</h2>
</div>
</div>
</div>
<p>The HTML <code class="literal">&lt;template&gt;</code> element<a id="id7" class="indexterm"></a> is an <code class="literal">HTMLTemplateElement</code> interface. The<a id="id8" class="indexterm"></a> <span class="strong"><strong>interface definition language</strong></span> (<span class="strong"><strong>IDL</strong></span>) definition of the template element is listed in the following code:</p>
<div class="informalexample"><pre class="programlisting">interface <span class="strong"><strong>HTMLTemplateElement : HTMLElement</strong></span> {
  readonly attribute <span class="strong"><strong>DocumentFragment content</strong></span>;
};</pre>
</div>
<p>The preceding<a id="id9" class="indexterm"></a> code is written in IDL language. This IDL language is used by the W3C for writing specification. Browsers that support HTML Import <a id="id10" class="indexterm"></a>must implement the aforementioned IDL. The details of the preceding code are listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">HTMLTemplateElement</code>: This <a id="id11" class="indexterm"></a>is the template interface and extends the <code class="literal">HTMLElement</code> class.</li>
<li class="listitem"><code class="literal">content</code>: This is<a id="id12" class="indexterm"></a> the only attribute of the HTML template element. It returns the content of the template and is read-only in nature.</li>
<li class="listitem"><code class="literal">DocumentFragment</code>: This is<a id="id13" class="indexterm"></a> a return type of the <code class="literal">content</code> attribute. <code class="literal">DocumentFragment</code> is a lightweight version of the document and does not have a parent.<div class="note" title="Note"><h3 class="title"><a id="note02"></a>Note</h3>
<p>To find out more about <a id="id14" class="indexterm"></a>
<code class="literal">DocumentFargment</code>, use the following link:</p>
<p>
<a class="ulink" href="https://developer.mozilla.org/en/docs/Web/API/DocumentFragment">https://developer.mozilla.org/en/docs/Web/API/DocumentFragment</a>
</p>
</div></li>
</ul>
</div>
</div>
<div class="section" title="Template feature detection"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"></a>Template feature detection</h2>
</div>
</div>
</div>
<p>The HTML <code class="literal">&lt;template&gt;</code> element <a id="id15" class="indexterm"></a>is very new to web application development and not completely implemented by all browsers. Before implementing the template element, we need to check the browser support. The JavaScript code for template support in a browser is listed in the following code:</p>
<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;
        Web Component: template support
    &lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 id="message"&gt;&lt;/h1&gt;
&lt;script&gt;
<span class="strong"><strong>    var isTemplateSupported = function () {</strong></span>
<span class="strong"><strong>        var template = document.createElement("template");</strong></span>
<span class="strong"><strong>        return 'content' in template;</strong></span>
<span class="strong"><strong>    };</strong></span>
<span class="strong"><strong>    var isSupported = isTemplateSupported(),</strong></span>
<span class="strong"><strong>            message = document.getElementById("message");</strong></span>
<span class="strong"><strong>    if (isSupported) {</strong></span>
<span class="strong"><strong>        message.innerHTML = "Template element is supported by the browser.";</strong></span>
<span class="strong"><strong>    } else {</strong></span>
<span class="strong"><strong>        message.innerHTML = "Template element is not supported by the browser.";</strong></span>
<span class="strong"><strong>    }</strong></span>
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>In the preceding code, the <code class="literal">isTemplateSupported</code> method checks the <code class="literal">content</code> property present inside the template element. If the <code class="literal">content</code> attribute is present inside the template element, this<a id="id16" class="indexterm"></a> method returns either <code class="literal">true</code> or <code class="literal">false</code>. If the template element is supported by the browser, the <code class="literal">h1</code> element will show the support message. The browser that is used to run the preceding code is Chrome 39 release. The output of the preceding code is shown in following screenshot:</p>
<div class="mediaobject"><img src="../Images/image00198.jpeg" alt="Template feature detection"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>The preceding screenshot shows that the browser used for development is supporting the HTML template element.</p>
<div class="note" title="Note"><h3 class="title"><a id="tip02"></a>Tip</h3>
<p>There is also a great online tool called <a id="id17" class="indexterm"></a>
<span class="strong"><strong>Can I Use</strong></span> for checking support for the template element in the current browser. To check out the template support in the browser, use the following link:</p>
<p>
<a class="ulink" href="http://caniuse.com/#feat=template">http://caniuse.com/#feat=template</a>
</p>
</div>
<p>The following<a id="id18" class="indexterm"></a> screenshot shows the current status of the support for the template element in the browsers using the <span class="strong"><strong>Can I Use</strong></span> online tool.</p>
<div class="mediaobject"><img src="../Images/image00199.jpeg" alt="Template feature detection"/></div>
<p style="clear:both; height: 1em;"> </p>
</div>
<div class="section" title="Inert template"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"></a>Inert template</h2>
</div>
</div>
</div>
<p>The HTML content<a id="id19" class="indexterm"></a> inside the template element is inert in nature until it is activated. The inertness of template content contributes to increasing the performance of the web application. The following code demonstrates the inertness of the template content:</p>
<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;
        Web Component: A inert template content example.
    &lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="message"&gt;&lt;/div&gt;
<span class="strong"><strong>&lt;template id="aTemplate"&gt;</strong></span>
<span class="strong"><strong>    &lt;img id="profileImage" src="http://www.gravatar.com/avatar/c6e6c57a2173fcbf2afdd5fe6786e92f. png"&gt;</strong></span>
<span class="strong"><strong>    &lt;script&gt;</strong></span>
<span class="strong"><strong>        alert("This is a script.");</strong></span>
<span class="strong"><strong>    &lt;/script&gt;</strong></span>
<span class="strong"><strong>&lt;/template&gt;</strong></span>
&lt;script&gt;
    (function(){
        var imageElement = document.getElementById("profileImage"),
            messageElement = <span class="strong"><strong>document.getElementById("message");</strong></span>
        messageElement.innerHTML = "IMG element "+imageElement;
    })();
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>In the preceding code, a <a id="id20" class="indexterm"></a>template contains an image element with the <code class="literal">src</code> attribute, pointing to a Gravatar profile image, and an inline JavaScript <code class="literal">alert</code> method. On page load, the <code class="literal">document.getElementById</code> method is looking for an HTML element with the <code class="literal">#profileImage</code> ID. The output of the preceding code is shown in the following screenshot:</p>
<div class="mediaobject"><img src="../Images/image00200.jpeg" alt="Inert template"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>The preceding<a id="id21" class="indexterm"></a> screenshot shows that the script is not able to find the HTML element with the <code class="literal">profileImage</code> ID and renders <code class="literal">null</code> in the browser. From the preceding screenshot it is evident that the content of the template is inert in nature.</p>
</div>
<div class="section" title="Activating a template"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"></a>Activating a template</h2>
</div>
</div>
</div>
<p>By default, the <a id="id22" class="indexterm"></a>content of the <code class="literal">&lt;template&gt;</code> element is inert and are not part of the DOM. The two different ways that can be used to activate the nodes are as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Cloning a node</li>
<li class="listitem">Importing a node</li>
</ul>
</div>
<div class="section" title="Cloning a node"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"></a>Cloning a node</h3>
</div>
</div>
</div>
<p>The<a id="id23" class="indexterm"></a> <code class="literal">cloneNode</code> method <a id="id24" class="indexterm"></a>can be used to duplicate a node. The syntax for the <code class="literal">cloneNode</code> method is listed as follows:</p>
<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&lt;Node&gt; &lt;target node&gt;.cloneNode(&lt;Boolean parameter&gt;)</strong></span>
</pre>
</div>
<p>The details<a id="id25" class="indexterm"></a> of the preceding code syntax are listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">This method can be applied on a node that needs to be cloned.</li>
<li class="listitem">The return type of this method is <code class="literal">Node</code>.</li>
<li class="listitem">The input parameter for this method is of the <code class="literal">Boolean</code> type and represents a type of cloning. There are 2 different types of cloning, listed as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Deep cloning</strong></span>: In <a id="id26" class="indexterm"></a>deep cloning, the children of the targeted node also get copied. To implement deep cloning, the <code class="literal">Boolean</code> input parameter to <code class="literal">cloneNode</code> method needs to be <code class="literal">true</code>.</li>
<li class="listitem"><span class="strong"><strong>Shallow cloning</strong></span>: In <a id="id27" class="indexterm"></a>shallow cloning, only the targeted node is copied without the children. To implement shallow cloning the <code class="literal">Boolean</code> input parameter to <code class="literal">cloneNode</code> method needs to be <code class="literal">false</code>.</li>
</ul>
</div></li>
</ul>
</div>
<p>The following code shows the use of the <code class="literal">cloneNode</code> method to copy the content of a template, having the <code class="literal">h1</code> element with some text:</p>
<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;
        Web Component: Activating template using cloneNode method
    &lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="container"&gt;&lt;/div&gt;
<span class="strong"><strong>&lt;template id="aTemplate"&gt;</strong></span>
<span class="strong"><strong>    &lt;h1&gt;Template is activated using cloneNode method.&lt;/h1&gt;</strong></span>
<span class="strong"><strong>&lt;/template&gt;</strong></span>
&lt;script&gt;
<span class="strong"><strong>    var aTemplate = document.querySelector("#aTemplate"),</strong></span>
        container = document.getElementById("container"),
        templateContent = <span class="strong"><strong>aTemplate.content</strong></span>,
        activeContent = <span class="strong"><strong>templateContent.cloneNode(true)</strong></span>;
    container.appendChild(activeContent);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>In the preceding code, the template element has the <code class="literal">aTemplate</code> ID and is referenced using the <code class="literal">querySelector</code> method. The HTML markup content inside the template is then retrieved using a <code class="literal">content</code> property and saved in a <code class="literal">templateContent</code> variable. The <code class="literal">cloneNode</code> method is then <a id="id28" class="indexterm"></a>used for deep cloning to<a id="id29" class="indexterm"></a> get the activated node that is later appended to a <code class="literal">div</code> element. The following screenshot shows the output of the preceding code:</p>
<div class="mediaobject"><img src="../Images/image00201.jpeg" alt="Cloning a node"/></div>
<p style="clear:both; height: 1em;"> </p>
<div class="note" title="Note"><h3 class="title"><a id="note03"></a>Note</h3>
<p>To find out more about the <a id="id30" class="indexterm"></a>
<code class="literal">cloneNode</code> method visit:</p>
<p>
<a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/API/Node.cloneNode">https://developer.mozilla.org/en-US/docs/Web/API/Node.cloneNode</a>
</p>
</div>
</div>
<div class="section" title="Importing a node"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"></a>Importing a node</h3>
</div>
</div>
</div>
<p>The <a id="id31" class="indexterm"></a>
<code class="literal">importNode</code> method<a id="id32" class="indexterm"></a> is another<a id="id33" class="indexterm"></a> way of activating the template content. The syntax for the aforementioned method is listed in the following code:</p>
<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&lt;Node&gt; document.importNode(&lt;target node&gt;,&lt;Boolean parameter&gt;)</strong></span>
</pre>
</div>
<p>The details of the preceding code syntax are listed as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">This method returns a copy of the node from an external document.</li>
<li class="listitem">This method takes two input parameters. The first parameter is the target node that needs to be copied. The second parameter is a <code class="literal">Boolean</code> flag and represents the way the target node is cloned. If the <code class="literal">Boolean</code> flag is <code class="literal">false</code>, the <code class="literal">importNode</code> method makes a shallow copy, and for a <code class="literal">true</code> value, it makes a deep copy.</li>
</ul>
</div>
<p>The<a id="id34" class="indexterm"></a> following<a id="id35" class="indexterm"></a> code shows the use of the <code class="literal">importNode</code> method to copy the content of a template containing an <code class="literal">h1</code> element with some text:</p>
<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;
        Web Component: Activating template using importNode method
    &lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="container"&gt;&lt;/div&gt;
<span class="strong"><strong>&lt;template id="aTemplate"&gt;</strong></span>
<span class="strong"><strong>    &lt;h1&gt;Template is activated using importNode method.&lt;/h1&gt;</strong></span>
<span class="strong"><strong>&lt;/template&gt;</strong></span>
&lt;script&gt;
    var aTemplate = document.querySelector("#aTemplate"),
        container = document.getElementById("container"),
        templateContent = aTemplate.content,
        activeContent = <span class="strong"><strong>document.importNode(templateContent, true);</strong></span>
    container.appendChild(activeContent);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>In the preceding code, the template element has the <code class="literal">aTemplate</code> ID and is referenced using the <code class="literal">querySelector</code> method. The HTML markup content inside the template is then retrieved using the <code class="literal">content</code> property and saved in the <code class="literal">templateContent</code> variable. The <code class="literal">importNode</code> method is then used for deep cloning to get the activated node that is later appended to a <code class="literal">div</code> element. The following screenshot shows the output of the preceding code:</p>
<div class="mediaobject"><img src="../Images/image00202.jpeg" alt="Importing a node"/></div>
<p style="clear:both; height: 1em;"> </p>
<div class="note" title="Note"><h3 class="title"><a id="note04"></a>Note</h3>
<p>To find out more about the <code class="literal">importNode</code> method, visit:</p>
<p>
<a class="ulink" href="http://mdn.io/importNode">http://mdn.io/importNode</a>
</p>
</div>
</div>
</div>
</div>


<div class="section" title="HTML Import"><div class="titlepage" id="aid-H5A42"><div><div><h1 class="title"><a id="ch01lvl1sec12"></a>HTML Import</h1>
</div>
</div>
</div>
<p>The<a id="id36" class="indexterm"></a> HTML Import is another important piece of technology of the W3C web component specification. It provides a way to include another HTML document present in a file with the current document. HTML Imports provide an alternate solution to the <code class="literal">Iframe</code> element, and are also great for resource bundling. The syntax of the HTML Imports is listed as follows:</p>
<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&lt;link rel="import" href="fileName.html"&gt;</strong></span>
</pre>
</div>
<p>The details of the preceding syntax are listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The HTML file can be imported using the <code class="literal">&lt;link&gt;</code> tag and the <code class="literal">rel</code> attribute with import as the value.</li>
<li class="listitem">The <code class="literal">href</code> string points to the external HTML file that needs to be included in the current document.</li>
</ul>
</div>
<p>The <a id="id37" class="indexterm"></a>HTML <code class="literal">import</code> element is implemented by the <code class="literal">HTMLElementLink</code> class. The IDL definition of HTML Import is listed in the following code:</p>
<div class="informalexample"><pre class="programlisting">partial <span class="strong"><strong>interface LinkImport</strong></span> {
    <span class="strong"><strong>readonly attribute Document? import;</strong></span>
};
<span class="strong"><strong>HTMLLinkElement</strong></span> implements <span class="strong"><strong>LinkImport</strong></span>;</pre>
</div>
<p>The preceding code shows IDL for the HTML Import where the parent interface is <code class="literal">LinkImport</code> which has the <code class="literal">readonly</code> attribute <code class="literal">import</code>. The <code class="literal">HTMLLinkElement</code> class implements the <code class="literal">LinkImport</code> parent interface. The browser that supports HTML Import must implement the preceding IDL.</p>
<div class="section" title="HTML Import feature detection"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"></a>HTML Import feature detection</h2>
</div>
</div>
</div>
<p>The <a id="id38" class="indexterm"></a>HTML Import is new to the browser and may not be supported by all browsers. To check the support of the HTML Import in the browser, we need to check for the <code class="literal">import</code> property that is present inside a <code class="literal">&lt;link&gt;</code> element. The code to check the HTML <code class="literal">import</code> support is as follows:</p>
<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;
        Web Component: HTML import support
    &lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 id="message"&gt;&lt;/h1&gt;
&lt;script&gt;
<span class="strong"><strong>    var isImportSupported = function () {</strong></span>
<span class="strong"><strong>        var link = document.createElement("link");</strong></span>
<span class="strong"><strong>        return 'import' in link;</strong></span>
<span class="strong"><strong>    };</strong></span>
    var isSupported = <span class="strong"><strong>isImportSupported()</strong></span>,
            message = document.getElementById("message");
    if (isSupported) {
        message.innerHTML = "Import is supported by the browser.";
    } else {
        message.innerHTML = "Import is not supported by the browser.";
    }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>The<a id="id39" class="indexterm"></a> preceding code has a <code class="literal">isImportSupported</code> function, which returns the <code class="literal">Boolean</code> value for HTML <code class="literal">import</code> support in the current browser. The function creates a <code class="literal">&lt;link&gt;</code> element and then checks the existence of an <code class="literal">import</code> attribute using the <code class="literal">in</code> operator. The following screenshot shows the output of the preceding code:</p>
<div class="mediaobject"><img src="../Images/image00203.jpeg" alt="HTML Import feature detection"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>The preceding screenshot shows that the import is supported by the current browser as the <code class="literal">isImportSupported</code> method returns true.</p>
<div class="note" title="Note"><h3 class="title"><a id="tip03"></a>Tip</h3>
<p>The <span class="strong"><strong>Can I Use</strong></span> tool can also be utilized for checking support for the HTML Import in the current browser. To check out the template support in the browser, use the following link:</p>
<p>
<a class="ulink" href="http://caniuse.com/#feat=imports">http://caniuse.com/#feat=imports</a>
</p>
</div>
<p>The following screenshot shows the current status of support for the HTML Import in browsers <a id="id40" class="indexterm"></a>using the <span class="strong"><strong>Can I Use</strong></span> online tool:</p>
<div class="mediaobject"><img src="../Images/image00204.jpeg" alt="HTML Import feature detection"/></div>
<p style="clear:both; height: 1em;"> </p>
</div>
<div class="section" title="Accessing the HTML Import document"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"></a>Accessing the HTML Import document</h2>
</div>
</div>
</div>
<p>The <a id="id41" class="indexterm"></a>HTML Import includes the external document to the current page. We can access the external document content using the <code class="literal">import</code> property of the link element. In this section, we will learn how to use the <code class="literal">import</code> property to refer to the external document. The <code class="literal">message.html</code> file is an external HTML file document that needs to be imported. The content of the <code class="literal">message.html</code> file is as follows:</p>
<div class="informalexample"><pre class="programlisting">&lt;h1&gt;
      This is from another HTML file document.
&lt;/h1&gt;</pre>
</div>
<p>The following code shows the HTML document where the <code class="literal">message.html</code> file is loaded and referenced by the <code class="literal">import</code> property:</p>
<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    <span class="strong"><strong>&lt;link rel="import" href="message.html"&gt;</strong></span>
&lt;/head&gt;
&lt;body&gt;
&lt;script&gt;
    (function(){
        <span class="strong"><strong>var externalDocument = document.querySelector('link[rel="import"]').import;</strong></span>
            headerElement = <span class="strong"><strong>externalDocument.querySelector('h1')</strong></span>
<span class="strong"><strong>        document.body.appendChild(headerElement.cloneNode(true));</strong></span>
    })();
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>The details <a id="id42" class="indexterm"></a>of the preceding code are listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">In the header section, the <code class="literal">&lt;link&gt;</code> element is importing the HTML document present inside the <code class="literal">message.html</code> file.</li>
<li class="listitem">In the body section, an inline <code class="literal">&lt;script&gt;</code> element using the <code class="literal">document.querySelector</code> method is referencing the link elements having the <code class="literal">rel</code> attribute with the <code class="literal">import</code> value. Once the link element is located, the content of this external document is copied using the <code class="literal">import</code> property to the <code class="literal">externalDocument</code> variable.</li>
<li class="listitem">The header <code class="literal">h1</code> element inside the external document is then located using a <code class="literal">querySelector</code> method and saved to the <code class="literal">headerElement</code> variable.</li>
<li class="listitem">The header element is then deep copied using the <code class="literal">cloneNode</code> method and appended to the <code class="literal">body</code> element of the current document.</li>
</ul>
</div>
<p>The following screenshot shows the output of the preceding code:</p>
<div class="mediaobject"><img src="../Images/image00205.jpeg" alt="Accessing the HTML Import document"/></div>
<p style="clear:both; height: 1em;"> </p>
</div>
<div class="section" title="HTML Import events"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"></a>HTML Import events</h2>
</div>
</div>
</div>
<p>The HTML <code class="literal">&lt;link&gt;</code> element with the <code class="literal">import</code> attribute supports two event handlers. These two events are listed <a id="id43" class="indexterm"></a>as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">load</code>: This<a id="id44" class="indexterm"></a> event is fired when the external HTML file is imported successfully onto the current page. A JavaScript function can be attached to the <code class="literal">onload</code> attribute, which can be executed on a successful load of the external HTML file.</li>
<li class="listitem"><code class="literal">error</code>: This<a id="id45" class="indexterm"></a> event is fired when the external HTML file is not loaded or found(HTTP code 404 not found). A JavaScript function can be attached to the <code class="literal">onerror</code> attribute, which can be executed on error of importing the external HTML file.</li>
</ul>
</div>
<p>The following code shows the use of these two event types while importing the <code class="literal">message.html</code> file to the current page:</p>
<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;script async&gt;
        function <span class="strong"><strong>handleSuccess</strong></span>(e) {
            //import load Successful
<span class="strong"><strong>            var targetLink = e.target,</strong></span>
<span class="strong"><strong>                externalDocument = targetLink.import;</strong></span>
<span class="strong"><strong>            headerElement = externalDocument.querySelector('h1'),</strong></span>
<span class="strong"><strong>              clonedHeaderElement = headerElement.cloneNode(true);</strong></span>
<span class="strong"><strong>            document.body.appendChild(clonedHeaderElement);</strong></span>
        }
        function <span class="strong"><strong>handleError</strong></span>(e) {
            //Error in load
            alert("error in import");
        }
    &lt;/script&gt;
    &lt;link <span class="strong"><strong>rel</strong></span>=<span class="strong"><strong>"import</strong></span>" href="message.html" 
          <span class="strong"><strong>onload="handleSuccess(event)</strong></span>"
          <span class="strong"><strong>onerror="handleError(event)</strong></span>"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>The details <a id="id46" class="indexterm"></a>of the preceding code are listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">handleSuccess</code>: This <a id="id47" class="indexterm"></a>method is attached to the <code class="literal">onload</code> attribute which is executed on the successful load of <code class="literal">message.html</code> in the current document. The <code class="literal">handleSuccess</code> method imports the document present inside the <code class="literal">message.html</code> file, then it finds the <code class="literal">h1</code> element, and makes a deep copy of it . The cloned <code class="literal">h1</code> element then gets appended to the body element.</li>
<li class="listitem"><code class="literal">handleError</code>: This <a id="id48" class="indexterm"></a>method is attached to the <code class="literal">onerror</code> attribute of the <code class="literal">&lt;link&gt;</code> element. This method will be executed if the <code class="literal">message.html</code> file is not found.</li>
</ul>
</div>
<p>As the <code class="literal">message.html</code> file is imported successfully, the <code class="literal">handleSuccess</code> method gets executed and header element <code class="literal">h1</code> is rendered in the browser. The following screenshot shows the output of the preceding code:</p>
<div class="mediaobject"><img src="../Images/image00206.jpeg" alt="HTML Import events"/></div>
<p style="clear:both; height: 1em;"> </p>
</div>
</div>


<div class="section" title="Shadow DOM"><div class="titlepage" id="aid-I3QM2"><div><div><h1 class="title"><a id="ch01lvl1sec13"></a>Shadow DOM</h1>
</div>
</div>
</div>
<p>Before the <a id="id49" class="indexterm"></a>web component specification, there were many issues of building web applications using HTML, CSS, and JavaScript. Some of the issues are listed as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Style override</strong></span>: The document stylesheet may change the style of the web component.</li>
<li class="listitem"><span class="strong"><strong>Script alteration</strong></span>: The document JavaScript may alter some part of the web component.</li>
<li class="listitem"><span class="strong"><strong>ID overlap</strong></span>: There may be a duplicate ID present in the document, which can lead to many erroneous situations.</li>
</ul>
</div>
<p>From the aforementioned issue list, there is clearly a problem with <span class="strong"><strong>scoping</strong></span>. Shadow DOM is another important piece of web component specification that solves the scoping problem by the encapsulation mechanism. Shadow DOM provides a way of packaging the HTML, CSS, and JavaScript for a web component.</p>
<p>Most of the HTML5 elements, such as the progress bar, are implemented as Shadow DOM by the Chrome browser. We can inspect this Shadow DOM through the Chrome developer console. By default, the Chrome developer console will not show Shadow DOM. We need to enable the <span class="strong"><strong>Show user agent shadow DOM</strong></span> checkbox present inside the settings of the developer console. The following screenshot shows the Chrome developer console setting to enable <a id="id50" class="indexterm"></a>Shadow DOM inspection:</p>
<div class="mediaobject"><img src="../Images/image00207.jpeg" alt="Shadow DOM"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>After enabling the Shadow DOM inspection setting, we can inspect the <code class="literal">&lt;progress&gt;</code> HTML5 element. The<a id="id51" class="indexterm"></a> following screenshot shows the Chrome developer inspection of the progress bar element containing Shadow DOM node:</p>
<div class="mediaobject"><img src="../Images/image00208.jpeg" alt="Shadow DOM"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>In the preceding screenshot, we can see a new element <code class="literal">#shadow-root</code>. This node is the Shadow DOM of the progress bar element. As the progress bar is built in the browser element; we can see the user-agent text in parenthesis.</p>
<div class="section" title="Shadow DOM feature detection"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"></a>Shadow DOM feature detection</h2>
</div>
</div>
</div>
<p>The Shadow DOM<a id="id52" class="indexterm"></a> support for a browser can be checked by enabling the <code class="literal">createShadowRoot</code> property inside an element. The following code demonstrates a way of detecting the support of the Shadow DOM in the current browser:</p>
<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;
        Web Component: Shadow DOM Feature detection
    &lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 id="message"&gt;&lt;/h1&gt;
&lt;script&gt;
    <span class="strong"><strong>var isShadowDOMSupported = function () {</strong></span>
<span class="strong"><strong>        return "createShadowRoot" in document.body;</strong></span>
<span class="strong"><strong>    };</strong></span>
    var isSupported = <span class="strong"><strong>isShadowDOMSupported</strong></span>(),
        message = document.getElementById("message");
    if (isSupported) {
        message.innerHTML = "Shadow DOM is supported by the browser.";
    } else {
        message.innerHTML = "Shadow DOM is not supported by the browser.";
    }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>In the preceding code, the <code class="literal">isShadowDOMSupported</code> method checks the support of the Shadow DOM in the current browser by checking the existence of the <code class="literal">createShadowRoot</code> property in the <code class="literal">document.body</code> element. The following screenshot shows the output of the preceding code in the current browser:</p>
<div class="mediaobject"><img src="../Images/image00209.jpeg" alt="Shadow DOM feature detection"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>The preceding<a id="id53" class="indexterm"></a> screenshot shows that the Shadow DOM is supported by the current browser, as the <code class="literal">isShadowDOMSupport</code> method returns <code class="literal">true</code>. We can also check the support of the Shadow DOM using the <span class="strong"><strong>Can I Use</strong></span> online tool. The following screenshot shows the status of Shadow DOM support in a different browser:</p>
<div class="mediaobject"><img src="../Images/image00210.jpeg" alt="Shadow DOM feature detection"/></div>
<p style="clear:both; height: 1em;"> </p>
</div>
<div class="section" title="Shadow tree"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"></a>Shadow tree</h2>
</div>
</div>
</div>
<p>Shadow DOM <a id="id54" class="indexterm"></a>brings the ability to include a subtree of DOM elements inside a document on the rendering time. The nodes inside DOM are organized as a tree structure. A node inside the DOM tree can have its own Shadow DOM tree. This makes the DOM a tree of trees. We can classify the DOM tree into three different types:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Document tree</strong></span>: This <a id="id55" class="indexterm"></a>represents the normal DOM tree whose root node is a document.</li>
<li class="listitem"><span class="strong"><strong>Shadow tree</strong></span>: This <a id="id56" class="indexterm"></a>represents the internal DOM subtree formed using HTML elements present inside shadow host. The root node of this tree is called <span class="strong"><strong>shadow root</strong></span>.</li>
<li class="listitem"><span class="strong"><strong>Composed tree</strong></span>: This <a id="id57" class="indexterm"></a>represents the more expanded version of document tree, which includes the Shadow DOM trees too and is used by the browser for rendering.</li>
</ul>
</div>
<p>The DOM element that has one or more than one Shadow DOM subtrees is called as <span class="strong"><strong>host element</strong></span> <a id="id58" class="indexterm"></a>or <a id="id59" class="indexterm"></a>
<span class="strong"><strong>shadow host</strong></span>. The following diagram shows a <a id="id60" class="indexterm"></a>sample DOM tree:</p>
<div class="mediaobject"><img src="../Images/image00211.jpeg" alt="Shadow tree"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>In the <a id="id61" class="indexterm"></a>preceding diagram, we find out that the node present inside the DOM element represents another subtree, which makes the DOM a tree of trees. A browser which supports Shadow DOM implementation should follow the IDL definition for <a id="id62" class="indexterm"></a>declaring the shadow<a id="id63" class="indexterm"></a> root element. The IDL of a shadow root element is listed in the following code:</p>
<div class="informalexample"><pre class="programlisting">interface ShadowRoot : DocumentFragment {
    HTMLElement getElementById(DOMString elementId);
    NodeList getElementsByClassName(DOMString className);
    NodeList getElementsByTagName(DOMString tagName);
    NodeList getElementsByTagNameNS(DOMString? namespace, DOMString localName);
    Selection? getSelection();
    Element? elementFromPoint(double x, double y);
    readonly attribute Element? activeElement;
    readonly attribute Element host;
    readonly attribute ShadowRoot? olderShadowRoot;
    attribute DOMString innerHTML;
    readonly attribute StyleSheetList styleSheets;
};</pre>
</div>
<p>The details of the preceding IDL are listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">getElementById</code>: This <a id="id64" class="indexterm"></a>method finds the element present inside the Shadow DOM tree with the given ID</li>
<li class="listitem"><code class="literal">getElementsByClassName</code>: This <a id="id65" class="indexterm"></a>method finds the element present inside the Shadow DOM tree with the given class name</li>
<li class="listitem"><code class="literal">getElementsByTagName</code>: This<a id="id66" class="indexterm"></a> method finds the element present inside the Shadow DOM tree with the given tag name</li>
<li class="listitem"><code class="literal">getElementsByTagNameNS</code>: This <a id="id67" class="indexterm"></a>method finds the element present inside the Shadow DOM tree with the given namespace and tag name</li>
<li class="listitem"><code class="literal">getSelection</code>: This<a id="id68" class="indexterm"></a> method returns the selection object for currently selected element inside the Shadow DOM tree</li>
<li class="listitem"><code class="literal">elementFromPoint</code>: This <a id="id69" class="indexterm"></a>method returns the element with the given <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates</li>
<li class="listitem"><code class="literal">activeElement</code>: This <a id="id70" class="indexterm"></a>property returns currently focused element inside the Shadow DOM tree</li>
<li class="listitem"><code class="literal">host</code>: This<a id="id71" class="indexterm"></a> property returns the shadow host element</li>
<li class="listitem"><code class="literal">olderShadowRoot</code>: If <a id="id72" class="indexterm"></a>the element has multiple shadow trees then this property returns the shadow root which was created earlier</li>
<li class="listitem"><code class="literal">innerHTML</code>: This<a id="id73" class="indexterm"></a> property returns the HTML content of the shadow root as a string</li>
<li class="listitem"><code class="literal">styleSheets</code>: This <a id="id74" class="indexterm"></a>property returns the list of stylesheet objects if the shadow tree contains the <code class="literal">&lt;style&gt;</code> element</li>
</ul>
</div>
<p>Now, let's check out an example<a id="id75" class="indexterm"></a> which demonstrates the use of these properties and the methods of a shadow root. The example code is listed as follows:</p>
<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Shadow Root: Method &amp; Properties example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="aShadowHost"&gt;&lt;/div&gt;
    <span class="strong"><strong>&lt;template id="selectorTemplate"&gt;</strong></span>
        &lt;style&gt;
            :host input{
                background: lightyellow;
            }
            :host .labelClass{
                color: blue;
            }
        &lt;/style&gt;
        <span class="strong"><strong>&lt;form&gt;</strong></span>
            &lt;label for="nameElement" class="labelClass"&gt;Name&lt;/label&gt;
            &lt;input type="text" id="nameElement"
                   placeholder="Enter your name"
                   value="Sandeep" <span class="strong"><strong>autofocus</strong></span>&gt;
        <span class="strong"><strong>&lt;/form&gt;</strong></span>
<span class="strong"><strong>    &lt;/template&gt;</strong></span>
    &lt;script&gt;
     (function(){
         var aShadowHost = document.getElementById("aShadowHost"),
             <span class="strong"><strong>shadowRoot1 = aShadowHost.createShadowRoot()</strong></span>,
             <span class="strong"><strong>shadowRoot2 = aShadowHost.createShadowRoot()</strong></span>,
             templateContent = document.querySelector('#selectorTemplate').content,
             templateNodes = document.importNode(templateContent, true);
         shadowRoot1.innerText ="inside shadowRoot1";
         shadowRoot2.appendChild(templateNodes);
         <span class="strong"><strong>shadowRoot2.getElementById("nameElement").select();</strong></span>
         //Shadow Root Methods
         console.log("getElementById: ",<span class="strong"><strong>shadowRoot2.getElementById("nameElement"))</strong></span>;
         console.log("getElementsByClassName: ",<span class="strong"><strong>shadowRoot2.getElementsByClassName("labelClass"))</strong></span>;
         console.log("getElementsByTagName: ",<span class="strong"><strong>shadowRoot2.getElementsByTagName("label"));</strong></span>
         console.log("getElementsByTagNameNS: ",<span class="strong"><strong>shadowRoot2.getElementsByTagNameNS("*","label"));</strong></span>
         console.log("getSelection() Method: <span class="strong"><strong>",shadowRoot2.getSelection());</strong></span>
         console.log("elementFromPoint: ",<span class="strong"><strong>shadowRoot2.elementFromPoint(8,9))</strong></span>;
    //Shadow Root Properties
         console.log("activeElement: ",<span class="strong"><strong>shadowRoot2.activeElement)</strong></span>;
         console.log("host: ",<span class="strong"><strong>shadowRoot2.host</strong></span>);
         console.log("olderShadowRoot: ",<span class="strong"><strong>shadowRoot2.olderShadowRoot)</strong></span>;
console.log("styleSheets: ",<span class="strong"><strong>shadowRoot2.styleSheets</strong></span>);
         console.log("innerHTML: ",<span class="strong"><strong>shadowRoot2.innerHTML</strong></span>);
    })();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>In the preceding <a id="id76" class="indexterm"></a>code, the two Shadow DOM subtrees <code class="literal">shadowRoot1</code> and <code class="literal">shadowRoot2</code> are present for the host element. The <code class="literal">shadowRoot1</code> subtree is created first and <code class="literal">shadowRoot2</code> is created later. Hence, the <code class="literal">shadowRoot1</code> subtree is an older shadow root. The <code class="literal">shadowRoot2</code> subtree contains the HTML markup from a template with the <code class="literal">selectorTemplate</code> ID. The <code class="literal">shadowRoot2</code> subtree has a <code class="literal">&lt;form&gt;</code> element containing a <code class="literal">&lt;label&gt;</code> and <code class="literal">&lt;input&gt;</code> element. It also contains some CSS styles inside the <code class="literal">&lt;style&gt;</code> element. The output of the preceding code is presented in the following screenshot:</p>
<div class="mediaobject"><img src="../Images/image00212.jpeg" alt="Shadow tree"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>The following screenshot shows the console log messages, which demonstrate the use of the preceding methods for the shadow tree:</p>
<div class="mediaobject"><img src="../Images/image00213.jpeg" alt="Shadow tree"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>The following<a id="id77" class="indexterm"></a> screenshot shows the console log messages that demonstrate the use of the preceding properties for the shadow tree:</p>
<div class="mediaobject"><img src="../Images/image00214.jpeg" alt="Shadow tree"/></div>
<p style="clear:both; height: 1em;"> </p>
</div>
</div>


<div class="section" title="Custom element"><div class="titlepage" id="aid-J2B82"><div><div><h1 class="title"><a id="ch01lvl1sec14"></a>Custom element</h1>
</div>
</div>
</div>
<p>Web component<a id="id78" class="indexterm"></a> specifications come with the power to create a new element for DOM. A custom element can have its own properties and methods. The reasons for creating a custom element are less code from the developer's point of view, creating a more semantic tag library, reducing the number of <code class="literal">div</code> tags, and so on. Once a web component is developed, it can be used by any application.</p>
<div class="section" title="Custom element feature detection"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"></a>Custom element feature detection</h2>
</div>
</div>
</div>
<p>A new <a id="id79" class="indexterm"></a>element can be registered to DOM using the <code class="literal">registerElement</code> method. We can detect the support of the custom element in the current browser by checking the presence of the <code class="literal">registerElement</code> function inside document. The following JavaScript code shows a method to detect the support for custom element:</p>
<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Web Component: custom element support&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 id="message"&gt;&lt;/h1&gt;
&lt;script&gt;
    <span class="strong"><strong>var isCustomElementSupported = function () {</strong></span>
<span class="strong"><strong>        return 'registerElement' in document;</strong></span>
<span class="strong"><strong>    };</strong></span>
    var isSupported = <span class="strong"><strong>isCustomElementSupported()</strong></span>,
            message = document.getElementById("message");
    if (isSupported) {
        <span class="strong"><strong>message.innerHTML = "Custom element is supported by the browser.";</strong></span>
    } else {
        message.innerHTML = "Custom element is not supported by the browser.";
    }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>In the preceding code, the <code class="literal">isCustomElementSupported</code> method has the code to check the custom element support. It uses the <code class="literal">in</code> operator to check whether the <code class="literal">registerElement</code> function is present inside the document object. If the custom element is supported, the method returns true and the success message gets rendered in the browser. The following screenshot shows the output of the preceding code in the browser:</p>
<div class="mediaobject"><img src="../Images/image00215.jpeg" alt="Custom element feature detection"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>We can also <a id="id80" class="indexterm"></a>use the <span class="strong"><strong>Can I Use</strong></span> online tool to check the support for custom elements. The following screenshot shows the current status of the browser for custom element support:</p>
<div class="mediaobject"><img src="../Images/image00216.jpeg" alt="Custom element feature detection"/></div>
<p style="clear:both; height: 1em;"> </p>
</div>
<div class="section" title="Developing a custom element"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"></a>Developing a custom element</h2>
</div>
</div>
</div>
<p>In this <a id="id81" class="indexterm"></a>section, we will develop a custom element and understand each step in detail. The steps involved in developing a custom element are listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creating a new object</li>
<li class="listitem">Defining object properties</li>
<li class="listitem">Defining lifecycle methods</li>
<li class="listitem">Registering a new element</li>
<li class="listitem">Extending an element</li>
</ul>
</div>
<div class="section" title="Creating a new object"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"></a>Creating a new object</h3>
</div>
</div>
</div>
<p>A <a id="id82" class="indexterm"></a>new object can be created using the <code class="literal">Object.create</code> method. The syntax of this method is listed here:</p>
<div class="informalexample"><pre class="programlisting">Object.create(&lt;target prototype&gt; [, propertiesObject]);</pre>
</div>
<p>The <code class="literal">Object.create</code> method takes two parameters. The first parameter is the target prototype of the newly created object. The second parameter contains the properties of the newly created object. The second parameter is optional. The following code defines a new object:</p>
<div class="informalexample"><pre class="programlisting">var <span class="strong"><strong>objectPrototype</strong></span> = Object.create(<span class="strong"><strong>HTMLElement.prototype</strong></span>);</pre>
</div>
<p>In the preceding code, a new object is created that has the <code class="literal">HTMLElement.prototype</code> parameter and is saved in the <code class="literal">objectPrototype</code> variable.</p>
<div class="note" title="Note"><h3 class="title"><a id="note05"></a>Note</h3>
<p>To find out more about the<a id="id83" class="indexterm"></a> <code class="literal">Object.create</code> method, use the following link:</p>
<p>
<a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a>
</p>
</div>
</div>
<div class="section" title="Defining object properties"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"></a>Defining object properties</h3>
</div>
</div>
</div>
<p>We<a id="id84" class="indexterm"></a> can define the property of an object using two different methods <code class="literal">defineProperty</code> and <code class="literal">defineProperties</code>. The <code class="literal">defineProperty</code> method is used to create a single property, and the <code class="literal">defineProperties</code> method for multiple properties. The syntax of these methods is listed here:</p>
<div class="informalexample"><pre class="programlisting">Object.<span class="strong"><strong>defineProperty</strong></span>(&lt;<span class="strong"><strong>targetObject</strong></span>&gt;, &lt;<span class="strong"><strong>propertyName</strong></span>&gt;, &lt;<span class="strong"><strong>propertySettings</strong></span>&gt;);
Object.<span class="strong"><strong>defineProperties</strong></span>(&lt;<span class="strong"><strong>targetObject</strong></span>&gt;, &lt;<span class="strong"><strong>properties</strong></span>&gt;);</pre>
</div>
<p>The details of the preceding syntax are listed as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">targetObject</code>: This <a id="id85" class="indexterm"></a>represents the target object for which the property needs to be defined.</li>
<li class="listitem"><code class="literal">propertyName</code>: This<a id="id86" class="indexterm"></a> represents the key of the property.</li>
<li class="listitem"><code class="literal">propertySettings</code>: This <a id="id87" class="indexterm"></a>represents all the configuration options for a property. The possible settings options are listed here:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">configurable</code>: This <a id="id88" class="indexterm"></a>takes a Boolean value. For a <code class="literal">true</code> value, the type of property can be changed or deleted. For a <code class="literal">false</code> value, the property type cannot be changed and deleted.</li>
<li class="listitem"><code class="literal">enumerable</code>: This<a id="id89" class="indexterm"></a> takes a Boolean value. For a <code class="literal">true</code> value, the property will be enumerated as its own property.</li>
<li class="listitem"><code class="literal">value</code>: This <a id="id90" class="indexterm"></a>takes any JavaScript value. It represents the value associated with the property.</li>
<li class="listitem"><code class="literal">writable</code>: This <a id="id91" class="indexterm"></a>takes a Boolean value. For a <code class="literal">true</code> value, the associated value of the property can be updated using assignment operator.</li>
<li class="listitem"><code class="literal">get</code>: This <a id="id92" class="indexterm"></a>takes a function. It returns the value of the property.</li>
<li class="listitem"><code class="literal">set</code>: This<a id="id93" class="indexterm"></a> takes a function. It sets the input value to the property.</li>
</ul>
</div></li>
</ul>
</div>
<p>The<a id="id94" class="indexterm"></a> following code shows an example of defining a single property named <code class="literal">title</code> for <code class="literal">newObject</code> that is writable:</p>
<div class="informalexample"><pre class="programlisting">var newObject = Object.create(HTMLElement.prototype);
<span class="strong"><strong>Object.defineProperty(newObject, 'title', {</strong></span>
<span class="strong"><strong>    writable : true</strong></span>
<span class="strong"><strong>});</strong></span>
</pre>
</div>
<div class="note" title="Note"><h3 class="title"><a id="note06"></a>Note</h3>
<p>To find out more about the <a id="id95" class="indexterm"></a>
<code class="literal">Object.defineProperty</code> method, use the following link:</p>
<p>
<a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a>
</p>
</div>
<p>The following code shows an example of defining multiple properties like <code class="literal">title</code> and <code class="literal">country</code> for the <code class="literal">newObject</code> variable. The <code class="literal">title</code> property is writable, and the <code class="literal">country</code> property is not writable and has a fixed value <code class="literal">India</code>:</p>
<div class="informalexample"><pre class="programlisting">var newObject = Object.create(HTMLElement.prototype);
<span class="strong"><strong>Object.defineProperties(newObject,  {</strong></span>
<span class="strong"><strong>    title:{</strong></span>
<span class="strong"><strong>        writable: true</strong></span>
<span class="strong"><strong>    },</strong></span>
<span class="strong"><strong>    country:{</strong></span>
<span class="strong"><strong>        writable: false,</strong></span>
<span class="strong"><strong>        value: "India"</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>});</strong></span>
</pre>
</div>
<div class="note" title="Note"><h3 class="title"><a id="note07"></a>Note</h3>
<p>To find out more about the <code class="literal">Object.defineProperties</code> method, use the following link:</p>
<p>
<a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties</a>
</p>
</div>
</div>
<div class="section" title="Defining lifecycle methods"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"></a>Defining lifecycle methods</h3>
</div>
</div>
</div>
<p>An object in <a id="id96" class="indexterm"></a>JavaScript goes through different states during its lifecycle. The different states of an object lifecycle are listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">created</code>: An object is in the <a id="id97" class="indexterm"></a><code class="literal">created</code> state when it is initialized. The event handler for this state is the <code class="literal">createdCallback</code> method.</li>
<li class="listitem"><code class="literal">attached</code>: An object <a id="id98" class="indexterm"></a>is in the <code class="literal">attached</code> state when it is inserted to the DOM. The event handler for this state is the <code class="literal">attachedCallback</code> method.</li>
<li class="listitem"><code class="literal">detached</code>: An<a id="id99" class="indexterm"></a> object is in the <code class="literal">detached</code> state when it is removed from the DOM. The event handler for this state is the <code class="literal">detachedCallback</code> method.</li>
<li class="listitem"><code class="literal">attributeChanged</code>: An<a id="id100" class="indexterm"></a> object is in the <code class="literal">attaributeChanged</code> state when one of its property's values is updated. The event handler for this state is the <code class="literal">attributeChangedCallback</code> method.</li>
</ul>
</div>
<p>The following code shows an example where an object is created using the <code class="literal">Object.create</code> method, and a callback method is attached for the created state:</p>
<div class="informalexample"><pre class="programlisting">var objectPrototype = Object.create(HTMLElement.prototype);
<span class="strong"><strong>objectPrototype.createdCallback=function(){</strong></span>
<span class="strong"><strong>   console.log("Instance is created");</strong></span>
};</pre>
</div>
</div>
<div class="section" title="Registering a new element"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"></a>Registering a new element</h3>
</div>
</div>
</div>
<p>A <a id="id101" class="indexterm"></a>new element can be registered to the DOM using the <code class="literal">document.registerElement</code> method. The syntax of this method is listed here:</p>
<div class="informalexample"><pre class="programlisting">var <span class="strong"><strong>constructor</strong></span> = document.<span class="strong"><strong>registerElement</strong></span>(&lt;<span class="strong"><strong>tag-name</strong></span>&gt;<span class="strong"><strong>,settings</strong></span>);</pre>
</div>
<p>The details of the preceding syntax are listed as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">tag-name</code>: This represents the name of the custom element. The name must be separated with a hyphen.</li>
<li class="listitem"><code class="literal">settings</code>: This takes the configuration option for the custom element.</li>
<li class="listitem"><code class="literal">constructor</code> : The <code class="literal">registerElement</code> method returns the constructor of new element.</li>
</ul>
</div>
<p>The following code shows an example of registering a new element named <code class="literal">welcome-message</code> to the DOM. The prototype of the <code class="literal">welcome-message</code> element is <code class="literal">objectPrototype</code>, which is created using the <code class="literal">Object.create</code> method:</p>
<div class="informalexample"><pre class="programlisting">var objectPrototype = Object.create(HTMLElement.prototype),
    welcomeElement = document.registerElement(<span class="strong"><strong>"welcome-message</strong></span>",{
        <span class="strong"><strong>prototype: objectPrototype</strong></span>
<span class="strong"><strong>});</strong></span>
</pre>
</div>
<div class="note" title="Note"><h3 class="title"><a id="note08"></a>Note</h3>
<p>To find out more about the<a id="id102" class="indexterm"></a> <code class="literal">document.registerElement</code> method, use the following link:</p>
<p>
<a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/API/document.registerElement">https://developer.mozilla.org/en-US/docs/Web/API/document.registerElement</a>
</p>
</div>
</div>
<div class="section" title="Extending an element"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec07"></a>Extending an element</h3>
</div>
</div>
</div>
<p>An<a id="id103" class="indexterm"></a> element can inherit a native or another custom element. The <code class="literal">extend</code> property is used to inherit another element. The following code shows an example of extending an <code class="literal">&lt;i&gt;</code> element:</p>
<div class="informalexample"><pre class="programlisting">var objectPrototype = Object.create(HTMLElement.prototype),
    italicElement = document.registerElement(<span class="strong"><strong>"italic-message</strong></span>",{
        prototype: objectPrototype,
        <span class="strong"><strong>extends:'i</strong></span>'
});</pre>
</div>
<p>The <code class="literal">is</code> operator is used to define the type of an HTML element. The following code shows if an <a id="id104" class="indexterm"></a>element is of the italic type:</p>
<div class="informalexample"><pre class="programlisting">&lt;welcome-message <span class="strong"><strong>is="i</strong></span>"&gt;
    Hello world
&lt;/welcome-message&gt;</pre>
</div>
</div>
</div>
<div class="section" title="Example of a custom element"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"></a>Example of a custom element</h2>
</div>
</div>
</div>
<p>In this <a id="id105" class="indexterm"></a>section, we will create a simple custom element named <code class="literal">&lt;my-message&gt;</code>. Code for the <code class="literal">&lt;my-message&gt;</code> element is as follows:</p>
<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Web Component: custom element example&lt;/title&gt;
    <span class="strong"><strong>&lt;script&gt;</strong></span>
        <span class="strong"><strong>var objectPrototype = Object.create(HTMLElement.prototype);</strong></span>
<span class="strong"><strong>        Object.defineProperty(objectPrototype, 'title', {</strong></span>
<span class="strong"><strong>            writable : true</strong></span>
<span class="strong"><strong>        });</strong></span>
<span class="strong"><strong>        objectPrototype.createdCallback=function(){</strong></span>
<span class="strong"><strong>            this.innerText=this.title;</strong></span>
<span class="strong"><strong>        };</strong></span>
<span class="strong"><strong>        var  myNameElement = document.registerElement("my-name",{</strong></span>
<span class="strong"><strong>            prototype:objectPrototype</strong></span>
<span class="strong"><strong>        });</strong></span>
<span class="strong"><strong>    &lt;/script&gt;</strong></span>
&lt;/head&gt;
&lt;body&gt;
    <span class="strong"><strong>&lt;my-name title="Welcome to custom element 1"&gt;&lt;/my-name&gt;</strong></span>
<span class="strong"><strong>    &lt;br&gt;</strong></span>
<span class="strong"><strong>    &lt;my-name title="Welcome to custom element 2"&gt;&lt;/my-name&gt;</strong></span>
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<div class="note" title="Note"><h3 class="title"><a id="tip04"></a>Tip</h3>
<p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p>
<p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p>
</div>
<p>In the preceding code, a custom <code class="literal">my-name</code> element is defined using the <code class="literal">registerElement</code> method. It has the <code class="literal">title</code> attribute, which has been defined using the <code class="literal">Object.defineProperty</code> method. A <code class="literal">createdCallback</code> method is added, which takes the input string of the <code class="literal">title</code> property and inserts it using the <code class="literal">innerText</code> property. The following screenshot shows the output of the preceding code:</p>
<div class="mediaobject"><img src="../Images/image00217.jpeg" alt="Example of a custom element"/></div>
<p style="clear:both; height: 1em;"> </p>
</div>
</div>


<div class="section" title="Node distribution" id="aid-K0RQ1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"></a>Node distribution</h1>
</div>
</div>
</div>
<p>The <a id="id106" class="indexterm"></a>composed tree takes part in rendering the DOM inside the browser. The Shadow DOM subtree of the nodes gets arranged for display. The arrangements of the nodes are done by a distribution mechanism with the help of specific insertion points. These insertion points are of two types:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Content insertion point</li>
<li class="listitem">Shadow insertion point</li>
</ul>
</div>
<div class="section" title="A content insertion point"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"></a>A content insertion point</h2>
</div>
</div>
</div>
<p>A <a id="id107" class="indexterm"></a>content insertion point is a <a id="id108" class="indexterm"></a>
<span class="strong"><strong>placeholder</strong></span> for child <a id="id109" class="indexterm"></a>nodes of the shadow host distribution. It works like a marker, which reprojects the child nodes of the shadow host. A content insertion point can be defined using the <code class="literal">&lt;content&gt;</code> element. The <code class="literal">&lt;content&gt;</code> element has a <code class="literal">select</code> attribute through which we can filter out the <a id="id110" class="indexterm"></a>
<span class="strong"><strong>reprojection</strong></span>. </p>
<p>The following code gives an example of the use of the <code class="literal">&lt;content&gt;</code> element with the <code class="literal">select</code> attribute:</p>
<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Web Component: content insertion point with select attribute example&lt;/title&gt;
    &lt;template id="selectorTemplate"&gt;
        &lt;style&gt;
            :host b{
                margin: 0px 10px;
            }
            :host ::content b.fruit{
                color:green;
            }
            :host ::content b.flower{
                color:orange;
            }
        &lt;/style&gt;
        <span class="strong"><strong>&lt;h1&gt;</strong></span>
<span class="strong"><strong>            Fruits &lt;content select="b.fruit"&gt;&lt;/content&gt;.</strong></span>
<span class="strong"><strong>        &lt;/h1&gt;</strong></span>
<span class="strong"><strong>        &lt;h1&gt;</strong></span>
<span class="strong"><strong>            Flowers &lt;content select="b.flower"&gt;&lt;/content&gt;.</strong></span>
<span class="strong"><strong>        &lt;/h1&gt;</strong></span>
    &lt;/template&gt;
    &lt;script&gt;
        var objectPrototype = Object.create(HTMLElement.prototype);
        objectPrototype.createdCallback=function(){
            var shadow = this.createShadowRoot(),
                templateContent = document.querySelector('#selectorTemplate').content,
                templateNodes = document.importNode(templateContent, true);
            shadow.appendChild(templateNodes);
        };
        var myNameElement = document.registerElement("selector- component",{
            prototype: objectPrototype
        });
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
<span class="strong"><strong>    &lt;selector-component&gt;</strong></span>
<span class="strong"><strong>        &lt;b class="fruit"&gt;Apple &lt;/b&gt;</strong></span>
<span class="strong"><strong>        &lt;b class="flower"&gt;Rose &lt;/b&gt;</strong></span>
<span class="strong"><strong>        &lt;b class="fruit"&gt;Orange &lt;/b&gt;</strong></span>
<span class="strong"><strong>        &lt;b class="fruit"&gt;Banana &lt;/b&gt;</strong></span>
<span class="strong"><strong>        &lt;b class="flower"&gt;Lotus &lt;/b&gt;</strong></span>
<span class="strong"><strong>        &lt;b class="fruit"&gt;Grapes &lt;/b&gt;</strong></span>
<span class="strong"><strong>        &lt;b class="flower"&gt;Jasmine &lt;/b&gt;</strong></span>
<span class="strong"><strong>    &lt;/selector-component&gt;</strong></span>
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>A detailed <a id="id111" class="indexterm"></a>explanation of the preceding code is listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A custom element named <code class="literal">&lt;selector-component&gt;</code> is created, which has a list of fruits and flowers.</li>
<li class="listitem">The HTML template of the custom element has two <code class="literal">&lt;content&gt;</code> elements. One content element filters out all the flowers using the <code class="literal">select</code> attribute with the <code class="literal">b.flower</code> value, and the other <code class="literal">&lt;content&gt;</code> element filters out all the fruits using the <code class="literal">select</code> attribute with the <code class="literal">b.fruit</code> value.</li>
</ul>
</div>
<p>The <a id="id112" class="indexterm"></a>following screenshot shows the output of the preceding code of filtering fruit and flower in a separate group:</p>
<div class="mediaobject"><img src="../Images/image00218.jpeg" alt="A content insertion point"/></div>
<p style="clear:both; height: 1em;"> </p>
</div>
<div class="section" title="A shadow insertion point"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"></a>A shadow insertion point</h2>
</div>
</div>
</div>
<p>Shadow <a id="id113" class="indexterm"></a>insertion points are placeholders <a id="id114" class="indexterm"></a>for other shadow trees. This insertion point reprojects the elements of other shadow trees. A shadow insertion point can be created using the <code class="literal">&lt;shadow&gt;</code> element. The following code gives an example of the use of the shadow insertion point:</p>
<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;&gt;Web Component: shadow insertion point example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="aShadowHost"&gt;&lt;/div&gt;
    &lt;template id=<span class="strong"><strong>"shadow1Template</strong></span>"&gt;
        <span class="strong"><strong>&lt;button&gt;Shadow Root 1 Button&lt;/button&gt;</strong></span>
    &lt;/template&gt;
    &lt;template id=<span class="strong"><strong>"shadow2Template</strong></span>"&gt;
<span class="strong"><strong>        &lt;fieldset&gt;</strong></span>
<span class="strong"><strong>            &lt;legend&gt;Shadow Root 2&lt;/legend&gt;</strong></span>
<span class="strong"><strong>            &lt;shadow&gt;&lt;/shadow&gt;</strong></span>
<span class="strong"><strong>        &lt;/fieldset&gt;</strong></span>
    &lt;/template&gt;
    &lt;script&gt;
        //Old shadow root
        var aShadowHost = document.getElementById("aShadowHost"),
            <span class="strong"><strong>aShadowRoot1 = aShadowHost.createShadowRoot();</strong></span>
            templateContent = document.querySelector('#shadow1Template').content,
            templateNodes = document.importNode(templateContent, true);
        aShadowRoot1.appendChild(templateNodes);
        //new shadow root with insertion point for older shadow root
        <span class="strong"><strong>var aShadowRoot2 = aShadowHost.createShadowRoot();</strong></span>
        templateContent = document.querySelector('#shadow2Template').content,
        templateNodes = document.importNode(templateContent, true);
        aShadowRoot2.appendChild(templateNodes);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>The details of the preceding code are listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">There are two shadow roots, <code class="literal">shadowRoot1(old)</code> and <code class="literal">shadowRoot2(new)</code>, created for the <code class="literal">&lt;div&gt;</code> element with the <code class="literal">aShadowHost</code> ID.</li>
<li class="listitem">The <code class="literal">shadow1Template</code> is the HTML template for <code class="literal">shadowRoot1</code>, and <code class="literal">shadow2Template</code> is the HTML template for <code class="literal">shadow2Root</code>.</li>
<li class="listitem">The <code class="literal">shadow1Template</code> contains a <code class="literal">&lt;button&gt;</code> element, and <code class="literal">shadow2Template</code> contains a <code class="literal">&lt;fieldset&gt;</code> and <code class="literal">&lt;legend&gt;</code> element. The <code class="literal">&lt;fieldset&gt;</code> element also has a <code class="literal">&lt;shadow&gt;</code> insertion point.</li>
<li class="listitem">During rendering of the page, the shadow insertion point will take the older shadow root content and insert it in the shadow insertion point.</li>
</ul>
</div>
<p>The <a id="id115" class="indexterm"></a>following screenshot shows the output of <a id="id116" class="indexterm"></a>the preceding code, where the older shadow root elements are reprojected and rendered inside the <code class="literal">&lt;fieldset&gt;</code> element, which belongs to the younger shadow root, that is, <code class="literal">shadowRoot1</code>.</p>
<div class="mediaobject"><img src="../Images/image00219.jpeg" alt="A shadow insertion point"/></div>
<p style="clear:both; height: 1em;"> </p>
</div>
</div>


<div class="section" title="Styling web components"><div class="titlepage" id="aid-KVCC2"><div><div><h1 class="title"><a id="ch01lvl1sec16"></a>Styling web components</h1>
</div>
</div>
</div>
<p>The way <a id="id117" class="indexterm"></a>we styled the HTML DOM elements earlier needs to be changed with the emergence of the web component specification. In this section, we will explore some of the key areas that need more focus while authoring CSS. We need to know some new pseudo element selectors for styling the web component. These <a id="id118" class="indexterm"></a>pseudo selectors are listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Unresolved pseudo selector</strong></span>: When <a id="id119" class="indexterm"></a>a custom element is loaded and registered with the DOM, the browser picks the matched element and upgrades it based on the defined lifecycle. During this upgradation process, the elements are exposed to the browser and appear as unstyled for a few moments. We can avoid the flash of unstyled content using the <code class="literal">:unresolved</code> pseudo class. An example of <code class="literal">unresolved</code> pseudo selector for the <code class="literal">&lt;header-message&gt;</code> custom element are listed here:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>header-message:unresolved</strong></span>:after {
   content: 'Registering Element...';
   color: red;
}</pre>
</div></li>
<li class="listitem"><span class="strong"><strong>Host pseudo selector</strong></span>: The <a id="id120" class="indexterm"></a>custom element itself can be referred using the <code class="literal">:host</code> pseudo selector to apply the <code class="literal">style</code> attribute. An example of the <code class="literal">host</code> selector is listed in the following code:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>:host</strong></span>{
   text-transform: uppercase;
}</pre>
</div></li>
<li class="listitem"><span class="strong"><strong>Shadow pseudo selector</strong></span>: The <a id="id121" class="indexterm"></a>Shadow DOM subtree of the custom element can be referred using the <code class="literal">::shadow</code> pseudo selector to apply the <code class="literal">style</code> attributes. An example of <code class="literal">shadow</code> selector is listed here:<div class="informalexample"><pre class="programlisting">:host <span class="strong"><strong>::shadow h1</strong></span>{
   color: orange;
}</pre>
</div></li>
<li class="listitem"><span class="strong"><strong>Content pseudo selector</strong></span>: The <a id="id122" class="indexterm"></a>content of the older insertion point element can be referred using the <code class="literal">::content</code> pseudo selector to apply the <code class="literal">style</code> attributes. An example of <code class="literal">content</code> selector is listed in the following code:<div class="informalexample"><pre class="programlisting">:host <span class="strong"><strong>::content b</strong></span>{
    color: blue;
}</pre>
</div></li>
</ul>
</div>
<p>Let's <a id="id123" class="indexterm"></a>check out a simple example to demonstrate the aforementioned pseudo selectors. The following code creates a custom element named <code class="literal">&lt;header-element&gt;</code>. To show the use of the <code class="literal">:unresolved</code> pseudo selector, we delayed registering the custom element for 3 seconds using the <code class="literal">window.setTimeOut</code> method.</p>
<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Web Component: Unresolved pseudo selector&lt;/title&gt;
    &lt;style&gt;
        <span class="strong"><strong>header-element:unresolved{</strong></span>
<span class="strong"><strong>            visibility: hidden;</strong></span>
<span class="strong"><strong>        }</strong></span>
<span class="strong"><strong>        header-element:unresolved:after {</strong></span>
<span class="strong"><strong>            content: 'Registering Element...';</strong></span>
<span class="strong"><strong>            color: red;</strong></span>
<span class="strong"><strong>            visibility: visible;</strong></span>
<span class="strong"><strong>        }</strong></span>
    &lt;/style&gt;
    &lt;template id="headerTemplate"&gt;
        &lt;style&gt;
            <span class="strong"><strong>:host {</strong></span>
<span class="strong"><strong>                text-transform: uppercase;</strong></span>
<span class="strong"><strong>            }</strong></span>
<span class="strong"><strong>            :host::shadow h1{</strong></span>
<span class="strong"><strong>                color:orange;</strong></span>
<span class="strong"><strong>            }</strong></span>
<span class="strong"><strong>            :host ::content b{</strong></span>
<span class="strong"><strong>                font-style: italic;</strong></span>
<span class="strong"><strong>                color:blue;</strong></span>
<span class="strong"><strong>            }</strong></span>
        &lt;/style&gt;
        <span class="strong"><strong>&lt;h1&gt;Hello &lt;content&gt;&lt;/content&gt;&lt;/h1&gt;</strong></span>
    &lt;/template&gt;
    &lt;script&gt;
        (function(){
            var objectPrototype = Object.create(HTMLElement.prototype);
            objectPrototype.createdCallback=function(){
                var shadow = this.createShadowRoot(),
                    templateContent = document.querySelector('#headerTemplate').content,
                    templateNodes = document.importNode(templateContent, true);
                shadow.appendChild(templateNodes);
            };
            <span class="strong"><strong>window.setTimeout(function(){</strong></span>
<span class="strong"><strong>                document.registerElement("header-element",{</strong></span>
<span class="strong"><strong>                    prototype:objectPrototype</strong></span>
<span class="strong"><strong>                });</strong></span>
<span class="strong"><strong>            }, 3000);</strong></span>
        })();
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    <span class="strong"><strong>&lt;header-element&gt;</strong></span>
<span class="strong"><strong>        &lt;b&gt;Web Component&lt;/b&gt;</strong></span>
<span class="strong"><strong>    &lt;/header-element&gt;</strong></span>
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>The details of the preceding code are listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The registration process of the custom element is delayed on purpose for 3 seconds. During this time, the element becomes <code class="literal">HTMLUnknownElement</code>. We used the <code class="literal">:unresolved</code> pseudo selector to show a <span class="strong"><strong>Registering Element…</strong></span> message during this time in the color red.</li>
<li class="listitem">Once the element is registered, the custom element becomes resolved (<code class="literal">HTMLElement</code>). In the <code class="literal">createdCallback</code> lifecycle method, we created a shadow root appended as a child.</li>
<li class="listitem">The template of <code class="literal">&lt;header-element&gt;</code> is present inside the <code class="literal">&lt;template&gt;</code> element with the <code class="literal">headerTemplate</code> ID. The template is then activated using the <code class="literal">document.importNode</code> method, which are added as children of the preceding shadow root.</li>
<li class="listitem">The host DOM tree is referred using the <code class="literal">:host</code> pseudo selector, which has a <code class="literal">style</code> attribute in order to transform the text into capital letters.</li>
<li class="listitem">The Shadow DOM tree is referred using the <code class="literal">::shadow</code> pseudo selector, which has a <code class="literal">style</code> attribute to change the text color to orange.</li>
<li class="listitem">The template also has the <code class="literal">&lt;content&gt;</code> element, which selects the original children of <code class="literal">&lt;header-element&gt;</code> and puts it into this location. In our example, the children are wrapped around the <code class="literal">&lt;b&gt;</code> tag. We referred this <code class="literal">&lt;b&gt;</code> element using the content selector to apply the <code class="literal">style</code> attribute so as to make the text color <code class="literal">blue</code> and the text type <code class="literal">italic</code>.</li>
</ul>
</div>
<p>The <a id="id124" class="indexterm"></a>following screenshot shows the output of the preceding code with the <code class="literal">:unresolved</code> pseudo selector style in effect for the first 3 seconds. We can see the message in red.</p>
<div class="mediaobject"><img src="../Images/image00220.jpeg" alt="Styling web components"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>Once the <a id="id125" class="indexterm"></a>element is registered to the DOM, the lifecycle method gets executed and <code class="literal">&lt;header-element&gt;</code> gets upgraded with its Shadow DOM. The following screenshot shows the final output of the preceding code:</p>
<div class="mediaobject"><img src="../Images/image00221.jpeg" alt="Styling web components"/></div>
<p style="clear:both; height: 1em;"> </p>
</div>


<div class="section" title="Building a digital clock component" id="aid-LTSU1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"></a>Building a digital clock component</h1>
</div>
</div>
</div>
<p>In <a id="id126" class="indexterm"></a>this section, we will build a simple digital clock element. The motive behind building a custom component is to implement the template, HTML Imports, Shadow DOM, and custom element to a real-time example. The definition of the digital clock component is present in the <code class="literal">clock-element.html</code> file, and the use of the digital clock component is present in the <code class="literal">clock-demo.html</code> file. The <code class="literal">clock-element.html</code> file has two sections. These are listed as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Clock template</li>
<li class="listitem">Clock element registration script</li>
</ul>
</div>
<div class="section" title="Clock template"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"></a>Clock template</h2>
</div>
</div>
</div>
<p>The <a id="id127" class="indexterm"></a>digital clock template contains the HTML markup and the CSS styles for rendering in the browser on activation. The HTML template code and the CSS styles for the clock component are listed in the following code:</p>
<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&lt;template id="clockTemplate</strong></span>"&gt;
    &lt;style&gt;
        <span class="strong"><strong>:host::shadow .clock</strong></span> {
            display: inline-flex;
            justify-content: space-around;
            background: white;
            font-size: 8rem;
            box-shadow: 2px 2px 4px -1px grey;
            border: 1px solid green;
            font-family: Helvetica, sans-serif;
            width: 100%;
        }
        <span class="strong"><strong>:host::shadow .clock .hour,</strong></span>
<span class="strong"><strong>        :host::shadow .clock .minute,</strong></span>
<span class="strong"><strong>        :host::shadow .clock .second </strong></span>{
            color: orange;
            padding: 1.5rem;
            text-shadow: 0px 2px black;
        }
    &lt;/style&gt;
    <span class="strong"><strong>&lt;div class="clock"&gt;</strong></span>
<span class="strong"><strong>        &lt;div class="hour"&gt;HH&lt;/div&gt;</strong></span>
<span class="strong"><strong>        &lt;div class="minute"&gt;MM&lt;/div&gt;</strong></span>
<span class="strong"><strong>        &lt;div class="second"&gt;SS&lt;/div&gt;</strong></span>
<span class="strong"><strong>    &lt;/div&gt;</strong></span>
<span class="strong"><strong>&lt;/template&gt;</strong></span>
</pre>
</div>
<p>A detailed explanation of the preceding code is listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The content of the clock element is present inside the <code class="literal">&lt;template&gt;</code> element. The ID of the template element is <code class="literal">clockTemplate</code>.</li>
<li class="listitem">This template contains two section styles and HTML markup.</li>
<li class="listitem">All the CSS style classes are wrapped around the <code class="literal">&lt;style&gt;</code> element. The host clock element is targeted using the <code class="literal">:host</code> pseudo selector, and its shadow tree children are targeted using the <code class="literal">::shadow</code> pseudo attribute and the styles are applied.</li>
<li class="listitem">The HTML markup <a id="id128" class="indexterm"></a>for the clock element is wrapped around the <code class="literal">div</code> element .The parent <code class="literal">div</code> element has the <code class="literal">.clock</code> class. The parent <code class="literal">div</code> element has the three children <code class="literal">div</code> element representing hours, minutes, and seconds.</li>
</ul>
</div>
</div>
<div class="section" title="Clock element registration script"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"></a>Clock element registration script</h2>
</div>
</div>
</div>
<p>The <a id="id129" class="indexterm"></a>clock component registration script is present in the <code class="literal">clock-element.html</code> file and is wrapped around a self-invoking anonymous function. The JavaScript code to create and register a clock component is listed in the following code:</p>
<div class="informalexample"><pre class="programlisting">&lt;script&gt;
    (function() {
        var selfDocument = <span class="strong"><strong>document.currentScript.ownerDocument</strong></span>,
            objectPrototype = <span class="strong"><strong>Object.create(HTMLElement.prototype)</strong></span>;
        objectPrototype.<span class="strong"><strong>createdCallback</strong></span> = function() {
            var shadow = this.<span class="strong"><strong>createShadowRoot</strong></span>(),
                templateContent = selfDocument.querySelector('#clockTemplate').content,
                templateNodes = <span class="strong"><strong>document.importNode</strong></span>(templateContent, true),
                hourElement = null,
                minuteElement = null,
                secondElement = null;
            shadow.appendChild(templateNodes);
            hourElement = shadow.querySelector('.hour'),
                    minuteElement = shadow.querySelector('.minute'),
                    secondElement = shadow.querySelector('.second');
            window.setInterval(function() {
                var date = new Date();
                hourElement.innerText = date.getHours();
                minuteElement.innerText = date.getMinutes();
                secondElement.innerText = date.getSeconds();
            }, 1000);
        };
        var digitalClockElement = <span class="strong"><strong>document.registerElement("digital-clock", {</strong></span>
<span class="strong"><strong>            prototype: objectPrototype</strong></span>
<span class="strong"><strong>        });</strong></span>
    })();
&lt;/script&gt;</pre>
</div>
<p>The details of the preceding code are listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The script for registering the clock element is embedded inside a self-calling function, which saves the reference to the current owner document to <code class="literal">selfDocument</code> variable using <code class="literal">document.currentScript.ownerDocument</code>.</li>
<li class="listitem">A new object is<a id="id130" class="indexterm"></a> created using the <code class="literal">Object.create</code> method. The prototype of this new object is <code class="literal">HTMLElement.prototype</code>. The reference of this new object is saved in the <code class="literal">objectPrototype</code> variable.</li>
<li class="listitem">The <code class="literal">createdCallback</code> lifecycle method of the host element is overloaded with the following steps:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A new <code class="literal">shadowRoot</code> object is created for the host element using the <code class="literal">createShadowRoot</code> method. Reference to this <code class="literal">shadowRoot</code> is then saved to the <code class="literal">shadow</code> variable.</li>
<li class="listitem">The template content of the clock element is then retrieved using the <code class="literal">selfDocument</code> reference variable.</li>
<li class="listitem">The inert content of the clock template is then activated using the <code class="literal">document.importNode</code> method.</li>
<li class="listitem">The activated template contents are then added as children to the host's shadow root.</li>
<li class="listitem">Using <code class="literal">window.setInterval()</code>, a block of code is called every 1 second. The purpose of this code block is to get the hours, minutes, and seconds of the current time and update the DOM repeatedly every second.</li>
</ul>
</div></li>
<li class="listitem">The clock element is then registered with the DOM using the <code class="literal">document.registerElement</code> method. After registering, the clock component is now ready for use.</li>
</ul>
</div>
</div>
</div>


<div class="section" title="Using the clock component" id="aid-MSDG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec18"></a>Using the clock component</h1>
</div>
</div>
</div>
<p>In the<a id="id131" class="indexterm"></a> previous section, we developed the clock component that is present inside the <code class="literal">clock-element.html</code> file. In this section, we will import the clock element and use it in the markup to render in the browser. The code to use clock component is present in the <code class="literal">clock-demo.html</code> file and is listed here:</p>
<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Web Component : digital clock element&lt;/title&gt;
    <span class="strong"><strong>&lt;link rel="import" href="clock-element.html"&gt;</strong></span>
&lt;/head&gt;
&lt;body&gt;
    <span class="strong"><strong>&lt;digital-clock&gt;&lt;/digital-clock&gt;</strong></span>
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>In the <a id="id132" class="indexterm"></a>preceding code, the clock component is imported using the <code class="literal">link</code> element with the <code class="literal">rel</code> attribute, which has the <code class="literal">import</code> value. The digital clock component can be implemented using the <code class="literal">&lt;digital-clock&gt;&lt;/digital-clock&gt;</code> custom element. The output of the preceding code is shown in the following screenshot:</p>
<div class="mediaobject"><img src="../Images/image00222.jpeg" alt="Using the clock component"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>The preceding screenshot shows the digital clock component. The numbers in the screenshot are showing <span class="emphasis"><em>hours</em></span> (HH), <span class="emphasis"><em>minutes</em></span> (MM), and <span class="emphasis"><em>seconds</em></span> (SS). The following screenshot shows the developer console of the clock component:</p>
<div class="mediaobject"><img src="../Images/image00223.jpeg" alt="Using the clock component"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>The<a id="id133" class="indexterm"></a> details of the preceding screenshot are listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The clock element is imported to the current page and has its own <code class="literal">#document</code> root</li>
<li class="listitem">The digital clock element has its Shadow DOM tree, which is rendered as a clock</li>
</ul>
</div>
</div>


<div class="section" title="X-Tag"><div class="titlepage" id="aid-NQU22"><div><div><h1 class="title"><a id="ch01lvl1sec19"></a>X-Tag</h1>
</div>
</div>
</div>
<p>The X-Tag<a id="id134" class="indexterm"></a> is a small JavaScript library for web component development by Mozilla. This library is built on the web component polyfill from Polymer team. The Mozilla Bricks framework is built on top of the X-Tag library. We can download the X-Tag library<a id="id135" class="indexterm"></a> using <a class="ulink" href="http://www.x-tags.org/download">http://www.x-tags.org/download</a>.</p>
<div class="section" title="X-Tag element lifecycle"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"></a>X-Tag element lifecycle</h2>
</div>
</div>
</div>
<p>Every X-Tag element <a id="id136" class="indexterm"></a>has a lifecycle. An element state is decided based on the event that is fired during state transition. An element during its lifecycle goes through the following states (event fired):</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">created</code>: This <a id="id137" class="indexterm"></a>event is fired by the element when it is initially created.</li>
<li class="listitem"><code class="literal">inserted</code>: This <a id="id138" class="indexterm"></a>event is fired by the element when it is inserted into the DOM for first time.</li>
<li class="listitem"><code class="literal">removed</code>: This <a id="id139" class="indexterm"></a>event is fired by the element when it is removed from the DOM.</li>
<li class="listitem"><code class="literal">attributeChanged</code>: This <a id="id140" class="indexterm"></a>event is fired when any of the property values of the element is changed.</li>
</ul>
</div>
<p>The lifecycle of the element can be defined inside the <code class="literal">lifecycle</code> attribute. The following code shows the syntax of the <code class="literal">lifecycle</code> attribute:</p>
<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>lifecycle:{</strong></span>
  <span class="strong"><strong>created</strong></span>: function(){
    // code for created state
  },
  <span class="strong"><strong>inserted</strong></span>: function(){
    // code for inserted state
  },
  <span class="strong"><strong>removed</strong></span>: function(){
    // code for removed state
  },
  <span class="strong"><strong>attributeChanged</strong></span>: function(){
    // code for attributeChanged state
  }
}</pre>
</div>
</div>
<div class="section" title="X-Tag custom element development"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"></a>X-Tag custom element development</h2>
</div>
</div>
</div>
<p>A <a id="id141" class="indexterm"></a>custom X-Tag element <a id="id142" class="indexterm"></a>can be created using the <code class="literal">xtag.register</code> method. The X-Tag core library code is present inside the <code class="literal">x-tag-components.js</code> file.</p>
<div class="note" title="Note"><h3 class="title"><a id="note09"></a>Note</h3>
<p>The <a id="id143" class="indexterm"></a>X-Tag core library source code can be downloaded by visiting:</p>
<p>
<a class="ulink" href="https://github.com/x-tag/core">https://github.com/x-tag/core</a>
</p>
</div>
<p>The <code class="literal">xtag.register</code> method has the following syntax:</p>
<div class="informalexample"><pre class="programlisting">xtag.register('&lt;element-name&gt;', {
    <span class="strong"><strong>lifecycle</strong></span>: {
        <span class="strong"><strong>created</strong></span>: function() {
            // code for created state
        },
        <span class="strong"><strong>inserted</strong></span>: function() {
            // code for inserted state
        },
        <span class="strong"><strong>removed</strong></span>: function() {
            // code for removed state
        },
        <span class="strong"><strong>attributeChanged</strong></span>: function() {
            // code for attributeChanged state
        }
    },
    <span class="strong"><strong>accessors</strong></span>: { 
&lt;property name&gt; : {
            <span class="strong"><strong>attribute</strong></span>: {
                //type and value of the property
            }
        }
    },
    <span class="strong"><strong>methods</strong></span>: { 
&lt;method name&gt; : function() {
            //Code for the method
        }
    },
    <span class="strong"><strong>events</strong></span>: {
        '&lt;event type&gt;:<span class="strong"><strong>delegate</strong></span>(&lt;element&gt;)': function(e) {
            //Code for event handler
        }
    }
});</pre>
</div>
<p>The <a id="id144" class="indexterm"></a>details <a id="id145" class="indexterm"></a>of the preceding syntax are listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">lifecycle</code>: This <a id="id146" class="indexterm"></a>property can have code for all states during the lifecycle of the element. Therefore, we can define its logic for the custom elements by implementing the <code class="literal">created</code>, <code class="literal">inserted</code>, <code class="literal">removed</code>, and <code class="literal">attributeChanged</code> state.</li>
<li class="listitem"><code class="literal">methods</code>: This<a id="id147" class="indexterm"></a> property can have all the methods that need to be exposed as a public API that is to be consumed externally.</li>
<li class="listitem"><code class="literal">events</code>: This <a id="id148" class="indexterm"></a>property can have all the element's event binding listeners that need to be fired based on the user action of the custom element.</li>
<li class="listitem"><code class="literal">accessors</code>: This <a id="id149" class="indexterm"></a>property can have all the attributes that need the getter and setters methods.</li>
</ul>
</div>
<p>Now, it is <a id="id150" class="indexterm"></a>time to create a custom component using this <a id="id151" class="indexterm"></a>X-Tag library. The code for creating an X-Tag base custom element is as follows:</p>
<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Web Component: xTag custom element support&lt;/title&gt;
  &lt;script src=<span class="strong"><strong>"x-tag-components.js</strong></span>"&gt;&lt;/script&gt;
  &lt;script&gt;
<span class="strong"><strong>    (function() {</strong></span>
<span class="strong"><strong>      xtag.register('italic-string', {</strong></span>
<span class="strong"><strong>        lifecycle: {</strong></span>
<span class="strong"><strong>          created: function() {</strong></span>
<span class="strong"><strong>            this.innerHTML = "&lt;i style='color:" + this.textColor + "'&gt;" + this.innerHTML + "&lt;/i&gt;";</strong></span>
<span class="strong"><strong>          }</strong></span>
<span class="strong"><strong>        },</strong></span>
<span class="strong"><strong>        accessors: {</strong></span>
<span class="strong"><strong>          textColor: {</strong></span>
<span class="strong"><strong>            attribute: {object: this.textColor}</strong></span>
<span class="strong"><strong>          }</strong></span>
<span class="strong"><strong>        },</strong></span>
<span class="strong"><strong>        methods: {</strong></span>
<span class="strong"><strong>          changeToRed: function() {</strong></span>
<span class="strong"><strong>            var italicElement = this.querySelector("i");</strong></span>
<span class="strong"><strong>            italicElement.style.color = "red";</strong></span>
<span class="strong"><strong>          }</strong></span>
<span class="strong"><strong>        },</strong></span>
<span class="strong"><strong>        events: {</strong></span>
<span class="strong"><strong>          'click:delegate(i)': function(e) {</strong></span>
<span class="strong"><strong>            console.log("click event is fired.");</strong></span>
<span class="strong"><strong>          }</strong></span>
<span class="strong"><strong>        }</strong></span>
<span class="strong"><strong>      });})();</strong></span>
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  <span class="strong"><strong>&lt;italic-string id="iStringComponent" textColor="blue"&gt;</strong></span>
<span class="strong"><strong>    Click Me</strong></span>
<span class="strong"><strong>  &lt;/italic-string&gt;&lt;br&gt;</strong></span>
<span class="strong"><strong>  &lt;button onclick="doColorRed()"&gt;Make Red&lt;/button&gt;</strong></span>
  &lt;script&gt;
<span class="strong"><strong>    var doColorRed = function() {</strong></span>
<span class="strong"><strong>      var italicStringElement = document.getElementById("iStringComponent");</strong></span>
<span class="strong"><strong>      italicStringElement.changeToRed();</strong></span>
<span class="strong"><strong>    }</strong></span>
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>The <a id="id152" class="indexterm"></a>details <a id="id153" class="indexterm"></a>of the preceding code are listed here:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A custom X-Tag-based element named <code class="literal">italic-string</code> is created by the <code class="literal">xtag.register</code> method.</li>
<li class="listitem">This custom element takes the <code class="literal">innerHTML</code> content and wraps it with a <code class="literal">&lt;i&gt;</code> element, which gives it an italic style font.</li>
<li class="listitem">This custom element has a <code class="literal">textColor</code> property name, where a color string can be given. The value of the <code class="literal">textColor</code> property is then applied to the <code class="literal">style</code> property of the <code class="literal">&lt;i&gt;</code> element.</li>
<li class="listitem">The <code class="literal">textColor</code> property is created using the <code class="literal">accessors</code> property. This <code class="literal">accessors</code> property takes the attributes that need to be configured to the <code class="literal">italic-string</code> element.</li>
<li class="listitem">An event listener is created using the <code class="literal">events</code> property. In the preceding code a <code class="literal">click</code> event type listener is attached to the <code class="literal">&lt;i&gt;</code> element. When the <code class="literal">&lt;i&gt;</code> element is clicked on, it shows a message in the console.</li>
<li class="listitem">A method can be defined using the <code class="literal">methods</code> property. There is a method callback <code class="literal">changedToRed()</code> that can be accessed as an API. This callback method has used <code class="literal">document.getElementById()</code> to locate the X-Tag custom element with the <code class="literal">iStringComponent</code> (the <code class="literal">italic-string</code> component). It then finds and changes the <code class="literal">color</code> style attribute of the <code class="literal">&lt;i&gt;</code> element to <code class="literal">Red</code>. A button's <code class="literal">onclick</code> method is attached with a <code class="literal">doColorRed</code> JavaScript function, which in turn calls the <code class="literal">changeToRed</code> method.</li>
</ul>
</div>
<p>The output of the preceding code looks like the following screenshot. It has the <span class="strong"><strong>Click Me</strong></span> text and a <span class="strong"><strong>Make Red</strong></span> button rendered in the browser:</p>
<div class="mediaobject"><img src="../Images/image00224.jpeg" alt="X-Tag custom element development"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>When user<a id="id154" class="indexterm"></a> clicks on the <span class="strong"><strong>Make Red</strong></span> button, the <span class="strong"><strong>Click Me</strong></span> text will change to red in color. The following screenshot shows the <span class="strong"><strong>Click Me</strong></span> text changed to red:</p>
<div class="mediaobject"><img src="../Images/image00225.jpeg" alt="X-Tag custom element development"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>If the user <a id="id155" class="indexterm"></a>clicks on the <span class="strong"><strong>Click Me</strong></span> text, then the event handler attached with it gets executed and prints the message. The following screenshot shows the console log message when the user clicks on the X-Tag element:</p>
<div class="mediaobject"><img src="../Images/image00226.jpeg" alt="X-Tag custom element development"/></div>
<p style="clear:both; height: 1em;"> </p>
<div class="note" title="Note"><h3 class="title"><a id="note10"></a>Note</h3>
<p>To know more about X-Tag library use the following link:</p>
<p>
<a class="ulink" href="http://www.x-tags.org/docs">http://www.x-tags.org/docs</a>
</p>
</div>
<p>Web component <a id="id156" class="indexterm"></a>specification is not completely implemented by the browsers. However, there are many libraries with polyfill support for web components <a id="id157" class="indexterm"></a>that exist. In this section, we will list the libraries, and get a quick introduction to them. Some of the most popular libraries are listed here:</p>
</div>
<div class="section" title="Polymer"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec25"></a>Polymer</h2>
</div>
</div>
</div>
<p>Polymer <a id="id158" class="indexterm"></a>is<a id="id159" class="indexterm"></a> the web component library from Google Inc. This library allows a web developer to compose CSS, HTML, and JavaScript to build rich, powerful, and reusable web component. In <a class="link" title="Chapter&#160;2.&#160;Introducing Polymer" href="lrn-web-cmpn-dev_ch02.html#aid-PNV61">Chapter 2</a>, <span class="emphasis"><em>Introducing Polymer</em></span> and <a class="link" title="Chapter&#160;3.&#160;Developing Web Components Using Polymer" href="lrn-web-cmpn-dev_ch03.html#aid-VF2I1">Chapter 3</a>, <span class="emphasis"><em>Developing Web Components Using Polymer</em></span>, we will learn more about this library.</p>
<div class="note" title="Note"><h3 class="title"><a id="note11"></a>Note</h3>
<p>To find out more about <a id="id160" class="indexterm"></a>Polymer library use the following link:</p>
<p>
<a class="ulink" href="https://www.polymer-project.org">https://www.polymer-project.org</a>
</p>
</div>
</div>
<div class="section" title="Mozilla Brick"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec26"></a>Mozilla Brick</h2>
</div>
</div>
</div>
<p>Mozilla Brick <a id="id161" class="indexterm"></a>is another <a id="id162" class="indexterm"></a>web component library from Mozilla. It has a collection of reusable UI components to be used in web application. The current version of this library is 2.0. In <a class="link" title="Chapter&#160;5.&#160;Developing Web Components Using Mozilla Brick" href="lrn-web-cmpn-dev_ch05.html#aid-1IHDQ1">Chapter 5</a>, <span class="emphasis"><em>Developing Web Components Using Mozilla Brick</em></span>, we will learn more about this library.</p>
<div class="note" title="Note"><h3 class="title"><a id="note12"></a>Note</h3>
<p>To find out more <a id="id163" class="indexterm"></a>about Mozilla Brick library use the following link:</p>
<p>
<a class="ulink" href="http://brick.readme.io/v2.0">http://brick.readme.io/v2.0</a>
</p>
</div>
</div>
<div class="section" title="ReactJS"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec27"></a>ReactJS</h2>
</div>
</div>
</div>
<p>The ReactJS is a <a id="id164" class="indexterm"></a>library <a id="id165" class="indexterm"></a>for web component development from Facebook. This library takes a different approach to build the web application. In <a class="link" title="Chapter&#160;6.&#160;Building Web Components with ReactJS" href="lrn-web-cmpn-dev_ch06.html#aid-1R42S1">Chapter 6</a>, <span class="emphasis"><em>Building Web Components with ReactJS</em></span>, we will learn more about the ReactJS library.</p>
<div class="note" title="Note"><h3 class="title"><a id="note13"></a>Note</h3>
<p>To find out more <a id="id166" class="indexterm"></a>about ReactJS library, use the following link:</p>
<p>
<a class="ulink" href="http://facebook.github.io/react">http://facebook.github.io/react</a>
</p>
</div>
</div>
<div class="section" title="Bosonic"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec28"></a>Bosonic</h2>
</div>
</div>
</div>
<p>Bosonic<a id="id167" class="indexterm"></a> is<a id="id168" class="indexterm"></a> another library for web component development. It uses some of the PolymerJS polyfill in the core. In <a class="link" title="Chapter&#160;4.&#160;Exploring Bosonic Tools for Web Component Development" href="lrn-web-cmpn-dev_ch04.html#aid-19UOO1">Chapter 4</a>, <span class="emphasis"><em>Exploring Bosonic Tools for Web Component Development</em></span>, we will explore more details about Bosonic.</p>
<div class="note" title="Note"><h3 class="title"><a id="note14"></a>Note</h3>
<p>To find out more about the<a id="id169" class="indexterm"></a> Bosonic library, use the following link:</p>
<p>
<a class="ulink" href="http://bosonic.github.io/index.html">http://bosonic.github.io/index.html</a>
</p>
</div>
</div>
</div>


<div class="section" title="Summary" id="aid-OPEK1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec20"></a>Summary</h1>
</div>
</div>
</div>
<p>In this chapter, we learned about the web component specification. We also explored the building blocks of web components such as Shadow DOM, custom element, HTML Imports, and templates. In the next chapter, we will learn about the PolymerJS library in detail.</p>
</div>
</body>
</html>