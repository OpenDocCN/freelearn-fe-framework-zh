- en: '*Chapter 6*: Use Memo to Boost Performance'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：使用Memo提升性能'
- en: 'In the previous chapter, we learned how the `useEffect` hook is designed and
    how to use it to manage a side effect in *React*. In this chapter, we will change
    to an optimization topic for reusing the last assignment. We will first introduce
    how we can run into performance degradation in a typical web application. Then,
    we will walk through the design and source code behind `useMemo` and describe
    various ways of reusing a value conditionally. We''ll then apply the optimization
    technique to two common cases: clicking to search and debouncing the search. At
    the end, the chapter also includes two bonus topics in the *Appendix* section,
    *Not a Classical Memorization* and *Skipping a Child Update*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了`useEffect`钩子的设计和如何使用它来管理*React*中的副作用。在本章中，我们将转向一个优化主题，用于重用最后的赋值。我们首先介绍我们如何在典型的Web应用程序中遇到性能下降。然后，我们将详细介绍`useMemo`的设计和源代码，并描述各种条件重用值的多种方式。接着，我们将优化技术应用于两个常见案例：点击搜索和搜索防抖。最后，本章还包括附录部分的两个附加主题，*非经典记忆*和*跳过子组件更新*。
- en: 'We will cover the following main topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Performance degradation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能下降
- en: Understanding the `useMemo` design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`useMemo`的设计
- en: Reusing a last assignment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重用最后的赋值
- en: Test-Driving `useMemo`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动`useMemo`
- en: '`useMemo` examples'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useMemo`示例'
- en: Questions and answers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问答
- en: Appendix
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附录
- en: Performance degradation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能下降
- en: When we build a site, we normally start it with a draft or prototype version
    where a couple of pages are laid out with the sample data and the preliminary
    logic. The idea is to start small and see whether the site has any potential to
    grow. Though this is a very common approach, interestingly, most of the performance-related
    issues do not show up at this point. When the site with the real business logic
    grows, we start to experience performance degradation issues. Understanding how
    these issues are created in the first place is valuable since it helps us plan
    for the growth of the site.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建一个网站时，我们通常从一个草案或原型版本开始，其中包含一些页面，这些页面使用示例数据和初步逻辑进行布局。目的是从小处着手，看看网站是否有增长潜力。虽然这是一个非常常见的做法，但有趣的是，大多数与性能相关的问题在这个阶段并没有显现出来。当具有真实业务逻辑的网站开始增长时，我们开始体验到性能下降的问题。了解这些问题最初是如何产生的非常有价值，因为它有助于我们规划网站的扩展。
- en: 'Let''s build such a case from scratch. A variable defined inside the body of
    a function component is evaluated when it gets invoked:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从零开始构建这样一个案例。一个在函数组件体内定义的变量在其被调用时会被评估：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, the `a` variable is assigned with a `1` constant. Storing
    a number like this shouldn't cost us much when `a` is reassigned every time when
    the `text` prop changes. But what if we need to calculate something heavy, such
    as matching a text in a large array?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`a`变量被赋值为一个`1`常量。当`text`属性每次变化时，存储这样的数字不应该花费我们太多，因为`a`每次都会被重新赋值。但如果我们需要计算一些重量级的操作，比如在一个大数组中匹配文本呢？
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Say the preceding `matchTextInArray` function takes an average of 200 *milliseconds*
    to complete, which is a bit costly. We can argue that the `found` variable only
    gets assigned when `text` changes, so if `text` doesn't get changed often, we
    don't have to worry about `found` getting assigned too often. Let's ponder over
    this a bit.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前面的`matchTextInArray`函数平均需要200 *毫秒*来完成，这有点昂贵。我们可以争辩说，只有当`text`发生变化时，`found`变量才会被赋值，所以如果`text`不经常变化，我们不必担心`found`会频繁赋值。让我们对此进行一些思考。
- en: A function component can be invoked for various reasons. In *React*, the update
    of a function component is mostly triggered by a state change. However, the state
    could be from inside the `Title` component or from the parent (or grandparent)
    of the `Title` component. Therefore, we can't just assume the update frequency
    of a component by looking at it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组件可以因各种原因被调用。在*React*中，函数组件的更新主要是由状态变化触发的。然而，状态可能来自`Title`组件内部或来自`Title`组件的父组件（或祖父组件）。因此，我们不能仅仅通过观察组件来假设组件的更新频率。
- en: Just imagine if the user decides to refresh the page; it should cause all the
    components of this page to update. In a way, the component can only determine
    what gets updated but can't entirely decide when it gets updated. In other words,
    when it comes to the update, the component also depends on its parent's behavior.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果用户决定刷新页面；它应该导致此页面的所有组件更新。从某种意义上说，组件只能确定哪些内容需要更新，但不能完全决定何时更新。换句话说，当涉及到更新时，组件也依赖于其父组件的行为。
- en: 'Let''s take a look at the following example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, the `Title` component gets another `flag` prop. Thus,
    whenever the `flag` prop flips, it renders and spends 200 milliseconds on calculating
    `a`. You can imagine the flag as a user voting button from a parent component.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Title` 组件获得了一个额外的 `flag` 属性。因此，每当 `flag` 属性翻转时，它就会渲染并花费200毫秒来计算 `a`。你可以想象这个标志就像是一个来自父组件的用户投票按钮。
- en: If the user keeps clicking the button, multiple 200 milliseconds can quickly
    stack up to become a second or two, and the performance of the app is essentially
    now tied directly to how quickly the user flips the flag. When this happens, to
    use a gaming term here, it causes a lag, or a frame drop. The user should start
    to feel a laggy response and lose confidence in using the site.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户持续点击按钮，多个200毫秒可以迅速累积成为一秒或两秒，应用程序的性能现在直接与用户翻旗的速度挂钩。当这种情况发生时，用游戏术语来说，它会导致延迟，或者帧率下降。用户应该开始感觉到响应延迟，并失去使用网站的信心。
- en: When this happens in a game, what do we do? Well, that's the time the gamer
    needs to upgrade their gaming hardware. But it could also be a time for developers
    to exploit an opportunity for optimization.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生在游戏中时，我们该怎么办？嗯，那正是玩家需要升级他们的游戏硬件的时候。但这也可能是开发者利用优化机会的时候。
- en: Reusing a previous assignment
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复使用之前的赋值
- en: 'So, what do we do in the situation of performance degradation? Let''s take
    a look at what we have following the current timeline. When either the `flag`
    or the `text` prop changes, the `found` variable gets a new assignment:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在性能下降的情况下，我们该怎么办？让我们看看当前时间线之后我们有什么。当 `flag` 或 `text` 属性发生变化时，`found` 变量会得到一个新的赋值：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, in our case, there's something we want to acknowledge, that is, the `matchTextInArray`
    does not even depend on the `flag` because the function doesn't take input arguments
    other than `text`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在我们的情况下，我们想要承认的是，`matchTextInArray` 并不依赖于 `flag`，因为该函数除了 `text` 之外没有其他输入参数。
- en: Why do we want to perform a new assignment when the previous assignment could
    still be valid? Can't we skip assignments when the `flag` prop changes?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们想在之前的赋值仍然有效时执行新的赋值？当 `flag` 属性变化时，我们能否跳过赋值？
- en: 'We learned in [*Chapter 5*](B17963_05_Epub.xhtml#_idTextAnchor157), *Use Effect
    to Handle Side Effects,* that an effect can be used to listen to a value change.
    In our case, can we listen to the `text` prop change to make an assignment while
    ignoring other values? Let''s give it a shot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第五章*](B17963_05_Epub.xhtml#_idTextAnchor157)，*使用 Effect 处理副作用* 中了解到，效果可以用来监听值的变化。在我们的情况下，我们能否监听
    `text` 属性的变化，在忽略其他值的同时进行赋值？让我们试一试：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, we use the dependency array from `useEffect` to act
    upon the `text` change and dispatch to update the `found` state after `matchTextInArray`.
    This is confirmed by the following timeline sketch:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `useEffect` 的依赖数组来对 `text` 变化做出反应，并在 `matchTextInArray` 之后更新 `found`
    状态。这可以通过以下时间线草图得到证实：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The solution works out of the box. The flag flips back and forth lots of times
    (six times), but we only have three new assignments due to the text change. Thus,
    the assignment isn't tied to the flip. This is wonderful because we manage to
    overcome potential performance degradation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案直接可用。标志来回翻转很多次（六次），但由于文本变化，我们只有三次新的赋值。因此，赋值并不依赖于翻转。这真是太好了，因为我们成功地克服了潜在的性能下降。
- en: Though the solution works, we would like to improve upon it because it uses
    a side effect to handle the assignment, and we can see this assignment doesn't
    have to be a side effect. Since a side effect gets collected later after the update,
    it must wait till the next update. This means the assignment behaves very differently
    from a direct assignment, such as `a = 1`. Last but not least, a `found` state
    is used to hold the assignment value, and the value does not have to be a state.
    It's better if we can address all these issues.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个解决方案是可行的，但我们希望对其进行改进，因为它使用副作用来处理赋值，而我们看到这个赋值不必是一个副作用。由于副作用在更新后收集，它必须等待下一次更新。这意味着赋值的行为与直接赋值，如
    `a = 1`，非常不同。最后但同样重要的是，使用 `found` 状态来保存赋值值，而这个值不必是一个状态。如果能解决所有这些问题就更好了。
- en: '*React* adds a `useMemo` hook to do exactly that without other hurdles. The
    job of the hook is to allow us to reuse the previous assignment in an update.
    Let''s take a look at the `useMemo` design first.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*React* 添加了一个 `useMemo` 钩子来做到这一点，而不需要其他障碍。钩子的任务是允许我们在更新中重用之前的赋值。让我们首先看看 `useMemo`
    的设计。'
- en: Understanding the useMemo design
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`useMemo`的设计
- en: 'React provides a `useMemo` hook to support a value assignment through a function
    that can either return a new value or an old value from the previous update:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: React提供了一个`useMemo`钩子，通过一个函数支持值赋值，该函数可以返回新值或从上一个更新返回旧值：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `useMemo` function takes a `create` function as its first input argument.
    This function returns a new value if invoked. The second parameter is a `deps`
    dependency array, similar to `deps` in `useEffect`. In the preceding case, `"Hello
    World"` is assigned to a `label` variable only once after the mount.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo`函数将其第一个输入参数作为`create`函数。如果被调用，该函数返回一个新值。第二个参数是`deps`依赖数组，类似于`useEffect`中的`deps`。在前面的例子中，`"Hello
    World"`在挂载后只被分配给`label`变量一次。'
- en: 'There''s no additional data structure required for `useMemo` other than the
    basic hook support, as shown in *Figure 6.1*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的钩子支持外，不需要额外的数据结构来支持`useMemo`，如图6.1所示：
- en: '![Figure 6.1 – Data structure for useMemo'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – useMemo的数据结构'
- en: '](img/Figure_6.1_B17963.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.1_B17963.jpg)'
- en: Figure 6.1 – Data structure for useMemo
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – useMemo的数据结构
- en: The hook's state persists between updates, and it's up to each hook function
    to define what (or in which format) it wants to persist. For instance, a `useState`
    hook stores a state array, a `useEffect` hook stores an effect object, and now
    a `useMemo` hook stores things related to an assignment. In fact, `useMemo` takes
    the form of the assigned value and the dependency array as `[value, deps]`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子的状态在更新之间持续存在，每个钩子函数都必须定义它想要持久化什么（或以何种格式）。例如，`useState`钩子存储状态数组，`useEffect`钩子存储效果对象，现在`useMemo`钩子存储与赋值相关的内容。实际上，`useMemo`采用分配值和依赖数组的格式作为`[value,
    deps]`。
- en: 'The source code of `useMemo` is structured with `mountMemo` and `updateMemo`
    in a typical hook setup, depending on whether the fiber is under mount or the
    update via the `isFiberMounting` flag, as explained in [*Chapter 3*](B17963_03_Epub.xhtml#_idTextAnchor080),
    *Hooking into React*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo`的源代码在典型的钩子设置中以`mountMemo`和`updateMemo`的形式组织，这取决于纤维是否处于挂载状态或通过`isFiberMounting`标志进行更新，如[第3章](B17963_03_Epub.xhtml#_idTextAnchor080)中所述，*Hooking
    into React*：'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `useMemo` hook accepts the `create` assignment function and the `deps` dependency
    array as inputs. The `name`, `create`, indicates that it creates a new value when
    it gets invoked.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo`钩子接受`create`赋值函数和`deps`依赖数组作为输入。`name`、`create`表示它在被调用时创建一个新值。'
- en: 'When under the mount, it first gets the hook object by creating one:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当处于挂载状态时，它首先通过创建一个来获取钩子对象：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If `deps` is not given at all, it's converted to `null` by default, and the
    initial value is stored by invoking the `create` assignment function. Before returning
    the value, both the initial value and its dependency are stored in the `state`
    property under the hook using an array.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供`deps`，则默认转换为`null`，并通过调用`create`赋值函数来存储初始值。在返回值之前，初始值及其依赖都通过数组存储在钩子下的`state`属性中。
- en: 'When under the update, it gets the hook by cloning one:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当处于更新状态时，它通过克隆一个来获取钩子：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once we have the hook, it gets `prevState` from the hook's `state`, which is
    an array of the previous value and the previous dependency array.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了钩子，它就从钩子的`state`中获取`prevState`，这是一个包含上一个值和上一个依赖数组的数组。
- en: 'It checks whether the dependency has changed with `areDepsEqual`. If there''s
    no change, it simply returns the previous value. And if there is a change, it
    invokes the `create` assignment function again to update into the new `value`.
    Before we return the value, both the value and the dependency are stored in the
    hook''s `state`. Here is the summarized `useMemo` workflow:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过`areDepsEqual`检查依赖是否已更改。如果没有变化，它将简单地返回上一个值。如果有变化，它将再次调用`create`赋值函数以更新到新`value`。在我们返回值之前，值和依赖都存储在钩子的`state`中。以下是`useMemo`工作流程的总结：
- en: '![Figure 6.2 – useMemo workflow'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – useMemo工作流程'
- en: '](img/Figure_6.2_B17963.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.2_B17963.jpg)'
- en: Figure 6.2 – useMemo workflow
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – useMemo工作流程
- en: Compared to `useState` and `useEffect`, `useMemo` is quite straightforward.
    It doesn't have any dispatch or effect involved. Instead, you can think of it
    as a special assignment statement. When the `deps` dependency is met, it then
    creates a value and returns it as the current value. In all cases, the current
    value is returned. So, to be precise, *an assignment is made in all cases; when
    the condition isn't met, an old value is reused*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `useState` 和 `useEffect` 相比，`useMemo` 非常直接。它不涉及任何分发或效果。相反，你可以将其视为一个特殊的赋值语句。当满足
    `deps` 依赖项时，它就会创建一个值并将其作为当前值返回。在所有情况下，都会返回当前值。因此，更准确地说，*在所有情况下都会进行赋值；当条件不满足时，会重用旧值*。
- en: Now that we know how `useMemo` is designed, let's walk you through all the scenarios
    that this special assignment can do.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 `useMemo` 的设计，现在就让我们带你了解这个特殊赋值可以做到的所有场景。
- en: Reusing a last assignment
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用最后一个赋值
- en: Reusing a value and memorizing a value sometimes refer to similar behavior.
    However, it's worth noting that the `useMemo` hook can only remember one value
    from the past, the last value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重用值和记住值有时会指相似的行为。然而，值得注意的是，`useMemo` 钩子只能记住过去的一个值，即最后一个值。
- en: A single *JavaScript* variable, by default, serves a purpose that, unless overwritten
    by a new assignment, holds the previously assigned value. So, take caution when
    reading the word "memo" here. If you take the word "memo" as a single value instead
    of memorizing all values, it could help you visualize it the right way as *React*
    designed it. If you are interested in classical memorization, check out the *Appendix
    A – Not a classical memorization* section at the end of this chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，单个 *JavaScript* 变量具有一个作用，除非被新的赋值覆盖，否则它将保留之前分配的值。因此，在阅读“memo”这个词时要小心。如果你将“memo”视为单个值而不是记住所有值，那么它可以帮助你正确地可视化它，就像
    *React* 设计的那样。如果你对经典记忆感兴趣，请查看本章末尾的 *附录A – 非经典记忆* 部分。
- en: How `useMemo` reuses the previous assignment is controlled by a `deps` dependency
    array, and it uses the `areDepsEqual` utility function to compare two dependency
    arrays between the previous and current update. We have already examined this
    function in [*Chapter 5*](B17963_05_Epub.xhtml#_idTextAnchor157), *Use Effect
    to Handle Side Effects*. We will skip the source code here and jump straight to
    the scenarios that correspond to each dependency array configuration.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo` 如何重用之前的赋值是由 `deps` 依赖项数组控制的，它使用 `areDepsEqual` 工具函数来比较前一次和当前更新之间的两个依赖项数组。我们已经在
    [*第五章*](B17963_05_Epub.xhtml#_idTextAnchor157) 中考察了这个函数，*使用 Effect 处理副作用*。在这里我们将跳过源代码，直接进入与每个依赖项数组配置相对应的场景。'
- en: 'Similarly, we get three cases here, no dependency, empty dependency, and some
    dependencies:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这里也有三种情况：无依赖项、空依赖项和某些依赖项：
- en: '`useMemo` without a dependency provided is not common, but it''s easy to see
    how a `useMemo` hook statement and a direct assignment can replace each other
    very quickly, as they share the assignment statement in `...`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有提供依赖项的 `useMemo` 不常见，但很容易看到 `useMemo` 钩子语句和直接赋值可以非常快速地相互替换，因为它们在 `...` 中共享赋值语句。
- en: '`deps` array is provided but with no element inside, it means the value doesn''t
    depend on anything. Therefore, the value is created only once after the mount:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了 `deps` 数组但没有元素，这意味着值不依赖于任何东西。因此，值在挂载后只创建一次：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you want to hold a static value for all updates, this is a good use of it.
    You might wonder why we can't take a static value declaration outside of the component.
    It's because the assignment can still use the variables inside the component.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想要在所有更新中保持一个静态值，这是一个很好的用途。你可能会想知道为什么我们不能在组件外部声明静态值。这是因为赋值仍然可以使用组件内部的变量。
- en: '`useMemo`. When the elements of `deps` are not empty, it compares each element
    between the previous and next dependencies to determine the change:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useMemo`。当 `deps` 的元素不为空时，它会比较前一次和下一次依赖项之间的每个元素，以确定是否有变化：'
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If any of the elements change, the value gets assigned again.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果任何元素发生变化，值将被重新赋值。
- en: There's one thing to make a note of – in all of the cases mentioned, the assignment
    is performed for all updates. Though sometimes the assignment seems to be skipped,
    what we really mean here is that the assignment is reused from the last time when
    the conditions met.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事项 – 在所有提到的情况下，都会为所有更新执行赋值。尽管有时赋值似乎被跳过了，但我们的真正意思是赋值是从上次满足条件时重用的。
- en: Assignment value type
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值值类型
- en: 'The type of value that returns from the assignment can be in any format – a
    string, a number, an object, or even a function. That makes `useMemo` a bit flexible
    to meet all cases that require reusing values:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从赋值返回的值类型可以是任何格式——字符串、数字、对象，甚至是函数。这使得 `useMemo` 在满足所有需要重用值的场景时更加灵活：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding usage of `useMemo` adds a `3` number to `b` and assigns the result
    to `a` when `b` changes. Similarly, we can construct a usage for using an object:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `useMemo` 的使用给 `b` 加上 `3` 并将结果赋值给 `a`，当 `b` 发生变化时。同样，我们也可以构建一个使用对象的用法：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding usage, an object with a `name` property is assigned to `obj`
    when `name` changes. We can even construct a usage for a function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的使用中，当 `name` 发生变化时，一个具有 `name` 属性的对象被赋值给 `obj`。我们甚至可以构建一个函数的用法：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, we constructed an assignment to create a function instance
    after being mounted. To make things a bit easier to understand, we can take `useMemo`
    out to see what the raw assignment is:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们构建了一个赋值，在挂载后创建了一个函数实例。为了使事情更容易理解，我们可以将 `useMemo` 取出，看看原始赋值是什么：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There's some subtlety when it comes to the usage of `useMemo` applying to a
    non-primitive value, such as an object, an array, or a function. When creating
    any of these values, you get a new value pointing to a new memory space. This
    means that when the dependency conditions are not met, old memory space is used
    instead.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `useMemo` 应用于非原始值，如对象、数组或函数时，有一些微妙之处。在创建这些值时，你会得到一个指向新内存空间的新值。这意味着当依赖条件不满足时，将使用旧内存空间。
- en: All in all, the `useMemo` hook can be used as a special assignment to return
    any type of value.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，`useMemo` 钩子可以用作特殊的赋值来返回任何类型的值。
- en: The myth of skipping an update
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳过更新的神话
- en: 'We may all be thinking from the use of the word "memo" that, maybe, `useMemo`
    can help us skip an update:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能都会从“memo”这个词的使用中想到，也许 `useMemo` 可以帮助我们跳过更新：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, since the `a` variable doesn't get a new value after
    the mount, maybe the `Child` component doesn't get any new updates either. Unfortunately,
    this is not the case.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，由于 `a` 变量在挂载后没有获得新值，可能 `Child` 组件也没有收到任何新的更新。不幸的是，情况并非如此。
- en: The answer to this question harks back to what makes an update in *React*. We
    mentioned at the beginning of this chapter that a state change from the `Title`
    component or its parent can make a new update, but the `a` variable is not a state
    and no one makes a dispatch for updating this value either.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案可以追溯到是什么让 *React* 中的更新发生。我们在本章开头提到，`Title` 组件或其父组件的状态变化可以触发新的更新，但 `a`
    变量不是一个状态，也没有人为更新这个值进行分发。
- en: In a way, the `useMemo` hook has no direct relationship with an update. It doesn't
    carry any functionalities in terms of hooking into the update as either `useState`
    or `useEffect` does. In fact, `useMemo` doesn't do anything more than an assignment,
    except the assignment is conditional.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，`useMemo` 钩子与更新没有直接关系。它没有像 `useState` 或 `useEffect` 那样直接挂钩到更新的功能。事实上，`useMemo`
    除了条件赋值之外，没有做任何其他的事情。
- en: Skipping an update based on the prop change can be done with a `memo` function
    provided by `React`. And `memo` and `useMemo` are two different things; we do
    not discuss `memo` in this book. If you really want to skip an update with the
    `useMemo` hook, we provide a special usage in the *Appendix B – Skipping a child
    update* section at the end of this chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性变化跳过更新可以使用 `React` 提供的 `memo` 函数来完成。`memo` 和 `useMemo` 是两回事；我们在这本书中不讨论 `memo`。如果你真的想用
    `useMemo` 钩子跳过更新，我们在本章末尾的 *附录 B – 跳过子组件更新* 部分提供了一个特殊的用法。
- en: Now that we know what `useMemo` is and what it can and cannot do, let's give
    it a test drive.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了 `useMemo` 是什么以及它能做什么，不能做什么，让我们来试驾一下。
- en: Test-Driving useMemo
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 `useMemo`
- en: 'Let''s improve the example that we saw at the beginning of the chapter with
    the `useMemo` hook to gain some performance:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过改进本章开头看到的 `useMemo` 钩子示例来获得一些性能提升：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code replaces `useState` and `useEffect` with `useMemo`. Let''s
    take a look at the timeline to see what difference it makes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用 `useMemo` 替换了 `useState` 和 `useEffect`。让我们看看时间线，看看它带来了什么变化：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A new value is created in the `"created"` series when the `text` changes, independent
    of the `flag` flips. Even better this time, there's no delay between assigning
    the `found` value and receiving the `text` change because it's a direct assignment
    under the same update now.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `text` 发生变化时，在 `"created"` 序列中创建了一个新值，与 `flag` 的翻转无关。这次甚至更好，因为现在在分配 `found`
    值和接收 `text` 变化之间没有延迟，因为这是一个在同一更新下的直接赋值。
- en: It's important to note that with or without `useMemo`, there's no big code structure
    change introduced to address the performance issue. In fact, to switch back to
    the non-optimized version, we can either omit the dependency or simply remove
    the `useMemo` usage with only one or two lines.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，无论是否有 `useMemo`，都没有引入大的代码结构变化来解决性能问题。事实上，要切换回非优化版本，我们可以省略依赖项，或者简单地通过一行或两行代码移除
    `useMemo` 的使用。
- en: Okay, we have now seen how the `useMemo` hook is used. Next, let's take a look
    at two examples of how we can apply it to some real performance issues.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在已经看到了如何使用 `useMemo` 钩子。接下来，让我们看看两个例子，展示我们如何将其应用于一些真实性能问题。
- en: useMemo examples
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`useMemo` 示例'
- en: The `useMemo` hook tends to be a hook that we use when we want to optimize the
    site for either resolving site performance and/or improving user experience. Thus,
    it normally tends to be used to address problems. In the following sections, we
    will go through two examples relating to a search to demonstrate the application
    of `useMemo` as an optimization tool.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo` 钩子通常是我们想要优化网站性能和/或提升用户体验时使用的钩子。因此，它通常用于解决问题。在接下来的几节中，我们将通过两个与搜索相关的例子来展示如何将
    `useMemo` 作为优化工具的应用。'
- en: Clicking to search
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点击搜索
- en: Say you have a list of fruits and you'd like to search it to find the matched
    fruit using an input box and a button. For example, typing `"bl"` should return
    us blackberries and blueberries from a list of fruits.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个水果列表，并且你想要通过输入框和按钮搜索它以找到匹配的水果。例如，输入 `"bl"` 应该从水果列表中返回黑莓和蓝莓。
- en: '![Figure 6.3 – Clicking on the search UI'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – 点击搜索用户界面'
- en: '](img/Figure_6.3_B17963.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.3_B17963.jpg)'
- en: Figure 6.3 – Clicking on the search UI
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 点击搜索用户界面
- en: 'Here''s a list of fruits defined in a `fruits` global variable:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在 `fruits` 全局变量中定义的水果列表：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We use a `text` state to store the string that the user types in at the moment.
    When the user clicks the `text` is sent to a `query` state as the current search
    query string:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个 `text` 状态来存储用户当前输入的字符串。当用户点击时，`text` 被发送到 `query` 状态作为当前搜索查询字符串：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `fruits` list is filtered against the `query` string to find our `matched`
    fruits. The preceding code works out of the box. But, after we send this piece
    to production, we get some feedback that the *UI* chokes a bit and can become
    quite laggy when a user types on the keyboard quickly or corrects their typos
    frequently.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`fruits` 列表通过 `query` 字符串进行过滤以找到我们的 `matched` 水果。前面的代码是现成的。但是，在我们将这段代码部署到生产环境中后，我们收到了一些反馈，指出当用户快速在键盘上输入或频繁更正错误时，*UI*
    会变得有些卡顿。'
- en: 'As we dug into the issue, we found out that the problem is caused by the following
    line of code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入调查问题时，我们发现问题是由以下代码行引起的：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can take a look at the timelines to help us visualize the problem:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看时间线来帮助我们可视化问题：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Every keystroke the user types translates into an update where the `matched`
    value is created. This is the exact same problem we talked about in our introduction,
    except that `text` and `query` are both states instead of props. The nature of
    the problem is the same though.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入的每个按键都转化为一个更新，其中创建 `matched` 值。这正是我们在介绍中讨论的相同问题，只是 `text` 和 `query` 都是状态而不是属性。问题的本质是相同的。
- en: 'So, the solution here is to see whether we can limit the `matched` values to
    be created only upon the `query` change. This way, when the user types, we do
    not need to constantly make new `matched` values. Let''s try this idea with `useMemo`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的解决方案是看看我们是否可以限制 `matched` 值只在 `query` 变化时创建。这样，当用户输入时，我们就不需要不断创建新的 `matched`
    值。让我们用 `useMemo` 来尝试这个想法：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that we added `query` to the `deps` change dependency array. If other
    things changed – for example, the user type – it shouldn''t touch the `matched`
    values. Let''s confirm it with the following timeline:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将 `query` 添加到了 `deps` 变化依赖数组中。如果其他东西发生了变化——例如，用户输入——它不应该影响 `matched` 值。让我们通过以下时间线来确认这一点：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, we get a lower amount of new `matched` values, and the performance isn't
    tied to how the user types the keystroke anymore. This is great as we can all
    type quickly these days.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们得到的新`匹配`值数量减少了，性能也不再与用户如何输入键盘按键有关。这对于我们所有人来说都是一件好事，因为如今我们都能快速打字。
- en: Playground – Click to Search
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 点击搜索
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/OJjmjBv](https://codepen.io/windmaomao/pen/OJjmjBv).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自由地在这个在线示例[https://codepen.io/windmaomao/pen/OJjmjBv](https://codepen.io/windmaomao/pen/OJjmjBv)中尝试。
- en: Click and search is one of the classic examples of user experience, and it serves
    as a solid pattern when it comes to performing a search on the web. While this
    approach is still being used, these days, users expect more from a responsive
    website, so there exists a more popular approach of improving the user experience
    with this problem.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 点击搜索是用户体验的经典例子之一，当在网络上执行搜索时，它作为一个稳固的模式。虽然这种方法仍在使用，但如今，用户对响应式网站有更高的期望，因此存在一种更受欢迎的方法来通过这个问题来提高用户体验。
- en: Debouncing the search
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索去抖动
- en: 'We all have used *Google* to search for something at some point. When we type
    in the search bar, a dropdown slides down to provide the closest matches following
    the user input. It''s a very smooth user experience, as *Google* has trained all
    of us to get used to it for decades, as shown in *Figure 6.4*:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都曾在某个时刻使用过*Google*进行搜索。当我们输入搜索栏时，下拉菜单会滑下来，提供与用户输入最接近的匹配项。这是一个非常流畅的用户体验，因为*Google*已经训练我们几十年来习惯它，如图6.4所示：
- en: '![Figure 6.4 – Debouncing the search UI'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – 搜索去抖动UI]'
- en: '](img/Figure_6.4_B17963.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4]'
- en: Figure 6.4 – Debouncing the search UI
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 搜索去抖动UI
- en: 'There''s no search button the user can click anymore; all the user needs to
    do is to keep typing. And when the user stops typing, the matched list is revealed.
    So, how do we implement this? Let''s first remove the **Search** button:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在不再有可以点击的搜索按钮；用户需要做的只是继续输入。当用户停止输入时，匹配的列表就会显示出来。那么，我们该如何实现这个功能呢？首先，让我们移除**搜索**按钮：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Although we don't have the button to click, the nature of this click-to-search
    doesn't change. Somehow, we still need a moment of this "click" when the user
    is about to finish typing and expect a search to happen. So, the idea here is
    to find the right "click" moment.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们没有点击的按钮，但点击搜索的本质并没有改变。某种意义上，我们仍然需要在用户即将完成输入并期望发生搜索的时候找到一个“点击”的时刻。因此，这里的想法是找到正确的“点击”时刻。
- en: How exactly can we know such timing, when something is about to happen but has
    not happened yet? Actually, there's a perfect analogy for this problem. Ever wondered
    how an elevator waits for all people to get inside before it closes its door?
    How does the door know when is the right time to close it? How does it anticipate
    whether no one else is going to get squeezed in at the next second?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们究竟如何知道这样的时机，即在某个事情即将发生但尚未发生的时候？实际上，这个问题有一个完美的类比。你是否想过电梯在关闭门之前如何等待所有乘客进入？门是如何知道何时是关闭门的正确时间的？它是如何预判在下一秒是否还有其他人想要挤进来的？
- en: Given an `fn` function, if a request to invoke it arrives, it doesn't do it
    right away. Instead, it waits for a certain amount of time. During that period,
    if no request comes in to invoke it anymore, it then invokes at the end of the
    period. This behavior is called **Debouncing**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个`fn`函数，如果收到调用它的请求，它不会立即执行。相反，它会等待一段时间。在这段时间内，如果没有更多的请求来调用它，它将在时间结束时调用。这种行为被称为**去抖动**。
- en: 'Debouncing was introduced for mechanical switches and relays – coincidence?
    To resolve hitting the key too frequently, the processor in a keyboard defers
    the hitting by "combining" them across time into a single hit. Quite a few libraries
    implement the `debounce` function; instead of reinventing the wheel, this book
    borrows one from a library called *Lodash*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 去抖动最初是为了机械开关和继电器而引入的——巧合吗？为了解决按键过于频繁的问题，键盘处理器通过“组合”它们在时间上形成一个单一的点击。相当多的库实现了`debounce`函数；为了避免重复造轮子，这本书从名为*Lodash*的库中借用了它：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `debounce` function takes the original `fn` function and a `dt` duration
    to wait before invoking `fn`; it returns a new `debouncedFn` function with the
    debouncing behavior. Instead of invoking `fn`, we invoke `debouncedFn` now.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`debounce`函数接受原始的`fn`函数和一个等待时间`dt`，在调用`fn`之前等待。它返回一个新的具有去抖动行为的`debouncedFn`函数。我们现在调用的是`debouncedFn`而不是`fn`。'
- en: 'Let''s apply it to find the right moment of "click":'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用它来找到“点击”的正确时刻：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding change, upon each user typing, a debounced `setDebouncedQuery`
    version gets invoked. But not all typing updates the query via `setQuery`; instead,
    it waits 300 *milliseconds* to make sure the user happens to stop the typing,
    and that moment is our moment of "click." Multiple user keystrokes are combined
    into a single `setQuery`. As we have set up, after each `query` change, the `useMemo`
    hook creates a new search.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个更改中，每当用户输入时，都会调用去抖动的`setDebouncedQuery`版本。但并非所有输入都会通过`setQuery`更新查询；相反，它会等待300
    *毫秒*，以确保用户恰好停止输入，那一刻就是我们的“点击”时刻。多个用户按键组合成一个单一的`setQuery`。正如我们所设置的，每次`query`更改后，`useMemo`钩子都会创建一个新的搜索。
- en: 'There''s only one small issue left to get everything working; the `setDebouncedQuery`
    function is created as a new instance upon each user keystroke, which is not what
    we wanted. Instead, we want to have one instance of `setDebouncedQuery` so that
    all the keystrokes can be debounced to the same `setQuery` function. How do we
    reuse the last function instance? Yes – with the `useMemo` hook we just learned
    about:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下只有一个小问题需要解决，以便让一切正常工作；`setDebouncedQuery`函数在每次用户按键时创建一个新的实例，这并不是我们想要的。相反，我们希望有一个`setDebouncedQuery`的实例，以便所有按键都可以去抖动到同一个`setQuery`函数。我们如何重用最后一个函数实例？是的——使用我们刚刚学到的`useMemo`钩子：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding code, we improved `setDebouncedQuery` with the usage of the
    `useMemo` hook, and inside we inserted `debounce` for `setQuery`. Now, let''s
    confirm with the following timeline:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过使用`useMemo`钩子改进了`setDebouncedQuery`，并在其中为`setQuery`插入了`debounce`。现在，让我们通过以下时间线来确认：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Awesome! For two groups of user sessions, it performs two searches. Comparing
    this timeline with the previous timeline as in the classical clicking to search,
    you can see they are quite similar. The physical button click is replaced with
    an imaginary "click," and we get a nicer user experience.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！对于两组用户会话，它执行了两次搜索。将这个时间线与之前的经典点击搜索时间线进行比较，你可以看到它们非常相似。物理按钮点击被一个想象的“点击”所取代，我们得到了更好的用户体验。
- en: Playground – Debouncing the Search
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 搜索去抖动
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/xxLdPga](https://codepen.io/windmaomao/pen/xxLdPga).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎免费尝试这个在线示例：[https://codepen.io/windmaomao/pen/xxLdPga](https://codepen.io/windmaomao/pen/xxLdPga)。
- en: With these two examples, we should now know how `useMemo` can be applied effectively.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个示例，我们现在应该知道如何有效地应用`useMemo`。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first learned about a new hook, `useMemo`. We first briefly
    went over what can cause performance degradation in general, and then we learned
    about the `useMemo` design and read line by line how an optimization scheme is
    constructed to reuse the last value without creating a new one every time. Then,
    we went through all scenarios of reusing a value based on a dependency array.
    We took `useMemo` for a spin, and at the end, we saw how it's applied to two classic
    examples, clicking to search and debouncing the search.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先了解了一个新的钩子，`useMemo`。我们首先简要地回顾了什么会导致性能下降，然后我们学习了`useMemo`的设计，并逐行阅读了如何构建一个优化方案来重用最后一个值，而无需每次都创建一个新的值。然后，我们探讨了基于依赖数组的所有重用值的场景。我们尝试了`useMemo`，最后，我们看到了它如何应用于两个经典示例：点击搜索和搜索去抖动。
- en: In the next chapter, we will get into another hook in the *React* family where
    a state change can be dispatched to multiple locations for an are update.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解React家族中的另一个钩子，其中状态更改可以分发到多个位置以进行区域更新。
- en: Questions
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Here are some questions and answers to refresh your knowledge:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些问题和答案来刷新你的知识：
- en: What is `useMemo`?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是`useMemo`？
- en: A `useMemo` hook is an assignment statement where a new value is created when
    one of the dependencies changes. It can be used to minimize the creation of a
    value, so it behaves like that sometimes when an assignment is "skipped."
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useMemo`钩子是一个赋值语句，其中当依赖项之一发生变化时创建新值。它可以用来最小化值的创建，所以它有时表现得像赋值被“跳过”一样。'
- en: What's the common usage of `useMemo`?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useMemo`的常见用法是什么？'
- en: It's mainly used as an optimization to avoid heavy operation on every render
    otherwise. If a certain evaluation is excessively used, thus blocking the *UI*,
    it is the right time to think about using `useMemo` to limit the usage to only
    relevant conditions. For instance, if typing isn't related to that task, we can
    take it out of the dependency list.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它主要用作优化，以避免在每次渲染时进行繁重的操作。如果某些评估被过度使用，从而阻塞 *UI*，那么考虑使用 `useMemo` 限制其使用到仅相关的条件是正确的时间。例如，如果输入与该任务无关，我们可以将其从依赖列表中移除。
- en: How do you use `useMemo` for memorization?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用 `useMemo` 进行记忆化？
- en: '`useMemo` doesn''t remember all past values and only remembers the last created
    value. So, the best usage of it is to use it as a special assignment replacement,
    instead of a caching mechanism.'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useMemo` 并不记住所有过去值，只记住最后创建的值。因此，最佳用法是将其用作特殊赋值替换，而不是缓存机制。'
- en: Appendix
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: Appendix A – Not a Classical Memorization
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录 A – 非经典记忆化
- en: It's very easy to confuse `useMemo` with a **Memorization** used in computer
    science, as the name indicates.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易将 `useMemo` 与计算机科学中使用的 **记忆化** 混淆，正如其名称所暗示的。
- en: Memorization is an optimization technique in computer programs, primarily designed
    to speed up the process by storing the results of expensive operations and returning
    the cached result if it has been computed under the same condition before. The
    last part, "under the same condition before," is the part that makes it special.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化是计算机程序中的一种优化技术，主要设计用于通过存储昂贵操作的结果并返回在相同条件下之前已计算出的缓存结果来加速过程。最后一部分，“在相同条件下之前”，是使其特殊化的部分。
- en: 'The *Fibonacci* sequence is a classical memorization problem. If it''s written
    using a recursive algorithm, it can be very costly; therefore, we tend to use
    cache storage to store all past calculated values:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*斐波那契* 序列是一个经典的记忆化问题。如果使用递归算法编写，可能会非常昂贵；因此，我们倾向于使用缓存存储来存储所有过去计算出的值：'
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code gives a specialized `fib` function; if you call it sequentially
    from `1`, `2`, and so on, it can give you the next number without too much effort.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码提供了一个专门的 `fib` 函数；如果你按顺序从 `1`、`2` 等调用它，它可以不费太多力气地给出下一个数字。
- en: 'Say in the *React* app, we start with `n=0`; unless `n` moves to the next number,
    we don''t want to calculate a new value. We could add `useMemo`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *React* 应用中，我们通常从 `n=0` 开始；除非 `n` 移动到下一个数字，我们不想计算新的值。我们可以添加 `useMemo`：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first thing we quickly find out is that it actually reuses the `fib` function,
    which means their functionalities don't overlap at all. In another way, `useMemo`
    doesn't do what `fib` does. Amazing!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先迅速发现的是，它实际上重用了 `fib` 函数，这意味着它们的函数性完全不重叠。从另一方面来说，`useMemo` 并不做 `fib` 做的事情。太神奇了！
- en: 'Another discovery is that what the `Title` component does is to ensure that
    when another `text` prop changes, it doesn''t calculate `f` again. But if we change
    `n` from `3` to `2`, it still creates a new number. This means the code can be
    reduced to the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个发现是，`Title` 组件所做的确保当另一个 `text` 属性改变时，它不会再次计算 `f`。但如果我们把 `n` 从 `3` 改为 `2`，它仍然会创建一个新的数字。这意味着代码可以简化为以下内容：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Haha, this is a bit funny now. We literally removed `useMemo`. Why? Because
    the saved calculation is already implemented by `fib`, the classical memorization.
    Moreover, the `useMemo` hook doesn't provide any of that kind of storage.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈，现在有点好笑了。我们实际上移除了 `useMemo`。为什么？因为通过 `fib` 已经实现了节省计算。此外，`useMemo` 钩子不提供任何这种存储。
- en: '`useMemo` has one memoized storage built for *a last value*. If you can take
    advantage of this, that''s great. Otherwise, you just over-complicate things.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo` 为 *最后一个值* 建立了一个记忆化存储。如果你能利用这一点，那就太好了。否则，你只是使事情过于复杂。'
- en: Don't expect `useMemo` to give you more values, since it doesn't even have a
    key/value map for multiple values. *React* itself is a big state machine; given
    a change, it moves to a new state. All it cares about is the current and next
    scene it's going into. Moving from `t-1` to `t` is what *React* is good at, but
    not at moving from `t` to `t-2`. Therefore, `useMemo` can't fit in the memorization
    context, which is normally what caching is about.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 不要期望 `useMemo` 给你更多值，因为它甚至没有多个值的键/值映射。*React* 本身是一个大状态机；给定一个变化，它会移动到新的状态。它所关心的只是它即将进入的当前和下一个场景。从
    `t-1` 移动到 `t` 是 *React* 擅长的事情，但不是从 `t` 移动到 `t-2`。因此，`useMemo` 不能适应记忆化上下文，这通常是缓存所涉及的内容。
- en: Appendix B – Skipping a Child Update
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录 B – 跳过子组件更新
- en: 'We will use a profiler chart provided by *React Developer Tools* to inspect
    the React component hierarchies inside the browser, as shown in *Figure 6.5*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用由 *React Developer Tools* 提供的 profiler 图表来检查浏览器内 React 组件层次结构，如图 *图 6.5*
    所示：
- en: '![Figure 6.5 – Profiler render with Child bailout failed'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.5 – 使用 Child bailout 失败的 Profiler 渲染'
- en: '](img/Figure_6.05_B17963.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.05_B17963.jpg)'
- en: Figure 6.5 – Profiler render with Child bailout failed
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 使用 Child bailout 失败的 Profiler 渲染
- en: What a profiler chart provides is a topology overview of all the fibers visited
    in one update. The topology speaks for itself on how they are wired like a tree.
    Moreover, we can tell what happened to them based on their colors.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Profiler 图表提供的是一次更新中所有访问到的 fibers 的拓扑概览。拓扑本身就能说明它们是如何像树一样连接的。此外，我们可以根据它们的颜色来判断它们发生了什么。
- en: A bar with a solid color stands for an update from this component. On the other
    hand, if the color is shaded gray, it means that *React* decides to skip updating
    the component, termed as a bailout.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实心颜色的条形表示来自该组件的更新。另一方面，如果颜色是灰色阴影，这意味着 *React* 决定跳过更新该组件，这被称为 bailout。
- en: The chart is useful when we get to study the performance of the site because
    it can tell us in a given update how many fibers are replaced and how many are
    reused, and whether a particular fiber has been visited or not.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们研究网站的性能时，这个图表很有用，因为它可以告诉我们在给定更新中替换了多少个 fibers，重用了多少个，以及是否有特定的 fiber 被访问过。
- en: 'A value created by `useMemo` can be used for any purpose. For it to impact
    a child component, it can be wired with a prop to send the info deeper:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo` 创建的值可以用于任何目的。为了影响子组件，它可以与 prop 连接起来，将信息发送得更深：'
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If we get a previous `assignment` of the a variable wiring to the `Child` component
    via a prop, does that mean we can have a conditional update of `Child`? This is
    a good question.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到一个将变量 `a` 通过 prop 连接到 `Child` 组件的先前 `assignment`，这意味着我们可以对 `Child` 进行条件更新吗？这是一个好问题。
- en: From the profiler chart corresponding to all components when the `Title` updates
    (see *Figure 6.5*), we quickly find out the answer is no. The preceding code can't
    make a skip of the `Child` update because, when the `Title` parent updates, it
    generates a new set of props through the reconciliation of the `Child` fiber.
    In other words, it triggers the update of `Child` regardless of whether an individual
    prop, such as `a`, has a new value.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Title` 更新时对应所有组件的 profiler 图表（见图 *图 6.5*），我们可以快速找到答案是否定的。前面的代码不能跳过 `Child`
    更新，因为当 `Title` 父组件更新时，它会通过 `Child` fiber 的 reconciliation 生成一组新的 props。换句话说，它触发了
    `Child` 的更新，无论单个 prop，如 `a`，是否有新值。
- en: 'Then, how exactly can we use `useMemo` to skip a child update manually? Let''s
    try something different. Keep in mind what `useMemo` is designed to do – to hold
    a value from the last update until the condition is met again:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何确切地使用 `useMemo` 来手动跳过子组件的更新呢？让我们尝试一些不同的方法。记住 `useMemo` 的设计目的是 – 保留从上次更新以来的值，直到再次满足条件：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding `useMemo` code, instead of returning a string, we use it to
    hold the `<Child />` component instance. What is `<Child />`? It''s an element
    object returned from the `Child` function component. So, as long as the element
    stays the same, we expect the screen to be the same. Let''s confirm this approach
    with the profiler chart, as shown in *Figure 6.6*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `useMemo` 代码中，我们不是返回一个字符串，而是用它来保存 `<Child />` 组件实例。`<Child />` 是什么？它是 `Child`
    函数组件返回的一个元素对象。因此，只要元素保持不变，我们期望屏幕也是一样的。让我们通过 profiler 图表来确认这种方法，如图 *图 6.6* 所示：
- en: '![Figure 6.6 – Profiler render with Child bailout successful'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6 – 使用 Child bailout 成功的 Profiler 渲染'
- en: '](img/Figure_6.06_B17963.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.06_B17963.jpg)'
- en: Figure 6.6 – Profiler render with Child bailout successful
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 使用 Child bailout 成功的 Profiler 渲染
- en: After the mount, as the `[]` dependency array indicates, `child` holds the same
    `Child` update from the last time. Now, when the `Title` component gets updated,
    it doesn't update the `Child` component. This is because, to React, there's no
    dispatched change from under the `Title` component, so it bails out everything
    underneath it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在挂载后，正如 `[]` 依赖数组所示，`child` 保留了上一次的相同 `Child` 更新。现在，当 `Title` 组件更新时，它不会更新 `Child`
    组件。这是因为，对 React 来说，`Title` 组件下面没有派发的更改，所以它跳过了下面的所有内容。
