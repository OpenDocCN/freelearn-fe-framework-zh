- en: TypeScript Crash Course
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript快速入门
- en: 'In this chapter, we will start working with TypeScript: the language Angular
    is written with. All the features that ECMAScript 2015 and ECMAScript 2016 provide,
    such as functions, classes, modules, and decorators, are already implemented in
    or added to the roadmap of TypeScript. Because of the extra type annotations,
    there are some syntactical additions compared to JavaScript.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用TypeScript：Angular所使用的语言。所有ECMAScript 2015和ECMAScript 2016提供的功能，如函数、类、模块和装饰器，都已经实现或添加到TypeScript的路线图中。由于额外的类型注解，与JavaScript相比，有一些语法上的添加。
- en: Being already familiar with AngularJS and subsequently ES5, we'll go through
    a process of smooth transition to TypeScript. We'll start by introducing ES2015
    and ES2016\. As we mentioned previously, TypeScript is a superset of these new
    ECMAScript standards, which means that by learning the new versions of JavaScript
    you'll also learn very important bits of TypeScript. In the second half of the
    chapter, we'll add the extra syntax for explicit type annotations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于已经熟悉AngularJS和随后的ES5，我们将经历一个平滑过渡到TypeScript的过程。我们将从介绍ES2015和ES2016开始。正如我们之前提到的，TypeScript是这些新ECMAScript标准的超集，这意味着通过学习JavaScript的新版本，你也将学习到TypeScript非常重要的部分。在本章的后半部分，我们将添加显式类型注解的额外语法。
- en: Later in this chapter, we will explain the extra features TypeScript provides,
    such as static typing and extra syntax. We will discuss the different consequences
    based on these features, which will help us to be more productive and less error-prone.
    Let's get going!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将解释TypeScript提供的额外功能，例如静态类型和额外语法。我们将讨论基于这些功能的不同后果，这将帮助我们提高生产力并减少错误。让我们开始吧！
- en: Introduction to TypeScript
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript简介
- en: TypeScript is an open source programming language that is developed and maintained
    by Microsoft. Its initial public release was in October 2012\. TypeScript is a
    superset of ECMAScript, supporting all of the syntax and semantics of JavaScript
    with some extra features on top, such as static typing and richer syntax.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是由微软开发和维护的开源编程语言。它的首次公开发布是在2012年10月。TypeScript是ECMAScript的超集，支持JavaScript的所有语法和语义，并在其之上提供了一些额外功能，如静态类型和更丰富的语法。
- en: '*Figure 1* shows the relationships among ES5, ES2015, ES2016, and TypeScript:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1* 展示了ES5、ES2015、ES2016和TypeScript之间的关系：'
- en: '![](img/cdbf660b-f4bd-48e6-9c32-65bdde97a088.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cdbf660b-f4bd-48e6-9c32-65bdde97a088.png)'
- en: Figure 1
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: As TypeScript is statically typed, it can provide a number of benefits to us
    as JavaScript developers. Let's take a quick look at those benefits now.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TypeScript是静态类型的，它可以为JavaScript开发者提供许多好处。现在让我们快速看一下这些好处。
- en: Compile-time type checking
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时类型检查
- en: One of the most common mistakes we make while writing JavaScript code is to
    misspell a property or a method name. Usually, we find out about the mistake when
    we get a runtime error. This can happen during development as well as during production.
    Hoping that we will know about the error before we deploy our code to the production
    environment isn't a comfortable feeling! However, this is not a problem specific
    to JavaScript; it is something common to all the dynamic languages. Even with
    lots of unit tests, these errors can slip by.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编写JavaScript代码时犯的最常见的错误之一是拼写属性或方法名错误。通常，我们在运行时错误中意识到这个错误。这可能在开发过程中发生，也可能在生产过程中发生。希望我们在将代码部署到生产环境之前知道这个错误并不是一个令人舒服的感觉！然而，这并不是JavaScript特有的问题；这是所有动态语言的共同问题。即使有很多单元测试，这些错误也可能被忽略。
- en: TypeScript provides a compiler, which takes care of such mistakes for us using
    static code analysis. If we take advantage of static typing, TypeScript will be
    aware of the existing properties a given object has, and if we misspell any of
    them, the compiler will warn us with a compile-time error.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript提供了一个编译器，它通过静态代码分析为我们处理这些错误。如果我们利用静态类型，TypeScript将知道给定对象具有的现有属性，如果我们拼写错误，编译器将以编译时错误的形式警告我们。
- en: Another great benefit of TypeScript is that it allows large teams to collaborate
    since it provides formal, verifiable naming. This way, it allows us to write easy-to-understand
    code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的另一个巨大好处是它允许大型团队协作，因为它提供了正式、可验证的命名。这样，它允许我们编写易于理解的代码。
- en: Better support by text editors and IDEs
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本编辑器和IDE的支持更好
- en: There are a number of tools, such as Tern, that are trying to bring better autocompletion
    support for JavaScript in text editors and IDEs. However, as JavaScript is a dynamic
    language, it is impossible for the IDEs and text editors to make sophisticated
    suggestions without any metadata. Google Closure Compiler, for instance, uses
    type annotations provided in the JSDoc in order to provide static typing to the
    language.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具，如 Tern，试图在文本编辑器和 IDE 中为 JavaScript 提供更好的自动完成支持。然而，由于 JavaScript 是一种动态语言，没有元数据，IDE
    和文本编辑器无法做出复杂的建议。例如，Google Closure Compiler 就使用 JSDoc 中提供的类型注解来为语言提供静态类型。
- en: Annotating the code with such metadata is a built-in feature of TypeScript known
    as type annotations. Based on them, text editors and IDEs can perform a better
    static analysis on our code. This provides better refactoring tools and autocompletion,
    which increases our productivity and allows us to make fewer mistakes while writing
    the source code for our applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的元数据注释代码是 TypeScript 的一个内置功能，称为类型注解。基于这些注解，文本编辑器和 IDE 可以对我们的代码进行更好的静态分析。这提供了更好的重构工具和自动完成功能，提高了我们的生产力，并允许我们在编写应用程序的源代码时犯更少的错误。
- en: There's even more to TypeScript
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 还有更多内容
- en: 'TypeScript by itself has a number of other benefits:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 本身还有许多其他好处：
- en: '**It is a superset of JavaScript**: All JavaScript programs (for example, ES5
    and ES2015) are already valid TypeScript ones. In essence, you have already been
    writing TypeScript code. Since it is based on the latest version of the ECMAScript
    standard, it allows us to take advantage of the latest bleeding-edge syntax provided
    by the language.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它是 JavaScript 的超集**：所有 JavaScript 程序（例如，ES5 和 ES2015）已经是有效的 TypeScript 程序。本质上，你已经在编写
    TypeScript 代码了。由于它基于 ECMAScript 标准的最新版本，它使我们能够利用语言提供的最新尖端语法。'
- en: '**It supports optional type checking**: If, for any reason, we decide that
    we don''t want to explicitly define the type of a variable or a method, we can
    just skip the type definition. However, we should be aware that this means we
    are no longer taking advantage of the static typing, so we are giving up on all
    the benefits mentioned earlier.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它支持可选的类型检查**：如果我们出于任何原因决定不想显式地定义变量或方法的类型，我们只需跳过类型定义即可。然而，我们应该意识到这意味着我们不再利用静态类型的好处，因此我们放弃了之前提到的所有好处。'
- en: '**It is developed and maintained by Microsoft**: The quality of the implementation
    of the language is very high, and it is unlikely that support will be dropped
    unexpectedly. TypeScript is based on the work of some of the world''s best experts
    in programming language development.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它由微软开发和维护**：语言的实现质量非常高，不太可能意外地放弃支持。TypeScript 基于世界上一些最好的编程语言开发专家的工作。'
- en: '**It is open source**: This allows the community to freely contribute to the
    language and suggest features, which are discussed in an open manner. The fact
    that TypeScript is open source makes the development of third-party extensions
    and tools easier. This extends the scope of its usage even further.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它是开源的**：这使得社区可以自由地为语言做出贡献并建议功能，这些功能以开放的方式进行讨论。TypeScript 是开源的事实使得第三方扩展和工具的开发更加容易，这进一步扩大了其使用范围。'
- en: Since modern browsers do not support TypeScript natively, there is a compiler
    that translates the TypeScript code we write into readable JavaScript in a predefined
    target version of ECMAScript. Once the code is compiled, all the type annotations
    are removed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现代浏览器不支持 TypeScript，因此有一个编译器可以将我们编写的 TypeScript 代码转换成预定义的 ECMAScript 目标版本的可读
    JavaScript。一旦代码编译完成，所有类型注解都会被移除。
- en: Using TypeScript
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TypeScript
- en: Let's start writing some TypeScript!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写一些 TypeScript 代码吧！
- en: In the following sections, we will take a look at different snippets showing
    some of the features of TypeScript. In order to be able to run the snippets and
    play with them yourself, you'll need to install the TypeScript compiler on your
    computer. Let's take a look at how to do this.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将查看不同的代码片段，展示 TypeScript 的一些功能。为了能够运行这些代码片段并自己尝试，你需要在你的计算机上安装 TypeScript
    编译器。让我们看看如何做这件事。
- en: The easiest way to install TypeScript is using **Node package manager** (**npm**).
    I'd recommend that you use version 5.0.0 or a newer version of `npm`. If you don't
    have node.js and `npm` installed already, you can visit [https://nodejs.org](https://nodejs.org)
    and follow the instructions there.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 TypeScript 最简单的方法是使用 **Node 包管理器**（**npm**）。我建议你使用 5.0.0 或更高版本的 `npm`。如果你还没有安装
    node.js 和 `npm`，你可以访问 [https://nodejs.org](https://nodejs.org) 并按照那里的说明操作。
- en: Installing TypeScript with npm
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 npm 安装 TypeScript
- en: 'Once you have `npm` installed and running, verify that you have the latest
    version by opening your terminal window and running the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装并运行了 `npm`，你可以通过打开终端窗口并运行以下命令来验证你是否拥有最新版本：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use the following command in order to install TypeScript 2.5.0 or newer:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令来安装 TypeScript 2.5.0 或更高版本：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding command will install the TypeScript compiler and add its executable
    (`tsc`) as global.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将安装 TypeScript 编译器并将其可执行文件（`tsc`）添加为全局。
- en: 'In order to verify that everything works properly, you can use the following
    command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一切是否正常工作，你可以使用以下命令：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output should be similar to the preceding one, though possibly with a different
    minor or patch version.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于前面的示例，尽管可能包含不同的次要或补丁版本。
- en: Note that we install TypeScript by prefixing the version with caret. This means
    that `npm` will download any version in the range 2.y.z, but below 3.0.0.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通过在版本号前加 caret 来安装 TypeScript。这意味着 `npm` 将下载 2.y.z 范围内的任何版本，但低于 3.0.0。
- en: Running our first TypeScript program
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的第一个 TypeScript 程序
- en: 'Now, let''s compile our first TypeScript program! Create a file called `hello-world.ts`
    and enter the following content:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编译我们的第一个 TypeScript 程序！创建一个名为 `hello-world.ts` 的文件，并输入以下内容：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since we''ve already installed the TypeScript compiler, we should have a global
    executable command called `tsc`. You can use it in order to compile the file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经安装了 TypeScript 编译器，我们应该有一个名为 `tsc` 的全局可执行命令。你可以用它来编译文件：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, you should see the `hello-world.js` file in the same directory where `hello-world.ts`
    is. The `hello-world.js` file is the output of the TypeScript compiler; it contains
    the JavaScript equivalent to the TypeScript we wrote. We can run this file using
    the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该在 `hello-world.ts` 所在的目录中看到 `hello-world.js` 文件。`hello-world.js` 文件是 TypeScript
    编译器的输出；它包含与我们编写的 TypeScript 相等的 JavaScript 代码。我们可以使用以下命令运行此文件：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, you''ll see the `Hello world!` string printed on the screen. In order
    to combine the process of compiling and running the program, you can use the `ts-node`
    package:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会在屏幕上看到打印的 `Hello world!` 字符串。为了结合编译和运行程序的过程，你可以使用 `ts-node` 包：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now you can run this command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行以下命令：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should see the same result, but without the `hello-world.js` file stored
    on the disk.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到相同的结果，但不需要在磁盘上存储 `hello-world.js` 文件。
- en: You can find the code for this book at [https://github.com/mgechev/switching-to-angular](https://github.com/mgechev/switching-to-angular).
    Most code snippets in the book's content have a comment as the first line, which
    shows where you can find the complete example in the directory structure of the
    samples repository. Note that the paths are relative to the `app` directory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/mgechev/switching-to-angular](https://github.com/mgechev/switching-to-angular)
    找到这本书的代码。书中大部分代码片段的第一行都有一个注释，显示你可以在样本存储库的目录结构中找到完整的示例。请注意，路径是相对于 `app` 目录的。
- en: TypeScript syntaxes and features introduced by ES2015 and ES2016
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由 ES2015 和 ES2016 引入的 TypeScript 语法和功能
- en: As TypeScript is a superset of JavaScript, before we start learning about its
    syntax, it'll be easier to start by introducing some of the bigger changes in
    ES2015 and ES2016; to understand TypeScript, we first must understand ES2015 and
    ES2016\. We will have a whistle-stop tour through these changes before diving
    into TypeScript properly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TypeScript 是 JavaScript 的超集，在我们开始学习其语法之前，先介绍一些 ES2015 和 ES2016 中的较大变化会更容易；为了理解
    TypeScript，我们首先必须理解 ES2015 和 ES2016。在深入 TypeScript 之前，我们将对这些变化进行快速浏览。
- en: 'A detailed explanation of ES2015 and ES2016 is beyond the scope of this book.
    In order to get familiar with all the new features and syntaxes, I strongly recommend
    that you take a look at *Exploring ES6: Upgrade to the next version of JavaScript*
    by *Dr. Axel Rauschmayer*.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '对 ES2015 和 ES2016 的详细解释超出了本书的范围。为了熟悉所有新特性和语法，我强烈建议你阅读 *Exploring ES6: Upgrade
    to the next version of JavaScript*，作者是 *Dr. Axel Rauschmayer*。'
- en: The next couple of pages will introduce new standards and allow us to take advantage
    of most of the features we will need during the development of Angular applications.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几页将介绍新的标准，并使我们能够在开发 Angular 应用程序的过程中充分利用我们所需的大部分功能。
- en: ES2015 arrow functions
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES2015 箭头函数
- en: 'JavaScript has first-class functions, which means that they can be passed around
    like any other value:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有第一类函数，这意味着它们可以像任何其他值一样传递：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This syntax is great; however, it is a bit too verbose. ES2015 introduced a
    new syntax to define anonymous functions called the arrow function syntax. Using
    it, we can create anonymous functions, as seen in the following examples:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法很棒；然而，它有点过于冗长。ES2015 引入了一种新的语法来定义匿名函数，称为箭头函数语法。使用它，我们可以创建匿名函数，如下面的例子所示：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the first example here, we got the total sum of the elements in the `[1,
    2, 3]` array. In the second example, we got all the even numbers from the `[3,
    1, 56, 7]` array. In the third example, we sorted an array by the `price` and
    `total` properties in ascending order.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的第一例中，我们得到了 `[1, 2, 3]` 数组中所有元素的总和。在第二个例子中，我们从 `[3, 1, 56, 7]` 数组中得到了所有偶数。在第三个例子中，我们按
    `price` 和 `total` 属性的升序对数组进行了排序。
- en: 'Arrow functions have a few more features that we need to look at. The most
    important feature is that they keep the context (`this`) from the surrounding
    code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数有几个我们需要了解的额外功能。最重要的功能是它们保留了周围代码的上下文（`this`）：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For example, when we invoke the `MyComponent` function with the `new`; operator,
    `this` will point to the new object instantiated by the call. The arrow function
    will keep the context (`this`), in the callback of `setTimeout`, and print `43`
    on the screen.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们使用 `new` 操作符调用 `MyComponent` 函数时，`this` 将指向由调用实例化的新对象。箭头函数将保持上下文（`this`），在
    `setTimeout` 的回调中，并在屏幕上打印 `43`。
- en: This is extremely useful in Angular since the binding context for a given component
    is its instance (that is, its `this` reference). If we define `MyComponent` as
    an Angular component and we have a binding to the `age` property, the preceding
    code will be valid and all the bindings will work (note that we don't have the
    scope, neither do we have explicit calls to the `$digest` loop, although we have
    called `setTimeout` directly).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，这非常有用，因为给定组件的绑定上下文是其实例（即其 `this` 引用）。如果我们定义 `MyComponent` 为 Angular
    组件，并且有一个绑定到 `age` 属性，前面的代码将是有效的，并且所有绑定都将工作（注意，我们没有作用域，我们也没有对 `$digest` 循环的显式调用，尽管我们直接调用了
    `setTimeout`）。
- en: Using the ES2015 and ES2016 classes
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ES2015 和 ES2016 类
- en: When developers new to JavaScript hear that the language empowers the **object-oriented**
    (**OO**) paradigm, they're normally confused when they discover that there's no
    syntax for the definition of classes. This perception was born of the fact that
    some of the most popular programming languages, such as Java, C#, and C++, have
    the concept of classes used for the construction of objects. However, JavaScript
    implements the OO paradigm differently. JavaScript has a prototype-based, object-oriented
    programming model, where we can instantiate objects using the object literal syntax
    or functions (also known as the constructor functions), and we can take advantage
    of the inheritance using the so called prototype chain.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JavaScript 新手听说该语言赋予 **面向对象**（**OO**）范式时，他们通常会在发现没有用于定义类的语法时感到困惑。这种观念源于一些最受欢迎的编程语言，如
    Java、C# 和 C++，它们都有用于构建对象的类的概念。然而，JavaScript 以不同的方式实现了面向对象范式。JavaScript 有一个基于原型的面向对象编程模型，我们可以使用对象字面量语法或函数（也称为构造函数）来实例化对象，并且我们可以利用所谓的原型链来利用继承。
- en: Although this is a valid way to implement the OO paradigm, and the semantics
    are similar to the one in the classical object-oriented model, it is confusing
    for inexperienced JavaScript developers who are not sure how to process this properly.
    This is one of the reasons TC39 decided to provide an alternative syntax to use
    the object-oriented paradigm in the language. Behind the scenes, the new syntax
    has the same semantics as the one we're used to, such as using the constructor
    functions and the prototype-based inheritance. However, it provides a more convenient
    syntax to empower the features of OO paradigm with less boilerplate.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一种实现面向对象范式的有效方式，并且语义与经典面向对象模型相似，但对于不确定如何正确处理此问题的经验不足的 JavaScript 开发者来说，这可能会令人困惑。这就是
    TC39 决定提供一种替代语法来在语言中使用面向对象范式的原因之一。幕后，新语法具有与我们熟悉的相同的语义，例如使用构造函数和基于原型的继承。然而，它提供了一个更方便的语法，以更少的样板代码来启用面向对象范式的功能。
- en: ES2016 adds some extra syntax to the ES2015 classes, such as static and instance
    property declaration.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ES2016 为 ES2015 类添加了一些额外的语法，例如静态和实例属性声明。
- en: 'Here is an example that demonstrates the syntax used to define the classes
    in ES2016:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，演示了在 ES2016 中定义类的语法：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In ES2015, the explicit declaration of the `_name` property is not required;
    however, since the TypeScript compiler should be aware during compile time of
    the existing properties of the instances of a given class, we would need to add
    the declaration of the property to the class definition itself.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES2015 中，不需要显式声明 `_name` 属性；然而，由于 TypeScript 编译器应该在编译时知道给定类的实例的现有属性，我们需要将属性的声明添加到类定义本身中。
- en: The preceding snippet is both a valid TypeScript and JavaScript code. In it,
    we defined a class called `Human`, which adds a single property to the objects
    instantiated by it. It does this by setting the value of the property to the value
    of the parameter `name` passed to its constructor.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段既是有效的 TypeScript 也是 JavaScript 代码。在其中，我们定义了一个名为 `Human` 的类，它为其实例化的对象添加了一个属性。它是通过将属性的值设置为传递给其构造函数的参数
    `name` 的值来实现的。
- en: Later, the `Developer` class extends the `Human` class by specifying a reference
    to it in the `extends` clause. This way, the instances of the `Developer` class
    will have the entire functionality that the `Human` class provides, plus the extra
    features introduced by `Developer`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，`Developer` 类通过在 `extends` 子句中指定对它的引用来扩展 `Human` 类。这样，`Developer` 类的实例将拥有
    `Human` 类提供的全部功能，以及 `Developer` 类引入的额外功能。
- en: 'Now, open the `ch4/es6-classes/sample-classes.ts` file and play around with
    it! You can create different instances of the classes in the same way you create
    objects using constructor functions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开 `ch4/es6-classes/sample-classes.ts` 文件并尝试一下！你可以以创建构造函数对象的方式创建类的不同实例：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In order to execute the code, run the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行代码，请运行以下命令：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Classes are commonly used in Angular. You can use them to define your components,
    directives, services, and pipes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类在 Angular 中被广泛使用。你可以使用它们来定义你的组件、指令、服务和管道。
- en: Defining variables with block scope
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义具有块作用域的变量
- en: Another confusing point of JavaScript for developers with a different background
    is the variable scope in the language. In Java and C++, for example, we're used
    to the block lexical scope. This means that a given variable defined inside a
    specific block will be visible only inside that block and all of the nested blocks
    inside of it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有不同背景的开发者来说，JavaScript 的变量作用域是一个令人困惑的点。例如，在 Java 和 C++ 中，我们习惯于块词法作用域。这意味着在特定块内部定义的变量将仅在块内部及其嵌套的所有块内部可见。
- en: 'However, in JavaScript, things are a little bit different. ECMAScript defines
    a functional lexical scope that has similar semantics to the block lexical scope,
    but it uses functions instead of blocks. Let''s take a look at the following code
    snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 JavaScript 中，情况略有不同。ECMAScript 定义了一个具有类似语义的功能词法作用域，但它使用函数而不是代码块。让我们看看下面的代码片段：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This has some weird implications. Once the code is executed, it will log five
    times the number `5`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一些奇怪的影响。一旦代码执行，它将输出数字 `5` 的五倍。
- en: 'ES2015 added a new syntax to define variables with block scope visibility.
    The syntax is similar to the current one, however, instead of `var`, it uses the
    `let` keyword:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015 添加了一种新的语法来定义具有块作用域可见性的变量。语法与当前语法类似，然而，它使用的是 `let` 关键字而不是 `var`：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now the semantics will be as expected: we''ll see the numbers from `0` to `4`
    logged in the console.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的语义将如预期的那样：我们将在控制台中看到从`0`到`4`的数字。
- en: Meta-programming with ES2016 decorators
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ES2016装饰器进行元编程
- en: 'JavaScript is a dynamic language that allows us to easily modify and/or alter
    the behavior to suit the programs we write. Decorators are a proposal to ES2016,
    and the design document at [https://github.com/wycats/javascript-decorators](https://github.com/wycats/javascript-decorators)
    describes their work as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'JavaScript是一种动态语言，它允许我们轻松地修改和/或改变行为以适应我们编写的程序。装饰器是ES2016的一个提议，设计文档在[https://github.com/wycats/javascript-decorators](https://github.com/wycats/javascript-decorators)中描述了它们的工作如下： '
- en: '"...make it possible to annotate and modify classes and properties at design
    time."'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '"...使设计时对类和属性进行注释和修改成为可能。"'
- en: Their syntaxes are quite similar to the annotations in Java, and they are even
    closer to the decorators in Python. ES2016 decorators are used commonly in Angular
    to define components, directives, and pipes, and to take advantage of the dependency
    injection mechanism of the framework. Most use cases of decorators involve altering
    the behavior to a predefined logic or adding some metadata to different constructs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的语法与Java中的注解非常相似，甚至比Python中的装饰器更接近。ES2016装饰器在Angular中常用以定义组件、指令和管道，并利用框架的依赖注入机制。装饰器的多数用例涉及改变行为以符合预定义逻辑或向不同的结构添加一些元数据。
- en: ES2016 decorators allow us to do a lot of fancy things by changing the behavior
    of our programs. Typical use cases could be to annotate the given methods or properties
    as deprecated or read only. A set of predefined decorators that can improve the
    readability of the code we produce can be found in a project called `core-decorators.js`.
    Another use case is taking advantage of the proxy-based, aspect-oriented programming
    using a declarative syntax. The library providing this functionality is `aspect.js`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ES2016装饰器通过改变程序的行为，使我们能够执行许多复杂操作。典型的用例可以是注释给定的方法或属性为已弃用或只读。可以在名为`core-decorators.js`的项目中找到一组预定义的装饰器，这些装饰器可以提高我们生成的代码的可读性。另一个用例是利用基于代理的面向方面编程，使用声明性语法。提供此功能的库是`aspect.js`。
- en: 'In general, ES2016 decorators are just a new syntax sugar, which translates
    to JavaScript code we''re already familiar with from the previous versions of
    the language. Let''s take a look at a simple example from the draft of the proposal:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，ES2016装饰器只是新的语法糖，它转换为我们从语言的前几个版本中已经熟悉的JavaScript代码。让我们看看提议草案中的一个简单示例：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this case, we have an ES2015 class called `Person` with a single getter
    called `kidCount`. Over the `kidCount` getter, we have applied the `@nonenumerable`
    decorator. The decorator is a function that accepts a target (the `Person` class),
    the name of the target property we intend to decorate (`kidCount`), and the descriptor
    of the target property. After we change the descriptor, we need to return it in
    order to apply the modification. Basically, the decorator''s application can be
    translated into ECMAScript 5 in the following way:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个名为`Person`的ES2015类，它有一个名为`kidCount`的单个getter。在`kidCount` getter上，我们应用了`@nonenumerable`装饰器。装饰器是一个接受目标（`Person`类）、我们打算装饰的目标属性名称（`kidCount`）以及目标属性描述符的函数。在更改描述符后，我们需要返回它以应用修改。基本上，装饰器的应用可以按以下方式转换为ECMAScript
    5：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using configurable decorators
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可配置的装饰器
- en: 'Here is an example of using the decorators defined by Angular:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用Angular定义的装饰器的示例：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When decorators accept arguments (just like `Component` in the preceding example),
    they need to be defined as functions that accept arguments and return the actual
    decorator:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当装饰器接受参数（就像前面的示例中的`Component`一样），它们需要定义为接受参数并返回实际装饰器的函数：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, we defined a function called `Component` that accepts a single
    argument called `config` and returns a decorator. On the other hand, the decorator
    accepts the constructor function as argument, which is the desugared version of
    the class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个名为`Component`的函数，它接受一个名为`config`的单个参数并返回一个装饰器。另一方面，装饰器接受构造函数作为参数，这是类的去糖版本。
- en: Writing modular code with ES2015
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ES2015编写模块化代码
- en: Another problem that JavaScript professionals have experienced over the years
    is the lack of a module system in the language. Initially, the community developed
    different patterns, aiming to enforce the modularity and the encapsulation of
    the software we produce. Such patterns included the module pattern, which takes
    advantage of the functional lexical scope and closures. Another example is the
    namespace pattern, which represents the different namespaces as nested objects.
    AngularJS introduced its own module system that unfortunately doesn't provide
    features, such as lazy module loading. However, these patterns were more like
    workarounds rather than real solutions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，JavaScript专业人士遇到的一个问题是语言中缺乏模块系统。最初，社区开发了不同的模式，旨在强制执行我们生产的软件的模块化和封装。这些模式包括模块模式，它利用了函数词法作用域和闭包的优势。另一个例子是命名空间模式，它将不同的命名空间表示为嵌套对象。AngularJS引入了自己的模块系统，但遗憾的是，它不提供诸如懒加载模块等特性。然而，这些模式更像是一种权宜之计，而不是真正的解决方案。
- en: '**CommonJS** (used in node.js) and **AMD** (short for, **Asynchronous Module
    Definition**) were later invented. They are still widely used today and provide
    features such as handling of circular dependencies and asynchronous module loading
    (in AMD).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**CommonJS**（在node.js中使用）和**AMD**（异步模块定义的缩写）后来被发明。它们至今仍被广泛使用，并提供处理循环依赖和异步模块加载（在AMD中）等功能。'
- en: 'TC39 took the best of the existing module systems and introduced this concept
    on a language level. ES2015 provides two APIs to define and consume modules. They
    are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: TC39 取了现有模块系统的最佳之处，并在语言级别上引入了这个概念。ES2015提供了两个API来定义和消费模块。它们如下所示：
- en: Declarative API
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式API
- en: Imperative API using a module loader
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块加载器的命令式API
- en: Angular takes full advantage of the ES2015 module system, so let's dive into
    it! In this section, we will take a look at the syntax used for the declarative
    definition and consumption of modules. We will also take a peek at the API of
    the module loader in order to see how we can programmatically load modules in
    an explicit asynchronous manner.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Angular充分利用了ES2015模块系统，所以让我们深入探讨！在本节中，我们将查看用于声明式定义和消费模块的语法。我们还将窥视模块加载器的API，以了解我们如何以显式异步的方式编程加载模块。
- en: Using the ES2015 module syntax
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ES2015模块语法
- en: 'Let''s take a look at an example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding snippet, we defined a simple ES2015 module in the `math.ts`
    file. We can think of it as a sample math Angular utility module. Inside it, we
    define and export the `square` and `log` functions and the constants `E` and `PI`.
    The `const` keyword is another keyword brought by ES2015 that is used to define
    constants. As you can see, what we do is nothing more than prefixing the definitions
    of the function with the `export` keyword. If we want to export the entire functionality
    in the end and skip the duplicate explicit usage of `export`, we can use the following
    approach:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在`math.ts`文件中定义了一个简单的ES2015模块。我们可以将其视为一个示例数学Angular实用模块。在其中，我们定义并导出`square`和`log`函数以及常量`E`和`PI`。`const`关键字是ES2015带来的另一个关键字，用于定义常量。正如你所见，我们所做的一切不过是给函数的定义前加上`export`关键字。如果我们想最终导出整个功能并跳过重复的显式`export`使用，我们可以使用以下方法：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The syntax on the last line is an enhanced object literal syntax, introduced
    by ES2015\. Now, let''s take a look at how we can consume this module:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行的语法是增强的对象字面量语法，由ES2015引入。现在，让我们看看我们如何消费这个模块：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As an identifier of the module, we use its relative path to the current file.
    Using destructuring, we import the required symbols: in this case, `square`, `log` and
    `E`. Now run the `app.ts` file with `ts-node`: `ts-node app.ts`. As output on
    the screen you should see:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 作为模块的标识符，我们使用其相对于当前文件的相对路径。使用解构，我们导入所需的符号：在这种情况下，`square`、`log`和`E`。现在使用`ts-node`运行`app.ts`文件：`ts-node
    app.ts`。屏幕上的输出应该是：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Taking advantage of the implicit asynchronous behavior of the module
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用模块的隐式异步行为
- en: An important thing to note is that the ES2015 module syntax has implicit asynchronous
    behavior.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要问题是，ES2015模块语法具有隐式的异步行为。
- en: '![](img/531918ef-6460-4640-af28-91457c3e19f9.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/531918ef-6460-4640-af28-91457c3e19f9.png)'
- en: Figure 2
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: In the preceding diagram (*Figure 2)*, we have the `A`, `B`, and `C` modules.
    The `A` module uses the `B` and `C` modules, so it depends on them. Once the user
    requires the `A` module, the JavaScript module loader will need to load the `B`
    and `C` modules before being able to invoke any of the logic that resides in the
    `A` module because of the dependencies they have. The `B` and `C` modules will
    be loaded asynchronously. Once they are loaded completely, the JavaScript virtual
    machine will be able to execute the `A` module.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图（*图2*）中，我们有`A`、`B`和`C`模块。`A`模块使用`B`和`C`模块，因此它依赖于它们。一旦用户需要`A`模块，JavaScript模块加载器需要先加载`B`和`C`模块，然后才能调用`A`模块中驻留的任何逻辑，因为这些依赖项。`B`和`C`模块将异步加载。一旦它们完全加载，JavaScript虚拟机将能够执行`A`模块。
- en: Usually, the modern bundlers are going to combine `A`, `B`, and `C` in a single
    file in order to reduce the overhead of the additional HTTP requests that the
    browser needs to perform in order to resolve the dependencies of `A`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，现代打包器会将`A`、`B`和`C`合并到一个文件中，以减少浏览器在解析`A`的依赖项时需要执行的额外HTTP请求的开销。
- en: Using aliases
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用别名
- en: 'Another typical situation is when we want to use an alias for a given export.
    For example, if we use a third-party library, we may want to rename some of its
    exports in order to escape name collisions or just to have a more convenient naming:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个典型的情况是我们想为给定的导出使用别名。例如，如果我们使用第三方库，我们可能想重命名其中的一些导出，以避免名称冲突或仅仅为了更方便的命名：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Importing all the module exports
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入所有模块导出
- en: 'We can import the entire `math` module using the following syntax:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下语法导入整个`math`模块：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The semantics behind this syntax is quite similar to CommonJS, although, in
    the browser, we have implicit asynchronous behavior.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法的语义与CommonJS非常相似，尽管在浏览器中，我们具有隐式的异步行为。
- en: Keep in mind that the `import *` syntax is often not recommended because it
    will get all the exported symbols from the target module even if we don't need
    them. This can lead to an unnecessary increase in the size of the production build
    of our applications.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`import *`语法通常不推荐使用，因为它将从目标模块获取所有导出的符号，即使我们不需要它们。这可能导致我们应用程序的生产构建大小的无谓增加。
- en: Default exports
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认导出
- en: 'If a given module defines an `export`, which would quite likely be used by
    any of its consumer modules, we can take advantage of the default `export` syntax:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模块定义了一个`export`，这很可能被其任何消费者模块使用，我们可以利用默认的`export`语法：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In order to consume this module, we can use the following `app.ts` file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消费此模块，我们可以使用以下`app.ts`文件：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, if we want to import the default export, together with additional
    exports, we can use this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们想导入默认导出以及额外的导出，我们可以使用以下方法：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In general, the default export is nothing more than an named export named with
    the `default` reserved word:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，默认导出不过是一个用`default`保留字命名的命名导出：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ES2015 module loader
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES2015模块加载器
- en: The new version of the standard defines a programmatic API to work with modules.
    This is the so called module loader API. It allows us to define and import modules,
    or configure the module loading.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的新版本定义了一个用于处理模块的程序化API。这就是所谓的模块加载器API。它允许我们定义和导入模块，或配置模块加载。
- en: 'Let''s suppose we have the following module definition in the `app.js` file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在`app.js`文件中有以下模块定义：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'From the `init.js` file, we can programmatically load the `app` module and
    invoke its `main` function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从`init.js`文件中，我们可以程序化地加载`app`模块并调用其`main`函数：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The global object `System` has a method called `import` that allows us to import
    modules using their identifier. In the preceding snippet, we import the `app`
    module defined in `app.js`. Moreover, `System.import` returns a promise that can
    be resolved on success or rejected in case of an error. Once the promise is resolved
    as the first parameter of the callback passed to `then`, we will get the module
    instance. The first parameter of the callback registered in case of rejection
    is an object representing the error that happened.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 全局对象`System`有一个名为`import`的方法，允许我们使用它们的标识符导入模块。在前面的代码片段中，我们导入了在`app.js`中定义的`app`模块。此外，`System.import`返回一个promise，可以在成功时解析或在出错时拒绝。一旦promise作为传递给`then`的回调函数的第一个参数解析，我们将得到模块实例。在拒绝的情况下注册的回调函数的第一个参数是一个表示发生错误的对象。
- en: The code from the previous snippet does not exist in the GitHub repository since
    it requires additional configuration and is not crucial for our purposes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的代码在GitHub仓库中不存在，因为它需要额外的配置，并且对我们来说不是至关重要的。
- en: ES2015 and ES2016 recap
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES2015和ES2016回顾
- en: Congratulations! We're more than halfway toward learning TypeScript. All the
    features we just saw are part of TypeScript since it implements a superset of
    JavaScript; since all these features are an upgrade on top of the current syntax,
    they are easy for experienced JavaScript developers to grasp.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们学习TypeScript已经超过了一半。我们刚刚看到的所有功能都是TypeScript的一部分，因为TypeScript实现了JavaScript的超集；由于所有这些功能都是在当前语法之上进行的升级，所以对于经验丰富的JavaScript开发者来说很容易掌握。
- en: In the next sections, we will describe all the amazing features of TypeScript
    that are outside the intersection with ECMAScript.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将描述TypeScript的所有令人惊叹的功能，这些功能超出了与ECMAScript的交集。
- en: Taking advantage of static typing
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用静态类型
- en: Static typing is what can provide better tooling for our development process.
    While writing JavaScript, the most that IDEs and text editors can do is to highlight
    syntax and provide some basic autocompletion suggestions based on sophisticated
    type inference for our code. This means that we can only verify that we haven't
    made any typos by running the code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型是能够为我们提供更好的开发过程工具的东西。在编写JavaScript时，IDE和文本编辑器能做的最多就是突出显示语法，并根据我们代码的复杂类型推断提供一些基本的自动完成建议。这意味着我们只能通过运行代码来验证我们没有犯任何错误。
- en: In the previous sections, we described the new features provided by ECMAScript
    expected to be implemented by browsers in the near future. In this section, we
    will take a look at what TypeScript provides in order to help us be less error
    prone and more productive. At the time of writing this book, there were no plans
    to implement built-in support for static typing in the browsers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们描述了ECMAScript预期在不久的将来由浏览器实现的新功能。在本节中，我们将探讨TypeScript提供了哪些功能，以帮助我们减少错误并提高生产力。在撰写本书时，没有计划在浏览器中实现内置的静态类型支持。
- en: The TypeScript code goes through intermediate preprocessing that performs the
    type checking and drops all the type annotations in order to provide valid JavaScript
    supported by modern browsers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript代码会经过中间预处理，执行类型检查并丢弃所有类型注解，以便提供现代浏览器支持的有效的JavaScript。
- en: Using explicit type declarations
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用显式类型声明
- en: 'Just like Java and C++, TypeScript allows us to explicitly declare the type
    of the given variable:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Java和C++一样，TypeScript允许我们显式声明给定变量的类型：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding line defines the `foo` variable in the current block using the
    `let` syntax. We explicitly declare that we want `foo` to be of the `number` type
    and we set the value of `foo` to `42`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行使用`let`语法在当前块中定义了`foo`变量。我们明确声明我们希望`foo`是`number`类型，并将`foo`的值设置为`42`。
- en: 'Now, let''s try to change the value of `foo`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试更改`foo`的值：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, after the declaration of `foo`, we will set its value to the `''42''`
    string. This is a perfectly valid JavaScript code; however, if we compile it using
    the TypeScript''s compiler, we will get this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在声明`foo`之后，我们将将其值设置为`'42'`字符串。这是一段完全有效的JavaScript代码；然而，如果我们使用TypeScript的编译器来编译它，我们会得到以下结果：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once `foo` is associated with the given type, we cannot assign to it values
    belonging to different types. This is one of the reasons we can skip the explicit
    type definition in case we assign a value to the given variable:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`foo`与给定的类型相关联，我们就不能将其分配给属于不同类型的值。这是我们可以在给定的变量赋值时跳过显式类型定义的原因之一：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The semantics of this code will be the same as the one with the explicit type
    definition because of the type inference of TypeScript. We'll further take a look
    at it at the end of this chapter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TypeScript的类型推断，此代码的语义将与具有显式类型定义的代码相同。我们将在本章末尾进一步探讨它。
- en: The any type
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任何类型
- en: 'All the types in TypeScript are subtypes of a type called `any`. We can declare
    variables belonging to the `any` type using the `any` keyword. Such variables
    can hold the value of any type:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript中的所有类型都是称为`any`的类型的一个子类型。我们可以使用`any`关键字声明属于`any`类型的变量。这样的变量可以持有任何类型的值：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding code is a valid TypeScript, and it will not throw any error during
    compilation or runtime. If we use the `any` type for all of our variables, we
    will be basically writing the code with dynamic typing, which drops all the benefits
    of the TypeScript's compiler. This is why we have to be careful with `any` and
    use it only when it is necessary.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是有效的 TypeScript 代码，在编译或运行时不会抛出任何错误。如果我们为所有变量使用 `any` 类型，我们基本上就是在使用动态类型编写代码，这将丢失
    TypeScript 编译器的所有好处。这就是为什么我们必须小心使用 `any`，并且只在必要时使用它。
- en: 'Other types in TypeScript that we will take a look at are as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中我们将要探讨的其他类型如下：
- en: '**Primitive types**: These include the Number, String, Boolean, Void, Null,
    Undefined, and Enum types'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始类型**：这些包括 Number、String、Boolean、Void、Null、Undefined 和 Enum 类型'
- en: '**Object types**: These include Function types, classes and interface type
    references, array types, tuple types, function types, and constructor types'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象类型**：这些包括函数类型、类和接口类型引用、数组类型、元组类型、函数类型和构造函数类型'
- en: '**Type parameters**: These include Generics that will be described in the *Writing
    generic code using type parameters* section'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型参数**：这些包括将在 *使用类型参数编写泛型代码* 部分中描述的泛型'
- en: Understanding the primitive types
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解原始类型
- en: 'Most of the primitive types in TypeScript are the ones we are already familiar
    with in JavaScript: Number, String, Boolean, Null, and Undefined. So, we will
    skip their formal explanation here. Another set of types that is handy while developing
    Angular applications is the `enum` types defined by users.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中的大多数原始类型是我们已经在 JavaScript 中熟悉的：Number、String、Boolean、Null 和 Undefined。因此，我们在这里将跳过它们的正式解释。另一组在开发
    Angular 应用程序时很有用的类型是由用户定义的 `enum` 类型。
- en: The Enum types
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举类型
- en: 'The Enum types are primitive user-defined types that, according to the specification,
    are subclasses of Number. The concept of enums exists in the Java, C++, and C#
    languages, and it has the same semantics in TypeScript: user-defined types consisting
    of sets of named values called elements. In TypeScript, we can define an `enum`
    using the following syntax:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型是原始用户定义类型，根据规范，它们是 Number 的子类。枚举的概念存在于 Java、C++ 和 C# 语言中，在 TypeScript 中具有相同的语义：由称为元素的一组命名值组成的用户定义类型。在
    TypeScript 中，我们可以使用以下语法定义一个 `enum`：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will be translated to the following JavaScript:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被翻译成以下 JavaScript：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can use the `enum` type as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `enum` 类型如下：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Understanding the object types
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解对象类型
- en: In this section, we will take a look at the array and function types, which
    belong to the more generic class of Object types. We will also explore how we
    can define classes and interfaces. Tuple types were introduced by TypeScript 1.3,
    and their main purpose is to allow the language to begin typing the new features
    introduced by ES2015, such as destructuring. We will not describe them in this
    book. For further reading, you can take a look at the language's specification
    at [http://www.typescriptlang.org](http://www.typescriptlang.org).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨数组类型和函数类型，它们属于更通用的对象类型类别。我们还将探讨如何定义类和接口。元组类型是在 TypeScript 1.3 中引入的，其主要目的是允许语言开始对
    ES2015 引入的新功能进行类型化，例如解构。我们不会在本书中描述它们。有关进一步阅读，您可以查看语言规范[http://www.typescriptlang.org](http://www.typescriptlang.org)。
- en: The array types
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组类型
- en: In TypeScript, arrays are JavaScript arrays with a common element type. This
    means that we cannot have elements from different types in a given array. We have
    different array types for all the built-in types in TypeScript, plus all the custom
    types that we define.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，数组是具有公共元素类型的 JavaScript 数组。这意味着在给定的数组中我们不能有来自不同类型的元素。我们为 TypeScript
    中的所有内置类型以及我们定义的所有自定义类型提供了不同的数组类型。
- en: 'We can define an array of numbers as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样定义一个数字数组：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we want to have an array, which seems heterogeneous, similar to the arrays
    in JavaScript, we can use the `any[]` type:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个类似 JavaScript 数组的异构数组，我们可以使用 `any[]` 类型：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is possible since the types of all the values we're pushing to the array
    are subtypes of the `any` type and the array we've declared contains values of
    the `any` type.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们推送到数组中的所有值的类型都是 `any` 类型的子类型，并且我们声明的数组包含 `any` 类型的值。
- en: 'We can use the array methods we''re familiar with in JavaScript with all the
    TypeScript Array types:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用在 JavaScript 中熟悉的数组方法与所有 TypeScript 数组类型一起使用：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We also have the square-brackets operator that gives us random access to the
    elements of the array:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个方括号运算符，它允许我们随机访问数组中的元素：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The Function types
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型
- en: 'We''re already familiar with how to define a new function in JavaScript. We
    can use function expression or function declaration:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了如何在 JavaScript 中定义一个新函数。我们可以使用函数表达式或函数声明：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Alternatively, we can use the new arrow function syntax:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用新的箭头函数语法：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The only thing TypeScript alters is the feature to define the types of the
    arguments of the function and the type of its return result (that is, the signature
    of the function). After the compiler of the language performs its type checking
    and transpilation, all the type annotations will be removed. If we use function
    expression and assign a function to a variable, we will be able to define the
    variable type in the following way:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 改变的只是定义函数参数类型和返回结果类型（即函数的签名）的功能。在语言的编译器执行类型检查和转译之后，所有的类型注解都将被移除。如果我们使用函数表达式并将函数赋给一个变量，我们可以以下这种方式定义变量的类型：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Consider the following example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we want to define a method in an object literal, we can do it in the following
    way:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在对象字面量中定义一个方法，我们可以这样做：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding example, we defined an object literal with the method called
    `squareRoot` using the ES2015 syntax.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用 ES2015 语法定义了一个带有 `squareRoot` 方法的对象字面量。
- en: 'In case we want to define a function that produces some side effects instead
    of returning a result, we can declare its return type as `void`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想定义一个产生一些副作用而不是返回结果的函数，我们可以将其返回类型声明为 `void`：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Defining classes
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类
- en: 'TypeScript classes are similar to what ES2015 offers. However, TypeScript alters
    the type declarations and adds more syntax sugar. For example, let''s take the
    `Human` class we defined earlier:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 类与 ES2015 提供的类似。然而，TypeScript 改变了类型声明并添加了更多的语法糖。例如，让我们看看我们之前定义的 `Human`
    类：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There is no difference between the current TypeScript definition and the one
    we already introduced; however, in this case, the declaration of the `_name` property
    is mandatory. Here is how we can use the class:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的 TypeScript 定义与我们之前介绍的定义之间没有区别；然而，在这种情况下，`_name` 属性的声明是强制性的。以下是我们可以如何使用这个类的方式：
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Using access modifiers
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用访问修饰符
- en: 'Similarly, for most conventional object-oriented languages that support classes,
    TypeScript allows a definition of access modifiers. In order to deny direct access
    to the `_name` property outside the class it is defined in, we can declare it
    as private:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于大多数支持类的传统面向对象语言，TypeScript 允许定义访问修饰符。为了防止在定义它的类外部直接访问 `_name` 属性，我们可以将其声明为私有：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The supported access modifiers by TypeScript are as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 支持的访问修饰符如下：
- en: '**Public**: All the properties and methods declared as public can be accessed
    from anywhere'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共**：所有声明为公共的属性和方法都可以从任何地方访问'
- en: '**Private**: All the properties and methods declared as private can be accessed
    only from inside the definition of the class itself'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：所有声明为私有的属性和方法只能从类的定义内部访问'
- en: '**Protected**: All the properties and methods declared as protected can be
    accessed from inside the definition of the class or the definition of any other
    class extending the one that owns the property or the method'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护**：所有声明为受保护的属性和方法都可以从类的定义内部或任何扩展拥有该属性或方法的类的定义内部访问'
- en: 'Access modifiers are a great way to implement Angular services with good encapsulation
    and a well-defined interface. In order to understand this concept better, let''s
    take a look at an example using the hierarchy of the class defined earlier, which
    is ported to TypeScript:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符是实现具有良好封装和明确接口的 Angular 服务的绝佳方式。为了更好地理解这个概念，让我们看看一个使用之前定义的类层次结构的例子，该结构已转换为
    TypeScript：
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Just like ES2015, TypeScript supports the `extends` keyword and desugars it
    to the prototypal JavaScript inheritance.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 ES2015 一样，TypeScript 支持使用 `extends` 关键字，并将其转换为原型 JavaScript 继承。
- en: 'In the preceding example, we set the access modifiers of the `name` and `age`
    properties directly inside the constructor function. The semantics behind this
    syntax differs from the one used in the previous example. It has the following
    meaning: define a protected property called `name` of the `string` type and assign
    the first value passed to the constructor call to it. It is the same for the private
    `age` property. This saves us from explicitly setting the value in the constructor
    itself. If we take a look at the constructor of the `Developer` class, we can
    see that we can use the mixture between these syntaxes. We can explicitly define
    the property in the constructor''s signature, or we can only define that the constructor
    accepts a parameters of the given types.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们直接在构造函数内部设置了`name`和`age`属性的访问修饰符。这个语法背后的语义与上一个例子中使用的不同。它的含义如下：定义一个名为`name`的受保护属性，其类型为`string`，并将构造函数调用传递的第一个值分配给它。对于私有的`age`属性也是一样。这使我们免去了在构造函数中显式设置值的麻烦。如果我们查看`Developer`类的构造函数，我们可以看到我们可以使用这些语法的混合。我们可以在构造函数的签名中显式定义属性，或者我们只定义构造函数接受给定类型的参数。
- en: 'Now, let''s create a new instance of the `Developer` class:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建`Developer`类的一个新实例：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'During compilation, TypeScript will throw an error telling us that:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程中，TypeScript会抛出一个错误告诉我们：
- en: '`Property languages is private and only accessible inside the class "Developer"`.
    Now, let''s see what will happen if we create a new `Human` class and try to access
    its properties from outside its definition:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`属性languages是私有的，并且只能在类"Developer"内部访问`。现在，让我们看看如果我们创建一个新的`Human`类并尝试从其定义外部访问其属性会发生什么：'
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In this case, we''ll get the following two errors:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们会得到以下两个错误：
- en: '`Property age is private and is only accessible inside the class "Human"`,
    and the `Property name is a protected and only accessible inside class "Human"
    and its subclasses`.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`属性age是私有的，并且只能在类"Human"内部访问`，而`属性name是受保护的，并且只能在类"Human"及其子类内部访问`。'
- en: However, if we try to access the `_name` property from inside the definition
    of `Developer`, the compiler won't throw any errors.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试在`Developer`的定义内部访问`_name`属性，编译器不会抛出任何错误。
- en: 'In order to get a better sense of what the TypeScript compiler will produce
    out of a type-annotated class, let''s take a look at the JavaScript produced by
    the following definition:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解TypeScript编译器将从一个类型注解的类中生成什么，让我们看看以下定义生成的JavaScript代码：
- en: '[PRE56]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The resulting ECMAScript 5 will be as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的ECMAScript 5将如下所示：
- en: '[PRE57]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The defined property will be added directly to the objects instantiated when
    calling the constructor function with the `new` operator. This means that once
    the code is compiled, we can directly access the private members of the created
    objects.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 定义好的属性将会直接添加到使用`new`操作符调用构造函数所实例化的对象中。这意味着一旦代码编译完成，我们就可以直接访问创建的对象的私有成员。
- en: In order to wrap this up, access modifiers are added in the language in order
    to help us enforce better encapsulation and get compile-time errors in case we
    violate it.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结，访问修饰符被添加到语言中是为了帮助我们强制更好的封装，并在我们违反它时在编译时得到错误。
- en: Defining interfaces
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义接口
- en: '**Subtyping** in programming languages allows us to treat objects in the same
    way based on the observation that they are specialized versions of a generic object.
    This doesn''t mean that they have to be instances of the same class of objects,
    or that they have a complete intersection between their interfaces. The objects
    might have only a few common properties and still be treated the same way in a
    specific context. In JavaScript, we usually use duck typing. We may invoke specific
    methods for all the objects passed to a function based on the assumption that
    these methods exist. However, all of us have experienced the `undefined is not
    a function` error thrown by the JavaScript interpreter.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言中的**子类型化**允许我们根据观察它们是通用对象的特殊版本，以相同的方式处理对象。这并不意味着它们必须是同一类对象的实例，或者它们在接口之间有完全的交集。这些对象可能只有少数共同属性，但在特定上下文中仍然可以以相同的方式处理。在JavaScript中，我们通常使用鸭子类型。我们可以根据假设这些方法存在，为传递给函数的所有对象调用特定的方法。然而，我们所有人都经历过JavaScript解释器抛出的`undefined
    is not a function`错误。
- en: Object-oriented programming and TypeScript come with a solution. They allow
    us to make sure that our objects have similar behavior if they implement interfaces
    that declare the subset of the properties they own.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程和TypeScript提供了解决方案。它们允许我们确保我们的对象在实现声明了它们拥有的属性子集的接口时具有相似的行为。
- en: 'For example, we can define an interface as `Accountable`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义一个接口为`Accountable`：
- en: '[PRE58]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we can make sure that both `Individual` and `Firm implement` this interface
    by performing the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过执行以下操作来确保`Individual`和`Firm`都实现了这个接口：
- en: '[PRE59]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In case we implement a given interface, we need to provide an implementation
    for all the methods defined inside it, otherwise, the TypeScript compiler will
    throw an error. The methods we implement must have the same signature as the ones
    declared in the interface definition.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实现了一个特定的接口，我们需要为其中定义的所有方法提供实现，否则TypeScript编译器将抛出一个错误。我们实现的方法必须与接口定义中声明的签名相同。
- en: 'TypeScript interfaces also support properties. In the `Accountable` interface,
    we can include a field called `accountNumber` with a type of string:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript接口也支持属性。在`Accountable`接口中，我们可以包含一个名为`accountNumber`的字段，其类型为字符串：
- en: '[PRE60]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We can define it in our class as a field or a getter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在类中将其定义为字段或getter。
- en: Interface inheritance
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口继承
- en: 'Interfaces may also extend each other. For example, we may turn our `Individual`
    class into an interface that has a social security number:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也可以相互扩展。例如，我们可以将我们的`Individual`类转换为一个包含社会保险号的接口：
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Since interfaces support multiple inheritances, `Individual` may also extend
    the `Human` interface that has the `name` and `age` properties:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接口支持多重继承，`Individual`也可以扩展具有`name`和`age`属性的`Human`接口：
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Implementing multiple interfaces
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现多个接口
- en: 'In case the behavior of the class is a union of the properties defined in a
    couple of interfaces, it may implement all of them:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类的行为是几个接口中定义的属性的并集，它可以实现所有这些接口：
- en: '[PRE63]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this case, we need to provide the implementation of all the methods and properties
    declared inside the interfaces our class implements, otherwise, the compiler will
    throw a compile-time error.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要为类实现的接口中声明的所有方法和属性提供实现，否则编译器将抛出一个编译时错误。
- en: Further expressiveness with TypeScript decorators
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TypeScript装饰器进一步增强表达力
- en: 'In ES2015, we are able to decorate only classes, properties, methods, getters,
    and setters. TypeScript takes this further by allowing us to decorate functions
    or method parameters:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2015中，我们只能装饰类、属性、方法、getter和setter。TypeScript进一步允许我们装饰函数或方法参数：
- en: '[PRE64]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Keep in mind that the parameter decorators should not alter any additional behavior.
    Instead, they are used to generate metadata. The most typical use case of these
    decorators is the dependency injection mechanism of Angular.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，参数装饰器不应改变任何额外的行为。相反，它们用于生成元数据。这些装饰器的最典型用例是Angular的依赖注入机制。
- en: Writing generic code using type parameters
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型参数编写泛型代码
- en: 'In the beginning of the section on using static typing, we mentioned the type
    parameters. In order to get a better understanding of them, let''s begin with
    an example. Let''s suppose that we want to implement the classical data structure
    `BinarySearchTree`. Let''s define its interface using a class without applying
    any method implementations:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用静态类型的部分的开头，我们提到了类型参数。为了更好地理解它们，让我们从一个例子开始。假设我们想要实现经典的数据结构`BinarySearchTree`。让我们使用一个没有应用任何方法实现的类来定义它的接口：
- en: '[PRE65]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the preceding snippet, we defined a class called `Node`. The instances of
    this class represent the individual nodes in our tree. Each node has a `left`
    and `right` child nodes and a value of the `any` type; we use `any` in order to
    be able to store data of any type inside our nodes and subsequently inside `BinarySearchTree`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了一个名为`Node`的类。这个类的实例代表我们树中的单个节点。每个节点都有一个`left`和`right`子节点以及一个`any`类型的值；我们使用`any`是为了能够在节点和随后的`BinarySearchTree`中存储任何类型的数据。
- en: Although the earlier implementation looks reasonable, we're giving up on using
    the most important feature that TypeScript provides, that is, static typing. Using
    `any` as a type of the value field inside the `Node` class, we can't take complete
    advantage of the compile-time type checking. This also limits the autocompletion
    and refactoring features that IDEs and text editors provide when we access the
    `value` property of the instances of the `Node` class.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然早期的实现看起来合理，但我们放弃了 TypeScript 提供的最重要功能之一，即静态类型。在`Node`类中，使用`any`作为值字段的类型，我们无法充分利用编译时类型检查。这也限制了
    IDE 和文本编辑器在我们访问`Node`类实例的`value`属性时提供的自动完成和重构功能。
- en: 'TypeScript comes with an elegant solution that is already widely popular in
    the world of static typing: type parameters. Using generics, we can parameterize
    the classes we create with the type parameters. For example, we can turn our `Node`
    class into the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 提供了一个优雅的解决方案，这在静态类型的世界中已经非常流行：类型参数。使用泛型，我们可以使用类型参数来参数化我们创建的类。例如，我们可以将我们的`Node`类转换为以下形式：
- en: '[PRE66]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here, `Node<T>` indicates that this class has a single type parameter called
    `T` that is used somewhere inside the definition of the class. We can use `Node`
    by performing the following snippet:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Node<T>`表示这个类有一个名为`T`的单个类型参数，它在类的定义中某处被使用。我们可以通过以下方式使用`Node`：
- en: '[PRE67]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the preceding snippet, we created three nodes: `numberNode`, `stringNode`,
    and another node of the `Node<number>` type, assigning its value to the right
    child of `numberNode`. Note that since `numberNode` is of the `Node<number>` type,
    we can set its value to `42`, but we can''t use the `''42''` string. The same
    is applicable to its left child. In the definition, we''ve explicitly declared
    that we want the left and right children to be of the `Node<number>` type. This
    means that we cannot assign values of the `Node<string>` type to them; this is
    why, we get the second compile-time error.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了三个节点：`numberNode`、`stringNode`以及另一个`Node<number>`类型的节点，将其值赋给`numberNode`的右子节点。请注意，由于`numberNode`是`Node<number>`类型，我们可以将其值设置为`42`，但不能使用`'42'`字符串。同样的规则适用于其左子节点。在定义中，我们明确声明我们希望左右子节点为`Node<number>`类型。这意味着我们不能将`Node<string>`类型的值赋给它们；这就是为什么我们得到第二个编译时错误的原因。
- en: Using generic functions
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型函数
- en: 'Another typical use of generics is for defining functions that operate over
    a set of types. For example, we may define an `identity` function that accepts
    an argument of type `T` and returns it:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的一个典型用途是定义在一系列类型上操作的功能。例如，我们可能定义一个`identity`函数，它接受类型为`T`的参数并返回它：
- en: '[PRE68]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'However, in some cases, we may want to use only the instances of the types
    that have some specific properties. For achieving this, we can use an extended
    syntax that allows us to declare that we want the types used as type parameters
    to be subtypes of the given type:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，我们可能只想使用具有某些特定属性的类型的实例。为了实现这一点，我们可以使用一个扩展语法，允许我们声明我们希望用作类型参数的类型是给定类型的子类型：
- en: '[PRE69]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: For example, here, we defined an interface called `Comparable`. It has a single
    operation called `compare`. The classes that implement the `Comparable` interface
    need to implement the `compare` operation. When `compare` is called with a given
    argument, it returns `1` if the target object is bigger than the passed argument,
    `0` if they are equal, and `-1` if the target object is smaller than the passed
    argument.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这里，我们定义了一个名为`Comparable`的接口。它有一个名为`compare`的操作。实现`Comparable`接口的类需要实现`compare`操作。当`compare`与给定的参数一起调用时，如果目标对象大于传递的参数，则返回`1`；如果它们相等，则返回`0`；如果目标对象小于传递的参数，则返回`-1`。
- en: Having multiple type parameters
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有多个类型参数
- en: 'TypeScript allows us to use multiple type parameters:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 允许我们使用多个类型参数：
- en: '[PRE70]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In this case, we can create an instance of the `Pair<K, V>` class using the
    following syntax:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用以下语法创建`Pair<K, V>`类的实例：
- en: '[PRE71]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Writing less verbose code with the type inference of TypeScript
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TypeScript 的类型推断编写更简洁的代码
- en: Static typing has a number of benefits; however, it makes us write a more verbose
    code by adding all the type annotations.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型有许多优点；然而，它通过添加所有类型注解，使我们编写的代码更加冗长。
- en: 'In some cases, the compiler of TypeScript is able to guess the types of expressions
    inside our code; let''s consider this example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，TypeScript 的编译器能够猜测我们代码中表达式的类型；让我们考虑这个例子：
- en: '[PRE72]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the preceding snippet, we defined an `answer` variable and assigned the value
    `42` to it. Since TypeScript is statically typed and the type of a variable cannot
    change once declared, the compiler is smart enough to guess that the type of `answer`
    is `number`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们定义了一个名为`answer`的变量并将其赋值为`42`。由于TypeScript是静态类型的，变量的类型一旦声明就不能改变，因此编译器足够智能，可以猜测`answer`的类型是`number`。
- en: 'If we don''t assign a value to a variable within its definition, the compiler
    will set its type to `any`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不在其定义中为变量赋值，编译器将将其类型设置为`any`：
- en: '[PRE73]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The preceding snippet will compile without any compile-time errors.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将编译而不会出现任何编译时错误。
- en: Best common type
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳公共类型
- en: 'Sometimes, the type inference could be a result of several expressions. Such
    is the case when we assign a heterogeneous array to a variable:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，类型推断可能是几个表达式的结果。这种情况发生在我们将异构数组赋值给变量时：
- en: '[PRE74]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In this case, the type of `x` will be `any[]`. However, suppose we have the
    following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`x`的类型将是`any[]`。然而，假设我们有以下情况：
- en: '[PRE75]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The type of `x` will then be `number[]` since the `Number` type is a subtype
    of `Null`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Number`类型是`Null`的子类型，因此`x`的类型将是`number[]`。
- en: Contextual type inference
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文类型推断
- en: 'Contextual typing occurs when the type of an expression is implied from its
    location; let''s take this example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文类型发生在表达式的类型从其位置隐含时；让我们看看这个例子：
- en: '[PRE76]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In this case, the type of the argument of the `e` callback is *guessed* by the
    compiler based on the context in which it is used. The compiler understands that
    the type of `e` is based on the call of `addEventListener` and the arguments passed
    to the method. In case we were using a keyboard event (`keydown`, for example),
    TypeScript would have been aware that `e` is of the `KeyboardEvent` type.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`e`回调函数的参数类型是由编译器根据其使用的上下文来猜测的。编译器理解`e`的类型是基于`addEventListener`的调用和传递给方法的参数。如果我们使用键盘事件（例如`keydown`），TypeScript就会知道`e`是`KeyboardEvent`类型。
- en: Type inference is a mechanism that allows us to write less verbose code by taking
    advantage of the static analysis performed by TypeScript. Based on the context,
    the compiler of TypeScript is able to guess the type of a given expression without
    explicit definition.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断是一种机制，通过利用TypeScript执行的静态分析，我们可以编写更简洁的代码。根据上下文，TypeScript的编译器能够根据给定的表达式推断其类型，而无需显式定义。
- en: Introducing structural typing
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入结构化类型
- en: An important feature of the type system of TypeScript is that it's **structurally
    typed**. Formally this means that the types equivalence and compatibility are
    determined by the structure of the types, not by other characteristics such as
    name or inheritance hierarchy.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的类型系统的一个重要特性是它是**结构化类型**。形式上这意味着类型的等价性和兼容性是由类型的结构决定的，而不是由名称或其他特征（如继承层次结构）决定的。
- en: 'This may sound quite abstract at first, so let''s take a look at a specific
    example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始听起来相当抽象，所以让我们看看一个具体的例子：
- en: '[PRE77]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The preceding snippet defines an interface called `Namable`, which has a declaration
    of a single property called `name`. We also define the `Cat` and `Castle` classes:
    both of them having a `name` property but neither of them implementing the `Namable`
    interface.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段定义了一个名为`Namable`的接口，它有一个名为`name`的单个属性声明。我们还定义了`Cat`和`Castle`类：它们都有`name`属性，但都没有实现`Namable`接口。
- en: 'If we invoke `formatName` with a new instance of `Cat` or `Castle`, the code
    will compile just fine:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用`Cat`或`Castle`的新实例调用`formatName`，代码将正常编译：
- en: '[PRE78]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In this case, we won't get any compile type errors because the properties that
    the `Namable` interface declares are a subset of the properties declared by `Cat`
    and `Castle`. Although in this case, the explicit interface implementation may
    look unnecessary, it's much more convenient to have it because during development
    of a given class; we'll get an inline error in our text editor or IDE in case
    of incorrect interface implementation. To some of the readers, this may look familiar
    to the *implicit interface implementation* in Go, however, we can go one step
    further.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不会得到任何编译类型错误，因为`Namable`接口声明的属性是`Cat`和`Castle`声明的属性的子集。尽管在这种情况下，显式接口实现可能看起来是不必要的，但它更加方便，因为在开发特定类时，如果接口实现不正确，我们将在文本编辑器或IDE中得到内联错误。对于一些读者来说，这可能会让人联想到Go中的*隐式接口实现*，然而，我们可以更进一步。
- en: 'Now let''s take the signature of `formatName` to the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`formatName`的签名如下：
- en: '[PRE79]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now we can perform this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以执行以下操作：
- en: '[PRE80]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If we invoke `formatName` with an instance of `Castle`, the code will compile
    just fine again! This is due to compatibility of the `Cat` and `Castle` classes:
    the `Cat` class has a subset of the properties declared by `Castle`. This may
    look unnatural to developers used to nominal typing, since in this case `Cat`
    and `Castle` are not in the same inheritance chain.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `Castle` 实例调用 `formatName`，代码将再次编译无误！这是由于 `Cat` 和 `Castle` 类的兼容性：`Cat`
    类具有由 `Castle` 声明的属性子集。对于习惯于命名类型开发的开发者来说，这可能会显得不自然，因为在这种情况下，`Cat` 和 `Castle` 不在同一个继承链中。
- en: 'Now, let''s change the definition of the `Cat` class definition to the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将 `Cat` 类定义的说明改为以下内容：
- en: '[PRE81]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If we keep the same signature of the `formatName` function, then invoking `formatName`
    with an instance of `Castle` will produce an error:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保持 `formatName` 函数相同的签名，那么使用 `Castle` 实例调用 `formatName` 将会产生错误：
- en: '[PRE82]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As the compilation error says, we cannot pass objects instances of a class that
    lacks some of the properties or methods of the type of the parameter of a given
    function or method signature.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 正如编译错误所说，我们不能传递缺少某些属性或方法的对象实例，这些属性或方法是给定函数或方法签名参数的类型。
- en: 'Now that we''re familiar with structural typing, let''s go to our next stop:
    ambient type definitions.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了结构化类型，让我们继续我们的下一站：环境类型定义。
- en: Using ambient type definitions
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用环境类型定义
- en: Although static typing is amazing, most of the frontend libraries we use are
    built with JavaScript, which is dynamically typed. Since we'd want to use TypeScript
    with Angular, not having type definitions in the code that uses external JavaScript
    libraries is a big issue; it prevents us from taking advantage of the compile-time
    type checking.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然静态类型很神奇，但我们使用的许多前端库都是用 JavaScript 构建的，它是动态类型的。由于我们想与 Angular 一起使用 TypeScript，因此使用外部
    JavaScript 库的代码中没有类型定义是一个大问题；它阻止了我们利用编译时类型检查的优势。
- en: TypeScript was built keeping these points in mind. In order to allow the TypeScript
    compiler to take care of what it does best, we can use the so called ambient type
    definitions. They allow us to provide external type definitions for the existing
    JavaScript libraries. This way, they provide hints to the compiler.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的构建考虑到了这些要点。为了使 TypeScript 编译器负责其最擅长的事情，我们可以使用所谓的环境类型定义。它们允许我们为现有的
    JavaScript 库提供外部类型定义。这样，它们为编译器提供提示。
- en: Using predefined ambient type definitions
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预定义的环境类型定义
- en: Fortunately, we don't have to create ambient type definitions for all JavaScript
    libraries and frameworks we use. The community and/or the authors of these libraries
    have already published such definitions online; the biggest repository resides
    at [https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped).
    During the last couple of months, the community developed a few tools for managing
    ambient type definitions, such as `tsd` and `typings`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要为我们使用的所有 JavaScript 库和框架创建环境类型定义。这些库的社区和/或作者已经在线上发布了此类定义；最大的存储库位于
    [https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)。在过去的几个月里，社区开发了一些用于管理环境类型定义的工具，例如
    `tsd` 和 `typings`。
- en: 'Later, Microsoft introduced an official way to manage them: using **`npm`**
    by providing an additional configuration in `tsconfig.json`. The type definitions
    are now distributed as scoped packages under the `@types` namespace and installed
    in `node_modules`.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，微软引入了一种官方的方式来管理它们：通过在 `tsconfig.json` 中提供额外的配置来使用 **`npm`**。现在，类型定义作为带有 `@types`
    命名空间的范围包分发，并安装到 `node_modules` 中。
- en: 'Let''s create a directory and add a `package.json` file to it:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个目录并向其中添加一个 `package.json` 文件：
- en: '[PRE83]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'After we provide the default values for the properties that `npm` asks us,
    our `package.json`  file in the `types-test` directory should look something like
    this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为 `npm` 请求的属性提供默认值后，`types-test` 目录中的 `package.json` 文件应该看起来像这样：
- en: '[PRE84]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We can install a new type definition using this command:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此命令安装新的类型定义：
- en: '[PRE85]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The preceding command will download the type definitions for AngularJS and save
    them in `node_modules/@types/angular`. Note that we provided the `--save-dev`
    flag to `npm` in order to save the type definition under `devDependencies` of
    `package.json`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将下载 AngularJS 的类型定义并将它们保存到 `node_modules/@types/angular` 中。请注意，我们向 `npm`
    提供了 `--save-dev` 标志，以便将类型定义保存到 `package.json` 的 `devDependencies` 下。
- en: When installing ambient type definitions, we would usually use `--save-dev`
    instead of `--save`, because the definitions are mostly used in development.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装环境类型定义时，我们通常会使用`--save-dev`而不是`--save`，因为定义主要用于开发。
- en: 'After running the preceding command, your `package.json` file should look similar
    to this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的命令后，你的`package.json`文件应该看起来像这样：
- en: '[PRE86]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, in order to use AngularJS with TypeScript, create `app.ts` and enter the
    following content:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使用TypeScript与AngularJS，创建`app.ts`文件并输入以下内容：
- en: '[PRE87]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'To compile `app.ts`, use the following command:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译`app.ts`，使用以下命令：
- en: '[PRE88]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The TypeScript compiler will output the compiled content into `app.js`. In order
    to add extra automation and invoke the TypeScript compiler each time we change
    any of the files in our project, we can use a task runner, such as gulp or grunt,
    or pass the `-w` option to `tsc`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器会将编译内容输出到`app.js`文件中。为了添加额外的自动化并每次我们更改项目中的任何文件时都调用TypeScript编译器，我们可以使用任务运行器，如gulp或grunt，或者将`-w`选项传递给`tsc`。
- en: Since using the `reference` element for including type definitions is considered
    bad practice, we can use a `tsconfig.json` file instead. There, we can configure
    which directories need to be included in the compilation process by `tsc`. For
    more information, visit [http://www.typescriptlang.org/docs/handbook/tsconfig-json.html](http://www.typescriptlang.org/docs/handbook/tsconfig-json.html).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用`reference`元素来包含类型定义被认为是不良实践，我们可以使用`tsconfig.json`文件代替。在那里，我们可以通过`tsc`配置需要包含在编译过程中的目录。更多信息，请访问[http://www.typescriptlang.org/docs/handbook/tsconfig-json.html](http://www.typescriptlang.org/docs/handbook/tsconfig-json.html)。
- en: 'Now, let''s create a file called `tsconfig.json` in the same directory, with
    the following content:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在同一目录下创建一个名为`tsconfig.json`的文件，内容如下：
- en: '[PRE89]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In this configuration file, we provide the `compilerOptions` property so that
    we don't have to pass parameters, such as `outDir` and `module` formats, as flags
    to `tsc`. Note that in the `files` property, we also list the files that we want
    to be compiled. TypeScript will compile all of them plus all their transitive
    dependencies!
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置文件中，我们提供了`compilerOptions`属性，这样我们就不需要将`outDir`和`module`格式等参数作为标志传递给`tsc`。注意，在`files`属性中，我们还列出了我们想要编译的文件。TypeScript将编译所有这些文件以及它们的传递依赖项！
- en: 'Now, let''s modify our preceding simple snippet:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改我们之前简单的代码片段：
- en: '[PRE90]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The only change we made was to add the line where we declare and initialize
    a new constant with the returned result by the invocation of the `Set` constructor
    function, with `any` as the type parameter. By having `tsconfig.json` in the same
    directory where our `app.ts` file and `node_modules` are, we can compile the project
    by running this command:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的唯一更改是在声明和初始化一个新常量时，使用`Set`构造函数的返回结果，并将`any`作为类型参数。由于`tsconfig.json`文件位于我们的`app.ts`文件和`node_modules`目录中，我们可以通过运行以下命令来编译项目：
- en: '[PRE91]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'However, we''ll get the following error:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们会遇到以下错误：
- en: '`demo.ts(4,22): error TS2304: Cannot find name ''Set''`.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`demo.ts(4,22): error TS2304: Cannot find name ''Set''`。'
- en: 'Here, `Set` implements the set data structure and is part of the ES2015 standard.
    Since using the ambient type definitions for ES2015 is a very common practice
    in all TypeScript projects, Microsoft added them as part of TypeScript itself.
    To the `compilerOptions` property inside `tsconfig.json`, add the following `lib`
    property:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Set`实现了集合数据结构，并作为ES2015标准的一部分。由于在所有TypeScript项目中使用ES2015的环境类型定义是一种非常常见的做法，Microsoft将其作为TypeScript本身的一部分添加。在`tsconfig.json`中的`compilerOptions`属性中，添加以下`lib`属性：
- en: '[PRE92]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Here, `lib` has the value of an array, which includes both `"es2015"` and `"dom"`
    because we need ES2015 Set, and the type definitions of Angular require the type
    definitions for the **Document Object Model** (**DOM**). Now when we run `tsc`
    in the directory where your `tsconfig.json` file is located, the compilation process
    should pass successfully and the output file should be located in `./dist/demo.js`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`lib`的值为一个数组，它包含`"es2015"`和`"dom"`，因为我们需要ES2015 Set，并且Angular的类型定义需要**文档对象模型**（**DOM**）的类型定义。现在，当我们在包含`tsconfig.json`文件的目录中运行`tsc`时，编译过程应该成功通过，输出文件应位于`./dist/demo.js`。
- en: Custom ambient type definitions
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义环境类型定义
- en: 'To understand how everything works together, let''s take a look at an example.
    Suppose, we have the following interface of a JavaScript library:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解所有这些是如何协同工作的，让我们看一个例子。假设，我们有一个JavaScript库的以下接口：
- en: '[PRE93]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We have an object literal assigned to a variable called `DOM`. The object has
    the following methods:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个对象字面量赋值给一个名为`DOM`的变量。该对象具有以下方法：
- en: '`selectElements`: This accepts a single argument with the `string` type and
    returns a set of `DOM` elements'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectElements`：这个函数接受一个字符串类型的单个参数，并返回一组`DOM`元素'
- en: '`hide`: This accepts a `DOM` node as an argument and returns nothing'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hide`：这个函数接受一个`DOM`节点作为参数，并返回空值'
- en: '`show`: This accepts a `DOM` node as an argument and returns nothing'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show`：这个函数接受一个`DOM`节点作为参数，并返回空值'
- en: 'In TypeScript, the preceding definition would look as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，前面的定义如下所示：
- en: '[PRE94]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This means that we can define the interface of our library as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以按照以下方式定义我们库的接口：
- en: '[PRE95]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'After we have the interface of our library, it will be easy to create the ambient
    type definition; we just have to create a file with a `d.ts` extension called
    `dom` and enter the following content:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了我们库的界面之后，创建环境类型定义将会变得简单；我们只需创建一个扩展名为`d.ts`的名为`dom`的文件，并输入以下内容：
- en: '[PRE96]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In the preceding snippet, we defined the interface called `DOMLibraryInterface`
    and declared the `DOM` variable of the `DOMLibraryInterface` type.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了一个名为`DOMLibraryInterface`的接口，并声明了`DOM`变量为`DOMLibraryInterface`类型。
- en: 'The only thing left before being able to use static typing with our JavaScript
    library is including the external type definition in the script files we want
    to use our library in. We can do it as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够使用静态类型与我们的JavaScript库一起使用之前，我们唯一剩下的事情是将外部类型定义包含到我们想要使用库的脚本文件中。我们可以这样做：
- en: '[PRE97]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The preceding snippet hints the compiler on where to find the ambient type definitions.
    An alternative, and better, way to provide a reference to the `d.ts` file is to
    use `tsconfig.json` as described earlier.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段提示编译器在哪里可以找到环境类型定义。一种替代的、更好的方法是通过使用前面描述的`tsconfig.json`来提供对`d.ts`文件的引用。
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we made an introduction to the TypeScript language that is
    used for the implementation of Angular.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了用于Angular实现的TypeScript语言。
- en: While exploring the language, we looked at some of the core features of ES2015
    and ES2016\. We explained the ES2015 and ES2016 classes, arrow functions, block
    scope variable definitions, destructuring, and modules. Since Angular takes advantage
    of the ES2016 decorators, and more accurately their extension in TypeScript, a
    section was dedicated to them.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索语言的过程中，我们查看了一些ES2015和ES2016的核心特性。我们解释了ES2015和ES2016的类、箭头函数、块作用域变量定义、解构和模块。由于Angular利用了ES2016装饰器，以及更准确地说，TypeScript中对它们的扩展，因此我们专门用一节来介绍它们。
- en: After this, we took a look at how we can take advantage of static typing using
    explicit type definitions. We described some of the built-in types in TypeScript
    and how we can define classes in the language by specifying access modifiers for
    their members. Our next stop was the interfaces. We ended our adventures in TypeScript
    by explaining the type parameters, structural typing, and the ambient type definitions.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们查看了我们如何利用显式类型定义来利用静态类型。我们描述了TypeScript中的一些内置类型以及我们如何通过指定成员的访问修饰符来在语言中定义类。我们的下一个目的地是接口。我们通过解释类型参数、结构化类型和环境类型定义来结束我们在TypeScript中的冒险。
- en: In the next chapters, we will explore Angular in depth starting with the components
    and directives of the framework.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨Angular，从框架的组件和指令开始。
