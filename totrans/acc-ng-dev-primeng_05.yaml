- en: '*Chapter 9*: Debugging with the New Ivy Runtime APIs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*: 使用新的Ivy运行时API进行调试'
- en: Angular Ivy introduces a new API for inspecting and debugging our Angular applications
    at runtime. It replaces the previous `NgProbe` API and allows tree-shaking of
    `DebugElement`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Ivy引入了一个新的API，用于在运行时检查和调试我们的Angular应用程序。它替换了之前的`NgProbe` API，并允许`DebugElement`进行摇树优化。
- en: 'We will explore Angular''s most useful runtime debugging functions, including
    the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索Angular最有用的运行时调试函数，包括以下内容：
- en: '`ng.applyChanges`'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng.applyChanges`'
- en: '`ng.getComponent`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng.getComponent`'
- en: '`ng.getContext`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng.getContext`'
- en: '`ng.getListeners`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng.getListeners`'
- en: Having these debugging utilities at hand will allow you to verify your assumptions
    about active components, their templates, and their DOM bindings at runtime.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些调试工具将允许您在运行时验证关于活动组件、它们的模板和它们的DOM绑定的假设。
- en: 'This chapter covers these topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Introduction to the new Ivy runtime API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新Ivy运行时API简介
- en: Inspecting an active component
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查活动组件
- en: Inspecting event listeners
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查事件监听器
- en: Inspecting an embedded view context
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查嵌入式视图上下文
- en: Getting familiar with these topics will improve your development workflow when
    implementing Angular Ivy applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉这些主题将提高您实现Angular Ivy应用程序的开发工作流程。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To support all the features used in the code examples of this chapter, your
    application requires at least the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持本章代码示例中使用的所有功能，您的应用程序至少需要以下要求：
- en: Angular Ivy version 12.0
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular Ivy版本12.0
- en: TypeScript version 4.2
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript版本4.2
- en: Also, note that the runtime debugging API is only available when Angular runs
    in development mode.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，运行时调试API仅在Angular以开发模式运行时才可用。
- en: You can find complete code examples for the random number generator in this
    book's companion GitHub repository at [https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter9/random-number](https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter9/random-number).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的配套GitHub仓库中找到随机数生成器的完整代码示例，网址为[https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter9/random-number](https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter9/random-number)。
- en: Introducing the new Ivy runtime API
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新Ivy运行时API介绍
- en: If you have worked with Angular versions before Angular Ivy, you might be familiar
    with the `NgProbe` API, which was available in the global scope at runtime as
    the `ng.probe` function. Angular Ivy replaces this API with a set of new runtime
    debugging functions, which are only available in Angular development mode.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前使用过Angular版本，您可能熟悉`NgProbe` API，该API在运行时作为全局作用域中的`ng.probe`函数可用。Angular
    Ivy用一组新的运行时调试函数替换了此API，这些函数仅在Angular开发模式下可用。
- en: 'The new API contains the following functions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 新API包含以下函数：
- en: '`ng.applyChanges(component: {}): void;`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng.applyChanges(component: {}): void;`'
- en: Mark the specified component for dirty checking if it is using the `OnPush`
    change detection strategy. Afterward, trigger a change detection cycle.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果指定的组件正在使用`OnPush`变更检测策略，则标记该组件进行脏检查。之后，触发变更检测周期。
- en: '`ng.getComponent<T>(element: Element): T | null;`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng.getComponent<T>(element: Element): T | null;`'
- en: Resolve the Angular component that is attached to the specified DOM element.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解析附加到指定DOM元素的Angular组件。
- en: '`ng.getContext<T>(element: Element): T | null;`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng.getContext<T>(element: Element): T | null;`'
- en: When passed a DOM element generated by a structural directive such as `NgIf`
    or `NgFor`, resolve the view context of the embedded view. In other cases, resolve
    the parent component.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当传递由结构指令（如`NgIf`或`NgFor`）生成的DOM元素时，解析嵌入式视图的视图上下文。在其他情况下，解析父组件。
- en: '`ng.getDirectiveMetadata(directiveOrComponentInstance: any): ComponentDebugMetadata
    | DirectiveDebugMetadata | null;`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng.getDirectiveMetadata(directiveOrComponentInstance: any): ComponentDebugMetadata
    | DirectiveDebugMetadata | null;`'
- en: Resolve the metadata of the specified Angular component or directive instance.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解析指定Angular组件或指令实例的元数据。
- en: '`ng.getDirectives(element: Element): {}[];`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng.getDirectives(element: Element): {}[];`'
- en: Resolve Angular directives – but not components – attached to the specified
    DOM element.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解析附加到指定DOM元素的Angular指令（但不是组件）。
- en: '`ng.getHostElement(componentOrDirective: {}): Element;`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng.getHostElement(componentOrDirective: {}): Element;`'
- en: Resolve the host element that the specified component or directive is attached
    to.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解析指定组件或指令附加到的宿主元素。
- en: '`ng.getInjector(elementOrDir: {} | Element): Injector;`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng.getInjector(elementOrDir: {} | Element): Injector;`'
- en: Resolve the injector associated with the specified element, directive, or component.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决与指定元素、指令或组件关联的注入器。
- en: '`ng.getListeners(element: Element): Listener[];`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng.getListeners(element: Element): Listener[];`'
- en: Resolve event listeners attached to the specified DOM element. This does not
    include host listeners created from directive or component metadata but includes
    event listeners not added by Angular.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决附加到指定DOM元素的事件监听器。这不包括由指令或组件元数据创建的主监听器，但包括Angular未添加的事件监听器。
- en: '`ng.getOwningComponent<T>(elementOrDir: {} | Element): T | null;`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng.getOwningComponent<T>(elementOrDir: {} | Element): T | null;`'
- en: Resolve the host component of the specified DOM element, directive, or component.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决指定DOM元素、指令或组件的主组件。
- en: '`ng.getRootComponents(elementOrDir: {} | Element): {}[];`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng.getRootComponents(elementOrDir: {} | Element): {}[];`'
- en: Resolve the root components associated with the specified DOM element, directive,
    or component, that is, the components bootstrapped by Angular.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决与指定DOM元素、指令或组件关联的根组件，即由Angular引导的组件。
- en: 'The `Listener` data structures returned by `ng.getListeners` have the following
    interface:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由`ng.getListeners`返回的`Listener`数据结构具有以下接口：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The data structures returned by `ng.getDirectiveMetadata` have the following
    interfaces:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由`ng.getDirectiveMetadata`返回的数据结构具有以下接口：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `inputs` and `outputs` properties defined in the preceding debug metadata
    interfaces contain object maps from data binding property names to component property
    names.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的调试元数据接口中定义的`inputs`和`outputs`属性包含从数据绑定属性名称到组件属性名称的对象映射。
- en: It is important to be aware that the `ComponentDebugMetadata#changeDetection`
    and `ComponentDebugMetadata#encapsulation` properties are number enumerations,
    so their values will be numbers at runtime, not strings. This makes them a bit
    harder to interpret when debugging.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`ComponentDebugMetadata#changeDetection`和`ComponentDebugMetadata#encapsulation`属性是数字枚举，因此它们的值在运行时将是数字，而不是字符串。这使得它们在调试时稍微难以解释。
- en: As seen in the preceding overview, most of these runtime debugging utilities
    accept as a parameter a DOM element, a component instance, or a directive instance.
    From the specified object, they look up DOM elements, one or more component instances,
    one or more directive instances, an injector, or event listeners attached to the
    DOM.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的概述所示，大多数这些运行时调试实用程序接受一个参数，即DOM元素、组件实例或指令实例。从指定的对象中，它们查找DOM元素、一个或多个组件实例、一个或多个指令实例、一个注入器或附加到DOM的事件监听器。
- en: The one that stands out is `ng.applyChanges`. We will discuss when and how to
    use it in the next section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最引人注目的是`ng.applyChanges`。我们将在下一节讨论何时以及如何使用它。
- en: Inspecting a component instance
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查组件实例
- en: To explore our application programmatically at runtime, we often need a reference
    to an active component instance. Once we have a component reference, we can change
    bound properties and call event handlers or other methods.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在运行时以编程方式探索我们的应用程序，我们通常需要一个活动组件实例的引用。一旦我们有了组件引用，我们就可以更改绑定属性并调用事件处理器或其他方法。
- en: However, first, we need a reference to either a directive instance or a DOM
    element with an attached component. Using the `$0` variable. Alternatively, we
    can use `document.querySelector`, or any other DOM querying or traversing API.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，首先，我们需要一个对指令实例或附加了组件的DOM元素的引用。使用`$0`变量。或者，我们可以使用`document.querySelector`或任何其他DOM查询或遍历API。
- en: 'Say we have a component that generates random numbers, as seen in the following
    figure:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个生成随机数的组件，如图所示：
- en: '![Figure 9.1 – A component for generating a random number'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 生成随机数的组件'
- en: '](img/Figure_9.1_B16295.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_B16295.jpg)'
- en: Figure 9.1 – A component for generating a random number
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 生成随机数的组件
- en: 'It has a component model as seen in the following code block:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有以下代码块中所示组件模型：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In its template, it is using Angular Material''s Button component as seen in
    the following code listing:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在其模板中，它使用Angular Material的按钮组件，如下面的代码列表所示：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Given that we have a reference to the `<button>` DOM element in the `$0` variable,
    we can do the following to resolve two different component instances:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`$0`变量中有一个对`<button>` DOM元素的引用，我们可以执行以下操作以解决两个不同的组件实例：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is a subtle but important distinction between `ng.getComponent` and `ng.getOwningComponent`.
    The first invocation returns an instance of the `MatButton` component, which is
    attached to the `<button>` DOM element. The second invocation gives us a reference
    to the active instance of `RandomNumberComponent`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng.getComponent`和`ng.getOwningComponent`之间存在一个微妙但重要的区别。第一次调用返回一个`MatButton`组件的实例，该实例附加到`<button>`DOM元素上。第二次调用给我们提供了一个`RandomNumberComponent`活动实例的引用。'
- en: We conclude that `ng.getComponent` returns the component attached to the specified
    DOM element, in this case `MatButton`. Now, `ng.getOwningComponent` returns the
    component instance that's associated with the component template used to generate
    the specified DOM element, in this case an instance of `RandomNumberComponent`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得出结论，`ng.getComponent`返回指定DOM元素附加的组件，在本例中是`MatButton`组件。现在，`ng.getOwningComponent`返回与用于生成指定DOM元素的组件模板关联的组件实例，在本例中是一个`RandomNumberComponent`实例。
- en: 'The `generatedNumber` UI property is bound to text in the DOM created for the
    random generator component by Angular. What if we wanted to change it to something
    specific, say `42`? With a reference to an active component instance, we can change
    UI properties directly as seen in the following browser console listing:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`generatedNumber`UI属性绑定到Angular为随机生成器组件创建的DOM中的文本。如果我们想将其更改为特定的值，比如`42`呢？有了活动组件实例的引用，我们可以直接更改UI属性，如下所示：'
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, when looking at the rendered application, we notice that the DOM has
    not been updated to reflect this new component state. When using the runtime debugging
    API, we must let Angular know when we have manually changed the state and want
    Angular to update the DOM it manages.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们查看渲染的应用程序时，我们注意到DOM尚未更新以反映这个新的组件状态。当使用运行时调试API时，我们必须让Angular知道我们已经手动更改了状态，并希望Angular更新它所管理的DOM。
- en: 'We notify Angular of the dirty state by passing the component instance to `ng.applyChanges`
    as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将组件实例传递给`ng.applyChanges`来通知Angular脏状态，如下所示：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After Angular completes a change detection cycle, we notice that the new state
    is reflected in the DOM, as seen in the following figure:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular完成一个变更检测周期后，我们注意到新的状态已反映在DOM中，如下所示：
- en: '![Figure 9.2 – A component displaying a manually specified number'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – 显示手动指定数字的组件'
- en: '](img/Figure_9.2_B16295.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.2_B16295.jpg)'
- en: Figure 9.2 – A component displaying a manually specified number
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 显示手动指定数字的组件
- en: Great, now you are familiar with the most common runtime debugging functions,
    which put us in control of Angular components. In the following sections, we will
    look at debugging APIs that are instrumental to runtime debugging, yet not as
    commonly used.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在你已经熟悉了最常见的运行时调试函数，这些函数使我们能够控制Angular组件。在接下来的章节中，我们将探讨对运行时调试至关重要的调试API，但它们并不像常见的API那样被广泛使用。
- en: Inspecting event listeners
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查事件监听器
- en: We'll reuse the random number generator example from the *Inspecting a component
    instance* section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用来自“检查组件实例”部分的随机数生成器示例。
- en: 'For reference, the following is the random number directive used in the template
    of the random number component:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了参考，以下是在随机数组件模板中使用的随机数指令：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When its `generateNumber` method is called, it outputs the randomly generated
    number through the `numberGenerated` output property. The random number component
    has bound its event handler `RandomNumberComponent#onNumberGenerated` to this
    custom component event.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当其`generateNumber`方法被调用时，它通过`numberGenerated`输出属性输出随机生成的数字。随机数组件已将其事件处理程序`RandomNumberComponent#onNumberGenerated`绑定到这个自定义组件事件上。
- en: DOM event listeners
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DOM事件监听器
- en: We pick the `<button>` element in the `$0`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`$0`中选择了`<button>`元素。
- en: 'Notice in the component template that the button component has a click event
    binding. We want to access it so that we can trigger it. To do that, pass the
    button DOM element to the `ng.getListeners` function, as seen in the following
    browser console listing:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在组件模板中，按钮组件有一个点击事件绑定。我们想要访问它，以便可以触发它。为此，将按钮DOM元素传递给`ng.getListeners`函数，如下所示：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We unpack the first and only event listener that is returned by `ng.getListeners`
    when passed the button DOM element. This `Listener` data structure is stored in
    the `onButtonClick` variable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解包`ng.getListeners`返回的第一个也是唯一的事件监听器，当传递按钮DOM元素时。这个`Listener`数据结构存储在`onButtonClick`变量中。
- en: We invoke the click event handler by invoking `onButtonClick.callback`. This
    triggers the same state update as clicking the **Generate** button. However, Angular
    is not aware of the dirty state.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 `onButtonClick.callback` 来调用点击事件处理器。这触发了与点击 **生成** 按钮相同的州更新。然而，Angular
    并不知道脏状态。
- en: Important Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: DOM event listeners registered outside of Angular code are also returned by
    `ng.getListeners`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 代码之外注册的 DOM 事件监听器也由 `ng.getListeners` 返回。
- en: 'You might remember from the *Inspecting a component instance* section that
    we must notify Angular of state changes we introduce through the runtime debugging
    APIs. We do this by passing the component instance to `ng.applyChanges` as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得在 *检查组件实例* 部分中，我们必须通过运行时调试 API 通知 Angular 我们通过运行时调试 API 引入的状态变化。我们通过将组件实例传递给
    `ng.applyChanges` 来这样做，如下所示：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When Angular finishes a change detection cycle, the newly generated number is
    displayed in the DOM for the random number generator component, which is managed
    by Angular.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Angular 完成变更检测周期后，新生成的数字将在随机数生成组件的 DOM 中显示，该组件由 Angular 管理。
- en: Notice that we did not pass any parameters to the `Listener#callback` method.
    In our use case, the event handler did not accept any parameters. If it did, we
    would most likely have to pass arguments of the expected type for it to work.
    For example, a click event listener might accept a `MouseEvent` event of type
    `click`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有向 `Listener#callback` 方法传递任何参数。在我们的用例中，事件处理器不接受任何参数。如果它接受，我们很可能会需要传递期望类型的参数才能使其工作。例如，一个点击事件监听器可能接受一个类型为
    `click` 的 `MouseEvent` 事件。
- en: Custom component event bindings
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义组件事件绑定
- en: Event handlers bound by Angular custom component event bindings are also registered
    as listeners. Our example component has an inline event handler bound for the
    custom `numberGenerated` event.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Angular 自定义组件事件绑定绑定的事件处理器也被注册为监听器。我们的示例组件为自定义的 `numberGenerated` 事件绑定了一个内联事件处理器。
- en: We pick the `<span>` element in the `$0`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `$0` 中选择 `<span>` 元素。
- en: 'We pass the `span` element to `ng.getListeners`, and notice that it lists two
    listeners, one of type `"dom"` and another one of type `"output"`, as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `span` 元素传递给 `ng.getListeners`，并注意到它列出了两个监听器，一个是类型为 `"dom"` 的监听器，另一个是类型为
    `"output"` 的监听器，如下所示：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We simulate a random number generation by passing `7` to `outputListener.callback`
    and run change detection by passing the component to `ng.applyChanges`. This is
    shown in the following browser console listing:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将 `7` 传递给 `outputListener.callback` 来模拟随机数生成，并通过将组件传递给 `ng.applyChanges`
    来运行变更检测。这如下面的浏览器控制台列表所示：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once a change detection cycle has finished, the random number generation that
    we simulated is displayed in the DOM, which is managed by Angular.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成变更检测周期，我们模拟的随机数生成将在 DOM 中显示，这是由 Angular 管理的。
- en: That is all for inspecting native and custom event listeners using the Angular
    runtime debugging API. In the final section of this chapter, we'll learn what
    an embedded view context is, and how to inspect it using Angular Ivy's runtime
    debugging API.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用 Angular 运行时调试 API 检查原生和自定义事件监听器的全部内容。在本章的最后部分，我们将学习嵌入视图上下文是什么，以及如何使用 Angular
    Ivy 的运行时调试 API 来检查它。
- en: Inspecting an embedded view context
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查嵌入视图上下文
- en: A structural directive is used to add and remove elements to the DOM throughout
    the lifecycle of a component. They create an embedded view, which is bound to
    a view context. This is the case of the `NgIf` and `NgFor` directives that are
    part of the Angular framework.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令用于在组件的生命周期内添加和删除 DOM 元素。它们创建一个嵌入视图，该视图绑定到视图上下文。这是 Angular 框架中 `NgIf` 和 `NgFor`
    指令的情况。
- en: Important Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Only one structural directive can be attached to an element. If you need to
    apply multiple structural directives, wrap the element in the special `<ng-container>`
    element, attach the outer structural directive to this element, and so on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 只能将一个结构指令附加到元素上。如果您需要应用多个结构指令，请将元素包裹在特殊的 `<ng-container>` 元素中，将外部结构指令附加到该元素上，依此类推。
- en: 'When we pass an element with a structural directive attached to `ng.getContext`,
    it returns the view context. For example, when we pass an element with an `NgIf`
    directive attached to it, `NgIfContext` is returned, which has the following shape:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将带有结构指令的元素传递给 `ng.getContext` 时，它返回视图上下文。例如，当我们传递带有 `NgIf` 指令的元素时，返回 `NgIfContext`，它具有以下形状：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The embedded view that is dynamically created by `NgIf` is bound to the `$implicit`
    property of `NgIfContext`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `NgIf` 动态创建的嵌入视图绑定到 `NgIfContext` 的 `$implicit` 属性。
- en: 'If we instead pass an element that has an `NgFor` directive attached to it,
    `NgForOfContext` is returned. It has the following shape:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递一个带有`NgFor`指令的元素，则返回`NgForOfContext`。它具有以下形状：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: An embedded view is dynamically created by the `NgFor` directive for each item
    in `NgForOfContext#ngForOf`. Each embedded view is bound to the `$implicit` property
    of `NgForOfContext` specific to that item.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgFor`指令为`NgForOfContext#ngForOf`中的每个项目动态创建一个嵌入式视图。每个嵌入式视图都绑定到特定于该项目的`NgForOfContext`的`$implicit`属性。'
- en: 'However, each embedded view also has access to the other properties that are
    specified in `NgForOfContext`. For example, we can loop through a list of users
    and store a reference to the `index` and `first` context properties, like so:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每个嵌入式视图也可以访问`NgForOfContext`中指定的其他属性。例如，我们可以遍历用户列表并存储对`index`和`first`上下文属性的引用，如下所示：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The embedded view created for each user has access to and uses the `index` and
    `first` properties, which are aliased as `i` and `isFirst`, respectively.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个用户创建的嵌入式视图可以访问并使用`index`和`first`属性，分别别名为`i`和`isFirst`。
- en: 'Passing a list item element from the previous code listing to `ng.getContext`
    results in an `NgForOfContext` value, such as the examples in the following code
    listing:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将前一个代码列表中的列表项元素传递给`ng.getContext`会导致返回一个`NgForOfContext`值，例如以下代码列表中的示例：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Similarly, if we pass the `<span>` element to `ng.getContext`, we get an `NgIfContext`
    value, such as the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们把`<span>`元素传递给`ng.getContext`，我们得到一个`NgIfContext`值，如下所示：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Take special care to pass the element that has a structural directive attached,
    or you will instead receive the closest component instance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意传递带有结构指令的元素，否则你将收到最近的组件实例。
- en: Now you know how to inspect the embedded view context of template elements with
    a structural directive attached.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道如何检查带有结构指令的模板元素的嵌入式视图上下文。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I hope you like the new shiny tools that we added to your toolbox in this chapter.
    We started with an overview of Angular Ivy's runtime debugging API, which is available
    only in development mode.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你喜欢我们在本章中添加到你的工具箱中的新工具。我们从一个概述开始，介绍了Angular Ivy的运行时调试API，该API仅在开发模式下可用。
- en: Next, we learned how to inspect a component instance using `ng.getComponent`
    and `ng.getOwningComponent`. We also changed the component state, then updated
    the DOM using `ng.applyChanges`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了如何使用`ng.getComponent`和`ng.getOwningComponent`检查组件实例。我们还更改了组件状态，然后使用`ng.applyChanges`更新DOM。
- en: In the *Inspecting event listeners* section, we used `ng.getListeners` to inspect
    both native DOM event listeners and custom component event listeners. We passed
    arguments to their callbacks and triggered change detection using `ng.applyChanges`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*检查事件监听器*部分，我们使用`ng.getListeners`来检查原生DOM事件监听器和自定义组件事件监听器。我们向它们的回调传递参数，并使用`ng.applyChanges`触发变更检测。
- en: Finally, you now know what an embedded view context is and how to inspect it,
    for example, how one is created and bound to each component or element managed
    by the `NgFor` directive. Similarly, we explored an example of an embedded view
    context for an element managed by an `NgIf` directive.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你现在知道什么是嵌入式视图上下文以及如何检查它，例如，它是如何创建并绑定到由`NgFor`指令管理的每个组件或元素。同样，我们探索了一个由`NgIf`指令管理的元素的嵌入式视图上下文示例。
- en: With all these newfound skills, you are ready to debug Angular applications
    by inspecting and updating state directly or through events, then reflecting the
    changes by triggering change detection.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得所有这些新技能后，你就可以通过直接检查和更新状态或通过事件来调试Angular应用程序，然后通过触发变更检测来反映这些更改。
- en: You are even able to inspect the ever-so-hard-to-locate embedded view contexts.
    Amazing!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至能够检查那些难以找到的嵌入式视图上下文。太棒了！
- en: In the next chapter, you will learn about the Angular Compatibility Compiler,
    and when and why it is needed. We will explore its configuration options and optimize
    it for a CI/CD workflow.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解Angular兼容性编译器以及何时以及为什么需要它。我们将探索其配置选项，并针对CI/CD工作流程进行优化。
