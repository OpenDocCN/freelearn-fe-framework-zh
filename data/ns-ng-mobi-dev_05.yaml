- en: Routing and Lazy Loading
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由和懒加载
- en: Routing is essential to the solid usability flow of any app. Let's understand
    the key elements of routing configuration for a mobile app that takes advantage
    of all the flexibility Angular's router gives us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 路由对于任何应用程序的稳定可用性流程至关重要。让我们了解移动应用程序的路由配置的关键要素，以充分利用Angular路由器给我们带来的所有灵活性。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Configuring the Angular Router with a NativeScript app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Angular路由器与NativeScript应用程序
- en: Lazy loading modules by route
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按路由懒加载模块
- en: Provide NSModuleFactoryLoader for Angular's NgModuleFactoryLoader
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Angular的`NgModuleFactoryLoader`提供`NSModuleFactoryLoader`
- en: Understanding how to use router-outlet in conjunction with page-router-outlet
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何在`page-router-outlet`与`router-outlet`结合使用
- en: Learn how to share singleton services across multiple lazy loaded modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在多个延迟加载模块之间共享单例服务
- en: Using auth guards to protect views that require valid authentication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用身份验证守卫保护需要有效身份验证的视图
- en: Learn about `NavigationButton` to customize back mobile navigation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用`NavigationButton`自定义后退移动导航
- en: Take advantage of our flexible routing setup by introducing late feature requirements
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引入后期功能需求来利用我们灵活的路由设置
- en: Get your kicks on Route 66
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在66号公路上踏上你的旅程
- en: 'As we begin our journey down this highway full of adventure, let''s start with
    a pit stop at our local service shop to ensure our vehicle is in tip-top shape.
    Take a turn into the root directory of `app` to build a new add-on to our vehicle''s
    engine: the routing module.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始沿着这条充满冒险的高速公路旅行时，让我们从在本地服务站停下来，确保我们的车辆状态良好。进入`app`的根目录，构建一个新的附加到我们车辆引擎的模块：路由模块。
- en: 'Create a new routing module, `app/app.routing.ts`, with the following contents:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的路由模块`app/app.routing.ts`，内容如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Defining the root `''''` path to redirect to a lazy loaded module provides
    a very flexible routing configuration, as you will see throughout this chapter.
    You will see a new module, `MixerModule`, which we will create momentarily. In
    fact, it will largely end up being what `AppComponent` is right now. Here''s a
    list of some advantages you gain with a route configuration similar to this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将根路径`''`定义为重定向到一个延迟加载模块提供了非常灵活的路由配置，正如你将在本章中看到的那样。您将看到一个新模块`MixerModule`，我们马上就会创建。实际上，它将在很大程度上成为当前`AppComponent`的样子。以下是您使用类似于此路由配置时获得的一些优势列表：
- en: Keeps app startup time fast by eagerly loading only the bare minimum root module
    configuration, then rapidly loading the first route's module lazily
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过急切加载仅有最少的根模块配置，然后懒加载第一个路由模块，使应用启动时间保持快速
- en: Provides us with the ability to utilize `page-router-outlet` in conjunction
    with `router-outlet` for a combination of master/detail navigation as well as
    the `clearHistory` swap page navigation
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们提供了利用`page-router-outlet`和`router-outlet`的能力，结合主/细节导航以及`clearHistory`交换页面导航
- en: Isolates routing configuration responsibility to the modules it concerns which
    scales well over time
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将路由配置责任隔离到相关模块，随着时间的推移，这种方式会更加灵活
- en: Allows us to target different **start pages** easily in the future if we decide
    to change the initial page our users are presented with
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们决定更改用户最初呈现的初始页面，可以轻松地在将来针对不同的**起始页面**进行定位
- en: This uses `NativeScriptRoutingModule.forRoot(routes)`, since this should be
    considered the root of our app's routing configuration.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用`NativeScriptRoutingModule.forRoot(routes)`，因为这应该被视为我们应用程序路由配置的根。
- en: We also export `NativeScriptRoutingModule`, since we will be importing this
    `AppRoutingModule` into our root `AppModule` in a moment. This makes the routing
    directives available to our root module's root component.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还导出 `NativeScriptRoutingModule`，因为我们将在稍后将这个 `AppRoutingModule` 导入到我们的根 `AppModule`
    中。这使得路由指令可用于我们根模块的根组件。
- en: Providing NSModuleFactoryLoader for NgModuleFactoryLoader
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 NgModuleFactoryLoader 提供 NSModuleFactoryLoader
- en: By default, Angular's built-in module loader uses SystemJS; however, NativeScript provides
    an enhanced module loader called `NSModuleFactoryLoader`. Let's provide this in
    our main routing module to ensure all our modules are loaded with it instead of
    Angular's default module loader.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular的内置模块加载器使用SystemJS；然而，NativeScript提供了一个增强的模块加载器称为 `NSModuleFactoryLoader`。让我们在主路由模块中提供这个，以确保所有我们的模块都是用它加载而不是Angular的默认模块加载器。
- en: 'Make the following modifications to `app/app.routing.ts`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `app/app.routing.ts` 进行以下修改：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we can use the standard Angular lazy loading syntax via `loadChildren`
    by specifying the default `NgModuleFactoryLoader` but should instead use NativeScript's
    enhanced `NSModuleFactoryLoader`. We won't go into what `NSModuleFactoryLoader`
    provides in detail, since it is explained very well here: [https://www.nativescript.org/blog/optimizing-app-loading-time-with-angular-2-lazy-loading](https://www.nativescript.org/blog/optimizing-app-loading-time-with-angular-2-lazy-loading),
    and we have a lot more we want to cover in this book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用标准的Angular懒加载语法通过 `loadChildren` 来指定默认的 `NgModuleFactoryLoader`，但应该使用NativeScript增强的
    `NSModuleFactoryLoader`。我们不会详细介绍 `NSModuleFactoryLoader` 提供的内容，因为在这里已经很好地解释了：[https://www.nativescript.org/blog/optimizing-app-loading-time-with-angular-2-lazy-loading](https://www.nativescript.org/blog/optimizing-app-loading-time-with-angular-2-lazy-loading)，而且我们还有很多内容要在本书中介绍。
- en: Excellent. With these upgrades in place, we can leave the service shop and continue
    on our journey down the highway. Let's move on to implementing our new routing
    setup.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。有了这些升级，我们可以离开服务店，继续沿着高速公路前行。让我们继续实现我们的新路由设置。
- en: 'Open `app/app.component.html`; cut its contents to the clipboard and replace
    them with the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `app/app.component.html`；将其内容剪切到剪贴板，并用以下内容替换：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will be the base of our view level implementation. `page-router-outlet`
    allows any Component to insert itself in its place, whether it be a single flat route
    or one with child views of its own. It also allows other Component views to push
    onto the mobile nav stack, allowing master/detail mobile navigation with back
    history.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将成为我们视图级实现的基础。 `page-router-outlet` 允许任何组件插入自己的位置，无论是单个平面路由还是具有自己子视图的路由。它还允许其他组件视图推送到移动导航栈，实现主/细节移动导航和后退历史记录。
- en: 'In order for this `page-router-outlet` directive to work, we need our root
    `AppModule` to import our new `AppRoutingModule`. We will also take this opportunity
    to remove `PlayerModule`, which was imported here before. Open `app/app.module.ts`
    and make the following modifications:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `page-router-outlet` 指令工作，我们需要我们的根 `AppModule` 导入我们的新 `AppRoutingModule`。我们还将利用这个机会删除之前导入的
    `PlayerModule`。打开 `app/app.module.ts` 并进行以下修改：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating MixerModule
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 MixerModule
- en: 'This module really won''t be anything new, as it will serve as a relocation
    of what was previously our root component''s view. However, it will introduce
    an extra nicety: the ability to define its own inner routes.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块实际上不会有什么新东西，因为它将作为之前我们根组件视图的重新定位。然而，它将引入一个额外的好处：能够定义自己的内部路由。
- en: 'Create `app/modules/mixer/components/mixer.component.html` and paste the contents
    from where we had cut from the  `app.component.html`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `app/modules/mixer/components/mixer.component.html`，并粘贴从 `app.component.html`
    中剪切的内容：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then create a matching `app/modules/mixer/components/mixer.component.ts`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个匹配的 `app/modules/mixer/components/mixer.component.ts`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we will create `BaseComponent`, which will serve as the placeholder for
    not only the preceding `MixerComponent` but also any other child view components we
    may want to present in its place. For example, our mixer may want to allow users
    to pop a single track out of the mixer and into an isolated view to work with
    audio effects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建`BaseComponent`，它将作为不仅是前面的`MixerComponent`，还有任何其他我们可能想要在其位置呈现的子视图组件的占位符。例如，我们的混音器可能希望允许用户将单个轨道从混音器中弹出并放入一个隔离的视图中以处理音频效果。
- en: 'Create `app/modules/mixer/components/base.component.ts` with the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app/modules/mixer/components/base.component.ts`中创建以下内容：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This provides a slot to insert any child routes our mixer configures, one of
    which is `MixerComponent` itself. Since the view is just a simple `router-outlet`,
    there's really no need to create a separate `templateUrl`, so we have just inlined
    it here.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个插槽，用于插入我们的混音器配置的任何子路由，其中之一是`MixerComponent`本身。由于视图只是一个简单的`router-outlet`，因此没有必要创建单独的`templateUrl`，所以我们在这里直接内联了它。
- en: 'Now we are ready to implement `MixerModule`; create `app/modules/mixer/mixer.module.ts`
    with the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备实现`MixerModule`；创建`app/modules/mixer/mixer.module.ts`，其中包含以下内容：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have imported `PlayerModule` since the mixer uses components/widgets defined
    there (namely, `track-list` and `player-controls`). We are also utilizing the
    `NativeScriptRouterModule.forChild(routes)` method to indicate that these are
    specifically child routes. Our route configuration sets up the BaseComponent at
    the root `'' ''` path, which defines `''home''` as `MixerComponent`. If you recall,
    our app''s `AppRoutingModule` configured the root path of our app, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了`PlayerModule`，因为混音器使用了在那里定义的组件/小部件（即`track-list`和`player-controls`）。我们还利用了`NativeScriptRouterModule.forChild(routes)`方法来指示这些特定的子路由。我们的路由配置在根路径`'
    '`处设置了BaseComponent，将`'home'`定义为`MixerComponent`。如果您还记得，我们应用的`AppRoutingModule`配置了我们应用的根路径，如下所示：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will route directly to `MixerComponent` here, defined as `'home'`. We could
    easily direct the start page to a different view by pointing `redirectTo` at a
    different child view of our mixer if we wanted. Since `BaseComponent` is simply
    a `router-outlet`, any children defined underneath the root `' '` of our mixer's
    routes (seen by our the overall app's routes as `'/mixer'`) will insert directly
    in that view slot. If you were to run this right now, you should see the same
    start page we had before.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将直接路由到`MixerComponent`，在这里被定义为`'home'`。如果需要，我们可以通过将`redirectTo`指向混音器的不同子视图来轻松地将启动页面定向到不同的视图。由于`BaseComponent`只是一个`router-outlet`，在我们的混音器路由的根路径`'
    '`下定义的任何子级（由我们整个应用的路由视为`'/mixer'`）都将直接插入到该视图插槽中。如果您现在运行这个，您应该会看到我们之前的相同的启动页面。
- en: Congrats! Your app's start time is now fast and you have lazily loaded your
    first module!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您的应用启动时间现在很快，您已经懒加载了第一个模块！
- en: 'However, there''s a couple of surprising things to note:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有一些令人惊讶的事情需要注意：
- en: You may notice a quick white flash before the start page appears (on iOS at
    least)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能会注意到在启动页面出现之前会有一个快速的白色闪烁（至少在iOS上是这样）
- en: You might notice the console log prints ``Current user:`` twice
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能会注意到控制台日志打印了“当前用户：”两次
- en: We will address each of these issues respectively.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别解决这些问题。
- en: Remove the white flash after the splash screen before the start page displays.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动页面显示之前去除闪屏。
- en: 'This is normal and is the result of the default Page background color which
    is white. To provide a seamless launch experience, open the `app/common.css` file
    and drop this global `Page` class definition to tint the background-color to the
    same as our `ActionBar` background-color:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正常的，是默认页面背景颜色白色的结果。为了提供无缝的启动体验，打开`app/common.css`文件，并将全局`Page`类定义放在这里，将背景颜色着色为与我们的`ActionBar`背景颜色相同：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, there will be no more white flash and the launch of the app will appear
    seamless.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不会再出现白屏，应用程序的启动将显得无缝。
- en: The console log prints ``Current user:`` twice
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台日志会打印两次“当前用户：”
- en: Angular's dependency injector is causing this due to lazy loading.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的依赖注入器由于延迟加载而导致了这个问题。
- en: 'This comes from `app/modules/core/services/auth.service.ts`, where we had a
    private `init` method that was being called from the service''s constructor:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码来自`app/modules/core/services/auth.service.ts`，我们在这里有一个私有的`init`方法，它是从服务的构造函数中调用的。
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Wait! What?! Does this mean `AuthService` is getting constructed twice??!!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！这是什么意思？这意味着`AuthService`被构造了两次吗？！
- en: Yes. It does. :(
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。它是的。:(
- en: I can hear the sound of the car's wheels squealing, as you veer off this highway
    adventure into a ditch right about now. ;)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我能听到车轮的尖叫声，就在此刻，你把这次高速公路冒险转向了沟渠里。;)
- en: This is most certainly a huge problem, as we absolutely intended for `AuthService`
    to be a globally shared Singleton that could be injected anywhere and shared to
    provide the current authenticated state of our app.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是一个巨大的问题，因为我们绝对打算让`AuthService`成为一个可以在任何地方注入并共享以提供我们应用程序当前认证状态的全局共享单例。
- en: It is imperative we solve this right now, but let's first take a brief detour
    to understand why this is happening before looking at a solid solution.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须解决这个问题，但在看一个可靠的解决方案之前，让我们先稍微偏离一下，了解一下为什么会发生这种情况。
- en: Understanding Angular's Dependency Injector when lazy loading modules
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Angular的依赖注入器在延迟加载模块时的行为
- en: 'Instead of restating the details, we will paraphrase directly from Angular''s
    official documentation (`https://angular.io/guide/ngmodule-faq#!#q-why-child-injector`),
    which explains this perfectly:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接从Angular官方文档(`https://angular.io/guide/ngmodule-faq#!#q-why-child-injector`)中引用，而不是重述细节，这完美地解释了这一点：
- en: Angular adds `@NgModule.providers` to the application root injector unless the
    module is lazy loaded. For a lazy-loaded module, Angular creates a child injector
    and adds the module's providers to the child injector.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Angular会将`@NgModule.providers`添加到应用程序根注入器，除非该模块是延迟加载的。对于延迟加载的模块，Angular会创建一个子注入器，并将模块的提供者添加到子注入器中。
- en: This means that a module behaves differently depending on whether it's loaded
    during application start or lazily loaded later. Neglecting that difference can
    lead to adverse consequences.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一个模块的行为会有所不同，取决于它是在应用程序启动期间加载还是在后来进行延迟加载。忽视这种差异可能会导致不良后果。
- en: Why doesn't Angular add lazy-loaded providers to the app root injector as it
    does for eagerly loaded modules?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么Angular不像对急切加载模块那样将延迟加载的提供者添加到应用程序根注入器中呢？
- en: The answer is grounded in a fundamental characteristic of the Angular dependency-injection
    system. An injector can add providers until it's first used. Once an injector
    starts creating and delivering services, its provider list is frozen; no new providers
    are allowed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 答案根植于Angular依赖注入系统的一个基本特性。一个注入器可以添加提供者，直到它第一次被使用。一旦注入器开始创建和提供服务，它的提供者列表就被冻结了；不允许添加新的提供者。
- en: When an application starts, Angular first configures the root injector with
    the providers of all eagerly loaded modules before creating its first component
    and injecting any of the provided services. Once the application begins, the app
    root injector is closed to new providers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，Angular首先会将根注入器配置为所有急切加载模块的提供者，然后创建其第一个组件并注入任何提供的服务。一旦应用程序开始，应用程序根注入器就关闭了新的提供者。
- en: Time passes and application logic triggers lazy loading of a module. Angular
    must add the lazy-loaded module's providers to an injector somewhere. It can't
    add them to the app root injector because that injector is closed to new providers.
    So Angular creates a new child injector for the lazy-loaded module context.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 时间过去了，应用逻辑触发了一个模块的延迟加载。Angular必须将延迟加载模块的提供者添加到某个注入器中。它不能将它们添加到应用程序根注入器，因为该注入器对新提供者是关闭的。因此，Angular为延迟加载模块上下文创建一个新的子注入器。
- en: 'If we look at our root `AppModule`, we can see it imports `CoreModule`, which
    provides `AuthService`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下我们的根`AppModule`，我们可以看到它导入了`CoreModule`，其中提供了`AuthService`：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we then look at `PlayerModule`, we can see it also imports `CoreModule`,
    since the components of `PlayerModule` make use of the `OrderByPipe` it declares
    as well as several of the services it provides (that is, `AuthService`, `LogService`,
    and `DialogService`):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再看一下`PlayerModule`，我们可以看到它也导入了`CoreModule`，因为`PlayerModule`的组件使用了它声明的`OrderByPipe`以及它提供的一些服务（即`AuthService`，`LogService`和`DialogService`）：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`PlayerModule` is now lazily loaded along with `MixerModule` due to our fancy
    new routing configuration. This causes Angular''s dependency injector to register
    a new child injector for our lazily loaded `MixerModule`, which brings along 
    `PlayerModule`, which also brings along its import of `CoreModule`, which defines
    those providers, including `AuthService`, `LogService`, and so on. When Angular registers
    `MixerModule`, it will register all the providers defined throughout the new module,
    including its imported modules with the new child injector, giving rise to the
    new instances of those services being constructed.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们新的路由配置，`PlayerModule`现在是延迟加载的，与`MixerModule`一起加载。这会导致Angular的依赖注入器为我们的延迟加载的`MixerModule`注册一个新的子注入器，其中包括`PlayerModule`，它还带来了它导入的`CoreModule`，其中定义了那些提供者，包括`AuthService`，`LogService`等等。当Angular注册`MixerModule`时，它将注册整个新模块中定义的所有提供者，包括它的导入模块与新的子注入器，从而产生这些服务的新实例。
- en: 'Angular''s docs also provide a recommended setup for modules to remedy this
    situation, so let''s paraphrase again from `https://angular.io/guide/ngmodule-faq#!#q-module-recommendations`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的文档还提供了一个推荐的模块设置来解决这种情况，所以让我们再次从`https://angular.io/guide/ngmodule-faq#!#q-module-recommendations`进行改述：
- en: SharedModule
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: SharedModule
- en: Create a `SharedModule` with the components, directives, and pipes that you
    use everywhere in your app. This module should consist entirely of declarations,
    most of them exported. The `SharedModule` may re-export other widget modules,
    such as `CommonModule`, `FormsModule`, and modules with the UI controls that you
    use most widely.The `SharedModule` should not have providers for reasons explained
    previously. Nor should any of its imported or re-exported modules have providers.
    If you deviate from this guideline, know what you're doing and why. Import the
    `SharedModule` in your feature modules, both those loaded when the app starts
    and those you lazily load later.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`SharedModule`，其中包含你在应用程序中到处使用的组件、指令和管道。这个模块应该完全由声明组成，其中大部分是导出的。`SharedModule`可以重新导出其他小部件模块，比如`CommonModule`，`FormsModule`，以及你最广泛使用的UI控件模块。`SharedModule`不应该有提供者，原因在之前已经解释过。它导入或重新导出的模块也不应该有提供者。如果你偏离了这个指南，要知道你在做什么以及为什么。在你的特性模块中导入`SharedModule`，无论是在应用启动时加载的模块还是以后延迟加载的模块。
- en: Create a `CoreModule` with providers for the singleton services you load when
    the application starts.Import `CoreModule` in the root `AppModule` only. Never
    import `CoreModule` in any other module.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`CoreModule`，其中包含应用启动时加载的单例服务的提供者。只在根`AppModule`中导入`CoreModule`。永远不要在任何其他模块中导入`CoreModule`。
- en: Consider making `CoreModule` a pure service module with no declarations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑将`CoreModule`作为一个纯服务模块，不包含任何声明。
- en: 'OK wow! That is an excellent recommendation. Particularly worthy of note is
    that very last line:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 好哇！这是一个很好的建议。特别值得注意的是最后一行：
- en: Consider making CoreModule a pure service module with no declarations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑将CoreModule变成一个纯服务模块，没有声明。
- en: So, we already have `CoreModule`, which is great news, but we will want to make
    it a *pure service module with no declarations*. We will also *Import CoreModule
    in the root AppModule only. Never import CoreModule in any other module. *Then,
    we can create a new `SharedModule` to provide just *...**the components, directives,
    and pipes that [we] use everywhere in [our] app*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经有了`CoreModule`，这是一个好消息，但我们希望将其变成一个*纯服务模块，没有声明*。我们还*只在根AppModule中导入CoreModule。永远不要在任何其他模块中导入CoreModule。*然后，我们可以创建一个新的`SharedModule`，只提供*……**在应用程序中到处使用的组件、指令和管道*。
- en: 'Let''s create `app/modules/shared/shared.module.ts`, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`app/modules/shared/shared.module.ts`，如下所示：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For `PIPES`, we are just moving the pipes directory from `app/modules/core` to
    the `app/modules/shared` folder. Now,  `SharedModule` is the one we can be free
    to import across several different modules that need any pipes or future shared
    components/directives it may provide. It will not define any service providers
    as mentioned by this suggestion:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`PIPES`，我们只是将pipes目录从`app/modules/core`移动到`app/modules/shared`文件夹中。现在，`SharedModule`是我们可以自由导入到需要任何管道或未来共享组件/指令的多个不同模块中的一个。它不会像这个建议所提到的那样定义任何服务提供者：
- en: '`SharedModule` should not have providers for reasons explained previously,
    nor should any of its imported or re-exported modules have providers.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 出于之前解释的原因，`SharedModule`不应该有提供者，也不应该有任何导入或重新导出的模块有提供者。
- en: 'We can then adjust `CoreModule` (located in `app/modules/core/core.module.ts`)
    as follows to be a pure service module with no declarations:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以调整`CoreModule`（位于`app/modules/core/core.module.ts`中）如下，使其成为一个纯服务模块，没有声明：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This module now only defines providers as the collection containing `AuthService`,
    `DatabaseService`, `DialogService`, and `LogService`, all of which we created
    earlier in the book, and we want to ensure they are true Singletons used across
    our app, whether they are used in lazy loaded modules or not.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块现在只定义了提供者，包括`AuthService`、`DatabaseService`、`DialogService`和`LogService`，这些都是我们在书中之前创建的，并且我们希望确保它们是真正的单例，无论它们是在惰性加载的模块中使用还是不使用。
- en: Why do we use the `...PROVIDERS` spread notation instead of just assigning the
    collection directly?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们使用`...PROVIDERS`扩展符号而不是直接分配集合？
- en: For scalability reasons. In the future, if we need to add an additional provider
    or override a provider, we can do so simply by just adding to the collection right
    in the module. The same goes for imports and exports.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 出于可扩展性的原因。将来，如果我们需要添加额外的提供者或覆盖提供者，我们只需简单地在模块中添加到集合中即可。导入和导出也是一样。
- en: We also take this opportunity to import some additional modules that we want
    to ensure are also used globally throughout the app. `NativeScriptModule`, `NativeScriptFormsModule`,
    and `NativeScriptHttpModule` are all essential modules that override certain web
    APIs from Angular's various providers out-of-the-box to enhance our app with native
    APIs. For example, instead of the app using `XMLHttpRequest` (which is a web API),
    it will use native HTTP APIs made available on both iOS and Android for the ultimate
    networking performance. We ensure we export these as well so our root module no
    longer needs to import them and can instead just import this `CoreModule`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还利用这个机会导入一些额外的模块，以确保它们也在整个应用程序中全局使用。`NativeScriptModule`、`NativeScriptFormsModule`和`NativeScriptHttpModule`都是重要的模块，可以在Angular的各种提供程序中覆盖某些Web
    API，以增强我们的应用程序使用本机API。例如，应用程序将使用本机HTTP API而不是`XMLHttpRequest`（这是一个Web API），从而提高iOS和Android的网络性能。我们还确保将它们导出，这样我们的根模块就不再需要导入它们，而是只需导入`CoreModule`。
- en: Lastly, we define a constructor that will help safeguard us in the future from accidentally
    importing this `CoreModule` into other lazily loaded modules.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个构造函数，以帮助我们在将来防止意外地将`CoreModule`导入到其他懒加载模块中。
- en: We don't know yet if `PlayerService` provided by `PlayerModule` will be needed
    by `RecorderModule`, which also will be lazily loaded. If that comes up in the
    future, we can also refactor `PlayerService` into `CoreModule` to ensure it's
    a true Singleton shared across our entire app. For now, we will just leave it
    where it is as part of `PlayerModule`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还不知道`PlayerModule`提供的`PlayerService`是否会被`RecorderModule`所需，后者也将被懒加载。如果将来出现这种情况，我们还可以将`PlayerService`重构为`CoreModule`，以确保它是整个应用程序中共享的真正单例。现在，我们将它留在`PlayerModule`中。
- en: Let's now make our final adjustments to our other modules based on what we have
    done to tighten everything down.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们根据我们所做的工作做最后的调整，来收紧一切。
- en: 'The `app/modules/player/player.module.ts` file should now look like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/modules/player/player.module.ts`文件现在应该是这样的：'
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `app/modules/recorder/recorder.module.ts` file should now look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/modules/recorder/recorder.module.ts`文件现在应该是这样的：'
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice we now import `SharedModule` instead of `CoreModule`. This provides us
    with the ability to share directives, components, and pipes (essentially anything
    that would be in the declarations portion of the module) across the entire app
    by importing that `SharedModule`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们现在导入`SharedModule`而不是`CoreModule`。这使我们能够通过导入`SharedModule`在整个应用程序中共享指令、组件和管道（基本上是模块声明部分中的任何内容）。
- en: 'Our root `AppModule` at `app/app.module.ts` stays the same:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的根`AppModule`在`app/app.module.ts`中保持不变：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Any module (lazy loaded or not) can still inject any services that `CoreModule`
    provides, since the root `AppModule` now imports that `CoreModule`. This allows
    Angular's root injector to construct the services provided by `CoreModule` exactly
    once. Then, any time those services are injected anywhere (*in a lazily loaded
    module or not*), Angular will first ask the parent injector (in the case of a
    lazy loaded module, it would be the child injector) for that service and, if not
    found there, it will ask the next parent making its way to the root injector,
    eventually, where those Singletons are provided.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 任何模块（懒加载或非懒加载）仍然可以注入`CoreModule`提供的任何服务，因为根`AppModule`现在导入了`CoreModule`。这允许Angular的根注入器仅构建一次由`CoreModule`提供的服务。然后，每当这些服务被注入到任何地方（*无论是在懒加载模块还是非懒加载模块中*），Angular都会首先询问父注入器（在懒加载模块的情况下，它将是子注入器）是否有该服务，如果在那里找不到，它将询问下一个父注入器，一直到根注入器，最终找到这些单例提供的地方。
- en: Well, we've had an amazing time in this desert of a town. Let's cruise on down
    the highway to the ultra secure Area 51, where modules can be locked away for
    years unless proper authorization is presented.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们在这个沙漠小镇度过了美好的时光。让我们沿着高速公路前往超安全的51区，那里的模块可以被锁定多年，除非提供适当的授权。
- en: Creating AuthGuard for RecorderModule
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为RecorderModule创建AuthGuard
- en: One of our app's requirements is that recording features should be locked away
    and inaccessible until a user is authenticated. This provides us with the ability
    to have a user base and potentially introduce paid features down the road if we
    so desire.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的一个要求是，录制功能应该被锁定并且在用户认证之前无法访问。这为我们提供了有用户基础的能力，并且如果需要的话，未来可能引入付费功能。
- en: Angular provides the ability to insert guards on our routes, which would only
    activate under certain conditions. This is exactly what we need to implement this
    feature requirement, since we have isolated the `'/record'` route to lazily load
    `RecorderModule`, which will contain all the recording features. We want to only
    allow access to that `'/record'` route if the user is authenticated.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了在我们的路由上插入守卫的能力，这些守卫只会在特定条件下激活。这正是我们需要实现这个功能要求的，因为我们已经将`'/record'`路由隔离为懒加载`RecorderModule`，其中包含所有的录制功能。我们只希望在用户认证时才允许访问`'/record'`路由。
- en: 'Let''s create `app/guards/auth-guard.service.ts` in a new folder for scalability,
    since we could grow and create other guards as necessary here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个新的文件夹中创建`app/guards/auth-guard.service.ts`，以便扩展性，因为我们可能会增长并在这里创建其他守卫。
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are able to take advantage of `BehaviorSubject` of `AuthService` to grab
    the latest value using `this.authService.authenticated$.getValue()` to determine
    the auth state. We use this to immediately activate the route via the `canActivate`
    hook (or load the module via the `canLoad` hook) if the user is authenticated.
    Otherwise, we display the login prompt via the service's method, but this time
    we wrap it in a reprompt sequence, which will continue to prompt on failed attempts
    until a successful authentication, or ignore it if the user cancels the prompt.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够利用`AuthService`的`BehaviorSubject`来使用`this.authService.authenticated$.getValue()`来获取最新的值，以确定认证状态。我们使用这个值来立即通过`canActivate`钩子激活路由（或者通过`canLoad`钩子加载模块）如果用户已经认证。否则，我们通过服务的方法显示登录提示，但这次我们将其包装在重新提示序列中，直到成功认证或者用户取消提示为止。
- en: For the book, we aren't wiring up to any backend service to do any real authentication
    with a service provider. We will leave that part up to you in your own app. We
    will just be persisting the e-mail and password you enter into the login prompt
    as a valid user after doing very simple validation on the input.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们不会连接到任何后端服务来进行真正的服务提供商认证。我们会把这部分留给你在你自己的应用中完成。我们只会将你在登录提示中输入的电子邮件和密码持久化为有效用户，经过非常简单的输入验证。
- en: 'Notice that `AuthGuard` is an Injectable service like other services, so we
    will want to make sure it is added to the providers metadata of `AppRoutingModule`.
    We can now guard our route with the following highlighted modifications to `app/app.routing.ts`
    to use it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`AuthGuard`是一个可注入的服务，就像其他服务一样，所以我们需要确保它被添加到`AppRoutingModule`的提供者元数据中。现在我们可以使用以下突出显示的修改来保护我们的路由，以在`app/app.routing.ts`中使用它：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To try this out, we need to add child routes to our `RecorderModule`, since
    we have not done that yet. Open `app/modules/recorder/recorder.module.ts` and
    add the following highlighted sections:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试这个功能，我们需要为我们的`RecorderModule`添加子路由，因为我们还没有这样做。打开`app/modules/recorder/recorder.module.ts`并添加以下突出显示的部分：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We now have a proper child route configuration that will display the single
    `RecordComponent` when the user navigates to the `'/record'` path. We won't show
    the details of `RecordComponent`, as you can refer to the [Chapter 5](part0064.html#1T1400-289fe2426d594f99a90e4363b2c9c34d), *Routing
    and Lazy Loading* branch on the repo for the book. However, it is just a stubbed
    out component at this point inside `app/modules/recorder/components/record.component.html`,
    which just shows a simple label, so we can try this out.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个合适的子路由配置，当用户导航到`'/record'`路径时，将显示单个`RecordComponent`。我们不会展示`RecordComponent`的细节，因为你可以参考书籍仓库中的[第5章](part0064.html#1T1400-289fe2426d594f99a90e4363b2c9c34d)，*路由和懒加载*分支。然而，目前在`app/modules/recorder/components/record.component.html`中，它只是一个存根组件，只显示一个简单的标签，所以我们可以试一下。
- en: Lastly, we need a button that will route to our `'/record'` path. If we look
    back at our original sketch, we wanted a Record button to display in the top right
    corner of `ActionBar`, so let's implement that now.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个按钮，可以路由到我们的`'/record'`路径。如果我们回顾一下我们最初的草图，我们想要一个Record按钮显示在`ActionBar`的右上角，所以现在让我们实现它。
- en: 'Open `app/modules/mixer/components/mixer.component.html` and add the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app/modules/mixer/components/mixer.component.html`并添加以下内容：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, if we were to run this in the iOS Simulator, we would notice that our
    Record button in `ActionBar` does not do anything! This is because `MixerModule`
    only imports the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在iOS模拟器中运行这个程序，我们会注意到我们在`ActionBar`中的Record按钮没有任何作用！这是因为`MixerModule`只导入了以下内容：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `NativeScriptRouterModule.forChild(routes)` method just configures the routes
    but does not make various routing directives, such as `nsRouterLink`, available
    to our components.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`NativeScriptRouterModule.forChild(routes)`方法只是配置路由，但不会使各种路由指令，如`nsRouterLink`，可用于我们的组件。'
- en: Since you learned earlier that `SharedModule` should be used to declare various
    directives, components, and pipes you want to share throughout your modules (lazy
    loaded or not), this is a perfect opportunity to take advantage of that.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你之前学到了`SharedModule`应该用来声明你想要在你的模块中共享的各种指令、组件和管道（无论是懒加载还是不懒加载），这是一个很好的机会来利用它。
- en: 'Open `app/modules/shared/shared.module.ts` and make the following highlighted
    modifications:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app/modules/shared/shared.module.ts`并进行以下突出显示的修改：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, back in `MixerModule`, we can adjust the imports to use `SharedModule`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`MixerModule`，我们可以调整导入以使用`SharedModule`：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This ensures all the directives exposed via `NativeScriptRouterModule` are now
    included and available for use in  `MixerModule` by utilizing our app-wide `SharedModule`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了通过利用我们应用程序范围的`SharedModule`，`MixerModule`中现在包含并可用于使用的`NativeScriptRouterModule`暴露的所有指令。
- en: 'Running our app again, we now see the login prompt when we tap the Record button
    in `ActionBar`. If we enter a properly formatted e-mail address and any password,
    it will persist the details, log us in, and display `RecordComponent` as follows
    on iOS:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行我们的应用程序，现在当我们点击`ActionBar`中的Record按钮时，我们会看到登录提示。如果我们输入一个格式正确的电子邮件地址和任何密码，它将保留这些详细信息，登录我们，并在iOS上显示`RecordComponent`如下：
- en: '![](../images/00022.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00022.jpeg)'
- en: You might notice something rather interesting. `ActionBar` changed from the
    background color we assigned via CSS and the button color now displays the default
    blue color. This is because `RecordComponent` does not define `ActionBar`; therefore,
    it is reverting to a default styled `ActionBar` with a default back button, which
    takes on the title of the page it just navigated from. The `'/record'` route is
    also using the ability of `page-router-outlet` to push components onto the mobile
    navigation stack. `RecordComponent` is animated into view while allowing the user
    to choose the top left button to navigate back (to pop the navigation history
    back one).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到一些非常有趣的事情。“ActionBar”从我们通过CSS分配的背景颜色和按钮颜色现在显示默认的蓝色。这是因为“RecordComponent”没有定义“ActionBar”；因此，它会恢复到一个具有默认返回按钮的默认样式的“ActionBar”，该按钮将采用刚刚导航离开的页面的标题。'/record'路由还使用了“page-router-outlet”的能力将组件推送到移动导航栈上。“RecordComponent”被动画化显示，同时允许用户选择左上角按钮进行导航返回（将导航历史后退一步）。
- en: 'To fix `ActionBar`, let''s just add `ActionBar` to the `RecordComponent` view
    with a custom `NavigationButton` (a `NativeScript` view component simulating a
    mobile device''s default back navigation button). We can make the adjustments
    to `app/modules/record/components/record.component.html`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复“ActionBar”，让我们在“RecordComponent”视图中添加“ActionBar”和自定义的“NavigationButton”（一个模拟移动设备默认返回导航按钮的“NativeScript”视图组件）。我们可以对“app/modules/record/components/record.component.html”进行调整：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, this looks a lot better:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这看起来好多了。
- en: '![](../images/00023.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00023.jpeg)'
- en: 'If we run this on Android and log in using any e-mail/password combo to persist
    a user, it will display the same `RecordComponent` view; however, you will notice
    another interesting detail. We have set up Android to display a standard back
    arrow system icon as `NavigationButton`, but when tapping that arrow, it does
    not do anything. Android''s default behavior relies on the device''s physical
    hardware back button next to the home button. However, we can provide a consistent
    experience by just adding a tap event to `NavigationButton`, so both iOS and Android
    react the same to tapping the back button. Make the following modification to
    the template:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Android上运行这个，并使用任何电子邮件/密码组合登录以保持用户登录，它将显示相同的“RecordComponent”视图；然而，您会注意到另一个有趣的细节。我们已经设置Android显示一个标准的返回箭头系统图标作为“NavigationButton”，但是当点击该箭头时，它不会做任何事情。Android的默认行为依赖于设备旁边的物理硬件返回按钮，靠近主页按钮。然而，我们可以通过向“NavigationButton”添加一个点击事件来提供一致的体验，这样iOS和Android都会对点击返回按钮做出相同的反应。对模板进行以下修改：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we can implement the `back()` method in `app/modules/recorder/components/record.component.ts`
    using `NativeScript` for Angular''s `RouterExtensions` service:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用Angular的“RouterExtensions”服务在“app/modules/recorder/components/record.component.ts”中实现“back()”方法。
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, Android''s back button can be tapped to navigate back in addition to the
    hardware back button. iOS simply ignores the tap event handler, since it uses
    the default native behavior for `NavigationButton`. Pretty nice. Here is how `RecordComponent`
    looks on Android:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，除了硬件返回按钮之外，Android的返回按钮也可以被点击以进行导航。iOS简单地忽略了点击事件处理程序，因为它使用了“NavigationButton”的默认本机行为。相当不错。以下是“RecordComponent”在Android上的外观：
- en: '![](../images/00024.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00024.jpeg)'
- en: We will implement a nice recording view in upcoming chapters.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中实现一个不错的录音视图。
- en: We are surely cruising down Route 66 by now!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们肯定是在66号公路上巡航！
- en: We have implemented lazily loaded routes, provided `AuthGuard` to protect unauthorized
    use of our app's recording features, and learned a ton in the process. *However,
    we've just realized we are missing a very important feature late in the game*.
    We need a way to work on several different mixes over time. By default, our app
    may launch the last opened mix, but we would like to create new mixes (let's consider them
    **compositions**) and record entirely new mixes of individual tracks as separate
    compositions. We need a new route to display these compositions that we can name
    appropriately, so we can jump back and forth and work on different material.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了延迟加载路由，提供了`AuthGuard`来保护我们应用的录音功能不被未经授权的使用，并在这个过程中学到了很多。*然而，我们刚意识到在游戏的最后阶段我们缺少了一个非常重要的功能*。我们需要一种方法来随着时间的推移处理几种不同的混音。默认情况下，我们的应用可能会启动最后打开的混音，但我们希望创建新的混音（让我们称之为**作品**）并将单独的音轨的全新混音记录为独立的作品。我们需要一个新的路由来显示这些作品，我们可以适当地命名，这样我们就可以来回跳转并处理不同的素材。
- en: Handling late feature requirements – managing compositions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理晚期功能需求 - 管理作品
- en: It's time to deal with unexpected traffic along Route 66\. We have encountered
    a late feature requirement, realizing we need a way to manage any number of different
    mixes so we can work on different material over time. We could refer to each mix
    as a composition of audio tracks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候处理66号公路上的意外交通了。我们遇到了一个晚期的功能需求，意识到我们需要一种管理任意数量不同混音的方法，这样我们就可以随着时间的推移处理不同的素材。我们可以将每个混音称为音轨的作品。
- en: The good news is we have spent a reasonable amount of time engineering a scalable
    architecture and we are about to reap the fruits of our labor. Responding to late
    feature requirements now becomes a rather enjoyable Sunday stroll around the neighborhood.
    Let's show off the strengths of our app's architecture by taking a moment to work
    on this new feature.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，我们已经花了相当多的时间来设计一个可扩展的架构，我们即将收获我们的劳动成果。现在对晚期功能需求的回应变得像在附近愉快地散步一样。让我们通过花点时间来处理这个新功能，展示我们应用架构的优势。
- en: 'Let''s start by defining a new route for a new `MixListComponent` we will create.
    Open `app/modules/mixer/mixer.module.ts` and make the following highlighted modifications:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先为我们将创建的新`MixListComponent`定义一个新的路由。打开`app/modules/mixer/mixer.module.ts`并进行以下突出显示的修改：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We are switching up our initial strategy of presenting `MixerComponent` as the
    home start page, but instead we are going to create a new `MixListComponent` in
    a moment to represent the `'home'` start page, which will be a listing of all
    the compositions we are working on. We could still have the `MixListComponent`
    auto select the last selected composition on the app launch for convenience later.
    We have now defined `MixerComponent` as a parameterized route, since it will always
    represent one of our working compositions identified by the `':id'` param routes,
    which will resolve to a route looking like `'/mixer/1'` for example. We have also
    imported `PROVIDERS`, which we will create in a moment.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在改变最初的策略，不再将`MixerComponent`作为主页起始页面呈现，而是将在稍后创建一个新的`MixListComponent`来代表`'home'`起始页面，这将是我们正在处理的所有作品的列表。我们仍然可以让`MixListComponent`在应用启动时自动选择最后选择的作品，以方便以后使用。我们现在已经将`MixerComponent`定义为带参数的路由，因为它将始终代表我们的一个工作作品，由`':id'`参数路由标识，这将解析为类似`'/mixer/1'`的路由。我们还导入了我们将在稍后创建的`PROVIDERS`。
- en: 'Let''s modify `DatabaseService` provided by `CoreModule` to help provide a
    constant persistence key for our new data needs. We will want to persist user
    created compositions stored via this constant key name. Open `app/modules/core/services/database.service.ts`
    and make the following highlighted modifications:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`CoreModule`提供的`DatabaseService`，以帮助为我们的新数据需求提供一个恒定的持久化键。我们将希望通过这个恒定的键名持久保存用户创建的作品。打开`app/modules/core/services/database.service.ts`并进行以下高亮修改：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s also create a new data model to represent our compositions. Create `app/modules/shared/models/composition.model.ts`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还创建一个新的数据模型来表示我们的作品。创建`app/modules/shared/models/composition.model.ts`：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, holding strong to our conventions, open `app/modules/shared/models/index.ts`
    and re-export this new model:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，坚持我们的惯例，打开`app/modules/shared/models/index.ts`并重新导出这个新模型：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now use this new model and database key in a new data service on which
    to build this new feature. Create `app/modules/mixer/services/mixer.service.ts`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在一个新的数据服务中使用这个新模型和数据库键来构建这个新功能。创建`app/modules/mixer/services/mixer.service.ts`：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We now have a service that will provide a list to bind our view to display the
    user's saved compositions. It also provides a way to add and edit compositions
    and seed the first app launch with a demo composition for a good first-time user
    experience (*we will add actual tracks to the demo later*).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个服务，它将提供一个列表来绑定我们的视图，以显示用户保存的作品。它还提供了一种添加和编辑作品以及在第一次应用启动时为良好的首次用户体验播种演示作品的方法（*我们稍后会为演示添加实际的曲目*）。
- en: 'In keeping with our conventions, let''s also add `app/modules/mixer/services/index.ts`,
    as follows, which we illustrated being imported in `MixerModule` a moment ago:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们的惯例，让我们也添加`app/modules/mixer/services/index.ts`，如下所示，我们刚才在`MixerModule`中导入过：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s now create `app/modules/mixer/components/mix-list.component.ts` to consume
    and project our new data service:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建`app/modules/mixer/components/mix-list.component.ts`来使用和投影我们的新数据服务：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And, for the view template, `app/modules/mixer/components/mix-list.component.html`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视图模板，`app/modules/mixer/components/mix-list.component.html`：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will render our list of `MixerService` user-saved compositions to the
    view and, when we first launch the app, it will have been seeded with one sample
    **Demo** composition preloaded with two recordings, so the user can play around.
    Here is how things look on iOS upon first launch now:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把我们的`MixerService`用户保存的作品列表呈现到视图中，并且当我们首次启动应用时，它将被预先加载一个样本**演示**作品，其中包含两个录音，以便用户可以玩耍。现在iOS首次启动的情况如下：
- en: '![](../images/00025.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00025.jpeg)'
- en: 'We can create new compositions and edit the names of existing ones. We can
    also tap the composition''s name to view  `MixerComponent`; however, we need to
    adjust the component to grab the route `'':id''` param and wire its view into
    the selected composition. Open `app/modules/mixer/components/mixer.component.ts`
    and add the highlighted sections:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建新的作品并编辑现有作品的名称。我们还可以点击作品的名称来查看`MixerComponent`；然而，我们需要调整组件来抓取路由`':id'`参数并将其视图连接到所选的作品。打开`app/modules/mixer/components/mixer.component.ts`并添加高亮部分：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can inject Angular''s `ActivatedRoute` to subscribe to the route''s params,
    which give us access to `id`. Because it will come in as a String by default,
    we use `+params[''id'']` to convert it to a number when we locate the composition
    in our service''s list. We assign a local reference to the selected `composition`,
    which now allows us to bind to it in the view. While we''re at it, we will also
    add a Button labeled `List` for now in `ActionBar` to navigate back to our compositions
    (*later, we will implement font icons to display in their place*). Open `app/modules/mixer/components/mixer.component.html`
    and make the following highlighted modifications:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注入 Angular 的 `ActivatedRoute` 来订阅路由的参数，这样我们就可以访问 `id`。因为它默认会以字符串形式传入，所以我们使用
    `+params['id']` 将其转换为数字，以便在服务列表中定位到该组合。我们为选定的 `composition` 分配一个本地引用，这样我们就可以在视图中绑定它。与此同时，我们还将在
    `ActionBar` 中添加一个名为 `List` 的按钮，用于返回到我们的组合（*稍后，我们将实现字体图标来显示在它们的位置*）。打开 `app/modules/mixer/components/mixer.component.html`
    并进行以下突出显示的修改：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This allows us to display the selected composition''s name in the title of
    `ActionBar` as well as pass its tracks to `track-list`. We need to add `Input` to
    `track-list`, so it renders the composition''s tracks instead of the dummy data
    it''s bound to now. Let''s open `app/modules/player/components/track-list/track-list.component.ts`
    and add an `Input`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以在 `ActionBar` 的标题中显示所选组合的名称，并将其轨道传递给 `track-list`。我们需要向 `track-list`
    添加 `Input`，以便它呈现组合的轨道，而不是它现在绑定的虚拟数据。让我们打开 `app/modules/player/components/track-list/track-list.component.ts`
    并添加一个 `Input`：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Previously, the `TrackListComponent` view was bound to `playerService.tracks`,
    so let's adjust the view template for the component at `app/modules/player/components/track-list/track-list.component.html`
    to bind to our new `Input`, which will now represent the tracks in the user's
    actual selected composition**:**
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`TrackListComponent` 视图绑定到了 `playerService.tracks`，所以让我们调整组件的视图模板，使其绑定到我们的新
    `Input`，这将代表用户实际选择的组合中的轨道**：**
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We now have the following sequence in our app to meet the needs of this late
    feature requirement and we did it in just a few pages of material here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序中有以下顺序来满足这个晚期功能需求，我们只需在这里的几页材料中就完成了：
- en: '![](../images/00026.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00026.jpeg)'
- en: And it works exactly the same on Android while retaining its unique native characteristics.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它在 Android 上的工作方式完全相同，同时保留其独特的本机特性。
- en: '![](../images/00027.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00027.jpeg)'
- en: You might notice, however, that `ActionBar` on Android defaults to all `ActionItem`
    on the right-hand side. One last trick we want to show you quickly is the ability
    for platform-specific view templates. Oh and don't worry about those ugly Android
    buttons; we will integrate font icons later for those.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可能会注意到，Android 上的 `ActionBar` 默认为所有 `ActionItem` 都在右侧。我们想要向您展示的最后一个技巧是平台特定的视图模板的能力。哦，不要担心那些丑陋的
    Android 按钮；我们稍后会为它们集成字体图标。
- en: Create platform-specific view templates wherever you see fit. Doing so will
    help you dial views for each platform where necessary and make them highly maintainable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在您认为合适的地方创建平台特定的视图模板。这样做将帮助您为每个平台调整视图，必要时使其高度可维护。
- en: 'Let''s create `app/modules/mixer/components/action-bar/action-bar.component.ts`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建 `app/modules/mixer/components/action-bar/action-bar.component.ts`：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can then create an iOS-specific view template: `app/modules/mixer/components/action-bar/action-bar.component.ios.html`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以创建一个特定于 iOS 的视图模板：`app/modules/mixer/components/action-bar/action-bar.component.ios.html`：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And an Android-specific view template: `app/modules/mixer/components/action-bar/action-bar.component.android.html`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个特定于 Android 的视图模板：`app/modules/mixer/components/action-bar/action-bar.component.android.html`：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then we can use it in `app/modules/mixer/components/mixer.component.html`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在 `app/modules/mixer/components/mixer.component.html` 中使用它：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Just ensure you add it to the `COMPONENTS` of `MixerModule`  in `app/modules/mixer/mixer.module.ts`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 只需确保将其添加到`app/modules/mixer/mixer.module.ts`中的`MixerModule`的`COMPONENTS`中：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Voila!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 看这里！
- en: '![](../images/00028.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00028.jpeg)'
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have arrived at the end of this amazing journey down Route 66 and hope you
    feel as exhilarated as we do. This chapter has presented some interesting Angular
    concepts, including route configuration with lazy loaded modules to keep the app
    startup time fast; building a custom module loader using native file handling
    APIs; combining the flexibility of `router-outlet` with NativeScript's `page-router-outlet`;
    gaining control and understanding of Singleton services with lazy loaded modules;
    guarding routes dependent on authorized access; and working on late feature requirements
    to show off our wonderfully scalable app design.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了66号公路的终点，希望您和我们一样感到兴奋。本章介绍了一些有趣的Angular概念，包括使用惰性加载模块进行路由配置，以保持应用程序启动时间快；使用本机文件处理API构建自定义模块加载器；将`router-outlet`的灵活性与NativeScript的`page-router-outlet`相结合；掌握并理解惰性加载模块的单例服务；保护依赖授权访问的路由；以及处理晚期功能需求，展示我们出色可扩展的应用程序设计。
- en: 'This chapter rounds out the general usability flow of our app and, at this
    point, we are ready to venture into the core competency of our app: **Audio Handling
    via iOS and Android''s rich native APIs**.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将总结我们应用程序的一般可用性流程，此时，我们已经准备好进入我们应用程序的核心竞争力：**通过iOS和Android丰富的本机API处理音频**。
- en: Before delving into the thick of things, in the next chapter we will take a
    brief moment to inspect NativeScript's various `tns` command-line arguments to
    run our app to lock in a thorough education of the tool belt we can now bring
    to work.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论之前，在下一章中，我们将花一点时间来检查NativeScript的各种`tns`命令行参数，以运行我们的应用程序，以便全面了解我们现在可以使用的工具。
