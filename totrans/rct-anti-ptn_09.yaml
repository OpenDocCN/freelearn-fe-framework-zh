- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying Design Principles in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design principles are like the cardinal rules that guide software development,
    ensuring that code remains maintainable, scalable, and readable over time. In
    the ever-changing landscape of technology, adhering to these principles can be
    the difference between a project’s long-term success and its descent into “code
    hell,” where changes become increasingly arduous and bugs frequent.
  prefs: []
  type: TYPE_NORMAL
- en: For React applications, the importance of design principles escalates due to
    the library’s declarative nature and component-based architecture. React empowers
    developers to build complex UIs from small, isolated pieces of code known as components.
    While this modular approach is one of React’s strongest features, it can also
    lead to a messy and unmanageable code base if design principles are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: In a typical React project, components often share state and behavior, get nested
    within each other, and are reused across different parts of an application. Without
    following design principles, you might find yourself entangled in a web of dependencies,
    making it difficult to change or even understand the code. For instance, neglecting
    the **Single Responsibility Principle** (**SRP**) could result in components that
    are difficult to test and refactor, while ignoring the **Interface Segregation
    Principle** (**ISP**) could make your components less reusable and more coupled
    to specific use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, as React continues to evolve, with new features such as Hooks and
    concurrent mode, having a design principle-centered approach ensures that you
    can adapt to these changes without significant rewrites. This allows you to focus
    on building features, fixing bugs, and delivering value, instead of grappling
    with technical debt.
  prefs: []
  type: TYPE_NORMAL
- en: Adhering to design principles in React development is not just a best practice
    but a necessity. It serves as a proactive measure to counteract complexity, making
    your React code easier to read, test, and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we commence by revisiting the SRP, a core concept that often
    serves as the bedrock of clean, maintainable code. From the humble beginnings
    of a simple string-transforming function, we’ll explore how this principle scales
    up to the complexities of render props, enriching the structure and readability
    of your React components.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning from there, we introduce the **Dependency Inversion Principle**
    (**DIP**), a transformative approach to component design. This section emphasizes
    that focusing on the interface – not the nitty-gritty details of implementation
    – is the pathway to reusable and easily understandable components.
  prefs: []
  type: TYPE_NORMAL
- en: Concluding the chapter, we delve into **Command and Query** **Responsibility
    Segregation** (**CQRS**), a pattern that gains importance as your React applications
    grow in size and complexity. Through a discussion on CQRS, you’ll discover strategies
    to separate your application’s command and query responsibilities, thereby making
    it more manageable and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to equip you with a holistic understanding of key design principles,
    which in turn will lay a strong foundation for the rest of your journey in mastering
    React.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the Single Responsibility Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embracing the Dependency Inversion Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Command and Query Responsibility Segregation in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A GitHub repository has been created to host all the code we discuss in the
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch9](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch9).
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the Single Responsibility Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B21103_04.xhtml#_idTextAnchor111), we delved into the SRP within
    the context of designing React components. Yet this principle is more universal,
    acting as the bedrock for various other programming tenets. To bring this idea
    to life, let’s work through some hands-on examples.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the core responsibility of a component is key to adhering to the
    SRP. Once you isolate what the component is fundamentally meant to do, it becomes
    easier to refactor and abstract out auxiliary functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: The SRP, being a high-level guideline, is advantageous when applied directly
    at the code level. There are numerous ways to implement this principle, but recognizing
    when to apply it is crucial, especially as complexity increases.
  prefs: []
  type: TYPE_NORMAL
- en: The most common two techniques we’ll use are *render props* and *composition*.
    Render props refer to a technique in React for sharing code between components
    using a prop whose value is a function. A component with a render prop takes a
    function that returns a React element and calls it instead of implementing its
    own render logic. On the other hand, composition in React is a development pattern
    where you build components as small, reusable pieces and then compose them together
    to create more complex UIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we’ll explore two specific examples, demonstrating
    how we use render props and composition respectively to adhere to this principle
    in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the render props pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start simple with a basic function component called `Title`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As it stands, this component merely outputs a static string. To give it the
    ability to render different titles, we introduce a `title` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With this change, the component becomes more versatile, appending a fixed prefix,
    `Title |`, to any title we pass in. But what if we want to further manipulate
    the title, perhaps to capitalize it?
  prefs: []
  type: TYPE_NORMAL
- en: 'By utilizing a higher-order function – the `transformer` parameter in the following
    code snippet – we can modify our `Title` component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In many programming languages (including JavaScript), a `map`, `filter`, and
    `reduce` on arrays, function composition, currying, and event handling. Higher-order
    functions simplify code structure, improve maintainability, and allow for more
    advanced programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great – our title is now fully customizable. But let’s stretch this even further.
    What if we want the title to be inside an `h3` tag rather than a simple `div`
    tag? React has got us covered – we can pass a function that returns JSX elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of the render prop – we call it as a function and pass in `title`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the render prop, we can pass an anonymous function (inside the curly
    braces) into it, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In React, this higher-order function doesn’t necessarily have to be named `render`.
    We could just as easily use the `children` prop for a more intuitive design, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to invoke `children` as if it were a regular function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Title` component receives a `title` prop and a child function (the latter
    of which is called a `s`, converts it to uppercase, and renders it within an `h3`
    tag. The `Title` component calls this child function with the provided title prop
    for custom rendering.
  prefs: []
  type: TYPE_NORMAL
- en: In React, the render prop pattern involves passing a function as a prop to a
    component. This function returns JSX that the component will render as part of
    its output. The pattern allows for more flexible and reusable components by giving
    the parent component control over a part of the child component’s rendering logic.
    It’s particularly useful for sharing behavior across multiple components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take note of the overarching pattern at play here: abstraction. Initially,
    we might think of `h2` or `h3` as specific instances of headings. However, upon
    zooming out a bit, we start to understand that they’re part of a broader abstraction:
    a React component or, more technically, `ReactNode`.'
  prefs: []
  type: TYPE_NORMAL
- en: This realization allows us to see the utility of using render props or children
    as higher-order functions. They’re not just features; they represent the level
    of abstraction we’ve achieved. Now, instead of being limited to a specific HTML
    tag such as `h3`, we can pass any JSX element as an argument, from headings to
    fully styled components.
  prefs: []
  type: TYPE_NORMAL
- en: With our newly crafted generic component that uses a render prop, we’ve essentially
    created a reusable framework. The beauty lies in the fact that we only need to
    write this general-purpose code once.
  prefs: []
  type: TYPE_NORMAL
- en: Render props and composition are excellent techniques for this. They allow you
    to extend or customize the behavior of a component without altering its core logic.
    This keeps your components clean, modular, and easy to test, as each component
    does one thing and does it well. We have already seen how render props work in
    the evolution of `Title`, so let’s now have a look at composition.
  prefs: []
  type: TYPE_NORMAL
- en: Using composition to apply the SRP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Composition** is a term we have used in many places throughout the book,
    and at its core is the SRP. If each part of the system can do its job well, it’s
    then possible to compose them together. Let’s inspect a concrete example of this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume we have an `Avatar` component in a design system with a handy feature:
    if a user passes in a `name` prop to the component, then when the mouse hovers
    over the avatar, a tooltip will show up at the bottom of the avatar with the name
    as its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Avatar component with Tooltip](img/B31103_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Avatar component with Tooltip'
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, `Avatar` utilizes another component, `Tooltip`, to make it happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `Avatar` component takes two optional props, `name` and `url`, and displays
    an image using the URL provided. If the `name` prop is also provided, it wraps
    the image in a `Tooltip` component that shows the name when hovered over. The
    `div` tag is styled with a `rounded` class, which will present the avatar in a
    circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original code for the `Avatar` component tightly coupled it to a `Tooltip`
    feature. As users demanded more customization options for the tooltip, maintaining
    this coupling became challenging. Adding more props to handle tooltip customization
    can bloat the `Avatar` component and create a ripple effect: any change in `Tooltip`
    may necessitate changes in `Avatar`, making it hard to manage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of forcing `Tooltip` into `Avatar`, we can simplify `Avatar` to focus
    solely on its primary function—displaying an image. This stripped-down version
    excludes the tooltip, reducing its bundle size and making it more maintainable.
    Here’s how the simplified `Avatar` component looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing so, we make the `Avatar` and `Tooltip` components composable, meaning
    they can work independently of each other. The consumer can then choose to wrap
    `Avatar` with `Tooltip` if desired, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code imports `Avatar` and `Tooltip` components from the `"@xui"` library.
    It then defines a `MyAvatar` component that displays an avatar for `"Juntao Qiu"`
    (if there isn’t a name needed here, we don’t use the `Tooltip` component). When
    you hover over the avatar, a tooltip appears on top with the name **Juntao Qiu**
    in a design customized with a white font color on a blue background.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefit of this approach is twofold:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Avatar` component remains lean, reducing its bundle size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The consumer has the freedom to customize `Tooltip` or even use different tooltip
    libraries without affecting `Avatar`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, the separation makes the code more modular, and users only have to
    “pay” in terms of code and complexity for the features they actually use.
  prefs: []
  type: TYPE_NORMAL
- en: In both the render props and composition examples, we underlined the essence
    of the SRP in modern web development. The SRP advocates for building components
    that do one thing and do it well, making them more maintainable, reusable, and
    flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s pivot to discussing the DIP, another crucial perspective that complements
    these design principles.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing the Dependency Inversion Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **DIP** is one of the five principles that make up SOLID, a set of guidelines
    aimed at helping developers create more maintainable, flexible, and scalable software.
    Specifically, the DIP encourages developers to depend on abstractions, not on
    concrete implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The five principles of SOLID are the Single Responsibility Principle, Open-Closed
    Principle, Liskov Substitution Principle, Interface Segregation Principle, and
    Dependency Inversion Principle.
  prefs: []
  type: TYPE_NORMAL
- en: The DIP addresses several challenges that developers face when building and
    maintaining large systems. One such problem is the rigidity that comes from tightly
    coupled modules. When high-level modules are dependent on low-level modules, even
    small changes to the low-level code can have a broad impact, necessitating changes
    across the system.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how the DIP works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In terms of high-level modules and low-level modules, let’s think of a notification
    feature in a system. Here, we want to send out a notification in a form that the
    user prefers, either an email, an SMS message, or both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the code, the `EmailNotification` class has a method called `send` that takes
    `message` and `type` as parameters. It then prints out a log to indicate that
    an email with this `message` and `type` is being sent. The `Application` class,
    on the other hand, has a `process` method that simulates some kind of user interaction.
    Inside this method, `Application` uses an instance of `EmailNotification` to send
    an email whenever `process` is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to note here is that `Application` is tightly coupled to
    `EmailNotification`. This means that if you wanted to change how notifications
    are sent, perhaps by using SMS instead of email, you’d have to modify the `Application`
    class directly, thereby violating the SRP and making the system less flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to resolve the problem, we can introduce a `Notification` interface and
    let `EmailNotification` implement the interface. That means we could have multiple
    implementations of the interface. Plus, instead of `Application` depending on
    the `EmailNotification` class, `Application` depends on the `Notification` interface.
    Because we rely on the interface, from `Application`’s view, it doesn’t matter
    which concrete implementation is passed in, as long as it implements the `Notification`
    interface – that means we could easily swap it to an `SMSNotification` class if
    we like. Here’s what the code for all of this will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The code defines a `Notification` interface with a `send` method, which is then
    implemented by the `EmailNotification` class. The `Application` class is now constructed
    with any object that adheres to the `Notification` interface. Within its `process`
    method, `Application` uses this object to send a notification. This setup decouples
    the `Application` class from the specific notification mechanism, making it more
    flexible and easier to change or extend.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we decide to replace `EmailNotification` with `SMSNotification`,
    the `Application` class won’t need any modifications; we would simply provide
    a different instance that implements the `Notification` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: All right – that’s briefly about how the DIP works. Let’s look at another example
    to find out how to apply the same principle inside a React application.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the DIP in an analytics button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, imagine you have a generic button component that’s used across various
    parts of your application. You want to send analytics events when the button is
    clicked, but how exactly those events are sent should be abstracted away from
    the button component itself.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that generic buttons are widely used in many products already,
    and not all of them need the analytics functionality. So, if you simply change
    the `onClick` handler in the shared `Button` component, it will annoy many innocent
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the current `Button` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we could define a new component that wraps the original button around
    and hijacks the click handler for the analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The new code defines a `FancyButton` component that wraps around a basic `Button`
    component. When clicked, `FancyButton` first sends an analytics event to a remote
    server and then proceeds to execute the original `onClick` function passed to
    it. All other props are passed down directly to the underlying `Button` component.
  prefs: []
  type: TYPE_NORMAL
- en: The issue here is that many instances where the `Button` component is used might
    contain similar analytics code, leading to repetitive logic across the code base.
    This redundancy is undesirable, as any changes to the analytics logic would require
    updates in multiple locations, increasing the risk of errors.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s consider the DIP. We will make some changes in the original `Button`
    component, but instead of sending analytics events directly, we’ll first extract
    an interface and make the button rely on the interface (keep in mind there could
    be multiple implementations of that interface).
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the previous `Notification` example, `EmailNotification` is one
    of the notification channels that send email. In this button example, one of the
    implementations sends an event, whereas for products that don’t use analytics
    at all, they just pass in an empty implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the change, we’ll need to define a new interface type, and we need
    a context for the implementation of the interface to live in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a React context named `InteractionMeasurement` with an interface
    that specifies a `measure` method. This method takes a name (either a string or
    undefined) and an optional timestamp, while the context is initialized as `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Button` component, we can use `useContext` to access the context
    we defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The code defines a `Button` component that uses `InteractionContext` to track
    clicks. When the button is clicked, it calls the `measure` method from the context,
    passing in the button’s name and the click event’s timestamp. Then, it proceeds
    to execute any additional `onClick` logic provided. This way, click tracking is
    abstracted away into the context, making the `Button` component more reusable
    and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: If `interactionContext` is `null`, the `measure` function won’t be called, and
    the component will proceed to execute only the `providedOnClick` function passed
    in as a prop. This allows for optional analytics tracking based on the availability
    of `InteractionContext`.
  prefs: []
  type: TYPE_NORMAL
- en: That would perfectly resolve the problem we have – if a product wants to enable
    the analytics, they can use `Button` within a context that contains an `InteractionMeasurement`
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said that, let’s say we have a `FormApp` application that uses `Button`
    inside an `InteractionContext` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `FormApp` component defines its own analytics logic in the `measure` function
    inside the `context` object. It then passes this function to child components
    through `InteractionContext.Provider`. When a button inside the form is clicked,
    not only will the button’s specific `onClick` logic be executed, but the `measure`
    function will also send event and timestamp data to a remote server for analytics.
    This setup allows for context-based analytics without tying the `Button` component
    to a specific implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For users who don’t want the analytics functionality, they can just use the
    `Button` component as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This methodology offers exceptional flexibility and dynamism, making it invaluable
    for designing common components. It enhances both code reusability and system
    maintainability while also reducing the overall bundle size.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that adding an extra `context` object in such scenarios may initially
    seem excessive. However, in large code bases where different teams work on distinct
    parts, this approach becomes more relevant. For instance, a product team focused
    on analysis might have different objectives compared to a design system team,
    whose aim is to develop generic and atomic components. The design system team
    may not be concerned with analytical aspects. Consequently, directly modifying
    the `Button` component in this environment can be impractical or challenging.
  prefs: []
  type: TYPE_NORMAL
- en: Having that said, I would like to introduce another design principle I constantly
    use in my code; you can think of it as a special form of the SRP at its core.
    This principle is CQRS.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Command and Query Responsibility Segregation in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Command and Query Responsibility Segregation** (**CQRS**) principle (also
    known as the **Separation of Command and Query Principle**) is a software design
    principle that suggests that methods or functions should either be commands that
    modify the system’s state or queries that return information about the system’s
    state, but not both.
  prefs: []
  type: TYPE_NORMAL
- en: '**Commands** (or **modifiers**) are methods that perform an action or change
    the state of an object without returning a value. **Queries**, on the other hand,
    are methods to read an object’s state without any changes. Separating commands
    and queries can help reduce coupling between components, making testing, maintaining,
    and modifying code easier. It also makes it easier to reason about the behavior
    of code and can improve the overall design of a system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this pattern is widely used on a large scale, such as in designing
    the architecture of systems, it works well at the code level as well. I will demonstrate
    this in a `ShoppingCart` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `ShoppingApplication` component maintains a shopping cart using the `useState`
    Hook with an array of items of type `Item`. The `addItemToCart` function adds
    new items to the cart, and `removeItemFromCart` removes items based on their `id`
    value. `totalPrice` is calculated as the sum of all item prices in the cart.
  prefs: []
  type: TYPE_NORMAL
- en: The component renders a list of items in the cart, along with their total price.
    Each item has a `removeItemFromCart` when clicked. A `ProductList` component is
    also rendered, and it receives `addItemToCart` as a prop for adding products to
    the cart.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code appears to be okay at first glance, but it contains some subtle
    issues. One problem is that when multiple identical products are added to the
    cart, the keys will overlap, triggering React’s warning about unique keys. Additionally,
    if you click the **Remove** button in this situation, it will delete all instances
    of that product from the cart, which is far from ideal and leads to a poor user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix these issues, we need to introduce a new `uniqKey` field to the `Item`
    type. We also need to generate a unique key before an item is inserted into the
    `cart` array. With that unique ID, we are finally able to remove items by `uniqKey`
    instead of by `id`. This is what the code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to update how the cart is rendered in JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: While the code is technically sound and sufficiently straightforward for its
    current scope, as we expand the `ShoppingApplication` component with more states
    and calculations, applying the CQRS principle could provide a structured way to
    keep everything organized.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the React Context API and the `useReducer` Hook to implement CQRS
    for the `ShoppingApplication` component. Let’s take a look at them now.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing useReducer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `useReducer` Hook in React is used for state management in functional components;
    it is particularly useful when the next state depends on the previous one or when
    you have complex state logic. The `useReducer` Hook takes two arguments: a reducer
    function and an initial state, and it returns the current state and a `dispatch`
    method to trigger updates.'
  prefs: []
  type: TYPE_NORMAL
- en: For the first parameter, a reducer function receives the current state and an
    `action` object, which contains information on how to update the state. The function
    should return the new state based on the action type and payload. The second parameter
    is the initial state you want to pass in and will be used as the default value
    when invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a reducer function for our `ShoppingApplication` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `shoppingCartReducer` is a function that takes two arguments – the current
    state and an action:'
  prefs: []
  type: TYPE_NORMAL
- en: The state is of type `ShoppingCartState`, which includes an array of items and
    `totalPrice`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action is of type `ActionType`, which includes a `string` type to identify
    the action and a payload containing an `Item` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the reducer function, a `switch` statement is used to determine which
    action is being dispatched. The `"ADD_ITEM"` case adds a new item to the state’s
    `items` array. This item is given a unique key, `uniqKey`, to differentiate it
    from identical items. The `"REMOVE_ITEM"` case removes an item from the `items`
    array based on this unique key.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using this structure, the reducer function provides a predictable way to
    manage the shopping cart’s state in response to different actions. Note there
    is nothing fancy here in this reducer function; it’s just a regular JavaScript
    function. To see how it works, we could test the reducer function with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And we would get something like this (obviously, your `uniqKey` value would
    be different from mine as it’s generated by the time an item is added):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: All right – that should give a taste of what a reducer function is and how it
    works with any given input. Now, let’s see how we can connect it with our application.
  prefs: []
  type: TYPE_NORMAL
- en: Using a reducer function in a context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see how we can use a reducer function to implement CQRS to simplify our
    shopping cart example. Firstly, we’ll need a context to manage the cart state,
    and also expose query functions for components to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a React context for managing a shopping cart. Inside `ShoppingCartProvider`,
    it uses the `useReducer` Hook to handle cart actions. Two functions, `addItem`
    and `removeItem`, dispatch actions to modify the cart. The `Provider` component
    makes the cart state and these functions available to its child components via
    `ShoppingCartContext`. This allows any nested components to interact with the
    shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `addItem` and `removeItem` are two command functions in the CQRS
    principle that only change the state without returning any data. If we want to
    get the data, we can define a query function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a custom Hook called `useTotalPrice` that calculates the total
    price of items in a shopping cart. It uses the React `useContext` Hook to access
    the shopping cart data from `ShoppingCartContext`. It then uses the `reduce` method
    to sum up the prices of all items in the cart, starting with an initial value
    of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `ShoppingApplication` component, we can simply wrap `ProductList` and
    `ShoppingCart` inside the `ShoppingCartContext` instance we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `ShoppingApplication` component serves as the main interface for the shopping
    application. It uses React’s `useContext` Hook to access the shopping cart context,
    which provides a list of items in the cart (`items`), a function to add items
    (`addItem`), and a function to remove items (`removeItem`). The component also
    uses a `useTotalPrice` custom Hook to calculate the total price of items in the
    cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'And in the outmost `App` component, we can encapsulate the `ShoppingApplication`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: So, CQRS is a design pattern that separates the modification and query aspects
    of a system to enhance scalability, maintainability, and simplicity. We demonstrated
    this principle by implementing a shopping cart feature – commands to modify the
    cart’s state, such as adding or removing items, were segregated from the queries,
    which included fetching a list of items and calculating the total price; this
    separation was made clear through the use of React’s Context API and custom Hooks,
    which isolated each responsibility effectively. This not only improves code readability
    but also makes it easier to manage and scale the application in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ve unpacked three crucial design principles: the SRP for
    focused, easy-to-understand components, the DIP for modular, testable code, and
    CQRS for a distinct separation between commands and queries, enhancing maintainability.
    These principles offer a robust foundation for building scalable and high-quality
    software.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll dive deeper into composition principles to further
    refine our approach to React application design.
  prefs: []
  type: TYPE_NORMAL
