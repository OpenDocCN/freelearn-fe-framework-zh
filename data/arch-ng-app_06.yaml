- en: Manipulating Streams and Their Values
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作流及其值
- en: Let's start with a recap of the previous chapter and remind ourselves how far
    we have come already in understanding RxJS. We learned about concepts such as
    `Observable`, `Observer`, and `Producer`, and how they interplay. Furthermore,
    we got insight into the subscription process so we could actually receive our
    coveted values. We also looked at how unsubscribing from streams works and in
    which cases it is necessary to define such a behavior. Lastly, we got our hands
    dirty by learning how to build a core implementation of RxJS and thereby got to
    see all those concepts in action. Armed with all that knowledge, we should feel
    quite confident about the foundation of RxJS, but as was mentioned in the last
    chapter, we need help from operators to actually do something meaningful with
    our streams.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回顾上一章开始，提醒自己我们已经对RxJS有了多深的理解。我们学习了诸如`Observable`、`Observer`和`Producer`等概念，以及它们是如何相互作用的。此外，我们还了解了订阅过程，以便我们实际上可以接收我们渴望的值。我们还研究了如何从流中取消订阅，以及在哪些情况下需要定义这种行为。最后，我们通过学习如何构建RxJS的核心实现，从而看到了所有这些概念的实际应用。拥有所有这些知识，我们应该对RxJS的基础感到相当自信，但正如上一章提到的，我们需要操作符的帮助来真正对我们的流做些有意义的事情。
- en: Let's not delay any further and start talking about this chapter. Operators
    are functions we can call on our streams to perform manipulation in many different
    ways. Operators are immutable, which makes the stream easy to reason about and
    will also make it quite easy to test. As you will see throughout this chapter,
    we will seldom deal with just one stream, but many streams, and it is understanding
    how to forge and control these streams that allows you to go from thinking it's
    *dark magic* to actually being able to apply RxJS when and where you need it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不再拖延，开始讨论本章内容。操作符是我们可以在流上调用的函数，可以以许多不同的方式执行操作。操作符是不可变的，这使得流易于推理，也将使测试变得相当容易。正如你将在本章中看到的那样，我们很少只处理一个流，而是处理许多流，理解如何构建和控制这些流将使你从认为它是*黑暗魔法*转变为实际上能够在需要时应用RxJS。
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: How to use basic operators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用基本操作符
- en: Debugging streams with operators as well as with existing tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用操作符以及现有工具调试流
- en: Digging deeper into different operator categories
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解不同的操作符类别
- en: Developing the mindset to solve a problem the Rx way
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 培养以Rx方式解决问题的思维方式
- en: Starting out
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: You almost always start out coding with RxJS by creating a stream of static
    values. Why static values? Well, there is no need to make it unnecessarily complex,
    and all you really need to start reasoning is an `Observable`. As you gradually
    progress in your problem solving, you might replace the static values with a more
    appropriate call to an AJAX call, or from another asynchronous source that your
    values originate from.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎总是通过创建一个静态值的流来开始使用RxJS进行编码。为什么是静态值呢？好吧，没有必要让它变得过于复杂，而你真正需要开始推理的只是一个`Observable`。随着你在解决问题的过程中逐渐进步，你可能会用更合适的AJAX调用或来自其他异步源值的调用来替换静态值。
- en: You then start thinking about what you want to achieve. This leads you to consider
    which operators you might need and in which order you need to apply them. You
    might also think about how to divide your problem up; this usually means creating
    more than one stream, where each stream solves a specific problem that connects
    to the larger problem you are trying to solve.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你开始思考你想要实现的目标。这会让你考虑你可能需要的操作符以及它们的顺序。你也可能会考虑如何将问题分解；这通常意味着创建多个流，其中每个流解决一个特定的问题，这些问题与你试图解决的更大问题相连接。
- en: Let's start with stream creation and see how we can take our first steps working
    with streams.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建流开始，看看我们如何迈出与流一起工作的第一步。
- en: 'The following code creates a stream of static values:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个静态值的流：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That is a very basic example of how we can create a stream. We use the `of()`
    creation operator, which takes any number of arguments. All the arguments are
    emitted, one by one, as soon as there is a subscriber. In the preceding code,
    we also subscribe to `staticValuesStream$` by calling the `subscribe()` method
    and passing a function that takes the emitted value as a parameter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基础的例子，展示了我们如何创建一个流。我们使用`of()`创建操作符，它接受任意数量的参数。所有参数都会在有订阅者时依次发出。在上面的代码中，我们还通过调用`subscribe()`方法并传递一个以发出值为参数的函数来订阅`staticValuesStream$`。
- en: Let's introduce an operator, `map()`, which acts like a projection and allows
    you to change what is being emitted. The `map()` operator gets called on each
    value in the stream before it is emitted.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们引入一个操作符 `map()`，它像一个投影一样工作，允许你改变正在发出的内容。`map()` 操作符在发出之前对流中的每个值进行调用。
- en: 'You use the `map()` operator by supplying it with a function and carrying out
    a projection, like so:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过提供一个函数并执行一个投影来使用 `map()` 操作符，如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, we have appended the `map()` operator to `staticValuesStream$`
    and we apply it to each value before emitting it and incrementing it by one. The
    resulting data is therefore changed. This is how you append operators to a stream:
    simply create the stream, or take an existing one, and append the operators one
    by one.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 `map()` 操作符附加到 `staticValuesStream$` 上，并在发出之前对每个值应用它，并将其增加一。因此，结果数据发生了变化。这就是将操作符附加到流上的方法：简单地创建流，或者使用现有的一个，然后逐个添加操作符。
- en: Let's add another operator, `filter()`, to ensure that we really understand
    how to work with operators. What does `filter()` do. Well, just like the `map()`
    operator, it is applied to each value, but instead of creating a projection, it
    decides which values will be emitted. `filter()` takes a Boolean. Any expression
    evaluated to `true` means the value will be emitted; if `false`, the expression
    will not be emitted.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个操作符 `filter()`，以确保我们真正理解如何使用操作符。`filter()` 做什么？嗯，就像 `map()` 操作符一样，它应用于每个值，但它不是创建一个投影，而是决定哪些值将被发出。`filter()`
    接收一个布尔值。任何评估为 `true` 的表达式意味着值将被发出；如果为 `false`，则表达式将不会发出。
- en: 'You use the `filter()` operator in the following way:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下方式使用 `filter()` 操作符：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We add the `filter()` operator by chaining it to the existing `map()` operator.
    The condition we give our `filter()` operator says to only return `true` for values
    that are divisible by `2`, that's what the modulus operator does. We know from
    before that the `map()` operator alone ensures that the values `2`, `3` , `4`,
    and `5` are emitted. These are the values that are now being evaluated by the
    `filter()` operator. Out of those four values, only `2` and `4` fulfill the condition
    set out by the `filter()` operator.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将其链接到现有的 `map()` 操作符来添加 `filter()` 操作符。我们给 `filter()` 操作符的条件是只对能被 `2` 整除的值返回
    `true`，这就是模运算符的作用。我们知道从之前的内容中，`map()` 操作符本身确保了值 `2`、`3`、`4` 和 `5` 被发出。这些是现在由 `filter()`
    操作符评估的值。在这四个值中，只有 `2` 和 `4` 满足 `filter()` 操作符设定的条件。
- en: 'Of course, when working on a stream and applying operators, things might not
    always be as simple as the preceding code. It might not be possible to anticipate
    exactly what gets emitted. For those occasions, we have a few tricks we can use.
    One such trick is to use the `do()` operator, which will allow us to inspect each
    value without changing it. This gives us ample opportunity to use it for debugging
    purposes. Depending on where we are in the stream, the `do()` operator will output
    different values. Let''s look at different situations where it matters where the
    `do()` operator is applied:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当在流上工作并应用操作符时，事情可能并不总是像前面的代码那样简单。可能无法准确预测将发出什么。在这些场合，我们有一些技巧可以使用。其中一种技巧是使用
    `do()` 操作符，这将允许我们检查每个值而不改变它。这为我们提供了充足的机会来用于调试目的。根据我们在流中的位置，`do()` 操作符将输出不同的值。让我们看看
    `do()` 操作符应用时不同情况下的不同影响：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, just by using the `do()` operator, we have a nice way to debug
    our streams, which becomes necessary as our streams grow in complexity.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，仅通过使用 `do()` 操作符，我们就有了调试流的好方法，随着流复杂性的增加，这变得是必要的。
- en: Understanding operators
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解操作符
- en: So far, we have shown how to create a stream and use some very basic operators
    on it to change what values get emitted. We also introduced how to inspect your
    stream without changing it by using the `do()` operator. Not all operators are
    as easy to understand as the `map()`, `filter()`, and `do()` operators. There
    are different tactics you can use to try to understand what each operator does
    so you know when to use them. Using the `do()` operator is one way, but there
    is a graphical approach you can take. This approach is known as a marble diagram.
    It consists of an arrow that represents time passing from left to right. There
    are circles, or marbles, on this arrow that represent emitted values. The marbles
    have a value in them, but the distance between the marbles might also describe
    what is happening over time. A marble diagram usually consists of at least two
    arrows with marbles on them, as well as an operator. The idea is to represent
    what happens to a stream when an operator is applied. The second arrow usually
    represents the resulting stream.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了如何创建一个流，并在它上面使用一些非常基本的运算符来改变发出的值。我们还介绍了如何使用 `do()` 运算符在不改变流的情况下检查流。并不是所有的运算符都像
    `map()`、`filter()` 和 `do()` 运算符那样容易理解。你可以使用不同的策略来尝试理解每个运算符的作用，以便你知道何时使用它们。使用 `do()`
    运算符是一种方法，但还有一种图形化的方法可以采用。这种方法被称为弹珠图。它由一个代表时间从左到右流逝的箭头组成。在这个箭头上有一些代表发出的值的圆圈或弹珠。弹珠中有一个值，但弹珠之间的距离也可能描述了随时间发生的事情。弹珠图通常至少由两个带有弹珠的箭头和一个运算符组成。其想法是表示应用运算符后流发生了什么。第二个箭头通常表示结果流。
- en: 'Here''s an example of a marble diagram:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个弹珠图的例子：
- en: '![](img/507d307c-1f03-4121-84f7-72db33991da2.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/507d307c-1f03-4121-84f7-72db33991da2.png)'
- en: 'Most operators in RxJS are depicted by a marble diagram on the site RxMarbles:
    [http://rxmarbles.com/](http://rxmarbles.com/). This is a truly great resource
    to quickly gain an understanding of what operators do. However, to truly understand
    RxJS you need to code; there is no getting around it. There are different ways
    of doing that of course. You can easily set up your own project and install RxJS
    from NPM, refer to it through a CDN link, or you can use a page such as JS Bin
    ([www.jsbin.com](http://www.jsbin.com)), which gives you the ability to easily
    add RxJS as a library and allows you to start coding straight away. It looks something
    like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 中的大多数运算符都在 RxMarbles 网站上用弹珠图表示：[http://rxmarbles.com/](http://rxmarbles.com/)。这是一个真正伟大的资源，可以快速了解运算符的作用。然而，要真正理解
    RxJS，你需要编写代码；这是不可避免的。当然，有不同方法可以做到这一点。你可以轻松设置自己的项目并从 NPM 安装 RxJS，通过 CDN 链接引用它，或者你可以使用像
    JS Bin ([www.jsbin.com](http://www.jsbin.com)) 这样的页面，它让你能够轻松地将 RxJS 作为库添加，并允许你立即开始编码。它看起来像这样：
- en: '![](img/369e27bb-a874-4e66-976f-1231b6e63380.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/369e27bb-a874-4e66-976f-1231b6e63380.png)'
- en: 'JS Bin makes it easy to start, but wouldn''t it be great if we could combine
    marble diagrams and JS Bin, and get a graphical representation of what you code,
    when you code? You can get just that with RxFiddle: [http://rxfiddle.net/](http://rxfiddle.net/).
    You can enter your code, click Run, and you are shown a marble diagram of what
    you just coded, which will look like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: JS Bin 让开始变得容易，但如果我们能将弹珠图和 JS Bin 结合起来，并得到你编码时的图形表示，那岂不是更好？你可以用 RxFiddle 实现这一点：[http://rxfiddle.net/](http://rxfiddle.net/)。你可以输入你的代码，点击运行，然后你会看到一个弹珠图，显示你刚刚编写的代码，它看起来像这样：
- en: '![](img/83235f79-246c-4f3e-be8c-d37e893bc8f8.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83235f79-246c-4f3e-be8c-d37e893bc8f8.png)'
- en: Stream in a stream
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流中的流
- en: 'We have been looking at different operators that change the values being emitted.
    There is another different aspect to streams: what if you need to create a new
    stream from an existing stream? Another good question is: when does such a situation
    usually occur? There are plenty of situations, such as:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在研究不同的运算符，它们会改变正在发出的值。流还有一个不同的方面：如果你需要从一个现有的流中创建一个新的流怎么办？另一个好问题是：这种情况下通常在什么时候发生？有很多情况，例如：
- en: Based on a stream of keyUp events, do an AJAX call.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于keyup事件流进行AJAX调用。
- en: Count the number of clicks and determine whether the user single, double, or
    triple-clicked.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算点击次数并确定用户是单击、双击还是三击。
- en: You get the idea; we are starting with one type of stream that needs to turn
    into another type of stream.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该明白了；我们从一个需要变成另一种类型的流的流类型开始。
- en: 'Let''s first have a look at creating a stream and see what happens when we
    try to create a stream as the result of using an operator:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何创建一个流，并看看当我们尝试使用运算符创建流时会发生什么：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At this point, every value that passes through the `map()` operator produces
    a new `Observable`. When you subscribe to `stream$`, each value that is emitted
    will be a stream. Your first instinct might be to attach a `subscribe()` to each
    of those values, like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，通过`map()`操作符传递的每个值都会产生一个新的`Observable`。当你订阅`stream$`时，每个发出的值都将是一个流。你的第一个本能可能是为这些值中的每一个都附加一个`subscribe()`，就像这样：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Fight this urge. This will only create code that is hard to maintain. What you
    want to do is merge all these streams into one so, that you just need one `subscribe()`.
    There is an operator just for that, called `flatMap()`. What `flatMap()` does
    is to take your array of streams and turn them into one stream, a metastream.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 抵制这种冲动。这将只会创建难以维护的代码。你想要做的是将这些流合并成一个，这样你只需要一个`subscribe()`。有一个操作符正是为此而设计的，称为`flatMap()`。`flatMap()`的作用是将你的流数组转换成一个流，一个元流。
- en: 'It is used in the following way:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用方式如下：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'OK, we get it, we don''t want a stream of Observables, but rather a stream
    of values. This operator seems really great. We still aren''t quite certain when
    to use though. Let''s make this a bit more realistic. Imagine you have a UI that
    consists of an input field. The user enters characters into that input field.
    Imagine that you want to react to one or more characters being entered and, for
    example, perform an AJAX request as the result of characters being entered. We
    focus on two things here: how to collect characters being entered and how to perform
    an AJAX request.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们明白了，我们不想得到一个Observable流，而是一个值流。这个操作符看起来真的很棒。但我们仍然不确定何时使用它。让我们使这个例子更现实一些。想象一下，你有一个由一个输入字段组成的UI。用户将字符输入到这个输入字段中。想象一下，你想要对输入的一个或多个字符做出反应，例如，在字符输入后执行一个AJAX请求。在这里，我们关注两个问题：如何收集输入的字符以及如何执行AJAX请求。
- en: 'Let'' start with the first thing, capturing characters entered into an input
    field. For this, we need an HTML page and a JavaScript page. Let''s start with
    the HTML page:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一件事开始，捕捉输入字段中输入的字符。为此，我们需要一个HTML页面和一个JavaScript页面。让我们从HTML页面开始：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This depicts our input element and a script reference to RxJS, as well as a
    reference to the `app.js` file. Then we have `app.js` file, where we get a reference
    to the input element and start listening to keystrokes as soon as they are entered:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了我们的输入元素和RxJS的脚本引用，以及`app.js`文件的引用。然后是`app.js`文件，其中我们获取输入元素的引用，并在输入被输入时立即开始监听按键：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Worth highlighting is the fact that we start listening to `keyup` events being
    emitted by calling the `fromEvent()` creation operator. Thereafter, we apply the
    `map()` operator to dig out the character value store on `ev.key`. Lastly, we
    subscribe to the stream. As expected, running this code will lead to characters
    being typed in the console as soon as you input values in the HTML page.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，我们通过调用`fromEvent()`创建操作符来开始监听由`keyup`事件发出的内容。然后，我们应用`map()`操作符来挖掘`ev.key`上的字符值存储。最后，我们订阅这个流。正如预期的那样，运行这段代码将在你输入HTML页面中的值时立即在控制台中打印出输入的字符。
- en: Let's make this more tangible by doing an AJAX request based on what we type.
    For this, we will be using the `fetch()` API and an online API called swapi (swapi.com),
    which contains a collection of APIs containing information on the Star Wars movies.
    Let's first define our AJAX call and then see how it fits into our existing stream
    of keys.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过基于我们输入的内容执行一个AJAX请求来使这个例子更具体。为此，我们将使用`fetch()` API和一个名为swapi（swapi.com）的在线API，它包含了一系列包含《星球大战》电影信息的API。让我们首先定义我们的AJAX调用，然后看看它如何融入我们现有的键流中。
- en: 'We said we would use `fetch()`. It lets us formulate a GET request as simple
    as this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过我们会使用`fetch()`。它允许我们像这样简单地制定一个GET请求：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Of course, we want to turn this request into an `Observable` so that it can
    play well with our `keyStream$`. Fortunately for us, this is easily accomplished
    through the use of the `from()` operator. Let''s, however, first rewrite our `fetch()`
    call into a method that''s easy to work with. The result of the rewrite looks
    like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们希望将这个请求转换成一个`Observable`，以便它能很好地与我们的`keyStream$`协同工作。幸运的是，通过使用`from()`操作符，我们可以轻松地实现这一点。然而，让我们首先将`fetch()`调用重写成一个易于操作的方法。重写后的结果如下：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code allows us to provide an argument used to construct a URL which we
    use to fetch some data with AJAX. At this point, we are ready to connect our function
    to our existing stream. We do that by typing the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码允许我们提供一个用于构造URL的参数，我们使用它通过AJAX获取一些数据。在这个阶段，我们准备将我们的函数连接到现有的流。我们通过输入以下内容来实现这一点：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We highlight the usage of the `flatmap()` operator in bold using our `from()`
    conversion operator. The operator mentioned last takes our `getStarwarsCharacterStream()`
    function as a parameter. The `from()` operator converts said function into a stream.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`from()`转换操作符以粗体形式突出显示`flatMap()`操作符的使用。最后提到的操作符将我们的`getStarwarsCharacterStream()`函数作为参数。`from()`操作符将此函数转换为流。
- en: 'Here, we have learned how to connect two different streams, but also how to
    convert a `Promise` into a stream. As good as this approach seems on paper, using
    `flatMap()` has its limitations and it is important to understand what they are.
    For that reason, let''s talk about the `switchMap()` operator next. The benefits
    of using a `switchMap()` operator will become clearer when we execute long-running
    tasks. For argument''s sake, let''s define such a task, like so:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们学习了如何连接两个不同的流，以及如何将`Promise`转换为流。尽管这种方法在纸面上看起来很好，但使用`flatMap()`有其局限性，了解这些局限性非常重要。因此，让我们接下来谈谈`switchMap()`操作符。使用`switchMap()`操作符的好处将在执行长时间运行的任务时变得更加明显。为了论证，让我们定义这样一个任务，如下所示：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this code, we have a function that takes 5 seconds to execute; enough time
    to show the point we are trying to make. Next, let''s show what the effect is
    if we keep using the `flatMap()` operator in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们有一个执行需要5秒钟的函数；这足以展示我们试图说明的点。接下来，让我们展示如果我们继续在以下代码中使用`flatMap()`操作符会产生什么效果：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code works in the following way: every time we hit a key, it
    generates an event. However, we have a `.filter()` operator in place that ensures
    an event is only generated when at least four keys are entered, `filter(key =>
    elem.value.length >3)`. Let''s talk about the user''s expectation at this point.
    If a user enters keys in an input control, they most likely expect a request to
    be made when they are done typing. A user defines being done as entering a few
    characters and also that they should be able to remove characters if they were
    mistyped. So, therefore, we can assume the following input sequence:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的工作方式如下：每次我们按下键，它都会生成一个事件。然而，我们有一个`.filter()`操作符，它确保只有当至少输入了四个键时才会生成事件，`filter(key
    => elem.value.length >3)`。让我们谈谈此时用户的期望。如果一个用户在一个输入控件中输入键，他们最可能期望在完成输入时发起一个请求。用户定义完成输入为输入一些字符，并且如果输入错误，他们应该能够删除字符。因此，我们可以假设以下输入序列：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point, they have entered characters and, within a reasonable amount
    of time, edited their answer. The user expects to receive an answer based on `abcd`.
    Using the `flatMap()` operator, however, means the user will get two answers back
    because, in reality, they typed `abcde` and `abcd`. Imagine we get a results list
    based on these two inputs; it would most likely be two lists that looked somewhat
    different. The response based on our code would look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，他们已经输入了字符，并在合理的时间内编辑了他们的答案。用户期望根据`abcd`得到一个答案。然而，使用`flatMap()`操作符意味着用户将得到两个答案，因为在现实中，他们输入了`abcde`和`abcd`。想象一下，如果我们根据这两个输入得到一个结果列表；它很可能是两个看起来有些不同的列表。基于我们代码的响应将看起来像这样：
- en: '![](img/28c01006-1de6-4bc6-9a3a-4dde658279ac.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/28c01006-1de6-4bc6-9a3a-4dde658279ac.png)'
- en: 'Our code most likely would be able to handle the situation described by rerendering
    the results list as soon as a new response arrives. There are two problems with
    this though: firstly, we do an unnecessary network request for `abcde`, and secondly,
    if the backend is fast enough in responding, we will see a flickering in the UI
    as the result list is rendered once and then, shortly after, is rendered again,
    based on the second response. This is not good, and we want to have a situation
    where the first request will be abandoned if we keep on typing. This is where
    the `switchMap()` operator comes in. It does exactly that. Let''s therefore alter
    the preceding code to the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码很可能能够通过在收到新响应时立即重新渲染结果列表来处理所描述的情况。然而，这里有两个问题：首先，我们对`abcde`进行了不必要的网络请求，其次，如果后端响应足够快，我们将在结果列表渲染一次后，基于第二个响应再次渲染，从而在UI中看到闪烁。这不是一个好的情况，我们希望有一个情况，即如果我们继续输入，第一个请求将被放弃。这就是`switchMap()`操作符发挥作用的地方。它确实做到了这一点。因此，让我们将前面的代码更改为以下代码：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this code, we simply switched our `flatMap()` to a `switchMap()`. When we
    now execute the code in the exact same way, that is, the user firstly typing `12345`
    and shortly altering that to `1234`, the end result is:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们只是将`flatMap()`切换为`switchMap()`。当我们现在以完全相同的方式执行代码时，即用户首先输入`12345`，然后很快将其更改为`1234`，最终结果是：
- en: '![](img/4903a7a2-7634-4617-9a3a-a56b3c16ad4a.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4903a7a2-7634-4617-9a3a-a56b3c16ad4a.png)'
- en: As we can see, we get one request only. The reason for this is that the previous
    event is aborted when a new event happens—`switchMap()` is doing its magic. The
    user is happy and we are happy.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们只得到一个请求。这是因为当发生新事件时，前一个事件会被中止——`switchMap()` 正在施展它的魔法。用户很高兴，我们也很高兴。
- en: AJAX
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AJAX
- en: 'We have already touched upon the topic of making AJAX requests. There are many
    ways to make AJAX requests; the two most common approaches are:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经触及了制作 AJAX 请求的主题。有许多方法可以制作 AJAX 请求；最常见的方法有两种：
- en: Using the fetch API; the fetch API is a web standard and is thus built into
    most browsers
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 fetch API；fetch API 是一个网络标准，因此内置在大多数浏览器中
- en: Using the `ajax()` method, nowadays built into the RxJS library; it used to
    exist in a library called Rx.Dom
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置在 RxJS 库中的 `ajax()` 方法；它曾经存在于一个名为 Rx.Dom 的库中
- en: fetch()
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fetch()
- en: 'The `fetch()` API is a web standard. You can find the official documentation
    at the following link: [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
    The `fetch()` API is `Promise`-based, which means we need to convert it to an
    `Observable` before use. The API exposes a `fetch()` method, which takes a mandatory
    URL parameter as the first argument, with the second argument being an optional
    object that allows you to control which body to send, if any, which HTTP verb
    to use, and so on.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` API 是一个网络标准。您可以在以下链接中找到官方文档：[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)。`fetch()`
    API 是基于 `Promise` 的，这意味着在使用之前我们需要将其转换为 `Observable`。该 API 暴露了一个 `fetch()` 方法，它以强制性的
    URL 参数作为第一个参数，第二个参数是一个可选对象，允许您控制发送哪个正文（如果有），使用哪个 HTTP 动词，等等。'
- en: 'We have already mentioned how to best deal with it in the context of RxJS.
    It is worth repeating though. It is not as simple as just taking our fetch and
    sticking it into the `from()` operator though. Let''s write some code and see
    why:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 RxJS 的上下文中提到了如何最好地处理它。尽管如此，这仍然值得重复。但这并不像只是将我们的 fetch 操作符放入 `from()` 操作符中那么简单。让我们写一些代码来看看原因：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We get our data right? Sorry, no, we get a `Response` object back. But that''s
    easy, just call a `json()` method in the `map()` operator and surely then we have
    our data? Again, sorry no, the `json()` method returns a `Promise` when you type
    the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了我们的数据吗？抱歉，没有，我们得到了一个 `Response` 对象。但这很容易，只需在 `map()` 操作符中调用一个 `json()`
    方法，然后我们肯定就有数据了？再次抱歉，没有，当你输入以下内容时，`json()` 方法返回一个 `Promise`：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have already shown a possible solution to this in the previous section,
    and that is the following construct:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一节中展示了可能的解决方案，如下所示：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What we did in this code was to simply take care of digging out our data before
    handing it over to the `from()` operator. It doesn''t feel quite RxJS to play
    around with Promises. There is a more stream-based approach you can take; we were
    almost there before, we just needed to make a minor adjustment:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们所做的是在将数据交给 `from()` 操作符之前简单地处理我们的数据。与 RxJS 不太一样，感觉与 Promise 玩耍。你可以采取一个更基于流的方案；我们几乎做到了，我们只需要做一些小的调整：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And there it is: our `fetch()` call is now providing us data like a stream.
    So what did we do? Well, we changed our `map()` call to a `flatMap()` call. The
    reason for that was that when we called `r.json()`, we got a `Promise`. We fixed
    that by wrapping it in a `from()` call, `Rx.Observable.from(r.json())`. That would
    make the stream emit a `PromiseObservable` unless we changed from `map()` to `flatMap()`.
    As we learned in the previous section, if we risk creating a stream within a stream,
    we need `flatMap()` to come to our rescue, which it did.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样：我们的 `fetch()` 调用现在像流一样提供数据。那么我们做了什么？嗯，我们将 `map()` 调用更改为 `flatMap()` 调用。这样做的原因是当我们调用
    `r.json()` 时，我们得到了一个 `Promise`。我们通过将其包裹在 `from()` 调用中，`Rx.Observable.from(r.json())`
    来解决这个问题。如果不将 `map()` 更改为 `flatMap()`，那么流将发出一个 `PromiseObservable`。正如我们在上一节中学到的，如果我们冒着在流中创建流的危险，我们需要
    `flatMap()` 来拯救我们，它确实做到了。
- en: ajax() operator
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ajax() 操作符
- en: 'Unlike the `fetch()` API, which is `Promise`-based, the `ajax()` method is
    actually `Observable`-based, which makes our job a little easier. Using it is
    quite straightforward, like so:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于 `Promise` 的 `fetch()` API 不同，`ajax()` 方法实际上是基于 `Observable` 的，这使得我们的工作变得稍微容易一些。使用它非常直接，如下所示：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, the preceding code calls the `ajax()` operator with a URL as
    an argument. The second thing worthy of mentioning is the call to the `map()`
    operator, which digs out our data from the `response` property. Because it is
    an `Observable`, we just have to subscribe to it as usual by calling the `subscribe()`
    method and providing it with a listener function as an argument.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前面的代码使用URL作为参数调用`ajax()`操作符。值得提及的第二件事是调用`map()`操作符，它从`response`属性中提取我们的数据。因为它是一个`Observable`，我们只需像往常一样通过调用`subscribe()`方法并给它提供一个监听函数作为参数来订阅它。
- en: 'This covers a simple case when you want to fetch data using the HTTP verb `GET`.
    Fortunately for us, it is quite easy to create, update, or delete by using an
    overloaded version of the `ajax()` operator which takes an `AjaxRequest` object
    instance which has the following fields:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了当你想使用HTTP动词`GET`获取数据时的简单情况。幸运的是，对于我们的需求来说，通过使用重载版本的`ajax()`操作符来创建、更新或删除数据相当容易，这个操作符接受一个`AjaxRequest`对象实例，它具有以下字段：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we can see from this object specification, all the fields are optional and
    there are also quite a few things we can configure with our request, such as `headers`,
    `timeout`, `user`, `crossDomain`, and so on; pretty much what we would expect
    from a nice AJAX wrapping functionality. Except for the overload of the `ajax()`
    operator, a few shorthand options also exist:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个对象规范中我们可以看出，所有字段都是可选的，我们还可以通过我们的请求配置相当多的事情，例如`headers`、`timeout`、`user`、`crossDomain`等等；基本上这是我们期望从良好的AJAX包装功能中得到的。除了`ajax()`操作符的重载之外，还存在一些简写选项：
- en: '`get()`: Fetches data using the `GET` verb'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`: 使用`GET`动词获取数据'
- en: '`put()`: Updates data using the `PUT` verb'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put()`: 使用`PUT`动词更新数据'
- en: '`post()`: Creates data using the `POST` verb'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post()`: 使用`POST`动词创建数据'
- en: '`patch()`: The idea with using the `PATCH` verb is to update a partial resource'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patch()`: 使用`PATCH`动词的目的是更新部分资源'
- en: '`delete()`: Removes data using the `DELETE` verb'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete()`: 使用`DELETE`动词删除数据'
- en: '`getJSON()`: Fetches data using the `GET` verb and sets the response type to
    `application/json`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getJSON()`: 使用`GET`动词获取数据，并将响应类型设置为`application/json`'
- en: Cascading calls
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 级联调用
- en: So far, we have covered the two main ways you will use AJAX to send or receive
    data. When it comes to receiving data, it's usually not as simple as fetching
    the data and rendering it. In fact, you will most likely have a dependency on
    when you can fetch which data. A typical example of this is needing to perform
    a login call before you can fetch the remaining data. In some cases, it might
    be that you need to first log in, then fetch the data of the logged in user, and
    once you have that you can fetch messages, orders, or whichever kind of data you
    need that might be specific to a certain user. This whole phenomenon of fetching
    data in this way is called cascading calls.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了你将使用AJAX发送或接收数据的两种主要方式。当涉及到接收数据时，通常并不像获取数据并渲染它那样简单。实际上，你很可能依赖于何时可以获取哪些数据。一个典型的例子是在获取剩余数据之前需要执行登录调用。在某些情况下，可能需要首先登录，然后获取登录用户的资料，一旦有了这些资料，就可以获取消息、订单或任何可能特定于某个用户的数据。这种以这种方式获取数据的现象被称为级联调用。
- en: Let's have a look at how we use cascading calls with Promises and gradually
    learn how to do the same with RxJS. We are taking this little detour as we assume
    that most of you reading this book are familiar with Promises.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用承诺（Promises）进行级联调用，并逐步学习如何使用RxJS做同样的事情。我们之所以这样做，是因为我们假设大多数阅读这本书的人对承诺（Promises）都很熟悉。
- en: 'Let''s look at the dependent case we first mentioned, where we need to perform
    the following steps in this order:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们最初提到的依赖情况，我们需要按以下顺序执行以下步骤：
- en: The user first logs in to the system
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户首先登录到系统中
- en: Then we fetch information about the user
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们获取用户的资料
- en: Then we fetch information about the user's orders
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们获取用户订单的信息
- en: 'Using promises, it would look something like this in code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺（promises），代码中可能看起来是这样的：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code describes how we first log in to the system, using the `login()`
    method, and obtain a token. We use this token in any future calls to ensure we
    make authenticated calls. We also see how we perform the `getUser()` call and
    obtain a user instance. We use that same user instance to perform our last call,
    `getOrders()`, whereby the user ID is used as a routing parameter: `` `/orders/user/${user.id}`
    ``.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码描述了我们首先使用`login()`方法登录系统，并获取一个令牌。我们使用这个令牌在未来的任何调用中确保我们进行认证调用。我们还看到我们如何执行`getUser()`调用并获取一个用户实例。我们使用相同的用户实例来执行我们的最后一个调用`getOrders()`，其中用户ID用作路由参数：``
    `/orders/user/${user.id}` ``。
- en: 'We have shown how to perform cascading calls using promises; we did this to
    establish a common ground for the problem we are trying to solve. The RxJS approach
    is very similar: we have shown that the `ajax()` operator exists and makes our
    lives easier when dealing with AJAX calls. To achieve the cascading calls effect
    with RxJS, we simply need to use the `switchMap()` operator. This will lead to
    our code looking like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何使用承诺（promises）来执行级联调用；我们这样做是为了为我们要解决的问题建立一个共同的基础。RxJS的方法非常相似：我们已经展示了`ajax()`操作符的存在，并且当处理AJAX调用时，它使我们的生活变得更简单。为了使用RxJS实现级联调用效果，我们只需简单地使用`switchMap()`操作符。这将使我们的代码看起来像这样：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We have highlighted the parts that need changing in the preceding code. In
    short, the changes are:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指出了前面代码中需要更改的部分。简而言之，更改如下：
- en: '`fetch()` is replaced by the `ajax()` operator'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch()`被`ajax()`操作符替换'
- en: We call `.map(r => r.response)` instead of `.then(r => r.json())`
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用`.map(r => r.response)`而不是`.then(r => r.json())`
- en: We do `.switchMap()` calls for each cascading call instead of `.then(getOrders)`
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对每个级联调用执行`.switchMap()`调用，而不是`.then(getOrders)`
- en: 'There is one more interesting aspect that we need to cover, namely that of
    parallel calls. When we fetched the user and the order, we waited for a previous
    call to fully complete before we initiated the next call. In a lot of cases, this
    might not be strictly necessary. Imagine that we have a similar case to the previous
    one, but there is a lot of interesting information surrounding the user that we
    want to fetch. Instead of just fetching orders, the user might have a friends
    collection or a collection of messages. The precondition for fetching that data
    is only that we fetched the user, so we know which collection of friends we should
    query for and which collection of messages we need. In the world of promises,
    we would use the `Promise.all()` construct to achieve parallelization. With that
    in mind, we update our `Promise` code to look like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个有趣的方面需要我们探讨，那就是并行调用。当我们获取用户和订单时，我们在发起下一个调用之前等待前一个调用完全完成。在很多情况下，这可能并不是严格必要的。想象一下，我们有一个与之前类似的情况，但围绕用户有很多有趣的信息我们需要获取。除了获取订单之外，用户可能还有一个朋友集合或消息集合。获取这些数据的前提条件只是我们已经获取了用户，因此我们知道应该查询哪个朋友集合以及需要查询哪个消息集合。在承诺的世界中，我们会使用`Promise.all()`构造来实现并行化。考虑到这一点，我们更新我们的`Promise`代码，使其看起来像这样：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see from the preceding code, we introduce the new `getUsersData()`
    method, which fetches orders, messages, and friends collections in parallel, making
    our app responsive sooner, as the data will arrive sooner than if we just fetched
    it one after another.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，我们引入了新的`getUsersData()`方法，该方法并行获取订单、消息和朋友集合，使我们的应用更快地响应，因为数据将比逐个获取更快地到达。
- en: 'We can easily achieve the same thing with RxJS by introducing the `forkJoin()`
    operator. It takes a list of streams and fetches everything in parallel. We therefore
    update our RxJS code to look like the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过引入`forkJoin()`操作符轻松地使用RxJS实现相同的效果。它接受一系列流，并并行获取所有内容。因此，我们更新我们的RxJS代码，使其看起来如下：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A deeper look
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨
- en: 'So far, we have had a look at some operators that will let you create streams
    or change streams with the `map()` and `filter()` operators, we have learned how
    to manage different AJAX scenarios, and so on. The basics are there, but we haven''t
    really approached the topic of operators in a structured way. What do we mean
    by that? Well, operators can be thought of as belonging to different categories.
    The number of operators at our disposal is a staggering 60 plus. It''s going to
    take us time to learn all that, if we ever do. Here is the thing though: we just
    need to know which different types of operators exist so that we can apply them
    where appropriate. This reduces our cognitive load and our memory. Once we know
    which categories we have, we just have to drill down, and most likely we will
    end up knowing 10-15 operators in total and the rest we can just look up when
    we need them.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了一些可以让你使用`map()`和`filter()`操作符创建或更改流的操作符，我们学习了如何管理不同的AJAX场景，等等。基础是有的，但我们还没有以结构化的方式真正接近操作符的话题。我们这是什么意思呢？嗯，操作符可以被认为是属于不同的类别。我们可用的操作符数量令人震惊，有60多个。如果我们真的要学习所有这些，这将需要时间。不过，这里的关键是：我们只需要知道存在哪些不同类型的操作符，这样我们就可以在适当的地方应用它们。这减少了我们的认知负担和记忆。一旦我们知道有哪些类别，我们只需要深入挖掘，很可能会最终知道总共10-15个操作符，其余的我们可以在需要时查阅。
- en: 'Currently, we have the following categories:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有以下类别：
- en: '**Creation operators**: These operators help us create streams in the first
    place. Almost anything can be converted into a stream with the help of these operators.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建操作符**：这些操作符帮助我们首先创建流。几乎任何东西都可以通过这些操作符转换为流。'
- en: '**Combination operators**: These operators help us combine values as well as
    streams.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合操作符**：这些操作符帮助我们结合值以及流。'
- en: '**Mathematical operators**: These operators perform mathematical evaluations
    on the values being emitted.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数学操作符**：这些操作符对正在发射的值执行数学评估。'
- en: '**Time-based operators**: These operators change at which speed values are
    emitted.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于时间的操作符**：这些操作符改变值发射的速度。'
- en: '**Grouping operators**: The idea with these operators is to operate on a group
    of values rather than individual ones.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分组操作符**：这些操作符的思路是对一组值而不是单个值进行操作。'
- en: Creation operators
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建操作符
- en: 'We use creation operators to create the streams themselves, because let''s
    face it: what we need to turn into a stream isn''t always going to be a stream,
    but by making it into a stream, it will have to play nicely with other streams
    and, best of all, will get to leverage the full power of using operators.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用创建操作符来创建流本身，因为坦白说：我们需要转换为流的东西并不总是流，但通过将其转换为流，它将必须与其他流很好地协同工作，最好的是，将能够利用使用操作符的全部力量。
- en: So, what do these other non-streams consist of? Well, it could be anything asynchronous
    or synchronous. The important thing is that it is data that needs to be emitted
    at some point. Therefore, a range of creation operators exist. In the coming subsections,
    we will present a subset of all those that exist, enough for you to realize the
    power of turning anything into a stream.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些其他非流由什么组成呢？嗯，可以是任何异步或同步的内容。重要的是，这些是需要在某一点发射的数据。因此，存在一系列创建操作符。在接下来的小节中，我们将展示所有这些操作符中的一部分，足够你认识到将任何事物转换为流的力量。
- en: of() operator
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: of()操作符
- en: 'We have already had the chance to use this operator a few times. It takes an
    unknown number of comma-separated arguments, which can be integers, strings, or
    objects. This is an operator you want to use if you just want to emit a limited
    set of values. To use it, simply type:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有机会使用这个操作符几次了。它接受未知数量的以逗号分隔的参数，可以是整数、字符串或对象。如果你只想发射一组有限的值，这是一个你想要使用的操作符。要使用它，只需输入：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As can be seen from the code, it really doesn't matter what we place in our
    `of()` operator, it is able to emit it anyway.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中可以看出，我们在`of()`操作符中放置什么内容其实并不重要，它无论如何都能发射出来。
- en: from() operator
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: from()操作符
- en: 'This operator can take arrays or a `Promise` as input and turn them into a
    stream. To use it, simply call it like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符可以接受数组或`Promise`作为输入，并将它们转换为流。要使用它，只需像这样调用：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This saves us a lot of headache by not having to deal with different types of
    asynchronous calls.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以节省我们很多麻烦，不必处理不同类型的异步调用。
- en: range() operator
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: range()操作符
- en: 'This operator lets you specify a range, a number to start from and a number
    to end on. This is a nice shorthand that quickly lets you create a stream with
    a range of numbers. To use it, simply type:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符允许你指定一个范围，一个起始数字和一个结束数字。这是一个很好的简写，可以快速创建一个具有数字范围的流。要使用它，只需输入：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: fromEvent() operator
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fromEvent() 操作符
- en: Now it gets really interesting. The `fromEvent()` operator allows us to mix
    a UI event such as a `click` or a `scroll` event and turn it into a stream. So
    far, we have operated under the assumption that asynchronous calls is something
    that only has to do with AJAX calls. This is far from true. The fact that we can
    mix UI events with any type of asynchronous calls creates a really interesting
    situation that allows us to compose really powerful, expressive code. We will
    touch on this topic further in the coming section, *Thinking in streams*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事情变得非常有趣。`fromEvent()`操作符允许我们将UI事件（如`click`或`scroll`事件）混合起来，并将其转换成一个流。到目前为止，我们一直假设异步调用只与AJAX调用有关。这远非事实。我们可以将UI事件与任何类型的异步调用混合，这创造了一个非常有趣的情况，使我们能够编写非常强大、表达力丰富的代码。我们将在下一节中进一步探讨这个话题，*在流中思考*。
- en: 'To use this operator, you need to provide it with two arguments: a DOM element
    and the name of an event, like so:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个操作符，你需要给它提供两个参数：一个DOM元素和事件名称，如下所示：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Combination
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: Combination operators are about combining values from different streams. We
    have a few operators at our disposal that can help us out. This kind of operator
    makes sense when we, for some reason, don't have all the data in one place but
    need to acquire it from more than one place. Combining data structures from different
    sources could be tedious and error-prone work if it weren't for the powerful operators
    we are about to describe.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 组合操作符是关于组合不同流中的值。我们有几个操作符可以帮助我们。当我们需要从多个地方而不是一个地方获取数据时，这种类型的操作符是有意义的。如果没有我们即将描述的强大操作符，从不同来源组合数据结构可能会很繁琐且容易出错。
- en: merge() operator
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: merge() 操作符
- en: 'The `merge()` operator takes data from different streams and combines it. Here
    is the thing though: these streams can be of any kind as long as they are of type
    `Observable`. This means we can combine data from a timing operation, a promise,
    static data from an `of()` operator, and so on. What merging does is to interleave
    the emitted data. This means that it will emit from both streams at the same time
    in the following example. Using the operator comes in two flavors, as a static
    method but also as an instance method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge()`操作符从不同的流中获取数据并将其合并。然而，这些流可以是任何类型，只要它们是`Observable`类型。这意味着我们可以将定时操作、承诺、`of()`操作符的静态数据等的数据组合起来。合并所做的就是交错发出的数据。这意味着在以下示例中，它将同时从两个流中发出。使用这个操作符有两种方式，作为静态方法，也可以作为实例方法：'
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The takeaway here is that if you just need to combine one stream with another,
    then use the instance method version of this operator, but if you have several
    streams, then use the static version. Furthermore, the order in which the streams
    are specified matters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的要点是，如果你只需要将一个流与另一个流组合，那么使用这个操作符的实例方法版本，但如果你有多个流，那么使用静态版本。此外，指定流的顺序也很重要。
- en: combineLatest()
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: combineLatest()
- en: 'Imagine you have a situation where you have set up connections with several
    endpoints that serve you with data. What you care about is the latest data that
    was emitted from each endpoint. You might be in a situation where one or several
    endpoints stop sending data after a while and you want to know what the last thing
    that happened was. In this situation, we want the ability to combine all the latest
    values from all of the involved endpoints. That''s where the `combineLatest()`
    operator comes in. You use it in the following way:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你与几个提供数据的端点建立了连接。你所关心的是每个端点发出的最新数据。你可能处于这样的情况：一段时间后，一个或多个端点停止发送数据，你想要知道最后发生了什么。在这种情况下，我们希望能够结合所有相关端点的最新值。这就是`combineLatest()`操作符发挥作用的地方。你可以按照以下方式使用它：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What we can see here is that `firstStream$` stops emitting values after a while
    thanks to the `take()` operator, which limits the number of items. However, the
    `combineLatest()` operator ensures we are still given the very last value `firstStream$`
    emitted.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，由于`take()`操作符限制了项目数量，`firstStream$`在一段时间后停止发出值。然而，`combineLatest()`操作符确保我们仍然得到了`firstStream$`发出的最后一个值。
- en: zip()
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: zip()
- en: 'The point of this operator is to stitch as many values together as possible.
    We may be dealing with continuous streams, but also with streams that have a limit
    to the number of values they emit. You use this operator in the following way:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符的目的是尽可能多地拼接值。我们可能正在处理连续的流，也可能在处理有值数限制的流。你使用这个运算符的方式如下：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we can see, here, we stitch values together vertically, and by the least
    common denominator, `thirdStream$` is the shortest, calculating the number of
    emitted values. This means we will take values from left to right and zip them
    together. As `thirdStream$` only has two values, we end up with only two emits.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在这里，我们垂直拼接值，并通过最小公倍数，`thirdStream$` 是最短的，计算发出的值的数量。这意味着我们将从左到右取值并将它们压缩在一起。由于
    `thirdStream$` 只有两个值，我们最终只发出两个值。
- en: concat()
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: concat()
- en: 'At first look, the `concat()` operator looks like another `merge()` operator,
    but this is not entirely true. The difference is that a `concat()` waits for other
    streams to be completed first before emitting a stream from the next stream in
    order. How you arrange your stream in your call to `concat()` matters. The operator
    is used in the following way:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，`concat()` 运算符看起来像另一个 `merge()` 运算符，但这并不完全正确。区别在于 `concat()` 会等待其他流完成后再从下一个流中发出流。你在调用
    `concat()` 时的流排列方式很重要。运算符的使用方式如下：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Mathematical
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学
- en: Mathematical operators are simply operators that carry out mathematical operations
    on values, such as finding the largest or smallest value, summarizing all values,
    and so on.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 数学运算符是执行数学运算的运算符，例如找到最大或最小值，汇总所有值等。
- en: max
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: max
- en: 'The `max()` operator finds the largest value. This comes in two flavors: we
    either just call the `max()` operator with no arguments, or we give it a `compare`
    function. The `compare` function then decides whether something is larger than,
    smaller than, or equal to an emitted value. Let''s have a look at the two different
    versions:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()` 运算符用于找到最大值。它有两种形式：我们或者不带参数直接调用 `max()` 运算符，或者提供一个 `compare` 函数。然后 `compare`
    函数决定某个值是否大于、小于或等于一个发出的值。让我们看看两种不同的版本：'
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can see in the preceding code that we get one result back and it is the largest
    one.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的代码中看到，我们得到一个结果，并且它是最大的。
- en: min
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: min
- en: 'The `min()` operator is pretty much the opposite of the `max()` operator; it
    comes in two flavors: with parameter and without parameter. Its task is to find
    the smallest value. To use it, type:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`min()` 运算符基本上是 `max()` 运算符的相反；它有两种形式：带参数和不带参数。它的任务是找到最小值。要使用它，请输入：'
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: sum
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sum
- en: 'There used to be an operator called `sum()`, but it hasn''t existed for several
    versions. What there is instead is `.reduce()`. With the `reduce()` operator,
    we can easily achieve the same thing. The following is how you would write a `sum()`
    operator using `reduce()`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一个名为 `sum()` 的运算符，但它在几个版本中已经不存在了。取而代之的是 `.reduce()`。使用 `reduce()` 运算符，我们可以轻松地实现相同的功能。以下是如何使用
    `reduce()` 编写 `sum()` 运算符的示例：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'What this does is to loop through all the emitted values and sum up the results.
    So, in essence, it sums up everything. Of course, this kind of operator can not
    only be applied to numbers, but to objects as well. The difference lies in how
    you carry out the `reduce()` operation. The following example covers such a scenario:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符的作用是遍历所有发出的值并将结果相加。所以，本质上，它汇总了所有内容。当然，这种运算符不仅可以应用于数字，也可以应用于对象。区别在于你如何执行
    `reduce()` 操作。以下示例涵盖了这种情况：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see from the preceding code, the `reduce()` operator ensures that
    all the object's properties get merged together into one object.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`reduce()` 运算符确保所有对象的属性都合并到一个对象中。
- en: Time
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间
- en: Time is a very important concept when talking about streams. Imagine you have
    multiple streams that have different bandwidths, or one stream is just faster
    than the other, or you have a scenario where you want to retry an AJAX call within
    a certain time interval. In all of these situations, we need to control how fast
    the data is being emitted, and time plays an important role in all these scenarios.
    At our disposal, we have a ton of operators that, like a magician, enable us to
    craft and control our values as we see fit.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论流时，时间是一个非常重要的概念。想象一下，你有多个具有不同带宽的流，或者一个流比另一个流快，或者你有一个在特定时间间隔内重试 AJAX 调用的场景。在这些所有情况下，我们需要控制数据发出的速度，时间在这些场景中都起着重要作用。在我们手中，有一大堆运算符，就像魔术师一样，使我们能够根据需要构建和控制我们的值。
- en: interval() operator
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`interval()`操作符'
- en: 'In JavaScript, there is a `setInterval()` function that enables you to execute
    code at regular intervals, up until the point that you choose to stop it. RxJS
    has an operator that behaves just like that, the `interval()` operator. It takes
    one parameter: normally, the number of milliseconds between emitted values. You
    use it in the following way:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，有一个`setInterval()`函数，允许你以固定的时间间隔执行代码，直到你选择停止它。RxJS有一个与此行为相同的操作符，即`interval()`操作符。它接受一个参数：通常是发出值之间的毫秒数。你可以按以下方式使用它：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A word of caution is that this operator will continue emitting until you stop
    it. The best way to stop it is to combine it with a `take()` operator. A `take()`
    operator takes a parameter that specifies how many emitted values it wants before
    stopping. The updated code looks like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这个操作符会一直发出，直到你停止它。停止它的最佳方法是将其与一个`take()`操作符结合。`take()`操作符接受一个参数，指定在停止之前它想要发出多少个值。更新后的代码如下：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: timer() operator
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`timer()`操作符'
- en: 'The `timer()` operator has the job of emitting values after a certain amount
    of time. It comes in two flavors: you either emit just one value after a number
    of milliseconds, or you keep on emitting values with a certain amount of delay
    between them. Let''s look at the two different flavors available:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`timer()`操作符的任务是在一定时间后发出值。它有两种风味：你可以在一定毫秒数后发出一个值，或者你可以在它们之间保持一定的延迟继续发出值。让我们看看可用的两种不同风味：'
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: delay() operator
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`delay()`操作符'
- en: 'The `delay()` operator delays all the values being emitted and is used in the
    following way:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`delay()`操作符延迟所有发出值，并按以下方式使用：'
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: sampleTime() operator
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`sampleTime()`操作符'
- en: 'The `sampleTime()` operator is used to only emit values after the sample period
    has passed. A good use case for this is when you want to have a *cooldown* functionality.
    Imagine you have users that press a Save button way too often. It might be that
    saving takes a few seconds to complete. A way to approach this is to disable the
    Save button while saving. Another valid approach is to simply ignore any presses
    of the button until the operation has had the chance to complete. The following
    code does just that:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampleTime()`操作符用于在样本周期过后才发出值。一个很好的用例是当你想要有一个*冷却*功能。想象一下，你有用户频繁地按保存按钮。保存可能需要几秒钟才能完成。一种方法是保存时禁用保存按钮。另一种有效的方法是简单地忽略按钮的任何点击，直到操作有机会完成。以下代码正是这样做的：'
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: debounceTime() operator
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`debounceTime()`操作符'
- en: 'The `sampleTime()` operator was able to ignore the user for a certain period
    of time, but the `debounceTime()` operator takes a different approach. Debounce
    as a concept means that we wait for things to calm down before emitting a value.
    Imagine an input element that the user types into. The user will stop typing eventually.
    We want to make sure the user has actually stopped, so we wait for a while before
    we actually do something. This is what the `debounceTime()` operator does for
    us. The following example shows how we can listen to the user typing into an input
    element, wait for the user to stop typing, and lastly, perform an AJAX call:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampleTime()`操作符能够忽略用户一段时间，但`debounceTime()`操作符采取了不同的方法。防抖作为一个概念意味着我们在发出值之前等待事情平静下来。想象一下用户输入的输入元素。用户最终会停止输入。我们想确保用户确实已经停止了，所以我们等待一段时间后才真正采取行动。这正是`debounceTime()`操作符为我们做的事情。以下示例展示了我们如何监听用户在输入元素中输入，等待用户停止输入，最后执行一个AJAX调用：'
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When the user then types a number in the text box, the keyup event will be triggered
    after 2 seconds of inactivity. After that, an AJAX call will be carried out using
    our text box input.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在文本框中输入一个数字时，在2秒的无操作后，keyup事件将被触发。之后，将使用我们的文本框输入执行一个AJAX调用。
- en: Grouping
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组
- en: Grouping operators allow us to operate on a group of collected events rather
    than one emitted event at a time.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 分组操作符允许我们对一组收集的事件进行操作，而不是一次只对一个发出的事件进行操作。
- en: buffer() operator
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`buffer()`操作符'
- en: 'The idea with the `buffer()` operator is that we can collect a bunch of events
    without them being emitted straight away. The operator itself takes an argument,
    an `Observable` that defines when we should stop collecting events. At that point
    in time, we can choose what to do with those events. Here is how you can use this
    operator:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer()`操作符的想法是我们可以收集大量事件，而无需立即发出。该操作符本身接受一个参数，一个`Observable`，它定义了何时停止收集事件。在那个时刻，我们可以选择对这些事件做什么。以下是你可以使用此操作符的方法：'
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What this does is to collect events until there has been 2 seconds of inactivity.
    At that point, we release all the key events we have buffered up. When we release
    all those events, we can, for example, send them somewhere via AJAX. This is a
    typical scenario in a chat application. Using the preceding code, we can always
    send the latest character that has been typed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这所做的是收集事件，直到有2秒的空闲时间。在那个时刻，我们释放所有已经缓冲起来的关键事件。当我们释放所有这些事件时，例如，我们可以通过AJAX将它们发送到某个地方。这在聊天应用中是一个典型的场景。使用前面的代码，我们总是可以发送最新输入的字符。
- en: bufferTime() operator
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: bufferTime()运算符
- en: A very similar operator to `buffer()` is `bufferTime()`. This one lets us specify
    how long we would like to buffer events for. It is a bit less flexible than `buffer()`,
    but can still be quite useful.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与`buffer()`非常相似的运算符是`bufferTime()`。这个运算符允许我们指定我们希望缓冲事件多长时间。它比`buffer()`稍微灵活一些，但仍然非常有用。
- en: Thinking in streams
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流式思维
- en: 'So far, we have gone through a bunch of scenarios that have shown us which
    operators are at our disposal and how they can be chained. We have also seen how
    operators such as `flatMap()` and `switchMap()` can really change things as we
    move from one type of observable to another. So, which approach should you take
    when working with Observables? Obviously, we need to express an algorithm using
    operators, but where do we start? The first thing we need to do is to think of
    the start and the end. Which types of events do we want to capture and what should
    the end result look like? That already gives us a hint as to the number of transformations
    we need to carry out to get there. If we want to transform the data only, then
    we can probably make do with a `map()` operator and a `filter()` operator. If
    we want to transform from one `Observable` to the next, then we need a `flatMap()`
    or a `switchMap()`. Do we have a specific behavior, such as waiting for the user
    to stop typing? If so, then we need to look at `debounceTime()` or similar. It''s
    really the same as all problems: break it down, see which parts you have, divide,
    and conquer. Let''s try to break this down into a list of steps though:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经经历了一系列场景，这些场景展示了我们有哪些运算符可供使用，以及它们如何被串联起来。我们还看到了像`flatMap()`和`switchMap()`这样的运算符如何在我们从一种类型的可观察对象移动到另一种类型时真正改变事情。那么，当与可观察对象一起工作时，你应该采取哪种方法？显然，我们需要使用运算符来表示一个算法，但我们应该从哪里开始呢？我们首先需要做的是思考起点和终点。我们想要捕获哪些类型的事件，最终结果应该是什么样子？这已经给我们提供了关于我们需要执行多少转换才能达到那里的线索。如果我们只想转换数据，那么我们可能只需要一个`map()`运算符和一个`filter()`运算符。如果我们想从一个`Observable`转换到下一个，那么我们需要一个`flatMap()`或`switchMap()`。我们是否有特定的行为，比如等待用户停止输入？如果有，那么我们需要查看`debounceTime()`或类似的运算符。这实际上与所有问题是一样的：分解问题，看看你有哪些部分，分解并征服。不过，让我们尝试将其分解成一系列步骤：
- en: What are the inputs? UI events or something else?
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入是什么？UI事件或其他什么？
- en: What are the outputs? The end result?
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出是什么？最终结果是什么？
- en: Given the second bullet, which transformations do I need to get there?
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据第二个要点，我需要哪些转换才能达到目标？
- en: Do I deal with more than one stream?
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否需要处理多个流？
- en: Do I need to handle errors, and if so, how?
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否需要处理错误，如果是的话，应该如何处理？
- en: This has hopefully introduced you to how to think about streams. Remember, start
    small and work your way toward your goal.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这能让你了解如何思考流。记住，从小处着手，逐步实现你的目标。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We set out to learn more about basic operators. In doing so, we encountered
    the `map()` and `filter()` operators, which allowed us to control what was being
    emitted. Knowledge of the `do()` operator gave us a way to debug our streams.
    Furthermore, we learned about the existence of sandboxed environments, such as
    JS Bin and RxFiddle, and how they can help us to quickly get started with RxJS.
    AJAX was the next topic that we delved into, and we built an understanding of
    the different scenarios that might occur. Moving on deeper into RxJS, we looked
    at different operator categories. We barely scratched the surface on that one,
    but it offered us a way to approach how to learn which types of operators are
    in the library. Finally, we finished off this chapter by looking at how to change
    and develop our mindset to thinking about streams.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们着手学习更多关于基本操作符的知识。在这个过程中，我们遇到了`map()`和`filter()`操作符，它们使我们能够控制被发射的内容。对`do()`操作符的了解为我们提供了调试流的方法。此外，我们还了解了存在沙盒环境，例如JS
    Bin和RxFiddle，以及它们如何帮助我们快速开始使用RxJS。接下来，我们深入探讨了AJAX这一主题，并构建了对可能出现的不同场景的理解。在深入RxJS的过程中，我们研究了不同的操作符类别。我们对这一点只是略作了解，但它为我们提供了一种方法来了解库中哪些类型的操作符。最后，我们通过探讨如何改变和发展我们的思维方式来思考流，结束了这一章节。
- en: It is with all this acquired knowledge that we are now ready to venture into
    more advanced Rx topics in the next chapter. We know our basics, now the time
    has come to master them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正是凭借所有这些获得的知识，我们现在准备进入下一章更高级的Rx主题。我们掌握了基础知识，现在是时候精通它们了。
