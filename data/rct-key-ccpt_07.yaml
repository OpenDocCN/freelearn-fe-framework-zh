- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Portals and Refs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 门户和引用
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下几点：
- en: Use direct DOM element access to interact with elements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用直接DOM元素访问来与元素交互
- en: Expose the functions and data of your components to other components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的组件的函数和数据暴露给其他组件
- en: Control the position of rendered JSX elements in the DOM
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制渲染的JSX元素在DOM中的位置
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: React.js is all about building user interfaces, and, in the context of this
    book, it’s specifically about building web user interfaces.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: React.js是关于构建用户界面的，在本书的上下文中，它特别是指构建网络用户界面。
- en: 'Web user interfaces are ultimately all about the **Document Object Model**
    ( **DOM** ). You can use JavaScript to read or manipulate the DOM. This is what
    allows you to build interactive websites: you can add, remove, or edit DOM elements
    after a page has been loaded. This can be used to add or remove overlay windows
    or to read values entered into input fields.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 网络用户界面最终都是关于**文档对象模型**（**DOM**）。你可以使用JavaScript来读取或操作DOM。这就是允许你构建交互式网站的原因：你可以在页面加载后添加、删除或编辑DOM元素。这可以用来添加或删除覆盖窗口或读取输入字段中输入的值。
- en: This was discussed in *Chapter 1* , *React – What and Why* , and, as you learned
    there, React is used to simplify this process. Instead of manipulating the DOM
    or reading values from DOM elements manually, you can use React to describe the
    desired state. React then takes care of the steps needed to achieve this desired
    state.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这在*第一章*，*React – 什么是和为什么*中已经讨论过了，正如你所学的，React用于简化这个过程。你不需要手动操作DOM或从DOM元素中读取值，你可以使用React来描述所需的状态。然后React负责完成达到这个所需状态的步骤。
- en: However, there are scenarios and use cases wherein, despite using React, you
    still want to be able to directly reach out to specific DOM elements—for example,
    to read a value entered by a user into an input field, or if you’re not happy
    with the position of a newly inserted element in the DOM that was chosen by React.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些场景和用例中，尽管使用了React，你仍然希望能够直接访问特定的DOM元素——例如，读取用户输入到输入字段中的值，或者如果你对React选择的DOM中新插入元素的位置不满意。
- en: 'React provides certain functionalities that help you in exactly these kinds
    of situations: **Portals** and **Refs** . Even though directly manipulating the
    DOM will still not be a great idea, these tools, as you will learn throughout
    this chapter, can help with reading DOM element values or with changing the DOM
    structure without working against React.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: React提供了一些功能，可以帮助你在这些情况下：**门户**和**引用**。尽管直接操作DOM仍然不是一个好主意，但正如你将在本章中学习的，这些工具可以帮助读取DOM元素值或更改DOM结构，而不会与React作对。
- en: A World without Refs
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有引用的世界
- en: 'Consider the following example: you have a website that renders an input field,
    requesting a user’s email address. It could look something like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：你有一个网站，它渲染一个输入字段，请求用户的电子邮件地址。它可能看起来像这样：
- en: '![A white box with a rectangle and a purple rectangle  Description automatically
    generated](img/B31339_07_01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![一个带有矩形和紫色矩形的白色框，描述自动生成](img/B31339_07_01.png)'
- en: 'Figure 7.1: An example form with an email input field'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：一个带有电子邮件输入字段的示例表单
- en: 'The code for the component that’s responsible for rendering the form and handling
    the entered email address value might look like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 负责渲染表单并处理输入的电子邮件地址值的组件的代码可能看起来像这样：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, this example uses the `useState()` Hook, combined with the `change`
    event, to register keystrokes in the `email` input field and store the entered
    value.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个示例使用`useState()`钩子，结合`change`事件，来注册`email`输入字段中的按键，并存储输入的值。
- en: 'This code works fine, and there is nothing wrong with having this kind of code
    in your application. But adding the extra event listener and state, as well as
    adding the function to update the state whenever the `change` event is triggered,
    is quite a bit of boilerplate code for one simple task: getting the entered email
    address.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行良好，在你的应用程序中包含这种类型的代码也没有什么问题。但是，添加额外的事件监听器和状态，以及添加在`change`事件触发时更新状态的函数，对于这样一个简单的任务——获取输入的电子邮件地址——来说，是一段相当多的样板代码。
- en: The preceding code snippet does nothing else with the email address other than
    submit it. In other words, the only reason for using the `enteredEmail` state
    in the example is to read the entered value.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段除了提交电子邮件地址外，没有做其他任何事情。换句话说，在示例中使用`enteredEmail`状态的唯一原因就是读取输入的值。
- en: Even though the `enteredEmail` is only required in the `handleSubmitForm()`
    function, React will re-execute the `EmailForm` component function for every `enteredEmail`
    state updated, i.e., for every keystroke in the `<input>` field. This is also
    not ideal since it leads to lots of unnecessary code execution and hence potential
    performance issues.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`enteredEmail`只在`handleSubmitForm()`函数中需要，React也会为每次`enteredEmail`状态更新重新执行`EmailForm`组件函数，即每次在`<input>`字段中的按键输入。这也不是理想的，因为它会导致大量的不必要的代码执行，从而可能引起性能问题。
- en: 'In scenarios such as this, quite a bit of code (and maybe performance) could
    be saved if you fell back to some vanilla JavaScript logic:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果你退回到一些纯JavaScript逻辑，可以节省大量的代码（也许还有性能）：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These two lines of code (which could be merged into one line theoretically)
    allow you to get hold of a DOM element and read the currently stored value.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码（理论上可以合并为一行）允许你获取一个DOM元素并读取当前存储的值。
- en: The problem with this kind of code is that it does not use React. And if you’re
    building a React app, you should really stick to React when working with the DOM.
    Don’t start blending your own vanilla JavaScript code *that accesses the DOM*
    into the React code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码的问题在于它没有使用React。如果你正在构建React应用程序，你应该真正坚持使用React来处理DOM。不要开始将你自己的纯JavaScript代码（访问DOM的代码）混合到React代码中。
- en: This can lead to unintended behaviors or bugs, especially if you start manipulating
    the DOM. It could lead to bugs because React would not be aware of your changes
    in that case; the actual rendered UI would not be in sync with React’s assumed
    UI. Even if you’re just reading from the DOM, it’s a good habit to not even start
    merging vanilla JavaScript DOM access methods with your React code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致意外的行为或错误，特别是如果你开始操作DOM。它可能导致错误，因为在这种情况下React不会意识到你的更改；实际的渲染UI不会与React假设的UI同步。即使你只是从DOM中读取，也不应该将纯JavaScript
    DOM访问方法与你的React代码合并。
- en: 'To still allow you to get hold of DOM elements and read values, as shown above,
    React gives you a special concept that you can use: **Refs** .'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仍然允许你获取DOM元素并读取值，如上所示，React为你提供了一个特殊的概念，你可以使用：**引用**。
- en: Ref stands for reference, and it’s a feature that allows you to store references
    to values—for example, to DOM elements from inside a React component. The preceding
    vanilla JavaScript code would do the same (it also gives you access to a rendered
    element), but when using Refs, you can get access without mixing vanilla JavaScript
    code into your React code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Ref代表引用，这是一个允许你存储对值引用的功能——例如，从React组件内部对DOM元素的引用。前面的纯JavaScript代码会做同样的事情（它也让你能够访问渲染后的元素），但是当使用引用时，你可以在不将纯JavaScript代码混合到React代码中的情况下获取访问权限。
- en: Refs can be created using a special React Hook called the `useRef()` Hook.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一个特殊的React Hook，称为`useRef()` Hook来创建引用。
- en: 'This Hook can be executed to generate a `ref` object:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Hook可以被调用以生成一个`ref`对象：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This generated Ref object, `emailRef` in the preceding example, is initially
    set to null but can then be assigned to any JSX element. This assignment is done
    via a special prop (the `ref` prop) that is automatically supported by every JSX
    element:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，这个生成的引用对象`emailRef`最初被设置为null，但随后可以被分配给任何JSX元素。这个分配是通过一个特殊的属性（`ref`属性）完成的，这个属性被每个JSX元素自动支持：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Just like the `key` prop introduced in *Chapter 5* , *Rendering Lists and Conditional
    Content* , the `ref` prop is provided by React. The `ref` prop wants a Ref object,
    i.e., one that was created via `useRef()` .
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在*第五章*中引入的`key`属性一样，*渲染列表和条件内容*，`ref`属性是由React提供的。`ref`属性需要一个引用对象，即通过`useRef()`创建的。
- en: In this example, `useRef()` receives `null` as an initial value since it’s technically
    not yet assigned to the DOM element when the component function executes for the
    first time. It’s only after that initial component render cycle that the connection
    will be established. Therefore, after this first component function execution,
    the value stored in the Ref will be the underlying DOM object of the `<input>`
    element in this example.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`useRef()`接收`null`作为初始值，因为当组件函数第一次执行时，它技术上还没有分配给DOM元素。只有在最初的组件渲染周期之后，连接才会建立。因此，在第一次组件函数执行之后，存储在引用中的值将是这个例子中`<input>`元素的底层DOM对象。
- en: 'With that Ref object created and assigned, you can then use it to get access
    to the connected JSX element (to the `<input>` element in this example). There’s
    just one important thing to note: to get hold of the connected element, you must
    access a special `current` prop on the created Ref object. This is required because
    React stores the value assigned to the Ref object in a nested object, accessible
    via the `current` property, as shown here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并分配了那个 Ref 对象之后，你可以使用它来获取连接的 JSX 元素（在这个例子中是 `<input>` 元素）。需要注意的是：要获取连接的元素，你必须访问创建的
    Ref 对象上的特殊 `current` 属性。这是必需的，因为 React 将分配给 Ref 对象的值存储在一个嵌套对象中，可以通过 `current`
    属性访问，如下所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`emailRef.current` yields the underlying DOM object that was rendered for the
    connected JSX element. In this case, it therefore allows access to the input element
    DOM object. Since that DOM object has a `value` property, this `value` property
    can be accessed without issue.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`emailRef.current` 返回为连接的 JSX 元素渲染的底层 DOM 对象。在这种情况下，因此它允许访问输入元素 DOM 对象。由于该
    DOM 对象有一个 `value` 属性，因此可以无问题地访问这个 `value` 属性。'
- en: '**Note**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: For further information on this topic, see [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attributes)
    .
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题的更多信息，请参阅 [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attributes)
    。
- en: 'With this kind of code, you can read the value from the DOM element without
    having to use `useState()` and an event listener. The final component code therefore
    becomes quite a bit leaner:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种代码，你可以从 DOM 元素中读取值，而无需使用 `useState()` 和事件监听器。因此，最终的组件代码变得更加简洁：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Refs versus State
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Refs 与 State 的比较
- en: Since Refs can be used to get quick and easy access to DOM elements, the question
    that might come up is whether you should always use Refs instead of state.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Refs 可以用来快速轻松地访问 DOM 元素，因此可能会出现的问题是是否应该始终使用 Refs 而不是状态。
- en: The clear answer to this question is “no.”
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个问题的明确答案是“不。”
- en: Refs can be a very good alternative in use cases like the one shown above, when
    you need read access to an element. This is very often the case when dealing with
    user input. In general, Refs can replace state if you’re just accessing some value
    to read it when some function (a form submit handler function, for example) is
    executed. As soon as you need to change values and those changes must be reflected
    in the UI (for example, by rendering some conditional content), Refs are out of
    the game.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要读取元素的情况，如上面所示的使用案例中，Refs 可以是一个非常好的替代品。在处理用户输入时，这种情况通常很常见。一般来说，如果你只是访问一些值来在某个函数（例如表单提交处理函数）执行时读取它，Refs
    可以替代状态。一旦你需要更改值并且这些更改必须在 UI 中反映（例如，通过渲染一些条件内容），Refs 就不再适用。
- en: In the example above, if, besides getting the entered value, you’d also like
    to reset (i.e., clear) the email input after the form was submitted, you should
    use state again. While you could reset the input with the help of a Ref, you should
    not do that. You would start manipulating the DOM, and only React should do that—with
    its own, internal methods, based on the declarative code you provide to React.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，如果你除了获取输入的值之外，还希望在表单提交后重置（即清除）电子邮件输入，你应该再次使用状态。虽然你可以借助 Ref 重置输入，但你不应这样做。你会开始操作
    DOM，而只有 React 应该这样做——使用它自己的、内部的方法，基于你提供给 React 的声明性代码。
- en: 'You should avoid resetting the email input like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该避免像这样重置电子邮件输入：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Instead, you should reset it by using React’s state concept and by following
    the declarative approach embraced by React:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你应该通过使用 React 的状态概念和遵循 React 所采用的声明性方法来重置它：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Note**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: As a rule, you should simply try to avoid writing imperative code in React projects.
    Instead, tell React how the final UI should look and let React figure out how
    to get there.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个规则，你应该简单地尝试在 React 项目中避免编写命令式代码。相反，告诉 React 最终 UI 应该是什么样子，然后让 React 想出如何到达那里。
- en: Reading values via Refs is an acceptable exception, and manipulating DOM elements
    (with or without Refs, e.g., by directly selecting DOM nodes via `document.getElementById()`
    or similar) should be avoided. A rare exception is a scenario such as calling
    `focus()` on an input element DOM object because methods like `focus()` don’t
    typically cause any DOM changes that could break the React app.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Refs 读取值是一个可接受的例外，并且操作 DOM 元素（无论是否使用 Refs，例如，通过直接选择 DOM 节点 `document.getElementById()`
    或类似方法）应该避免。一个罕见的例外是调用输入元素 DOM 对象上的 `focus()` 方法，因为像 `focus()` 这样的方法通常不会引起任何可能导致
    React 应用程序中断的 DOM 变化。
- en: Using Refs for More than DOM Access
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Refs 进行更多操作
- en: Accessing DOM elements (for reading values) is one of the most common use cases
    for using Refs. As shown above, it can help you reduce code in certain situations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 DOM 元素（用于读取值）是使用 Refs 的最常见用例之一。如上所示，它可以在某些情况下帮助您减少代码。
- en: 'But Refs are more than just “element connection bridges;” they are objects
    that can be used to store all kinds of values—not just pointers at DOM objects.
    You can, for example, also store strings or numbers or any other kind of value
    in a Ref:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Refs 不仅仅是“元素连接桥梁”；它们是可以用来存储各种值的对象——不仅仅是 DOM 对象的指针。例如，您还可以在 Ref 中存储字符串、数字或其他任何类型的值：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can pass an initial value to `useRef()` ( `0` in this example) and then
    access or change that value at any point in time inside the component to which
    the Ref belongs:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向 `useRef()` 传递一个初始值（本例中的 `0`），然后在任何时候访问或更改 Ref 所属组件中的该值：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, you still have to use the `current` property to read and change the
    stored value, because, as mentioned above, this is where React will store the
    actual value that belongs to the Ref.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您仍然必须使用 `current` 属性来读取和更改存储的值，因为，如上所述，这是 React 存储属于 Ref 的实际值的地方。
- en: 'This can be useful for storing data that should “survive” component re-evaluations.
    As you learned in *Chapter 4* , *Working with Events and State* , React will execute
    component functions every time the state of a component changes. Since the function
    is executed again, any data stored in function-scoped variables would be lost.
    Consider the following example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于存储应该“生存”组件重新评估的数据很有用。正如你在 *第 4 章* 中学到的，*与事件和状态一起工作*，React 每当组件状态发生变化时都会执行组件函数。由于函数再次执行，存储在函数作用域变量中的任何数据都会丢失。考虑以下示例：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, counters 1 and 3 would change to 1 once the button is clicked.
    However, counter 2 would remain zero, even though the `counter2` variable gets
    changed to a value of 1 in `handleChangeCounters` as well:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当按钮被点击时，计数器 1 和 3 会变为 1。然而，计数器 2 将保持为零，尽管在 `handleChangeCounters` 中 `counter2`
    变量也被更改为值 `1`：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_07_02.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![计算机的截图  描述由中等置信度自动生成](img/B31339_07_02.png)'
- en: 'Figure 7.2: Only two of the three counter values changed'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：只有三个计数器值中的两个发生了变化
- en: In this example, it should be expected that the state value changes and the
    new value is reflected in the updated user interface. That is the whole idea behind
    state, after all.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，应该预期状态值发生变化，并且新值会反映在更新的用户界面中。毕竟，这就是状态的全部理念。
- en: 'The Ref ( `counterRef` ) also keeps its updated value across component re-evaluations,
    though. That’s the behavior described above: Refs are not reset or cleared when
    the surrounding component function is executed again. The vanilla JavaScript variable
    ( `counter2` ) does not keep its value. Even though it is changed in `handleChangeCounters`
    , a new variable is initialized when the component function is executed again;
    thus the updated value ( `1` ) is lost.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Ref（`counterRef`）也会在组件重新评估之间保持其更新值。这就是上面描述的行为：当周围组件函数再次执行时，Refs 不会被重置或清除。纯 JavaScript
    变量（`counter2`）不会保持其值。尽管它在 `handleChangeCounters` 中被更改，但当组件函数再次执行时，会初始化一个新的变量；因此，更新值（`1`）会丢失。
- en: 'In this example, it might again look like Refs can replace state, but the example
    actually shows very well why that is **not** the case. Try replacing `counter1`
    with another Ref (so that there is no state value left in the component) and clicking
    the button:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，它可能看起来像 Refs 可以替代状态，但实际上这个例子很好地说明了这**不是**情况。尝试将 `counter1` 替换为另一个 Ref（这样组件中就没有剩余的状态值）并点击按钮：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Nothing will change on the page because, while the button click is registered
    and the `handleChangeCounters` function is executed, no state change is initiated,
    and state changes (initiated via the `setXYZ` state updating function calls) are
    the triggers that cause React to re-evaluate a component. Changes to Ref values
    do **not** do that.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上不会发生任何变化，因为虽然按钮点击被记录并且 `handleChangeCounters` 函数被执行，但没有发起状态变化，状态变化（通过 `setXYZ`
    状态更新函数调用发起）是触发 React 重新评估组件的触发器。改变 Ref 值**不会**这样做。
- en: '![A comparison of numbers and numbers  Description automatically generated
    with medium confidence](img/B31339_07_03.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![数字与数字的比较  描述由中等置信度自动生成](img/B31339_07_03.png)'
- en: 'Figure 7.3: The counter values don’t change'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：计数器值没有变化
- en: As you can tell, changing Ref values does not trigger component functions to
    be executed again—state, on the other hand, does. However, if a component function
    runs again (due to a state change), Ref values are kept around and not dropped.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以看到的，更改Ref值不会触发组件函数再次执行——另一方面，状态会。然而，如果一个组件函数再次运行（由于状态变化），Ref值会被保留而不是丢弃。
- en: 'Therefore, if you have data that should survive component re-evaluations but
    should not be managed as state (because changes to that data should not cause
    the component to be re-evaluated when changed), you could use a Ref:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你有应该能够生存组件重新评估但不应作为状态管理的数据（因为该数据的变化不应导致组件在变化时重新评估），你可以使用一个Ref：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is not a feature that’s used frequently, but it can be helpful from time
    to time. In all other cases, use normal state values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个经常使用的功能，但有时可能会有所帮助。在其他所有情况下，使用正常的状态值。
- en: Refs in Custom Components
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义组件中的Refs
- en: Refs cannot just be used to access DOM elements. You can also use them to access
    React components—including your own components.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Refs不仅可以用来访问DOM元素，还可以用来访问React组件——包括你自己的组件。
- en: 'This can sometimes be useful. Consider this example: you have a `<Form>` component
    that contains a nested `<Preferences>` component. The latter component is responsible
    for displaying two checkboxes, asking the user for their newsletter preferences:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时可能很有用。考虑这个例子：你有一个`<Form>`组件，它包含一个嵌套的`<Preferences>`组件。后者组件负责显示两个复选框，询问用户的新闻通讯偏好：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_07_04.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图 自动生成描述](img/B31339_07_04.png)'
- en: 'Figure 7.4: A newsletter sign-up form that shows two checkboxes to set newsletter
    preferences'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：一个显示两个复选框以设置新闻通讯偏好的新闻通讯注册表单
- en: 'The code of the `Preferences` component could look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Preferences`组件的代码可能看起来像这样：'
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, it’s a basic component that essentially outputs the two checkboxes,
    adds some styling, and keeps track of the selected checkbox via state.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这是一个基本组件，它本质上输出两个复选框，添加一些样式，并通过状态跟踪选定的复选框。
- en: 'The `Form` component code could look like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form`组件的代码可能看起来像这样：'
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now imagine that upon form submission (inside of the `handleSubmit` function),
    the `Preferences` should be reset (i.e., no checkbox is selected anymore). In
    addition, prior to resetting, the selected values should be read and used in the
    `handleSubmit` function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，在表单提交（在`handleSubmit`函数内部）时，应该重置`Preferences`（即不再选择任何复选框）。此外，在重置之前，应该读取选定的值并在`handleSubmit`函数中使用它们。
- en: This would be straightforward if the checkboxes were not put into a separate
    component. If the entire code and JSX markup reside in the `Form` component, state
    could be used in that component to read and change the values. But this is not
    the case in this example, and rewriting the code just because of this problem
    sounds like an unnecessary restriction.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果复选框没有被放入一个单独的组件中，这将很简单。如果整个代码和JSX标记都位于`Form`组件中，那么可以在该组件中使用状态来读取和更改值。但在这个例子中并非如此，仅仅因为这个问题而重写代码听起来像是一个不必要的限制。
- en: Fortunately, Refs can help in this situation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Refs可以帮助这种情况。
- en: You can expose features (for example, functions or state values) of a component
    to other components via Refs. Refs can essentially be used as a *communication
    device* between two components, just as they were used as a *communication device*
    with a DOM element in the previous sections.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过Refs将组件的功能（例如，函数或状态值）暴露给其他组件。本质上，Refs可以用作两个组件之间的*通信设备*，就像它们在前面章节中用作与DOM元素的*通信设备*一样。
- en: 'Conveniently, your custom components can receive a ref as a regular prop:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 便利的是，你的自定义组件可以接收一个ref作为常规属性：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You could therefore use this `Preferences` component and pass a `ref` to it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以使用这个`Preferences`组件并将其传递一个`ref`给它：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It’s important to note that this code only works when using React 19 or higher.
    When working with an older React version, passing Refs as regular props to components
    is unfortunately not supported. In such projects, you would have to wrap the component
    function that should receive a Ref with a special `forwardRef()` function that’s
    provided by React.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这段代码仅在React 19或更高版本中使用时才有效。当使用较旧的React版本时，将Refs作为常规属性传递给组件是不支持的。在这种情况下，你将不得不使用React提供的特殊`forwardRef()`函数将应该接收Ref的组件函数包装起来。
- en: Therefore, in React projects using React 18 or older, to receive and use Refs,
    you must wrap the receiving component ( `Preferences` , in this example) with
    `forwardRef()` .
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在React 18或更早版本的React项目中，要接收和使用Refs，你必须将接收组件（例如，在这个例子中的`Preferences`）包裹在`forwardRef()`中。
- en: 'This can be done like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以这样操作：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This looks slightly different than all the other components in this book because
    an arrow function is used instead of the `function` keyword. You can always use
    arrow functions instead of “normal functions”, but here it’s helpful to switch
    as it makes wrapping the function with `forwardRef()` very easy. Alternatively,
    you could stick to the `function` keyword and wrap the function like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他本书中的所有组件看起来略有不同，因为这里使用的是箭头函数而不是`function`关键字。你始终可以使用箭头函数而不是“普通函数”，但在这里切换是有帮助的，因为它使得用`forwardRef()`包裹函数变得非常容易。或者，你也可以坚持使用`function`关键字，并像这样包裹函数：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is up to you which syntax you prefer. Both work and both are commonly used
    in React projects.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择你喜欢的语法。两者都有效，并且在React项目中都常用。
- en: The interesting part about this code is that the component function now receives
    **two** parameters instead of one. Besides receiving `props` , which component
    functions always do, it now also receives a special `ref` parameter. And this
    parameter is only received because the component function is wrapped with `forwardRef()`
    .
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有趣的部分是，组件函数现在接收**两个**参数而不是一个。除了接收`props`，组件函数始终会这样做之外，它现在还接收一个特殊的`ref`参数。而这个参数之所以被接收，是因为组件函数被`forwardRef()`包裹。
- en: 'This `ref` parameter will contain any `ref` value set by the component using
    the `Preferences` component. For example, the `Form` component could set a `ref`
    parameter on `Preferences` like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`ref`参数将包含使用`Preferences`组件设置的任何`ref`值。例如，`Form`组件可以在`Preferences`上设置一个`ref`参数，如下所示：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Again, `useRef()` is used to create a `ref` object ( `preferencesRef` ), and
    that object is then passed via the special `ref` prop to the `Preferences` component.
    The created Ref receives a default value of an empty object ( `{}` ); it’s this
    object that can then be accessed via `ref.current` . In the `Preferences` component,
    the `ref` value can either be received and extracted like a regular prop (React
    >= 19) or must be accessed with the help of React’s `forwardRef()` function. In
    that case, it’s received via this second `ref` parameter, which exists because
    of `forwardRef()` .
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`useRef()`用于创建一个`ref`对象（`preferencesRef`），然后通过特殊的`ref`属性将其传递给`Preferences`组件。创建的Ref接收一个默认值为空对象（`{}`）的值；正是这个对象可以通过`ref.current`访问。在`Preferences`组件中，`ref`值可以像常规属性一样接收和提取（React
    >= 19）或必须使用React的`forwardRef()`函数来访问。在这种情况下，它通过第二个`ref`参数接收，这是由于`forwardRef()`的存在。
- en: But what’s the benefit of that? How can this `preferencesRef` object now be
    used inside `Preferences` to enable cross-component interaction?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但这有什么好处呢？现在如何在这个`preferencesRef`对象内部使用`Preferences`来启用跨组件交互？
- en: Since `ref` is an object that is never replaced, even if the component in which
    it was created via `useRef()` is re-evaluated (see previous sections above), the
    receiving component can assign properties and methods to that object and the creating
    component can then use these methods and properties. The `ref` object is therefore
    used as a communication vehicle.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ref`是一个永远不会被替换的对象，即使通过`useRef()`创建它的组件被重新评估（参见上面的前几节），接收组件可以将属性和方法分配给该对象，创建组件然后可以使用这些方法和属性。因此，`ref`对象被用作通信工具。
- en: 'In this example, the `Preferences` component could be changed like this to
    use the `ref` object:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Preferences`组件可以像这样更改以使用`ref`对象：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In `Preferences` , both the state values and a pointer at a newly added `reset`
    function are stored in the received `ref` object. `ref.current` is used since
    the object created by React (when using `useRef()` ) always has such a `current`
    property, and that property should be used to store the actual values in `ref`
    .
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Preferences`中，状态值和指向新添加的`reset`函数的指针都存储在接收到的`ref`对象中。使用`ref.current`是因为React（在使用`useRef()`时）创建的对象始终具有这样的`current`属性，并且应该使用该属性来在`ref`中存储实际值。
- en: 'Since `Preferences` and `Form` operate on the same object that’s stored in
    the `ref` object, the properties and methods assigned to the object in `Preferences`
    can also be used in `Form` :'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Preferences`和`Form`操作的是存储在`ref`对象中的同一个对象，因此在`Preferences`中分配给该对象的属性和方法也可以在`Form`中使用：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By using Refs like this, a parent component ( `Form` , in this case) is able
    to interact with some child component (for instance, `Preferences` ) in an imperative
    way—meaning properties can be accessed and methods called to manipulate the child
    component (or, to be precise, to trigger some internal functions and behavior
    inside the child component).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式使用 Refs，父组件（在这种情况下是 `Form`）能够以命令式的方式与某些子组件（例如，`Preferences`）进行交互——这意味着可以访问属性并调用方法来操作子组件（或者更准确地说，触发子组件内部的一些函数和行为）。
- en: '**Note**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: React also provides an `useImperativeHandle()` Hook that may be used to expose
    data or functions from custom components.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: React 还提供了一个 `useImperativeHandle()` 钩子，它可以用来从自定义组件中暴露数据或函数。
- en: Technically, you don’t need to use this Hook, as the above examples prove. You
    can communicate between components via Refs without any extra Hooks.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，您不需要使用这个钩子，因为上面的例子已经证明了这一点。您可以通过 Refs 在组件之间进行通信，而不需要任何额外的钩子。
- en: 'But you might want to consider using `useImperativeHandle()` since it will
    handle scenarios like missing `ref` values (i.e., if no `ref` value is provided).
    You can learn more about the usage of this (arguably niche) Hook in the official
    documentation: [https://react.dev/reference/react/useImperativeHandle](https://react.dev/reference/react/useImperativeHandle)
    .'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可能需要考虑使用 `useImperativeHandle()`，因为它将处理像缺少 `ref` 值（即没有提供 `ref` 值）这样的场景。您可以在官方文档中了解更多关于这个（可以说是小众的）钩子的使用方法：[https://react.dev/reference/react/useImperativeHandle](https://react.dev/reference/react/useImperativeHandle)。
- en: Controlled versus Uncontrolled Components
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受控组件与不受控组件
- en: Passing Refs to custom components (via props or `forwardRef()` ) is a method
    that can be used to allow the `Form` and `Preferences` components to work together.
    But even though it might look like an elegant solution at first, it should typically
    not be your default solution for this kind of problem.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Refs 传递给自定义组件（通过 props 或 `forwardRef()`）是一种方法，可以用来允许 `Form` 和 `Preferences`
    组件协同工作。但尽管这最初可能看起来像是一个优雅的解决方案，但对于这类问题，它通常不应成为您的默认解决方案。
- en: Using Refs, as shown in the example above, leads to more imperative code in
    the end. It’s imperative code because instead of defining the desired user interface
    state via JSX (which would be declarative), individual step-by-step instructions
    are added in JavaScript.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面示例所示，使用 Refs 最终会导致更多的命令式代码。这是因为，而不是通过 JSX（这将是一种声明式方法）定义所需的用户界面状态，JavaScript
    中添加了单个的逐步指令。
- en: If you revisit *Chapter 1* , *React – What and Why* (the *The Problem with Vanilla
    JavaScript* section), you’ll see that code such as `preferencesRef.current.reset()`
    (from the example above) looks quite similar to instructions such as `buttonElement.addEventListener(…)`
    (example from *Chapter 1* ). Both examples use imperative code and should be avoided
    for the reasons mentioned in *Chapter 1* (writing step-by-step instructions leads
    to inefficient micro-management and often unnecessarily complex code).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回顾 *第一章* ，*React – 什么和为什么*（*JavaScript 的弊端*部分），您会看到像 `preferencesRef.current.reset()`（来自上面的例子）这样的代码看起来与
    `buttonElement.addEventListener(…)`（来自 *第一章* 的例子）这样的指令非常相似。这两个例子都使用了命令式代码，并且应该避免，正如
    *第一章* 中提到的理由（逐步编写指令会导致低效的微观管理，并且通常会产生不必要的复杂代码）。
- en: Inside the `Form` component, the `reset()` function of `Preferences` is invoked.
    Hence, the code describes the desired action that should be performed (instead
    of the expected outcome). Typically, when working with React you should strive
    to describe the desired (UI) state instead. Remember, when working with React,
    that you should write declarative, rather than imperative, code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Form` 组件内部，调用了 `Preferences` 的 `reset()` 函数。因此，代码描述了应该执行的动作（而不是预期的结果）。通常，当使用
    React 时，您应该努力描述所需的（UI）状态。记住，当使用 React 时，您应该编写声明式代码，而不是命令式代码。
- en: When using Refs to read or manipulate data as shown in the previous sections
    of this chapter, you are building so-called **uncontrolled components** . The
    components are considered “uncontrolled” because React is not directly controlling
    the UI state. Instead, values are read from other components or the DOM. It’s
    therefore the DOM that controls the state (e.g., a state such as the value entered
    by a user into an input field).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Refs 来读取或操作数据，如本章前面的部分所示，您正在构建所谓的**不受控组件**。这些组件被认为是“不受控”的，因为 React 并没有直接控制
    UI 状态。相反，值是从其他组件或 DOM 中读取的。因此，DOM 控制着状态（例如，用户输入到输入字段中的值这样的状态）。
- en: As a React developer, you should try to minimize the use of uncontrolled components.
    It’s absolutely fine to use Refs to save some code if you only need to gather
    some entered values. But as soon as your UI logic becomes more complex (for example,
    if you also want to clear user input), you should go for **controlled components**
    instead.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 React 开发者，你应该尽量减少使用非受控组件。如果你只需要收集一些输入值，使用 Refs 来节省一些代码是完全可行的。但是，一旦你的 UI 逻辑变得更加复杂（例如，如果你还想清除用户输入），你应该选择
    **受控组件**。
- en: 'Doing so is quite straightforward: a component becomes controlled as soon as
    React manages the state. In the case of the `EmailForm` component from the beginning
    of this chapter, the controlled component approach was shown before Refs were
    introduced. Using `useState()` to store the user’s input (and update the state
    with every keystroke) meant that React was in full control of the entered value.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做相当简单：组件一旦被 React 管理状态，就变为受控组件。在本章开头提到的 `EmailForm` 组件的例子中，在引入 Refs 之前已经展示了受控组件的方法。使用
    `useState()` 存储用户的输入（并且每次按键更新状态）意味着 React 完全控制了输入的值。
- en: 'For the previous example, the `Form` and `Preferences` components, switching
    to a controlled component approach could look like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的例子，`Form` 和 `Preferences` 组件，切换到受控组件方法可能看起来像这样：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, the `Preferences` component stops managing the checkbox state
    and instead receives props from its parent component (the `Form` component).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Preferences` 组件停止管理复选框状态，而是从其父组件（`Form` 组件）接收属性。
- en: '`bind()` is used on the `onUpdateInfo` prop (which will receive a function
    as a value) to *pre-configure* the function for future execution. `bind()` is
    a default JavaScript method that can be called on any JavaScript function to control
    which arguments will be passed to that function once it’s invoked in the future.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onUpdateInfo` 属性（它将接收一个函数作为值）上使用 `bind()` 来 *预先配置* 该函数以供将来执行。`bind()` 是一个默认的
    JavaScript 方法，可以在任何 JavaScript 函数上调用，以控制在将来调用该函数时将传递哪些参数。
- en: '**Note**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can learn more about this JavaScript feature at [https://academind.com/tutorials/function-bind-event-execution](https://academind.com/tutorials/function-bind-event-execution)
    .
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://academind.com/tutorials/function-bind-event-execution](https://academind.com/tutorials/function-bind-event-execution)
    上了解更多关于这个 JavaScript 功能的信息。
- en: 'The `Form` component now manages the checkbox states, even though it doesn’t
    directly contain the checkbox elements. But it now begins to control the `Preferences`
    component and its internal state, hence turning `Preferences` into a controlled
    component instead of an uncontrolled one:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form` 组件现在管理复选框状态，即使它不直接包含复选框元素。但现在它开始控制 `Preferences` 组件及其内部状态，因此将 `Preferences`
    转换为受控组件而不是非受控组件：'
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`Form` manages the checkbox selection state, including resetting the state
    via the `reset()` function, and passes the managed state values ( `wantsNewProdInfo`
    and `wantsProdUpdateInfo` ) as well as the `handleUpdateProdInfo` function, which
    updates the state values, to `Preferences` . The `Form` component now controls
    the `Preferences` component.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form` 组件管理复选框的选择状态，包括通过 `reset()` 函数重置状态，并将管理的状态值（`wantsNewProdInfo` 和 `wantsProdUpdateInfo`）以及
    `handleUpdateProdInfo` 函数（用于更新状态值）传递给 `Preferences`。现在 `Form` 组件控制 `Preferences`
    组件。'
- en: If you go through the two code snippets above, you’ll notice that the final
    code is once again purely declarative. Across all components, state is managed
    and used to declare the expected user interface.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了上面的两个代码片段，你会注意到最终的代码再次是纯声明式的。在所有组件中，状态被管理和使用来声明预期的用户界面。
- en: It is considered a good practice to go for controlled components in most cases.
    If you are only extracting some entered user input values, however, then using
    Refs and creating an uncontrolled component is absolutely fine.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，使用受控组件被认为是一种良好的实践。然而，如果你只是提取一些输入的用户值，那么使用 Refs 并创建一个非受控组件是完全可行的。
- en: React and Where Things End up in the DOM
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 和 DOM 中的元素位置
- en: 'Leaving the topic of Refs, there is one other important React feature that
    can help with influencing (indirect) DOM interaction: **Portals** .'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 离开 Refs 的主题，还有一个其他重要的 React 功能可以帮助影响（间接）DOM 交互：**Portals**。
- en: When building user interfaces, you sometimes need to display elements and content
    conditionally. This was already covered in *Chapter 5* , *Rendering Lists and
    Conditional Content* . When rendering conditional content, React will inject that
    content into the place in the DOM where the overall component (in which the conditional
    content is defined) is located.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建用户界面时，有时需要条件性地显示元素和内容。这已经在*第5章*，*渲染列表和条件内容*中讨论过了。当渲染条件性内容时，React会将该内容注入到包含条件性内容的整体组件在DOM中的位置。
- en: 'For example, when showing a conditional error message below an input field,
    that error message is right below the input in the DOM:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当在输入字段下方显示条件性错误信息时，该错误信息在DOM中正好位于输入字段下方：
- en: '*![A screen shot of a computer  Description automatically generated](img/B31339_07_05.png)*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*![计算机屏幕截图  自动生成的描述](img/B31339_07_05.png)*'
- en: 'Figure 7.5: The error message DOM element sits right below the <input> it belongs
    to'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：错误信息DOM元素位于其所属的<input>元素下方
- en: This behavior makes sense. Indeed, it would be pretty irritating if React were
    to start inserting DOM elements in random places. But in some scenarios, you may
    prefer a (conditional) DOM element to be inserted in a different place in the
    DOM—for example, when working with overlay elements such as error dialogs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是有意义的。确实，如果React开始在随机位置插入DOM元素，那将会非常令人烦恼。但在某些场景中，你可能希望（条件性）DOM元素被插入到DOM中的不同位置——例如，当处理如错误对话框之类的覆盖元素时。
- en: 'In the preceding example, you could add logic to ensure that an error dialog
    is presented to the user if the form is submitted with an invalid email address.
    This could be implemented with logic similar to the `"Invalid email address!"`
    error message, and therefore the dialog element would, of course, also be injected
    dynamically into the DOM:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你可以添加逻辑以确保如果表单提交了无效的电子邮件地址，则向用户显示错误对话框。这可以通过类似于“无效的电子邮件地址！”的错误信息逻辑来实现，因此对话框元素当然也会被动态注入到DOM中：
- en: '![A screenshot of a computer screen  Description automatically generated](img/B31339_07_06.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B31339_07_06.png)'
- en: 'Figure 7.6: The error dialog and its backdrop are injected into the DOM'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：错误对话框及其背景被注入到DOM中
- en: In this screenshot, the error dialog is opened as an overlay above a backdrop
    element, which is itself added so that it acts as an overlay to the rest of the
    user interface.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕截图中，错误对话框作为一个覆盖层在背景元素上方打开，而背景元素本身被添加是为了使其作为用户界面的覆盖层。
- en: '**Note**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'The appearance is handled entirely by CSS, and you can take a look at the complete
    project (including the styling) here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/examples/05-portals-problem](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/examples/05-portals-problem)
    .'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 外观完全由CSS处理，你可以在这里查看完整的项目（包括样式）：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/examples/05-portals-problem](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/examples/05-portals-problem)
    .
- en: This example works and looks fine. However, there is room for improvement.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例工作得很好，看起来也很不错。然而，还有改进的空间。
- en: 'Semantically, it doesn’t entirely make sense to have the overlay elements injected
    somewhere nested into the DOM next to the `<input>` element. It would make more
    sense for overlay elements to be closer to the root of the DOM (in other words,
    to be direct child elements of `<div id="root">` or even `<body>` ), instead of
    being children of `<form>` . And it’s not just a semantic problem. If the example
    app contains other overlay elements, those elements might clash with each other,
    like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从语义上讲，将覆盖元素注入到DOM中，嵌套在<input>元素旁边，并不完全合理。覆盖元素更接近DOM的根（换句话说，是<div id="root">或甚至是<body>的直接子元素）会更合理，而不是成为<form>的子元素。而且，这不仅仅是一个语义问题。如果示例应用包含其他覆盖元素，这些元素可能会相互冲突，如下所示：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_07_07.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B31339_07_07.png)'
- en: 'Figure 7.7: The <footer> element at the bottom is visible above the backdrop'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：底部的<footer>元素在背景之上可见
- en: 'In this example, the `<footer>` element at the bottom (“An example project”)
    is not hidden or grayed out by the backdrop that belongs to the error dialog.
    The reason for that is that the footer also has some CSS styling attached that
    turns it into a de facto overlay (because of `position: fixed` and `left` + `bottom`
    being used in its CSS styles).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，底部（“一个示例项目”）的`<footer>`元素没有被错误对话框的背景隐藏或变灰。原因是footer也附加了一些CSS样式，使其成为事实上的覆盖层（因为使用了`position:
    fixed`和`left` + `bottom`）。'
- en: As a solution to this problem, you could tweak some CSS styles and, for example,
    use the `z-index` CSS property to control overlay levels. However, it would be
    a cleaner solution if the overlay elements (i.e., the `<div>` backdrop and the
    `<dialog>` error elements) were inserted into the DOM in a different place—for
    example, at the very end of the `<body>` element (but as direct children to `<body>`
    ).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个问题的解决方案，你可以调整一些CSS样式，例如，使用`z-index` CSS属性来控制覆盖层级。然而，如果覆盖元素（即，`<div>`背景和`<dialog>`错误元素）被插入到DOM的不同位置——例如，在`<body>`元素的末尾（但作为`<body>`的直接子元素）——将会是一个更干净的解决方案。
- en: And that’s exactly the kind of problem React **Portals** help you solve.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是React **门户**可以帮助你解决的问题。
- en: Portals to the Rescue
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 门户救援
- en: A **Portal** , in React’s world, is a feature that allows you to instruct React
    to insert a DOM element in a different place than where it would normally be inserted.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在React的世界里，**门户**是一个允许你指示React将DOM元素插入到不同于其通常插入位置的功能。
- en: Considering the example shown above, this portal feature can be used to *tell*
    React to not insert the `<dialog>` error and the `<div>` backdrop that belongs
    to the dialog inside the `<form>` element, but to instead insert those elements
    at the end of the `<body>` element.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到上面显示的例子，这个门户功能可以用来指示React不要在`<form>`元素内部插入属于对话框的`<dialog>`错误和`<div>`背景，而是将这些元素插入到`<body>`元素的末尾。
- en: 'To use this portal feature, you first must define a place wherein elements
    can be inserted (an “injection hook”). This can be done in the HTML file that
    belongs to the React app (i.e., `index.html` ). There, you can add a new element
    (for example, a `<div>` element) somewhere in the `<body>` element:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个门户功能，你首先必须定义一个可以插入元素的位置（一个“注入钩子”）。这可以在属于React应用的HTML文件中完成（例如，`index.html`）。在那里，你可以在`<body>`元素中的某个位置添加一个新元素（例如，一个`<div>`元素）：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, a `<div id="dialogs">` element is added in the `<body>` section,
    after the `<div id="root">` element to make sure that any components (and their
    styles) inserted in that element are evaluated last. This will ensure that their
    styles take a higher priority and overlay elements inserted into `<div id="dialogs">`
    would not be overlaid by other content coming earlier in the DOM. Adding and using
    multiple hooks would be possible, but for this example, only one *injection point*
    is needed. You can also use HTML elements other than `<div>` elements.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在`<div id="root">`元素之后在`<body>`部分添加了一个`<div id="dialogs">`元素，以确保插入该元素的任何组件（及其样式）都是最后评估的。这将确保它们的样式具有更高的优先级，并且插入到`<div
    id="dialogs">`中的覆盖元素不会被DOM中较早出现的内容覆盖。添加和使用多个钩子是可能的，但在这个例子中只需要一个*注入点*。你也可以使用除`<div>`元素之外的HTML元素。
- en: 'With the `index.html` file adjusted, React can be instructed to render certain
    JSX elements (i.e., components) in a specified *injection point* via the `createPortal()`
    function of `react-dom` :'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 调整了`index.html`文件后，可以通过`react-dom`的`createPortal()`函数指示React在指定的*注入点*渲染某些JSX元素（即，组件）：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Inside this `ErrorDialog` component, which is rendered conditionally by another
    component (the `EmailForm` component, the example code for which is available
    on GitHub), the returned JSX code is wrapped by `createPortal()` . `createPortal()`
    takes two arguments: the JSX code that should be rendered in the DOM and a pointer
    at the element in `index.html` where the content should be injected.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`ErrorDialog`组件内部，它由另一个组件（例如，GitHub上的示例代码`EmailForm`组件）条件性地渲染，返回的JSX代码被`createPortal()`包裹。`createPortal()`接受两个参数：应该在DOM中渲染的JSX代码以及在`index.html`中内容应注入的元素的指针。
- en: 'In this example, the newly added `<div id="dialogs">` is selected via `document.getElementById(''dialogs'')`
    . Therefore, `createPortal()` ensures that the JSX code generated by `ErrorDialog`
    is rendered in that place in the HTML document:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，新添加的`<div id="dialogs">`是通过`document.getElementById('dialogs')`选择的。因此，`createPortal()`确保由`ErrorDialog`生成的JSX代码在HTML文档的该位置渲染：
- en: '![img](img/B31339_07_08.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_07_08.png)'
- en: 'Figure 7.8: The overlay elements are inserted into <div id=”dialogs”>'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：覆盖元素被插入到`<div id="dialogs">`中
- en: In this screenshot, you can see that the overlay elements ( `<div>` backdrop
    and `<dialog>` error) are indeed inserted into the `<div id="dialogs">` element,
    instead of the `<form>` element (as they were before).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕截图中，您可以看到覆盖元素（`<div>`背景和`<dialog>`错误）确实被插入到`<div id="dialogs">`元素中，而不是`<form>`元素（如之前那样）。
- en: As a result of this change, `<footer>` no longer overlays the error dialog backdrop
    without any CSS code changes. Semantically, the final DOM structure also makes
    more sense since you would typically expect overlay elements to be closer to the
    root DOM node.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这次更改，无需修改任何CSS代码，`<footer>`元素不再覆盖错误对话框的背景。从语义上讲，最终的DOM结构也更加合理，因为通常期望覆盖元素更接近根DOM节点。
- en: Still, using this portal feature is optional. The same visual result (though
    not the DOM structure) could have been achieved by changing some CSS styles. Nonetheless,
    aiming for a clean DOM structure is a worthwhile pursuit, and avoiding unnecessarily
    complex CSS code is also not a bad thing.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，使用此门户功能是可选的。通过更改一些CSS样式，同样可以达到相同的效果（尽管不是DOM结构）。不过，追求干净的DOM结构是一个值得追求的目标，避免不必要的复杂CSS代码也是一个不错的选择。
- en: Summary and Key Takeaways
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述和关键要点
- en: Refs can be used to gain direct access to DOM elements or to store values that
    won’t be reset or changed when the surrounding component is re-evaluated.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Refs可用于直接访问DOM元素或存储在周围组件重新评估时不会被重置或更改的值。
- en: Only use this direct access to read values, not to manipulate DOM elements (let
    React do this instead).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用此直接访问来读取值，而不是操纵DOM元素（让React来处理）。
- en: Components that gain DOM access via Refs, instead of state and other React features,
    are considered uncontrolled components (because React is not in direct control).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Refs而不是状态和其他React功能获得DOM访问的组件被认为是未受控组件（因为React没有直接控制）。
- en: Prefer controlled components (using state and a strictly declarative approach)
    over uncontrolled components unless you’re performing very simple tasks such as
    reading an entered input value.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非您正在执行非常简单的任务，例如读取输入的值，否则请优先使用受控组件（使用状态和严格的声明式方法）而不是不受控组件。
- en: Using Refs, you can also expose features of your own components so that they
    may be used imperatively.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Refs，您还可以暴露您自己的组件功能，以便它们可以被命令式地使用。
- en: You can set and use a `ref` prop on custom components when working with React
    19 or higher.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用React 19或更高版本时，您可以在自定义组件上设置和使用`ref`属性。
- en: When using React < 19, React’s `forwardRef()` function must be used to receive
    Refs on custom components.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用React < 19时，必须在自定义组件上使用React的`forwardRef()`函数来接收Refs。
- en: Portals can be used to instruct React to render JSX elements in a different
    place in the DOM than they normally would.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 门户可以用来指示React在DOM的不同位置渲染JSX元素，而不是它们通常的位置。
- en: What’s Next?
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: At this point in the book, you’ve encountered many key tools and concepts that
    can be used to build interactive and engaging user interfaces. Thanks to Refs,
    you can read DOM values without using state (hence avoiding unnecessary component
    re-evaluations) or manage values that persist across component updates. Thanks
    to Portals, you’re able to control where exactly component markup is inserted
    into the DOM.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，您已经遇到了许多可以用来构建交互式和引人入胜的用户界面的关键工具和概念。多亏了Refs，您可以在不使用状态的情况下读取DOM值（从而避免不必要的组件重新评估），或者管理在组件更新之间持续存在的值。多亏了Portals，您能够控制组件标记在DOM中确切的位置。
- en: As a result, you get some new tools that can be used to fine-tune your React
    app. You may be able to improve performance (by avoiding component re-evaluations)
    or improve the structure and semantics of your DOM elements. Ultimately, it’s
    the combination of all these tools that allows you to build engaging, interactive,
    and also performant web applications with React.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您获得了一些可以用来微调您的React应用的新工具。您可能能够通过避免组件重新评估来提高性能，或者提高DOM元素的架构和语义。最终，正是所有这些工具的组合，使您能够使用React构建引人入胜、交互式且性能良好的Web应用。
- en: 'But, as you will learn in the next chapter, React has even more helpful core
    concepts to offer: for example, a way of handling **side effects** .'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如您将在下一章中了解到的那样，React还有更多有用的核心概念可以提供：例如，处理**副作用**的方法。
- en: The next chapter will explore what exactly **side effects** are, why they need
    special handling, and how React helps you with that.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨**副作用**究竟是什么，为什么需要特殊处理，以及React如何帮助您处理这些。
- en: Test Your Knowledge!
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你的知识！
- en: Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers with examples that can
    be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/07-portals-refs/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/07-portals-refs/exercises/questions-answers.md)
    .
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你对本章涵盖的概念的理解。然后，你可以将你的答案与在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/07-portals-refs/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/07-portals-refs/exercises/questions-answers.md)中可以找到的示例进行比较。
- en: How can Refs help with handling user input in forms?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Refs如何帮助处理表单中的用户输入？
- en: What is an uncontrolled component?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是无状态组件？
- en: What is a controlled component?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是受控组件？
- en: When should you **not** use Refs?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在什么情况下**不**使用Refs？
- en: What’s the main idea behind portals?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端口背后的主要思想是什么？
- en: Apply What You Have Learned
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用你所学的知识
- en: With this newly gained knowledge about Refs and Portals, it’s again time to
    practice what you have learned.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了关于Refs和端口的新的知识之后，又是时候练习你所学的内容了。
- en: Below, you’ll find two activities that allow you to practice working with Refs
    and Portals. As always, you will, of course, also need some of the concepts covered
    in earlier chapters (e.g., working with state).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，你将找到两个活动，允许你练习使用Refs和端口。一如既往，你当然还需要一些之前章节中涵盖的概念（例如，处理状态）。
- en: 'Activity 7.1: Extract User Input Values'
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动7.1：提取用户输入值
- en: In this activity, you have to add logic to an existing React component to extract
    values from a form. The form contains an input field and a drop-down menu and
    you should make sure that, upon form submission, both values are read and, for
    the purpose of this dummy app, output to the browser console.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你必须向现有的React组件添加逻辑以从表单中提取值。该表单包含一个输入字段和一个下拉菜单，你应该确保在表单提交时，两个值都被读取，并且为了这个模拟应用程序，输出到浏览器控制台。
- en: Use your knowledge about Refs and uncontrolled components to implement a solution
    without using React state.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你对Refs和无状态组件的了解来实现一个不使用React状态的解决方案。
- en: '**Note**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the starting code for this activity at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-1-start)
    . When downloading this code, you’ll always download the entire repository. Make
    sure to then navigate to the subfolder with the starting code ( `activities/practice-1-start`
    in this case) to use the right code snapshot.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-1-start)找到这个活动的起始代码。下载此代码时，你将始终下载整个仓库。请确保然后导航到包含起始代码的子文件夹（在本例中为`activities/practice-1-start`），以使用正确的代码快照。
- en: 'After downloading the code and running `npm install` in the project folder
    (to install all the required dependencies), the solution steps are as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目文件夹中下载代码并运行`npm install`（安装所有必需的依赖项）之后，解决方案步骤如下：
- en: Create two Refs, one for each input element that should be read (input field
    and drop-down menu).
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个Refs，一个用于每个需要读取的输入元素（输入字段和下拉菜单）。
- en: Connect the Refs to the input elements.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Refs连接到输入元素。
- en: In the submit handler function, access the connected DOM elements via the Refs
    and read the currently entered or selected values.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提交处理函数中，通过Refs访问连接的DOM元素并读取当前输入或选择的值。
- en: Output the values to the browser console.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值输出到浏览器控制台。
- en: '![img](img/1.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/1.png)'
- en: 'The expected result (user interface) should look like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的结果（用户界面）应如下所示：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_07_09.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B31339_07_09.png)'
- en: 'Figure 7.9: The browser developer tools console outputs the selected values'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：浏览器开发者工具控制台输出所选值
- en: ￼ **Note**
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You will find all code files used for this activity, as well as the solution,
    at [ttps://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-1)
    .
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在这个活动中找到所有用于此活动的代码文件以及解决方案，可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-1)找到。
- en: 'Activity 7.2: Add a Side Drawer'
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动7.2：添加侧边抽屉
- en: In this activity, you will connect an already existing `SideDrawer` component
    with a button in the main navigation bar to open the side drawer (i.e., display
    it) whenever the button is clicked. After the side drawer opens, a click on the
    backdrop should close the drawer again.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将连接一个已经存在的`SideDrawer`组件与主导航栏中的按钮，以便在点击按钮时打开侧边抽屉（即显示它）。侧边抽屉打开后，点击背景应再次关闭抽屉。
- en: In addition to implementing the general logic described above, your goal will
    be to ensure proper positioning in the final DOM so that no other elements are
    overlaid on top of the `SideDrawer` (without editing any CSS code). The `SideDrawer`
    should also not be nested in any other components or JSX elements.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实现上述的一般逻辑外，你的目标将是确保在最终DOM中的正确定位，以便没有其他元素覆盖在`SideDrawer`之上（无需编辑任何CSS代码）。`SideDrawer`也不应嵌套在任何其他组件或JSX元素中。
- en: '**Note**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'This activity comes with some starting code, which can be found here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-2-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-2-start)
    .'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动附带一些起始代码，可以在以下位置找到：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-2-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-2-start)。
- en: 'After downloading the code and running `npm install` to install all the required
    dependencies, the solution steps are as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下载代码并运行`npm install`以安装所有必需的依赖项后，解决方案步骤如下：
- en: Add logic to conditionally show or hide the `SideDrawer` component in the `MainNavigation`
    component.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainNavigation`组件中添加逻辑，以有条件地显示或隐藏`SideDrawer`组件。
- en: Add an *injection hook* for the side drawer in the HTML document.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文档中为侧边抽屉添加一个*注入钩子*。
- en: Use React’s portal feature to render the JSX elements of `SideDrawer` in the
    newly added hook.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用React的portal功能在新增的钩子中渲染`SideDrawer`的JSX元素。
- en: 'The final user interface should look and behave like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的用户界面应看起来和表现如下：
- en: '![img](img/B31339_07_10.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_07_10.png)'
- en: 'Figure 7.10: A click on the menu button opens the side drawer'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：点击菜单按钮打开侧边抽屉
- en: Upon clicking on the menu button, the side drawer opens. If the backdrop behind
    the side drawer is clicked, it should close again.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 点击菜单按钮后，侧边抽屉打开。如果点击侧边抽屉背后的背景，它应该再次关闭。
- en: 'The final DOM structure (with the side drawer opened) should look like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的DOM结构（侧边抽屉已打开）应如下所示：
- en: '![img](img/B31339_07_11.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_07_11.png)'
- en: 'Figure 7.11: The drawer-related elements are inserted in a separate place in
    the DOM'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：与抽屉相关的元素在DOM中插入到单独的位置
- en: The side drawer-related DOM elements (the `<div>` backdrop and `<aside>` ) are
    inserted into a separate DOM node ( `<div id="drawer">` ).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 与侧边抽屉相关的DOM元素（背景`<div>`和`<aside>`）被插入到一个单独的DOM节点中（`<div id="drawer">`）。
- en: '**Note**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You will find all code files used for this activity, as well as the solution,
    at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-2)
    .
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在这个活动中找到所有用于此活动的代码文件，以及解决方案，请访问[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-2)。
