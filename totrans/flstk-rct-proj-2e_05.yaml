- en: Building a Backend with MongoDB, Express, and Node
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB、Express和Node构建后端
- en: While developing different web applications, you will find there are common
    tasks, basic features, and implementation code repeated across the process. The
    same is true for the MERN applications that will be developed in this book. Taking
    these similarities into consideration, we will first lay the foundations for a
    skeleton MERN application that can be easily modified and extended to implement
    a variety of MERN applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发不同的网络应用程序时，你会发现过程中有常见的任务、基本功能和重复的实现代码。对于本书中将开发的MERN应用程序也是如此。考虑到这些相似之处，我们首先将建立一个可轻松修改和扩展以实现各种MERN应用程序的框架MERN应用程序的基础。
- en: 'In this chapter, we will cover the following topics and start with the backend
    implementation of the MERN skeleton using Node, Express, and MongoDB:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题，并从使用Node、Express和MongoDB实现的MERN框架的后端实现开始：
- en: Overview of the skeleton application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架应用程序概述
- en: Backend code setup
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端代码设置
- en: User model with Mongoose
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mongoose的用户模型
- en: User CRUD API endpoints with Express
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express的用户CRUD API端点
- en: User Auth with JSON Web Tokens
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON Web Tokens进行用户认证
- en: Running backend code and checking APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行后端代码并检查API
- en: Overview of the skeleton application
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架应用程序概述
- en: The skeleton application will encapsulate rudimentary features and a workflow
    that's repeated for most MERN applications. We will build the skeleton as a basic
    but fully functioning MERN web application with user **create**, **read**, **update**,
    **delete** (**CRUD**), and **auth**entication-**auth**orization (**auth**) capabilities;
    this will also demonstrate how to develop, organize, and run code for general
    web applications built using this stack. The aim is to keep the skeleton as simple
    as possible so that it is easy to extend and can be used as a base application
    for developing different MERN applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 框架应用程序将封装基本功能和大多数MERN应用程序中重复的工作流程。我们将构建一个基本但功能齐全的MERN网络应用程序，具有用户**创建**、**读取**、**更新**、**删除**（**CRUD**）和**认证**-**授权**（**auth**）功能；这还将展示如何使用此堆栈开发、组织和运行通用网络应用程序的代码。目标是使框架尽可能简单，以便易于扩展，并可作为开发不同MERN应用程序的基础应用程序。
- en: Feature breakdown
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能分解
- en: 'In the skeleton application, we will add the following use cases with user
    CRUD and auth functionality implementations:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架应用程序中，我们将添加以下用例，包括用户CRUD和auth功能实现：
- en: '**Sign up**: Users can register by creating a new account using an email address.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册**：用户可以通过使用电子邮件地址创建新账户进行注册。'
- en: '**User list**: Any visitor can see a list of all registered users.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户列表**：任何访客都可以看到所有注册用户的列表。'
- en: '**Authentication**: Registered users can sign-in and sign-out.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：注册用户可以登录和登出。'
- en: '**Protected user profile**: Only registered users can view individual user
    details after signing in.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护的用户资料**：只有注册用户在登录后才能查看个人用户详情。'
- en: '**Authorized user edit and delete**: Only a registered and authenticated user
    can edit or remove their own user account details.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权用户编辑和删除**：只有注册并认证的用户可以编辑或删除自己的用户账户详情。'
- en: With these features, we will have a simple working web application that supports
    user accounts. We will start building this basic web application with the backend
    implementation, then integrate a React frontend to complete the full stack.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些功能，我们将拥有一个简单的运行中的网络应用程序，支持用户账户。我们将从后端实现开始构建这个基本网络应用程序，然后集成React前端以完成全栈。
- en: Defining the backend components
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义后端组件
- en: In this chapter, we will focus on building a working backend for the skeleton
    application with Node, Express, and MongoDB. The completed backend will be a standalone
    server-side application that can handle HTTP requests to create a user, list all
    users, and view, update, or delete a user in the database while taking user authentication
    and authorization into consideration.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于使用Node、Express和MongoDB构建一个工作后端框架，该后端将是一个独立的服务器端应用程序，可以处理创建用户、列出所有用户、在数据库中查看、更新或删除用户等HTTP请求，同时考虑用户认证和授权。
- en: User model
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户模型
- en: 'The user model will define the user details to be stored in the MongoDB database,
    and also handle user-related business logic such as password encryption and user
    data validation. The user model for this skeletal version will be basic with support
    for the following attributes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 用户模型将定义要存储在MongoDB数据库中的用户详情，并处理与用户相关的业务逻辑，如密码加密和用户数据验证。此版本的用户模型将是基本的，支持以下属性：
- en: '| **Field name** | **Type** | **Description** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **字段名称** | **类型** | **描述** |'
- en: '| `name` | String | Required field to store the user''s name. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `name` | 字符串 | 存储用户名称的必填字段。|'
- en: '| `email` | String | Required unique field to store the user''s email and identify
    each account (only one account allowed per unique email). |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `email` | 字符串 | 必需的唯一字段，用于存储用户的电子邮件并识别每个账户（每个唯一电子邮件地址仅允许一个账户）。|'
- en: '| `password` | String | A required field for authentication. The database will
    store the encrypted password and not the actual string for security purposes.
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `password` | 字符串 | 认证所需的字段。出于安全目的，数据库将存储加密后的密码，而不是实际字符串。|'
- en: '| `created` | Date | Automatically generated timestamp when a new user account
    is created. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `created` | 日期 | 创建新用户账户时自动生成的时间戳。|'
- en: '| `updated` | Date | Automatically generated timestamp when existing user details
    are updated. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `updated` | 日期 | 更新现有用户详细信息时自动生成的时间戳。|'
- en: When we build applications by extending this skeleton, we can add more fields
    as required. But starting with these fields will be enough to identify unique
    user accounts, and also for implementing user CRUD operation-related features.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过扩展此骨架构建应用程序时，我们可以根据需要添加更多字段。但以这些字段开始将足以识别唯一的用户账户，并且还可以实现与用户 CRUD 操作相关的功能。
- en: API endpoints for user CRUD
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户 CRUD 的 API 端点
- en: 'To enable and handle user CRUD operations on the user database, the backend
    will implement and expose API endpoints that the frontend can utilize in the views,
    as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在用户数据库上启用和处理用户 CRUD 操作，后端将实现并公开前端可以在视图中使用的 API 端点，如下所示：
- en: '| **Operation** | **API route** | **HTTP method** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **API 路由** | **HTTP 方法** |'
- en: '| Create a user | `/api/users` | `POST` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 创建用户 | `/api/users` | `POST` |'
- en: '| List all users | `/api/users` | `GET` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 列出所有用户 | `/api/users` | `GET` |'
- en: '| Fetch a user | `/api/users/:userId` | `GET` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 获取用户 | `/api/users/:userId` | `GET` |'
- en: '| Update a user | `/api/users/:userId` | `PUT` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 更新用户 | `/api/users/:userId` | `PUT` |'
- en: '| Delete a user | `/api/users/:userId` | `DELETE` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 删除用户 | `/api/users/:userId` | `DELETE` |'
- en: '| User sign-in | `/auth/signin` | `POST` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 用户登录 | `/auth/signin` | `POST` |'
- en: '| User signout (optional) | `/auth/signout` | `GET` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 用户登出（可选） | `/auth/signout` | `GET` |'
- en: Some of these user CRUD operations will have protected access, which will require
    the requesting client to be authenticated, authorized, or both, as defined by
    the feature specifications. The last two routes in the table are for authentication
    and will allow the user to sign-in and sign-out. For the applications developed
    in this book, we will use the JWT mechanism to implement these authentication
    features, as discussed in more detail in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用户 CRUD 操作中的一些将具有受保护访问权限，这要求请求客户端进行认证、授权或两者兼而有之，具体取决于功能规范。表中最后两个路由用于认证，将允许用户登录和登出。对于本书中开发的应用程序，我们将使用
    JWT 机制来实现这些认证功能，如下一节中更详细地讨论。
- en: Auth with JSON Web Tokens
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSON Web Tokens 进行认证
- en: To restrict and protect access to user API endpoints according to the skeleton
    features, the backend will need to incorporate authentication and authorization
    mechanisms. There are a number of options when it comes to implementing user auth
    for web applications. The most common and time-tested option is the use of sessions
    to store user state on both the client and server-side. But a newer approach is the
    use of **JSON Web Token** (**JWT**) as a stateless authentication mechanism that
    does not require storing user state on the server side.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了根据骨架功能限制和保护对用户 API 端点的访问，后端需要整合认证和授权机制。在实现 Web 应用程序的用户认证方面有许多选择。最常见且经过时间考验的选项是在客户端和服务器端使用会话来存储用户状态。但一种较新的方法是使用
    **JSON Web Token**（JWT）作为无状态认证机制，它不需要在服务器端存储用户状态。
- en: Both approaches have strengths for relevant real-world use cases. However, for
    the purpose of keeping the code simple in this book, and because it pairs well
    with the MERN stack and our example applications, we will use JWT for auth implementation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法在相关的现实世界用例中都有其优势。然而，为了保持本书中的代码简单，并且因为它与 MERN 栈和我们的示例应用程序配合良好，我们将使用 JWT
    进行认证实现。
- en: How JWT works
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JWT 的工作原理
- en: 'Before diving into the implementation of authentication with JWT in the MERN
    stack, we will look at how this mechanism generally works across a client-server
    application, as outlined in the following diagram:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入到 MERN 栈中 JWT 认证的实现之前，我们将查看这种机制通常如何在客户端-服务器应用程序中工作，如下面的图所示：
- en: '![](img/37d37ce8-62c0-4627-9f8f-c25a5c63b36f.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37d37ce8-62c0-4627-9f8f-c25a5c63b36f.png)'
- en: Initially, when a user signs in using their credentials, the server-side generates
    a JWT signed with a secret key and a unique user detail. Then, this token is returned
    to the requesting client to be saved locally either in `localStorage`, `sessionStorage` or
    a cookie in the browser, essentially handing over the responsibility for maintaining
    user state to the client-side.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，当用户使用其凭据登录时，服务器端生成一个带有秘密密钥和唯一用户详情的 JWT。然后，此令牌将返回给请求客户端以在本地保存，无论是 `localStorage`、`sessionStorage`
    还是浏览器中的 cookie，本质上是将维护用户状态的责任交给了客户端。
- en: 'For HTTP requests that are made following a successful sign-in, especially
    requests for API endpoints that are protected and have restricted access, the
    client-side has to attach this token to the request. More specifically, the `JSON
    Web Token` must be included in the request `Authorization` header as a `Bearer`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在成功登录后发出的 HTTP 请求，特别是对受保护和有限访问的 API 端点的请求，客户端必须将此令牌附加到请求中。更具体地说，`JSON Web
    Token` 必须包含在请求的 `Authorization` 标头中，作为 `Bearer`：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When the server receives a request for a protected API endpoint, it checks the
    `Authorization` header of the request for a valid JWT, then verifies the signature
    to identify the sender and ensures the request data was not corrupted. If the
    token is valid, the requesting client is given access to the associated operation
    or resource; otherwise, an authorization error is returned.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器收到对受保护 API 端点的请求时，它会检查请求的 `Authorization` 标头中的有效 JWT，然后验证签名以识别发送者并确保请求数据未被损坏。如果令牌有效，请求客户端将被授予访问相关操作或资源的权限；否则，将返回授权错误。
- en: In the skeleton application, when a user signs in with their email and password,
    the backend will generate a signed JWT with the user's ID and with a secret key
    that's available only on the server. This token will then be required for verification
    when a user tries to view any user profiles, update their account details, or
    delete their user account.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在骨架应用程序中，当用户使用他们的电子邮件和密码登录时，后端将生成一个带有用户 ID 和仅在服务器上可用的秘密密钥的已签名 JWT。然后，当用户尝试查看任何用户资料、更新他们的账户详情或删除他们的用户账户时，此令牌将用于验证。
- en: Implementing the user model to store and validate user data, then integrating
    it with APIs to perform CRUD operations based on auth with JWT, will produce a
    functioning standalone backend. In the rest of this chapter, we will look at how
    to achieve this in the MERN stack and setup.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实现用户模型以存储和验证用户数据，然后将其与 API 集成以执行基于 JWT 的 CRUD 操作，这将产生一个功能独立的后端。在本章的其余部分，我们将探讨如何在
    MERN 框架中实现这一点并设置。
- en: Setting up the skeleton backend
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置后端骨架
- en: To start developing the backend part of the MERN skeleton, we will set up the
    project folder, install and configure the necessary Node modules, and then prepare
    run scripts to aid development and run the code. Then, we will go through the
    code step by step to implement a working Express server, a user model with Mongoose,
    API endpoints with Express router, and JWT-based auth to meet the specifications
    we defined earlier for user-oriented features.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始开发 MERN 骨架的后端部分，我们将设置项目文件夹，安装和配置必要的 Node 模块，然后准备运行脚本以帮助开发和运行代码。然后，我们将逐步分析代码以实现一个工作的
    Express 服务器、带有 Mongoose 的用户模型、Express 路由器上的 API 端点以及基于 JWT 的身份验证，以满足我们之前定义的用户功能规格。
- en: The code that will be discussed in this chapter, as well as the complete skeleton
    application, is available on GitHub at[ https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter03%20and%2004/mern-skeleton](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter03%20and%2004/mern-skeleton) . The
    code for just the backend is available at the same repository in the branch named
    `mern2-skeleton-backend`. You can clone this code and run the application as you
    go through the code explanations in the rest of this chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论的代码以及完整的骨架应用程序可在 GitHub 上找到[ https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter03%20and%2004/mern-skeleton](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter03%20and%2004/mern-skeleton)
    。仅后端代码可在同一存储库的 `mern2-skeleton-backend` 分支中找到。您可以将此代码克隆并运行，在阅读本章其余部分的代码解释时进行操作。
- en: Folder and file structure
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件夹和文件结构
- en: 'As we go through our setup and implementation in the rest of this chapter,
    we will end up with the following folder structure containing files that are relevant
    to the MERN skeleton backend. With these files, we will have a functioning, standalone
    server-side application:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将通过设置和实现，最终得到以下文件夹结构，其中包含与 MERN 骨架后端相关的文件。有了这些文件，我们将拥有一个功能齐全的、独立的后端服务器应用程序：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will keep the configuration files in the root directory and the backend-related
    code in the `server` folder. Within the `server` folder, we will divide the backend
    code into modules containing models, controllers, routes, helpers, and common
    server-side code. This folder structure will be further expanded in the next chapter,
    where we'll complete the skeleton application by adding a React frontend.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把配置文件放在根目录下，把与后端相关的代码放在 `server` 文件夹中。在 `server` 文件夹内，我们将后端代码划分为包含模型、控制器、路由、辅助函数和通用服务器端代码的模块。这个文件夹结构将在下一章中进一步扩展，届时我们将通过添加
    React 前端来完成骨架应用程序。
- en: Initializing the project
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化项目
- en: If your development environment is already set up, you can initialize the MERN
    project to start developing the backend. First, we will initialize `package.json`
    in the project folder, configure and install any development dependencies, set
    configuration variables to be used in the code, and update `package.json` with
    run scripts to help develop and run the code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的开发环境已经设置好，你可以初始化 MERN 项目以开始开发后端。首先，我们将从项目文件夹中初始化 `package.json`，配置和安装任何开发依赖项，设置代码中使用的配置变量，并在
    `package.json` 中更新运行脚本以帮助开发和运行代码。
- en: Adding package.json
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 package.json
- en: We will need a `package.json` file to store meta information about the project,
    list module dependencies with version numbers, and to define run scripts. To initialize
    a `package.json` file in the project folder, go to the project folder from the
    command line and run `yarn init`, then follow the instructions to add the necessary
    details. With `package.json` created, we can proceed with setup and development
    and update the file as more modules are required throughout code implementation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个 `package.json` 文件来存储关于项目的元信息，列出带有版本号的模块依赖项，并定义运行脚本。要在项目文件夹中初始化 `package.json`
    文件，从命令行进入项目文件夹，运行 `yarn init`，然后按照指示添加必要的详细信息。创建 `package.json` 后，我们可以继续设置和开发，并在代码实现过程中需要更多模块时更新该文件。
- en: Development dependencies
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发依赖项
- en: In order to begin the development process and run the backend server code, we
    will configure and install Babel, Webpack, and Nodemon, as discussed in Chapter
    2*,* *Preparing the Development Environment*, and make some minor adjustments
    to the backend.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始开发过程并运行后端服务器代码，我们将配置和安装 Babel、Webpack 和 Nodemon，如第 2 章所述，*准备开发环境*，并对后端进行一些小的调整。
- en: Babel
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Babel
- en: Since we will be using ES6+ and the latest JS features in the backend code,
    we will install and configure Babel modules to convert ES6+ into older versions
    of JS so that it's compatible with the Node version being used.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在后端代码中使用 ES6+ 和最新的 JS 特性，我们将安装和配置 Babel 模块将 ES6+ 转换为较旧的 JS 版本，以便与正在使用的
    Node 版本兼容。
- en: First, we'll configure Babel in the `.babelrc` file with presets for the latest
    JS features and specify the current version of Node as the target environment.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在 `.babelrc` 文件中配置 Babel，使用最新的 JS 特性预设，并指定当前版本的 Node 作为目标环境。
- en: '`mern-skeleton/.babelrc`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/.babelrc`:'
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Setting `targets.node` to `current` instructs Babel to compile against the current
    version of Node and allows us to use expressions such as `async/await` in our
    backend code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `targets.node` 设置为 `current` 指示 Babel 编译针对当前版本的 Node，并允许我们在后端代码中使用 `async/await`
    等表达式。
- en: 'Next, we need to install the Babel modules as `devDependencies` from the command
    line:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从命令行安装 Babel 模块作为 `devDependencies`：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once the module installations are done, you will notice that the `devDependencies`
    list has been updated in the `package.json` file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成模块安装，你将注意到 `package.json` 文件中的 `devDependencies` 列表已经更新。
- en: Webpack
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack
- en: We will need Webpack to compile and bundle the server-side code using Babel.
    For configuration, we can use the same `webpack.config.server.js` we discussed
    in Chapter 2, *Preparing the Development Environment*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 Webpack 来使用 Babel 编译和打包服务器端代码。对于配置，我们可以使用第 2 章中讨论的相同的 `webpack.config.server.js`。
- en: 'From the command line, run the following command to install `webpack`, `webpack-cli`,
    and the `webpack-node-externals` module:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行运行以下命令以安装`webpack`、`webpack-cli`和`webpack-node-externals`模块：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will install the Webpack modules and update the `package.json` file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装Webpack模块并更新`package.json`文件。
- en: Nodemon
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nodemon
- en: To automatically restart the Node server as we update our code during development,
    we will use Nodemon to monitor the server code for changes. We can use the same
    installation and configuration guidelines we discussed in Chapter 2, *Preparing
    the Development Environment*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新代码期间自动重启Node服务器，我们将使用Nodemon来监控服务器代码的更改。我们可以使用我们在第2章“准备开发环境”中讨论的相同安装和配置指南。
- en: Before we add run scripts to start developing and running the backend code,
    we will define configuration variables for values that are used across the backend
    implementation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加运行脚本以开始开发和运行后端代码之前，我们将定义跨后端实现使用的值配置变量。
- en: Config variables
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置变量
- en: In the `config/config.js` file, we will define some server-side configuration-related
    variables that will be used in the code but should not be hardcoded as a best
    practice, as well as for security purposes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`config/config.js`文件中，我们将定义一些服务器端配置相关的变量，这些变量将在代码中使用，但应作为最佳实践避免硬编码，以及出于安全考虑。
- en: '`mern-skeleton/config/config.js`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/config/config.js`：'
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The config variables that were defined are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 定义好的配置变量如下：
- en: '`env`: To differentiate between development and production modes'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`：用于区分开发和生产模式'
- en: '`port`: To define the listening port for the server'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`：用于定义服务器的监听端口'
- en: '`jwtSecret`: The secret key to be used to sign JWT'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jwtSecret`：用于签名JWT的秘密密钥'
- en: '`mongoUri`: The location of the MongoDB database instance for the project'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongoUri`：项目MongoDB数据库实例的位置'
- en: These variables will give us the flexibility to change values from a single
    file and use it across the backend code. Next, we will add the run scripts, which
    will allow us to run and debug the backend implementation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量将使我们能够从单个文件更改值并在后端代码中使用它。接下来，我们将添加运行脚本，这将允许我们运行和调试后端实现。
- en: Running scripts
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行脚本
- en: To run the server as we develop the code for only the backend, we can start
    with the `yarn development` script in the `package.json` file. For the complete
    skeleton application, we will use the same run scripts we defined in Chapter 2,
    *Preparing the Development Environment*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要在开发后端代码时运行服务器，我们可以从`package.json`文件中的`yarn development`脚本开始。对于完整的骨架应用程序，我们将使用我们在第2章“准备开发环境”中定义的相同运行脚本。
- en: '`mern-skeleton/package.json`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/package.json`：'
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this script added, running `yarn development` in the command line from
    your project folder will basically start Nodemon according to the configuration
    in `nodemon.json`. The configuration instructs Nodemon to monitor server files
    for updates and, on update, to build the files again, then restart the server
    so that the changes are immediately available. We will begin by implementing a
    working server with this configuration in place.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此脚本后，从项目文件夹中运行命令行中的`yarn development`将基本上根据`nodemon.json`中的配置启动Nodemon。配置指示Nodemon监控服务器文件以进行更新，并在更新时重新构建文件，然后重启服务器，以便更改立即可用。我们将从实现具有此配置的工作服务器开始。
- en: Preparing the server
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备服务器
- en: In this section, we will integrate Express, Node, and MongoDB in order to run
    a completely configured server before we start implementing user-specific features.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在开始实现用户特定功能之前，将Express、Node和MongoDB集成在一起，以运行一个完全配置的服务器。
- en: Configuring Express
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Express
- en: To use Express, we will install it and then add and configure it in the `server/express.js` file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Express，我们将安装它，然后在`server/express.js`文件中添加和配置它。
- en: 'From the command line, run the following command to install the `express` module
    and to have the `package.json` file automatically updated:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行运行以下命令以安装`express`模块并自动更新`package.json`文件：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once Express has been installed, we can import it into the `express.js` file,
    configure it as required, and make it available to the rest of the app.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Express安装后，我们可以将其导入到`express.js`文件中，按需配置它，并使其对整个应用程序可用。
- en: '`mern-skeleton/server/express.js`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/express.js`：'
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To handle HTTP requests and serve responses properly, we will use the following
    modules to configure Express:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确处理HTTP请求并提供服务，我们将使用以下模块来配置Express：
- en: '`body-parser`: Request body-parsing middleware to handle the complexities of
    parsing streamable request objects so that we can simplify browser-server communication
    by exchanging JSON in the request body. To install the module, run `yarn add body-parser` from
    the command line. Then, configure the Express app with `bodyParser.json()` and `bodyParser.urlencoded({
    extended: true })`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body-parser`: 请求体解析中间件，用于处理解析可流式请求对象的复杂性，以便我们可以通过在请求体中交换 JSON 来简化浏览器-服务器通信。要安装此模块，请在命令行中运行
    `yarn add body-parser`。然后，使用 `bodyParser.json()` 和 `bodyParser.urlencoded({ extended:
    true })` 配置 Express 应用。'
- en: '`cookie-parser`: Cookie parsing middleware to parse and set cookies in request
    objects. To install the `cookie-parser` module, run `yarn add cookie-parser` from
    the command line.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookie-parser`: 解析和设置请求对象中的 Cookie 的解析中间件。要安装 `cookie-parser` 模块，请在命令行中运行
    `yarn add cookie-parser`。'
- en: '`compression`: Compression middleware that will attempt to compress response
    bodies for all requests that traverse through the middleware. To install the `compression`
    module, run `yarn add compression` from the command line.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compression`: 尝试压缩所有通过中间件传输的请求响应体的压缩中间件。要安装 `compression` 模块，请在命令行中运行 `yarn
    add compression`。'
- en: '`helmet`: Collection of middleware functions to help secure Express apps by
    setting various HTTP headers. To install the `helmet` module, run `yarn add helmet` from
    the command line.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`helmet`: 通过设置各种 HTTP 头来帮助保护 Express 应用的中间件集合。要安装 `helmet` 模块，请在命令行中运行 `yarn
    add helmet`。'
- en: '`cors`: Middleware to enable **cross-origin resource sharing** (**CORS**).
    To install the `cors` module, run `yarn add cors` from the command line.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cors`: 允许**跨源资源共享**（**CORS**）的中间件。要安装 `cors` 模块，请在命令行中运行 `yarn add cors`。'
- en: After the preceding modules have been installed, we can update `express.js`
    to import these modules and configure the Express app before exporting it for
    use in the rest of the server code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了前面的模块之后，我们可以更新 `express.js` 以导入这些模块，并在将其导出以供服务器代码的其余部分使用之前配置 Express 应用。
- en: 'The updated `mern-skeleton/server/express.js` code should be as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的 `mern-skeleton/server/express.js` 代码应如下所示：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Express app can now accept and process information from incoming HTTP requests,
    for which we first need to start a server using this app.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Express 应用现在可以接受和处理来自传入 HTTP 请求的信息，为此我们首先需要使用此应用启动一个服务器。
- en: Starting the server
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动服务器
- en: With the Express app configured to accept HTTP requests, we can go ahead and
    use it to implement a server that can listen for incoming requests.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 Express 应用以接受 HTTP 请求后，我们可以继续使用它来实现一个可以监听传入请求的服务器。
- en: 'In the `mern-skeleton/server/server.js` file, add the following code to implement
    the server:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mern-skeleton/server/server.js` 文件中，添加以下代码以实现服务器：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we import the config variables to set the port number that the server
    will listen on and then import the configured Express app to start the server.
    To get this code running and continue development, we can run `yarn development` from
    the command line. If the code has no errors, the server should start running with
    Nodemon monitoring for code changes. Next, we will update this server code to
    integrate the database connection.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入配置变量以设置服务器将监听的端口号，然后导入配置好的 Express 应用以启动服务器。要运行此代码并继续开发，我们可以在命令行中运行 `yarn
    development`。如果代码没有错误，服务器应该会启动运行，Nodemon 会监控代码更改。接下来，我们将更新此服务器代码以集成数据库连接。
- en: Setting up Mongoose and connecting to MongoDB
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Mongoose 并连接到 MongoDB
- en: We will be using the `mongoose` module to implement the user model in this skeleton,
    as well as all future data models for our MERN applications. Here, we will start
    by configuring Mongoose and utilizing it to define a connection with the MongoDB
    database.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `mongoose` 模块来实现此骨架中的用户模型，以及所有未来 MERN 应用的数据模型。在这里，我们将首先配置 Mongoose 并利用它来定义与
    MongoDB 数据库的连接。
- en: 'First, to install the `mongoose` module, run the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要安装 `mongoose` 模块，请运行以下命令：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then, update the `server.js` file to import the `mongoose` module, configure
    it so that it uses native ES6 promises, and finally use it to handle the connection
    to the MongoDB database for the project.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新 `server.js` 文件以导入 `mongoose` 模块，配置它以使用原生 ES6 promises，并最终使用它来处理项目与 MongoDB
    数据库的连接。
- en: '`mern-skeleton/server/server.js`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/server.js`:'
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you have the code running in development and also have MongoDB running, saving
    this update should successfully restart the server, which is now integrated with
    Mongoose and MongoDB.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发环境中运行代码，并且 MongoDB 也正在运行，保存此更新应该可以成功重启服务器，现在该服务器已集成 Mongoose 和 MongoDB。
- en: Mongoose is a MongoDB object modeling tool that provides a schema-based solution
    to model application data. It includes built-in type casting, validation, query
    building, and business logic hooks. Using Mongoose with this backend stack provides
    a higher layer over MongoDB with more functionality, including mapping object
    models to database documents. This makes it simpler and more productive to develop
    with a Node and MongoDB backend. To learn more about Mongoose, visit [mongoosejs.com](http://mongoosejs.com).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 是一个 MongoDB 对象建模工具，它提供了一个基于模式的解决方案来建模应用程序数据。它包括内置的类型转换、验证、查询构建和业务逻辑钩子。使用
    Mongoose 与此后端堆栈一起提供 MongoDB 之上的更高层，具有更多功能，包括将对象模型映射到数据库文档。这使得使用 Node 和 MongoDB
    后端进行开发更加简单和高效。要了解更多关于 Mongoose 的信息，请访问 [mongoosejs.com](http://mongoosejs.com)。
- en: With an Express app configured, the database integrated with Mongoose, and a
    listening server ready, we can add code to load an HTML view from this backend.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置了 Express 应用程序、数据库集成 Mongoose 以及准备就绪的监听服务器后，我们可以添加代码以从后端加载 HTML 视图。
- en: Serving an HTML template at a root URL
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在根 URL 上提供 HTML 模板
- en: With a Node- Express- and MongoDB- enabled server now running, we can extend
    it so that it serves an HTML template in response to an incoming request at the
    root URL `/`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个启用了 Node-Express-和 MongoDB 服务器正在运行，我们可以扩展它，使其能够响应根 URL `/` 的传入请求来提供 HTML
    模板。
- en: In the `template.js` file, add a JS function that returns a simple HTML document
    that will render `Hello World` on the browser screen.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `template.js` 文件中，添加一个 JS 函数，该函数返回一个简单的 HTML 文档，将在浏览器屏幕上渲染“Hello World”。
- en: '`mern-skeleton/template.js`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/template.js`:'
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To serve this template at the root URL, update the `express.js` file to import
    this template and send it in the response to a GET request for the `'/'` route.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要在根 URL 上提供此模板，更新 `express.js` 文件以导入此模板，并在对 `'/'` 路由的 GET 请求中将其发送作为响应。
- en: '`mern-skeleton/server/express.js`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/express.js`:'
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this update, opening the root URL in a browser should show Hello World
    rendered on the page. If you are running the code on your local machine, the root
    URL will be `http://localhost:3000/`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此更新，在浏览器中打开根 URL 应该会显示在页面上渲染的“Hello World”。如果你在本地机器上运行代码，根 URL 将是 `http://localhost:3000/`。
- en: At this point, the backend Node- Express- and MongoDB-based server that we can
    build on to add user-specific features.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以构建在基于 Node-Express-和 MongoDB 的后端服务器上，以添加特定于用户的功能。
- en: Implementing the user model
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现用户模型
- en: We will implement the user model in the `server/models/user.model.js` file and
    use Mongoose to define the schema with the necessary user data fields. We're doing
    this so that we can add built-in validation for the fields and incorporate business
    logic such as password encryption, authentication, and custom validation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `server/models/user.model.js` 文件中实现用户模型，并使用 Mongoose 定义包含必要用户数据字段的模式。我们这样做是为了可以对字段添加内置验证，并集成如密码加密、身份验证和自定义验证等业务逻辑。
- en: We will begin by importing the `mongoose` module and use it to generate a `UserSchema`,
    which will contain the schema definition and user-related business logic to make
    up the user model. This user model will be exported so that it can be used by
    the rest of the backend code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先导入 `mongoose` 模块，并使用它来生成一个 `UserSchema`，它将包含模式定义和与用户相关的业务逻辑，以构成用户模型。这个用户模型将被导出，以便其余的后端代码可以使用它。
- en: '`mern-skeleton/server/models/user.model.js`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/models/user.model.js`:'
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `mongoose.Schema()` function takes a schema definition object as a parameter
    to generate a new Mongoose schema object that will specify the properties or structure
    of each document in a collection. We will discuss this schema definition for the
    User collection before we add any business logic code to complete the user model.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`mongoose.Schema()` 函数接受一个模式定义对象作为参数，以生成一个新的 Mongoose 模式对象，该对象将指定集合中每个文档的属性或结构。在我们添加任何业务逻辑代码以完成用户模型之前，我们将讨论用户集合的模式定义。'
- en: User schema definition
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户模式定义
- en: The user schema definition object that's needed to generate the new Mongoose
    schema will declare all user data fields and associated properties. The schema
    will record user-related information including name, email, created-at and last-updated-at
    timestamps, hashed passwords, and the associated unique password salt. We will
    elaborate on these properties next, showing you how each field is defined in the
    user schema code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 需要生成新Mongoose模式的用户模式定义对象将声明所有用户数据字段和相关属性。该模式将记录与用户相关的信息，包括名称、电子邮件、创建时间和最后更新时间戳、哈希密码以及相关的唯一密码盐。我们将在下一节中详细说明这些属性，展示每个字段如何在用户模式代码中定义。
- en: Name
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名称
- en: The `name` field is a required field of the `String` type.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`名称`字段是`String`类型的必填字段。'
- en: '`mern-skeleton/server/models/user.model.js`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/models/user.model.js`:'
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This field will store the user's name.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段将存储用户的名称。
- en: Email
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邮箱
- en: The `email` field is a required field of the `String` type.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`电子邮件`字段是`String`类型的必填字段。'
- en: '`mern-skeleton/server/models/user.model.js`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/models/user.model.js`:'
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The value to be stored in this email field must have a valid email format and
    must also be unique in the user collection.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储在此电子邮件字段中的值必须具有有效的电子邮件格式，并且必须在用户集合中是唯一的。
- en: Created and updated timestamps
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和更新时间戳
- en: The `created` and `updated` fields are `Date` values.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`created`和`updated`字段是`Date`值。'
- en: '`mern-skeleton/server/models/user.model.js`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/models/user.model.js`:'
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These `Date` values will be programmatically generated to record timestamps
    that indicate when a user is created and user data is updated.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`Date`值将程序化生成，以记录用户创建和用户数据更新的时间戳。
- en: Hashed password and salt
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希密码和盐
- en: The `hashed_password` and `salt` fields represent the encrypted user password
    that we will use for authentication.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashed_password`和`salt`字段代表用于认证的加密用户密码。'
- en: '`mern-skeleton/server/models/user.model.js`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/models/user.model.js`:'
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The actual password string is not stored directly in the database for security
    purposes and is handled separately, as discussed in the next section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，实际的密码字符串不会直接存储在数据库中，并且将单独处理，如下一节所述。
- en: Password for auth
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于认证的密码
- en: The `password` field is very crucial for providing secure user authentication
    in any application, and each user password needs to be encrypted, validated, and
    authenticated securely as a part of the user model.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`密码`字段对于在任何应用程序中提供安全用户身份验证至关重要，每个用户密码都需要作为用户模型的一部分进行加密、验证和安全的认证。'
- en: Handling the password string as a virtual field
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将密码字符串作为虚拟字段处理
- en: The `password` string that's provided by the user is not stored directly in
    the user document. Instead, it is handled as a `virtual` field.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 用户提供的`密码`字符串不会直接存储在用户文档中。相反，它被处理为一个`虚拟`字段。
- en: '`mern-skeleton/server/models/user.model.js`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/models/user.model.js`:'
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When the `password` value is received on user creation or update, it is encrypted
    into a new hashed value and set to the `hashed_password` field, along with the
    unique `salt` value in the `salt` field.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当在用户创建或更新时接收到`密码`值时，它将被加密成一个新的哈希值，并设置到`hashed_password`字段，同时与`salt`字段中的唯一`盐`值一起。
- en: Encryption and authentication
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密和认证
- en: The encryption logic and salt generation logic, which are used to generate the
    `hashed_password` and `salt` values representing the `password` value, are defined
    as `UserSchema` methods.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 用于生成表示`密码`值的`hashed_password`和`salt`值的加密逻辑和盐生成逻辑被定义为`UserSchema`方法。
- en: '`mern-skeleton/server/models/user.model.js`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/models/user.model.js`:'
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `UserSchema` methods can be used to provide the following functionality:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserSchema`方法可用于提供以下功能：'
- en: '`authenticate`: This method is called to verify sign-in attempts by matching
    the user-provided password text with the `hashed_password` stored in the database
    for a specific user.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authenticate`：此方法被调用以验证登录尝试，通过将用户提供的密码文本与数据库中特定用户的`hashed_password`进行匹配。'
- en: '`encryptPassword`: This method is used to generate an encrypted hash from the
    plain-text password and a unique `salt` value using the `crypto` module from Node.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encryptPassword`：此方法用于使用Node的`crypto`模块从纯文本密码和唯一的`salt`值生成加密哈希。'
- en: '`makeSalt`: This method generates a unique and random salt value using the
    current timestamp at execution and `Math.random()`.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makeSalt`：此方法使用执行时的当前时间戳和`Math.random()`生成一个唯一且随机的盐值。'
- en: The `crypto` module provides a range of cryptographic functionality, including
    some standard cryptographic hashing algorithms. In our code, we use the SHA1 hashing
    algorithm and `createHmac` from `crypto` to generate the cryptographic HMAC hash
    from the password text and `salt` pair.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`crypto`模块提供了各种加密功能，包括一些标准的加密哈希算法。在我们的代码中，我们使用SHA1哈希算法和`crypto`中的`createHmac`来从密码文本和`salt`对生成加密的HMAC哈希。'
- en: Hashing algorithms generate the same hash for the same input value. But to ensure
    two users don't end up with the same hashed password if they happen to use the
    same password text, we pair each password with a unique `salt` value before generating
    the hashed password for each user. This will also make it difficult to guess the
    hashing algorithm being used because the same user input is seemingly generating
    different hashes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希算法为相同的输入值生成相同的哈希。但为了确保两个用户不会因为偶然使用相同的密码文本而得到相同的哈希密码，我们在为每个用户生成哈希密码之前，将每个密码与一个唯一的`salt`值配对。这也会使猜测所使用的哈希算法变得困难，因为看似相同的用户输入生成了不同的哈希。
- en: These `UserSchema` methods are used to encrypt the user-provided password string
    into a `hashed_password` with a randomly generated `salt` value. The `hashed_password`
    and the `salt` are stored in the user document when the user details are saved
    to the database on a create or update. Both the `hashed_password` and `salt` values
    are required in order to match and authenticate a password string provided during
    user sign-in using the `authenticate` method. We should also ensure the user selects
    a strong password string to begin with, which can done by adding custom validation
    to the passport field.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`UserSchema`方法用于将用户提供的密码字符串加密成带有随机生成的`salt`值的`hashed_password`。当用户详细信息在创建或更新时保存到数据库中时，`hashed_password`和`salt`存储在用户文档中。为了匹配和验证用户在登录期间提供的密码字符串，需要这两个值。我们还应该确保用户一开始就选择一个强大的密码字符串，这可以通过添加自定义验证到护照字段来实现。
- en: Password field validation
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码字段验证
- en: To add validation constraints to the actual password string that's selected
    by the end user, we need to add custom validation logic and associate it with
    the `hashed_password` field in the schema.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向最终用户选择的实际密码字符串添加验证约束，我们需要添加自定义验证逻辑并将其与模式中的`hashed_password`字段关联。
- en: '`mern-skeleton/server/models/user.model.js`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/models/user.model.js`:'
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We will keep the password validation criteria simple in our application and
    ensure that a password value is provided and it has a length of at least six characters
    when a new user is created or an existing password is updated. We achieve this
    by adding custom validation to check the password value before Mongoose attempts
    to store the `hashed_password` value. If validation fails, the logic will return
    the relevant error message.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将保持密码验证标准简单，并确保在创建新用户或更新现有密码时提供密码值，并且其长度至少为六个字符。我们通过在Mongoose尝试存储`hashed_password`值之前添加自定义验证来实现这一点。如果验证失败，逻辑将返回相关的错误信息。
- en: The defined `UserSchema`, along with all the password-related business logic,
    completes the user model implementation. Now, we can import and use this user
    model in other parts of the backend code. But before we begin using this model
    to extend backend functionality, we will add a helper module so that we can parse
    readable Mongoose error messages, which are thrown against schema validations.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 定义好的`UserSchema`以及所有与密码相关的业务逻辑，完成了用户模型实现。现在，我们可以导入并使用这个用户模型在其他后端代码的部分。但在我们开始使用这个模型来扩展后端功能之前，我们将添加一个辅助模块，这样我们就可以解析可读的Mongoose错误消息，这些错误消息是在对模式验证进行操作时抛出的。
- en: Mongoose error handling
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mongoose错误处理
- en: The validation constraints that are added to the user schema fields will throw
    error messages if they're violated when user data is saved to the database. To
    handle these validation errors and other errors that the database may throw when
    we make queries to it, we will define a helper method that will return a relevant
    error message that can be propagated in the request-response cycle as appropriate.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户数据保存到数据库中时，如果违反了添加到用户模式字段中的验证约束，将抛出错误消息。为了处理这些验证错误以及数据库在查询时可能抛出的其他错误，我们将定义一个辅助方法，该方法将返回可以在请求-响应周期中适当传播的相关错误消息。
- en: We will add the `getErrorMessage` helper method to the `server/helpers/dbErrorHandler.js`
    file. This method will parse and return the error message associated with the
    specific validation error or other errors that can occur while querying MongoDB
    using Mongoose.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `server/helpers/dbErrorHandler.js` 文件中添加 `getErrorMessage` 辅助方法。此方法将解析并返回与特定验证错误或其他在查询
    MongoDB 时可能发生的错误相关的错误信息。
- en: '`mern-skeleton/server/helpers/dbErrorHandler.js`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/helpers/dbErrorHandler.js`:'
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Errors that are not thrown because of a Mongoose validator violation will contain
    an associated error `code`. In some cases, these errors need to be handled differently.
    For example, errors caused due to a violation of the `unique` constraint will
    return an error object that is different from Mongoose validation errors. The
    `unique` option is not a validator but a convenient helper for building MongoDB
    `unique` indexes, so we will add another `getUniqueErrorMessage` method to parse
    the `unique` constraint-related error object and construct an appropriate error
    message.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Mongoose 验证器违规而未抛出的错误将包含一个相关的错误 `code`。在某些情况下，这些错误需要不同的处理方式。例如，由于违反 `unique`
    约束而引起的错误将返回一个与 Mongoose 验证错误不同的错误对象。`unique` 选项不是一个验证器，而是构建 MongoDB `unique` 索引的方便助手，因此我们将添加另一个
    `getUniqueErrorMessage` 方法来解析与 `unique` 约束相关的错误对象并构建适当的错误信息。
- en: '`mern-skeleton/server/helpers/dbErrorHandler.js`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/helpers/dbErrorHandler.js`:'
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By using the `getErrorMessage` function that's exported from this helper file,
    we can add meaningful error messages when handling errors that are thrown by Mongoose
    operations.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用从该辅助文件导出的 `getErrorMessage` 函数，我们可以在处理由 Mongoose 操作抛出的错误时添加有意义的错误信息。
- en: With the user model completed, we can perform Mongoose operations that are relevant
    to achieving user CRUD functionality with the User APIs we'll develop in the next
    section.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 用户模型完成后，我们可以执行与使用我们将在下一节中开发的用户 API 实现用户 CRUD 功能相关的 Mongoose 操作。
- en: Adding user CRUD APIs
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用户 CRUD API
- en: The user API endpoints exposed by the Express app will allow the frontend to
    perform CRUD operations on documents that are generated according to the user
    model. To implement these working endpoints, we will write Express routes and
    the corresponding controller callback functions that should be executed when HTTP
    requests come in for these declared routes. In this section, we will look at how
    these endpoints work without any auth restrictions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Express 应用程序公开的用户 API 端点将允许前端根据用户模型生成文档执行 CRUD 操作。为了实现这些工作端点，我们将编写 Express
    路由和相应的控制器回调函数，这些函数应在针对这些声明的路由传入 HTTP 请求时执行。在本节中，我们将查看这些端点在没有任何认证限制的情况下是如何工作的。
- en: Our user API routes will be declared using the Express router in `server/routes/user.routes.js`,
    and then mounted on the Express app we configured in `server/express.js`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Express 路由器在 `server/routes/user.routes.js` 中声明用户 API 路由，然后将其挂载到我们在 `server/express.js`
    中配置的 Express 应用程序上。
- en: '`mern-skeleton/server/express.js`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/express.js`:'
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All routes and API endpoints, such as the user-specific routes we'll declare
    next, need to be mounted on the Express app so that they can be accessed from
    the client-side.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 所有路由和 API 端点，例如我们接下来将声明的特定用户路由，都需要挂载到 Express 应用程序上，以便从客户端访问。
- en: User routes
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户路由
- en: The user routes that are defined in the `user.routes.js` file will use `express.Router()`
    to define route paths with the relevant HTTP methods and assign the corresponding
    controller function that should be called when these requests are received by
    the server.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `user.routes.js` 文件中定义的用户路由将使用 `express.Router()` 来定义与相关 HTTP 方法相关的路由路径，并将相应的控制器函数分配给当这些请求被服务器接收时应调用的函数。
- en: 'We will keep the user routes simplistic by using the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下方式保持用户路由的简单性：
- en: '`/api/users` for the following:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/users` 用于以下操作：'
- en: Listing users with GET
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GET 列出用户
- en: Creating a new user with POST
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 POST 创建新用户
- en: '`/api/users/:userId` for the following:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/users/:userId` 用于以下操作：'
- en: Fetching a user with GET
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GET 获取用户
- en: Updating a user with PUT
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PUT 更新用户
- en: Deleting a user with DELETE
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DELETE 删除用户
- en: The resulting `user.routes.js` code will look as follows (without the auth considerations
    that need to be added for protected routes).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 `user.routes.js` 代码将如下所示（不包括需要添加到受保护路由的认证考虑因素）。
- en: '`mern-skeleton/server/routes/user.routes.js`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/routes/user.routes.js`:'
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Besides declaring API endpoints that correspond to user CRUD operations, we'll
    also configure the Express router so that it handles the `userId` parameter in
    a requested route by executing the `userByID` controller function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 除了声明与用户 CRUD 操作对应的 API 端点外，我们还将配置 Express 路由器，以便它通过执行 `userByID` 控制器函数来处理请求路由中的
    `userId` 参数。
- en: When the server receives requests at each of these defined routes, the corresponding
    controller functions are invoked. We will define the functionality for each of
    these controller methods and export it from the `user.controller.js` file in the
    next subsection.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器接收到这些定义的路由中的每个请求时，相应的控制器函数会被调用。我们将在下一小节中定义这些控制器方法的功能，并将其从 `user.controller.js`
    文件中导出。
- en: User controller
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户控制器
- en: The `server/controllers/user.controller.js` file will contain definitions of
    the controller methods that were used in the preceding user route declarations
    as callbacks to be executed when a route request is received by the server.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`server/controllers/user.controller.js` 文件将包含用于先前用户路由声明的控制器方法的定义，这些方法作为回调在服务器接收到路由请求时执行。'
- en: 'The `user.controller.js` file will have the following structure:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`user.controller.js` 文件将具有以下结构：'
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This controller will make use of the `errorHandler` helper to respond to route
    requests with meaningful messages when a Mongoose error occurs. It will also use
    a module called `lodash` when updating an existing user with changed values.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制器将使用 `errorHandler` 辅助函数来响应路由请求，并在发生 Mongoose 错误时返回有意义的消息。在更新具有更改值的现有用户时，它还将使用名为
    `lodash` 的模块。
- en: '`lodash` is a JavaScript library that provides utility functions for common
    programming tasks, including the manipulation of arrays and objects. To install
    `lodash`, run `yarn add lodash` from the command line.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`lodash` 是一个 JavaScript 库，它提供了用于常见编程任务的实用函数，包括数组和对象的操作。要安装 `lodash`，请在命令行中运行
    `yarn add lodash`。'
- en: Each of the controller functions we defined previously is related to a route
    request, and will be elaborated on in relation to each API use case.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的每个控制器函数都与一个路由请求相关联，并将根据每个 API 用例进行详细说明。
- en: Creating a new user
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新用户
- en: The API endpoint to create a new user is declared in the following route.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新用户的 API 端点在以下路由中声明。
- en: '`mern-skeleton/server/routes/user.routes.js`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/routes/user.routes.js`:'
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the Express app gets a POST request at `'/api/users'`, it calls the `create`
    function we defined in the controller.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Express 应用接收到针对 `'/api/users'` 的 POST 请求时，它会调用我们在控制器中定义的 `create` 函数。
- en: '`mern-skeleton/server/controllers/user.controller.js`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/controllers/user.controller.js`:'
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function creates a new user with the user JSON object that's received in
    the POST request from the frontend within `req.body`. The call to `user.save`
    attempts to save the new user in the database after Mongoose has performed a validation
    check on the data. Consequently, an error or success response is returned to the
    requesting client.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用从前端 POST 请求中接收到的用户 JSON 对象在 `req.body` 内创建新用户。调用 `user.save` 尝试在 Mongoose
    对数据进行验证检查后，将新用户保存到数据库中。因此，会向请求客户端返回错误或成功响应。
- en: The `create` function is defined as an asynchronous function with the **async** keyword,
    allowing us to use **await** with `user.save()`, which returns a Promise. Using
    the **await** keyword inside an **async** function causes this function to wait
    until the returned Promise resolves, before the next lines of code are executed.
    If the Promise rejects, an error is thrown and caught in the `catch` block.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 函数被定义为使用 `**async**` 关键字的一个异步函数，允许我们使用 `**await**` 与 `user.save()`
    一起，它返回一个 Promise。在 `**async**` 函数内部使用 `**await**` 关键字会导致此函数在执行下一行代码之前等待返回的 Promise
    解决。如果 Promise 拒绝，则会抛出错误并在 `catch` 块中捕获。'
- en: '`Async/await` is an addition to ES8 that allows us to write asynchronous JavaScript
    code in a seemingly sequential or synchronous manner. For controller functions
    that handle asynchronous behavior such as accessing the database, we will use
    the `async/await` syntax to implement them.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`Async/await` 是 ES8 的一个新增功能，它允许我们以看似顺序或同步的方式编写异步 JavaScript 代码。对于处理异步行为，如访问数据库的控制器函数，我们将使用
    `async/await` 语法来实现它们。'
- en: Similarly, in the next section, we will use `async/await` while implementing
    the controller function to list all users after querying the database.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在下一节中，我们将使用 `async/await` 来实现控制器函数，以便在查询数据库后列出所有用户。
- en: Listing all users
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出所有用户
- en: The API endpoint to fetch all the users is declared in the following route.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 获取所有用户的 API 端点在以下路由中声明。
- en: '`mern-skeleton/server/routes/user.routes.js`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/routes/user.routes.js`:'
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When the Express app gets a GET request at `'/api/users'`, it executes the `list`
    controller function.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Express 应用程序接收到对 `'/api/users'` 的 GET 请求时，它执行 `list` 控制器函数。
- en: '`mern-skeleton/server/controllers/user.controller.js`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/controllers/user.controller.js`:'
- en: '[PRE31]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `list` controller function finds all the users from the database, populates
    only the `name`, `email`, `created`, and `updated` fields in the resulting user
    list, and then returns this list of users as JSON objects in an array to the requesting
    client.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`list` 控制器函数从数据库中查找所有用户，仅在结果用户列表中填充 `name`、`email`、`created` 和 `updated` 字段，然后将此用户列表作为
    JSON 对象数组返回给请求客户端。'
- en: The remaining CRUD operations to read, update, and delete a single user require
    that we retrieve a specific user by ID first. In the next section, we will implement
    the controller functions that enable fetching a single user from the database
    to either return the user, update the user, or delete the user in response to
    the corresponding requests.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的 CRUD 操作，包括读取、更新和删除单个用户，需要我们首先通过 ID 获取特定的用户。在下文中，我们将实现控制器函数，以便从数据库中检索单个用户，以响应相应的请求，返回用户、更新用户或删除用户。
- en: Loading a user by ID to read, update, or delete
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 ID 加载用户以读取、更新或删除
- en: All three API endpoints for read, update, and delete require a user to be loaded
    from the database based on the user ID of the user being accessed. We will program
    the Express router to do this action first before responding to a specific request
    to read, update, or delete.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 读取、更新和删除的所有三个 API 端点都需要根据被访问用户的用户 ID 从数据库中加载用户。我们将编程 Express 路由器首先执行此操作，然后再响应特定的读取、更新或删除请求。
- en: Loading
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载
- en: Whenever the Express app receives a request to a route that matches a path containing
    the `:userId` parameter in it, the app will execute the `userByID` controller
    function, which fetches and loads the user into the Express request object, before
    propagating it to the `next` function that's specific to the request that came
    in.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Express 应用程序收到一个请求，该请求与包含 `:userId` 参数的路径匹配时，应用程序将执行 `userByID` 控制器函数，该函数获取并加载用户到
    Express 请求对象中，然后再将其传播到特定于请求的 `next` 函数。
- en: '`mern-skeleton/server/routes/user.routes.js`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/routes/user.routes.js`:'
- en: '[PRE32]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `userByID` controller function uses the value in the `:userId` parameter
    to query the database by `_id` and load the matching user's details.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`userByID` 控制器函数使用 `:userId` 参数中的值通过 `_id` 查询数据库并加载匹配用户的详细信息。'
- en: '`mern-skeleton/server/controllers/user.controller.js`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/controllers/user.controller.js`:'
- en: '[PRE33]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If a matching user is found in the database, the user object is appended to
    the request object in the `profile` key. Then, the `next()` middleware is used
    to propagate control to the next relevant controller function. For example, if
    the original request was to read a user profile, the `next()` call in `userByID` would
    go to the `read` controller function, which is discussed next.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在数据库中找到匹配的用户，则将用户对象附加到请求对象的 `profile` 键中。然后，使用 `next()` 中间件将控制权传递给下一个相关的控制器函数。例如，如果原始请求是读取用户资料，则
    `userByID` 中的 `next()` 调用将转到 `read` 控制器函数，这将在下文中讨论。
- en: Reading
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取
- en: The API endpoint to read a single user's data is declared in the following route.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 读取单个用户数据的 API 端点在以下路由中声明。
- en: '`mern-skeleton/server/routes/user.routes.js`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/routes/user.routes.js`:'
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When the Express app gets a GET request at `'/api/users/:userId'`, it executes
    the `userByID` controller function to load the user by the `userId` value, followed
    by the `read` controller function.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Express 应用程序接收到对 `'/api/users/:userId'` 的 GET 请求时，它执行 `userByID` 控制器函数，通过
    `userId` 值加载用户，然后执行 `read` 控制器函数。
- en: '`mern-skeleton/server/controllers/user.controller.js`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/controllers/user.controller.js`:'
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `read` function retrieves the user details from `req.profile` and removes
    sensitive information, such as the `hashed_password` and `salt` values, before
    sending the user object in the response to the requesting client. This rule is
    also followed in implementing the controller function to update a user, as shown
    next.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`read` 函数从 `req.profile` 中检索用户详细信息，并在将用户对象发送到请求客户端的响应中之前删除敏感信息，例如 `hashed_password`
    和 `salt` 值。在实现更新用户的控制器函数时也遵循此规则，如下所示。'
- en: Updating
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新
- en: The API endpoint to update a single user is declared in the following route.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 更新单个用户的 API 端点在以下路由中声明。
- en: '`mern-skeleton/server/routes/user.routes.js`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/routes/user.routes.js`:'
- en: '[PRE36]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When the Express app gets a PUT request at `'/api/users/:userId'`, similar to
    `read`, it loads the user with the `:userId` parameter value before executing
    the `update` controller function.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当Express应用接收到`'/api/users/:userId'`的PUT请求时，类似于读取，它会加载具有`:userId`参数值的用户，然后在执行`update`控制器函数之前。
- en: '`mern-skeleton/server/controllers/user.controller.js`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/controllers/user.controller.js`：'
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `update` function retrieves the user details from `req.profile` and then
    uses the `lodash` module to extend and merge the changes that came in the request
    body to update the user data. Before saving this updated user to the database,
    the `updated` field is populated with the current date to reflect the last updated
    timestamp. Upon successfully saving this update, the updated user object is cleaned
    by removing sensitive data, such as `hashed_password` and `salt`, before sending
    the user object in the response to the requesting client. Implementation of the
    final user controller function to delete a user is similar to the `update` function,
    as detailed in the next section.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`函数从`req.profile`中检索用户详细信息，然后使用`lodash`模块扩展并合并请求体中传入的更改以更新用户数据。在将此更新后的用户保存到数据库之前，`updated`字段被填充为当前日期，以反映最后更新的时间戳。在成功保存此更新后，更新后的用户对象通过删除敏感数据（如`hashed_password`和`salt`）来清理，然后在响应中发送给请求客户端。删除用户的最终用户控制器函数的实现与`update`函数类似，具体细节将在下一节中说明。'
- en: Deleting
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除
- en: The API endpoint to delete a user is declared in the following route.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 删除用户的API端点在以下路由中声明。
- en: '`mern-skeleton/server/routes/user.routes.js`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/routes/user.routes.js`：'
- en: '[PRE38]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When the Express app gets a DELETE request at `'/api/users/:userId'`, similar
    to read and update, it loads the user by ID and then the `remove` controller function
    is executed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当Express应用接收到`'/api/users/:userId'`的DELETE请求时，类似于读取和更新，它会根据ID加载用户，然后执行`remove`控制器函数。
- en: '`mern-skeleton/server/controllers/user.controller.js`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/controllers/user.controller.js`：'
- en: '[PRE39]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `remove` function retrieves the user from `req.profile` and uses the `remove()`
    query to delete the user from the database. On successful deletion, the requesting
    client is returned the deleted user object in the response.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`函数从`req.profile`中检索用户，并使用`remove()`查询从数据库中删除用户。在成功删除后，请求客户端会收到响应中的删除用户对象。'
- en: With the implementation of the API endpoints so far, any client can perform
    CRUD operations on the user model. However, we want to restrict access to some
    of these operations with authentication and authorization. We'll look at this
    in the next section.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，API端点的实现允许任何客户端对用户模型执行CRUD操作。然而，我们希望通过身份验证和授权来限制对这些操作的一些访问。我们将在下一节中探讨这个问题。
- en: Integrating user auth and protected routes
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成用户认证和保护路由
- en: To restrict access to user operations such as user profile view, user update,
    and user delete, we will first implement sign-in authentication with JWT, then
    use it to protect and authorize the read, update, and delete routes.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制对用户操作（如查看用户资料、更新用户和删除用户）的访问，我们首先实现使用JWT的登录认证，然后使用它来保护并授权读取、更新和删除路由。
- en: The auth-related API endpoints for sign-in and sign-out will be declared in
    `server/routes/auth.routes.js` and then mounted on the Express app in `server/express.js`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 登录和注销相关的认证API端点将在`server/routes/auth.routes.js`中声明，然后将其挂载到`server/express.js`中的Express应用上。
- en: '`mern-skeleton/server/express.js`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/express.js`：'
- en: '[PRE40]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will make the routes we define in `auth.routes.js` accessible from the
    client-side.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们在`auth.routes.js`中定义的路由从客户端可访问。
- en: Auth routes
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证路由
- en: The two auth APIs are defined in the `auth.routes.js` file using `express.Router()`
    to declare the route paths with the relevant HTTP methods. They're also assigned
    the corresponding controller functions, which should be called when requests are
    received for these routes.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 两个认证API在`auth.routes.js`文件中定义，使用`express.Router()`声明路由路径和相关HTTP方法。它们还被分配了相应的控制器函数，当接收到这些路由的请求时应该调用这些函数。
- en: 'The auth routes are as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 认证路由如下：
- en: '`''/auth/signin''`: POST request to authenticate the user with their email
    and password'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''/auth/signin''`：使用电子邮件和密码进行用户认证的POST请求'
- en: '`''/auth/signout''`: GET request to clear the cookie containing a JWT that
    was set on the response object after sign-in'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''/auth/signout''`：登录后，在响应对象上设置的JWT包含的cookie的GET请求用于清除'
- en: 'The resulting `mern-skeleton/server/routes/auth.routes.js` file will be as
    follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`mern-skeleton/server/routes/auth.routes.js`文件将如下所示：
- en: '[PRE41]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: A POST request to the `signin` route and a GET request to the `signout` route
    will invoke the corresponding controller functions defined in the `auth.controller.js`
    file, as discussed in the next section.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `signin` 路由的 POST 请求和对 `signout` 路由的 GET 请求将调用在 `auth.controller.js` 文件中定义的相应控制器函数，如下一节所述。
- en: Auth controller
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证控制器
- en: The auth controller functions in `server/controllers/auth.controller.js` will
    not only handle requests to the `signin` and `signout` routes, but also provide
    JWT and `express-jwt` functionality to enable authentication and authorization
    for protected user API endpoints.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`server/controllers/auth.controller.js` 中的认证控制器函数不仅会处理对 `signin` 和 `signout`
    路由的请求，还会提供 JWT 和 `express-jwt` 功能，以启用受保护用户 API 端点的认证和授权。'
- en: 'The `mern-skeleton/server/controllers/auth.controller.js` file will have the
    following structure:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/controllers/auth.controller.js` 文件将具有以下结构：'
- en: '[PRE42]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The four controller functions are elaborated on in the following sections to
    show how the backend implements user auth using JSON Web Tokens. We'll start with
    the `signin` controller function in the next section.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下几节中详细说明了四个控制器函数，以展示后端如何使用 JSON Web Tokens 实现用户认证。我们将从下一节的 `signin` 控制器函数开始。
- en: Sign-in
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录
- en: The API endpoint to sign-in a user is declared in the following route.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下路由中声明了用于登录用户的 API 端点。
- en: '`mern-skeleton/server/routes/auth.routes.js`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/routes/auth.routes.js`:'
- en: '[PRE43]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When the Express app gets a POST request at `'/auth/signin'`, it executes the
    `signin` controller function.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Express 应用程序接收到对 `'/auth/signin'` 的 POST 请求时，它将执行 `signin` 控制器函数。
- en: '`mern-skeleton/server/controllers/auth.controller.js`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/controllers/auth.controller.js`:'
- en: '[PRE44]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `POST` request object receives the email and password in `req.body`. This
    email is used to retrieve a matching user from the database. Then, the password
    authentication method defined in `UserSchema` is used to verify the password that's
    received in `req.body` from the client.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 请求对象在 `req.body` 中接收电子邮件和密码。这个电子邮件用于从数据库中检索匹配的用户。然后，使用在 `UserSchema`
    中定义的密码认证方法来验证从客户端接收到的 `req.body` 中的密码。'
- en: If the password is successfully verified, the JWT module is used to generate
    a signed JWT using a secret key and the user's `_id` value.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果密码验证成功，JWT 模块将使用密钥和用户 `_id` 值生成一个签名的 JWT。
- en: Install the `jsonwebtoken` module to make it available to this controller in
    the import by running ` yarn add jsonwebtoken` from the command line.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在命令行中运行 `yarn add jsonwebtoken` 来安装 `jsonwebtoken` 模块，使其可用于此控制器。
- en: Then, the signed JWT is returned to the authenticated client, along with the
    user's details. Optionally, we can also set the token to a cookie in the response
    object so that it is available to the client-side if cookies are the chosen form
    of JWT storage. On the client-side, this token must be attached as an `Authorization`
    header when requesting protected routes from the server. To sign-out a user, the
    client-side can simply delete this token depending on how it is being stored.
    In the next section, we will learn how to use a `signout` API endpoint to clear
    the cookie containing the token.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将签名的 JWT 返回给认证的客户端，并附带用户的详细信息。可选地，我们还可以将令牌设置为响应对象中的 cookie，以便在客户端（如果选择 cookie
    作为 JWT 存储形式）可用。在客户端，此令牌必须在请求受保护路由时附加为 `Authorization` 标头。要注销用户，客户端可以简单地根据其存储方式删除此令牌。在下一节中，我们将学习如何使用
    `signout` API 端点清除包含令牌的 cookie。
- en: Signout
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注销
- en: The API endpoint to sign-out a user is declared in the following route.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下路由中声明了用于注销用户的 API 端点。
- en: '`mern-skeleton/server/routes/auth.routes.js`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/routes/auth.routes.js`:'
- en: '[PRE45]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When the Express app gets a GET request at `'/auth/signout'`, it executes the
    `signout` controller function.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Express 应用程序接收到对 `'/auth/signout'` 的 GET 请求时，它将执行 `signout` 控制器函数。
- en: '`mern-skeleton/server/controllers/auth.controller.js`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/controllers/auth.controller.js`:'
- en: '[PRE46]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `signout` function clears the response cookie containing the signed JWT.
    This is an optional endpoint and not really necessary for auth purposes if cookies
    are not used at all in the frontend.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`signout` 函数清除包含签名的 JWT 的响应 cookie。这是一个可选端点，如果前端完全不使用 cookie，那么对于认证目的来说并不是必需的。'
- en: With JWT, user state storage is the client's responsibility, and there are multiple
    options for client-side storage besides cookies. On signout, the client needs
    to delete the token on the client-side to establish that the user is no longer
    authenticated. On the server-side, we can use and verify the token that's generated
    at sign-in to protect routes that should not be accessed without valid authentication.
    In the next section, we will learn how to implement these protected routes using
    JWT.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JWT，用户状态存储是客户端的责任，除了cookies之外，客户端还有多种存储选项。在注销时，客户端需要在客户端删除令牌，以确认用户不再经过身份验证。在服务器端，我们可以使用和验证在登录时生成的令牌来保护不应未经有效身份验证而访问的路由。在下一节中，我们将学习如何使用JWT实现这些受保护的路由。
- en: Protecting routes with express-jwt
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用express-jwt保护路由
- en: To protect access to the read, update, and delete routes, the server will need
    to check that the requesting client is actually an authenticated and authorized
    user.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护对读取、更新和删除路由的访问，服务器需要检查请求客户端是否是经过身份验证和授权的用户。
- en: To check whether the requesting user is signed in and has a valid JWT when a
    protected route is accessed, we will use the `express-jwt` module.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问受保护的路由时，为了检查请求用户是否已登录并且具有有效的JWT，我们将使用`express-jwt`模块。
- en: The `express-jwt` module is a piece of middleware that validates JSON Web Tokens.
    Run `yarn add express-jwt` from the command line to install `express-jwt`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`express-jwt`模块是一个中间件，用于验证JSON Web Tokens。通过命令行运行`yarn add express-jwt`来安装`express-jwt`。'
- en: Protecting user routes
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护用户路由
- en: We will define two auth controller methods called `requireSignin` and `hasAuthorization`,
    both of which will be added to the user route declarations that need to be protected
    with authentication and authorization.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义两个认证控制器方法，分别称为`requireSignin`和`hasAuthorization`，这两个方法将被添加到需要通过身份验证和授权进行保护的用户路由声明中。
- en: The read, update, and delete routes in `user.routes.js` need to be updated as
    follows.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`user.routes.js`中的读取、更新和删除路由需要按以下方式更新。'
- en: '`mern-skeleton/server/routes/user.routes.js`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/routes/user.routes.js`:'
- en: '[PRE47]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The route to read a user's information only needs authentication verification,
    whereas the update and delete routes should check for both authentication and
    authorization before these CRUD operations are executed. We will look into the
    implementation of the `requireSignin` method, which checks authentication, and
    the `hasAuthorization` method, which checks authorization, in the next section.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 读取用户信息的路由只需要进行身份验证验证，而更新和删除路由在执行这些CRUD操作之前应该检查身份验证和授权。我们将在下一节中探讨`requireSignin`方法的实现，该方法用于检查身份验证，以及`hasAuthorization`方法的实现，该方法用于检查授权。
- en: Requiring sign-in
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求登录
- en: The `requireSignin` method in `auth.controller.js` uses `express-jwt` to verify
    that the incoming request has a valid JWT in the `Authorization` header. If the
    token is valid, it appends the verified user's ID in an `'auth'` key to the request
    object; otherwise, it throws an authentication error.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth.controller.js`中的`requireSignin`方法使用`express-jwt`来验证传入的请求是否在`Authorization`头中包含有效的JWT。如果令牌有效，它将在请求对象中添加一个带有`''auth''`键的已验证用户ID；否则，它将抛出一个身份验证错误。'
- en: '`mern-skeleton/server/controllers/auth.controller.js`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/controllers/auth.controller.js`:'
- en: '[PRE48]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can add `requireSignin` to any route that should be protected against unauthenticated
    access.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`requireSignin`添加到任何需要保护免受未经身份验证访问的路由。
- en: Authorizing signed in users
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权已登录用户
- en: For some of the protected routes, such as update and delete, on top of checking
    for authentication we also want to make sure the requesting user is only updating
    or deleting their own user information.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些受保护的路由，例如更新和删除，除了检查身份验证之外，我们还想确保请求用户只更新或删除他们自己的用户信息。
- en: To achieve this, the `hasAuthorization` function defined in `auth.controller.js`
    will check whether the authenticated user is the same as the user being updated
    or deleted before the corresponding CRUD controller function is allowed to proceed.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，`auth.controller.js`中定义的`hasAuthorization`函数将在允许相应的CRUD控制器函数继续之前，检查经过身份验证的用户是否与正在更新或删除的用户相同。
- en: '`mern-skeleton/server/controllers/auth.controller.js`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-skeleton/server/controllers/auth.controller.js`:'
- en: '[PRE49]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `req.auth` object is populated by `express-jwt` in `requireSignin` after
    authentication verification, while `req.profile` is populated by the `userByID`
    function in `user.controller.js`. We will add the `hasAuthorization` function
    to routes that require both authentication and authorization.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在`requireSignin`认证验证后，`express-jwt`填充了`req.auth`对象，而`req.profile`则由`user.controller.js`中的`userByID`函数填充。我们将向需要认证和授权的路由添加`hasAuthorization`函数。
- en: Auth error handling for express-jwt
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`express-jwt`的认证错误处理'
- en: 'To handle auth-related errors thrown by `express-jwt` when it tries to validate
    JWT tokens in incoming requests, we need to add the following error-catching code
    to the Express app configuration in `mern-skeleton/server/express.js`, near the
    end of the code, after the routes are mounted and before the app is exported:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理`express-jwt`在尝试验证传入请求中的JWT令牌时抛出的认证相关错误，我们需要在`mern-skeleton/server/express.js`中的Express应用程序配置中添加以下错误捕获代码，在代码末尾，在路由挂载之后和应用程序导出之前：
- en: '[PRE50]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`express-jwt` throws an error named `UnauthorizedError` when a token cannot
    be validated for some reason. We catch this error here to return a `401` status
    back to the requesting client. We also add a response to be sent if other server-side
    errors are generated and caught here.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当由于某种原因令牌无法验证时，`express-jwt`会抛出一个名为`UnauthorizedError`的错误。我们在这里捕获这个错误，向请求客户端返回`401`状态。如果在这里生成并捕获其他服务器端错误，我们也会添加一个要发送的响应。
- en: With user auth implemented for protecting routes, we have covered all the desired
    features of a working backend for our skeleton MERN application. In the next section,
    we will look at how we can check whether this standalone backend is functioning
    as desired without implementing a frontend.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在为保护路由实现用户认证后，我们已经涵盖了我们的MERN应用程序骨架所需的所有工作后端功能。在下一节中，我们将探讨如何检查这个独立后端是否按预期工作，而不需要实现前端。
- en: Checking the standalone backend
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查独立后端
- en: There are a number of options when it comes to selecting tools to check backend
    APIs, ranging from the command-line tool curl ([https://github.com/curl/curl](https://github.com/curl/curl))
    to **Advanced REST Client** (**ARC**) ([https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo](https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo)),
    a Chrome extension app with an interactive user interface.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择用于检查后端API的工具时，有多种选择，从命令行工具curl（[https://github.com/curl/curl](https://github.com/curl/curl)）到**高级REST客户端**（**ARC**）（[https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo](https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo)），这是一个具有交互式用户界面的Chrome扩展应用程序。
- en: To check the APIs that were implemented in this chapter, first, have the server
    running from the command line and use either of these tools to request the routes.
    If you are running the code on your local machine, the root URL is `http://localhost:3000/`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查本章中实现的API，首先，从命令行启动服务器，并使用这些工具之一请求路由。如果您在本地机器上运行代码，根URL是`http://localhost:3000/`。
- en: Using ARC, we will showcase the expected behavior for five use cases so that
    we can check the implemented API endpoints.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ARC，我们将展示五个用例的预期行为，以便我们可以检查实现的API端点。
- en: Creating a new user
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新用户
- en: 'First, we will create a new user with the `/api/users` POST request and pass
    name, email, and password values in the request body. When the user is successfully
    created in the database without any validation errors, we will see a 200 OK success
    message, as shown in the following screenshot:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过`/api/users` POST请求创建一个新用户，并在请求体中传递名称、电子邮件和密码值。当用户在数据库中成功创建且没有验证错误时，我们将看到如下截图所示的200
    OK成功消息：
- en: '![](img/b9f549c9-8db0-4578-8f8a-41399b35ddff.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9f549c9-8db0-4578-8f8a-41399b35ddff.png)'
- en: You can also try to send the same request with invalid values for name, email,
    and password to check whether the relevant error messages are returned by the
    backend. Next, we will check whether the users were successfully created and stored
    in the database by calling the list users API.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以尝试发送具有无效名称、电子邮件和密码值的相同请求，以检查后端是否返回了相关的错误消息。接下来，我们将通过调用列表用户API来检查用户是否已成功创建并存储在数据库中。
- en: Fetching the user list
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取用户列表
- en: 'We can see whether a new user is in the database by fetching a list of all
    users with a `GET` request to `/api/users`. The response should contain an array
    of all the user objects stored in the database:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向`/api/users`发送一个获取所有用户的`GET`请求来查看新用户是否在数据库中。响应应包含存储在数据库中的所有用户对象的数组：
- en: '![](img/0ba36f8e-98d2-4426-b9db-44182588be8e.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0ba36f8e-98d2-4426-b9db-44182588be8e.png)'
- en: Notice how the returned user objects only show the `_id`, `name`, `email`, and
    `created` field values, and not the `salt` or `hashed_password` values, which
    are also present in the actual documents stored in the database. The request only
    retrieves the selected fields we specified in the Mongoose `find` query that we
    made in the list controller method. This omission is also in place when fetching
    a single user.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 注意返回的用户对象只显示了`_id`、`name`、`email`和`created`字段的值，而没有显示`salt`或`hashed_password`值，这些值也存在于数据库中实际存储的文档中。请求只检索我们在列表控制器方法中指定的Mongoose
    `find`查询中指定的所选字段。在获取单个用户时也存在这种省略。
- en: Trying to fetch a single user
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试获取单个用户
- en: 'Next, we will try to access a protected API without signing in first. A `GET`
    request to read any one of the users will return a 401 Unauthorized error, such
    as in the following example. Here, a `GET` request to `/api/users/5a1c7ead1a692aa19c3e7b33`
    returns a 401 error:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试在不先登录的情况下访问受保护的API。读取任何用户的`GET`请求将返回401未授权错误，如下例所示。在这里，向`/api/users/5a1c7ead1a692aa19c3e7b33`发送的`GET`请求返回401错误：
- en: '![](img/70f7128e-1a9d-44e6-8e84-8837b61a8236.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/70f7128e-1a9d-44e6-8e84-8837b61a8236.png)'
- en: To make this request return a successful response with user details, a valid
    authorization token needs to be provided in the request header. We can generate
    a valid token by successfully calling the sign-in request.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个请求返回包含用户详情的成功响应，需要在请求头中提供一个有效的授权令牌。我们可以通过成功调用登录请求来生成一个有效的令牌。
- en: Signing in
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录
- en: 'To be able to access the protected route, we will sign-in using the credentials
    of the user we created in the first example. To sign-in, a POST request is sent
    to `/auth/signin` with the email and password in the request body, as shown in
    the following screenshot:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够访问受保护的路由，我们将使用第一个示例中创建的用户凭据进行登录。为了登录，发送一个POST请求到`/auth/signin`，请求体中包含电子邮件和密码，如下面的截图所示：
- en: '![](img/24e09460-8fe0-468f-91e4-7632e51bd8ef.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24e09460-8fe0-468f-91e4-7632e51bd8ef.png)'
- en: On successful sign-in, the server returns a signed JWT and user details. We
    will need this token to access the protected route for fetching a single user.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 登录成功后，服务器返回一个签名过的JWT和用户详情。我们需要这个令牌来访问用于获取单个用户的受保护路由。
- en: Fetching a single user successfully
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成功获取单个用户
- en: 'Using the token received after sign-in, we can now access the protected route
    that failed previously. The token is set in the `Authorization` header in the
    Bearer scheme when making the GET request to `/api/users/5a1c7ead1a692aa19c3e7b33`.
    This time, the user object is returned successfully:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 使用登录后收到的令牌，我们现在可以访问之前失败的受保护路由。在向`/api/users/5a1c7ead1a692aa19c3e7b33`发送GET请求时，令牌被设置为`Authorization`头部的Bearer方案中。这次，成功返回了用户对象：
- en: '![](img/c157ee7c-b504-497a-9d46-051f24e4f9da.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c157ee7c-b504-497a-9d46-051f24e4f9da.png)'
- en: Using ARC as demonstrated in this section, you can also check the implementation
    of the other API endpoints for updating and deleting a user. With all these API
    endpoints working as expected, we have a complete working backend for MERN-based
    applications.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节所示，使用ARC，您还可以检查其他API端点的更新和删除用户实现。所有这些API端点按预期工作，我们就有了一个完整的MERN应用程序后端。
- en: Summary
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we developed a fully functioning standalone server-side application
    using Node, Express, and MongoDB and covered the first part of the MERN skeleton
    application. In the backend, we implemented a user model for storing user data,
    implemented with Mongoose; user API endpoints to perform CRUD operations, which
    were implemented with Express; and user auth for protected routes, which was implemented
    with JWT and `express-jwt`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用Node、Express和MongoDB开发了一个完全功能独立的后端应用程序，并涵盖了MERN框架应用程序骨架的第一部分。在后端，我们实现了用于存储用户数据的用户模型，使用Mongoose实现；实现了执行CRUD操作的API端点，使用Express实现；以及实现了用于受保护路由的用户认证，使用JWT和`express-jwt`实现。
- en: We also set up the development flow by configuring Webpack so that it compiles
    ES6+ code using Babel. We also configured Nodemon so that it restarts the server
    when the code changes. Finally, we checked the implementation of the APIs using
    the Advanced Rest API Client extension app for Chrome.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过配置Webpack来设置开发流程，以便使用Babel编译ES6+代码。我们还配置了Nodemon，以便在代码更改时重启服务器。最后，我们使用Chrome的高级Rest
    API客户端扩展应用程序检查了API的实现。
- en: Now, we are ready to extend this backend application code and add the React
    frontend, which will complete the MERN skeleton application. We will do this in
    the next chapter.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好扩展这个后端应用程序代码并添加React前端，这将完成MERN框架的应用程序。我们将在下一章中这样做。
