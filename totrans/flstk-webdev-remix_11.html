<html><head></head><body>
<div id="_idContainer049">
<h1 class="chapter-number" id="_idParaDest-169"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-170"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.2.1">Optimistic UI</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Optimistic UI </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.4.1">makes your app feel snappy by giving immediate feedback, even when actions take a bit longer. </span><span class="koboSpan" id="kobo.4.2">This is especially useful when you’re waiting for a network response. </span><span class="koboSpan" id="kobo.4.3">Optimistic updates can make a UI feel more responsive and improve the user experience. </span><span class="koboSpan" id="kobo.4.4">In this chapter, you will learn how to add optimistic UI updates </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">with Remix.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">This chapter is split into </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">two sections:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.8.1">Considering </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">optimistic UI</span></span></li>
<li><span class="koboSpan" id="kobo.10.1">Adding optimistic UI updates </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">in Remix</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.12.1">First, we will discuss the trade-offs of using optimistic UI updates and investigate the complexity and risks of client/server state synchronizations and rollbacks. </span><span class="koboSpan" id="kobo.12.2">Next, we will review the current state of BeeRich and investigate which mutations to enhance with optimistic UI updates. </span><span class="koboSpan" id="kobo.12.3">We will then add optimistic UI updates where it makes sense using </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">Remix’s primitives.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">After reading this chapter, you will know how to evaluate the usage of optimistic UIs. </span><span class="koboSpan" id="kobo.14.2">You will have also practiced implementing optimistic UIs with Remix’s primitives, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.15.1">useNavigation</span></strong><span class="koboSpan" id="kobo.16.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.17.1">useFetcher</span></strong><span class="koboSpan" id="kobo.18.1">. </span><span class="koboSpan" id="kobo.18.2">Finally, you will understand how Remix eases the implementation of optimistic UIs by providing a resilient baseline for </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">your application.</span></span></p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.21.1">You can find the code for this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">here: </span></span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/11-optimistic-ui"><span class="No-Break"><span class="koboSpan" id="kobo.23.1">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/11-optimistic-ui</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.24.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">BeeRich has grown quite a bit. </span><span class="koboSpan" id="kobo.25.2">Now is a good time to refactor the code. </span><span class="koboSpan" id="kobo.25.3">Before starting with this chapter, we want to update the current code. </span><span class="koboSpan" id="kobo.25.4">We will also enhance our form validation and parsing using </span><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">zod</span></strong><span class="koboSpan" id="kobo.27.1">. </span><span class="koboSpan" id="kobo.27.2">Follow the step-by-step guide in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">README.md</span></strong><span class="koboSpan" id="kobo.29.1"> file to prepare BeeRich for the upcoming </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">advanced topics.</span></span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.31.1">Considering optimistic UI</span></h1>
<p><span class="koboSpan" id="kobo.32.1">The</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.33.1"> source of truth of a web application is usually stored remotely in a database. </span><span class="koboSpan" id="kobo.33.2">We can only be sure that a mutation succeeded after updating the database and receiving confirmation from the server. </span><span class="koboSpan" id="kobo.33.3">The UI response to a mutation is thereby delayed until we hear back from </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">Optimistic UI is a pattern that’s used to provide instant feedback to users while waiting for an execution to resolve. </span><span class="koboSpan" id="kobo.35.2">When updating the UI optimistically, we apply a UI update before receiving the definitive response from the server. </span><span class="koboSpan" id="kobo.35.3">Most of the time, our mutations succeed, so why wait for a server response? </span><span class="koboSpan" id="kobo.35.4">In this section, we will discuss some trade-offs of optimistic </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">UI updates.</span></span></p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.37.1">Communicating rollbacks</span></h2>
<p><span class="koboSpan" id="kobo.38.1">Updating </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.39.1">the UI optimistically speeds up the perceived response time when the optimistic state aligns with the server response. </span><span class="koboSpan" id="kobo.39.2">When the optimistic update does not align with the server response, then optimistic updates need to be rolled back or corrected. </span><span class="koboSpan" id="kobo.39.3">This is where the optimistic UI pattern starts to become </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">more complicated.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">When something goes wrong with an optimistic mutation, we must communicate the error and highlight the rollback to the user. </span><span class="koboSpan" id="kobo.41.2">Otherwise, we risk losing the user’s trust and confidence in our application. </span><span class="koboSpan" id="kobo.41.3">For instance, after attempting to delete an item, we might have to revert to the optimistic removal of the item and tell the user why the item reappeared again – “</span><em class="italic"><span class="koboSpan" id="kobo.42.1">I just deleted that item; why is </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.43.1">it back?</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">”</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">When considering optimistic UI, it is a good idea to investigate the error rate of a mutation. </span><span class="koboSpan" id="kobo.45.2">If the error rate is high, then the number of rollbacks might degrade the user experience more than the increased response times are worth. </span><span class="koboSpan" id="kobo.45.3">As always, it depends on the use case, type of application, </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">and user.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">We can summarize that error handling with optimistic UI becomes harder to implement as rollbacks have to be communicated correctly. </span><span class="koboSpan" id="kobo.47.2">On top of that, optimistic UIs also require re-synchronizing client and server states, leading to more complicated </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">client-side code.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.49.1">Synchronizing client and server states</span></h2>
<p><span class="koboSpan" id="kobo.50.1">One of the </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.51.1">biggest risks of optimistic UI is introducing stale states in the UI. </span><span class="koboSpan" id="kobo.51.2">When applying optimistic updates, it can become quite challenging to synchronize the UI state with the server response consistently. </span><span class="koboSpan" id="kobo.51.3">The resulting logic might be complex and introduce bugs where part of the application’s UI is out of sync with the </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">server state.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">When adding optimistic updates, we may allow users to submit several updates subsequently. </span><span class="koboSpan" id="kobo.53.2">We optimistically update the UI each time. </span><span class="koboSpan" id="kobo.53.3">Then, we must deal with the synchronization of the UI with the server responses. </span><span class="koboSpan" id="kobo.53.4">When several updates happen simultaneously, this may lead to race conditions and other hard problems that require thorough synchronization logic and </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">error handling.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">Optimistic UI updates are optional. </span><span class="koboSpan" id="kobo.55.2">When implemented correctly, they may improve the user experience by speeding up the perceived response time. </span><span class="koboSpan" id="kobo.55.3">However, there is also the risk that optimistic UI updates may increase the complexity of our application’s state management disproportionally and degrade the user experience if not </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">implemented thoroughly.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">Optimistic UI updates can lead to stale states, complex client-server state synchronization logic, and a worse user experience if rollbacks aren’t communicated properly. </span><span class="koboSpan" id="kobo.57.2">Conclusively, we must cautiously evaluate whether a certain mutation would profit from the addition of optimistic UI updates or whether it would disproportionally increase </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">the complexity.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Luckily, Remix provides a great foundation for implementing optimistic UI updates and allows us to implement optimistic UI updates through additive changes to our existing pending UI. </span><span class="koboSpan" id="kobo.59.2">Let’s remind ourselves of Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">loader</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.61.1">revalidation feature.</span></span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.62.1">Synchronizing client and server states in Remix</span></h2>
<p><span class="koboSpan" id="kobo.63.1">Remix </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.64.1">manages the complexity of optimistic UI out of the box by providing a data revalidation flow. </span><span class="koboSpan" id="kobo.64.2">Let’s quickly review Remix’s built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">loader</span></strong><span class="koboSpan" id="kobo.66.1"> revalidation before jumping into </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">Whenever we submit a form in Remix and execute an </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">action</span></strong><span class="koboSpan" id="kobo.70.1"> function, Remix will automatically re-fetch the data from all active </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">loader</span></strong><span class="koboSpan" id="kobo.72.1"> functions. </span><span class="koboSpan" id="kobo.72.2">This ensures that we always update all data on the page after every </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">data mutation.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">When utilizing Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">loader</span></strong><span class="koboSpan" id="kobo.76.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">action</span></strong><span class="koboSpan" id="kobo.78.1"> functions for data reads and writes, we avoid introducing stale data in our UIs and eliminate the main concern of degrading</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.79.1"> the user experience when implementing optimistic </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">UI updates.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">Additionally, Remix’s primitives, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">useNavigation</span></strong><span class="koboSpan" id="kobo.83.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">useFetcher</span></strong><span class="koboSpan" id="kobo.85.1">, allow us to read pending submission data without adding custom React states, which keeps the complexity increase of adding optimistic UI at a low. </span><span class="koboSpan" id="kobo.85.2">Let’s see for ourselves by adding optimistic UI to BeeRich. </span><span class="koboSpan" id="kobo.85.3">First, let’s review the current mutations in our BeeRich application and investigate whether adding an optimistic UI would improve the </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">user experience.</span></span></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.87.1">Adding optimistic UI updates in Remix</span></h1>
<p><span class="koboSpan" id="kobo.88.1">In this section, we will </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.89.1">review our BeeRich application and discuss which user actions would profit the most from adding optimistic UI updates. </span><span class="koboSpan" id="kobo.89.2">Then, we will go ahead and make the required </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">code changes.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.91.1">Creating an expense</span></h2>
<p><span class="koboSpan" id="kobo.92.1">Run </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.93.1">BeeRich locally by executing </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">npm run dev</span></strong><span class="koboSpan" id="kobo.95.1"> in the project’s root and navigate to the expense overview page (</span><a href="http://localhost:3000/dashboard/expenses"><span class="koboSpan" id="kobo.96.1">http://localhost:3000/dashboard/expenses</span></a><span class="koboSpan" id="kobo.97.1">). </span><span class="koboSpan" id="kobo.97.2">Now, create a </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">new expense.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Notice that after submitting the expense creation form, we are redirected to the expense details page. </span><span class="koboSpan" id="kobo.99.2">The URL now includes the new expense identifier. </span><span class="koboSpan" id="kobo.99.3">After the redirect, we have access to the newly created expense loader data, including the expense identifier. </span><span class="koboSpan" id="kobo.99.4">All further updates to the expense require the </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">expense identifier.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">Adding optimistic UI updates to the expense creation form may become quite complicated. </span><span class="koboSpan" id="kobo.101.2">One way to achieve this would be to optimistically update the look and feel of the creation form so that it looks like the expense update form before redirecting the user to the actual details page. </span><span class="koboSpan" id="kobo.101.3">However, we can’t execute any subsequent expense update submissions until we receive the expense </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">id</span></strong><span class="koboSpan" id="kobo.103.1"> parameter from the expense creation submission. </span><span class="koboSpan" id="kobo.103.2">We could disable all submit buttons until we receive the server response, or we could queue subsequent submissions and submit an update programmatically with the latest changes the user tried to submit. </span><span class="koboSpan" id="kobo.103.3">This could become </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">quite complicated.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">Things become even more complicated when thinking about the attachment logic. </span><span class="koboSpan" id="kobo.105.2">What if we are still waiting on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">id</span></strong><span class="koboSpan" id="kobo.107.1"> parameter when the user wants to remove the attached file or tries to upload a new attachment? </span><span class="koboSpan" id="kobo.107.2">We could prevent all subsequent changes to the </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.108.1">attachment by disabling the attachment actions until we get the expense </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">id</span></strong><span class="koboSpan" id="kobo.110.1"> parameter from </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">As always, it comes down to trade-offs. </span><span class="koboSpan" id="kobo.112.2">How much could we increase the response time and enhance the experience by adding optimistic updates? </span><span class="koboSpan" id="kobo.112.3">Is it worth the complexity? </span><span class="koboSpan" id="kobo.112.4">Since our application is quite fast, we decided not to add optimistic updates to the expense creation form. </span><span class="koboSpan" id="kobo.112.5">Instead, let’s move on and investigate the expense </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">update form.</span></span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.114.1">Updating an expense</span></h2>
<p><span class="koboSpan" id="kobo.115.1">Navigate</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.116.1"> to the expense overview page (</span><a href="http://localhost:3000/dashboard/expenses"><span class="koboSpan" id="kobo.117.1">http://localhost:3000/dashboard/expenses</span></a><span class="koboSpan" id="kobo.118.1">) and select an expense. </span><span class="koboSpan" id="kobo.118.2">This will navigate us to the expense details page, which renders the expense update form. </span><span class="koboSpan" id="kobo.118.3">Now, make some changes to the existing expense and click </span><strong class="bold"><span class="koboSpan" id="kobo.119.1">Save</span></strong><span class="koboSpan" id="kobo.120.1">. </span><span class="koboSpan" id="kobo.120.2">Make sure you test the experience on a throttled network using the </span><strong class="bold"><span class="koboSpan" id="kobo.121.1">Network</span></strong><span class="koboSpan" id="kobo.122.1"> tab of your browser’s developer tools. </span><span class="koboSpan" id="kobo.122.2">After a successful update, we do not redirect the user and are not awaiting an </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">id</span></strong><span class="koboSpan" id="kobo.124.1"> parameter. </span><span class="koboSpan" id="kobo.124.2">Instead, we display a success message: </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.125.1">Changes saved!</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">Technically, the UI already displays optimistic updates as we always show the latest input values to the user. </span><span class="koboSpan" id="kobo.127.2">Let’s also update the </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">Save</span></strong><span class="koboSpan" id="kobo.129.1"> submit button in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">dashboard.expenses.$id._index.tsx</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.131.1">route module:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.132.1">Remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">disabled</span></strong><span class="koboSpan" id="kobo.134.1"> property and pending “Save…” </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">UI state:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.136.1">
&lt;Button type="submit" name="intent" value="update" isPrimary&gt;  Save&lt;/Button&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.137.1">It might feel odd at first to remove the pending UI. </span><span class="koboSpan" id="kobo.137.2">Let’s think this through. </span><span class="koboSpan" id="kobo.137.3">The form now supports subsequent updates as we no longer disable the submit button on pending submissions. </span><span class="koboSpan" id="kobo.137.4">Since we always show the user-inputted values in the update form, the input state itself is already optimistic. </span><span class="koboSpan" id="kobo.137.5">Since we still show the global transition animation and expense details pulse animation on pending navigation, we still communicate that updates are in progress. </span><span class="koboSpan" id="kobo.137.6">Additionally, we still display the success message on successful update. </span><span class="koboSpan" id="kobo.137.7">This might be a </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">good compromise.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.139.1">But what about the attachment? </span><span class="koboSpan" id="kobo.139.2">Adding an attachment creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">expense.attachment</span></strong><span class="koboSpan" id="kobo.141.1"> value. </span><span class="koboSpan" id="kobo.141.2">We require the attachment filename value for the view and delete attachment actions of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">Attachment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.143.1"> component.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.144.1">One</span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.145.1"> solution is to add the attachment optimistically but disable the attachment link and the delete button until we receive the server response, which includes the newly added attachment value. </span><span class="koboSpan" id="kobo.145.2">Let’s make </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">it happen!</span></span></p></li> <li><span class="koboSpan" id="kobo.147.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">dashboard.expenses.$id._index.tsx</span></strong><span class="koboSpan" id="kobo.149.1"> route module component, use Remix’s global navigation object to derive whether an attachment is currently </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">being uploaded:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.151.1">
const navigation = useNavigation();const attachment = </span><strong class="bold"><span class="koboSpan" id="kobo.152.1">navigation.formData?.get('attachment');</span></strong><span class="koboSpan" id="kobo.153.1">const isUploadingAttachment = attachment instanceof File &amp;&amp; attachment.name !== '';</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.154.1">Remix’s navigation object has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">formData</span></strong><span class="koboSpan" id="kobo.156.1"> property. </span><span class="koboSpan" id="kobo.156.2">This property contains the data of the currently submitted form or </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">undefined</span></strong><span class="koboSpan" id="kobo.158.1"> if no submission is in progress. </span><span class="koboSpan" id="kobo.158.2">By checking for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">name</span></strong><span class="koboSpan" id="kobo.160.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">attachment</span></strong><span class="koboSpan" id="kobo.162.1"> input value, we can verify whether a file has been appended to the expense </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">update form.</span></span></p></li> <li><span class="koboSpan" id="kobo.164.1">Next, update the conditional render clause for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">Attachment</span></strong><span class="koboSpan" id="kobo.166.1"> component to render if an attachment is currently being uploaded. </span><span class="koboSpan" id="kobo.166.2">Further, pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">disabled</span></strong><span class="koboSpan" id="kobo.168.1"> to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">Attachment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.170.1"> component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.171.1">
{</span><strong class="bold"><span class="koboSpan" id="kobo.172.1">(isUploadingAttachment ||</span></strong><span class="koboSpan" id="kobo.173.1"> expense.attachment</span><strong class="bold"><span class="koboSpan" id="kobo.174.1">)</span></strong><span class="koboSpan" id="kobo.175.1"> ? </span><span class="koboSpan" id="kobo.175.2">(  &lt;Attachment    label="Current Attachment"    attachmentUrl={`/dashboard/expenses/${expense.id}/attachments/${expense.attachment}`}    </span><strong class="bold"><span class="koboSpan" id="kobo.176.1">disabled={isUploadingAttachment}</span></strong><span class="koboSpan" id="kobo.177.1">  /&gt;) : (  &lt;Input label="New Attachment" type="file" name="attachment" /&gt;)}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.178.1">We now</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.179.1"> render the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">Attachment</span></strong><span class="koboSpan" id="kobo.181.1"> component when an upload is still in progress. </span><span class="koboSpan" id="kobo.181.2">This is an optimistic update to the UI since the upload is still </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">in progress.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.183.1">By disabling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">Attachment</span></strong><span class="koboSpan" id="kobo.185.1"> component’s actions if an upload is still in progress, we prevent users from viewing or removing a </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">pending attachment.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.187.1">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">useNavigation</span></strong><span class="koboSpan" id="kobo.189.1"> hook and its </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">formData</span></strong><span class="koboSpan" id="kobo.191.1"> property allow us to conditionally update the UI without creating additional custom React states. </span><span class="koboSpan" id="kobo.191.2">This is great as we avoid the need for synchronization logic altogether. </span><span class="koboSpan" id="kobo.191.3">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">ErrorBoundary</span></strong><span class="koboSpan" id="kobo.193.1"> components further ensure a resilient baseline if an </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">error occurs.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">Great! </span><span class="koboSpan" id="kobo.195.2">Just like that, we added optimistic UI updates when attaching a file and updating an expense. </span><span class="koboSpan" id="kobo.195.3">Users can now make multiple updates without having to wait for a response from the server. </span><span class="koboSpan" id="kobo.195.4">If an issue arises, Remix will display our </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">ErrorBoundary</span></strong><span class="koboSpan" id="kobo.197.1">, letting the user know about </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">the error.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">As always, implement the same experience for the income routes. </span><span class="koboSpan" id="kobo.199.2">This ensures that you revisit the lessons learned before </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">moving on.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">Next, let’s investigate the expense deletion form for an opportunity to add optimistic </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">UI updates.</span></span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.203.1">Deleting an expense</span></h2>
<p><span class="koboSpan" id="kobo.204.1">On the expense overview page, we render a </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">ListLinkItem</span></strong><span class="koboSpan" id="kobo.206.1"> component for every expense. </span><span class="koboSpan" id="kobo.206.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">ListLinkItem</span></strong><span class="koboSpan" id="kobo.208.1"> component </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.209.1">in </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">app/components/links.tsx</span></strong><span class="koboSpan" id="kobo.211.1"> uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">useFetcher.Form</span></strong><span class="koboSpan" id="kobo.213.1"> to submit the delete mutation. </span><span class="koboSpan" id="kobo.213.2">Optimistically removing or adding elements to a list is a great way to provide instant feedback. </span><span class="koboSpan" id="kobo.213.3">Let’s see how we can add an optimistic UI to our expense </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">deletion forms.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">One way to </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.216.1">implement optimistic updates on deletion is to hide the list item immediately after entering the pending state. </span><span class="koboSpan" id="kobo.216.2">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">ListLinkItem</span></strong><span class="koboSpan" id="kobo.218.1"> component in </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">app/components/links.tsx</span></strong><span class="koboSpan" id="kobo.220.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.222.1">
const fetcher = useFetcher();const isSubmitting = fetcher.state !== 'idle';
</span><strong class="bold"><span class="koboSpan" id="kobo.223.1">if (isSubmitting) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.224.1">  return null;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.225.1">}</span></strong></pre>
<p><span class="koboSpan" id="kobo.226.1">You already know that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">useFetcher</span></strong><span class="koboSpan" id="kobo.228.1"> hook manages its transition life cycle. </span><span class="koboSpan" id="kobo.228.2">When trying to implement pending and optimistic UIs with </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">useFetcher.Form</span></strong><span class="koboSpan" id="kobo.230.1">, we don’t use </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">useNavigation</span></strong><span class="koboSpan" id="kobo.232.1">; instead, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">useFetcher</span></strong><span class="koboSpan" id="kobo.234.1"> hook’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">state</span></strong><span class="koboSpan" id="kobo.236.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">formData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.238.1"> properties.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">Just like that, we </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.240.1">remove the expense item from the list when a submission is pending. </span><span class="koboSpan" id="kobo.240.2">Once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">action</span></strong><span class="koboSpan" id="kobo.242.1"> function finishes, Remix refreshes the loader data and sets the navigation state back to </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">idle</span></strong><span class="koboSpan" id="kobo.244.1">. </span><span class="koboSpan" id="kobo.244.2">If the mutation was successful, then the updated loader data no longer contains the deleted expense, and our UI update persists. </span><span class="koboSpan" id="kobo.244.3">But what happens if an </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">error occurs?</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.246.1">Take a look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">handleDelete</span></strong><span class="koboSpan" id="kobo.248.1"> function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">dashboard.expenses.$id._index.tsx</span></strong><span class="koboSpan" id="kobo.250.1"> route module. </span><span class="koboSpan" id="kobo.250.2">Right now, we throw a 404 </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">Response</span></strong><span class="koboSpan" id="kobo.252.1"> if deleting an expense doesn’t work. </span><span class="koboSpan" id="kobo.252.2">This triggers the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">ErrorBoundary</span></strong><span class="koboSpan" id="kobo.254.1">. </span><span class="koboSpan" id="kobo.254.2">Let’s improve this by giving the user direct feedback in the UI if the delete </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">action fails.</span></span></li>
<li><span class="koboSpan" id="kobo.256.1">Update </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">handleDelete</span></strong><span class="koboSpan" id="kobo.258.1"> to return a JSON </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">Response</span></strong><span class="koboSpan" id="kobo.260.1"> if the delete </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">action fails:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.262.1">
try {  await deleteExpense(id, userId);} catch (err) {  </span><strong class="bold"><span class="koboSpan" id="kobo.263.1">return json({ success: false });</span></strong><span class="koboSpan" id="kobo.264.1">}</span></pre></li> <li><span class="koboSpan" id="kobo.265.1">Next, update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">ListLinkItem</span></strong><span class="koboSpan" id="kobo.267.1"> component </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">components/links.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">.</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.271.1">const fetcher = useFetcher&lt;{ success: boolean }&gt;();</span></strong><span class="koboSpan" id="kobo.272.1">const isSubmitting = fetcher.state !== 'idle';</span><strong class="bold"><span class="koboSpan" id="kobo.273.1">const hasFailed = fetcher.data?.success === false;</span></strong><span class="koboSpan" id="kobo.274.1">if (isSubmitting) {  return null;}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.275.1">We access the action data using the fetcher’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">data</span></strong><span class="koboSpan" id="kobo.277.1"> property. </span><span class="koboSpan" id="kobo.277.2">If the action data is present and </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">success</span></strong><span class="koboSpan" id="kobo.279.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">false</span></strong><span class="koboSpan" id="kobo.281.1">, we know that the expense’s </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">deletion failed.</span></span></p></li> <li><span class="koboSpan" id="kobo.283.1">Finally, update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">className</span></strong><span class="koboSpan" id="kobo.285.1"> property on the list element conditionally to style the list item text red in case </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">hasFailed</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.287.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">.</span></span><pre class="source-code"><span class="koboSpan" id="kobo.290.1">
className={clsx(  'w-full flex flex-row items-center border',  isActive    ? </span><span class="koboSpan" id="kobo.290.2">'bg-secondary dark:bg-darkSecondary border-secondary dark:border-darkSecondary'    : 'hover:bg-backgroundPrimary dark:hover:bg-darkBackgroundPrimary border-background dark:border-darkBackground hover:border-secondary dark:hover:border-darkSecondary',</span><strong class="bold"><span class="koboSpan" id="kobo.291.1">  {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.292.1">    'text-red-600 dark:text-red-400 hover:text-red-700 dark:hover:text-red-500 focus:text-red-700 dark:focus:text-red-500':</span></strong><strong class="bold"><span class="koboSpan" id="kobo.293.1">      hasFailed,</span></strong><strong class="bold"><span class="koboSpan" id="kobo.294.1">  },</span></strong><span class="koboSpan" id="kobo.295.1">  className,)}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.296.1">If an error occurs, we now avoid rendering the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">ErrorBoundary</span></strong><span class="koboSpan" id="kobo.298.1"> and instead display error feedback right where the error happened in </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">the UI.</span></span></p></li> <li><span class="koboSpan" id="kobo.300.1">Test the changes by throwing an error inside the try-case in </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">handleDelete</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.302.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">dashboard.expenses.$id._index.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.305.1">
try {  </span><strong class="bold"><span class="koboSpan" id="kobo.306.1">throw Error('something went wrong while deleting');</span></strong><span class="koboSpan" id="kobo.307.1">  await deleteExpense(id, userId);} catch (err) {  return json({ success: false });}</span></pre></li> <li><span class="koboSpan" id="kobo.308.1">Run BeeRich locally and try to delete an expense. </span><span class="koboSpan" id="kobo.308.2">The expense list item text should now turn red and indicate the </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">state rollback.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.310.1">Great work! </span><span class="koboSpan" id="kobo.310.2">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">ErrorBoundary</span></strong><span class="koboSpan" id="kobo.312.1"> is a great fallback in case something goes wrong. </span><span class="koboSpan" id="kobo.312.2">However, sometimes, it is a good idea to enhance the user experience further by providing inline feedback. </span><span class="koboSpan" id="kobo.312.3">This allows the user to retry the failed action immediately, and Remix’s loader data revalidation takes care of </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">the rest.</span></span></p></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.314.1">Remix provides a great foundation for optimistic UI</span></p>
<p class="callout"><span class="koboSpan" id="kobo.315.1">Remix automatically updates loader data after a mutation, keeping the client and server in sync. </span><span class="koboSpan" id="kobo.315.2">This greatly simplifies the process of creating </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">optimistic UIs.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">Great work! </span><span class="koboSpan" id="kobo.317.2">As always, make sure to also update the income routes with the latest changes in this section. </span><span class="koboSpan" id="kobo.317.3">This ensures that you practice what you learned before moving on to the </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">In this part, we added optimistic UI updates for deleting expenses. </span><span class="koboSpan" id="kobo.319.2">We also used the fetcher’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">data</span></strong><span class="koboSpan" id="kobo.321.1"> property to signal when an action fails and needs to be rolled back. </span><span class="koboSpan" id="kobo.321.2">Next, let’s investigate if we can optimistically remove expense and </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">income attachments.</span></span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.323.1">Removing an attachment</span></h2>
<p><span class="koboSpan" id="kobo.324.1">We already </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.325.1">optimistically display the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">Attachment</span></strong><span class="koboSpan" id="kobo.327.1"> component on pending uploads. </span><span class="koboSpan" id="kobo.327.2">We should also consider optimistically removing an attachment when clicking the attachment </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">deletion button.</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">This time, we don’t want to display the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">Attachment</span></strong><span class="koboSpan" id="kobo.331.1"> component on pending removal but instead display the file input. </span><span class="koboSpan" id="kobo.331.2">However, we also want to prevent race conditions and we should make sure we disable the input until the server confirms </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">the removal.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">Since the attachment deletion form submission uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">Form</span></strong><span class="koboSpan" id="kobo.335.1"> component (instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">useFetcher.Form</span></strong><span class="koboSpan" id="kobo.337.1">), we know the submission is handled via the global navigation object. </span><span class="koboSpan" id="kobo.337.2">Hence, we can detect whether the user deletes an attachment by checking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">formData</span></strong><span class="koboSpan" id="kobo.339.1"> property on the global </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">navigation object:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.341.1">Add the following Boolean flag to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">dashboard.expenses.$id._index.tsx</span></strong><span class="koboSpan" id="kobo.343.1"> route </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">module component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.345.1">
const isUploadingAttachment = attachment instanceof File &amp;&amp; attachment.name !== '';</span><strong class="bold"><span class="koboSpan" id="kobo.346.1">const isRemovingAttachment = navigation.formData?.get('intent') === 'remove-attachment';</span></strong></pre></li> <li><span class="koboSpan" id="kobo.347.1">Next, update the conditional to display the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">Attachment</span></strong><span class="koboSpan" id="kobo.349.1"> component if an upload is pending or an attachment exists on the expense but not if an attachment is currently being removed. </span><span class="koboSpan" id="kobo.349.2">Additionally, disable the input field if a submission </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">is pending:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.351.1">
{(isUploadingAttachment || expense.attachment) </span><strong class="bold"><span class="koboSpan" id="kobo.352.1">&amp;&amp; !isRemovingAttachment</span></strong><span class="koboSpan" id="kobo.353.1"> ? </span><span class="koboSpan" id="kobo.353.2">(  &lt;Attachment    label="Current Attachment"    attachmentUrl={`/dashboard/expenses/${expense.id}/attachments/${expense.attachment}`}    disabled={isUploadingAttachment}  /&gt;) : (  &lt;Input label="New Attachment" type="file" name="attachment" </span><strong class="bold"><span class="koboSpan" id="kobo.354.1">disabled={isSubmitting}</span></strong><span class="koboSpan" id="kobo.355.1"> /&gt;)}</span></pre></li> <li><span class="koboSpan" id="kobo.356.1">Try </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.357.1">out the implementation to verify that everything works as expected. </span><span class="koboSpan" id="kobo.357.2">As always, use the </span><strong class="bold"><span class="koboSpan" id="kobo.358.1">Network</span></strong><span class="koboSpan" id="kobo.359.1"> tab to throttle the connection to inspect </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">pending states.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.361.1">Great! </span><span class="koboSpan" id="kobo.361.2">We added optimistic UI updates to the attachment deletion form and the expense update form. </span><span class="koboSpan" id="kobo.361.3">You learned that Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">useFetcher</span></strong><span class="koboSpan" id="kobo.363.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">useNavigation</span></strong><span class="koboSpan" id="kobo.365.1"> primitives contain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">formData</span></strong><span class="koboSpan" id="kobo.367.1"> property of the form currently being submitted. </span><span class="koboSpan" id="kobo.367.2">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">formData</span></strong><span class="koboSpan" id="kobo.369.1"> property to optimistically update the UI until the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">loader</span></strong><span class="koboSpan" id="kobo.371.1"> revalidation synchronizes the UI with the </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">server state.</span></span></p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.373.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.374.1">In this chapter, you learned how to add optimistic UI updates in Remix. </span><span class="koboSpan" id="kobo.374.2">You were introduced to the trade offs of optimistic UI, such as the increased complexity of client-side logic and the necessity of user feedback in case </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">of rollbacks.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">loader</span></strong><span class="koboSpan" id="kobo.378.1"> revalidation is a great starting point for synchronizing the UI with the server state. </span><span class="koboSpan" id="kobo.378.2">You now understand that Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">loader</span></strong><span class="koboSpan" id="kobo.380.1"> revalidation enables us to avoid custom client-server state synchronization and lets us avoid stale states. </span><span class="koboSpan" id="kobo.380.2">When relying on the loader data, we get rollbacks out of the box. </span><span class="koboSpan" id="kobo.380.3">After each mutation, we receive the latest loader data, and our UI </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">updates automatically.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">It is still worth communicating why a mutation failed. </span><span class="koboSpan" id="kobo.382.2">With or without optimistic updates, it is important to display an error message to the user. </span><span class="koboSpan" id="kobo.382.3">For optimistic updates, it might also make sense to highlight the rolled-back data visually. </span><span class="koboSpan" id="kobo.382.4">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">ErrorBoundary</span></strong><span class="koboSpan" id="kobo.384.1"> component is a great starting point for recovering from errors. </span><span class="koboSpan" id="kobo.384.2">However, if we want more granular feedback, we must add custom error messages and utilize Remix’s primitives to highlight </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">rolled-back data.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">When implementing optimistic UIs, we usually start by removing pending UIs. </span><span class="koboSpan" id="kobo.386.2">Adding and removing pending entities to and from lists is an easy way to show </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">instant feedback.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">You also learned how to implement optimistic UI updates using Remix’s primitives such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">useNavigation</span></strong><span class="koboSpan" id="kobo.390.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">useFetcher</span></strong><span class="koboSpan" id="kobo.392.1">. </span><span class="koboSpan" id="kobo.392.2">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">formData</span></strong><span class="koboSpan" id="kobo.394.1"> property on the client to display user data before the final response is returned from </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">In the next chapter, we will learn about different caching strategies to further improve the response times and performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">Remix applications.</span></span></p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.398.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.399.1">You can find more information about how to implement optimistic UI in the Remix </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">documentation: </span></span><a href="https://remix.run/docs/en/2/discussion/pending-ui"><span class="No-Break"><span class="koboSpan" id="kobo.401.1">https://remix.run/docs/en/2/discussion/pending-ui</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.402.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">There is also a great Remix Single video about optimistic UI on the Remix YouTube </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">channel: </span></span><a href="https://www.youtube.com/watch?v=EdB_nj01C80"><span class="No-Break"><span class="koboSpan" id="kobo.405.1">https://www.youtube.com/watch?v=EdB_nj01C80</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.406.1">.</span></span></p>
</div>
</body></html>