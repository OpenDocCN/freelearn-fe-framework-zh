- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enhancing Your Applications with Directives, Pipes, and Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building frontend applications, we often need to enhance, transform, add,
    remove, or replace DOM elements and values within HTML templates. The Angular
    framework facilitates this through the use of directives, pipes, and animations.
    This chapter will explain how to create and use directives, pipes, and animations
    within Angular. By the end of this chapter, you will know all the ins and outs
    of directives, from directive composition to creating directives with powerful
    selectors. You will also learn about making custom pipes and using the built-in
    pipes effectively. Lastly, we will explore how to build and reuse animations within
    applications built using Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using and creating Angular directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming values using Angular pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and reusing stunning animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using and creating Angular directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Directives come in two different types: **attribute directives** and **structural
    directives**. Angular has a list of built-in directives and allows you to create
    your own directive to cover your personal use cases. Since Angular 15, a new feature
    was introduced: **directive composition**. Directive composition allows you to
    assign directives inside component decorators instead of their template. Directive
    composition can also be used to declare directives inside the decorator of other
    directives, resulting in a directive that applies multiple directives simultaneously.'
  prefs: []
  type: TYPE_NORMAL
- en: When you want to use a directive in a standalone component, you need to add
    the directive to the `imports` array of the component. If it’s a built-in directive,
    you can also import `CommonModule`, as `CommonModule` contains all built-in directives.
    When you generate a component using the built-in Nx generator, `CommonModule`
    is added by default. This section will teach you everything about directives,
    starting with attribute directives.
  prefs: []
  type: TYPE_NORMAL
- en: Angular attribute directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Attribute directives** serve as tools for modifying DOM elements’ attributes,
    behavior, or appearance. The directive makes modifications based on logic defined
    in a class decorated with a directive decorator. Attribute directives are assigned
    by adding the selector of the attribute directive to the HTML tag like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<div [ngClass]="useRedStyles ? ''red'' : ''blue''">Click</div>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: export * from './lib/highlight.directive';
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '@Directive({'
  prefs: []
  type: TYPE_NORMAL
- en: 'selector: ‹[btLibsUiHighlight]›,'
  prefs: []
  type: TYPE_NORMAL
- en: 'standalone: true,'
  prefs: []
  type: TYPE_NORMAL
- en: '}) export class HighlightDirective {}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: export class HighlightDirective implements OnInit {
  prefs: []
  type: TYPE_NORMAL
- en: private el = inject(ElementRef).nativeElement;
  prefs: []
  type: TYPE_NORMAL
- en: 'ngOnInit() { ElementRef by using constructor injection instead of the inject
    function and then add the background color and text color inside the function
    brackets of the constructor. Alternatively, if you only want to set a style, CSS
    class, or attribute on the host element, you can use the @HostBinding() decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to apply this directive, you need to import it in a standalone component
    or NgModule and use the selector on an HTML element like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '@Input() btLibsUiHighlight!: string;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: this.el.style.backgroundColor = this.btLibsUiHighlight;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <div [btLibsUiHighlight]="'orange'">I'm highlighted</div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '@Input(''btLibsUiHighlight'') background!: string;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '@Input() textColor = ''white'';'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<div [btLibsUiHighlight]="''orange''" btLibsUiHighlight input is required;
    the additional inputs are optional, but remember to give them a default value;
    otherwise, you might run into errors or unwanted UI behavior. You can make both
    inputs optional with default values; you have to rename the inputs so that no
    input has the same name as the directive selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you change the directive on the HTML element by removing the square brackets
    and adding the additional inputs only if you want to overwrite the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: private el = inject(ElementRef).nativeElement;
  prefs: []
  type: TYPE_NORMAL
- en: private originalColor = 'black';
  prefs: []
  type: TYPE_NORMAL
- en: private originalBackground = 'white';
  prefs: []
  type: TYPE_NORMAL
- en: '@HostListener(''mouseenter'') onMouseEnter() {'
  prefs: []
  type: TYPE_NORMAL
- en: this.originalColor = this.el.style.color;
  prefs: []
  type: TYPE_NORMAL
- en: this.originalBackground = this.el.style.backgroundColor;
  prefs: []
  type: TYPE_NORMAL
- en: this.el.style.backgroundColor = this.background;
  prefs: []
  type: TYPE_NORMAL
- en: this.el.style.color = this.textColor;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@HostListener(''mouseleave'') onMouseLeave() {'
  prefs: []
  type: TYPE_NORMAL
- en: this.el.style.backgroundColor = this.originalBackground;
  prefs: []
  type: TYPE_NORMAL
- en: this.el.style.color = this.originalColor;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<div *ngFor directive; as you can see, it’s prefixed with an asterisk. This
    asterisk is typical for structural directives and helps you to distinguish them
    from attribute directives in your HTML templates. Another difference between structural
    and attribute directives is that you can declare multiple attribute directives
    on a DOM element but only one structural directive. If you want to apply multiple
    structural directives, you need to wrap the DOM element with an ng-container tag
    and add the additional directive to the ng-container tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Angular exposes built-in directives and allows you to create your own. First,
    let’s look at some common built-in structural directives
  prefs: []
  type: TYPE_NORMAL
- en: Common built-in structural directives
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used built-in structural directives are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*ngIf`: This is used to conditionally show or hide DOM elements (alternatively
    (to the directive), you can use the new `@if` control flow syntax, as shown in
    [*Chapter 2*](B21625_02.xhtml#_idTextAnchor033)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*ngFor`: This is used to create a for loop in your HTML template and output
    a DOM element for each item in an array (alternatively (to the directive), you
    can use the new `@for` control flow syntax, as shown in [*Chapter 2*](B21625_02.xhtml#_idTextAnchor033)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*ngSwitch`: This is used to create a switch case in your HTML template and
    display the DOM elements for the matching switch case (alternatively (to the directive),
    you can use the new `@switch` control flow syntax, as shown in [*Chapter 2*](B21625_02.xhtml#_idTextAnchor033)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you ever worked on an Angular application, you have most likely seen and
    used all of these structural directives before, as they are really common. Still,
    the `*ngIf` and `*ngFor` directives have some additional, lesser-known properties
    that I want to explain and showcase. After that, we will create a custom structural
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: Using *ngIf to its fullest extent
  prefs: []
  type: TYPE_NORMAL
- en: 'The `*ngIf` directive is used to display DOM elements conditionally. The DOM
    elements do not render unless the property or statement is evaluated as `true`.
    Often, you need to display one block of HTML if the condition is `true` and another
    if it’s `false`. A common solution to this is to use two `*ngIf` directives with
    an opposing statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is perfectly valid and very readable syntax, but `*ngIf` also allows you
    to create an `if-else` statement. You can do this with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is a bit bulky in the HTML template because you need to
    use the `ng-template` tag for the content shown when the `else` statement is triggered.
    What syntax you want to use is up to you; there is no better or worse way; it’s
    more about preference.
  prefs: []
  type: TYPE_NORMAL
- en: Using *ngFor effectively
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `*ngFor`, you can add many properties to enhance the usage of the
    directive. The `*ngFor` directive outputs DOM elements for each item in a list.
    Often, when you output DOM elements for a list, you want to know the current index,
    if something is the first or last element, or if it’s an odd or even index. Based
    on these values, you might want to add some styling classes or use specific properties
    in the template. The `*ngFor` directive allows you to detect these values like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you can add variables to the `HTML` tag that defines the `*ngFor`
    directive to access values such as `index`, `first`, `last`, `odd`, and `even`.
    If our `list` would be the following array: `[0, 1, 2, 3]`, then the preceding
    code snippet would output the following result in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Besides the `index`, `first`, `last`, `odd`, and `even` properties, `*ngFor`
    also has something else to improve its performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, when you render something with `*ngFor` and something changes in
    the list, Angular will re-render the entire list. As you can imagine, this affects
    your performance negatively. You can add the `trackBy` function to improve this.
    When you use the `trackBy` function, Angular will identify each item by using
    the `index` or an `ID`. By doing so, it will only re-render things that change.
    It’s recommended that you use the `trackBy` function as much as possible. In the
    template, you can define the `trackBy` function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In your component class, you can define the `trackBy` function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know about the hidden features of `*ngIf` and `*ngFor`, let’s see
    how you can create custom structural directives.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom structural directives
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own structural directives is similar to creating attribute directives,
    but the directive class has some critical differences. In addition, the use cases
    are different. Custom attribute directives are useful for things such as auto-focusing
    on elements, applying different themes to specific elements, highlights, text
    resizing, tooltips, and popovers, as well as adding CSS classes, aria attributes,
    or IDs. Custom structural directives are used to remove or add DOM elements; some
    good use cases are an `if false` directive, a `"repeat x number of times"` function,
    and showing or hiding elements based on permissions or specific window sizes.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a custom directive that shows an element when a condition is
    false, which is basically the opposite of the `*ngIf` directive. Start by generating
    the directive using the same steps we used for generating the custom attribute
    directive (see the *Creating custom attribute directives* section). The only difference
    will be the name; this time, name the directive `ifFalse`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When your directive class is generated, you can start to add the logic for
    your structural directive. In the attribute directive, you injected `ElementRef`;
    for the structural directive, you must inject `TemplateRef` and `ViewContainerRef`.
    When you add a structural directive to an HTML element, Angular will convert it
    into an embedded template using the `ng-template` tags like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The embedded template created by Angular is what you access with `TemplateRef`.
    The embedded template is not rendered unless the structural directives adds it
    to the view container using `ViewContainerRef`. `ViewContainerRef` gives you access
    to the view where the host element with the directive is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding `TemplateRef` and `ViewContainerRef` to your directive
    class. You can inject `TemplateRef` and `ViewContainerRef` by using constructor
    injection or the `inject` function; I will use the `inject` function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also track if we already added the embedded view to the view container.
    To do this, add another private property to the directive class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need an `@Input()` for our `if false` directive so we can give it
    a condition to assess. We will use an `@Input()` setter, so each time, it receives
    a new value; we can perform the logic to add or remove the embedded template to
    the view when the condition is evaluated. The `@Input()` setter needs to have
    the same name as the directive selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `@Input()` setter, we will add the embedded template as an embedded
    view of the view container if the condition evaluates as `false` and if we have
    not already added it to the embedded template. In the case of an `if false` directive,
    when the condition evaluates to true, and considering we have already added the
    embedded template, we want to clear the view container so that the previously
    added embedded view is removed and Angular renders the original HTML again without
    the additional embedded template added to it. To achieve this, you can change
    `@Input()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we add `TemplateRef` as an embedded view when our check passes;
    otherwise, we clear the view container, given that we already added `TemplateRef`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use our custom structural directive like any other directive by
    using the directive selector with an asterisk in front of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know how to use built-in and create custom attribute and structural
    directives, let’s learn what you can do with directive selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Directive selectors
  prefs: []
  type: TYPE_NORMAL
- en: '`btLibsUiHighlight` directive and change the selector so that it will be applied
    to all span elements by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use the preceding example as a selector, the directive will automatically
    be applied to all span elements, and you can add it to other elements using the
    `btLibsUiHighlight` selector. Now, let’s say you need an option to exclude some
    span elements, so by default, all span elements receive the highlight directive,
    but when you want to opt-out, you can. To achieve this, you can add the `:not`
    syntax to the selector like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all span elements will have the highlight directive applied unless you
    add `noHighlight` to a span element. For all other elements, you still need to
    add `btLibsUiHighlight` to apply the directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to exclude HTML elements, you can achieve this using your selector
    by using the `:not` syntax like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When you use the preceding selector, you can add the `btLibsUiHighlight` directive
    to all elements but the `label` element. When you try to add the directive to
    a `label` element, the compiler will throw up an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also make selectors that apply directives to HTML elements with a specific
    ID, data attribute, or CSS class applied to the HTML element. Here is an example
    for all three of these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know everything you need to know about built-in directives, custom
    directives, and directive selectors, let’s move on and learn about directive composition.
  prefs: []
  type: TYPE_NORMAL
- en: Angular directive composition
  prefs: []
  type: TYPE_NORMAL
- en: '**Directive composition** is a relatively new concept that was introduced in
    Angular version 15\. As the word indicates, directive composition lets you compose
    different directives on components and directives. It lets you declare directives
    in component and directive class decorators instead of adding them using HTML
    templates. You can use directive composition to automatically apply directives
    to components, just like directive selectors. Directive composition can also be
    used to create directives that apply multiple directives using a single selector.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have a tag and button component and a type and size directive,
    allowing you to set a type (primary or secondary) and size (small, medium, or
    large), which applies a specific CSS class to the host element. If you want to
    automatically apply these two directives to all your buttons and tags, you can
    use directive composition to achieve this. Add a `hostDirectives` array inside
    the component decorator to add the directives to the component. In the `hostDirectives`
    array, you can add objects with the directive and the inputs for the decorator.
    If the decorator has no inputs, you can add the decorator class to the `hostDirectives`
    array. If you always want to use the input’s default value (given the input has
    a default value), you don’t have to declare the input in the `hostDirectives`
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining the objects in the `hostDirectives` array, the two directives
    will be applied automatically when you declare the button or tag component in
    a template. When using directive composition, you can also alias the input values
    of the directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in your HTML templates, if you want to supply a value for the `btLibsUiType`
    input of `TypeDirective`, you can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Using directive composition inside directives works the same as in components.
    Let’s say we have `backgroundColorDirective` and `textColorDirective`; we can
    declare `textColorDirective` inside the `hostDirectives` array of `backgroundColorDirective`.
    Now, when you use `backgroundColorDirective`, both directives will be applied,
    and the inputs of both directives will be exposed, given that you defined the
    inputs of `textColorDirective` in the `hostDirectives` array of `backgroundColorDirective`.
  prefs: []
  type: TYPE_NORMAL
- en: When using directive composition, you need to use standalone directives. Otherwise,
    it will not work. Also, each time a component is created, a new instance of all
    the directives declared in the `hostDirectives` array will be created. Because
    a new instance of each directive is created for each instance of the host component,
    you must be careful when using directive composition. When you put too many directives
    inside commonly used components, your memory usage will blow up and negatively
    affect the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about attribute directives, structural directives,
    directive selectors, and directive composition. We will now move on to the next
    section of this chapter and start to learn more about transforming values by using
    Angular pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming values using Angular pipes
  prefs: []
  type: TYPE_NORMAL
- en: 'In Angular, **pipes** are used to transform values. Angular offers a lot of
    useful built-in pipes and allows you to create your own. Let’s first list the
    most powerful and commonly used built-in pipes and briefly explain what they are
    used for:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AsyncPipe`: `AsyncPipe` is used to handle asynchronous values in your templates.
    It automatically subscribes to an `AsyncPipe` unsubscribe automatically because
    this prevents memory leaks. It’s recommended to use `AsyncPipe` as much as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpperCasePipe`: This pipe is used to transform a text value into all uppercase
    characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LowerCasePipe`: This pipe is used to transform a text value into all lowercase
    characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TitleCasePipe`: This pipe is used to capitalize the first letter of each word.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CurrencyPipe`: This pipe is used to transform a number value into a currency
    value with a currency symbol. You can also control the decimal formatting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DatePipe`: This is used to format date values based on the format you specify.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to explore all the built-in pipes, you can find a complete list
    at this URL: [https://angular.io/guide/pipes](https://angular.io/guide/pipes).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about the most commonly used built-in pipes, let’s see how
    you can use pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Using pipes in HTML templates and TypeScript files
  prefs: []
  type: TYPE_NORMAL
- en: 'Pipes are commonly used in HTML templates, but you can also use them in your
    TypeScript files. To use pipes in HTML templates, you can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'On the left side, you have a property or value; then, you indicate that you’re
    going to use a pipe with the vertical bar (pipe symbol: `|`), and on the right
    side of the pipe symbol, you declare the name of the pipe you want to use; in
    our example, it is `date`. If your pipe takes a parameter, you supply the parameter
    by adding a colon and the value like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When a pipe takes more than one parameter, you can chain them together by adding
    another colon and append the value after the colon like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can chain multiple pipes to a value if you need to apply them. When you
    chain pipes, they will be executed one by one, from left to right. Chaining pipes
    is done using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned before, you can also use pipes inside your TypeScript files. Although
    pipes are mostly used inside HTML templates, they can also be useful inside your
    TypeScript files. You can add pipes to the providers array of your component and
    then inject the pipes using dependency injection. After injecting the pipe, you
    can use it in your component class by calling the `transform` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When using standalone components (as we are doing), you need to import the pipe
    into the component before you can use the pipe. You can either import `CommonModule`,
    which contains all the pipes, or import the specific pipe if it’s a simple component
    and you don’t need `CommonModule` for other purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to use pipes in your HTML templates and TypeScript files,
    let’s learn about pure and impure pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Is it pure or impure?
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular pipes come in two flavors: `pure false` flag. The difference between
    pure and impure pipes lies in their update behavior and how Angular runs change
    detection on them.'
  prefs: []
  type: TYPE_NORMAL
- en: You need to use a pure transform function when creating a pure pipe. A **pure
    function** is a function that always returns the same output when given the same
    input.
  prefs: []
  type: TYPE_NORMAL
- en: Angular only runs a pure pipe when a pure change in the input value is detected.
    Pure changes are changes to a primitive value (number, string, Boolean, bigint,
    symbol, undefined, and null) or when a new reference object is supplied (date,
    array, function, or object). Changes to a reference object are not seen as pure
    changes. So, if you have a pure pipe that takes an array as a value, updating
    the array will not trigger the pipe because this is an impure change. When you
    assign the property using a new array, the pipe will run because it receives a
    new reference object instead, which is a pure change.
  prefs: []
  type: TYPE_NORMAL
- en: Angular skips updates of reference objects when running pure pipes because detecting
    pure changes is much faster than performing deep checks on objects; because of
    this, Angular can quickly determine if your pipes need to be executed again or
    if the pipe can be skipped. If Angular had to do a deep check or run your pipes
    on each change detection cycle, it would hugely impact the performance of your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, remember that when you use pure pipes with reference objects, you might
    not always get what you expect unless you know what you’re doing. For example,
    suppose that you have a dashboard array and a pipe that filters the array only
    to include active dashboards like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, when updating the dashboard array with `push`, the pipe will not run because
    the reference of the dashboard array did not change. If you assign a dashboard’s
    property using a new array, the reference changes and Angular’s change detection
    will trigger the active pipe and filter the results as expected.
  prefs: []
  type: TYPE_NORMAL
- en: When using an impure pipe, Angular will execute the pipe each time it detects
    a change. This means Angular will run the pipe upon each keystroke or mouse movement.
    Impure pipes can be useful and will update reference objects as expected, but
    be careful when using impure pipes, as they can dramatically slow down your application.
    When you use impure pipes, you want to set the change detection strategy of your
    component to `OnPush` so that your pipes will not be executed too often. When
    the component change detection is set to `OnPush`, change detection will only
    run when the component receives new input values or when you trigger it manually.
    It’s good practice to set your change detection strategy to `OnPush` as much as
    possible, as it will help improve your application’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the difference between pure and impure pipes, let’s
    learn more about `AsyncPipe`, as it is the most important built-in pipe Angular
    provides us with. After learning about `AsyncPipe`, we will learn how to create
    custom pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Using AsyncPipe
  prefs: []
  type: TYPE_NORMAL
- en: The most powerful built-in pipe is `AsyncPipe`. Even though `AsyncPipe` is an
    impure pipe, it’s recommended to use it as much as possible to handle the observable
    and promise results used in your templates. Using `AsyncPipe` offers advantages
    over handling observables with subscriptions in your component class.
  prefs: []
  type: TYPE_NORMAL
- en: First, `AsyncPipe` subscribes and, more importantly, unsubscribes to observables
    automatically. This is very important because it prevents memory leaks. If you
    don’t clean up a subscription correctly, you will end up with memory leaks, and
    your application will start to slow down and show unexpected behavior up to the
    point of crashing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate `AsyncPipe`, we will create an observable in the component class
    using the RxJS `interval` operator like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This `interval` observable will emit the next index every 2 seconds, starting
    at `0`. So, after 2 seconds, the observable emits `0`, and after another 2 seconds,
    the observable emits `1`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can subscribe to the `interval` observable inside the component class and
    assign the result to a component property that we display inside the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can use the `count` property inside your template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re using `OnPush` change detection for your component, you need to call
    a change detection manually each time the observable receives a new value. Otherwise,
    the `count` property will not be updated in your template. When using the aforementioned
    approach, you must also add logic to unsubscribe from your observable when the
    component is destroyed or when the observable property is assigned to another
    observable. Now, let’s see how we can use the interval observable in our HTML
    template using `AsyncPipe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using `AsyncPipe` is simple. You declare the property assigned
    using the observable (in our case, it’s named `timer`) and add `AsyncPipe` next
    to it. Each time the interval observable emits a new value, it will be reflected
    in our template. There is no need for an extra property to save the observable
    result, no need to unsubscribe, and there is no risk of memory leaks! Even when
    you assign the `timer` property using a new observable, the async pipe will automatically
    unsubscribe from the old observable and subscribe to the new observable.
  prefs: []
  type: TYPE_NORMAL
- en: When using the async pipe, using `OnPush` change detection is recommended because
    `AsyncPipe` is impure. Another advantage of `AsyncPipe` is that it automatically
    marks the component template that needs to be checked for changes when the pipe
    receives a new value. This is useful when you set your change detection strategy
    to `OnPush`. When using a regular observable subscription, the HTML template is
    not marketed to be checked for changes if you use the `OnPush` strategy, meaning
    you have to trigger the change detection manually after your subscription receives
    a new value.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know more about `AsyncPipe` and why it’s such a powerful tool, let’s
    explore how you can create your own pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Building your own pipes
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating pipes in our Nx monorepo, we will do so in a `util` library.
    For our example, we will create a simple pipe that will multiply a number using
    a specified factor. The correct place to create this pipe is in a library under
    the shared domain and the `util` type. Use our custom generator to create a new
    library with the name: `common-pipes` and select **shared** as its domain and
    **util** as its type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When your new library is generated, follow these steps to generate the custom
    pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Close and reopen VSCode so that your new library is included in the Nx schematics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on the folder at this location: `libs\shared\util\common-pipes\src\lib`,
    and select **Nx generate**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `pipe` and click on **@nx/angular –** **pipe**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `multiply` for the **name*** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Show** **all options**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **standalone** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Generate** in the top right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the component is generated, add the following to the `index.ts` file
    in the library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After that, you can use your pipe, but before using it, let’s add some logic.
  prefs: []
  type: TYPE_NORMAL
- en: When you open the `multiply.pipe.ts` file, you’ll see that Nx generated a `MultiplyPipe`
    class, which implements the `PipeTransform` interface. The class is also decorated
    with the `@Pipe()` decorator, where the standalone flag is set to `true` and the
    pipe name `multiply` is defined. Inside this decorator, you can add the pure flag;
    your pipe is pure by default. You only have to add the pure flag with a `false`
    value when you want to create an impure pipe. In our example, we will create a
    simple, pure pipe, so there is no need to add the pure flag to the decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nx also added a transform function to the class to adhere to the `PipeTransform`
    interface. The transform function is the “hard” of your pipe, where you add your
    transformation logic. You can adjust the transform function to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have a value and a multiplier function parameter. The value
    parameter is what we declare on the left side of the pipe in our HTML templates.
    `multiplier` is the parameter we supply after the colon. We gave `multiplier`
    a default value of `2`, so it’s optional when declaring the pipe in your templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to use the pipe, you first need to import it; if you work with
    NgModules, the pipe needs to be imported in an NgModules instance; if you work
    with standalone components, like we are doing here, you have to import the pipe
    into the components you want to use it in. After you import the pipe into a standalone
    component, you can use it in the template like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to supply the pipe with a custom multiplier value, you can use
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to add more parameters to your pipe, you can do so by adding more
    parameters inside your transform function. Let’s say you want another multiplier
    in your `multiply` pipe. You can add it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can use the following syntax inside your HTML templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Our example pipe is simple, but you can add any logic you want inside your
    transform function. Just make sure you use a pure function when creating a pure
    pipe, that is, a function that returns the same value when given the same input
    and doesn’t affect any other code. When you create an impure pipe, make sure not
    to add time-consuming or resource-intensive code, as it will impact the performance
    of your application negatively. Here is an example of how you make a pipe impure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now you know that pipes are used to transform values. Angular offers built-in
    pipes for common transformations and to handle asynchronous values. You know the
    difference between pure and impure pipes, and you can create your own custom pipes.
    To finish this chapter, we will learn about Angular animations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and reusing stunning animations
  prefs: []
  type: TYPE_NORMAL
- en: In the previous sections, you’ve seen how to manipulate DOM elements using directives
    and how to transform template values using pipes; in this section, you will learn
    how to create animations for your HTML elements and components using the built-in
    animation module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, you have to enable the animation module. To do this, go to `app.config.ts`
    in your applications under the *expenses-registration application* in your Nx
    monorepo. Inside `app.config.ts`, you’ll find the `appConfig` object used in your
    `main.ts` inside the `bootstrapApplication` function. To enable the animation
    module, add the `provideAnimations()` function inside the providers array of the
    `appConfig` object like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re using an NgModule-based application, you need to import `BrowserAnimationsModule`
    inside the NgModule where you want to use animations. After adding either the
    `provideAnimations` function or `BrowserAnimationsModule`, you can start adding
    animations inside your components. To demonstrate animations, let’s create a selectable
    label component inside our `common-components` library. Use the Nx generator to
    create a component, name it `selectable-label`, choose the `common-components`
    library for the project, check the `OnPush`. When the component is generated,
    add the following export in the `index.ts` of the `common-components` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following code to the `component` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following CSS to the SCSS file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following HTML to the HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a simple label component, let’s create our animation. Start
    by adding the `animations` array inside your component decorator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Animations for the component are added inside this `animations` array. Add
    the following animation inside the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple animation that changes the background color from the hex color
    `#382632` to `#455b66` and takes 2 seconds to perform the transition. Now let’s
    examine what we added line by line.
  prefs: []
  type: TYPE_NORMAL
- en: Animation trigger
  prefs: []
  type: TYPE_NORMAL
- en: 'Our animation starts with a trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'state(''selected'', style({ backgroundColor: ''#382632'' })),'
  prefs: []
  type: TYPE_NORMAL
- en: 'state(''deselected'', style({ backgroundColor: ''#455b66''})),'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: transition('selected <=> deselected', [animate('2s')])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'animate(''2s'', style({ color: ''red'' })),'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: animate('2s', keyframes([
  prefs: []
  type: TYPE_NORMAL
- en: 'style({ backgroundColor: ‹blue›, offset: 0}),'
  prefs: []
  type: TYPE_NORMAL
- en: 'style({ backgroundColor: ‹red›, offset: 0.8}),'
  prefs: []
  type: TYPE_NORMAL
- en: 'style({ backgroundColor: ‹#754600›, offset: 1.0})])),'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: sequence([
  prefs: []
  type: TYPE_NORMAL
- en: 'animate(‹2s›, style({ backgroundColor: ‹#382632› })),'
  prefs: []
  type: TYPE_NORMAL
- en: 'animate(‹2s›, style({ color: ‹orange› }))'
  prefs: []
  type: TYPE_NORMAL
- en: '])'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: group([
  prefs: []
  type: TYPE_NORMAL
- en: 'animate(‹2s›, style({ color: ‹white› })),'
  prefs: []
  type: TYPE_NORMAL
- en: 'animate(‹2s›, style({ backgroundColor: ‹#455b66› })),'
  prefs: []
  type: TYPE_NORMAL
- en: '])'
  prefs: []
  type: TYPE_NORMAL
- en: group([
  prefs: []
  type: TYPE_NORMAL
- en: 'animate(‹2s›, style({ fontSize: ‹24px› })),'
  prefs: []
  type: TYPE_NORMAL
- en: 'animate(‹2s›, style({ opacity: ‹0.5› })),'
  prefs: []
  type: TYPE_NORMAL
- en: '])'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[@selectedState]="animationState"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: (@selectedState.start)="onAnimationEvent($event)"
  prefs: []
  type: TYPE_NORMAL
- en: (@selectedState.done)="onAnimationEvent($event)"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: <div [@.disabled]="isDisabled"> ……… </div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'export function selectedAnimation(): AnimationTriggerMetadata {'
  prefs: []
  type: TYPE_NORMAL
- en: return trigger('selectedState', [
  prefs: []
  type: TYPE_NORMAL
- en: 'state(‹selected›, style({ backgroundColor: ‹#382632› })),'
  prefs: []
  type: TYPE_NORMAL
- en: 'state(‹deselected›, style({ backgroundColor: ‹#455b66›})),'
  prefs: []
  type: TYPE_NORMAL
- en: transition(‹selected <=> deselected›,[animate(‹2s›)]),])
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '@Component({'
  prefs: []
  type: TYPE_NORMAL
- en: ………
  prefs: []
  type: TYPE_NORMAL
- en: 'animations: [selectedAnimation()],'
  prefs: []
  type: TYPE_NORMAL
- en: '})'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
