- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Handling User Inputs: Forms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the early days of web applications, before the concept of `<form>` tag
    has been used to create, organize, and send forms to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: In common applications, such as banking systems and health applications, we
    use forms to organize the inputs that our users need to perform in our systems.
    With such a common element in web applications, it is natural that Angular, a
    framework whose philosophy is *batteries included*, offers this feature to its
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will delve into the following forms features in Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: Template-driven forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom validations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typed reactive forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create maintainable and fluid
    forms for your user, in addition to improving your productivity with this type
    of task.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch6](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch6).
  prefs: []
  type: TYPE_NORMAL
- en: During the study of this chapter, remember to run the backend of the application
    found in the `gym-diary-backend` folder with the `npm` `start` command.
  prefs: []
  type: TYPE_NORMAL
- en: Template-driven forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular has two different ways of working with forms: **template-driven** and
    **reactive**. First, let’s explore template-driven forms. As we can see by the
    name, we maximize the use of the capabilities of the HTML template to create and
    manage the data model linked to the form.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will evolve our Gym Diary application to better exemplify this concept.
    In the following command line, we use the Angular CLI to create the new page component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To access the new assignment form, we’ll refactor the journal page component
    so the **Add New Entry** button takes the user to the component we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add to the `DiaryModule` module the import of the framework module responsible
    for managing the application’s routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `RouterModule` module imported, we will be able to use Angular’s route
    services. For more details on routing, see [*Chapter 7*](B19562_07.xhtml#_idTextAnchor207),
    *Routes and Routers*. We will add the new component to a route in the `DiaryRoutingModule`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To be able to compare the two form creation approaches, we will create a route
    for each example component that we are going to create. Here, the URL `/home/new-template`
    will direct us to the template-driven form route.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now refactor `DiaryComponent` to modify the behavior of the **Add New**
    **Entry** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to inject Angular’s router service.We change the `addExercise`
    method to use the service and, using the `navigate` method, direct to the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can proceed to the HTML template of our form in the `new-entry-form-template.component.html`
    file and place only the elements of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Angular uses HTML best practices, so we will now create the form fields under
    the HTML `<form>` tag. In the input fields, we are respecting the HTML semantics
    and creating the fields as `<input>` with the correct types for the type of information
    the client needs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s run our application with the `ng serve` command. By clicking on the **New
    Entry** button, we will be able to notice our diary entry addition form.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Gym Diary Form UI](img/B19562_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Gym Diary Form UI
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have the structure and template of our form. Now, we are going to
    prepare for Angular to manage the state of the fields via user input in the template.
    To use the template-driven form, we need to import the `FormModule` module to
    our feature module, `DiaryModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In our form template, we will add the directives that will create and link
    the form information to its data model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: export class NewEntryFormTemplateComponent {
  prefs: []
  type: TYPE_NORMAL
- en: private exerciseSetsService = inject(ExerciseSetsService);
  prefs: []
  type: TYPE_NORMAL
- en: private router = inject(Router);
  prefs: []
  type: TYPE_NORMAL
- en: 'entry: ExerciseSet = { date: new Date(), exercise: '''', reps: 0, sets: 0 };'
  prefs: []
  type: TYPE_NORMAL
- en: newEntry() {
  prefs: []
  type: TYPE_NORMAL
- en: const newEntry = { ...this.entry };
  prefs: []
  type: TYPE_NORMAL
- en: this.exerciseSetsService
  prefs: []
  type: TYPE_NORMAL
- en: .addNewItem(newEntry)
  prefs: []
  type: TYPE_NORMAL
- en: .subscribe((entry) => this.router.navigate(['/home']));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: ng g c diary/new-entry-form-reactive
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: import { NewEntryFormReactiveComponent } from './new-entry-form-reactive/new-entry-form-reactive.component';
  prefs: []
  type: TYPE_NORMAL
- en: 'const routes: Routes = ['
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'path: '''','
  prefs: []
  type: TYPE_NORMAL
- en: 'component: DiaryComponent,'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'path: ''new-template'','
  prefs: []
  type: TYPE_NORMAL
- en: 'component: NewEntryFormTemplateComponent,'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'path: ''new-reactive'','
  prefs: []
  type: TYPE_NORMAL
- en: 'component: NewEntryFormReactiveComponent,'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '];'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '@NgModule({'
  prefs: []
  type: TYPE_NORMAL
- en: 'declarations: ['
  prefs: []
  type: TYPE_NORMAL
- en: . . .
  prefs: []
  type: TYPE_NORMAL
- en: '],'
  prefs: []
  type: TYPE_NORMAL
- en: 'imports: ['
  prefs: []
  type: TYPE_NORMAL
- en: . . .
  prefs: []
  type: TYPE_NORMAL
- en: ReactiveFormsModule,
  prefs: []
  type: TYPE_NORMAL
- en: '],'
  prefs: []
  type: TYPE_NORMAL
- en: '})'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'addExercise(newSet: ExerciseSet) {'
  prefs: []
  type: TYPE_NORMAL
- en: this.router.navigate(['/home/new-reactive']);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: export class NewEntryFormReactiveComponent implements OnInit {
  prefs: []
  type: TYPE_NORMAL
- en: 'public entryForm!: FormGroup;'
  prefs: []
  type: TYPE_NORMAL
- en: private formBuilder = inject(FormBuilder);
  prefs: []
  type: TYPE_NORMAL
- en: ngOnInit() {
  prefs: []
  type: TYPE_NORMAL
- en: this.entryForm = this.formBuilder.group({
  prefs: []
  type: TYPE_NORMAL
- en: 'date: [''''],'
  prefs: []
  type: TYPE_NORMAL
- en: 'exercise: [''''],'
  prefs: []
  type: TYPE_NORMAL
- en: 'sets: [''''],'
  prefs: []
  type: TYPE_NORMAL
- en: 'reps: [''''],'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: <div class="flex h-screen items-center justify-center bg-gray-200">
  prefs: []
  type: TYPE_NORMAL
- en: <form
  prefs: []
  type: TYPE_NORMAL
- en: '[formGroup]="entryForm"'
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: <input
  prefs: []
  type: TYPE_NORMAL
- en: type="date"
  prefs: []
  type: TYPE_NORMAL
- en: id="date"
  prefs: []
  type: TYPE_NORMAL
- en: name="date"
  prefs: []
  type: TYPE_NORMAL
- en: formControlName="date"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: <input
  prefs: []
  type: TYPE_NORMAL
- en: type="text"
  prefs: []
  type: TYPE_NORMAL
- en: id="exercise"
  prefs: []
  type: TYPE_NORMAL
- en: name="exercise"
  prefs: []
  type: TYPE_NORMAL
- en: formControlName="exercise"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: <input
  prefs: []
  type: TYPE_NORMAL
- en: type="number"
  prefs: []
  type: TYPE_NORMAL
- en: id="sets"
  prefs: []
  type: TYPE_NORMAL
- en: name="sets"
  prefs: []
  type: TYPE_NORMAL
- en: formControlName="sets"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: <input
  prefs: []
  type: TYPE_NORMAL
- en: type="number"
  prefs: []
  type: TYPE_NORMAL
- en: id="reps"
  prefs: []
  type: TYPE_NORMAL
- en: name="reps"
  prefs: []
  type: TYPE_NORMAL
- en: formControlName="reps"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: <button type="submit">
  prefs: []
  type: TYPE_NORMAL
- en: Add Entry
  prefs: []
  type: TYPE_NORMAL
- en: </button>
  prefs: []
  type: TYPE_NORMAL
- en: formGroup attribute to associate the template with the object we created earlier.
    To associate each template field to the FormGroup attribute, we use the formControlName
    element.
  prefs: []
  type: TYPE_NORMAL
- en: To debug the data model, we are also using the JSON pipe, but note that to get
    the data model filled in by the user, we use the `value` attribute of the `entryForm`
    object. Finally, we will complement the form with functionality and record the
    input using the project’s API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to change the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we inject the consumer services of the `ExerciseSetsService` API and the
    Angular route service router.
  prefs: []
  type: TYPE_NORMAL
- en: In the `newEntry` method, as in the previous example, we capture the data that
    the user typed. However, in the reactive form, it is in the `value` attribute,
    and we send this attribute to the API using the service.
  prefs: []
  type: TYPE_NORMAL
- en: Running the project, we can see that the interface works like its counterpart
    written for the template-driven form.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Gym Diary Form UI using a reactive -form](img/B19562_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Gym Diary Form UI using a reactive -form
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering, what is the advantage of using the reactive form and why
    is it recommended by the Angular community and team? Next, we’ll see how to use
    the form’s built-in validations and how to integrate them into our reactive form.
  prefs: []
  type: TYPE_NORMAL
- en: Data validation
  prefs: []
  type: TYPE_NORMAL
- en: A good UX practice is to validate the information that users enter in the form
    as soon as it leaves the filled field. This minimizes user frustration while improving
    the information that will be sent to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using reactive forms, we can use utility classes created by the Angular team
    to add validations that are commonly used in forms. Let’s improve our project,
    first in the `NewEntryFormReactiveComponent` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are importing the `Validators` package from Angular
    that will provide the `utility` class for the basic validations of our report.
    In the `ngOnInit` method where we create the reactive form object, the validations
    are in the second position of the array that defines the form’s fields.
  prefs: []
  type: TYPE_NORMAL
- en: We use the required validation in all fields of the form, and in the `sets`
    and `reps` fields, we add another validation to guarantee that the number is positive.
    To add more than one validation, we can add another array with the validations.
  prefs: []
  type: TYPE_NORMAL
- en: Another change we made to our component is that it now checks whether the form
    is valid before starting the interaction with the backend. We do this by checking
    the `valid` attribute of the object. Angular automatically updates this field
    as the user enters data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the template file, let’s add the error messages for the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To show validation in the template, we use `div` elements with the message we
    want. To decide whether or not the message will appear, we use the `ngIf` directive,
    checking the status of the field.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we first get the field using the `GET` method and check the following
    two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The `invalid` property checks whether the field is invalid according to what
    was configured in the component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `touched` property checks whether the user has accessed the field. It is
    recommended not to show all the validations when the interface is loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the validations in each field, to improve usability, we changed
    the **Submission** button by disabling it while the form was invalid and applying
    the CSS to make it clear to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Running the project, we can see the validations accessing all fields without
    filling any field.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Gym Diary Form UI validations](img/B19562_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Gym Diary Form UI validations
  prefs: []
  type: TYPE_NORMAL
- en: We’ve learned how to use Angular’s utility classes to perform validation, so
    let’s explore how we can create our own custom validations.
  prefs: []
  type: TYPE_NORMAL
- en: Custom validations
  prefs: []
  type: TYPE_NORMAL
- en: We can expand the use of validations and create custom functions that can even
    receive parameters to maximize reuse in our projects. To illustrate this, let’s
    create a custom validation to evaluate whether the number of repetitions or sets
    are multiples of two and three, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new file called `custom-validation.ts` and add the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For Angular to recognize the form validation function, it must return a new
    function with the signature described in the `ValidatorFn` interface. This signature
    defines that it will receive `AbstractControl` and must return an object of type
    `ValidationErrors` that allows the template to interpret the new type of validation.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we get the input value using `control.value`, and if it is not a multiple
    of three, we will return the `error` object. Otherwise, we will return `null`,
    which will indicate to Angular that the value is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this function, we are going to refactor our form component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To use our custom function, we import it from the new file we created and use
    it in the validation array in the construction of the form object in the same
    way as standard Angular validations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s change the form template to add the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We include the new `div` elements, but to specifically validate the error of
    multiples of the input, we use the `error` attribute and in it the new `isNotMultiple`
    attribute of our custom function.
  prefs: []
  type: TYPE_NORMAL
- en: We are using this parameter in square brackets because it is defined at runtime
    and Angular will warn at compile time that it does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running our project, we can see the new validations:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.4 – Gym Diary Form UI\uFEFF custom validations](img/B19562_06_4.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Gym Diary Form UI custom validations
  prefs: []
  type: TYPE_NORMAL
- en: In addition to validations, reactive forms from version 14 of Angular can be
    better typed to ensure higher productivity and security in the development of
    your project. We will go over this function in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Typed reactive forms
  prefs: []
  type: TYPE_NORMAL
- en: In our project, if we look at the types of objects and values, we can see that
    they are all of the `any` type. Although functional, it is possible to improve
    this development experience by better using TypeScript’s type checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s refactor our code in the component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We moved the creation of the form object to the construction of the component
    and set the initialization of the fields with the types that will be accepted
    by the API. Using Visual Studio Code’s IntelliSense, we can see that Angular infers
    the types and now we have an object very close to the `ExerciseSet` type.
  prefs: []
  type: TYPE_NORMAL
- en: With this change, however, the `addNewItem` method threw an error, which is
    actually a good thing, as it means that we are now using TypeScript’s type checking
    to discover possible bugs that could only appear at runtime. To resolve this issue,
    we first need to change the service to receive an object that can contain some
    of the attributes of `ExerciseSet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the service, change the `addNewItem` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `Partial` type of TypeScript to inform the function that it
    can receive an object with part of the interface attributes. Returning to our
    component, we can see that it still has an error. This happens because it can
    receive `null` values in the form’s attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this, let’s change the `FormBuilder` service to the `NonNullableFormBuilder`
    type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this change, Angular itself performs this verification. The only requirement
    is that all the form fields are initialized, which we have already done here.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have our reactive form working and can now use TypeScript’s type-checking
    more effectively!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored Angular forms and how to use them to improve our
    user experience and our team’s productivity. We learned how to use template forms
    for simpler requirements and explored how Angular performs the binding between
    the HTML and the data model using the `ngModel` object.
  prefs: []
  type: TYPE_NORMAL
- en: We also work with reactive forms, which opens up many possibilities for creating
    and manipulating forms. Regarding reactive forms, we studied how to apply validations
    to fields and how to create our own custom validation functions. Finally, we refactored
    our reactive form to use TypeScript type checking using typed forms.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore Angular’s routing mechanism and the possibilities
    it can have for our applications.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
