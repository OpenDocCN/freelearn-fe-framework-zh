- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Migrating from React Class Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to build our own Hooks by extracting
    custom Hooks from existing code. Then, we used our custom Hooks in the blog app.
    Finally, we learned how to write tests for Hooks, using the React Testing Library,
    and wrote tests for our custom Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to start by implementing a todo app using React
    class components. Then, we are going to learn how to migrate an existing React
    class component application to Hooks. Seeing the differences between Hooks and
    class components in practice will deepen our understanding of the trade-offs of
    using either solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling state with React class components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating from React class components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trade-offs of React class components vs React Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A fairly recent version of Node.js should already be installed. The Node Package
    Manager (`npm`) also needs to be installed (it should come with Node.js). For
    more information on how to install Node.js, please check out their official website:
    [https://nodejs.org/](https://nodejs.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use **Visual Studio Code** (**VS Code**) for the guides in
    this book, but everything should work similarly in any other editor. For more
    information on how to install VS Code, please refer to their official website:
    [https://code.visualstudio.com](https://code.visualstudio.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we use the following versions:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js v22.14.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm` v10.9.2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code v1.97.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The versions mentioned in the preceding list are the ones used in the book.
    While installing a newer version should not be an issue, please note that certain
    steps might work differently on a newer version. If you are having an issue with
    the code and steps provided in this book, please try using the mentioned versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter13)'
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended that you write the code on your own. Do not simply
    run the code examples that are provided with the book. It is important to write
    the code yourself to be able to learn and understand it properly. However, if
    you run into any issues, you can always refer to the code example.
  prefs: []
  type: TYPE_NORMAL
- en: Handling state with React class components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start migrating from class components to Hooks, we are going to create
    a small todo list app using class components. Afterward, we are going to turn
    these class components into function components using Hooks. Finally, we are going
    to compare the two solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the app structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we did before with the blog app, we are going to start by thinking about
    the basic structure of our todo app. Here, we are going to need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to add new todo items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to show all todo items in a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A filter for the todo items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is always a good idea to start with a mock-up. So let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the previous list of structural elements, start by drawing a mock-up
    of an interface for our todo app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Mock-up of our todo app](img/B31327_13_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Mock-up of our todo app
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, map out the simple components by drawing around the UI elements and giving
    them a name, in a similar way to how we did it with the blog app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Mapping out simple components in our app mock-up](img/B31327_13_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Mapping out simple components in our app mock-up
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, map out the container components, which group together the simple components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Mapping out container components in our app mock-up](img/B31327_13_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Mapping out container components in our app mock-up
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, we are going to need the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`App`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Header`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddTodo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TodoList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TodoItem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TodoFilter` (+ `TodoFilterItem`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TodoList` component makes use of a `TodoItem` component, which is used
    to show an item, with a checkbox to complete and a button to remove it. The `TodoFilter`
    component internally uses a `TodoFilterItem` component to show the various filters.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to use the barebones Vite app from [*Chapter 1*](Chapter_01.xhtml#_idTextAnchor016)*,
    Introducing React and React Hooks* to create a new project. Let’s initialize the
    project now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the `Chapter01_3` folder to a new `Chapter13_1` folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the new `Chapter13_1` folder in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Delete* the current `src/App.jsx` file, as we are going to create a new one
    in the next step.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our project initialized, we can start defining the app structure.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the app structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already know what the basic structure of our app is going to be like from
    the mock-ups, so let’s start by defining the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `src/App.jsx` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside it, import `React`, and all the container components of our app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, define the `App` component as a class component. In a class component,
    we need to define a `render` method to render our component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The App component defines the basic structure of our app. It will consist of
    a header, a way to add new todo items, a list of todo items, and a filter.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are going to define the following components as static components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Header`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddTodo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TodoList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TodoItem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TodoFilter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later in this chapter, we are going to add dynamic functionality to them.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Header component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to start with the `Header` component, as it is the most simple
    out of all the components:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `src/Header.jsx` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this project, we decided to put all components directly in the `src/` folder,
    as there are only a handful of components anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the newly created file, import `React`, and define the class component
    with a `render` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Defining the AddTodo component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we are going to define the `AddTodo` component, which renders an `input`
    field and a button:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `src/AddTodo.jsx` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside it, import `React` and define the class component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `render` method, we return a form that contains an input field and a
    submit button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Defining the TodoList component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we define the `TodoList` component, which is going to make use of the `TodoItem`
    component (we will create that one in the next step). For now, we are going to
    statically define the data for two todo items in an array and use it to render
    `TodoItem` components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start defining the `TodoList` component:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `src/TodoList.jsx` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside it, import `React` and the `TodoItem` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define the class component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `render` method, we statically define two todo items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we are going to render the items using the `map` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We define the `key` property last, in order to avoid overwriting it with the
    spreading of the `item` object.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the TodoItem component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After defining the `TodoList` component, we are now going to define the `TodoItem`
    component, in order to render single items. Let’s start defining the `TodoItem`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `src/TodoItem.jsx` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside it, import `React` and define the class component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are going to use destructuring to get the `title` and `completed` props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we are going to render a checkbox, the title and a button to delete
    the item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Defining the TodoFilter component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we are going to define the `TodoFilter` component. In the same file,
    we are also going to define the `TodoFilterItem` component, as they are tightly
    coupled to each other. So, let’s start implementing these components:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `src/TodoFilter.jsx` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside it, import `React` and define a `TodoFilterItem` class component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use destructuring to get the `name` prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we return a button to select the filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we define the actual `TodoFilter` component, which is going to render
    three `TodoFilterItem` components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we finished implementing all static components, we can start the app.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To start the app, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Open the URL in a browser and you will see that the app looks just like our
    mock-up!
  prefs: []
  type: TYPE_NORMAL
- en: However, the app is completely static, and when we click on anything, nothing
    happens. In the next step, we are going to make our app dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing dynamic code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have defined all of the static components, our app should look just
    like the mock-up. The next step is to implement dynamic code using React state,
    life cycle, and handler functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we are going to:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a mock API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the `StateContext`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the `App` component dynamic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the `AddTodo` component dynamic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the `TodoList` component dynamic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the `TodoItem` component dynamic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the `TodoFilter` component dynamic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a mock API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First of all, we are going to define an API that will fetch todos. In our case,
    we are simply going to return an array of todo items, after a short delay, to
    simulate a network request, which usually takes some time to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start implementing the mock API now:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `src/api.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside it, define and export a function that returns items after a short delay:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we are using the Promise API to resolve with an array of mock items after
    waiting for 100ms to simulate a real API request.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to define a context that will keep our current list of todos.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the StateContext
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are now going to define the context that will keep the current state of
    our todo app:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `src/StateContext.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside it, import the `createContext` function from React:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define and export a context that contains an empty array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have a context where we can store our array of todo items, let’s
    move on to making the components dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Making the App component dynamic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to start by making the `App` component dynamic, adding functionality
    to fetch, add, toggle, filter, and remove todo items. To do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/App.jsx` and import the `StateContext` and the `fetchTodos` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we are going to modify our `App` class code, adding a `constructor` to
    it, which will set the initial state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this constructor, we first need to call `super` to make sure that the parent
    class (`React.Component`) constructor gets called and the component gets initialized
    properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can set the initial state with `this.state`. Initially, there are no
    todo items, and the filter is set to `all`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define the `componentDidMount` lifecycle method, which is going to
    load todo items when the component first renders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we are going to define the `loadTodos` method, which in our case, is
    simply going to set the state, as we are not going to connect this simple app
    to a backend. We are also going to call `this.filterTodos()` to update the `filteredTodos`
    array after fetching:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will define the `filterTodos` method later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the `addTodo` method, which creates a new item and adds it
    to the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To keep things simple, we are just using `Date.now()` to generate a unique id
    for each todo item.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We now define a `toggleTodo` method, which uses the `map` function to find
    and modify a certain todo item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define the `removeTodo` method, which uses the `filter` function to find
    and remove a certain todo item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define a method to apply different filters to todo items, such as `active`,
    `completed` and `all`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can define the `filterTodos` method, which is going to call the `applyFilter`
    method and update the `filteredTodos` and the `filter` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The **nullish coalescing** (`??`) operator is used to fall back to a different
    value when the value on the left hand side is `undefined` or `null`. Unlike the
    `||` operator, the `??` operator only triggers for `undefined`/`null` values,
    not for falsy values like `0`, `''`, or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: We are using `filterTodos` to re-filter todos after adding/removing, as well
    as changing the filter. To allow for both functionalities to work properly, we
    need to check if the filter argument `filterArg` was passed. If not, we fall back
    to the current `filter` value from the `state` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we adjust the `render` method and use the state to provide a value for
    the `StateContext`. We also pass certain methods down to the components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to re-bind `this` to the class, so that we can pass the methods
    to our components without the `this` context changing. Adjust the `constructor`
    method by rebinding the `this` context of all methods, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the `App` component can dynamically fetch, add, toggle, remove and filter
    todo items. As we can see, when we use class components, we need to re-bind the
    `this` context of the handler functions to the class. Otherwise, we would get
    an error when we call the methods, because their `this` context is not bound to
    the class anymore and thus they cannot call methods such as `this.setState`.
  prefs: []
  type: TYPE_NORMAL
- en: Making the AddTodo component dynamic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After making the `App` component dynamic, it is time to make all of our other
    components dynamic, too. We are going to start from the top, with the `AddTodo`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/AddTodo.jsx` and define a `constructor`, which sets the initial state
    for the input field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define a method for handling changes in the input field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define a method to handle submission of the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can assign the input value, as well as the input and submit handlers,
    to the relevant components. Additionally, we’ll disable the button when the input
    field is empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to adjust the constructor by re-binding the `this` context
    for all of the handler methods, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the `AddTodo` component will show a disabled button as long as no text
    is entered. Once we enter some text and click the button, it will trigger the
    `addTodo` method from the `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: Making the TodoList component dynamic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next component in our todo app is the `TodoList` component. Here, we just
    need to get the todo items from the `StateContext`. To do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/TodoList.jsx` and import the `StateContext`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we set the `contextType` to the `StateContext`, which will allow us to
    use the context via `this.context`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With class components, if you want to use multiple contexts, you have to use
    the `StateContext.Consumer` component, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can imagine, using multiple contexts like this will result in a very
    deep component tree, and the code will be hard to read and refactor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we can get the items from `this.context`, instead of statically defining
    them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we pass all props down to the `TodoItem` component, so that we can
    use the `removeTodo` and `toggleTodo` methods there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now the `TodoList` component gets the items from the `StateContext` instead
    of statically defining them. Next, let’s move on to making the `TodoItem` component
    dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Making the TodoItem component dynamic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have passed on the `removeTodo` and `toggleTodo` methods as props
    to the `TodoItem` component, we can implement these features there and make the
    `TodoItem` component dynamic too:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/TodoItem.jsx` and define handler methods for the `toggleTodo` and
    `removeTodo` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we assign the handler functions to the checkbox and button, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to re-bind the `this` context for the handler methods. Define
    a new `constructor` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now the `TodoItem` component properly triggers the toggle and remove methods.
    Next, we are going to make the `TodoFilter` component dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Making the TodoFilter component dynamic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lastly, we are going to use the `filterTodos` method to dynamically filter
    our todo item list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/TodoFilter.jsx` and, in the `TodoFilter` class component, pass all
    props down to the `TodoFilterItem` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, add a `handleFilter` method to the `TodoFilterItem` class
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, get the `filter` prop, disable the button with the currently selected
    filter, and call `this.handleFilter` when the button is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we define a `constructor` method for the `TodoFilterItem` class component
    and re-bind the `this` context of the handler function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now the `TodoFilter` component triggers the filter handler function to change
    the filter. Our whole app is dynamic now, and we can use all of its functionalities!
  prefs: []
  type: TYPE_NORMAL
- en: Starting the app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, we have finished making all components dynamic and can start
    the app, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Open the URL in a browser, try adding/toggling/removing/filtering todos, and
    you will see that everything works as expected!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Showing only completed items in our todo app](img/B31327_13_04.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – Showing only completed items in our todo app
  prefs: []
  type: TYPE_NORMAL
- en: '**Example code**'
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this section can be found in the `Chapter13/Chapter13_1`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our app works well with React class components, let’s use it to learn
    how to migrate an existing app to React Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from React class components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After setting up our example project with React class components, we are now
    going to migrate this project to React Hooks. We are going to show how to migrate
    side effects, such as fetching todos when the component mounts, as well as migrating
    the state management to a Hook based solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we are going to migrate the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TodoItem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TodoList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TodoFilterItem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TodoFilter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddTodo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`App`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we do that, please create a new folder for the migrated project, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the `Chapter13_1` folder to a new `Chapter13_2` folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the new `Chapter13_2` folder in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can get started migrating the components.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the TodoItem component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the simplest components to migrate is the `TodoItem` component. It does
    not use any state or side effects, so we can simply convert it to a function component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start migrating the `TodoItem` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit `src/TodoItem.jsx` and *delete* all of the existing code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we define a function component which accepts `title`, `completed`, `id`,
    `toggleTodo` and `removeTodo` props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define two handler functions to toggle and remove todo items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we render the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try to keep your function components small, and combine them by creating new
    function components that use other function components (this pattern is called
    **composition**). It is always a good idea to have many small components, rather
    than one large component. They are much easier to maintain, reuse, and refactor.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, function components do not require us to re-bind `this`, or
    to define constructors at all. Also, we do not need to destructure from `this.props`
    multiple times in multiple places. We can simply destructure all props in the
    function definition.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the app now, you will see that it still works. React actually lets
    you combine function components with class components, so there is no need to
    migrate the whole codebase at once, you can migrate certain parts at a time. React
    class components can even render function components that use Hooks. The only
    limitation is that we cannot use Hooks in class components. Therefore, we need
    to migrate a whole component at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to migrating the `TodoList` component.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the TodoList component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TodoList` component renders multiple `TodoItem` components. Here, we used
    a context, which means that we can now use a Context Hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s migrate the `TodoList` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit `src/TodoList.jsx` and *delete* all of the existing code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function component. In this case, we do not destructure the props,
    but simply get the whole object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define the Context Hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, return the list of rendered items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, using contexts with Hooks is much more straightforward. We can
    simply call a function (the Context Hook), and use the return value. No magical
    assignment of `this.context`!
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s migrate the TodoFilter component.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the TodoFilter component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `TodoFilter` component does not use any Hooks. However, we are going to
    replace the `TodoFilterItem` and `TodoFilter` class components with two function
    components – one for `TodoFilterItem`, and one for the `TodoFilter` component:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit `src/TodoFilter.jsx` and *delete* all of the existing code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the `TodoFilterItem` component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, define the `TodoFilter` component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, the `TodoFilter` component statically renders three `TodoFilterItem`
    components, which are used to toggle the filter between showing `all`, `active`
    or `completed` todo items. Next, let’s migrate the `AddTodo` component.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the AddTodo component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the `AddTodo` component, we are going to use a State Hook to handle the
    input field state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s migrate the `AddTodo` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit `src/AddTodo.jsx` and *delete* all of the existing code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `useState` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `AddTodo` component, which accepts an `addTodo` function as prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, define a State Hook for the input field state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define the handler functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, render the input field and button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, using the State Hook makes state management much simpler. We
    can define a separate value and setter function for each state value, instead
    of having to deal with a single `state` object. Additionally, we do not need to
    destructure from `this.state` all the time. As a result, our code is much more
    clean and concise.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to migrating the App component.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the state management and App component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At last, all that is left to do is migrate the `App` component. Then, our whole
    todo app will be migrated to React Hooks. Here, we are going to use a Reducer
    Hook to manage the state, an Effect Hook to fetch todos when the component mounts,
    and a Memo Hook to store the filtered todos list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section we are going to:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the reducers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrate the `App` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our app is going to accept five actions, let’s first take a moment to think
    about what they will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LOAD_TODOS`: To load a new list of todo items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ADD_TODO`: To insert a new todo item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`TOGGLE_TODO`: To toggle the completed value of a todo item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`REMOVE_TODO`: To remove a todo item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`FILTER_TODOS`: To filter todo items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Defining the reducers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we are going to define the reducers for our state. We are going to need
    one app reducer and two sub-reducers: one for todos and one for the filter.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the filter reducer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We are going to start by defining the reducer for the `filter` value:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `src/reducers.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this file, define a function for the `filterReducer`, which is going to
    handle the `FILTER_TODOS` action and set the filter value accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let’s move on to the `todosReducer` function.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the todos reducer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, we are going to define the `todosReducer` function for the todo items.
    Here, we are going to handle the `LOAD_TODOS`, `ADD_TODO`, `TOGGLE_TODO`, and
    `REMOVE_TODO` actions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/reducers.js` and define a new function, which is going to handle
    these actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `LOAD_TODOS` action, we simply replace the current state with the new
    `todos` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `ADD_TODO` action, we are going to insert a new item at the beginning
    of the current state array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `TOGGLE_TODO` action, we are going to use the `map` function to update
    a single todo item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `REMOVE_TODO` action, we are going to use the `filter` function to
    remove a single todo item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By default (for all other actions), we simply return the current state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we just need to define the `appReducer`, which will combine the other two
    reducers into one.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the app reducer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To handle our todo app state in one Reducer Hook, we are going to combine the
    two reducers we created into a single `appReducer` function. To do that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/reducers.js` and define and export a new function for the app reducer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this function, we return an object with the values from the other reducers.
    We simply pass the sub-state and action to the other reducers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have defined a reducer to manage the app state, we can start migrating
    the `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the App component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s get started migrating the `App` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit `src/App.jsx` and *delete* all of the existing code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we define the function component, which is not going to accept any props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define a Reducer Hook using the `appReducer` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s also destructure the `state` object to make it easier for us to access
    later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we implement the filter mechanism using a Memo Hook. This is one of the
    few cases where using the Memo Hook is actually necessary. Otherwise, our component
    would re-render too often, causing an infinite loop. We can use the Memo Hook
    to ensure that a change to `filteredTodos` is only triggered when the `todos`
    or `filter` state changes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define an Effect Hook, which is going to fetch todos from our mock
    API and then dispatch a `LOAD_TODOS` action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function inside an Effect Hook needs to be synchronous, so we are using
    a workaround to get the async/await construct to work here. When not caring about
    waiting for an async function to complete, it is best practice to prefix the function
    call with `void` to show that we intentionally did not `await` it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define various functions that are going to dispatch actions and change
    the state of our app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we render all the components that are needed for our todo app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that our app is fully migrated, we can start the dev server and verify
    that everything still works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, using a Reducer Hook to handle complex state changes makes our
    code much more concise and easier to maintain. Our app is now fully migrated to
    Hooks, and it still works exactly the same way as before!
  prefs: []
  type: TYPE_NORMAL
- en: Another possibility to further refactor and improve the code would be to store
    the state and dispatch function in a context, and then define custom Hooks for
    handling the various functions of our todo app. However, in this example, we wanted
    to keep it as close to the original class component code as possible, so any further
    refactoring is left as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example code**'
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this section can be found in the `Chapter13/Chapter13_2`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s wrap up the book by discussing the trade-offs of using React class
    components vs React Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Trade-offs of React class components vs React Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have finished our migration from class components to Hooks, let
    us revise and sum up what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Function components with Hooks are easier to understand and test, since they
    are simply JavaScript functions instead of complex React constructs. We were also
    able to refactor the state-changing logic into a separate `reducers.js` file,
    thus decoupling it from the `App` component, and making it easier to refactor
    and test. We can safely say that separating concerns between app logic and components
    significantly improved the maintainability of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s recap the advantages we gained by refactoring our app. With function
    components and Hooks, the following points do not need to be taken into consideration
    anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: No need to deal with constructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No confusing `this` context (`this` re-binding).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need to destructure the same values over and over again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No magic when dealing with contexts, props, and state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need to define `componentDidMount` and `componentDidUpdate` if we want to
    re-fetch data when the props change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, function components have the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Encourage making small and simple components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are easier to refactor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are easier to test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Require less code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are easier to understand for beginners.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are more declarative.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Server Components (RSCs) can only be function components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, class components can be fine in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: When sticking to certain conventions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using arrow functions to avoid `this` re-binding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possibly easier to understand for the team, because of existing knowledge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many projects still use classes. For dependencies, this is not such a problem,
    as they can still be easily used in function components. However, in legacy codebases,
    you may still need to work with class components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, it is a matter of preference, but Hooks do have many advantages
    over classes! If you are starting a new project, definitely go for Hooks. If you
    are working on an existing project, consider whether it might make sense to refactor
    certain components to Hook-based components in order to make them simpler.
  prefs: []
  type: TYPE_NORMAL
- en: However, you should not immediately port all your projects to Hooks, as refactoring
    can always introduce new bugs. The best way to adopt Hooks is to slowly but surely
    replace old class components with Hook-based function components when appropriate.
    For example, if you are already refactoring a component, you can refactor it to
    use Hooks!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first built a todo app using React class components. We
    started by designing the app structure, then implemented static components, and
    finally, we made them dynamic. Next, we learned how to migrate an existing project
    using class components, to function components using Hooks. Finally, we learned
    about the trade-offs of class components, when class components or Hooks should
    be used, and how one should go about migrating an existing project to Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen in practice how React class components differ to function components
    with Hooks. Hooks make our code much more concise and easier to read and maintain.
    We have also learned that we should gradually migrate our components from class
    components to function components with Hooks—there is no need to immediately migrate
    the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter marks the end of this book. In this book, we started out with a
    motivation to use Hooks. We learned that there are common problems in React apps,
    which could not be easily solved without Hooks. Then, we created our first component
    using Hooks, and compared it to the class-based solution. Next, we learned about
    the State Hook, which is the most ubiquitous of them all. We also learned about
    solving common problems with Hooks, such as conditional Hooks, and Hooks in loops.
    We gained a deep understanding of how Hooks work internally and what their limitations
    are.
  prefs: []
  type: TYPE_NORMAL
- en: After learning about the State Hook in depth, we developed a small blog app
    using Hooks. We then learned about Reducer Hooks, Effect Hooks, and Context Hooks,
    in order to be able to implement more features in our app. Next, we learned how
    to use TanStack Query Hooks and React Suspense for data fetching. Then, we used
    Hooks to handle forms. Next, we used React Router to implement routes in our blog
    app, and we learned how Hooks can make dynamic routing much easier. We gained
    experience developing a real-world frontend application with Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about the various built-in Hooks provided by React, even the
    advanced ones. Then, we learned about various Hooks that are provided by the community,
    which make dealing with application state and various use cases much easier. We
    gained an in-depth understanding of all the Hooks that React provides, and where
    to find more Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Towards the end of the book, we learned about the rules of Hooks, how to create
    our own custom Hooks and how to write tests for them using Vitest. We also learned
    how to migrate an existing class-component based app to a Hook-based solution.
    We thus gained an understanding on how to effectively refactor React applications
    with Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned about Hooks in depth, you are ready to use them in
    your applications! You have also learned how to migrate existing projects to Hooks,
    so you can start doing that now. I hope you enjoyed learning about React Hooks,
    and that you are looking forward to implementing Hooks in your applications! I
    am sure that using Hooks will make coding much more enjoyable for you, just like
    they did for me.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To recap what we have learned in this chapter, try to answer the following
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How are React class components defined?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do we need to call when using a constructor with class components? Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we set the initial state with class components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we change the state with class components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we need to re-bind the `this` context with class component methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we re-bind the `this` context?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we use React Context with class components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What can we replace state management with when migrating to Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the trade-offs of using Hooks versus class components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When, and how, should an existing project be migrated to Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are interested in more information about the concepts that we have learned
    in this chapter, take a look at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes in JavaScript: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'React class components: [https://www.robinwieruch.de/react-component-types/#react-class-components](https://www.robinwieruch.de/react-component-types/#react-class-components)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Migrating class components to functions: [https://react.dev/reference/react/Component#migrating-a-simple-component-from-a-class-to-a-function](https://react.dev/reference/react/Component#migrating-a-simple-component-from-a-class-to-a-function)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/wnXT0](Chapter_13.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_%283%29.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/New_Packt_Logo1.png)'
  prefs: []
  type: TYPE_IMG
- en: '[www.packtpub.com](https://www.packtpub.com)'
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe to our online digital library for full access to over 7,000 books
    and videos, as well as industry leading tools to help you plan your personal development
    and advance your career. For more information, please visit our website.
  prefs: []
  type: TYPE_NORMAL
- en: Why subscribe?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spend less time learning and more time coding with practical eBooks and Videos
    from over 4,000 industry professionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve your learning with Skill Plans built especially for you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a free eBook or video every month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully searchable for easy access to vital information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy and paste, print, and bookmark content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At [www.packtpub.com](https://www.packtpub.com), you can also read a collection
    of free technical articles, sign up for a range of free newsletters, and receive
    exclusive discounts and offers on Packt books and eBooks.
  prefs: []
  type: TYPE_NORMAL
- en: Other Books You May Enjoy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you enjoyed this book, you may be interested in these other books by Packt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/9781836202271.jpg)](https://www.packtpub.com/en-us/product/react-key-concepts-9781836202264)'
  prefs: []
  type: TYPE_NORMAL
- en: '**React Key Concepts, Second Edition**'
  prefs: []
  type: TYPE_NORMAL
- en: Maximilian Schwarzmüller
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-83620-227-1'
  prefs: []
  type: TYPE_NORMAL
- en: Build modern, user-friendly, and reactive web apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create components and utilize props to pass data between them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle events, perform state updates, and manage conditional content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add styles dynamically and conditionally for modern user interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use advanced state management techniques such as React’s Context API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize React Router to render different pages for different URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand key best practices and optimization opportunities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about React Server Components and Server Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![](img/9781837637959.jpg)](https://www.packtpub.com/en-us/product/modern-full-stack-react-projects-9781837632756)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modern Full-Stack React Projects**'
  prefs: []
  type: TYPE_NORMAL
- en: Daniel Bugl
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-83763-795-9'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a backend using Express and MongoDB, and unit-test it with Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy full-stack web apps using Docker, set up CI/CD and end-to-end tests using
    Playwright
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add authentication using JSON Web Tokens (JWT)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a GraphQL backend and integrate it with a frontend using Apollo Client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a chat app based on event-driven architecture using Socket.IO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facilitate Search Engine Optimization (SEO) and implement server-side rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Next.js, an enterprise-ready full-stack framework, with React Server Components
    and Server Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packt is searching for authors like you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re interested in becoming an author for Packt, please visit [authors.packtpub.com](https://www.authors.packtpub.com)
    and apply today. We have worked with thousands of developers and tech professionals,
    just like you, to help them share their insight with the global tech community.
    You can make a general application, apply for a specific hot topic that we are
    recruiting an author for, or submit your own idea.
  prefs: []
  type: TYPE_NORMAL
- en: Share your thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you’ve finished *Learn React Hooks*, *Second Edition*, we’d love to hear
    your thoughts! If you purchased the book from Amazon, please [click here to go
    straight to the Amazon review pag](https://packt.link/r/1836209177)e for this
    book and share your feedback or leave a review on the site that you purchased
    it from.
  prefs: []
  type: TYPE_NORMAL
- en: Your review is important to us and the tech community and will help us make
    sure we’re delivering excellent quality content.
  prefs: []
  type: TYPE_NORMAL
