- en: More Angular – SPA and Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter was about building our first useful app in Angular, then
    this chapter is about adding a whole lot of Angular goodness to it. Within the
    learning curve, we have made a start in exploring a technology platform and now
    we can build some rudimentary apps using Angular. But that's just the start! There
    is a lot more to learn before we can make effective use of Angular in a decent-sized
    application. This chapter takes us one step closer to realizing this goal.
  prefs: []
  type: TYPE_NORMAL
- en: The *7-Minute Workout* app still has some rough edges that we can fix while making
    the overall app experience better. This chapter is all about adding those enhancements
    and features. And as always, this app-building process provides us with enough
    opportunities to enhance our understanding of the framework and learn new things
    about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we cover in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploring Angular''s Single Page Applications** (**SPAs**): We explore Angular''s
    SPA capabilities, which include route navigation, link generation, and routing
    events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding dependency injection**: One of the core platform features.
    In this chapter, we learn how Angular makes effective use of dependency injection to
    inject components and services across the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular pure (stateless) and impure (stateful) pipes**: We explore the primary
    data transformation construct of Angular, pipes, in more detail as we build some
    new pipes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-component communication**: Since Angular is all about components and
    their interactions, we look at how to do cross-component communication in a parent-child
    and sibling component setup. We learn how Angular''s *template variables* and *events* facilitate
    this communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating and consuming events**: We learn how a component can expose its
    own events and how to bind to these events from the HTML template and from other
    components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a side note, I expect you are using the *7-Minute Workout* on a regular basis
    and working on your physical fitness. If not, take a seven-minute exercise break
    and exercise now. I insist!
  prefs: []
  type: TYPE_NORMAL
- en: Hope the workout was fun! Now let's get back to some serious business. Let's
    start with exploring Angular's **Single Page Application** (**SPA**) capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: We are starting from where we left off in Chapter 2, *Building Our First App
    - 7-Minute Workout*. The `checkpoint2.4` Git branch can serve as the base for
    this chapter. The code is also available on GitHub ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))
    for everyone to download. Checkpoints are implemented as branches in GitHub. If
    you are not using Git, download the snapshot of `checkpoint2.4` (a ZIP file) from
    the GitHub location: [http://bit.ly/ng6be-checkpoint-2-4](http://bit.ly/ng6be-checkpoint-2-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Single Page Application capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *7-Minute Workout* starts when we load the app, but it ends with the last
    exercise sticking to the screen permanently. Not a very elegant solution. Why
    don't we add a start and finish page to the app? This makes the app look more
    professional and allows us to understand the single-page nomenclature of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular SPA infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With modern web frameworks, such as Angular and Vue.js, we are now getting used
    to apps that do not perform full-page refreshes. But if you are new to this scene,
    it's worth mentioning what *SPAs* are.
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Page Applications** (**SPAs**) are browser-based apps devoid of any
    full-page refresh. In such apps, once the initial HTML is loaded, any future page
    navigations are retrieved using AJAX and HTML fragments and injected into the
    already loaded view. Google Mail is a great example of an SPA. SPAs make for a
    great user experience as the user gets a desktop app-like feel, with no constant
    post-backs and page refreshes, which are typically associated with traditional
    web apps.'
  prefs: []
  type: TYPE_NORMAL
- en: Like any modern JavaScript framework, Angular also provides the necessary constructs
    for SPA implementation. Let's understand them and add our app pages too.
  prefs: []
  type: TYPE_NORMAL
- en: Angular routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular supports SPA development using its **routing infrastructure**. This
    infrastructure tracks browser URLs, enables hyperlink generation, exposes routing
    events, and provides a set of directives/components for views that react to URL
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four major framework pieces that work together to support the Angular
    routing infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Router (Router)**: The primary infrastructure piece that actually provides
    component navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Routing configuration (Route)**: The component router is dependent upon
    the routing configuration for setting up routes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The RouterOutlet component**: The `RouterOutlet` component is the placeholder container
    (*host*) where route-specific views are loaded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The RouterLink directive**: This generates hyperlinks that can be embedded
    in the anchor tags for navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram highlights the roles these components play within the
    routing setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I highly encourage everyone to keep revisiting this diagram as we set up routing
    for *7-Minute Workout*.
  prefs: []
  type: TYPE_NORMAL
- en: '*The router* is the central piece of this complete setup; therefore a quick
    overview of the router will be helpful.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have worked with any JavaScript framework with SPA support, this is how
    things work. The framework watches the browser URL and serves views based on the
    URL loaded. There are dedicated framework components for this job. In the Angular world,
    this tracking is done by a *framework service*, **the router**.
  prefs: []
  type: TYPE_NORMAL
- en: In Angular, any class, object, or function that provides some generic functionality
    is termed a **service**. *Angular does not provide any special construct to declare
    a service as it does for components, directives, and pipes*. Anything that can
    be consumed by components/directives/pipes can be termed a service. The router
    is one such service. And there are many more services that are part of the framework. *If
    you are from the Angular 1 realm, this is a pleasant surprise-no service, factory,
    provider, value, or constant!*
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular router is there to:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable navigation between components on route change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass routing data between component views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the state of the current route available to active/loaded components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide APIs that allow navigation from component code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Track the navigation history, allowing us to move back and forward between component
    views using browser buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide life cycle events and guard conditions that allow us to affect navigation
    based on some external factors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The router also supports some advanced routing concepts, such as parent-child
    routes. This gives us the ability to define routes at multiple levels inside the
    component tree. The parent component can define routes and child components can
    further add more sub-routes to the parent route definition. This is something
    that we cover in detail in Chapter 4, *Building Personal Trainer*.
  prefs: []
  type: TYPE_NORMAL
- en: The router does not work alone. As highlighted in the preceding diagram, it
    depends upon other framework pieces to achieve the desired results. Let's add
    some app pages and work with each piece of the puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: Routing setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Angular router is not part of the core Angular framework. It has a separate
    Angular module and its own npm package. Angular CLI has already installed this
    package as part of the project setup. Look at `package.json` to confirm this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Since the router is already installed, we just need to integrate it into *7-Minute
    Workout*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by adding the  `base` reference (highlighted) to the `head` section
    of `index.html`, if not present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*The router requires `base href` to be set.* The `href` value specifies the
    base URL to use for all relative URLs within an HTML document, including links
    to CSS, scripts, images, and any other resource. This setting helps the router
    to create navigation URLs.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding start and finish pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The plan here is to have three pages for *7-Minute Workout*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start page**: This becomes the landing page for the app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workout page**: What we have currently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Finish page**: We navigate to this once the workout is complete'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The workout component and its view (`workout-runner.component.ts` and `workout-runner.component.html`)
    are already there. So let's create `StartComponent` and `FinishComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, using the Angular CLI generates the boilerplate for the start and finish
    components. Navigate to the `trainer/src/app` folder and execute the component-generation
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, copy the views for the *start* and *finish* components from the `checkpoint3.1` Git
    branch (the GitHub location to download from is [http://bit.ly/ng6be-3-1-app](http://bit.ly/ng6be-3-1-app)).
  prefs: []
  type: TYPE_NORMAL
- en: Both the *start* and *finish* components' implementations are empty. The interesting
    bits are in the view. The start component view has a link to navigate to the workout
    runner component (`<a routerLink="/workout" ...`) and so does finish. We have
    yet to define the routes.
  prefs: []
  type: TYPE_NORMAL
- en: The start and finish components have been added to *app module*, as they are
    rudimentary views, unlike workout runner, which has its own `WorkoutRunnerModule` module.
  prefs: []
  type: TYPE_NORMAL
- en: All three components are ready. Time to define the route configurations!
  prefs: []
  type: TYPE_NORMAL
- en: Route configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up the routes for *7-Minute Workout*, we are going to create a *route
    definition module file*. Create a file called `app-routing.module.ts` in the `trainer/src/app` folder
    defining the top-level routes for the app. Add the following routing setup or
    copy it from the `checkpoint3.1` Git branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Angular CLI also supports boilerplate route-generation for modules. We have
    not used that feature. We can learn about it from the CLI documentation at [http://bit.ly/ng-cli-routing](http://bit.ly/ng-cli-routing).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `routes` variable is an array of `Route` objects. Each `Route` defines
    the configuration of a single route, which contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path`: The target path to match'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`component`: The component to be loaded when the path is hit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such a route definition can be interpreted as, "when the user navigates to a
    URL (defined in `path`), load the corresponding component defined in the `component` property."
    Take the first route example; navigating to `http://localhost:9000/start` loads
    the component view for `StartComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the last `Route` definition looks a bit different. `path` looks
    odd and it does not have a `component` property either. A path with `**` denotes
    a catch-all path or the **wildcard route** for our app. Any navigation that does
    not match one of the first three routes matches the catch-all route, causing the
    app to navigate to the start page (defined in the `redirectTo` property).
  prefs: []
  type: TYPE_NORMAL
- en: We can try this once the routing setup is complete. Type any random route, such
    as `http://localhost:9000/abcd`, and the app automatically redirects to `http://localhost:9000/start`.
  prefs: []
  type: TYPE_NORMAL
- en: We finally create and import a new module into `AppRoutingModule` with the call
    to `RouterModule.forRoot`.  And by re-exporting Angular's `RouterModule`, we can
    import `AppRoutingModule` instead of `RouterModule` and have access to all of
    the routing constructs together with our app routes available in `AppModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enableTracing: true` property on the `forRoot` function parameter allows
    us to monitor the *router events* (such as `NavigationStart`, `NavigationEnd`,
    and `NavigationCancel`) that happen when navigation takes place and the correct
    route is resolved. The logs are visible in the browser''s debugger console. *Use
    it for debugging purposes only, remove it from production builds*.'
  prefs: []
  type: TYPE_NORMAL
- en: Could the preceding routing setup could have been done inside `AppModule`? Yes,
    it's definitely possible, but we would recommend against it. As the number of
    routes grow and the routing setup becomes more complex, having a separate routing
    module helps us organize the code better.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to highlight here:* route ordering is important in route
    definition*. Since route matching is done in a top-down fashion, it stops at the
    first match to define your specific routes before any generic catch-all route,
    such as the `**` *wildcard route *in our definition, which is declared at the
    last.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default router setup uses the **pushstate** mechanism for URL navigation.
    In such a setup, URLs look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '`localhost:4200/start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localhost:4200/workout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localhost:4200/finish`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This may not seem like a big deal, but remember that we are doing client-side
    navigation, not the full-page redirects that we are so used to. As the **developer
    guide** states:'
  prefs: []
  type: TYPE_NORMAL
- en: Modern HTML 5 browsers support `history.pushState`, a technique that changes
    a browser's location and history without triggering a server page request. The
    router can compose a "natural" URL that is indistinguishable from one that would
    otherwise require a page load.
  prefs: []
  type: TYPE_NORMAL
- en: Pushstate API and server-side url-rewrites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The router uses the  pushstate API in one of two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: When we click on links embedded in the view (`<a>` tag)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we use the router API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both cases, the router intercepts any navigation events, loads the appropriate
    component view, and finally updates the browser URL. The request never goes to
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we refresh the browser window?
  prefs: []
  type: TYPE_NORMAL
- en: The Angular router cannot intercept the browser's refresh event, and hence a
    complete page refresh happens. In such a scenario, the server needs to respond
    to a resource request (URL) that only exists on the client side. A typical server
    response is to send the app entry file (such as `index.html`) for any arbitrary
    request that may result in a `404 (Not Found)` error. This is what we call the
    server **url-rewrite**. This implies requests to any non-existent URLs, such as `/start`, `/workout`,
    or `/finish` loads the index page.
  prefs: []
  type: TYPE_NORMAL
- en: Each server platform has a different mechanism to support url-rewrite. We suggest
    you look at the documentation for the server stack you use to enable url-rewrite
    for your Angular apps.
  prefs: []
  type: TYPE_NORMAL
- en: We can see the server-side rewrites in action once the app routing is complete.
    Once completed, try to refresh the app and see the browser's network log; *the
    server sends the same  generated* `index.html` *content every time irrespective
    of the URL requested*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The routing module definition is complete now. Before proceeding further, open `app.module.ts` and
    import `AppRoutingModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have all the required components and all the routes defined, where
    do we inject these components on route change? We just need to define a placeholder
    for that in the host view.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering component views with router-outlet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Look at the current `AppComponent` template (`app.component.html`), it has an embedded `WorkoutRunnerComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This needs to change as we need to render different components based on the
    URL (`/start`, `/workout`, or `/finish`). Remove the preceding declaration and
    replace it with a *router directive*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`RouterOutlet` is an Angular component directive that acts as a placeholder
    for loading route-specific components when the route changes. It integrates with
    the router service to load the appropriate component based on the current browser
    URL and the route definition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram helps us to easily visualize what is happening with the `router-outlet` setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We are almost done; it's time to trigger navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Route navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like standard browser navigation, Angular navigation happens:'
  prefs: []
  type: TYPE_NORMAL
- en: When a user enters a URL directly into the browser address bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On clicking on a link on the anchor tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On using a script/code to navigate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not started, start the app and load `http://localhost:4200` or `http://localhost:4200/start`.
    The start page should be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Start button and the workout should start under the `http://localhost:4200/workout` URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular router also supports the old style of *hash (#)-based routing*.
    When hash-based routing is enabled, the routes appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`localhost:9000/#/start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localhost:9000/#/workout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localhost:9000/#/finish`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To change it to hash-based routing, the route configuration for the top-level
    routes should be augmented with an extra `useHash:true` property in the `RouterModule.forRoot` function
    (second parameter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, the anchor link in the `StartComponent` view definition does
    not have an `href` attribute. Instead, there is a `RouterLink` directive (the
    directive name is `RouterLink`, the selector is `routerLink`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding case, since the route is fixed, the directive takes a constant
    expression (`"/workout"`). We are not using the standard square bracket notation
    (`[]`) here, instead are assigning the directive a fixed value. This is known
    as **one-time binding**. For dynamic routes, we can use template expressions and
    the link parameter array. We'll touch upon dynamic routes and the link parameter
    array shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the **/** prefix in the preceding route path. `/` is used to specify
    an absolute path. The Angular router also supports relative paths, which are useful
    when working with child routes. We will explore the concept of child routes in
    the next few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refresh the app and check the rendered HTML for `StartComponent`; the preceding
    anchor tag is rendered with the correct `href` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Avoid hardcoding route links
  prefs: []
  type: TYPE_NORMAL
- en: While you could have directly used `<a href="/workout">`, prefer `routerLink` to
    avoid hardcoding routes.
  prefs: []
  type: TYPE_NORMAL
- en: The link parameter array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The route setup for the current *7-Minute Workout* is quite simple, and there
    isn''t a need to pass parameters as part of link generation. But the capability is
    there for non-trivial routes that require dynamic parameters. See this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the first route can be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The array assigned to the `RouterLink` directive is what we called the **link
    parameter array**. The array follows a specific pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first element is always the route path, and the next set of parameters is
    there to replace placeholder tokens defined in a route template.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular router is quite a beast and supports almost everything that we expect
    from a modern router library. It supports child routes, async routes, lifecycle
    hooks, secondary routes, and some other advanced scenarios. We'll delay discussion
    on these topics until later chapters. This chapter just gets us started with Angular
    routing, but there is more to come!
  prefs: []
  type: TYPE_NORMAL
- en: 'The router link parameter can also be an object. Such objects are used to supply **optional
    parameters** to the route. See this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that the generated link contains a semicolon to separate optional parameters
    from the route and other parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The last missing part of the implementation is routing to the finish page once
    the workout completes.
  prefs: []
  type: TYPE_NORMAL
- en: Using the router service for component navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigation from the workout page to the finish page is not triggered manually
    but on completion of the workout. `WorkoutRunnerComponent` needs to trigger this
    transition.
  prefs: []
  type: TYPE_NORMAL
- en: For this, `WorkoutRunnerComponent` needs to get hold of the router and invoke
    the `navigate` method on it.
  prefs: []
  type: TYPE_NORMAL
- en: How does `WorkoutRunnerComponent` get the router instance? Using Angular's *dependency
    injection framework*. We have been shying away from this topic for some time now.
    We have achieved a lot without even knowing that there's a dependency injection
    framework in play all this time. Let's wait a tad longer and first concentrate
    on fixing the navigation issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `WorkoutRunnerComponent` to get hold of the router service instance, it
    just needs to declare the service on the constructor. Update the `WorkoutRunnerComponent` constructor
    and add the imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Angular now magically injects the current router into the `router` private variable
    when `WorkoutRunnerComponent` is instantiated. The magic is done by *dependency
    injection framework*.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s now just a matter of replacing the `console.log("Workout complete!");` statement
    with the call to the `navigation` router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `navigate` method takes the same *link parameter array* as the `RouterLink` directive.
    We can verify the implementation by patiently waiting for the workout to complete!
  prefs: []
  type: TYPE_NORMAL
- en: If you are having a problem running the code, look at the `checkpoint3.1` Git
    branch for a working version of what we have done thus far. Or if you are not
    using Git, download the snapshot of `checkpoint3.1` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-1](http://bit.ly/ng6be-checkpoint-3-1). Refer
    to the `README.md` file in the trainer folder when setting up the snapshot for
    the first time.
  prefs: []
  type: TYPE_NORMAL
- en: The routes we have defined in *7-Minute Workout* are standard simple routes.
    But if there are dynamic routes that take parameters, how do we make the parameters
    available in our components? Angular has a service for that, the `ActivatedRoute` service.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ActivatedRoute service to access route params
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when the app requires access to the active route state. Information
    such as the current URL fragment, the current route parameters, and other route-related
    data may come in handy during a component's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The `ActivatedRoute` service is a one-stop shop for all current route-related
    queries. It has a number of properties, including `url` and `paramMap`, that can
    be used to query the route's current state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of a parameterized route and how to access a parameter
    passed from a component,  given this route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user navigates to `/user/5`, the underlying component  can access
    the `:id` parameter value by first injecting `ActivatedRoute` into its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, anywhere in the code where the parameter is required, call `get` methods
    on the `ActivatedRoute.paramMap` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `paramMap` property on `ActivatedObject` is actually an **observable.** We
    will learn more about observables later in the chapter, but for now, it is enough
    to understand that observables are objects that let the outside world know about
    their state changes by raising events that others can listen into.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use this router capability in the later chapters where we build a new
    app that can create workouts and edit existing workouts. In the upcoming chapters,
    we also look at some advanced routing concepts, including *child routes*, *lazy
    loaded routes*, and *guard conditions*.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered the basics of Angular routing, it's now time to concentrate
    on a much overdue topic: *Dependency Injection*.
  prefs: []
  type: TYPE_NORMAL
- en: Angular dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular makes heavy use of dependency injection to manage app and framework
    dependencies. The surprising part is that we could ignore this topic until we
    started our discussion on the router. All this time, the Angular dependency injection
    framework has been supporting our implementation. The hallmark of a good dependency
    injection framework is that the consumer can use it without bothering too much
    about the internals and with little ceremony.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not sure what dependency injection is or just have a vague idea about
    it, an introduction to DI surely does not hurt anyone.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any application, its components (not to be confused with Angular components)
    do not work in isolation. There are dependencies between them. A component may
    use other components to achieve its desired functionalities. **Dependency injection** is
    a pattern for managing such dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The DI pattern is popular in many programming languages as it allows us to manage
    dependencies in a loosely coupled manner. With such a framework in place, dependent
    objects are managed by a DI container. This makes dependencies swappable and the
    overall code more decoupled and testable.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind DI is that an object does not create/manage its own dependencies.
    Instead, the dependencies are provided from the outside. These dependencies are
    made available either through a constructor, which is called **constructor injection** (Angular
    also does this) or by directly setting the object properties, which is called **property
    injection**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a rudimentary example of DI in action. Consider a class called `Tracker` that
    requires `Logger` for a logging operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The dependency of the `Logger` class is hardwired inside `Tracker` as `Tracker` itself
    instantiates the `Logger` instance. What if we externalize this dependency? So
    the class becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This innocuous-looking change has a major impact. By adding the ability to
    provide the dependency externally, we can now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decouple these components and enable extensibility**. The DI pattern allows
    us to alter the logging behavior of the `Tracker` class without touching the class
    itself. Here is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The two `Tracker` objects we just saw have different logging capabilities for
    the same `Tracker` class implementation. `trackerWithDBLog` logs to a DB and `trackerWithMemoryLog` to
    the memory (assuming both `DBLogger` and `MemoryLogger` are derived from the `Logger` class).
    Since `Tracker` is not dependent on a specific implementation on  `Logger` (`DBLogger` or `MemoryLogger`),
    this implies `Logger` and `Tracker` are loosely coupled. In the future, we can
    derive a new `Logger` class implementation and use that for logging without changing
    the `Tracker` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mock dependencies**: The ability to mock dependencies makes our components
    more testable. The `Tracker` implementation can be tested in isolation (unit testing)
    by providing a mock implementation for `Logger`, such as `MockLogger`, or by using
    a mocking framework that can easily mock the `Logger` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now understand how powerful DI is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think carefully: once DI is in place, the responsibility for resolving the
    dependencies now falls on the calling/consumer code. In the preceding example,
    a class that was earlier instantiating `Tracker` now needs to create a `Logger` derivation
    and inject it into `Tracker` before using it.'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, this flexibility in swapping internal dependencies of a component comes
    at a price. The calling code implementation can become overly complex as it now
    has to manage child dependencies too. This may seem simple at first, but given
    the fact that dependent components may themselves have dependencies, what we are
    dealing with is a complex dependency-tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: This is where DI containers/frameworks add value. They make managing dependencies
    less cumbersome for the calling code. These containers then construct/manage dependencies
    and provide it to our client/consumer code.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular DI framework manages dependencies for our Angular components, directives,
    pipes, and services.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring dependency injection in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular employs its very own DI framework to manage dependencies across the
    application. The very first example of visible dependency injection was the injection
    of the component router into `WorkoutRunnerComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When the `WorkoutRunnerComponent` class gets instantiated, the DI framework
    internally locates/creates the correct router instance and injects it into the
    caller (in our case, `WorkoutRunnerComponent`).
  prefs: []
  type: TYPE_NORMAL
- en: While Angular does a good job of keeping the DI infrastructure hidden, it's
    imperative that we understand how Angular DI works. Otherwise, everything may
    seem rather magical.
  prefs: []
  type: TYPE_NORMAL
- en: 'DI is about creating and managing dependencies, and the framework component
    that does this is dubbed the **the injector**. For the injector to manage dependencies,
    it needs to understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The what:** What is the dependency? The dependency could be a class, an object,
    a factory function, or a value. Every dependency needs to be registered with the
    DI framework before it can be injected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The where/when:** The DI framework needs to know where to inject a dependency
    and when.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The how**: The DI framework also needs to know the recipe for creating the
    dependency when requested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any injected dependency needs to answer these questions, irrespective of whether
    it's a framework construct or an artifact created by us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, the `Router` instance injection done in `WorkoutRunnerComponent`.
    To answer the what and how parts, we register the `Router` service by importing
    the `RouterModule` into `AppRoutingModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `AppRoutingModule` is a module that exports multiple routes together with
    all the Angular-router-related services (technically it re-exports `RouterModule`).
  prefs: []
  type: TYPE_NORMAL
- en: The where and when are decided based on the component that requires the dependencies.
    The constructor of `WorkoutRunnerComponent` takes a dependency of `Router`. This
    informs the injector to inject the current `Router` instance when `WorkoutRunnerComponent` is
    created as part of route navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, the injector determines the dependencies of a class based on the
    metadata reflected from it when converting TypeScript to ES5 code (done by the
    TypeScript compiler). The metadata is generated only if we add a decorator, such
    as `@Component` or `@Pipe`, on the class.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we inject `Router` into another class? Is the same `Router` instance
    used? The short answer is yes. The Angular injector creates and caches dependencies
    for future reuse, and hence these services are singleton in nature.
  prefs: []
  type: TYPE_NORMAL
- en: While dependencies in an injector are singleton, at any given time, there can
    be multiple injectors active throughout an Angular app. You'll learn about the
    injector hierarchy shortly. With the router, there is another layer of complexity.
    Since Angular supports the child route concept, each of these child routes has
    its own router instance. Wait until we cover child routers in the next chapter
    so that you can understand the intricacies!
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an Angular service to track workout history. This process will
    help you understand how dependencies are wired using Angular DI.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking workout history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be a great addition to our app if we could track our workout history.
    When did we last exercise? Did we complete it? How much time did we spend on it?
  prefs: []
  type: TYPE_NORMAL
- en: To answer these questions, we need to track when the workout starts and when
    it ends. This tracking data then needs to be persisted somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: A possible solution could be to extend our `WorkoutRunnerComponent` with the
    desired functionality. But that adds unnecessary complexity to `WorkoutRunnerComponent` and
    that's not its primary job.
  prefs: []
  type: TYPE_NORMAL
- en: We need a dedicated history-tracking service for this job, a service that tracks
    historical data and shares it throughout the app. Let's start building the workout-history-tracker
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Building the workout-history-tracker service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The workout-history-tracker service is going to track workout progress. The
    service will also expose an interface, allowing `WorkoutRunnerComponent` to start
    and stop workout tracking.
  prefs: []
  type: TYPE_NORMAL
- en: Inspired again by the *Angular style guide*, we are going to create a new module, **core
    module**, and add the service to this module. The role of the core module is to
    host services that are available across the application. It is also a good place
    to add single-use components that are required when the application starts. A
    nav bar and busy indicator are good examples of such components.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the command line, navigate to the `trainer/src/app` folder and generate
    a new module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new `CoreModule` module and imports it into `AppModule`. Next,
    create a new service inside the `trainer/src/app/core` folder, again using Angular
    CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated code is quite simple. The generator creates a new class `WorkoutHistoryTrackerService` (`workout-history-tracker.service.ts`)
    with a `@Injectable` decorator applied on the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `providedIn:'root'` property on `Injectable` instructs Angular to create **a
    provider** with the *root injector*. The sole job of this provider is to create
    the `WorkoutHistoryTrackerService` service and return it when Angular's DI injector
    desires. Any service that we create/use needs to be registered on an injector.
    As the Angular documentation on *providers* describes,
  prefs: []
  type: TYPE_NORMAL
- en: '*Providers tell the injector how to create the service. Without a provider,
    the injector would not know that it is responsible for injecting the service nor
    be able to create the service*.'
  prefs: []
  type: TYPE_NORMAL
- en: A service in Angular is just a class that has been registered with Angular's
    DI framework. Nothing special about them!
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it is desirable to include the service as part of a module instead
    of registering it with the root injector. In such a case, the service can be registered
    at the module level. There are two ways to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1**: Reference the module with the `providedIn` property:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Option 2**: Register the service on the module, using the `providers` array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Registering services at module level is advantageous in scenarios where a module
    is lazy loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Registering the service using `Injectable` (*option 1*) has another advantage.
    It enables Angular CLI build to perform advanced optimization with code bundling,
    leaving out any service that is declared but never used (a process called **tree
    shaking**).
  prefs: []
  type: TYPE_NORMAL
- en: Irrespective of the two options we use, the service is still registered (via
    a provider) with the root injector.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the `Injectable` approach to registering dependency throughout
    the book, unless stated otherwise. Open `workout-history-tracker.service.ts` and
    add the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There are two classes defined: `WorkoutHistoryTrackerService` and `WorkoutLogEntry`.
    As the name suggests, `WorkoutLogEntry` defines log data for one workout execution. `maxHistoryItems` allows
    us to configure the maximum number of items to store in the `workoutHistory` array,
    the array that contains the historical data. The `get tracking()` method defines
    a getter property for `workoutTracked` in TypeScript. `workoutTracked` is set
    to `true` during workout execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the start tracking, stop tracking, and exercise complete functions
    to `WorkoutHistoryTrackerService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `startTracking` function creates a `WorkoutLogEntry` and adds it to the `workoutHistory` array.
    By setting the `currentWorkoutLog` to the newly created log entry, we can manipulate
    it later during workout execution. The `endTracking` function and the `exerciseComplete` function
    just alter `currentWorkoutLog`. The `exerciseComplete` function should be called
    on completion of each exercise that is part of the workout.  To save you some
    keystrokes, get the complete code for implementation done thus far from this gist: [http://bit.ly/ng6be-gist-workout-history-tracker-v1-ts](http://bit.ly/ng6be-gist-workout-history-tracker-v1-ts).
  prefs: []
  type: TYPE_NORMAL
- en: 'The service implementation now also includes a function to get workout history
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: That completes the `WorkoutHistoryTrackerService` implementation; now it's time
    to integrate it into the workout execution.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with WorkoutRunnerComponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WorkoutRunnerComponent` requires `WorkoutHistoryTrackerService` to track workout
    history; hence there is a dependency to be fulfilled. We already have registered `WorkoutHistoryTrackerService` with
    Angular''s DI framework using the `Injectable` decorator and now it''s time to
    consume the service.'
  prefs: []
  type: TYPE_NORMAL
- en: Injecting dependencies with Constructor Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consuming dependency is easy! *More often than not, we use constructor injection
    to consume a dependency*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `import` statement at the top and update the `WorkoutRunnerComponent` constructor,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As with `router,` Angular injects `WorkoutHistoryTrackerService` too when `WorkoutRunnerComponent` is
    created. Easy!
  prefs: []
  type: TYPE_NORMAL
- en: Once the service is injected and available to `WorkoutRunnerComponent`, the
    service instance (`tracker`) needs to be called when the workout starts, when
    an exercise is complete, and when the workout finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this as the first statement in the `start` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `startExerciseTimeTracking` function, add the highlighted code after
    the `clearInterval` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And the highlighted code inside the workout to complete the `else` condition
    in the same function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: History tracking is almost complete except for one case. What if the user manually
    navigates away from the workout page? How do we stop tracking?
  prefs: []
  type: TYPE_NORMAL
- en: When that happens, we can always rely on the component's life cycle hooks/events
    to help us. Workout tracking can be stopped when the `NgOnDestroy` event is fired.
    An appropriate place to perform any cleanup work is before the component is removed
    from the component tree. Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this function and the corresponding life cycle event interface to `workout-runner.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The workout-history-tracking implementation is complete. We are eager to start
    the workout history page/component implementation, but not before completing our
    discussion on Angular's DI capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to skip the next section for now if you want to maintain the app-building
    velocity. Come back to this section with a fresh and relaxed mind. There are some
    very important core concepts we'll share in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection in depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first try to understand the different places we can register a dependency
    using `WorkoutHistoryTrackerService` as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Registering dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard way to register a dependency is to register it at the root/global
    level. This can be done either by passing the dependency type into the `provides` attribute
    (array) in the `NgModule` decorator, or by using the `providedIn` attribute on
    the `Injectable` service decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember our `WorkoutHistoryTrackerService` registration? Check the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The same thing can be done on the module declaration too, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Technically speaking, when using any of the preceding mechanisms, the service
    gets registered with the **app's root injector**, irrespective of the Angular
    module it is declared in. Any Angular artifact across modules henceforth can use
    the service (`WorkoutHistoryTrackerService`). No module imports are required at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is different from component/directive/pipe registration. Such
    artifacts have to be exported from a module for another module to use them.
  prefs: []
  type: TYPE_NORMAL
- en: '*Another place where dependencies can be registered is on the component*. The `@Component` decorator
    has a `providers` array parameter to register dependencies. With these two levels
    of dependency registration, the obvious question that we need to answer is, which
    one to use?'
  prefs: []
  type: TYPE_NORMAL
- en: It seems obvious that if the dependency is exclusively used by a component and
    its children, it should be registered at the `@Component` decorator level. Not
    really! There is much more we need to understand before we can answer this question.
    There is a whole new world of hierarchical injectors that need to be introduced.
    Let's wait, and instead learn other ways of registering dependencies, by continuing
    our discussion on providers.
  prefs: []
  type: TYPE_NORMAL
- en: '*Providers create dependencies when the Angular injector requests them*. *These
    providers have the recipe to create these dependencies*. While a class seems to
    be the obvious dependency that can be registered, we can also register:'
  prefs: []
  type: TYPE_NORMAL
- en: A specific object/value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A factory function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering `WorkoutHistoryTrackerService` using the `Injectable` decorator
    is the most common pattern of registration. But at times we need some flexibility
    with our dependency registrations. To register an object or a factory function,
    we need to use the expanded version of provider registrations available on `NgModule`.
  prefs: []
  type: TYPE_NORMAL
- en: To learn about these variations, we need to explore providers and dependency
    registration in a little more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Angular providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Providers create dependencies that are served by the DI framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this `WorkoutHistoryTrackerService` dependency registration done on `NgModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax is a short-form notation for the following version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The first property (`provide`) is a token that acts as a key for registering
    a dependency. This key also allows us to locate the dependency during dependency
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: The second property (`useClass`) is a *provider definition object* that defines
    the recipe for creating the dependency value.
  prefs: []
  type: TYPE_NORMAL
- en: With `useClass`, we are registering a **class provider**.  *A class provider creates
    dependencies by instantiating the type of object requested for*. There are some
    other provider types.
  prefs: []
  type: TYPE_NORMAL
- en: Value providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*A class provider* creates class objects and fulfills the dependency, but at times we
    want to register a specific object/primitive with the DI provider instead. **Value
    providers** solve this use case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Had we registered `WorkoutHistoryTrackerService` using this technique, the
    registration would have looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*With the value provider, we have the responsibility to provide an instance
    of a service/object/primitive to Angular DI.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the *value provider*, since we are creating the dependency manually, we
    are also responsible for constructing any child dependencies if there are dependencies
    further down the lineage. Take the example of `WorkoutHistoryTrackerService` again.
    If `WorkoutHistoryTrackerService` has some dependencies, those too need to be
    fulfilled by manual injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we not only have to create an instance of `WorkoutHistoryTrackerService`,
    we also have to create an instance of the `LocalStorage` service. For a service
    with a complex dependency graph, setting up that service with a value provider
    becomes challenging.
  prefs: []
  type: TYPE_NORMAL
- en: Wherever possible, prefer *class provider* over *value provider*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Value providers still come in handy in specific scenarios. For example, we
    can register a common app configuration using a value provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Or register a mock dependency while unit testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Factory providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when dependency construction is not a trivial affair. Construction
    depends upon external factors. These factors decide what objects or class instances
    are created and returned. **Factory providers** do this heavy lifting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take an example where we want to have different configurations for dev and
    production releases. We can very well use a factory implementation to select the
    right configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A factory function can have its own dependencies too. In such a case, the syntax
    changes a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The dependencies are passed as a parameters to the factory function and registered
    on the provider definition object property, `deps` (`Environment` is the dependency
    injected in the preceding example).
  prefs: []
  type: TYPE_NORMAL
- en: Use the `UseFactory` provide if the construction of the dependency is complex
    and not everything can be decided during dependency wire-up.
  prefs: []
  type: TYPE_NORMAL
- en: While we have a number of options to declare dependencies, consuming dependencies
    is far simpler. We saw one way of constructor injection in the *Injecting dependencies
    with Constructor Injection *section.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit injection using injector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can even do explicit injections using Angular''s **Injector service**. This
    is the same injector Angular uses to support DI. Here is how to inject the `WorkoutHistoryTrackerService` service
    using `Injector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We inject the  `Injector` service and then ask for the `WorkoutHistoryTrackerService` instance
    explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: When would someone want to do this? Well, almost never. Avoid this pattern as
    it exposes the DI container to your implementation and adds a bit of noise.
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to register dependency and how to consume it, but how does the
    DI framework locate these dependencies?
  prefs: []
  type: TYPE_NORMAL
- en: Dependency tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember this expanded version of dependency registration shown earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `provide` property value is a **token**. This token is used to identify
    the dependency to inject. In the preceding example, we use class name or type
    to identify dependency and hence the token is called a **class token**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the preceding registration, whenever Angular sees a statement similar
    to the following, it injects the correct dependency based on the class type, here `WorkoutHistoryTrackerService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Angular supports some other tokens too.
  prefs: []
  type: TYPE_NORMAL
- en: Using InjectionToken
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when the dependency we define is either a primitive, object,
    or function. In such a scenario, the class token cannot be used as there is no
    class. Angular solves this problem using `InjectionToken` (or **string tokens** as
    we'll see later). The app configuration registration examples that we shared earlier
    can be rewritten using string tokens if there is no `AppConfig` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To register a dependency using `InjectionToken`, we first need to create the `InjectionToken` class
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the token to register the dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, inject the dependency anywhere using the `@Inject` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, when `@Inject()` is not present, the injector uses the type/class
    name of the parameter (*class token*) to locate the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Using string tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular also supports **string tokens**, allowing us to use string literals
    to identify and inject dependencies. The preceding example with a string token
    becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: A downside to string tokens is that you can misspell the token across the declaration
    and injection.
  prefs: []
  type: TYPE_NORMAL
- en: Phew! This was a really long section on Angular's Dependency Injection and there's
    still stuff left to cover. For now, let's get back on track and add the workout
    history page.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the workout history page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The workout history data that we are collecting during the execution of the
    workout can now be rendered in a view. Let's add a `History` component. The component
    will be available at the `/history` location and can be loaded by clicking on
    a link in the app header section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the route definition in `app.routes.ts` to include a new route and the
    related import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The History link needs to be added to the app header section. Let''s refactor
    the header section into its own component. Update the `app.component.html` template
    and replace the `nav` element with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nav` element moves into a header component, which we still need to create.
    Use `ng generate` to generate a new `HeaderComponent` component by running the
    command inside the `trainer/src/app/core` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This statement creates a new header component and declares it on the core module.
    Next, update the definition for the header component (`header.component.ts`) and
    its view (`header.component.html`) from the `checkpoint3.2` Git branch (GitHub
    location: [http://bit.ly/ng6be-3-2-header](http://bit.ly/ng6be-3-2-header)).
  prefs: []
  type: TYPE_NORMAL
- en: 'While we have added the header element to `app.component.html`, the header
    component will not render unless we import the core module and export the component
    from the core module. Angular CLI did the first part for us, for the second part,
    update `core.module.ts` to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the `HeaderComponent` view, the history link is now there. We
    had to import `RouterModule` as the following link is generated using the `RouterLink` directive,
    which is part of `RouterModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the workout history component by first generating the component''s
    boilerplate. From the command line, navigate to `trainer/src/app` and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `WorkoutHistoryComponent` implementation is available in the `checkpoint3.2` Git
    branch; the folder is `workout-history` (GitHub location: [http://bit.ly/ng6be-3-2-workout-history](http://bit.ly/ng6be-3-2-workout-history)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WorkoutHistoryComponent` view code is trivial, to say the least: a few
    Angular constructs, including `ngFor` and `ngIf`. The component implementation
    too is pretty straightforward. Inject the `WorkoutHistoryTrackerService` service
    dependency and load the history data when `WorkoutHistoryComponent` is initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'And this time, we use the `Location` service instead of `Router` to navigate
    away from the `history` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The Location service is used to interact with the browser URL. Depending upon
    the URL strategy, either URL paths (such as `/start` or `/workout`) or URL hash
    segments (such as `#/start` or `#/workout`) are used to track location changes.
    The router service internally uses the location service to trigger navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Router versus Location
  prefs: []
  type: TYPE_NORMAL
- en: While the `Location` service allows us to perform navigation, using `Router` is
    a preferred way of performing route navigation. We used the location service here
    because the need was to navigate to the last route without bothering about how
    to construct the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are ready to test our workout history implementation. Load the start page
    and click on the History link. The history page is loaded with an empty grid.
    Go back, start a workout, and let an exercise complete. Check the history page
    again; there should be a workout listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Looks good! If we run the workout multiple times and let the history list build,
    we realize there is one sore point in this listing. Historical data is not sorted
    in reverse-chronological order, with the newest at the top. Also, it would be
    great if we had some filtering capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and filtering history data using pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Chapter 2, *Building Our First App – 7-Minute Workout*, we explored pipes.
    We even built our own pipe to format the seconds values as hh:mm:ss. The primary
    purpose of pipes is to transform data and, surprisingly, they work on arrays too!
    For arrays, pipes can sort and filter data. We create two pipes, one for each sorting
    and filtering.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS has prebuilt filters (filters are pipes in Angular), `orderBy` and `filter`,
    for this very purpose. Angular does not come with these pipes and there is a good
    reason. These pipes are prone to poor performance. Learn the rationale behind
    this decision in the framework documentation on pipes at [http://bit.ly/ng-no-filter-orderby-pipe](http://bit.ly/ng-no-filter-orderby-pipe).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the `orderBy` pipe.
  prefs: []
  type: TYPE_NORMAL
- en: The orderBy pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `orderBy` pipe we implement is going to order an array of objects based
    on any of the object''s properties. The usage pattern for sorting items in ascending
    order based on the `fieldName` property is going to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'And for sorting items in descending order, the usage pattern is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Make note of the extra hyphen (`-`) before `fieldName`.
  prefs: []
  type: TYPE_NORMAL
- en: We plan to add `OrderByPipe` in a new shared module. Are you thinking, why not
    add it to core module? By convention, the core module contains global services
    and one-time-use components. This is exactly one core module per application.
    Shared modules, on the other hand, have components/directives/pipes that are shared across
    modules. Such shared modules can be also be defined at multiple levels, across
    the parent and child modules. In this case, we will define the shared module inside `AppModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `SharedModule` module by running this command in the `trainer/src/app` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'From the command line, navigate to the `trainer/src/app/shared` folder and
    generate the order by pipe boilerplate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `order-by.pipe.ts` and update the definition from the checkpoint3.2 code
    (GitHub location: [http://bit.ly/ng6be-3-2-order-by-pipe](http://bit.ly/ng6be-3-2-order-by-pipe)).
    While we are not going to delve into the pipe''s implementation details, some
    relevant parts need to be highlighted. Look at this pipe outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `field` variable receives the field on which sorting is required. If
    the field has a `-` prefix, we truncate the prefix before sorting the array in
    descending order.
  prefs: []
  type: TYPE_NORMAL
- en: The pipe also uses the spread operator, `[...]`, which may be new to you. Learn
    more about the spread operator on MDN at [http://bit.ly/js-spread](http://bit.ly/js-spread).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `OrderByPipe`, update the template view for workout history:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'And again, we need to export the pipe from the shared module allowing `WorkoutHistoryComponent` to
    use it. Add an exports property on `SharedModule` and set it to `OrderByPipe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The historical data will now be sorted in descending order on the `startedOn` field.
  prefs: []
  type: TYPE_NORMAL
- en: Make note of the single quotes around the pipe parameter (`'-startedOn'`). We
    are passing a literal string to the `orderBy` pipe. Pipe parameters support data
    binding and can be bound to component properties too.
  prefs: []
  type: TYPE_NORMAL
- en: That's enough for the `orderBy` pipe. Let's implement filtering.
  prefs: []
  type: TYPE_NORMAL
- en: Pipe chaining with search pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by creating the search pipe boilerplate by running the following command
    from the `trainer/src/app/shared` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The implementation can now be copied from checkpoint3.2 (GitHub location: [http://bit.ly/ng6be-3-2-search-pipe](http://bit.ly/ng6be-3-2-search-pipe)). `SearchPipe` does
    a basic equality-based filtering. Nothing special.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the pipe code; the pipe takes two arguments, the first being the field
    to search, and the second the value to search. We use the JavaScript array's `filter` function
    to filter the record, doing a strict equality check. Wondering about the `pure` attribute
    on the `Pipe` decorator? This is going to be the subject of discussion in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the workout history view and incorporate the search pipe too.
    Open `workout-history.component.html` and uncomment the div with radio buttons.
    These radio buttons filter workouts based on whether they were completed or not.
    This is how the HTML filter selection looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We define three filters: `all`, `completed`, and `incomplete` workouts. The
    radio selection sets the component's `completed` property using the `change` event
    expression. `$event.target` is the radio button that was clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `search` pipe can now be added to the `ngFor` directive expression. We
    are going to chain the `search` and `orderBy` pipes. Update the `ngFor` expression
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: A great example of Angular's pipe chaining capabilities!
  prefs: []
  type: TYPE_NORMAL
- en: As we did with `OrderByPipe`, `SearchPipe` too needs to be exported from the
    shared module before using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `search` pipe first filters the historical data, followed by the `orderBy` pipe
    reordering it. Pay close attention to the `search` pipe parameters: the first
    parameter is a string literal denoting the field to search (`historyItem.completed`),
    whereas the second parameter is derived from the component''s `completed` property.
    Having the ability to bind pipe parameters to component properties allows us great
    flexibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and verify the search capabilities of the history page. Based on the
    radio selection, the history records are filtered, and of course, they are sorted
    in reverse-chronological order based on the workout start dates.
  prefs: []
  type: TYPE_NORMAL
- en: While pipe usage with arrays looks simple, it can throw up some surprises if
    we do not understand when pipes are evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Pipe gotcha with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand the issue with pipes applied to arrays, let's reproduce the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `search.pipe.ts` and remove the `@Pipe` decorator''s `pure` attribute.
    Also, take the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'And change it into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a button at the end of the radio list (in `workout-history.component.html`)
    that adds a new log entry to the `history` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a function to `WorkoutHistoryComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function duplicates the first history item and adds back to the `history` array.
    If we load the page and click on the button, a new log entry gets added to the
    history array, but it does not show up on the view unless we change the filter
    (by clicking on the other radios). Interesting!
  prefs: []
  type: TYPE_NORMAL
- en: Before calling `addLog` make sure at least one history log is already there;
    otherwise the `addLog` function will fail.
  prefs: []
  type: TYPE_NORMAL
- en: The pipes that we have built thus far are **stateless** (also called **pure**)
    in nature. They simply transform input data into output. **Stateless** **pipes** are
    reevaluated only if the pipe input changes (the expression on the left side of
    pipe symbol) or any pipe argument is updated.
  prefs: []
  type: TYPE_NORMAL
- en: For arrays, this happens on an array assignment/reference change and not on
    the addition or deletion of elements. Switching the filter condition works, as
    it causes the search pipe to evaluate again as the search parameter (the `completed` status)
    changes. This behavior is something to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s the fix? For starters, we can make the history array immutable, which
    implies that it cannot be changed once created. To add a new element, we need
    to create a new array with the new value, something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This works perfectly, but we are changing our implementation to make it work
    with pipes which is incorrect. Instead, we can change the pipe. The pipe should
    be marked stateful.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between a stateless and stateful pipe is that stateful pipes
    are evaluated by Angular every time the framework does a change-detection run,
    which involves checking the complete application for changes. Therefore, with
    stateful pipes, the check is not limited to the pipe input/argument changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a `search` pipe stateless, just revert the first change we made and
    add back `pure: false` on the `Pipe` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: It still does not work! The `search` pipe has one more quirk that needs a fix.
    The All radio selection does not work perfectly. Add a new workout log, and it
    still will not show up, unless we switch filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fix here is to revert the second change. Isolate this line in the `search` pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'And change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We changed the `if` condition to return a new array every time (using the spread
    operator), even when `searchTerm` is `null`. If we return the same array reference,
    Angular does not check for a size change in the array and hence does not update
    the UI.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our History page implementation. You may now be wondering what
    the last few fixes on pipes have to do with how change detection works. Or you
    may be wondering what change detection is. Let's put all of these doubts to rest
    and introduce everyone to *Angular's change-detection system*.
  prefs: []
  type: TYPE_NORMAL
- en: Angular's change detection will be covered extensively in Chapter 8, *Some Practical
    Scenarios*. The aim of the next section is to introduce the concept of change
    detection and how Angular performs this process.
  prefs: []
  type: TYPE_NORMAL
- en: Angular change detection overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To put it succinctly, change detection is all about tracking changes done to
    the component's model during app execution. This helps Angular's data-binding
    infrastructure to identify what parts of the view need to be updated. Every data
    binding framework needs to address this issue, and the approach these frameworks
    take for tracking changes differs. It even differs from AngularJS to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how change detection works in Angular, there are a few things
    that we need to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: An Angular app is nothing but a hierarchy of components, from the root to the
    leaf.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is nothing special about the component properties that we bind to view;
    therefore Angular needs an efficient mechanism to know when these properties change.
    It cannot keep polling for changes in these properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To detect changes in a property value, Angular does a *strict comparison* (`===`)
    between the previous and current value. For reference types, it means only the
    references are compared. No deep comparison is done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For precisely this reason, we had to mark our search pipe as stateful. Adding
    elements to an existing array does not change the array reference and hence Angular
    fails to detect any change in the array. Once the pipe is marked as stateful,
    the pipe is evaluated, irrespective of whether the array has changed or not.
  prefs: []
  type: TYPE_NORMAL
- en: Since Angular cannot know when any bound property is updated automatically,
    it instead resorts to checking every bound property when a change detection run
    is triggered. Starting from the root of the component tree, Angular checks each
    bound property for changes as it goes down the component hierarchy. If a change
    is detected, that component is marked for refresh. It's worth reiterating that
    changes in a bound property do not immediately update the view. Instead, a change-detection
    run works in two phases.
  prefs: []
  type: TYPE_NORMAL
- en: In the *first phase*, it does the component tree walk and marks components that
    need to be refreshed due to model updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *second phase*, the actual view is synchronized with the underlying model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model changes and view updates are never interleaved during a change-detection
    run.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now just need to answer two more questions:'
  prefs: []
  type: TYPE_NORMAL
- en: When is a change-detection run triggered?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many times does it run?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An Angular change-detection run is triggered when any of these events are triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User input/browser events**: We click on a button, enter some text, scroll
    the content. Each of these actions can update the view (and the underlying model).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote XHR requests**: This is another common reason for view updates. Getting
    data from a remote server to show on the grid and getting user data to render
    a view are examples of this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setTimeout and setInterval**: As it turns out, we can use `setTimeout` and `setInterval` to
    execute some code asynchronously and at specific intervals. Such code can also
    update the model. For example, a `setInterval` timer may check for stock quotes
    at regular intervals and update the stock price on the UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To answer how many times, **it's one**. Each component model is checked only
    once, in a top-down fashion, starting from the root component to the tree leaves.
  prefs: []
  type: TYPE_NORMAL
- en: The last statement is true when Angular is configured to run in production mode.
    In development mode, the component tree is traversed twice for changes. Angular
    expects the model to be stable after the first tree walk. If that is not the case,
    Angular throws an error in development mode, and ignores the changes in production
    mode. We can enable the production mode by invoking the `enableProdMode` function
    before the `bootstrap` function call.
  prefs: []
  type: TYPE_NORMAL
- en: It's time now to pick another topic linked to Angular's depedency injection.
    The concept of **hierarchical injectors** will be our next topic of discussion. 
    It is a very powerful feature that can come in handy as we build bigger and better
    apps using Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical injectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **injector** in Angular's dependency injection setup is a container that is responsible for
    storing dependencies and dispensing them when asked for. The provider registration
    examples shared earlier actually register the dependencies with a global injector.
  prefs: []
  type: TYPE_NORMAL
- en: Registering component-level dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the dependency registrations that we have done thus far were done on
    a module. Angular goes one step further and allows registration of dependencies
    at the component level too. There is a similar `providers` attribute on the `@Component` decorator
    that allows us to register dependency at the component level.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could''ve very well registered the `WorkoutHistoryTrackerService` dependency
    on `WorkoutRunnerComponent`. Something along these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: But whether we should do it or not is something that we discuss here.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of this discussion on hierarchical injectors, it's important
    to understand that Angular creates an injector per component (oversimplified).
    Dependency registration done at the component level is available on the component
    and its descendants.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that dependencies are singleton in nature. Once created, the
    injector will always return the same dependency every time. This feature is evident
    from the workout history implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutHistoryTrackerService` was registered with the `CoreModule` and then
    injected into two components: `WorkoutRunnerComponent` and `WorkoutHistoryComponent`.
    Both components get the same instance of `WorkoutHistoryTrackerService`. The next
    diagram highlights this registration and injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To confirm, just add a `console.log` statement in the `WorkoutHistoryTrackerService` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Refresh the app and open the history page by clicking on the header link. The
    message log is generated once, irrespective of how many times we run the workout
    or open the history page.
  prefs: []
  type: TYPE_NORMAL
- en: That's also a new interaction/data flow pattern!
  prefs: []
  type: TYPE_NORMAL
- en: Think carefully; a service is being used to share state between two components. `WorkoutRunnerComponent` is
    generating data and `WorkoutHistoryComponent` is consuming it. And without any
    interdependence. We are exploiting the fact that dependencies are singleton in
    nature. This data-sharing/interaction/data-flow pattern can be used to share state
    between any number of components. Indeed, this is a very powerful weapon in our
    arsenal. The next time there is a need to share state between unrelated components,
    think of services.
  prefs: []
  type: TYPE_NORMAL
- en: But what does all this have to do with hierarchical injectors? OK, let's not
    beat around the bush; let's get straight to the point.
  prefs: []
  type: TYPE_NORMAL
- en: While dependencies registered with the injector are singleton, `Injector` itself
    is not! At any given point in time, there are multiple injectors active in the
    application. In fact, injectors are created in the same hierarchy as the component
    tree. Angular creates an `Injector` instance for every component in the component
    tree (oversimplification; see the next information box).
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular does not literally create an injector for each component. As explained
    in the Angular developer guide: every component doesn''t need its own injector
    and it would be horribly inefficient to create masses of injectors for no good
    purpose. But it is true that every component has an injector (even if it shares
    that injector with another component) and there may be many different injector
    instances operating at different levels of the component tree. It is useful to
    pretend that every component has its own injector.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The component and injector tree looks something like this when a workout is
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The insert textbox denotes the component name. The **root injector** is the
    injector created as part of the application bootstrap process.
  prefs: []
  type: TYPE_NORMAL
- en: What is the significance of this injector hierarchy? To understand the implications,
    we need to understand what happens when a component requests a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Angular DI dependency walk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever requested for a dependency, Angular first tries to satisfy the dependency
    from the component''s own injector. If it fails to find the requested dependency,
    it queries the parent component injector for the dependency, and its parent if
    the probing fails again, and so on and so forth till it finds the dependency or
    reaches the root injector. The takeaway: any dependency search is hierarchy-based.'
  prefs: []
  type: TYPE_NORMAL
- en: Earlier when we registered `WorkoutHistoryTrackerService`, it was registered
    with the root injector. The `WorkoutHistoryTrackerService` dependency request
    from both `WorkoutRunnerComponent` and `WorkoutHistoryComponent` gets satisfied
    by the root injector, and not by their own component injectors.
  prefs: []
  type: TYPE_NORMAL
- en: This hierarchical injector structure brings a lot of flexibility. We can configure
    different providers at different component levels and override the parent provider
    configuration in child components. This only applies to dependencies registered
    on components. If the dependency is added to a module, it gets registered on the
    root injector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, if a dependency is registered at the component level, its life cycle
    is bound to the component''s life cycle. The dependency is created every time
    the component is loaded, and destroyed when the component is destroyed. Unlike
    module-level dependencies that are created only once: when requested for the first
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to override the global `WorkoutHistoryTrackerService` service in components
    that use it to learn what happens on such overrides. It's going to be fun and
    we will learn a lot!
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout-runner.component.ts` and add a `providers` attribute to the `@Component` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Do this in `workout-history.component.ts` too. Now if we refresh the app, start
    a workout, and then load the history page, the grid is empty. Irrespective of
    the times we try to run the workout, the history grid is always empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is quite obvious. After setting the `WorkoutHistoryTrackerService` provider
    on each `WorkoutRunnerComponent` and `WorkoutHistoryComponent`, the dependency
    is being fulfilled by the respective component injectors themselves. Both component
    injectors create their own instance of `WorkoutHistoryTrackerService` when requested,
    and hence the history tracking is broken. Look at the following diagram to understand
    how the request is fulfilled in both scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A quick question: what happens if we register the dependency in the root component, `TrainerAppComponent`,
    instead of doing it on the module? Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, with this setup too, things work perfectly. That's pretty evident; `TrainerAppComponent` is
    a parent component for `RouterOutlet` that internally loads `WorkoutRunnerComponent` and `WorkoutHistoryComponent`.
    Hence in such a setup, the dependency gets fulfilled by the `TrainerAppComponent` injector.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency lookup up on the component hierarchy can be manipulated if an intermediate
    component has declared itself as a host component. We will learn more about it
    in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical injectors allow us to register dependencies at a component level,
    avoiding the need to register all dependencies globally.
  prefs: []
  type: TYPE_NORMAL
- en: The predominant use case for this functionality is when building an Angular
    library component. Such components can register their own dependencies without
    requiring the consumer of the library to register library-specific dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: if you are having trouble loading the right service/dependency, make
    sure you check the component hierarchy for overrides done at any level.'
  prefs: []
  type: TYPE_NORMAL
- en: We now understand how dependency resolution works in components. But what happens
    if a service has a dependency? Yet more uncharted territory to explore. Let's
    extend our app further.
  prefs: []
  type: TYPE_NORMAL
- en: Remove any `provider` registration done on components before continuing further.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection with @Injectable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WorkoutHistoryTrackerService` has a fundamental flaw: the history is not persisted.
    Refresh the app and the history is lost. We need to add persistence logic to store
    historical data. To avoid any complex setup, we are going to use the browser local
    storage to store historical data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `LocalStorageService` service by invoking this CLI command from the `trainer/src/app/core` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the following two functions to the generated class, or copy them from
    the `checkpoint3.2` GitHub branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: A simple wrapper over the browser's `localStorage` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like any other dependency, inject it into the `WorkoutHistoryTrackerService` constructor
    (the `workout-history-tracker.ts` file) with the necessary import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: It is advisable that the default `Injectable` decorator on the service is applied,
    even if we register the dependency on module (`NgModule` provider registrations
    syntax). Especially when the service itself has a dependency, as it does with
    the preceding example of `WorkoutHistoryTrackerService`. Do not use the `providedIn` decorator
    attribute of `Injectable`  when using the module-based service registration.
  prefs: []
  type: TYPE_NORMAL
- en: By putting in the `@Injectable` decorator, we are forcing the TypeScript transpiler
    to generate metadata for the `WorkoutHistoryTrackerService` class. This includes
    details about the constructor arguments. Angular DI consumes this generated metadata
    to determine the types of dependency the service has, and in future, it fulfills
    these dependencies when the service is created.
  prefs: []
  type: TYPE_NORMAL
- en: What about `WorkoutRunnerComponent`, which that uses `WorkoutHistoryTrackerService`?
    We have not used `@Injectable` there but still, the DI works. We don't need to.
    Any decorator works and there is already an `@Component` decorator applied to
    all components.
  prefs: []
  type: TYPE_NORMAL
- en: The actual integration between the `LocalStorage` service and `WorkoutHistoryTrackerService` is
    a mundane process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the constructor for `WorkoutHistoryTrackerService` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'And add a declaration for `storageKey`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The constructor loads the workout logs from the local storage. The `map` function
    call is necessary as everything stored in `localStorage` is a string. Therefore,
    while de-serializing, we need to convert the string back to the date value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this statement last in the `startTracking`, `exerciseComplete`, and `endTracking` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We save the workout history to local storage every time the historical data
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! We have built workout history tracking over `localStorage`. Verify
    it!
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to our big-ticket item, audio support, there are a few minor
    fixes that are needed for a better user experience. The first one is related to
    the History link.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking route changes using the router service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The History link in the `Header` component is visible for all routes other that
    when a workout is in progress. We don't want to lose an in-progress workout by
    accidentally clicking on the History link. Moreover, no one is interested in knowing
    about the workout history while doing a workout.
  prefs: []
  type: TYPE_NORMAL
- en: The fix is easy. We just need to determine whether the current route is the
    workout route and hide the link. The `Router` service is going to help us with
    this job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `header.component.ts` and look at the highlighted implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The `showHistoryLink` property binds to the view and decides whether the history
    link is shown to the user or not. In the constructor, we inject the `Router` service
    and subscribe to the observable `events` using the `subscribe` function.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about observables later in the chapter, but for now, it is
    enough to understand that observables are objects that raise events and can be
    subscribed to. Since the router raises a number of events throughout the component's
    life cycle, the `filter` operator allows us to filter the event we are interested
    in and the `subscribe` function registers a callback function that is invoked
    every time the route changes.
  prefs: []
  type: TYPE_NORMAL
- en: To learn about the other router events, including `NavigationStart`, `NavigationEnd`, `NavigationCancel`,
    and `NavigationError`, look at the router documentation ([http://bit.ly/ng-router-events](http://bit.ly/ng-router-events))
    to understand when the events are raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback implementation just toggles the `showHistoryLink` state based
    on the current route URL. To use `showHistoryLink` in the view, just update the
    header template line with the anchor tag to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! The History link does not show up on the workout page.
  prefs: []
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the `checkpoint3.2` Git
    branch for a working version of what we have done thus far. Or if you are not
    using Git, download the snapshot of `checkpoint3.2` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-2](http://bit.ly/ng6be-checkpoint-3-2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Another fix/enhancement is related to the video panel on the workout page.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the video playback experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current video panel implementation can at best be termed amateurish. The
    size of the default player is small. When we play the video, the workout does
    not pause. The video playback is interrupted on exercise transitions. Also, the
    overall video-load experience adds a noticeable lag at the start of every exercise
    routine. This is a clear indication that this approach to video playback needs
    some fixing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we are going to do to fix the video panel:'
  prefs: []
  type: TYPE_NORMAL
- en: Show the image thumbnail for the exercise video instead of loading the video
    player itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user clicks on the thumbnail, load a popup/dialog with a bigger video
    player that can play the selected video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause the workout while the video playback is on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get on with the job!
  prefs: []
  type: TYPE_NORMAL
- en: Using thumbnails for video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Replace the `ngFor` HTML template inside `video-player.component.html` with this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: We have abandoned iframe, and instead loaded the thumbnail image of the video
    (check the `img` tag). All other content shown here is for styling the image.
  prefs: []
  type: TYPE_NORMAL
- en: We have referenced the Stack Overflow post ([http://bit.ly/so-yt-thumbnail](http://bit.ly/so-yt-thumbnail)) to
    determine the thumbnail image URL for our videos.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new workout; the images should show up, but the playback functionality
    is broken. We need to add a video playback dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ngx-modialog library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To show the video in a dialog, we are going to incorporate a third-party library, **ngx-modialog**,
    available on GitHub at [http://bit.ly/ngx-modialog](http://bit.ly/ngx-modialog).
    Let's install and configure the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command line (inside the `trainer` folder), run the following command
    to install the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Work on an Angular v6-compatible `ngx-modialog` library is in progress ([https://github.com/shlomiassaf/ngx-modialog/issues/426](https://github.com/shlomiassaf/ngx-modialog/issues/426)).
    To use the version 5 library, which is dependent on older version of RxJS, install
    the `rxjs-compat` package from command line, `npm i rxjs-compat --save`, before
    proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next import and configure the library in the core module. Open `core.module.ts` and
    add the highlighted configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The library is now ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: While *ngx-modialog* has a number of predefined templates for standard dialogs,
    such as alert, prompt, and confirm, these dialogs provide little customization
    in terms of look and feel. To have better control over the dialog UI, we need
    to create a custom dialog, which thankfully the library supports.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom dialogs in `ngx-modialog` are nothing but Angular components with some
    special library construct incorporated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with building a video dialog component that shows the YouTube
    video in a popup dialog. Generate the component''s boilerplate by navigating to `trainer/src/app/workout-runner/video-player` and
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Copy the video dialog implementation from the `workout-runner/video-player/video-dialog` folder
    in the `checkpoint3.3` Git branch (GitHub location: [http://bit.ly/ng6be-3-3-video-dialog](http://bit.ly/ng6be-3-3-video-dialog))
    into your local setup. You need to update the component implementation and the
    view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, update `workout-runner.module.ts` and add a new `entryComponents` attribute
    to the module decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The newly created `VideoDialogComponent` needs to be added to `entryComponents` as
    it is not explicitly used in the component tree.
  prefs: []
  type: TYPE_NORMAL
- en: '`VideoDialogComponent` is a standard Angular component, with some modal dialog
    and specific implementations that we describe later. The `VideoDialogContext` class
    declared inside `VideoDialogComponent` has been created to pass the `videoId` of
    the YouTube video clicked to the dialog instance. The library uses this context
    class to pass data between the calling code and the modal dialog. The `VideoDialogContext` class
    inherits a configuration class that the dialog library uses to alter the behavior
    and UI of the modal dialog from `BSModalContext`.'
  prefs: []
  type: TYPE_NORMAL
- en: To get a better sense of how `VideoDialogContext` is utilized, let's invoke
    the preceding dialog from the workout runner when the video image is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `ngFor` div in `video-player.component.html` and add a `click` event
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding handler invokes the `playVideo` method, passing in the video
    clicked. The `playVideo` function, in turn, opens the corresponding video dialog.
    Add the `playVideo` implementation to `video-player.component.ts` as highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The `playVideo` function calls the `Modal` class' `open` function, passing in
    the dialog component to open and a new instance of the `VideoDialogContext` class
    with the `videoId` of the YouTube video. Before proceeding, delete the `ngOnChange` function
    and the interface declaration too.
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to the `VideoDialogComponent` implementation, the component implements
    the `ModalComponent<VideoDialogContext>` interface required by the modal library.
    Look at how the context (`VideoDialogContext`) to the dialog is passed to the
    constructor and how we extract and assign the `videoId` property from the context.
    Then it's just a matter of binding the `videoId` property to the template view
    (see the HTML template) and rendering the YouTube player.
  prefs: []
  type: TYPE_NORMAL
- en: And we are good to go. Load the app and start the workout. Then click on any
    workout video images. The video dialog should load and now we can watch the video!
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we call the dialog implementation complete, there is one small issue
    that needs to be fixed. When the dialog opens, the workout should pause: that''s
    not happening currently. We will help you fix it at the end of the next section
    using Angular''s eventing infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the `checkpoint3.3` Git
    branch for a working version of what we have done thus far. Or if you are not
    using Git, download the snapshot of `checkpoint3.3` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-3](http://bit.ly/ng6be-checkpoint-3-3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one last feature that we plan to add to *7-Minute Workout* before
    wrapping up the application and building something new with Angular: audio support.
    It teaches us some new cross-component communication patterns too.'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-component communication using Angular events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We touched upon events in the last chapter when learning about Angular's binding infrastructure.
    It's time now to look at eventing in more depth. Let's add audio support to *7-Minute
    Workout*.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking exercise progress with audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the *7-Minute Workout* app, adding sound support is vital. One cannot exercise
    while constantly staring at the screen. Audio clues help the user perform the
    workout effectively as they can just follow the audio instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we are going to support exercise tracking using audio clues:'
  prefs: []
  type: TYPE_NORMAL
- en: A ticking clock soundtrack progress during the exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A half-way indicator sounds, indicating that the exercise is halfway through
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exercise-completion audio clip plays when the exercise is about to end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An audio clip plays during the rest phase and informs users about the next exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be an audio clip for each of these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Modern browsers have good support for audio. The HTML5 `<audio>` tag provides
    a mechanism to embed audio clips into HTML content. We too will use the `<audio>` tag
    to play back our clips.
  prefs: []
  type: TYPE_NORMAL
- en: Since the plan is to use the HTML `<audio>` element, we need to create a wrapper
    directive that allows us to control audio elements from Angular. Remember that
    directives are HTML extensions without a view.
  prefs: []
  type: TYPE_NORMAL
- en: The `checkpoint3.4` Git and the `trainer/static/audio` folder contain all the
    audio files used for playback; copy them first. If you are not using Git, a snapshot
    of the chapter code is available at [http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4).
    Download and unzip the contents and copy the audio files.
  prefs: []
  type: TYPE_NORMAL
- en: Building Angular directives to wrap HTML audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have worked a lot with JavaScript and jQuery, you may have realized we have
    purposefully shied away from directly accessing the DOM for any of our component
    implementations. There has not been a need to do it. The Angular data-binding
    infrastructure, including property, attribute, and event binding, has helped us
    manipulate HTML without touching the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: For the audio element too, the access pattern should be Angularish. In Angular,
    the only place where direct DOM manipulation is acceptable and practiced is inside
    directives. Let's create a directive that wraps access to audio elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to `trainer/src/app/shared` and run this command to generate a template
    directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Since it is the first time we are creating a directive, we encourage you to
    look at the generated code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the directive is added to the shared module, it needs to be exported
    too. Add the `MyAudioDirective` reference in the `exports` array too (`shared.module.ts`).
    Then update the directive definition with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The `MyAudioDirective` class is decorated with `@Directive`. The `@Directive` decorator
    is similar to the `@Component` decorator except we cannot have an attached view.
    Therefore, no `template` or `templateUrl` is allowed!
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `selector` property allows the framework to identify where to
    apply the directive. We have replaced the generated `[abeMyAudioDirective]` attribute
    selector with just `audio`. Using `audio` as the selector makes our directive
    load for every `<audio>` tag used in HTML. The new selector works as an element
    selector.
  prefs: []
  type: TYPE_NORMAL
- en: In a standard scenario, directive selectors are attribute-based (such as `[abeMyAudioDirective]` for
    the generated code), which helps us identify where the directive has been applied.
    We deviate from this norm and use an element selector for the `MyAudioDirective` directive.
    We want this directive to be loaded for every audio element, and it becomes cumbersome
    to go to each audio declaration and add a directive-specific attribute. Hence
    an element selector.
  prefs: []
  type: TYPE_NORMAL
- en: The use of `exportAs` becomes clear when we use this directive in view templates.
  prefs: []
  type: TYPE_NORMAL
- en: The `ElementRef` object injected in the constructor is the Angular element (`audio` in
    this case) for which the directive is loaded. Angular creates the `ElementRef` instance
    for every component and directive when it compiles and executes the HTML template.
    When requested in the constructor, the DI framework locates the corresponding `ElementRef` and
    injects it. We use `ElementRef` to get hold of the underlying audio element in
    the code (the instance of `HTMLAudioElement`). The `audioPlayer` property holds
    this reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The directive now needs to expose an API to manipulate the audio player. Add
    these functions to the `MyAudioDirective` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The `MyAudioDirective` API has two functions (`start` and `stop`) and three
    getters (`currentTime`, `duration`, and a Boolean property called `playbackComplete`).
    The implementations for these functions and properties just wrap the audio element
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Learn about these audio functions from the MDN documentation here: [http://bit.ly/html-media-element](http://bit.ly/html-media-element).
  prefs: []
  type: TYPE_NORMAL
- en: To understand how we use the audio directive, let's create a new component that
    manages audio playback.
  prefs: []
  type: TYPE_NORMAL
- en: Creating WorkoutAudioComponent for audio support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we go back and look at the audio cues that are required, there are four distinct
    audio cues, and hence we are going to create a component with five embedded `<audio>` tags
    (two audio tags work together for next-up audio).
  prefs: []
  type: TYPE_NORMAL
- en: From the command line go to the `trainer/src/app/workout-runner` folder and
    add a new `WorkoutAudioComponent` component using Angular CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout-audio.component.html` and replace the existing view template
    with this HTML snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'There are five `<audio>` tags, one for each of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ticking audio**: The first audio tag produces the ticking sound and is started as
    soon as the workout starts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Next up audio and exercise audio**: There next two audio tags work together.
    The first tag produces the "Next up" sound. And the actual exercise audio is handled
    by the third tag (in the preceding code snippet).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Halfway audio**: The fourth audio tag plays halfway through the exercise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**About to complete audio**: The final audio tag plays a piece to denote the
    completion of an exercise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you notice the usage of the `#` symbol in each of the `audio` tags? There
    are some variable assignments prefixed with `#`. In the Angular world, these variables are
    known as **template reference variables** or at times **template variables**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the platform guide defines:'
  prefs: []
  type: TYPE_NORMAL
- en: A template reference variable is often a reference to a DOM element or directive
    within a template.
  prefs: []
  type: TYPE_NORMAL
- en: Don't confuse them with the template input variables that we have used with
    the `ngFor` directive earlier, `*ngFor="let` video `of videos"`. The **template
    input variable's** (`video` in this case) scope is within the HTML fragment it
    is declared, whereas the template reference variable can be accessed across the
    entire template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the last section where `MyAudioDirective` was defined. The `exportAs` metadata
    is set to `MyAudio`. We repeat that same `MyAudio` string while assigning the `template
    reference variable` for each audio tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The role of `exportAs` is to define the name that can be used in the view to
    assign this directive to a variable. Remember, a single element/component can
    have multiple directives applied to it. `exportAs` allows us to select which directive
    should be assigned to a template-reference variable based on what is on the right
    side of equals.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, template variables, once declared, give access to the view element/component
    they are attached to, to other parts of the view, something we will discuss shortly.
    But in our case, we will use template variables to refer to the multiple `MyAudioDirective` from
    the parent component's code. Let's understand how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the generated `workout-audio.compnent.ts` with the following outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The interesting bit in this outline is the `@ViewChild` decorator against the
    five properties. The `@ViewChild` decorator allows us to inject a child component/directive/element
    reference into its parent. The parameter passed to the decorator is the template
    variable name, which helps DI match the element/directive to inject. When Angular
    instantiates the main `WorkoutAudioComponent`, it injects the corresponding audio
    directives based on the `@ViewChild` decorator and the template reference variable
    name passed. Let's complete the basic class implementation before we look at `@ViewChild` in
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Without `exportAs` set on the `MyAudioDirective` directive, the `@ViewChild` injection
    injects the related `ElementRef` instance instead of the `MyAudioDirective` instance.
    We can confirm this by removing the `exportAs` attribute from `myAudioDirective` and
    then looking at the injected dependencies in `WorkoutAudioComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining task is to just play the correct audio component at the right
    time. Add these functions to `WorkoutAudioComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Having trouble writing these functions? They are available in the `checkpoint3.3` Git
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two new model classes used in the preceding code. Add their declarations
    to `model.ts`, as follows (again available in `checkpoint3.3`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: These are model classes to track progress events. The `WorkoutAudioComponent` implementation
    consumes this data. Remember to import the reference for `ExerciseProgressEvent` and `ExerciseProgressEvent` in `workout-audio.component.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, the audio component consumes the events by defining two event
    handlers: `onExerciseProgress` and `onExerciseChanged.` How the events are generated
    becomes clear as we move along.
  prefs: []
  type: TYPE_NORMAL
- en: The `start` and `resume` functions stop and resume audio whenever a workout
    starts, pauses, or completes. The extra complexity in the resume function it to
    tackle cases when the workout was paused during next up, about to complete, or
    half-way audio playback. We just want to continue from where we left off.
  prefs: []
  type: TYPE_NORMAL
- en: The `onExerciseProgress` function should be called to report the workout progress.
    It's used to play the halfway audio and about-to-complete audio based on the state
    of the workout. The parameter passed to it is an object that contains exercise
    progress data.
  prefs: []
  type: TYPE_NORMAL
- en: The `onExerciseChanged` function should be called when the exercise changes.
    The input parameter contains the current and next exercise in line and helps `WorkoutAudioComponent` to
    decide when to play the next up exercise audio.
  prefs: []
  type: TYPE_NORMAL
- en: 'We touched upon two new concepts in this section: template reference variables
    and injecting child elements/directives into the parent. It''s worth exploring
    these two concepts in more detail before we continue with the implementation.
    We''ll start with learning more about template reference variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding template reference variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Template reference variables** are created on the view template and are mostly
    consumed from the view. As you have already learned, these variables can be identified
    by the `#` prefix used to declare them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the greatest benefits of template variables is that they facilitate
    cross-component communication at the view template level. Once declared, such
    variables can be referenced by sibling elements/components and their children.
    Check out the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The Angular templating engine assigns the DOM object for `input` (an instance
    of `HTMLInputElement`) to the `emailId` variable. Since the variable is available
    across siblings, we use it in a button's `click` expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Template variables work with components too. We can easily do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `runner` has a reference to the `WorkoutRunnerComponent` object,
    and the button is used to start the workout.
  prefs: []
  type: TYPE_NORMAL
- en: The `ref-` prefix is the canonical alternative to `#`. The `#runner` variable
    can also be declared as `ref-runner`.
  prefs: []
  type: TYPE_NORMAL
- en: Template variable assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may not have noticed but there is something interesting about the template variable
    assignments described in the last few sections. To recap, the three examples that
    we have used are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'What got assigned to the variable depends on where the variable was declared.
    This is governed by rules in Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: If a directive is present on the element, such as `MyAudioDirective` in the
    first example shown previously, the directive sets the value. The `MyAudioDirective` directive
    sets the `ticks` variable to an instance of `MyAudioDirective`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no directive present, either the underlying HTML DOM element is
    assigned or a component object is assigned (as shown in the `input` and `workout-runner` examples).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be employing this technique to implement the workout audio component
    integration with the workout runner component. This introduction gives us the
    head start that we need.
  prefs: []
  type: TYPE_NORMAL
- en: The other new concept that we promised to cover is child element/directive injection
    using the `ViewChild` and `ViewChildren` decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Using the @ViewChild decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@ViewChild` decorator instructs the Angular DI framework to search for
    some specific child component/directive/element in the component tree and inject
    it into the parent. This allows the parent component to interact with child components/element
    using the reference to the child, a new communication pattern!
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, the audio element directive (the `MyAudioDirective` class)
    is injected into the `WorkoutAudioComponent` code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To establish the context, let''s recheck a view fragment from `WorkoutAudioComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Angular injects the directive (`MyAudioDirective`) into the `WorkoutAudioComponent` property: `ticks`.
    The search is done based on the selector passed to the `@ViewChild` decorator.
    Let''s see the audio example again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The selector parameter on `ViewChild` can be a string value, in which case Angular
    searches for a matching template variable, as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or it can be a *type.* This is valid and should inject an instance of `MyAudioDirective`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: However, it does not work in our case. Why? Because there are multiple `MyAudioDirective` directives
    declared in the `WorkoutAudioComponent` view, one for each of the `<audio>` tags.
    In such a scenario, the first match is injected. Not very useful. Passing the
    type selector would have worked if there was only one `<audio>` tag in the view!
  prefs: []
  type: TYPE_NORMAL
- en: Properties decorated with `@ViewChild` are sure to be set before the `ngAfterViewInit` event
    hook on the component is called. This implies such properties are `null` if accessed
    inside the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Angular also has a decorator to locate and inject multiple child components/directives: `@ViewChildren`.
  prefs: []
  type: TYPE_NORMAL
- en: The @ViewChildren decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`@ViewChildren` works similarly to `@ViewChild`, except it can be used to inject
    multiple child types into the parent. Again taking the previous audio component
    above as an example, using `@ViewChildren`, we can get all the `MyAudioDirective` directive
    instances in `WorkoutAudioComponent`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Look carefully; `allAudios` is not a standard JavaScript array, but a custom
    class, `QueryList<Type>`. The `QueryList` class is an immutable collection that
    contains the reference to the components/directives that Angular was able to locate
    based on the filter criteria passed to the `@ViewChildren` decorator. The best
    thing about this list is that Angular will keep this list in sync with the state
    of the view. When directives/components get added/removed from the view dynamically,
    this list is updated too. Components/directives generated using `ng-for` are a
    prime example of this dynamic behavior. Consider the preceding `@ViewChildren` usage
    and this view template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The number of `MyAudioDirective` directives created by Angular depends upon
    the number of `clips`. When `@ViewChildren` is used, Angular injects the correct
    number of `MyAudioDirective` instances into the `allAudio` property and keeps
    it in sync when items are added or removed from the `clips` array.
  prefs: []
  type: TYPE_NORMAL
- en: While the usage of `@ViewChildren` allows us to get hold of all `MyAudioDirective` directives,
    it cannot be used to control the playback. You see, we need to get hold of individual `MyAudioDirective` instances
    as the audio playback timing varies. Hence the distinct `@ViewChild` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Once we get hold of the `MyAudioDirective` directive attached to each audio
    element, it is just a matter of playing the audio tracks at the right time.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating WorkoutAudioComponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have componentized the audio playback functionality into `WorkoutAudioComponent`,
    it is and always will be tightly coupled to the `WorkoutRunnerComponent` implementation. `WorkoutAudioComponent` derives
    its operational intelligence from `WorkoutRunnerComponent`. Hence the two components
    need to interact. `WorkoutRunnerComponent` needs to provide the `WorkoutAudioComponent` state
    change data, including when the workout started, exercise progress, workout stopped,
    paused, and resumed.
  prefs: []
  type: TYPE_NORMAL
- en: One way to achieve this integration would be to use the currently exposed `WorkoutAudioComponent` API
    (stop, resume, and other functions) from `WorkoutRunnerComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Something can be done by injecting `WorkoutAudioComponent` into `WorkoutRunnerComponent`,
    as we did earlier when we injected `MyAudioDirective` into `WorkoutAudioComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the `WorkoutAudioComponent` in the `WorkoutRunnerComponent''s` view,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing so gives us a reference to the `WorkoutAudioComponent` inside the `WorkoutRunnerComponent` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WorkoutAudioComponent` functions can then be invoked from `WorkoutRunnerComponent` from
    different places in the code. For example, this is how `pause` would change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'And to play the next-up audio, we would need to change parts of the `startExerciseTimeTracking` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: This is a perfectly viable option where `WorkoutAudioComponent` becomes a dumb
    component controlled by `WorkoutRunnerComponent`. The only problem with this solution
    is that it adds some noise to the `WorkoutRunnerComponent` implementation. `WorkoutRunnerComponent` now
    needs to manage audio playback too.
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative, however.
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutRunnerComponent` can expose events that are triggered during different
    times of workout execution, such as workout started, exercise started, and workout
    paused. The advantage of having `WorkoutRunnerComponent` expose events is that
    it allows us to integrate other components/directives with `WorkoutRunnerComponent` using
    the same events. Be it the `WorkoutAudioComponent` or components we create in
    future.'
  prefs: []
  type: TYPE_NORMAL
- en: Exposing WorkoutRunnerComponent events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now we have only explored how to consume events. Angular allows us to raise
    events too. Angular components and directives can expose custom events using the `EventEmitter` class
    and the `@Output` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these event declarations to `WorkoutRunnerComponent` at the end of the
    variable declaration section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The names of the events are self-explanatory, and within our `WorkoutRunnerComponent` implementation,
    we need to raise them at the appropriate times.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to add the `ExerciseProgressEvent` and `ExerciseChangeEvent` imports
    to the `model` already declared on top. And add the `Output` and `EventEmitter` imports
    to `@angular/core`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to understand the role of the `@Output` decorator and the `EventEmitter` class.
  prefs: []
  type: TYPE_NORMAL
- en: The @Output decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a decent amount of Angular eventing capabilities in Chapter 2, *Building
    Our First App – 7-Minute Workout*. Specifically, we learned how we can consume
    any event on a component, directive, or DOM element using the `bracketed ()` syntax.
    How about raising our own events?
  prefs: []
  type: TYPE_NORMAL
- en: In Angular, we can create and raise our own events, events that signify something
    noteworthy has happened in our component/directive. Using the `@Output` decorator
    and the `EventEmitter` class, we can define and raise custom events.
  prefs: []
  type: TYPE_NORMAL
- en: It's also a good time to refresh what we learned about events, by revisiting
    the *Eventing subsection* in the *Angular event binding infrastructure* section
    from Chapter 2, *Building Our First App – 7-Minute Workout*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember this: it is through events that components can communicate with the
    outside world. When we declare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: It signifies that `WorkoutRunnerComponent` exposes an event, `exercisePaused` (raised
    when the workout is paused).
  prefs: []
  type: TYPE_NORMAL
- en: 'To subscribe to this event, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks absolutely similar to how we did the DOM event subscription in the
    workout runner template. See this sample stipped from the workout-runner''s view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The `@Output` decorator instructs Angular to make this event available for template
    binding. Events created without the `@Output` decorator cannot be referenced in
    HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Output` decorator can also take a parameter, signifying the name of the
    event. If not provided, the decorator uses the property name: `@Output("workoutPaused")
    exercisePaused: EventEmitter<number> ...`. This declares a `workoutPaused` event
    instead of `exercisePaused`.'
  prefs: []
  type: TYPE_NORMAL
- en: Like any decorator, the `@Output` decorator is there just to provide metadata
    for the Angular framework to work with. The real heavy lifting is done by the `EventEmitter` class.
  prefs: []
  type: TYPE_NORMAL
- en: Eventing with EventEmitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular embraces **reactive programming** (also dubbed **Rx**-style programming)
    to support asynchronous operations with events. If you are hearing this term for
    the first time or don't have much idea about what reactive programming is, you're
    not alone.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is all about programming against **asynchronous data streams**.
    Such a stream is nothing but a sequence of ongoing events ordered based on the
    time they occur. We can imagine a stream as a pipe generating data (in some manner)
    and pushing it to one or more subscribers. Since these events are captured asynchronously
    by subscribers, they are called asynchronous data streams.
  prefs: []
  type: TYPE_NORMAL
- en: The data can be anything, ranging from browser/DOM element events to user input
    to loading remote data using AJAX. With *Rx* style, we consume this data uniformly.
  prefs: []
  type: TYPE_NORMAL
- en: In the Rx world, there are Observers and Observables, a concept derived from
    the very popular **Observer design pattern**. **Observables** are streams that
    emit data. **Observers**, on the other hand, subscribe to these events.
  prefs: []
  type: TYPE_NORMAL
- en: The `EventEmitter` class in Angular is primarily responsible for providing eventing
    support. It acts both as an *observer* and *observable*. We can fire events on
    it and it can also listen to events.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two functions available on `EventEmitter` that are of interest to
    us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emit`: As the name suggests, use this function to raise events. It takes a
    single argument that is the event data. `emit` *is the observable side*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe`: Use this function to subscribe to the events raised by `EventEmitter`. `subscribe` is
    the observer side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's do some event publishing and subscriptions to understand how the preceding
    functions work.
  prefs: []
  type: TYPE_NORMAL
- en: Raising events from WorkoutRunnerComponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look at the `EventEmitter` declaration. These have been declared with the `type` parameter.
    The `type` parameter on `EventEmitter` signifies the type of data emitted.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add the event implementation to `workout-runner.component.ts`, starting
    from the top of the file and moving down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this statement to the end of the `start` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: We use the `emit` function of  `EventEmitter`  to raise a `workoutStarted` event
    with the current workout plan as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'To `pause`, add this line to raise the `exercisePaused` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'To `resume`, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Each time, we pass the current exercise index as an argument to `emit` when
    raising the `exercisePaused` and `exerciseResumed` events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `startExerciseTimeTracking` function, add the highlighted code after
    the call to `startExercise`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The argument passed contains the exercise that is going to start (`next`) and
    the next exercise in line (`this.getNextExercise()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To the same function, add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: The event is raised when the workout is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same function, we raise an event that communicates the workout progress.
    Add this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: That completes our eventing implementation.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have guessed, `WorkoutAudioComponent` now needs to consume these
    events. The challenge here is how to organize these components so that they can
    communicate with each other with the minimum dependency on each other.
  prefs: []
  type: TYPE_NORMAL
- en: Component communication patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the implementation stands now, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: A basic `WorkoutAudioComponent` implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augmented `WorkoutRunnerComponent` by exposing workout life cycle events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two components just need to talk to each other now.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the parent needs to communicate with its children, it can do this by:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Property binding**: The parent component can set up a property binding on
    the child component to push data to the child component. For example, this property
    binding can stop the audio player when the workout is paused:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Property binding, in this case, works fine. When the workout is paused, the
    audio is stopped too. But not all scenarios can be handled using property bindings.
    Playing the next exercise audio or halfway audio requires a bit more control.
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling functions on child components**: The parent component can also call
    functions on the child component if it can get hold of the child component. We
    have already seen how to achieve this using the `@ViewChild` and `@ViewChildren` decorators
    in the `WorkoutAudioComponent` implementation. This approach and its shortcomings
    have also been discussed briefly in the *Integrating WorkoutAudioComponent* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is one more not-so-good option. Instead of the parent referencing the
    child component, the child references the parent component. This allows the child
    component to call the parent component's public functions or subscribe to parent
    component events.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to try this approach and then scrap the implementation for a better
    one! A lot of learning can be derived from the not-so-optimal solution we plan
    to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting a parent component into a child component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the `WorkoutAudioComponent` to the `WorkoutRunnerComponent` view just before the
    last closing `div`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, inject `WorkoutRunnerComponent` into `WorkoutAudioComponent`. Open `workout-audio.component.ts` and
    add the following declaration and update the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'And remember to add these imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Let's try to understand what we have done before running the app. There is some
    amount of trickery involved in the construction injection. If we directly try
    to inject `WorkoutRunnerComponent` into `WorkoutAudioComponent`, it fails with
    Angular complaining of not being able to find all the dependencies. Read the code
    and think carefully; there is a subtle dependency cycle issue lurking. `WorkoutRunnerComponent` is
    already dependent on `WorkoutAudioComponent`, as we have referenced `WorkoutAudioComponent` in
    the `WorkoutRunnerComponent` view. Now by injecting `WorkoutRunnerComponent` in `WorkoutAudioComponent`,
    we have created a dependency cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Cyclic dependencies are challenging for any DI framework. When creating a component
    with a cyclic dependency, the framework has to somehow resolve the cycle. In the
    preceding example, we resolve the circular dependency issue by using an `@Inject` decorator
    and passing in the token created using the `forwardRef()` global framework function.
  prefs: []
  type: TYPE_NORMAL
- en: Once the injection is done correctly, inside the constructor, we attach a handler
    to the `WorkoutRunnerComponent` events, using the `subscribe` function of `EventEmitter`.
    The arrow function passed to `subscribe` is called whenever the event occurs with
    a specific event argument. We collect all the subscriptions into a `subscription` array.
    This array comes in handy when we unsubscribe, which we need to, to avoid memory
    leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit about `EventEmitter`: the `EventEmmiter` subscription (`subscribe` function)
    takes three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is a callback, which is invoked whenever an event is emitted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is an error callback function, invoked when the observable
    (the part that is generating events) errors out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final argument takes a callback function that is called when the observable
    is done publishing events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have done enough to make audio integration work. Run the app and start the
    workout. Except for the ticking audio, all the `\` audio clips play at the right
    time. You may have to wait some time to hear the other audio clips. What is the
    problem?
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, we never started the ticking audio clip at the start of the
    workout. We can fix it by either setting the `autoplay` attribute on the `ticks` audio
    element or using the component life cycle events to trigger the ticking sound.
    Let's take the second approach.
  prefs: []
  type: TYPE_NORMAL
- en: Using component life cycle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The injected `MyAudioDirective` in `WorkoutAudioComponent`, shown as follows,
    is not available till the view is initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: We can verify it by accessing the `ticks` variable inside the constructor; it
    will be null. Angular has still not done its magic and we need to wait for the
    children of `WorkoutAudioComponent` to be initialized.
  prefs: []
  type: TYPE_NORMAL
- en: The component's life cycle hooks can help us here. The `AfterViewInit` event
    hook is called once the component's view has been initialized and hence is a safe
    place from which to access the component's child directives/elements. Let's do
    it quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `WorkoutAudioComponent` by adding the interface implementation, and
    the necessary imports, as highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and test the app. The app has come to life with full-fledged audio
    feedback. Nice!
  prefs: []
  type: TYPE_NORMAL
- en: While everything looks fine and dandy on the surface, there is a memory leak
    in the application now. If, in the middle of the workout, we navigate away from
    the workout page (to the start or finish page) and again return to the workout
    page, multiple audio clips play at random times.
  prefs: []
  type: TYPE_NORMAL
- en: It seems that `WorkoutRunnerComponent` is not getting destroyed on route navigation,
    and due to this, none of the child components are destroyed, including `WorkoutAudioComponent`.
    The net result? A new `WorkoutRunnerComponent` is being created every time we
    navigate to the workout page but is never removed from the memory on navigating
    away.
  prefs: []
  type: TYPE_NORMAL
- en: The primary reason for this memory leak is the event handlers we have added
    in `WorkoutAudioComponent`. We need to unsubscribe from these events when the
    audio component unloads, or else the `WorkoutRunnerComponent` reference will never
    be dereferenced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another component lifecycle event comes to our rescue here: `OnDestroy` Add
    this implementation to the `WorkoutAudioComponent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Also, remember to add references to the `OnDestroy` event interface as we did
    for `AfterViewInit`.
  prefs: []
  type: TYPE_NORMAL
- en: Hope the `subscription` array that we created during event subscription makes
    sense now. One-shot unsubscribe!
  prefs: []
  type: TYPE_NORMAL
- en: This audio integration is now complete. While this approach is not an awfully
    bad way of integrating the two components, we can do better. Child components
    referring to the parent component seems to be undesirable.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding, delete the code that we have added to `workout-audio.component.ts` from
    the *Injecting a parent component into a child component* section onward.
  prefs: []
  type: TYPE_NORMAL
- en: Sibling component interaction using events and template variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if `WorkoutRunnerComponent` and `WorkoutAudioComponent` were organized
    as sibling components?
  prefs: []
  type: TYPE_NORMAL
- en: 'If `WorkoutAudioComponent` and `WorkoutRunnerComponent` become siblings, we
    can make good use of Angular''s *eventing* and *template reference variables*.
    Confused? Well, to start with, this is how the components should be laid out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Does it ring any bells? Starting from this template, can you guess how the final
    HTML template would look? Think about it before you proceed further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still struggling? As soon as we make them sibling components, the power of
    the Angular templating engine comes to the fore. The following template code is
    enough to integrate `WorkoutRunnerComponent` and `WorkoutAudioComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WorkoutAudioComponent` template variable, `wa`, is being manipulated by
    referencing the variable in the event handler expressions on `WorkoutRunnerComponent`.
    Quite elegant! We still need to solve the biggest puzzle in this approach: Where
    does the preceding code go? Remember, `WorkoutRunnerComponent` is loaded as part
    of route loading. Nowhere in the code have we had a statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: We need to reorganize the component tree and bring in a container component
    that can host `WorkoutRunnerComponent` and `WorkoutAudioComponent`. The router
    then loads this container component instead of `WorkoutRunnerComponent`. Let's
    do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a new component code from command line by navigating to `trainer/src/app/workout-runner` and
    executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Copy the HTML code with the events described to the template file. The workout
    container component is ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need to rewire the routing setup. Open `app-routing.module.ts`. Change
    the route for the workout runner and add the necessary import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: And we have a working audio integration that is clear, concise, and pleasing
    to the eye!
  prefs: []
  type: TYPE_NORMAL
- en: It's time now to wrap up the chapter, but not before addressing the video player
    dialog glitch introduced in the earlier sections. The workout does not stop/pause
    when the video player dialog is open.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to detail the fix here, and urge the readers to give it a try
    without consulting the `checkpoint3.4` code.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an obvious hint. Use the eventing infrastructure!
  prefs: []
  type: TYPE_NORMAL
- en: 'And another one: raise events from `VideoPlayerComponent`, one for each playback
    started and ended.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And one last hint: the `open` function on the dialog service (`Modal`) returns
    a promise, which is resolved when the dialog is closed.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the `checkpoint3.4` Git
    branch for a working version of what we have done thus far. Or if you are not
    using Git, download the snapshot of `checkpoint3.4` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bit by bit, piece by piece, we have added a number of enhancements to the *7-Minute
    Workout* app that are imperative for any professional app. There is still scope
    for new features and improvements, but the core app works just fine.
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter by exploring the Single Page Application (SPA) capabilities
    of Angular. Here we learned about basic Angular routing, setting up routes, using
    route configuration, generating links using the `RouterLink` directive, and using
    the Angular `Router` and `Location` services to perform navigation.
  prefs: []
  type: TYPE_NORMAL
- en: From the app perspective, we added start, finish, and workout pages to *7-Minute
    Workout*.
  prefs: []
  type: TYPE_NORMAL
- en: We then built a workout history tracker service that was used to track historical
    workout executions. During this process, we learned about Angular's **Dependency
    Injection (DI)** in depth. We covered how a dependency is registered, what a dependency
    token is, and how dependencies are singleton in nature. We also learned about
    injectors and how hierarchical injectors affect dependency probing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we touched upon an important topic: cross-component communication,
    primarily using Angular eventing. We detailed how to create custom events using
    the `@Output` decorator and `EventEmitter`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `@ViewChild` and `@ViewChildren` decorators that we touched upon in this
    chapter helped us understand how a parent can get hold of a child component for
    use. Angular DI also allows injecting a parent component into a child.
  prefs: []
  type: TYPE_NORMAL
- en: We concluded this chapter by building a `WorkoutAudioComponent` and highlighted
    how sibling-component communication can happen using Angular events and template
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: What's next? We are going to build a new app, *Personal Trainer*. This app will
    allow us to build our own custom workouts. Once we can create our own workout,
    we are going to morph the *7-Minute Workout* app into a generic *Workout Runner* app
    that can run workouts that we build using *Personal Trainer*.
  prefs: []
  type: TYPE_NORMAL
- en: For the next chapter, we'll showcase Angular's form capabilities while we build
    a UI that allows us to create, update, and view our own custom workouts/exercises.
  prefs: []
  type: TYPE_NORMAL
