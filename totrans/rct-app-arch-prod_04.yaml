- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Building and Configuring Pages
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和配置页面
- en: In the previous chapters, we have configured the base of our application, including
    the setup of the application, and shared UI components that will serve as the
    foundation of our UI.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经配置了应用程序的基础，包括应用程序的设置和共享 UI 组件，这些组件将作为我们 UI 的基础。
- en: In this chapter, we can proceed by creating our application pages. We will learn
    how routing in Next.js works and what rendering methods we can use to get the
    most out of Next.js. Then, we will learn about configuring per-page layouts, making
    our application look and feel like a single-page application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们可以通过创建应用程序页面来继续前进。我们将学习 Next.js 中的路由是如何工作的，以及我们可以使用哪些渲染方法来充分利用 Next.js。然后，我们将学习如何配置每个页面的布局，使我们的应用程序看起来和感觉像一个单页应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Next.js routing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js 路由
- en: Next.js rendering strategies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js 渲染策略
- en: Next.js SEO
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js SEO
- en: Layouts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局
- en: Building the pages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建页面
- en: By the end of this chapter, we will learn how to create pages in Next.js and
    get a better understanding of selecting different rendering strategies depending
    on the needs of the application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将学习如何在 Next.js 中创建页面，并更好地了解根据应用程序的需求选择不同的渲染策略。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we get started, we need to set up the project. To be able to develop
    the project, you will need the following things installed on your computer:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要设置项目。为了能够开发项目，你需要在你的计算机上安装以下内容：
- en: '**Node.js** version 16 or above and **npm** version 8 or above.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js** 版本 16 或以上和 **npm** 版本 8 或以上。'
- en: 'There are multiple ways to install Node.js and npm. Here is a great article
    that goes into more detail:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Node.js 和 npm 有多种方法。这里有一篇很好的文章，详细介绍了更多细节：
- en: '[https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js)'
- en: '**VSCode** (optional) is currently the most popular editor/IDE for JavaScript/TypeScript,
    so we will be using it. It is open source, has great integration with TypeScript,
    and you can extend its features via extensions. It can be downloaded from [https://code.visualstudio.com/](https://code.visualstudio.com/).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VSCode**（可选）目前是 JavaScript/TypeScript 最受欢迎的编辑器/IDE，因此我们将使用它。它是开源的，与 TypeScript
    集成良好，并且你可以通过扩展来扩展其功能。可以从 [https://code.visualstudio.com/](https://code.visualstudio.com/)
    下载。'
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/React-Application-Architecture-for-Production](https://github.com/PacktPublishing/React-Application-Architecture-for-Production)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/React-Application-Architecture-for-Production](https://github.com/PacktPublishing/React-Application-Architecture-for-Production)
- en: 'The repository can be cloned locally with the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令在本地克隆存储库：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the repository is cloned, we need to install the application’s dependencies:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦克隆了存储库，我们需要安装应用程序的依赖项：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also need to provide the environment variables:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要提供环境变量：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the dependencies have been installed, we need to select the right stage
    of the code base that matches this chapter. We can do that by executing the following
    command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了依赖项，我们需要选择与本章匹配的代码库的正确阶段。我们可以通过执行以下命令来完成：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command will prompt us with a list of stages for each chapter:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将为我们显示每个章节的阶段列表：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the fourth chapter, so you can select `chapter-04-start` if you want
    to follow along, or `chapter-04` to see the final results of the chapter. Once
    the chapter has been selected, all files required to follow along with the chapter
    will appear.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第四章，所以如果你想跟随，可以选择 `chapter-04-start`，或者选择 `chapter-04` 来查看章节的最终结果。一旦选择了章节，所有必要的文件都会出现，以便跟随章节内容。
- en: To follow along with this chapter, you don’t need to make any changes to the
    code. You can use it as a reference to help get a better overview of the code
    base.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，你不需要对代码进行任何更改。你可以将其作为参考，以帮助更好地了解代码库。
- en: For more information about the setup details, check out the `README.md` file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置细节的更多信息，请查看 `README.md` 文件。
- en: Next.js routing
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Next.js 路由
- en: 'Next.js has a filesystem-based router where every page file represents a page.
    The pages are special files that exist in the `pages` folder, and they have the
    following structure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 有一个基于文件系统的路由器，其中每个页面文件代表一个页面。页面是存在于 `pages` 文件夹中的特殊文件，它们具有以下结构：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, only exporting the `page` component as a default export is required;
    this is the minimum requirement for a page to be defined. We will see what else
    can be exported from a page in a few moments.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，只需将`page`组件作为默认导出即可；这是定义页面所需的最小要求。我们将在稍后看到还可以从页面导出什么。
- en: Since the routing is filesystem-based, routes are determined by how the page
    files are named. For example, the page pointing to the root route should be defined
    in the `src/pages/index.tsx` file. If we want the about page, we can define it
    in `src/pages/about.tsx`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于路由是基于文件系统的，路由由页面文件的命名方式确定。例如，指向根路由的页面应在`src/pages/index.tsx`文件中定义。如果我们想定义关于页面，我们可以在`src/pages/about.tsx`中定义它。
- en: 'For any complex application with dynamic data, it is not enough to only create
    predefined pages. For example, let’s say we have a social network application
    where we can visit user profiles. The profiles should be loaded by the user’s
    ID. Since it would be too repetitive to create a page file for every user, we
    need to make the page dynamic as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何具有动态数据的复杂应用程序，仅创建预定义页面是不够的。例如，假设我们有一个社交网络应用程序，我们可以访问用户个人资料。个人资料应该通过用户的ID加载。由于为每个用户创建页面文件会过于重复，我们需要使页面动态化，如下所示：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To get the ID and load the data dynamically, we can define a generic user profile
    page in `pages/users/[userId].tsx`, where `userId` will be injected into the page
    dynamically. For example, going to `/users/123` will show the user profile page
    and pass the value of `123` as `userId` via the `query` property of the router.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取ID并动态加载数据，我们可以在`pages/users/[userId].tsx`中定义一个通用的用户个人资料页面，其中`userId`将动态注入到页面中。例如，访问`/users/123`将显示用户个人资料页面，并通过路由器的`query`属性将`123`的值作为`userId`传递。
- en: Next.js rendering strategies
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Next.js渲染策略
- en: 'Next.js supports four different rendering strategies:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js支持四种不同的渲染策略：
- en: '**Client-side rendering**: Where we can load the initial content on the server
    and then fetch additional data from the client.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端渲染**：在这里，我们可以在服务器上加载初始内容，然后从客户端获取附加数据。'
- en: '**Server-side rendering**: Where we can fetch the data on the server, inject
    it on the page, and return the page to the client with the provided data.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端渲染**：在这里，我们可以在服务器上获取数据，将其注入到页面中，并带有提供的数据将页面返回给客户端。'
- en: '**Static site generation**: Where static data is injected on the page and returned
    in the markup to the client.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态站点生成**：在这里，静态数据被注入到页面中，并以标记的形式返回给客户端。'
- en: '**Incremental static regeneration**: The middle ground between server-side
    rendering and static site generation. We can generate *x* number of pages statically,
    and then if a page that hasn’t been rendered and cached yet is requested, Next.js
    can render it on the server and cache it for future requests.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增量静态再生**：服务器端渲染和静态站点生成之间的折中方案。我们可以静态生成*x*个页面，然后如果请求尚未渲染和缓存的页面，Next.js可以在服务器上渲染它并为其未来的请求缓存它。'
- en: For our application, we will mainly focus on the first two methods, so let’s
    see how they work in the following examples.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将主要关注前两种方法，让我们看看以下示例中它们是如何工作的。
- en: Client-side rendering
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端渲染
- en: 'Considering the user profile page example, we can perform client-side rendering
    by writing the pages as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到用户个人资料页面示例，我们可以通过以下方式执行客户端渲染：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we can see, we are using `userId` to fetch the user data. In this example,
    we are doing this on the client side, which means that the server will initially
    render the following markup:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们正在使用`userId`来获取用户数据。在这个例子中，我们在客户端执行此操作，这意味着服务器最初将渲染以下标记：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Only after the data is fetched on the client will the user data be displayed:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在客户端获取数据后，用户数据才会显示：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is fine unless we care about SEO and the performance of the initial page
    load. Here we have to wait for the initial page to load and then for the user
    data to be fetched. This approach is perfectly valid for data that is not supposed
    to be public, such as admin dashboards.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这在关注SEO和初始页面加载性能的情况下是可行的。这里我们必须等待初始页面加载，然后获取用户数据。这种方法对于不应公开的数据，如管理仪表板，是完全有效的。
- en: However, for public pages, it is a good idea to enable the server to return
    the actual markup to the client to make it easier for search engines to crawl
    and index our pages. We can do that by server-side rendering the pages.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于公共页面，让服务器返回实际的标记给客户端是一个好主意，这样可以使搜索引擎更容易爬取和索引我们的页面。我们可以通过服务器端渲染页面来实现这一点。
- en: Server-side rendering
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: 'Let’s revisit the user profile page example, this time by rendering it on the
    server:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下用户个人资料页面的示例，这次是在服务器上渲染：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see here, besides the page component, the `page` file exports the
    `getServerSideProps` function, which is executed on the server. Its return value
    can contain `props`, which is passed to the component’s props.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，除了页面组件外，`page`文件还导出了`getServerSideProps`函数，该函数在服务器上执行。它的返回值可以包含`props`，这些`props`被传递到组件的属性中。
- en: 'The server will render the following markup:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将渲染以下标记：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The complete markup with the user data will be available on the initial render.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 包含用户数据的完整标记将在初始渲染时可用。
- en: Let’s keep in mind that there is no perfect rendering strategy for all use cases;
    therefore, we must balance the pros and cons and choose which one to use based
    on our needs. The great thing with Next.js is that it allows us to use different
    rendering strategies per page so we can combine them to fit the application’s
    needs in the best way.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住，没有一种完美的渲染策略适用于所有用例；因此，我们必须权衡利弊，并根据我们的需求选择使用哪种策略。Next.js的伟大之处在于它允许我们根据每个页面使用不同的渲染策略，这样我们就可以将它们结合起来，以最佳方式满足应用程序的需求。
- en: Next.js SEO
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Next.js SEO
- en: To improve the SEO of our pages, we should add some meta tags and the title
    of the page and inject them into the page. This can be done via the `Head` component
    provided by Next.js.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高我们页面的SEO，我们应该添加一些元标签和页面的标题，并将它们注入到页面中。这可以通过Next.js提供的`Head`组件来完成。
- en: 'For the application, we want to have a dedicated component where we can add
    the title of the pages. Let’s open the `src/components/seo/seo.tsx` file and add
    the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序，我们希望有一个专门的组件，我们可以添加页面的标题。让我们打开`src/components/seo/seo.tsx`文件并添加以下内容：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Head` component will inject its content into the `head` of the page. For
    now, the title will suffice, but it can be extended to add different meta tags
    if needed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Head`组件将把其内容注入到页面的`head`中。目前，标题就足够了，但如果需要，它可以扩展以添加不同的元标签。'
- en: Let’s add the `Seo` component to our landing page at `src/pages/index.tsx`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`src/pages/index.tsx`的着陆页中添加`Seo`组件。
- en: 'First, let’s import the component:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入组件：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And then, we can add it at the top of the component:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在组件的顶部添加它：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Layouts
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: When developing an application with multiple views or pages, we need to consider
    layout reusability.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发具有多个视图或页面的应用程序时，我们需要考虑布局的可重用性。
- en: 'Consider the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '![Figure 4.1 – Layouts example ](img/B17297_04_01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 布局示例](img/B17297_04_01.jpg)'
- en: Figure 4.1 – Layouts example
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 布局示例
- en: We can see that the navbar and the footer are the same on both pages and the
    main content comes between, so it is a good idea to make it reusable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在两个页面中，导航栏和页脚是相同的，而主要内容位于中间，因此使其可重用是一个好主意。
- en: 'There are two ways to add the `layout` component to pages:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 向页面添加`layout`组件有两种方式：
- en: Wrap the returned JSX of every page with the layout component
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个页面的返回 JSX 包裹在布局组件中
- en: Attach the layout to the page component and use it to wrap the entire component
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将布局附加到页面组件上，并使用它来包裹整个组件
- en: Wrapping JSX of every page with the layout component
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将每个页面的JSX包裹在布局组件中
- en: 'Let’s say we have a layout component that can wrap the content of each page:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个可以包裹每个页面内容的布局组件：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can add the `Layout` component to the page like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`Layout`组件添加到页面中，如下所示：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This way of handling layouts in Next.js applications is OK for some simple
    cases. However, it comes with some drawbacks, as described in the following list:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Next.js应用程序中处理布局的这种方式对于一些简单情况来说是可行的。然而，它也有一些缺点，如下列所示：
- en: If the `Layout` component tracks some internal state, it will lose it when the
    page changes
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Layout`组件跟踪一些内部状态，当页面更改时它将丢失这些状态
- en: The page will lose its scroll position
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面将丢失其滚动位置
- en: Anything we want to return before the final return, we also need to wrap with
    `Layout`
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想在最终返回之前返回的任何内容，也需要用`Layout`包裹
- en: For our application, we will use a better way to handle per-page layouts by
    attaching them to the page component. Let’s see it in action in the following
    section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将使用一种更好的方式来处理每个页面的布局，通过将其附加到页面组件上。让我们在以下部分中看看它是如何工作的。
- en: Attaching the layout to the page component and using it to wrap the entire component
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将布局附加到页面组件上，并使用它来包裹整个组件
- en: 'To make this work, we need to first update the `src/pages/_app.tsx` file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这起作用，我们首先需要更新`src/pages/_app.tsx`文件：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The page component expects the `getLayout` static property to be attached, which
    will be used to wrap the entire component when it is rendered in `_app.tsx`. Thanks
    to the reconciliation in React, all of the layout component states will persist
    when navigating between pages with the same layout.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 页面组件期望附加`getLayout`静态属性，它将在`_app.tsx`中渲染整个组件时被用来包装。多亏了React的协调，当在具有相同布局的页面之间导航时，所有布局组件的状态都将保持。
- en: We already have the layout components built and will just add them to our pages.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了布局组件，只需将它们添加到我们的页面中。
- en: Now that we have everything prepared, let’s build out our pages.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有东西，让我们构建我们的页面。
- en: Building the pages
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建页面
- en: 'Now that we are acquainted with how Next.js pages work and have prepared the
    `Seo` component and the layout setup, let’s implement the pages for the application.
    We will be implementing the following pages:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了Next.js页面的工作方式，并准备好了`Seo`组件和布局设置，让我们实现应用程序的页面。我们将实现以下页面：
- en: The public organization details page
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共组织详情页面
- en: The public job details page
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共工作详情页面
- en: The jobs page in the dashboard
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表板中的工作页面
- en: The job details page in the dashboard
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表板中的工作详情页面
- en: The create job page
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建工作页面
- en: 404 page
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 404页面
- en: The public organization details page
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共组织详情页面
- en: The public organization details page is the page where any user can see all
    details about a given organization and a list of its jobs. Since it is a public
    page, we want to render it on the server for better SEO.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 公共组织详情页面是任何用户都可以看到特定组织所有详情及其工作列表的页面。由于这是一个公开页面，我们希望它在服务器上渲染以获得更好的SEO。
- en: To create the page, let’s create the `src/pages/organizations/[organizationId]/index.tsx`
    file, where `organizationId` refers to the dynamic ID of the organization, which
    will be used to retrieve the given organization.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建页面，让我们创建`src/pages/organizations/[organizationId]/index.tsx`文件，其中`organizationId`指的是组织的动态ID，它将被用来检索指定的组织。
- en: 'Then, let’s import all dependencies:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们导入所有依赖项：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let’s implement the page component:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现页面组件：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The page component accepts `organization` and `jobs` as props. The props are
    passed to the page automatically by Next.js. What gets passed as props to a page
    component is determined by the return value of the `getServerSideProps` function,
    which is executed on the server and enables server-side rendering. We will see
    the implementation of it in a moment, but for now, let’s wire up the layout:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 页面组件接受`organization`和`jobs`作为props。props由Next.js自动传递给页面。传递给页面组件的props由`getServerSideProps`函数的返回值决定，该函数在服务器上执行并启用服务器端渲染。我们将在稍后看到它的实现，但现在，让我们连接布局：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is how we will use layouts for our pages based on the setup we just configured.
    The `getLayout` function will wrap the page component, and the layouts will be
    applied. We can also nest multiple layouts if required, so this approach is very
    flexible.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将根据我们刚刚配置的设置来使用布局的方式。`getLayout`函数将包装页面组件，并将应用布局。如果需要，我们还可以嵌套多个布局，因此这种方法非常灵活。
- en: 'Now, let’s export our page, which must be exported as `default`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们导出我们的页面，它必须以`default`导出：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And then, let’s implement the `getServerSideProps` function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们实现`getServerSideProps`函数：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We are extracting the organization’s ID from `params` and using this to fetch
    the organization and its jobs, and then we return it as props, which will be passed
    to the page component. The `getServerSideProps` function must be exported as a
    named export.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从`params`中提取组织的ID，并使用它来获取组织和其工作，然后我们将其作为props返回，这些props将被传递给页面组件。`getServerSideProps`函数必须作为命名导出导出。
- en: One more thing to note is that currently, we are loading data using the utility
    functions that load our testing data since we don’t have our API ready. In the
    following chapters, we will see how to create an actual API integration, but for
    now, this will allow us to build most of the UI for our pages.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的另一件事是，目前我们正在使用加载测试数据的实用函数来加载数据，因为我们还没有准备好API。在接下来的章节中，我们将看到如何创建实际的API集成，但到目前为止，这将使我们能够构建我们页面的大部分UI。
- en: 'Let’s now open `http://localhost:3000/organizations/amYXmIyT9mD9GyO6CCr`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在打开`http://localhost:3000/organizations/amYXmIyT9mD9GyO6CCr`：
- en: '![Figure 4.2 – The public organization details page ](img/B17297_04_02.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 公共组织详情页面](img/B17297_04_02.jpg)'
- en: Figure 4.2 – The public organization details page
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 公共组织详情页面
- en: And there is our organization details page! Organizations can use this link
    to share info about their organizations and the list of their job postings.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组织详细信息页面就在这里！组织可以使用此链接来分享他们组织的详细信息以及他们的职位发布列表。
- en: The page is rendered on the server, meaning the page’s content will be immediately
    available to the user.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 页面是在服务器上渲染的，这意味着页面的内容将立即对用户可用。
- en: To verify that, disable JavaScript in your browser and refresh the page.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这一点，请在浏览器中禁用JavaScript并刷新页面。
- en: You will notice that there is no difference. All the content is available even
    if JavaScript is disabled because all the markup is generated on the server and
    returned to the client.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到没有任何区别。即使禁用了JavaScript，所有内容都是可用的，因为所有标记都是在服务器上生成的并返回给客户端的。
- en: The public job details page
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共职位详细信息页面
- en: The public job details page is the page that shows all details about a given
    job and allows users to apply for it. It should also be available to all users,
    so we want to make it search-engine friendly. Therefore, we want to render its
    content on the server, just as we did with the organization page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 公共职位详细信息页面是显示特定职位所有详细信息并允许用户申请的页面。它应该对所有用户都可用，因此我们希望使其对搜索引擎友好。因此，我们希望像组织页面一样在服务器上渲染其内容。
- en: Let’s start by creating `src/pages/organizations/[organizationId]/jobs/[jobId].tsx`,
    where `jobId` refers to the ID of the job.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建 `src/pages/organizations/[organizationId]/jobs/[jobId].tsx` 文件，其中 `jobId`
    指的是职位的ID。
- en: 'Then, let’s import all required dependencies:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们导入所有必需的依赖项：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, let’s define our job page component:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们定义我们的职位页面组件：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we did with the organization page, we are loading the job and the organization
    via `getServerSideProps` and rendering the content on the server.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在组织页面中所做的那样，我们通过 `getServerSideProps` 加载职位和组织，并在服务器上渲染内容。
- en: 'Next, we can attach the layout of the page and export it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以附加页面布局并将其导出：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And finally, let’s create the `getServerSideProps` function and export it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建 `getServerSideProps` 函数并将其导出：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We are fetching the job and organization data, and we pass that as props to
    the page. The content is rendered on the server, so it will be available to the
    client immediately, just as it was on the organization details page.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在获取职位和组织数据，并将这些数据作为属性传递给页面。内容在服务器上渲染，因此它将立即对客户端可用，就像在组织详细信息页面上一样。
- en: 'To verify that everything works, let’s open `http://localhost:3000/organizations/amYXmIyT9mD9GyO6CCr/jobs/2LJ_sgmy_880G9WivH5Hf`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一切是否正常工作，让我们打开 `http://localhost:3000/organizations/amYXmIyT9mD9GyO6CCr/jobs/2LJ_sgmy_880G9WivH5Hf`：
- en: '![Figure 4.3 – The public job details page ](img/B17297_04_03.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 公共职位详细信息页面](img/B17297_04_03.jpg)'
- en: Figure 4.3 – The public job details page
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 公共职位详细信息页面
- en: It’s nice to have the content immediately available on the client, so why wouldn’t
    we render everything on the server?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，内容立即在客户端可用，那么为什么不在服务器上渲染一切呢？
- en: 'Server-side rendering has a couple of drawbacks:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染有几个缺点：
- en: More computing power for the server is required, which can affect server cost
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要更多的服务器计算能力，这可能会影响服务器成本
- en: Long `getServerSideProps` execution time can block the entire application
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长时间的 `getServerSideProps` 执行时间可能会阻塞整个应用程序
- en: That’s why we want to use it only where it makes sense, such as public pages
    that should be search-engine friendly, and where their content might change more
    frequently.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们只想在有意义的地方使用它，例如应该对搜索引擎友好的公共页面，以及它们的内容可能更频繁变化的地方。
- en: For the dashboard pages, we will render the initial loading state on the server
    and then load and render data on the client.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于仪表板页面，我们将在服务器上渲染初始加载状态，然后在客户端加载和渲染数据。
- en: The jobs page in the dashboard
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仪表板中的职位页面
- en: Let’s create the `src/pages/dashboard/jobs/index.tsx` file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建 `src/pages/dashboard/jobs/index.tsx` 文件。
- en: 'Then, we can import all required dependencies:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以导入所有必需的依赖项：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we can define and export the page component:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以定义并导出页面组件：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice how all data fetching happens in the component because we are doing it
    on the client.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到所有数据获取都是在组件中发生的，因为我们是在客户端进行的。
- en: 'To verify that everything works as expected, let’s open `http://localhost:3000/dashboard/jobs`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一切是否按预期工作，让我们打开 `http://localhost:3000/dashboard/jobs`：
- en: '![Figure 4.4 – The dashboard jobs page ](img/B17297_04_04.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 仪表板职位页面](img/B17297_04_04.jpg)'
- en: Figure 4.4 – The dashboard jobs page
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 仪表板职位页面
- en: And there it is! This page allows organization admins to have an overview of
    their organization’s jobs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这个页面允许组织管理员对其组织的职位有一个概览。
- en: The job details page in the dashboard
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仪表板中的工作详情页面
- en: The dashboard job details page will show all details about a given job in the
    dashboard.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板工作详情页面将在仪表板中显示给定工作的所有详细信息。
- en: To get started, let’s create `src/pages/dashboard/jobs/[jobId].tsx`, where `jobId`
    refers to the dynamic ID of the job.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们创建`src/pages/dashboard/jobs/[jobId].tsx`，其中`jobId`指的是工作的动态ID。
- en: 'Then we can import all dependencies:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以导入所有依赖项：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then let’s define and export our page component:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们定义并导出我们的页面组件：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To verify that everything works as expected, let’s open `http://localhost:3000/dashboard/jobs/wS6UeppUQoiXGTzAI6XrM`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一切按预期工作，让我们打开`http://localhost:3000/dashboard/jobs/wS6UeppUQoiXGTzAI6XrM`：
- en: '![Figure 4.5 – The dashboard job details page ](img/B17297_04_05.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 仪表板工作详情页面](img/B17297_04_05.jpg)'
- en: Figure 4.5 – The dashboard job details page
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 仪表板工作详情页面
- en: And this is our dashboard job details page. We can see basic details about a
    given job here.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的仪表板工作详情页面。我们可以在这里看到给定工作的基本详情。
- en: The create job page
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建工作页面
- en: The create job page is the page where we will render the form for creating jobs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建工作页面是我们将渲染创建工作表单的页面。
- en: To get started, let’s create `src/pages/dashboard/jobs/create.tsx`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们创建`src/pages/dashboard/jobs/create.tsx`。
- en: 'Then, let’s import the required dependencies:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们导入所需的依赖项：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we can create and export the page component:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建并导出页面组件：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To verify that everything works as expected, let’s open `http://localhost:3000/dashboard/jobs/create`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一切按预期工作，让我们打开`http://localhost:3000/dashboard/jobs/create`：
- en: '![Figure 4.6 – The dashboard create job page ](img/B17297_04_06.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 仪表板创建工作页面](img/B17297_04_06.jpg)'
- en: Figure 4.6 – The dashboard create job page
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 仪表板创建工作页面
- en: And there it is! For this chapter, we have just created the pages and will handle
    the data submission in the upcoming chapters.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这里！对于本章，我们刚刚创建了页面，将在接下来的章节中处理数据提交。
- en: 404 page
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 404页面
- en: If you tried to visit a page before we implemented it, you might have noticed
    a blank page. To let users know when they visit a non-existent page, we should
    create a custom 404 page.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在我们实现之前尝试访问一个页面，您可能已经注意到一个空白页面。为了使用户知道他们访问了一个不存在的页面，我们应该创建一个自定义的404页面。
- en: 'Let’s start by creating `src/pages/404.tsx` and add the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建`src/pages/404.tsx`并添加以下内容：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `404.tsx` file in the `pages` folder is a special page that will be displayed
    whenever a user visits an unknown page.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`pages`文件夹中的`404.tsx`文件是一个特殊页面，当用户访问未知页面时将显示。'
- en: 'To verify that everything works as expected, let’s visit `http://localhost:3000/non-existing-page`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一切按预期工作，让我们访问`http://localhost:3000/non-existing-page`：
- en: '![Figure 4.7 – 404 page ](img/B17297_04_07.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 404页面](img/B17297_04_07.jpg)'
- en: Figure 4.7 – 404 page
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 404页面
- en: And there it is! We have a nice interface to return to the application if we
    end up on a missing page.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这里！我们有一个漂亮的界面可以返回到应用程序，如果我们最终进入了一个缺失的页面。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, our focus has been on building the pages of our application.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的重点是构建我们应用程序的页面。
- en: We started by looking at how routing works in Next.js. Then we covered the rendering
    strategies we will be using. After that, we built the SEO component, which injects
    content into the head of the page.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查看Next.js中的路由是如何工作的。然后，我们介绍了我们将要使用的渲染策略。之后，我们构建了SEO组件，该组件将内容注入到页面的头部。
- en: We then configured the layout system for our pages. At the end of the chapter,
    we built the pages for our application. To build the content for our pages, we
    used test data that was predefined. We used test data to render content on the
    pages, but we still need to make real API calls.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为我们的页面配置了布局系统。在本章的结尾，我们为我们的应用程序构建了页面。为了构建页面的内容，我们使用了预定义的测试数据。我们使用测试数据在页面上渲染内容，但我们仍然需要执行真实的API调用。
- en: In the next chapter, we will learn how to mock the API endpoints, which we can
    use during development to make HTTP requests and fetch data as if we were consuming
    the real API.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何模拟API端点，我们可以在开发期间使用它们来执行HTTP请求并获取数据，就像我们正在消费真实的API一样。
