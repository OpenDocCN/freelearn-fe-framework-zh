- en: Chapter 4. Stateful Components and Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will exploit the React states and events in detail. This
    chapter will cover the components that have a state, the practices to communicate
    between them, and how to respond to users input/events in order to have the UI
    reflect this state. We will develop a web page where we can update the name of
    our liked pages from Facebook. This also covers how the state changes your React
    UI having enhanced performance using the virtual DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: React states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties versus states in ReactJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's glance through the differences between props and states in React.
  prefs: []
  type: TYPE_NORMAL
- en: '**Properties** are declared when React components are created, while **states**
    are declared within the component definitions. Thus, during the component initialization
    phase props are declared.'
  prefs: []
  type: TYPE_NORMAL
- en: In most of the scenarios, React components take data and pass in the form of
    props. In the other cases, when you are required to take user input to have a
    server request, states are used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(this.props)` is used to access parameters passed from the parent component,
    while `(this.state)` is used to manage dynamic data. State should be considered
    private data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the state property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we explored React properties (**props**). Just as components
    can have properties, they can also have **states**. States are primarily set to
    those components where it is necessary to change, for example if the component
    has to be updated or replaced in future. Thus, it is not mandatory to have a state
    for the entire component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Components can be both stateless and stateful:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stateless components** are those where only props are present, but no state
    is defined. Thus, there will no change in these prop values for these components
    within the component life cycle. The only source of static data should be presented
    to the component instance via the props. Thus, props are immutable data for a
    React component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateful components:** Stateless components, are meant to represent any React
    component declared as a function that has no state and returns the same markup
    given the same props. As the name implies, stateful components are those where
    both props and states are declared. Generally, any kind of such data-change communication
    is done via the state change `[setState(data, callback)]`. The updated state is
    then rendered in the UI. In case of interactive apps `[form submission etc]` where
    the data changes continuously, it''s necessary to have such stateful components.
    Otherwise, for non-interactive apps, it''s advisable to have fewer stateful components,
    because they increase complexity and redundancy in the app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing a state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Initialization of a component state is done by the method `getInitialState()`,
    which returns an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `getInitialState()` method is invoked once before the component is mounted.
    The return value will be used as the initial value of `this.state`
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For all the following examples, we have the same content in the `index.html`
    file. Thus, we can use the same `index.html` file and only change the contents
    of the corresponding JavaScript file based on the topic being discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a React stateful component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `getInitialState`() method initiates the component with the values (name:
    `Doel`, id: `1`), during the first render cycle. These values are persisted until
    the state values are changed and can be collected by running `{this.state.<VALUE>}`.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting a state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data change in React is commonly done by invoking the method `setState(data,
    callback)`, which together with the data of `this.state` re-renders the component.
    If you provide an optional callback argument, React will call it when executing
    this method, although usually it's not required as React keeps the UI updated.
  prefs: []
  type: TYPE_NORMAL
- en: A state is set from inside the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how the state is updated/set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what we did:'
  prefs: []
  type: TYPE_NORMAL
- en: Changed values in states are reflected only after the component is mounted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting of the component happens when it has been passed to `React.render(<Component
    />)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our event handler `onClick` calls the `handleClick()` function, which is internally
    calling `this.state`(). So when the `onClick` event is initialized on the name
    `doel`, it will change its value from `doel` to `doel sengupta`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the React documentation ([http://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html](http://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html)),
    Facebook recommends:'
  prefs: []
  type: TYPE_NORMAL
- en: Have many stateless components to render data and a stateful component as parent,
    which passes its states to the stateless children via props.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essentially, the function of the stateful component is to contain the interaction
    logic and the stateless components render the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state of a component has the data that is manipulated by the component's
    event handlers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should keep minimal data in `this.state` and perform all the computations
    within the `render` method. This reduces redundancy or storage of computed values
    and ensures more reliability on React's computational abilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React components should be built within `render`() based on the underlying props
    and states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Props should be essentially used as the source of truth. Any data that can be
    changed via the user's input or otherwise, should be stored in states.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing a state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the code for `replace_state.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `replaceState`() method is used when existing values are to be cleared and
    new ones have to be added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the app looks like when it is run for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Replacing a state](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: App screenshot during initial page load
  prefs: []
  type: TYPE_NORMAL
- en: 'After the page initially loads, the value of the `first_name` attribute is
    `michael`, but when the `onClick` function is called the value changes to `undefined`.
    The component states with the attributes `first_name` and `last_name` have been
    replaced with only `last_name` when `replaceState`() is called. The following
    screenshot illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Replacing a state](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Re-rendering the component after replaceState() is called
  prefs: []
  type: TYPE_NORMAL
- en: A React state example using an interactive form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we first run the code we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A React state example using an interactive form](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: User interactive form
  prefs: []
  type: TYPE_NORMAL
- en: 'After typing in the textbox, the value below automatically changes, as seen
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A React state example using an interactive form](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Form data updated using this.setState()
  prefs: []
  type: TYPE_NORMAL
- en: Let's now dig deeper into how events flow within a React ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React uses `SyntheticEvent`, which is a cross-browser wrapper around the browser's
    native event. So all the event handlers in the react applications will be passed
    instances of `SyntheticEvent`. React's event ecosystem has the same interface
    as any of the browser's native events with the advantage that it works identically
    in all the browsers and provides `stopPropagation`() and `preventDefault`() too.
  prefs: []
  type: TYPE_NORMAL
- en: 'If React is installed as an NPM module, then these `SyntheticEvent`-related
    files can be found in the following location within your app: `app/node_modules/react/lib`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All these events comply with the W3C standard. The main event flow happens
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dispatching the event : `@param {object} dispatchConfig`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Marker identifying the event target: `@param {object} dispatchMarker`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Native event: `@param {object} nativeEvent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way React uses this event delegation is by listening to the nodes that have
    listeners. Depending on the event handlers on the particular node, the synthetic
    event system of React implements its own bubbling.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the event names in the Synthetic Event system are as follows. Refer
    to the Facebook documentation for the complete list of the listed registered events.
  prefs: []
  type: TYPE_NORMAL
- en: Form events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Event names for Form events are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onChange`, `onInput`, `onSubmit`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about the `onChange` event, refer to Forms ([https://facebook.github.io/react/docs/forms.html](https://facebook.github.io/react/docs/forms.html)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Mouse events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Event names for Mouse events are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onClick`, `onContextMenu`, `onDoubleClick`, `onDrag`, `onDragEnd`, `onDragEnter`,
    `onDragExit`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDragLeave`, `onDragOver`, `onDragStart`, `onDrop`, `onMouseDown`, `onMouseEnter`,
    `onMouseLeave`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onMouseMove`, `onMouseOut,` `onMouseOver`, `onMouseUp`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's show an example of some of the different events called by the `SyntheticEvent`
    system on a React component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the JavaScript file, we have the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The following code displays a textbox in the browser. As we type in the box,
    the corresponding event type prints out below. Since we are updating the state
    with `event.type`, the corresponding event is shown below as we type in the box.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Mouse events](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: User interactive form
  prefs: []
  type: TYPE_NORMAL
- en: nativeEvent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the source code for the corresponding HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: From the following screenshots, we can see that as we resize the browser window,
    the width and height values change. The first image shows the full size [1311/681]
    of the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![nativeEvent](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: App showing browser's native attributes
  prefs: []
  type: TYPE_NORMAL
- en: The second image from the preceding application code shows that after resizing
    the browser window, the pixel values changed to 497/219.
  prefs: []
  type: TYPE_NORMAL
- en: '![nativeEvent](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Native DOM attributes changing with browser window changes
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'According to the Facebook developer team ([http://facebook.github.io/react/tips/dom-event-listeners.html](http://facebook.github.io/react/tips/dom-event-listeners.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '*"The event callbacks which are declared in a React app, are all bound to the
    React components. These event callbacks are not tied to the original elements.
    By autobinding, these methods are automatically bounded to the current element."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Also, every `SyntheticEvent` object has the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean bubbles`: All event handlers are triggered in the event bubbling phases;
    it can be `true`/`false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean cancelable`: Whether the SyntheticEvent object can be cancelled or
    not (true/false)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOMEventTarget currentTarget`: As per W3C recommendations, the `currentTarget`
    event property returns the element whose event listeners triggered the event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is particularly useful during capturing and bubbling.
  prefs: []
  type: TYPE_NORMAL
- en: The `currentTarget` property always refers to the element whose event listener
    triggered the event, as opposed to the `target` property, which returns the element
    that triggered the event.
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean defaultPrevented`: Whether the `SyntheticEvent` object can be prevented
    by default or not (true/false)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number eventPhase`: The `eventPhase` event property returns a number that
    indicates which phase of the event flow is currently being evaluated (see: [https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase](https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The number is represented by four constants:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0` – `NONE`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`1` – `CAPTURING_PHASE`: The event flow is within the capturing phase.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2` – `AT_TARGET`: The event flow is in the target phase, that is, it is being
    evaluated at the event target.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3` – `BUBBLING_PHASE`: The event flow is in the bubbling phase.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`boolean isTrusted`: As per JS recommendations, in Chrome, Firefox, and Opera,
    the event is trusted (returns true) if it is invoked by the user, and not trusted
    if it is invoked by a script ((returns false)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOMEvent nativeEvent`: `nativeEvent` is a kind of `DOMEvent`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void preventDefault()`: The `preventDefault()` method does cancel the event
    if it is cancellable (it cancels the default action of the method) but it does
    not prevent further propagation of an event through the DOM. The return type of
    `preventDefault()` in React is void.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void stopPropagation()`: `stopPropagation` is called to prevent events from
    bubbling up to their parent elements, which thereby prevents any parent event
    handlers from being invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isDefaultPrevented()`: `isDefaultPrevented` is used to check whether
    the `preventDefault()` method is called (true) or not (false).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isPropagationStopped()`: `isPropagationStopped` is used to check whether
    the `stopPropagation()` method is called (true) or not (false).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOMEventTarget target`: It is used to identify the target of the `SyntheticEvent`
    object declared, which returns the element that triggered the event. The return
    type is in `DOMEventTarget`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number timeStamp`: This is used to identify the timestamp of the `SyntheticEvent`
    object declared. The return type is in the form number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string type`: This is used to identify a kind of `SyntheticEvent` object declared.
    The return type is in the form string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: As of v0.14, returning false from an event handler will no longer stop
    event propagation. Instead, `e.stopPropagation()` or `e.preventDefault()` should
    be triggered manually, as appropriate.'
  prefs: []
  type: TYPE_NORMAL
- en: Event pooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **pool** is a place where events/objects are kept, so that they can be reused
    at a later stage, after being garbage collected. In the React ecosystem, the event
    objects (`SyntheticEvent`) that are received in callbacks are pooled. As mentioned
    before, after the event callback has been called, `SyntheticEvent` will be put
    back in the pool with empty attributes, which thereby reduces the pressure on
    the Garbage Collector. Next are some key highlights for event pooling as mentioned
    in the Facebook documentation as well.
  prefs: []
  type: TYPE_NORMAL
- en: The `SyntheticEvent` system in React is pooled.
  prefs: []
  type: TYPE_NORMAL
- en: '*"This means that the `SyntheticEvent` object will be reused.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*All properties will be nullified after the event callback has been invoked.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This is for performance reasons.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We cannot access the event in an asynchronous way.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In order to access the event properties in an asynchronous way, we should
    call `event.persist`() on the event, which will remove the synthetic event from
    the pool and allow references to the event to be retained by user code."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Supported events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React normalizes events so that they have consistent properties across different
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: According to the Facebook documentation ([http://facebook.github.io/react/docs/events.html](http://facebook.github.io/react/docs/events.html))
  prefs: []
  type: TYPE_NORMAL
- en: '*"The event handlers of the Synthetic Events of the React ecosystem are triggered
    by an event in the bubbling phase."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we have covered what a state is in the React component and how event
    handling happens, let's see how we can use these in the app that we were building
    in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until the last chapter, we were able to display the likes of a user, using
    the Graph-API and Facebook login into our app. Based on its props, each component
    has rendered itself once. Props are immutable: they are passed from the parent
    and are *owned* by the parent. Now, we will be able to update the name of the
    liked component `onClick` on any part of the particular `div` where the React
    component resides.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `index.html` code snippet for the following example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is within the `js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted part shows the changes we made, in order to save the state.
  prefs: []
  type: TYPE_NORMAL
- en: '`getInitialState()`: is declared by initializing the value of the liked data
    name''s value from the props data. `getInitialState()` executes exactly once during
    the lifecycle of the component and sets up the initial state of the component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The reason for the *mutable state* (the state that can be changed) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **mutable state** is introduced to the component (`UserLikedItem`). In order
    to implement interactions, `this.state` can be changed by calling `this.setState()`
    and is private to the component. When the state updates, the component (`UserLikedItem`)
    re-renders itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render()` methods are written by the Facebook developer team, declaratively
    as functions of `this.props` and `this.state`. They ensure that the framework
    guarantees the UI is always consistent with the inputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a perfect example of how data flows between components in the React
    ecosystem. The property (data) is passed from the React component `UserLikesList`
    to another component, `UserLikedItem`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Supported events](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: App fetching user's liked pages from Facebook
  prefs: []
  type: TYPE_NORMAL
- en: React attaches event handlers to components using a camelCase naming convention.
    We attach an `onClick` handler to the `div` element, so that whenever a user clicks
    at any portion of the image or the image name or category, it will change to **I
    liked it**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Supported events](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: React this.setState() replacing liked item's name
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to Facebook's Reconciliation documentation ([https://facebook.github.io/react/docs/reconciliation.html](https://facebook.github.io/react/docs/reconciliation.html))
  prefs: []
  type: TYPE_NORMAL
- en: '*"React''s key design decision is to make the API seem like it re-renders the
    whole app on every update."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Thus, whenever the `setState`() method is called on an object, that particular
    node is marked. At the end of the event loop, all the nodes are re-rendered where
    the `setState`() method is called.
  prefs: []
  type: TYPE_NORMAL
- en: React is fast because it never talks to the DOM directly. It maintains an in-memory
    representation of the actual DOM. Whenever the `render()` method is called, it
    returns a mapping of the actual DOM. React can detect (using a diff algorithm)
    changes in the mapped DOM compared to the in-memory representation. It then re-renders
    the changes and updates the UI likewise.
  prefs: []
  type: TYPE_NORMAL
- en: The event ecosystem in React is implemented by a full synthetic event system
    (`SyntheticEvent()`). Cross-browser efficiency is achieved as all the events bubble
    up consistently.
  prefs: []
  type: TYPE_NORMAL
- en: In the current chapter, we have explored the stateful components in React and
    how the synthetic event system is handled in React applications. States are used
    for those properties in React components that are mutable. In the next chapter,
    we will explore the component lifecycle and how these lifecycle methods interact
    with various events and the DOM as a whole.
  prefs: []
  type: TYPE_NORMAL
