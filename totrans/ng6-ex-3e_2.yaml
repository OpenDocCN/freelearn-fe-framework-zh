- en: Building Our First App – 7 Minute Workout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的第一个应用 – 7 分钟健身
- en: I hope that the first chapter was intriguing enough and that you want to learn
    more about Angular—believe me, we have just scratched the surface! The framework
    has a lot to offer, and together with TypeScript, it strives to make frontend
    development more organized and hence manageable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望第一章足够吸引人，让你想要了解更多关于 Angular 的知识——相信我，我们只是触及了表面！这个框架有很多东西可以提供，与 TypeScript
    一起，它致力于使前端开发更加有组织，因此更容易管理。
- en: Keeping up with the theme of this book, we will be building a new app in Angular,
    and in the process, become more familiar with the framework. This app will also
    help us explore some new capabilities of Angular.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本书的主题，我们将使用 Angular 构建一个新的应用，在这个过程中，我们将更加熟悉这个框架。这个应用也将帮助我们探索 Angular 的一些新功能。
- en: 'The topics that we will cover in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: '**7 Minute Workout problem description**: We detail the functionality of the
    app that we build in this chapter.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**7 分钟健身问题描述**：我们详细说明了本章中构建的应用的功能。'
- en: '**Code organization**: For our first real app, we will try to explain how to
    organize code, specifically Angular code.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码组织**：对于我们的第一个真实应用，我们将尝试解释如何组织代码，特别是 Angular 代码。'
- en: '**Designing the model**: One of the building blocks of our app is its model.
    We design the app model based on the app''s requirements.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计模型**：我们应用的一个构建块是其模型。我们根据应用的需求设计应用模型。'
- en: '**Understanding the data binding infrastructure**: While building the *7 Minute
    Workout* view, we will look at the data binding capabilities of the framework,
    which include *property*, *attribute*, *class*, *style*, and *event* bindings.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解数据绑定基础设施**：在构建 *7 分钟健身* 视图时，我们将查看框架的数据绑定功能，包括 *属性*、*属性*、*类*、*样式* 和 *事件*
    绑定。'
- en: '**Exploring the Angular platform directives**: Some of the directives that
    we will cover are `ngFor`, `ngIf`, `ngClass`, `ngStyle`, and `ngSwitch`.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**探索 Angular 平台指令**：我们将涵盖的一些指令包括 `ngFor`、`ngIf`、`ngClass`、`ngStyle` 和 `ngSwitch`。'
- en: '**Cross-component communication with input properties**: As we build nested
    components, we learn how input properties can be used to pass data from the parent
    to its child components.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用输入属性进行跨组件通信**：当我们构建嵌套组件时，我们学习如何使用输入属性将数据从父组件传递到其子组件。'
- en: '**Cross-component communication with events**: Angular components can subscribe
    to and raise events. We get introduced to event binding support in Angular.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用事件进行跨组件通信**：Angular 组件可以订阅和触发事件。我们了解了 Angular 中的事件绑定支持。'
- en: '**Angular pipes**: Angular pipes provide a mechanism to format view content.
    We explore some standard Angular pipes and build our own pipe to support conversions
    from seconds to hh:mm:ss.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular 管道**：Angular 管道提供了一种格式化视图内容的方式。我们探讨了几个标准的 Angular 管道，并构建了自己的管道以支持秒到
    hh:mm:ss 的转换。'
- en: Let's get started! The first thing we will do is to define our *7 Minute Workout*
    app.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！我们首先要做的是定义我们的 *7 分钟健身* 应用。
- en: What is 7 Minute Workout?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 7 分钟健身？
- en: We want everyone reading this book to be physically fit. Therefore, this book
    should serve a dual purpose; it should not only stimulate your grey matter, but
    also urge you to look after your physical fitness. What better way to do it than
    to build an app that targets physical fitness!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望所有阅读这本书的人都身体健康。因此，这本书应该具有双重目的；它不仅应该刺激你的大脑，还应该敦促你关注你的身体健康。还有什么比构建一个针对身体健康的应用更好的方式呢！
- en: '*7 Minute Workout* is an exercise/workout app that requires us to perform a
    set of 12 exercises in quick succession within the seven-minute time span. *7
    Minute Workout* has become quite popular due to its bite-sized length and great
    benefits. We cannot confirm or refute the claims, but doing any form of strenuous
    physical activity is better than doing nothing at all. If you are interested to
    know more about the workout, then check out [http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/](http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*7 分钟健身* 是一个锻炼/健身应用，要求我们在七分钟的时间范围内快速连续完成一组 12 个练习。由于其短小精悍的长度和巨大的益处，*7 分钟健身*
    已经变得相当受欢迎。我们无法证实或反驳这些说法，但进行任何形式的剧烈体育活动都比什么都不做要好。如果你想了解更多关于这个健身的信息，那么请查看 [http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/](http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/)。'
- en: The technicalities of the app include performing a set of 12 exercises, dedicating
    30 seconds for each of the exercises. This is followed by a brief rest period
    before starting the next exercise. For the app that we are building, we will be
    taking rest periods of 10 seconds each. So, the total duration comes out at a
    little more than seven minutes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用的技术细节包括执行一组12个练习，每个练习分配30秒。在开始下一个练习之前，会有一个简短的休息期。对于我们要构建的应用，我们将休息10秒。因此，总时长略超过七分钟。
- en: 'At the end of the chapter, we will have the *7 Minute Workout* app ready, which
    will look something like the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将拥有一个准备好的**7分钟健身**应用，其外观可能如下所示：
- en: '![](img/00011.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.jpeg)'
- en: The 7 Minute Workout app
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 7分钟健身应用
- en: Downloading the code base
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载代码库
- en: The code for this app can be downloaded from the GitHub site ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))
    dedicated to this book. Since we are building the app incrementally, we have created
    **multiple checkpoints** that map to **GitHub branches** such as `checkpoint2.1`,
    `checkpoint2.2`, and so on. During the narration, we will highlight the branch
    for reference. These branches will contain the work done on the app up until that
    point in time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用的代码可以从专门为此书建立的GitHub网站([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))下载。由于我们是逐步构建应用，我们创建了多个**检查点**，这些检查点对应于**GitHub分支**，如`checkpoint2.1`、`checkpoint2.2`等。在叙述过程中，我们将突出显示这些分支以供参考。这些分支将包含到那个时间点为止在应用上所做的所有工作。
- en: The *7 Minute Workout* code is available in the repository folder named `trainer`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**7分钟健身**的代码位于名为`trainer`的仓库文件夹中。'
- en: So, let's get started!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Setting up the build
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置构建环境
- en: Remember that we are building on a modern platform for which browsers still
    lack support. Therefore, directly referencing script files in HTML is out of the
    question (while common, it's a dated approach that we should avoid anyway). Browsers
    do not understand **TypeScript**; this implies that there has to be a process
    that converts code written in TypeScript into standard **JavaScript (ES5)**. Hence,
    having a build set up for any Angular app becomes imperative. And thanks to the
    growing popularity of Angular, we are never short of options.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们正在构建一个现代平台，而浏览器对此仍缺乏支持。因此，直接在HTML中引用脚本文件是不可能的（虽然常见，但这是一个过时的方法，我们本应避免）。浏览器不理解**TypeScript**；这意味着必须有一个将用TypeScript编写的代码转换为标准**JavaScript
    (ES5**)的过程。因此，为任何Angular应用设置构建环境变得至关重要。而且，由于Angular日益流行，我们从不缺乏选择。
- en: If you are a frontend developer working on the web stack, you cannot avoid **Node.js**.
    This is the most widely used platform for web/JavaScript development. So, no prizes
    for guessing that most of the Angular build solutions out there are supported
    by Node. Packages such as **Grunt**, **Gulp**, **JSPM**, and **webpack** are the
    most common building blocks for any build system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名从事Web栈前端开发的开发者，你无法避免**Node.js**。这是最广泛使用的Web/JavaScript开发平台。因此，无需猜测，大多数Angular构建解决方案都由Node支持。例如**Grunt**、**Gulp**、**JSPM**和**webpack**是任何构建系统的最常见构建模块。
- en: Since we too are building on the Node.js platform, install Node.js before starting.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们也是在Node.js平台上进行开发，因此在开始之前请先安装Node.js。
- en: For this book and this sample app, we endorse **Angular CLI** ([http://bit.ly/ng6be-angular-cli](http://bit.ly/ng6be-angular-cli)).
    A command line tool, it has a build system and a scaffolding tool that hugely
    simplifies Angular's development workflow. It is popular, easy to set up, easy
    to manage, and supports almost everything that a modern build system should have.
    More about it later.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书和这个示例应用，我们推荐**Angular CLI**([http://bit.ly/ng6be-angular-cli](http://bit.ly/ng6be-angular-cli))。这是一个命令行工具，它具有构建系统和脚手架工具，极大地简化了Angular的开发工作流程。它很受欢迎，易于设置，易于管理，并支持现代构建系统应该拥有的几乎所有功能。关于它的更多信息将在后面介绍。
- en: 'As with any mature framework, Angular CLI is not the only option out there
    on the web. Some of the notable starter sites plus build setups created by the
    community are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何成熟的框架一样，Angular CLI并不是网络上的唯一选择。社区创建的一些值得注意的起始网站和构建设置如下：
- en: '| **Start site** | **Location** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **起始网站** | **位置** |'
- en: '| `angular2-webpack-starter` | [http://bit.ly/ng2webpack](http://bit.ly/ng2webpack)
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `angular2-webpack-starter` | [http://bit.ly/ng2webpack](http://bit.ly/ng2webpack)
    |'
- en: '| `angular-seed` | [https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed)
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `angular-seed` | [https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed)
    |'
- en: 'Let''s start with installing Angular CLI. On the command line, type the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装 Angular CLI 开始。在命令行中，输入以下内容：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once installed, Angular CLI adds a new command `ng` to our execution environment.
    To create a new Angular project from the command line, run the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，Angular CLI 将在我们的执行环境中添加一个新的命令 `ng`。要从命令行创建一个新的 Angular 项目，请运行以下命令：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This generates a folder structure with a bunch of files, a boilerplate Angular
    application, and a preconfigured build system. To run the application from the
    command line, execute the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个包含大量文件、一个模板化的 Angular 应用和一个预配置的构建系统的文件夹结构。要从命令行运行应用程序，请执行以下操作：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And you can see a basic Angular application in action!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到一个基本的 Angular 应用正在运行！
- en: 'For our *7 Minute Workout* app, instead of starting from scratch, we are going
    to start from a version that is based on the project structure generated by `ng
    new` with minor modification. Start with the following steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 *7 分钟健身* 应用，我们不会从头开始，而是从一个基于 `ng new` 生成的项目结构稍作修改的版本开始。以下是一些步骤：
- en: Curious about what the default project includes? Go ahead and run `ng new PROJECT-NAME`.
    Look at the generated content structure and the Angular CLI documentation to get
    an idea of what's part of a default setup.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇默认项目包含什么吗？运行 `ng new 项目名称`。查看生成的内容结构和 Angular CLI 文档，以了解默认设置中包含的内容。
- en: 'Download the base version of this app from [http://bit.ly/ngbe-base](http://bit.ly/ngbe-base)
    and unzip it to a location on your machine. If you are familiar with how Git works,
    you can just clone the repository and check out the`base` branch:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [http://bit.ly/ngbe-base](http://bit.ly/ngbe-base) 下载此应用的基版，并将其解压到您的机器上的某个位置。如果您熟悉
    Git 的工作方式，您可以直接克隆存储库并切换到 `base` 分支：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code serves as the starting point for our app.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是我们应用的开端。
- en: Navigate to the `trainer` folder from the command line and execute the command
    `npm install` from the command line to install the **package dependencies** for
    our application.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令行导航到 `trainer` 文件夹，并执行命令 `npm install` 以安装我们应用的 **包依赖**。
- en: '**Packages** in the Node.js world are third-party libraries (such as Angular
    for our app) that are either used by the app or support the app''s building process.
    **npm** is a command-line tool for pulling these packages from a remote repository.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 世界中，**包**是用于应用或支持应用构建过程的第三方库（例如，我们的应用中使用 Angular）。**npm** 是一个用于从远程仓库拉取这些包的命令行工具。
- en: 'Once npm pulls the app dependencies from the npm store, we are ready to build
    and run the application. From the command line, enter the following command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 npm 从 npm 存储库中拉取了应用依赖，我们就可以构建和运行应用了。从命令行输入以下命令：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This compiles and runs the app. If the build process goes fine, the default
    browser window/tab will open with a rudimentary app page (`http://localhost:4200/`).
    We are all set to begin developing our app in Angular!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这会编译并运行应用。如果构建过程顺利，默认的浏览器窗口/标签页将打开一个基本的网页（`http://localhost:4200/`）。我们现在可以开始使用
    Angular 开发我们的应用了！
- en: But before we do that, it would be interesting to know a bit more about Angular
    CLI and the customization that we have done on the default project template that
    Angular CLI generates.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们这样做之前，了解一些关于 Angular CLI 和我们对默认项目模板所做的自定义将很有趣。
- en: Angular CLI
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular CLI
- en: '**Angular CLI** was created with the aim of standardizing and simplifying the development
    and deployment workflow for Angular apps. As the documentation suggests:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular CLI** 的创建目的是为了标准化和简化 Angular 应用的开发和部署工作流程。正如文档所建议的：'
- en: '"The Angular CLI makes it easy to create an application that already works,
    right out of the box. It already follows our best practices!"'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '"Angular CLI 使得创建一个即开即用的应用变得简单。它已经遵循我们的最佳实践！"'
- en: 'It incorporates:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含：
- en: A build system based on **webpack**
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 **webpack** 的构建系统
- en: A **scaffolding tool** to generate all standard Angular artifacts including
    modules, directives, components, and pipes
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于生成所有标准 Angular 艺术品的 **脚手架工具**，包括模块、指令、组件和管道
- en: Adherence to **Angular style guide** ([http://bit.ly/ngbe-styleguide](http://bit.ly/ngbe-styleguide)),
    making sure we use community-driven standards for projects of every shape and
    size
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循 **Angular 风格指南** ([http://bit.ly/ngbe-styleguide](http://bit.ly/ngbe-styleguide))，确保我们使用社区驱动的标准来处理各种规模的项目
- en: You may have never heard the term style guide, or may not understand its significance.
    A style guide in any technology is a set of guidelines that help us organize and
    write code that is easy to develop, maintain, and extend. To understand and appreciate
    Angular's own style guide, some familiarity with the framework itself is desirable,
    and we have started that journey.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能从未听说过风格指南这个术语，或者可能不理解它的意义。在任何技术中，风格指南都是一系列指导原则，帮助我们组织编写易于开发、维护和扩展的代码。要理解和欣赏Angular自己的风格指南，对框架本身有一定的熟悉度是可取的，我们已经开始了这段旅程。
- en: A targeted **linter;** Angular CLI integrates with **codelyzer** ([http://bit.ly/ngbe-codelyzer](http://bit.ly/ngbe-codelyzer)),
    a **static code analysis tool** that validates our Angular code against a set
    of rules to make sure that the code we write adheres to standards laid down in
    the Angular style guide
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**目标式代码检查器**；Angular CLI集成了**codelyzer**([http://bit.ly/ngbe-codelyzer](http://bit.ly/ngbe-codelyzer))，这是一个**静态代码分析工具**，它将我们的Angular代码与一系列规则进行验证，以确保我们编写的代码遵循Angular风格指南中规定的标准。
- en: Preconfigured **unit** and **end-to-end** (**e2e**) test framework
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预配置的**单元测试**和**端到端测试**（**e2e**）框架
- en: And much more!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以及更多！
- en: Imagine if we had to do all this manually! The steep learning curve would have
    quickly overwhelm us. Thankfully, we don't have to deal with it, Angular CLI does
    it for us.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果我们必须手动完成所有这些工作！陡峭的学习曲线会很快让我们感到不知所措。幸运的是，我们不必处理它，Angular CLI会为我们处理。
- en: The Angular CLI build setup is based on webpack, but it does not expose the
    underlying webpack configuration; this is intentional. The Angular team wanted
    to shield developers from the complexities and internal workings of webpack. The
    ultimate aim of Angular CLI is to eliminate any entry level barriers and make
    setting up and running Angular code simple.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI的构建设置基于webpack，但它不暴露底层的webpack配置；这是故意的。Angular团队希望保护开发者免受webpack的复杂性和内部工作原理的影响。Angular
    CLI的最终目标是消除任何入门级障碍，并使设置和运行Angular代码变得简单。
- en: It doesn't mean Angular CLI is not configurable. There is a *config file* (`angular.json`)
    that we can use to alter the build setup. We will not cover that here. Check the
    configuration file for 7 Minute Workout and read the documentation here: [http://bit.ly/ng6be-angular-cli-config](http://bit.ly/ng6be-angular-cli-config).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着Angular CLI不可配置。有一个*配置文件*（`angular.json`），我们可以用它来修改构建设置。我们在这里不会介绍这个。请检查7分钟健身计划的配置文件，并在此处阅读文档：[http://bit.ly/ng6be-angular-cli-config](http://bit.ly/ng6be-angular-cli-config)。
- en: 'The tweaks that we have done to the default generated project template are:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对默认生成的项目模板所做的调整包括：
- en: Referenced Bootstrap CSS in the `style.css` file.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`style.css`文件中引用了Bootstrap CSS。
- en: Upgraded some npm library versions.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级了一些npm库的版本。
- en: Changed the prefix configuration for generated code to use `abe` (short for
    Angular By Example) from `app`. With this change, all our components and directive
    selectors will be prefixed by `abe` instead of `app`. Check `app.component.ts`;
    the `selector` is `abe-root` instead of `app-root`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将生成的代码的前缀配置更改为使用`abe`（代表Angular By Example），而不是`app`。这个更改意味着所有我们的组件和指令选择器都将使用`abe`作为前缀，而不是`app`。检查`app.component.ts`；选择器是`abe-root`而不是`app-root`。
- en: While on the topic of Angular CLI and builds, there is something that we should
    understand before proceeding.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论Angular CLI和构建时，我们在继续之前应该了解一些事情。
- en: '*What happens to the TypeScript code we write?*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们编写的TypeScript代码会发生什么？*'
- en: Code transpiling
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码转译
- en: Browsers, as we all know, only work with JavaScript, they don't understand TypeScript.
    We hence need a mechanism to convert our TypeScript code into plain JavaScript
    (**ES5** is our safest bet). The **TypeScript compiler** does this job. The compiler
    takes the TypeScript code and converts it into JavaScript. This process is commonly
    referred to as **transpiling**, and since the TypeScript compiler does it, it's
    called a **transpiler**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器，众所周知，只支持JavaScript，它们不理解TypeScript。因此，我们需要一个机制将我们的TypeScript代码转换为纯JavaScript（**ES5**是我们的最佳选择）。**TypeScript编译器**负责这项工作。编译器将TypeScript代码转换为JavaScript。这个过程通常被称为**转译**，由于TypeScript编译器执行这个操作，因此被称为**转译器**。
- en: JavaScript as a language has evolved over the years with every new version adding
    new features/capabilities to the language. The latest avatar, ES2015, succeeds
    ES5 and is a major update to the language. While released in June 2015, some of
    the older browsers still lack support for the ES2015 flavor, of JavaScript making
    its adoption a challenge.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 语言在过去的几年中不断发展，每个新版本都为语言添加了新的功能/能力。最新的版本 ES2015 继承了 ES5，是语言的一次重大更新。尽管于
    2015 年 6 月发布，但一些较旧的浏览器仍然不支持 ES2015 版本的 JavaScript，这使得其采用成为一项挑战。
- en: When transpiling code from TypeScript to JavaScript, we can specify the flavor
    of JavaScript to use. As mentioned earlier, ES5 is our safest bet, but if we plan
    to work with only the latest and greatest browsers, go for ES2015\. For 7 Minute
    Workout, our code to transpile to is ES5 format. We set this TypeScript compiler
    configuration in `tsconfig.json` (see the `target` property).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 TypeScript 代码转换为 JavaScript 代码时，我们可以指定要使用的 JavaScript 版本。如前所述，ES5 是我们的最佳选择，但如果我们打算只与最新的浏览器合作，可以选择
    ES2015。对于 7 分钟健身应用，我们将代码转换为 ES5 格式。我们在 `tsconfig.json` 中设置了此 TypeScript 编译器配置（请参阅
    `target` 属性）。
- en: 'Interestingly, transpilation can happen at both build/compile time and at runtime:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，转换可以在构建/编译时和运行时发生：
- en: '**Build-time transpilation**: Transpilation as part of the build process takes
    the script files (in our case, TypeScript `.ts` files) and compiles them into
    plain JavaScript. Angular CLI does build-time transpilation.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建时转换**：构建过程中的转换将脚本文件（在我们的例子中是 TypeScript `.ts` 文件）编译成纯 JavaScript。Angular
    CLI 执行构建时转换。'
- en: '**Runtime transpilation**: This happens in the browser at runtime. We directly
    reference the TypeScript files (`.ts` in our case), and the TypeScript compiler,
    which is loaded in the browser beforehand, compiles these script files on the
    fly. This is a workable setup only for small examples/code snippets, as there
    is an additional performance overhead involved in loading the transpiler and transpiling
    the code on the fly.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时转换**：这发生在浏览器运行时。我们直接引用 TypeScript 文件（在我们的例子中是 `.ts` 文件），并且 TypeScript
    编译器，在浏览器中预先加载，会即时编译这些脚本文件。这种设置仅适用于小型示例/代码片段，因为加载转换器和即时转换代码会带来额外的性能开销。'
- en: The process of transpiling is not limited to TypeScript. Every language targeted
    towards the web, such as **CoffeeScript**, **ES2015**, (yes JavaScript itself!)
    or any other language that is not inherently understood by a browser needs transpilation.
    There are transpilers for most languages, and the prominent ones (other than TypeScript)
    are **tracuer** and **babel.**
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 转换过程不仅限于 TypeScript。所有针对 Web 的语言，如 **CoffeeScript**、**ES2015**（是的，JavaScript
    本身！）或任何浏览器本身无法理解的任何其他语言，都需要转换。大多数语言都有转换器，其中最著名的是（除了 TypeScript 之外）**tracuer**
    和 **babel**。
- en: The Angular CLI build system takes care of setting up the TypeScript compiler
    and sets up file watchers that recompile the code every time we make changes to
    our TypeScript file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI 构建系统负责设置 TypeScript 编译器，并设置文件监视器，每次我们更改 TypeScript 文件时都会重新编译代码。
- en: If you are new to TypeScript, remember that TypeScript does not depend on Angular;
    in fact, Angular has been built on TypeScript. I highly recommend that you look
    at the official documentation on TypeScript ([https://www.typescriptlang.org/](https://www.typescriptlang.org/))
    and learn the language outside the realms of Angular.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚接触 TypeScript，请记住 TypeScript 不依赖于 Angular；实际上，Angular 是基于 TypeScript 构建的。我强烈建议你查看
    TypeScript 的官方文档（[https://www.typescriptlang.org/](https://www.typescriptlang.org/)）并在
    Angular 的范畴之外学习这门语言。
- en: Let's get back to the app we are building and start exploring the code setup.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们正在构建的应用程序，并开始探索代码设置。
- en: Organizing code
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码组织
- en: 'The advantage of Angular CLI is that is dictates a code organization structure
    that works for applications of all sizes. Here is how the current code organization
    looks:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI 的优势在于它规定了适用于所有规模应用程序的代码组织结构。以下是当前代码组织结构的样子：
- en: '![](img/00012.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00012.jpeg)'
- en: '`trainer` is the application root folder.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trainer` 是应用程序的根文件夹。'
- en: The files inside `trainer` are configuration files and some standard files that
    are part of every standard node application.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trainer` 文件夹内的文件是配置文件和一些标准文件，它们是每个标准 Node 应用程序的一部分。'
- en: The `e2e` folder will contain end to end tests for the app.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e2e` 文件夹将包含应用程序的端到端测试。'
- en: '`src` is the primary folder where all the development happens. All the application
    artifacts go into `src`.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src` 是所有开发发生的主要文件夹。所有应用程序的工件都放入 `src`。'
- en: The `assets` folder inside `src` hosts static content (such as images, CSS,
    audio files, and others).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src` 文件夹内的 `assets` 文件夹托管静态内容（例如图片、CSS、音频文件等）。'
- en: The `app` folder has the app's source code.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app` 文件夹包含应用程序的源代码。'
- en: The `environments` folder is useful to set configurations for different deployment
    environments (such as *dev, qa, production*).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environments` 文件夹用于为不同的部署环境（如 *dev、qa、production*）设置配置。'
- en: To organize Angular code inside the `app` folder, we take a leaf from the Angular
    style guide ([http://bit.ly/ng6be-style-guide](http://bit.ly/ng6be-style-guide))
    released by the Angular team.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 `app` 文件夹内组织 Angular 代码，我们借鉴了 Angular 团队发布的 Angular 风格指南（[http://bit.ly/ng6be-style-guide](http://bit.ly/ng6be-style-guide)）。
- en: Feature folders
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能文件夹
- en: The style guide recommends use of **feature folders** to organize code. With
    feature folders, files linked to a single feature are placed together. If a feature
    grows, we break it down further into sub features and tuck the code into sub folders.
    Consider the `app` folder to be our first feature folder! As the application grows, `app` will
    add sub features for better code organization.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 风格指南建议使用**功能文件夹**来组织代码。使用功能文件夹，将链接到单个功能的文件放在一起。如果一个功能增长，我们将它进一步拆分为子功能，并将代码放入子文件夹中。将
    `app` 文件夹视为我们的第一个功能文件夹！随着应用程序的增长，`app` 将添加子功能以更好地组织代码。
- en: Let's get straight into building the application. Our first focus area, the
    app's model!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 直接进入构建应用程序。我们的第一个重点领域，应用程序的模型！
- en: The 7 Minute Workout model
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7分钟健身模型
- en: 'Designing the model for this app requires us to first detail the functional
    aspects of the *7 Minute Workout* app, and then derive a model that satisfies
    those requirements. Based on the problem statement defined earlier, some of the
    obvious requirements are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 设计该应用程序的模型需要我们首先详细说明 *7 分钟健身* 应用程序的功能方面，然后推导出一个满足这些要求的模型。根据之前定义的问题陈述，一些明显的要求如下：
- en: Being able to start the workout.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够开始锻炼。
- en: 'Providing a visual clue about the current exercise and its progress. This includes
    the following:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供关于当前练习及其进度的视觉提示。这包括以下内容：
- en: Providing a visual depiction of the current exercise
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供当前练习的视觉表示
- en: Providing step-by-step instructions on how to do a specific exercise
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供如何进行特定练习的逐步说明
- en: The time left for the current exercise
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前练习剩余时间
- en: Notifying the user when the workout ends.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当锻炼结束时通知用户。
- en: 'Some other valuable features that we will add to this app are as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加到该应用程序的一些其他有价值的功能如下：
- en: The ability to pause the current workout.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停当前锻炼的能力。
- en: Providing information about the next exercise to follow.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供关于接下来要进行的练习的信息。
- en: 'Providing audio clues so that the user can perform the workout without constantly
    looking at the screen. This includes:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供音频提示，以便用户可以在不经常查看屏幕的情况下进行锻炼。这包括：
- en: A timer click sound
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器点击声音
- en: Details about the next exercise
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于下一项练习的详细信息
- en: Signaling that the exercise is about to start
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号表示练习即将开始
- en: Showing related videos for the exercise in progress and the ability to play
    them.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示正在进行中的练习的相关视频，并能够播放它们。
- en: As we can see, the central themes for this app are **workout** and **exercise**.
    Here, a workout is a set of exercises performed in a specific order for a particular
    duration. So, let's go ahead and define the model for our workout and exercise.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，该应用的核心主题是**锻炼**和**练习**。在这里，一个锻炼是一组按照特定顺序进行、持续特定时间的练习。因此，让我们继续定义我们的锻炼和练习模型。
- en: 'Based on the requirements just mentioned, we will need the following details
    about an exercise:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 根据刚刚提到的要求，我们将需要以下关于一项练习的详细信息：
- en: The name. This should be unique.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称。这应该是唯一的。
- en: The title. This is shown to the user.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题。这会显示给用户。
- en: The description of the exercise.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习的描述。
- en: Instructions on how to perform the exercise.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何执行练习的说明。
- en: Images for the exercise.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习的图片。
- en: The name of the audio clip for the exercise.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习音频片段的名称。
- en: Related videos.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关视频。
- en: With TypeScript, we can define the classes for our model.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TypeScript，我们可以为我们的模型定义类。
- en: 'The `Exercise` class looks as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exercise` 类如下所示：'
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: TypeScript tips
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 小贴士
- en: Declaring constructor parameters with `public` or `private` is a shorthand for
    creating and initializing class members at one go. The `?` suffix after `nameSound`,
    `procedure`, and `videos` implies that these are optional parameters.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `public` 或 `private` 声明构造函数参数是一种创建和初始化类成员的快捷方式。`nameSound`、`procedure` 和
    `videos` 后的 `?` 后缀表示这些是可选参数。
- en: 'For the workout, we need to track the following properties:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于锻炼，我们需要跟踪以下属性：
- en: The name. This should be unique.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称。这应该是唯一的。
- en: The title. This is shown to the user.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题。这会显示给用户。
- en: The exercises that are part of the workout.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组成锻炼的练习。
- en: The duration for each exercise.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个练习的时长。
- en: The rest duration between two exercises.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两次练习之间的休息时间。
- en: 'The model class to track workout progress (`WorkoutPlan`) looks as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 用于跟踪锻炼进度的模型类 (`WorkoutPlan`) 如下所示：
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `totalWorkoutDuration` function returns the total duration of the workout
    in seconds.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`totalWorkoutDuration` 函数返回锻炼的总时长（以秒为单位）。'
- en: '`WorkoutPlan` has a reference to another class in the preceding definition,
    `ExercisePlan`. It tracks the exercise and the duration of the exercise in a workout,
    which is quite apparent once we look at the definition of `ExercisePlan`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutPlan` 在前面的定义中引用了另一个类，`ExercisePlan`。它跟踪锻炼和锻炼中的持续时间，一旦我们查看 `ExercisePlan`
    的定义，这一点就非常明显：'
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let me save you some typing and tell you where to get the model classes, but
    before that, we need to decide where to add them. We are ready for our first feature.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我为您节省一些输入，并告诉您在哪里获取模型类，但在那之前，我们需要决定在哪里添加它们。我们已经准备好进行第一个功能。
- en: First feature module
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个功能模块
- en: The primary feature of *7 Minute Workout* is to execute a predefined set of
    exercises. Hence we are going to create a feature module now and later add the
    feature implementation to this module. We call this module `workout-runner`. Let's
    initialize the feature with Angular CLI's scaffolding capabilities.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*7 分钟锻炼* 的主要功能是执行预定义的练习集。因此，我们现在将创建一个功能模块，稍后会将功能实现添加到该模块中。我们称此模块为 `workout-runner`。让我们使用
    Angular CLI 的脚手架功能初始化功能。'
- en: 'From the command line, navigate to the `trainer/src/app` folder and run the
    following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行导航到 `trainer/src/app` 文件夹并运行以下命令：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Follow the console logs to know what files are generated. The command essentially:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪控制台日志以了解生成的文件。该命令本质上：
- en: Creates a new Angular `WorkoutRunnerModule` module inside a new `workout-runner`
    folder
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新的 `workout-runner` 文件夹内创建一个新的 Angular `WorkoutRunnerModule` 模块
- en: Imports the newly created module into the main application module app (`app.module.ts`)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新创建的模块导入主应用程序模块 app (`app.module.ts`)
- en: We now have a new **feature module**.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个新的 **功能模块**。
- en: Give every feature its own module.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 给每个功能创建自己的模块。
- en: Make special note of the conventions Angular CLI follows when scaffolding Angular
    artifacts. From the preceding example, the module name provided with the command
    line was `workout-runner`. While the generated folder and filenames use the same
    name, the class name for the generated module is `WorkoutRunnerModule` (pascal
    case with the `Module` suffix).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Angular CLI 在构建 Angular 实体时遵循的约定。从前面的示例中，通过命令行提供的模块名称是 `workout-runner`。虽然生成的文件夹和文件名使用相同的名称，但生成的模块的类名是
    `WorkoutRunnerModule`（Pascal 大写并带有 `Module` 后缀）。
- en: Open the newly generated module definition (`workout-runner.module.ts`) and
    look at the generated content. `WorkoutRunnerModule` imports `CommonModule`, a
    module with common Angular directives such as `ngIf` and `ngFor`, allowing us
    to use these common directives across any component/directive defined in `WorkoutRunnerModule`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 打开新生成的模块定义文件 (`workout-runner.module.ts`) 并查看生成的内容。`WorkoutRunnerModule` 导入
    `CommonModule`，这是一个包含常见 Angular 指令（如 `ngIf` 和 `ngFor`）的模块，允许我们在 `WorkoutRunnerModule`
    中定义的任何组件/指令中使用这些常见指令。
- en: Modules are Angular's way of organizing code. We will touch upon Angular modules
    shortly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是 Angular 组织代码的方式。我们将在稍后讨论 Angular 模块。
- en: Copy the `model.ts` file from [http://bit.ly/ng6be-2-1-model-ts](http://bit.ly/ng6be-2-1-model-ts) into
    the `workout-runner` folder. Shortly, we will see how these model classes are
    utilized.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `model.ts` 文件从 [http://bit.ly/ng6be-2-1-model-ts](http://bit.ly/ng6be-2-1-model-ts)
    复制到 `workout-runner` 文件夹。不久我们将看到这些模型类是如何被利用的。
- en: Since we have started with a preconfigured Angular app, we just need to understand
    how the app starts.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从一个预配置的 Angular 应用程序开始，我们只需要了解应用程序是如何启动的。
- en: App bootstrapping
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序启动
- en: 'Chapter 1, *Getting Started*, had a good introduction to the app bootstrapping
    process. The app bootstrapping process for *7 Minute Workout* remains the same;
    look at the `src` folder. There is a `main.ts` file that bootstraps the application
    by calling the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第 1 章，*入门*，对应用程序启动过程进行了良好的介绍。*7 分钟锻炼* 的应用程序启动过程保持不变；查看 `src` 文件夹。有一个 `main.ts`
    文件通过调用以下内容启动应用程序：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The heavy lifting is done by the Angular CLI, which compiles the application,
    includes the script and CSS reference into `index.html`, and runs the application.
    We don't need to configure anything. These configurations are part of the default
    Angular CLI configuration (`.angular-cli.json`).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重量级的工作由 Angular CLI 完成，它编译应用程序，将脚本和 CSS 引用包含到`index.html`中，并运行应用程序。我们不需要进行任何配置。这些配置是默认
    Angular CLI 配置的一部分（`.angular-cli.json`）。
- en: We have created a new module and added some model classes to the `module` folder.
    Before we go any further and start implementing the feature, let's talk a bit
    about **Angular modules**.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个新模块，并将一些模型类添加到`module`文件夹中。在我们进一步实施功能之前，让我们先谈谈**Angular 模块**。
- en: Exploring Angular modules
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Angular 模块
- en: As the *7 Minute Workout* app grows and we add new components/directives/pipes/other
    artifacts to it, a need arises to organize these items. Each of these items needs
    to be part of an Angular module.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 *7 分钟健身* 应用程序的增长，我们向其中添加了新的组件/指令/管道/其他工件，这就需要对这些项目进行组织。每个项目都需要成为 Angular
    模块的一部分。
- en: A naïve approach would be to declare everything in our app's root module (`AppModule`),
    as we did with `WorkoutRunnerComponent`, but this defeats the whole purpose of
    Angular modules.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一种天真方法是在我们应用程序的根模块（`AppModule`）中声明一切，就像我们对`WorkoutRunnerComponent`所做的那样，但这违背了
    Angular 模块的全部目的。
- en: To understand why a single-module approach is never a good idea, let's explore
    Angular modules.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解为什么单模块方法永远不会是一个好主意，让我们来探索 Angular 模块。
- en: Comprehending Angular modules
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Angular 模块
- en: In Angular, **modules** are a way to organize code into chunks that belong together
    and work as a cohesive unit. Modules are Angular's way of grouping and organizing
    code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，**模块**是将代码组织成属于一起并作为一个统一单元工作的块的方式。模块是 Angular 对代码分组和组织的方式。
- en: 'An Angular module primarily defines:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Angular 模块主要定义：
- en: The components/directives/pipes it owns
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它拥有的组件/指令/管道
- en: The components/directives/pipes it makes public for other modules to consume
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它公开的组件/指令/管道，供其他模块消费
- en: Other modules that it depends on
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它所依赖的其他模块
- en: Services that the module wants to make available application-wide
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块想要在应用程序范围内提供的服务
- en: 'Any decent-sized Angular app will have modules interlinked with each other:
    some modules consuming artifacts from other, some providing artifacts to others,
    and some modules doing both.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 任何相当规模的 Angular 应用都将有模块相互链接：一些模块消费来自其他模块的工件，一些向其他模块提供工件，还有一些模块两者都做。
- en: 'As a standard practice, module segregation is feature-based. One divides the
    app into features or subfeatures (for large features) and modules are created
    for each of the features. Even the framework adheres to this guideline as all
    of the framework constructs are divided across modules:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项标准实践，模块隔离是基于功能的。人们将应用分为功能或子功能（对于大型功能），并为每个功能创建模块。甚至框架也遵循此指南，因为所有框架构造都分布在模块中：
- en: There is `CommonModule` that aggregates the standard framework constructs used
    in every browser-based Angular app
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在`CommonModule`，它聚合了在所有基于浏览器的 Angular 应用中使用的标准框架构造。
- en: There is `RouterModule` if we want to use the Angular routing framework
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想使用 Angular 路由框架，则存在`RouterModule`。
- en: There is `HtppModule` if our app needs to communicate with the server over HTTP
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的应用需要通过 HTTP 与服务器通信，则存在`HtppModule`。
- en: Angular modules are created by applying the `@NgModule` decorator to a TypeScript
    class, something we learned in Chapter 1, *Getting Started*. The decorator definition
    exposes enough metadata, allowing Angular to load everything the module refers
    to.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 模块是通过将`@NgModule`装饰器应用于 TypeScript 类来创建的，这是我们已经在第一章 *入门* 中学到的。装饰器定义暴露了足够的元数据，使
    Angular 能够加载模块引用的所有内容。
- en: 'The decorator has multiple attributes that allow us to define:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器有多个属性，允许我们定义：
- en: External dependencies (using `imports`).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部依赖（使用`imports`）。
- en: Module artifacts (using `declarations`).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块工件（使用`declarations`）。
- en: Module exports (using `exports`).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块导出（使用`exports`）。
- en: The services defined inside the module that need to be registered globally (using
    `providers`).
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块内部定义并需要全局注册的服务（使用`providers`）。
- en: The main application view, called the **root component**, which hosts all other
    app views. Only the root module should set this using the `bootstrap` property.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要应用程序视图，称为**根组件**，它托管所有其他应用程序视图。只有根模块应该使用`bootstrap`属性设置此属性。
- en: 'This diagram highlights the internals of a module and how they link to each
    other:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此图突出了模块的内部结构以及它们是如何相互链接的：
- en: '![](img/00013.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpeg)'
- en: Modules defined in the context of Angular (using the `@NgModule` decorator)
    are different from modules we import using the `import` statement in our TypeScript
    file. Modules imported through the `import` statement are **JavaScript modules**,
    which can be in different formats adhering to *CommonJS*, *AMD*, or *ES2015* specifications,
    whereas Angular modules are constructs used by Angular to segregate and organize
    its artifacts. Unless the context of the discussion is specifically a JavaScript
    module, any reference to module implies an Angular module. We can learn more about
    this here: [http://bit.ly/ng2be6-module-vs-ngmodule](http://bit.ly/ng2be6-module-vs-ngmodule).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular的上下文中定义的模块（使用`@NgModule`装饰器）与我们通过TypeScript文件中的`import`语句导入的模块不同。通过`import`语句导入的模块是**JavaScript模块**，可以是遵循*CommonJS*、*AMD*或*ES2015*规范的任何格式，而Angular模块是Angular用于隔离和组织其工件的结构。除非讨论的上下文是特定的JavaScript模块，否则任何关于模块的提及都指的是Angular模块。我们可以在这里了解更多信息：[http://bit.ly/ng2be6-module-vs-ngmodule](http://bit.ly/ng2be6-module-vs-ngmodule)。
- en: 'We hope one thing is clear from all this discussion: creating a single application-wide
    module is not the right use of Angular modules unless you are building something
    rudimentary.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望从所有这些讨论中可以清楚地看出：除非你正在构建一些基础的东西，否则创建单个应用程序范围的模块不是正确使用Angular模块的方式。
- en: It's time to get into the thick of the action; let's build our first component.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候深入到行动的核心了；让我们构建我们的第一个组件。
- en: Our first component - WorkoutRunnerComponent
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个组件 - WorkoutRunnerComponent
- en: '`WorkoutRunnerComponent`, is the central piece of our *7 Minute Workout* app
    and it will contain the logic to execute the workout.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`是我们*7分钟锻炼*应用的核心部分，它将包含执行锻炼的逻辑。'
- en: 'What we are going to do in the `WorkoutRunnerComponent` implementation is as
    follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WorkoutRunnerComponent`实现中，我们将做以下事情：
- en: Start the workout
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始锻炼
- en: Show the workout in progress and show the progress indicator
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展示正在进行的锻炼过程并显示进度指示器
- en: After the time elapses for an exercise, show the next exercise
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 练习时间结束后，显示下一个练习
- en: Repeat this process until all the exercises are over
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程，直到所有练习结束
- en: We are ready to create (or scaffold) our component.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好创建（或搭建）我们的组件。
- en: 'From the command line, navigate to the `src/app` folder and execute the following
    `ng` command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行导航到`src/app`文件夹并执行以下`ng`命令：
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The generator generates a bunch of files (three) in the `workout-runner` folder
    and updates the module declaration in `WorkoutRunnerModule` to include the newly
    created `WorkoutRunnerComponent`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器在`workout-runner`文件夹中生成一些文件（三个），并更新`WorkoutRunnerModule`中的模块声明，以包括新创建的`WorkoutRunnerComponent`。
- en: The `-is` flag is used to stop generation of a separate CSS file for the component.
    Since we are using global styles, we do not need component-specific styles.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`-is`标志用于停止为组件生成单独的CSS文件。由于我们使用全局样式，我们不需要组件特定的样式。'
- en: Remember to run this command from the `src/app` folder and not from the `src/app/workout-runner`
    folder. If we run the preceding command from `src/app/workout-runner`, Angular
    CLI will create a new subfolder with the `workout-runner` component definition.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 记住要从`src/app`文件夹运行此命令，而不是从`src/app/workout-runner`文件夹运行。如果我们从`src/app/workout-runner`运行前面的命令，Angular
    CLI将为`workout-runner`组件定义创建一个新的子文件夹。
- en: 'The preceding `ng generate` command for component generates these three files:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`ng generate`命令为组件生成以下三个文件：
- en: '`<component-name>.component.html`: This is the component''s view HTML.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<component-name>.component.html`：这是组件的视图HTML。'
- en: '`<component-name>.component.spec.ts`: Test specification file used in unit
    testing. We will dedicate a complete chapter to unit testing Angular applications.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<component-name>.component.spec.ts`：用于单元测试的测试规范文件。我们将用完整的一章来介绍Angular应用程序的单元测试。'
- en: '`<component-name>.component.ts`: Main component file containing component implementation.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<component-name>.component.ts`：包含组件实现的主体组件文件。'
- en: Again, we will encourage you to have a look at the generated code to understand
    what gets generated. The Angular CLI component generator saves us some keystrokes
    and once generated, the boilerplate code can evolve as desired.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将鼓励您查看生成的代码，以了解生成了什么。Angular CLI组件生成器为我们节省了一些按键，一旦生成，样板代码可以按需演变。
- en: We touched upon the component decorator (`@Component`) in [Chapter 1](part0019.html#I3QM0-7edc9b1e1ea341adae33006323903887),
    *Getting Started*, and the decorater applied here is no different. While we see
    only four decorator metadata properties (such as `templateUrl`), the component
    decorator supports some other useful properties too. Look at the Angular documentation
    for component to learn more about these properties and their application. In the
    coming chapters, we will utilize some metadata attributes other than the standard
    ones used on every component.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0019.html#I3QM0-7edc9b1e1ea341adae33006323903887)“入门”中，我们提到了组件装饰器（`@Component`），这里应用的装饰器也没有什么不同。虽然我们只看到了四个装饰器元数据属性（例如`templateUrl`），但组件装饰器还支持一些其他有用的属性。查看Angular文档中的组件部分，了解更多关于这些属性及其应用的信息。在接下来的章节中，我们将利用一些除了每个组件上使用的标准属性之外的其他元数据属性。
- en: An observant reader might have noticed that the generated `selector` property
    value has a prefix `abe`; this is intentional. Since we are extending the HTML
    **domain-specific language** (**DSL**) to incorporate a new element, the prefix
    `abe` helps us demarcate HTML extensions that we have developed. So instead of
    using `<workout-runner></workout-runner>` in HTML we use `<abe-workout-runner></abe-workout-runner>`.
    The prefix value has been configured in `angular.json`, see the `prefix` property.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一个细心的读者可能会注意到生成的`selector`属性值有一个前缀`abe`；这是故意的。由于我们正在扩展HTML**领域特定语言**（**DSL**）以包含一个新元素，前缀`abe`帮助我们区分我们开发的HTML扩展。因此，我们不是在HTML中使用`<workout-runner></workout-runner>`，而是使用`<abe-workout-runner></abe-workout-runner>`。前缀值已在`angular.json`中配置，请参阅`prefix`属性。
- en: Always add a prefix to your component selector.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 总是为你的组件选择器添加一个前缀。
- en: We now have the `WorkoutRunnerComponent` boilerplate; let's start adding the
    implementation, starting with adding the model reference.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了`WorkoutRunnerComponent`的模板；让我们开始添加实现，首先添加模型引用。
- en: 'In `workout-runner.component.ts`, import all the workout models:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-runner.component.ts`中，导入所有锻炼模型：
- en: '[PRE11]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to set up the workout data. Let''s do that by adding some code
    in the generated `ngOnInit` function and related class properties to the `WorkoutRunnerComponent`
    class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置锻炼数据。让我们通过在生成的`ngOnInit`函数和相关类属性中添加一些代码到`WorkoutRunnerComponent`类中来实现这一点：
- en: '[PRE12]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`ngOnInit` is a special function that Angular calls when a component is initialized.
    We will talk about `ngOnInit` shortly.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnInit`是一个Angular在组件初始化时调用的特殊函数。我们很快就会讨论`ngOnInit`。'
- en: The `buildWorkout` on `WorkoutRunnerComponent` sets up the complete workout,
    as we will define shortly. We also initialize a `restExercise` variable to track
    even the rest periods as exercise (note that `restExercise` is an object of type
    `ExercisePlan`).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`上的`buildWorkout`设置完整的锻炼，正如我们很快就会定义的。我们还初始化了一个`restExercise`变量来跟踪休息时间（注意`restExercise`是`ExercisePlan`类型的一个对象）。'
- en: 'The `buildWorkout` function is a lengthy function, so it''s better to copy
    the implementation from the workout runner''s implementation available in Git
    branch checkpoint2.1 ([http://bit.ly/ng6be-2-1-workout-runner-component-ts](http://bit.ly/ng6be-2-1-workout-runner-component-ts)).
    The `buildWorkout` code looks as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildWorkout`函数是一个较长的函数，所以最好从Git分支checkpoint2.1中可用的锻炼运行器的实现中复制实现（[http://bit.ly/ng6be-2-1-workout-runner-component-ts](http://bit.ly/ng6be-2-1-workout-runner-component-ts)）。`buildWorkout`代码如下：'
- en: '[PRE13]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code builds the `WorkoutPlan` object and pushes the exercise data into
    the `exercises` array (an array of `ExercisePlan` objects), returning the newly
    built workout.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码构建了`WorkoutPlan`对象，并将锻炼数据推入`exercises`数组（`ExercisePlan`对象数组），返回新构建的锻炼。
- en: 'The initialization is complete; now, it''s time to actually implement the *start*
    workout. Add a `start` function to the `WorkoutRunnerComponent` implementation,
    as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化已完成；现在，是时候实际实现*开始*锻炼了。在`WorkoutRunnerComponent`实现中添加一个`start`函数，如下所示：
- en: '[PRE14]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then declare the new variables used in the function at the top, with other
    variable declarations:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在函数顶部声明在函数中使用的新的变量，以及其他变量声明：
- en: '[PRE15]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `workoutTimeRemaining` variable tracks the total time remaining for the
    workout, and `currentExerciseIndex` tracks the currently executing exercise index.
    The call to `startExercise` actually starts an exercise. This is how the code
    for `startExercise` looks:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`workoutTimeRemaining`变量跟踪锻炼剩余的总时间，`currentExerciseIndex`跟踪当前执行的锻炼索引。对`startExercise`的调用实际上启动了一个锻炼。这就是`startExercise`代码的样子：'
- en: '[PRE16]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We start by initializing `currentExercise` and `exerciseRunningDuration`. The
    `currentExercise` variable tracks the exercise in progress and `exerciseRunningDuration`
    tracks its duration. These two variables also need to be declared at the top:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化`currentExercise`和`exerciseRunningDuration`。`currentExercise`变量跟踪正在进行的锻炼，`exerciseRunningDuration`跟踪其时长。这两个变量也需要在顶部声明：
- en: '[PRE17]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We use the `setInterval` JavaScript function with a delay of one second (1,000
    milliseconds) to make progress. Inside the `setInterval` callback, `exerciseRunningDuration`
    is incremented with each passing second. The nested `clearInterval` call stops
    the timer once the exercise duration lapses.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用延迟为一秒（1,000毫秒）的`setInterval` JavaScript函数来使进度。在`setInterval`回调函数内部，`exerciseRunningDuration`随着每一秒的过去而递增。嵌套的`clearInterval`调用一旦锻炼时长结束就停止计时器。
- en: TypeScript arrow functions
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript箭头函数
- en: The callback parameter passed to `setInterval` (`()=>{...}`) is a lambda function
    (or an arrow function in ES 2015). Lambda functions are short-form representations
    of anonymous functions, with added benefits. You can learn more about them at
    [http://bit.ly/ng2be-ts-arrow-functions](http://bit.ly/ng2be-ts-arrow-functions).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`setInterval`的回调参数（`()=>{...}`）是一个lambda函数（或ES 2015中的箭头函数）。Lambda函数是匿名函数的简写形式，具有额外的优势。你可以在[http://bit.ly/ng2be-ts-arrow-functions](http://bit.ly/ng2be-ts-arrow-functions)了解更多关于它们的信息。
- en: 'The first cut of the component is almost complete, except it currently has
    a static view (UI) and hence we cannot verify the implementation. We can quickly
    rectify this situation by adding a rudimentary view definition. Open `workout-runner.component.ts`,
    comment out the `templateUrl` property, and add an inline template property (`template`)
    and set it to the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的第一版几乎完成，但当前它有一个静态视图（UI），因此我们无法验证其实现。我们可以通过添加一个基本的视图定义来快速纠正这种情况。打开`workout-runner.component.ts`，注释掉`templateUrl`属性，并添加一个内联模板属性（`template`），并将其设置为以下内容：
- en: '[PRE18]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Strings enclosed in backticks (`` ` ` ``) are a new addition to ES2015\. Also
    called template literals, such string literals can be multiline and allow expressions
    to be embedded inside (not to be confused with Angular expressions). Look at the
    MDN article at [http://bit.ly/template-literals](http://bit.ly/template-literals)
    for more details.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 用反引号（`` ` ` ``）括起来的字符串是ES2015的新增功能。也称为模板字面量，这种字符串字面量可以是多行的，并允许在内部嵌入表达式（不要与Angular表达式混淆）。查看MDN文章[http://bit.ly/template-literals](http://bit.ly/template-literals)以获取更多详细信息。
- en: Inline versus external view template`external template file` (specified using
    `templateUrl`) for elaborate views. Angular CLI by default generates an external
    template reference, but we can affect this behavior by passing the `--inline-template`
    flag to the `ng` component generation command, such as `--inline-template true`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 内联视图与外部视图模板（使用`templateUrl`指定的`external template file`）用于详细视图。Angular CLI默认生成外部模板引用，但我们可以通过将`--inline-template`标志传递给`ng`组件生成命令（如`--inline-template
    true`）来影响这种行为。
- en: 'The preceding template HTML will render the raw `ExercisePlan` object and the
    exercise time remaining. It has an interesting expression inside the first interpolation:
    `currentExercise | json`. The `currentExercise` property is defined in `WorkoutRunnerComponent`,
    but what about the `|` symbol and what follows it (`json`)? In the Angular world,
    it is called a **pipe**. The sole purpose of a pipe is to transform/format template
    data.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模板HTML将渲染原始的`ExercisePlan`对象和剩余的锻炼时间。在第一个插值表达式内部有一个有趣的表达式：`currentExercise
    | json`。`currentExercise`属性在`WorkoutRunnerComponent`中定义，但关于`|`符号以及其后的内容（`json`）是什么？在Angular世界中，它被称为**管道**。管道的唯一目的是转换/格式化模板数据。
- en: The `json` pipe here does JSON data formatting. You will learn more about pipes
    later in this chapter, but to get a general sense of what the `json` pipe does,
    we can remove the `json` pipe plus the `|` symbol and render the template; we
    are going to do this next.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`json`管道用于JSON数据格式化。你将在本章后面了解更多关于管道的内容，但为了对`json`管道的作用有一个大致的了解，我们可以移除`json`管道以及`|`符号，并渲染模板；我们将在下一部分做这件事。
- en: 'To render the new `WorkoutRunnerComponent` implementation, it has to be added
    to the root component''s view. Modify `src/components/app/app.component.html`
    and replace the `h3` tag with the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染新的`WorkoutRunnerComponent`实现，必须将其添加到根组件的视图中。修改`src/components/app/app.component.html`，将`h3`标签替换为以下代码：
- en: '[PRE19]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While the implementation may look complete, there is a crucial piece missing.
    Nowhere in the code do we actually start the workout. The workout should start
    as soon as we load the page.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实现看起来已经完整，但还缺少一个关键部分。代码中没有任何地方真正开始锻炼。锻炼应该在页面加载后立即开始。
- en: Component lifecycle hooks are going to rescue us!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 组件生命周期钩子将帮助我们解决问题！
- en: Component lifecycle hooks
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件生命周期钩子
- en: 'The life of an Angular component is eventful. Components get created, change
    state during their lifetime, and finally, they are destroyed. Angular provides
    some **lifecycle hooks**/**functions** that the framework invokes (on the component)
    when such an event occurs. Consider these examples:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Angular组件的生命周期是充满事件的。组件被创建，在其生命周期中改变状态，最终被销毁。Angular提供了一些**生命周期钩子**/**函数**，当发生此类事件时，框架会调用（在组件上）。考虑以下示例：
- en: When a component is initialized, Angular invokes `ngOnInit`
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件初始化时，Angular会调用`ngOnInit`
- en: When a component's data-bound properties change, Angular invokes `ngOnChanges`
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件的数据绑定属性发生变化时，Angular会调用`ngOnChanges`
- en: When a component is destroyed, Angular invokes `ngOnDestroy`
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件被销毁时，Angular会调用`ngOnDestroy`
- en: As developers, we can tap into these key moments and perform some custom logic
    inside the respective component.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们可以利用这些关键时刻，并在相应的组件中执行一些自定义逻辑。
- en: The hook we are going to utilize here is `ngOnInit`. The `ngOnInit` function
    gets fired the first time the component's data-bound properties are initialized,
    but before the view initialization starts.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要利用的钩子是`ngOnInit`。`ngOnInit`函数在组件的数据绑定属性首次初始化时触发，但在视图初始化开始之前。
- en: While `ngOnInit` and the class constructor seem to look similar, they have a
    different purpose. *A constructor* is a language feature and it is used to initialize
    class members. `ngOnInit`, on the other hand, is used to do some initialization
    stuff once the component is ready. Avoid use of a constructor for anything other
    than member initialization.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ngOnInit`和类构造函数看起来很相似，但它们有不同的用途。*构造函数*是一种语言特性，用于初始化类成员。另一方面，`ngOnInit`用于在组件准备好后执行一些初始化操作。避免将构造函数用于除成员初始化之外的其他任何用途。
- en: 'Update the `ngOnInit` function to the `WorkoutRunnerComponent` class with a
    call to start the workout:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ngOnInit`函数更新为`WorkoutRunnerComponent`类，并调用开始锻炼：
- en: '[PRE20]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Angular CLI as part of component scaffolding already generates the signature
    for `ngOnInit`. The `ngOnInit` function is declared on the `OnInit` interface,
    which is part of the core Angular framework. We can confirm this by looking at
    the import section of `WorkoutRunnerComponent`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI作为组件脚手架的一部分已经生成了`ngOnInit`的签名。`ngOnInit`函数在`OnInit`接口上声明，该接口是Angular核心框架的一部分。我们可以通过查看`WorkoutRunnerComponent`的导入部分来确认这一点：
- en: '[PRE21]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are a number of other lifecycle hooks, including `ngOnDestroy`, `ngOnChanges`,
    and `ngAfterViewInit`, that components support, but we are not going to dwell
    on any of them here. Look at the developer guide ([https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks))
    on lifecycle hooks to learn more about other such hooks.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 组件支持许多其他生命周期钩子，包括`ngOnDestroy`、`ngOnChanges`和`ngAfterViewInit`，但在这里我们不会深入探讨它们。有关其他此类钩子的更多信息，请参阅开发者指南（[https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks)）。
- en: Implementing the interface (`OnInit` in the preceding example) is optional.
    These lifecycle hooks work as long as the function name matches. We still recommend
    you use interfaces to clearly communicate the intent.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 实现接口（如前例中的`OnInit`）是可选的。只要函数名匹配，这些生命周期钩子就会正常工作。我们仍然建议您使用接口来清楚地传达意图。
- en: 'Time to run our app! Open the command line, navigate to the `trainer` folder,
    and type this line:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行我们的应用了！打开命令行，导航到`trainer`文件夹，并输入以下行：
- en: '[PRE22]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code compiles, but no UI is rendered. What is failing us? Let's look at
    the browser console for errors.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编译通过了，但没有渲染UI。是什么出了问题？让我们查看浏览器控制台中的错误。
- en: 'Open the browser''s dev tools (common keyboard shortcut `F12`) and look at
    the console tab for errors. There is a template parsing error. Angular is not
    able to locate the `abe-workout-runner` component. Let''s do some sanity checks
    to verify our setup:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器的开发者工具（常见快捷键`F12`），查看控制台标签页以查找错误。存在模板解析错误。Angular无法定位到`abe-workout-runner`组件。让我们做一些合理性检查来验证我们的设置：
- en: '`WorkoutRunnerComponent` implementation complete - *check*'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`实现完成 - *检查*'
- en: Component declared in `WorkoutRunnerModule`- *check*
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`WorkoutRunnerModule`中声明的组件 - *检查*
- en: '`WorkoutRunnerModule` imported into `AppModule` - *check*'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已将 `WorkoutRunnerModule` 导入到 `AppModule` 中 - *检查*
- en: Still, the `AppComponent` template cannot locate the `WorkoutRunnerComponent`.
    Is it because `WorkoutRunnerComponent` and `AppComponent` are in different modules?
    Indeed, that is the problem! While `WorkoutRunnerModule` has been imported into `AppModule`, `WorkoutRunnerModule`
    still does not export the new `WorkoutRunnerComponent` that will allow `AppComponent`
    to use it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，`AppComponent` 模板找不到 `WorkoutRunnerComponent`。这是否是因为 `WorkoutRunnerComponent`
    和 `AppComponent` 在不同的模块中？确实如此！这是问题所在！虽然 `WorkoutRunnerModule` 已被导入到 `AppModule`
    中，但 `WorkoutRunnerModule` 仍然没有导出新的 `WorkoutRunnerComponent`，这将允许 `AppComponent`
    使用它。
- en: Remember, adding a component/directive/pipe to the `declaration` section of
    a module makes them available inside the module. It's only after we export the
    component/directive/pipe that it becomes available to be used across modules.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，将组件/指令/管道添加到模块的 `声明` 部分会使它们在模块内部可用。只有在我们导出组件/指令/管道之后，它才能在模块之间使用。
- en: 'Let''s export `WorkoutRunnerComponent` by updating the export array of the `WorkoutRunnerModule`
    declaration to the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更新 `WorkoutRunnerModule` 声明的导出数组来导出 `WorkoutRunnerComponent`：
- en: '[PRE23]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This time, we should see the following output:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们应该看到以下输出：
- en: '![](img/00014.jpeg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00014.jpeg)'
- en: Always export artifacts defined inside an Angular module if you want them to
    be used across other modules.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在其他模块中使用在 Angular 模块内部定义的工件，请始终导出这些工件。
- en: The model data updates with every passing second! Now you'll understand why
    interpolations (`{{ }}`) are a great debugging tool.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 模型数据每秒都会更新！现在你将理解为什么插值 (`{{ }}`) 是一个很好的调试工具。
- en: This will also be a good time to try rendering `currentExercise` without the
    `json` pipe and see what gets rendered.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个尝试不带 `json` 管道渲染 `currentExercise` 的好时机，看看会渲染什么。
- en: We are not done yet! Wait long enough on the page and we realize that the timer
    stops after 30 seconds. The app does not load the next exercise data. Time to
    fix it!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成！在页面上等待足够长的时间，我们会意识到计时器在 30 秒后停止。应用程序没有加载下一个锻炼数据。是时候修复它了！
- en: 'Update the code inside the `setInterval` function:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `setInterval` 函数内部的代码：
- en: '[PRE24]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `if` condition `if (this.exerciseRunningDuration >= this.currentExercise.duration)`
    is used to transition to the next exercise once the time duration of the current
    exercise lapses. We use `getNextExercise` to get the next exercise and call `startExercise`
    again to repeat the process. If no exercise is returned by the `getNextExercise`
    call, the workout is considered complete.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `if (this.exerciseRunningDuration >= this.currentExercise.duration)` 条件语句，一旦当前锻炼的时间耗尽，就切换到下一个锻炼。我们使用
    `getNextExercise` 获取下一个锻炼，并再次调用 `startExercise` 以重复此过程。如果 `getNextExercise` 调用没有返回任何锻炼，则认为锻炼已完成。
- en: During exercise transitioning, we increment `currentExerciseIndex` only if the
    next exercise is not a rest exercise. Remember that the original workout plan
    does not have a rest exercise. For the sake of consistency, we have created a
    rest exercise and are now swapping between rest and the standard exercises that
    are part of the workout plan. Therefore, `currentExerciseIndex` does not change
    when the next exercise is rest.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在锻炼切换期间，只有当下一个锻炼不是休息锻炼时，我们才增加 `currentExerciseIndex`。记住，原始锻炼计划中没有休息锻炼。为了保持一致性，我们创建了一个休息锻炼，现在在休息锻炼和锻炼计划中的标准锻炼之间切换。因此，当下一个锻炼是休息时，`currentExerciseIndex`
    不会改变。
- en: 'Let''s quickly add the `getNextExercise` function too. Add the function to
    the `WorkoutRunnerComponent` class:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速添加 `getNextExercise` 函数。将函数添加到 `WorkoutRunnerComponent` 类中：
- en: '[PRE25]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `getNextExercise` function returns the next exercise that needs to be performed.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNextExercise` 函数返回需要执行的下个锻炼。'
- en: Note that the returned object for `getNextExercise` is an `ExercisePlan` object
    that internally contains the exercise details and the duration for which the exercise
    runs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`getNextExercise` 返回的对象是一个 `ExercisePlan` 对象，它内部包含锻炼的详细信息以及锻炼的持续时间。
- en: The implementation is quite self-explanatory. If the current exercise is rest,
    take the next exercise from the `workoutPlan.exercises` array (based on `currentExerciseIndex`);
    otherwise, the next exercise is rest, given that we are not on the last exercise
    (the `else if` condition check).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相当直观。如果当前锻炼是休息，则从 `workoutPlan.exercises` 数组中获取下一个锻炼（基于 `currentExerciseIndex`）；否则，如果不在最后一个锻炼上（`else
    if` 条件检查），下一个锻炼是休息。
- en: With this, we are ready to test our implementation. The exercises should flip
    after every 10 or 30 seconds. Great!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就准备好测试我们的实现了。练习应该在每10秒或30秒后翻转。太棒了！
- en: The current build setup automatically compiles any changes made to the script
    files when the files are saved; it also refreshes the browser after these changes.
    But just in case the UI does not update or things do not work as expected, refresh
    the browser window. If you are having a problem with running the code, look at
    the Git branch `checkpoint2.1` for a working version of what we have done thus
    far. Or if you are not using Git, download the snapshot of Checkpoint 2.1 (a ZIP
    file) from [http://bit.ly/ng6be-checkpoint2-1](http://bit.ly/ng6be-checkpoint2-1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的构建设置会在保存脚本文件时自动编译对脚本文件所做的任何更改；它也会在这些更改后刷新浏览器。但以防万一UI没有更新或事情没有按预期工作，请刷新浏览器窗口。如果你在运行代码时遇到问题，请查看Git分支`checkpoint2.1`以获取我们迄今为止所做工作的一个工作版本。或者如果你不使用Git，可以从[http://bit.ly/ng6be-checkpoint2-1](http://bit.ly/ng6be-checkpoint2-1)下载Checkpoint
    2.1的快照（一个ZIP文件）。在第一次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: We have done enough work on the component for now, let's build the view.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们对组件的工作已经足够，让我们来构建视图。
- en: Building the 7 Minute Workout view
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建7分钟健身视图
- en: Most of the hard work has already been done while defining the model and implementing
    the component. Now, we just need to skin the HTML using the super-awesome data
    binding capabilities of Angular. It's going to be simple, sweet, and elegant!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义模型和实现组件时，大部分艰苦的工作已经完成。现在，我们只需要使用Angular超棒的数据绑定功能来“皮肤”HTML。这将简单、甜蜜且优雅！
- en: 'For the *7 Minute Workout* view, we need to show the exercise name, the exercise
    image, a progress indicator, and the time remaining. Replace the local content
    of the `workout-runner.component.html` file with the content of the file from
    the Git branch `checkpoint2.2`, (or download it from [http://bit.ly/ng6be-2-2-workout-runner-component-html](http://bit.ly/ng6be-2-2-workout-runner-component-html)).
    The view HTML looks as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*7分钟健身*视图，我们需要显示练习名称、练习图像、进度指示器和剩余时间。将`workout-runner.component.html`文件的本地内容替换为Git分支`checkpoint2.2`中的文件内容（或从[http://bit.ly/ng6be-2-2-workout-runner-component-html](http://bit.ly/ng6be-2-2-workout-runner-component-html)下载）。视图HTML看起来如下：
- en: '[PRE26]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`WorkoutRunnerComponent` currently uses an inline template; instead, we need
    to revert back to using an external template. Update the `workout-runner.component.ts`
    file and get rid of the `template` property, then uncomment `templateUrl`, which
    we commented out earlier.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`目前使用内联模板；相反，我们需要恢复使用外部模板。更新`workout-runner.component.ts`文件，删除`template`属性，然后取消注释我们之前注释掉的`templateUrl`。'
- en: 'Before we understand the Angular pieces in the view, let''s just run the app
    again. Save the changes in `workout-runner.component.html` and if everything went
    fine, we will see the workout app in its full glory:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们理解视图中的Angular组件之前，让我们再次运行应用程序。保存`workout-runner.component.html`中的更改，如果一切顺利，我们将看到健身应用程序的全貌：
- en: '![](img/00015.jpeg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00015.jpeg)'
- en: The basic app is now up and running. The exercise image and title show up, the
    progress indicator shows the progress, and exercise transitioning occurs when
    the exercise time lapses. This surely feels great!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 基本应用现在已经上线并运行。练习图像和标题显示出来，进度指示器显示进度，当练习时间结束时发生练习转换。这感觉真是太棒了！
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.2`
    for a working version of what we have done thus far. You can also download the
    snapshot of `checkpoint2.2` (a ZIP file) from this GitHub location: [http://bit.ly/ng6be-checkpoint-2-2](http://bit.ly/ng6be-checkpoint-2-2)
    . Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行代码时遇到问题，请查看Git分支`checkpoint2.2`以获取我们迄今为止所做工作的一个工作版本。你还可以从这个GitHub位置下载`checkpoint2.2`的快照（一个ZIP文件）：[http://bit.ly/ng6be-checkpoint-2-2](http://bit.ly/ng6be-checkpoint-2-2)。在第一次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'Looking at the view HTML, other than some Bootstrap styles, there are some
    interesting Angular pieces that need our attention. Before we dwell on these view
    constructs in detail, let''s break down these elements and provide a quick summary:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 观察视图HTML，除了一些Bootstrap样式外，还有一些需要我们注意的有趣的Angular组件。在我们详细研究这些视图结构之前，让我们分解这些元素并提供一个快速总结：
- en: '`<h1 ...>{{currentExercise.exercise.title}}</h1>`: Uses **interpolation**'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<h1 ...>{{currentExercise.exercise.title}}</h1>`: 使用 **插值**'
- en: '`<img ... [src]="''/assets/images/'' + currentExercise.exercise.image" .../>`:
    Uses **property binding** to bind the `src` property of the image to the component
    model property `currentExercise.exercise.image`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<img ... [src]="''/assets/images/'' + currentExercise.exercise.image" .../>`:
    使用 **属性绑定** 将图像的 `src` 属性绑定到组件模型属性 `currentExercise.exercise.image`'
- en: '`<div ... [attr.aria-valuenow]="exerciseRunningDuration" ... >`: Uses **attribute
    binding** to bind the aria attribute on *div* to `exerciseRunningDuration`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div ... [attr.aria-valuenow]="exerciseRunningDuration" ... >`: 使用 **属性绑定**
    将 `div` 上的 aria 属性绑定到 `exerciseRunningDuration`'
- en: '`< div ... [ngStyle]="{''width'':(exerciseRunningDuration/currentExercise.duration)
    * 100 + ''%''}">`: Uses a **directive** `ngStyle` to bind the `style` property
    on the progress bar `div` to an expression that evaluates the exercise progress'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div ... [ngStyle]="{''width'':(exerciseRunningDuration/currentExercise.duration)
    * 100 + ''%''}">`: 使用 **指令** `ngStyle` 将进度条 `div` 上的 `style` 属性绑定到一个评估练习进度的表达式'
- en: Phew! There is a lot of binding involved. Let's dig deeper into the binding
    infrastructure.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吸！这里涉及了很多绑定。让我们更深入地了解绑定基础设施。
- en: The Angular binding infrastructure
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 绑定基础设施
- en: Most modern JavaScript frameworks today come with strong model-view binding
    support, and Angular is no different. The primary aim of any binding infrastructure
    is to reduce the boilerplate code that a developer needs to write to keep the
    model and view in sync. A robust binding infrastructure is always declarative
    and terse.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，大多数现代 JavaScript 框架都提供了强大的模型-视图绑定支持，Angular 也不例外。任何绑定基础设施的主要目标是减少开发者需要编写的用于保持模型和视图同步的样板代码。一个健壮的绑定基础设施总是声明性和简洁的。
- en: 'The Angular binding infrastructure allows us to transform template (raw) HTML
    into a live view that is bound to model data. Based on the binding constructs
    used, data can flow and be synced in both directions: from model to view and view
    to model.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 绑定基础设施允许我们将模板（原始）HTML 转换为与模型数据绑定的实时视图。根据使用的绑定构造，数据可以双向流动和同步：从模型到视图和从视图到模型。
- en: The link between the component's model and its view is established using the
    `template` or `templateUrl` property of the `@Component` decorator. With the exception
    of the `script` tag, almost any piece of HTML can act as a template for the Angular
    binding infrastructure.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的模型与其视图之间的链接是通过 `@Component` 装饰器的 `template` 或 `templateUrl` 属性建立的。除了 `script`
    标签外，几乎任何 HTML 片段都可以作为 Angular 绑定基础设施的模板。
- en: To make this binding magic work, Angular needs to take the view template, compile
    it, link it to the model data, and keep it in sync with model updates without
    the need for any custom boilerplate synchronization code.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这种绑定魔法生效，Angular 需要获取视图模板，编译它，将其链接到模型数据，并在无需任何自定义同步代码的情况下保持与模型更新的同步。
- en: 'Based on the data flow direction, these bindings can be of three types:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据流方向，这些绑定可以分为三种类型：
- en: '**One-way binding from model to view**: In model-to-view binding, changes to
    the model are kept in sync with the view. Interpolations, property, attribute,
    class, and style bindings fall in this category.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从模型到视图的单向绑定**：在模型到视图绑定中，模型的变化与视图保持同步。插值、属性、属性、类和样式绑定属于此类。'
- en: '**One-way binding from view to model**: In this category, view changes flow
    towards the model. Event bindings fall in this category.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从视图到模型的单向绑定**：在这个类别中，视图变化流向模型。事件绑定属于此类。'
- en: '**Two-way/bidirectional binding**: Two-way binding, as the name suggests, keeps
    the view and model in sync. There is a special binding construct used for two-way
    binding, `ngModel`, and some standard HTML data entry elements such as `input`
    and `select` support two-way binding.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向/双向绑定**：正如其名所示，双向绑定保持视图和模型同步。用于双向绑定的有一个特殊的绑定构造 `ngModel`，以及一些标准的 HTML 数据输入元素，如
    `input` 和 `select` 支持双向绑定。'
- en: 'Let''s understand how to utilize the binding capabilities of Angular to support
    view templatization. Angular provides these binding constructs:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解如何利用 Angular 的绑定能力来支持视图模板化。Angular 提供了以下绑定构造：
- en: Interpolations
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插值
- en: Property binding
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性绑定
- en: Attribute binding
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性绑定
- en: Class binding
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类绑定
- en: Style binding
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式绑定
- en: Event binding
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件绑定
- en: We have already touched upon a number of binding capabilities in [Chapter 1](part0019.html#I3QM0-7edc9b1e1ea341adae33006323903887),
    *Getting Started*, so here we strive to reduce repetition and build upon the knowledge
    that we acquired in the last chapter.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第1章](part0019.html#I3QM0-7edc9b1e1ea341adae33006323903887)“入门”中提到了许多绑定功能，所以在这里我们力求减少重复，并建立在上一章获得的知识之上。
- en: This is a good time to learn about all these binding constructs. **Interpolation**
    is the first one.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是学习所有这些绑定结构的好时机。**插值**是第一个。
- en: Interpolations
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值
- en: '**Interpolations** are quite simple. The expression (commonly know as a **template
    expression**) inside the interpolation symbols (`{{ }}`) is evaluated in the context
    of the model (or the component class members), and the outcome of the evaluation
    (string) is embedded in HTML. A handy framework construct to display a component''s
    data/properties. We have seen these all along in Chapter 1, *Getting Started*,
    and also in the view we just added. We render the exercise title and the exercise
    time remaining using interpolation:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**插值**非常简单。插值符号（`{{ }}`）内的表达式（通常称为模板表达式）在模型（或组件类成员）的上下文中被评估，评估结果（字符串）被嵌入到HTML中。这是一个方便的框架结构，用于显示组件的数据/属性。我们在第1章“入门”中一直看到这些，也在我们刚刚添加的视图中看到。我们使用插值来渲染练习标题和剩余练习时间：'
- en: '[PRE27]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Remember that interpolations synchronize model changes with the view. Interpolation
    is one way of binding from a model to a view.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，插值同步模型变化与视图。插值是从模型到视图绑定的一种方式。
- en: View bindings in Angular are always evaluated in the context of the component's
    scope.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的视图绑定始终在组件的作用域上下文中进行评估。
- en: Interpolations, in fact, are a special case of property binding, which allows
    us to bind any HTML element/component properties to a model. We will shortly discuss
    how an interpolation can be written using property binding syntax. Consider interpolation
    as syntactical sugar over property binding.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，插值是属性绑定的一种特殊情况，它允许我们将任何HTML元素/组件属性绑定到模型。我们将很快讨论如何使用属性绑定语法编写插值。将插值视为属性绑定的语法糖。
- en: Property binding
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性绑定
- en: As discussed in [Chapter 1](part0019.html#I3QM0-7edc9b1e1ea341adae33006323903887)
    *Getting Started*, property bindings allow us to bind native HTML/component properties
    to the component's model and keep them in sync (from model->view). Let's look
    at property binding from a different context.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[第1章](part0019.html#I3QM0-7edc9b1e1ea341adae33006323903887)“入门”中讨论的那样，属性绑定使我们能够将原生HTML/组件属性绑定到组件模型并保持它们同步（从模型到视图）。让我们从不同的角度来探讨属性绑定。
- en: 'Look at this view excerpt from the 7 Minute Workout''s component view (`workout-runner.component.html`):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 看看7分钟健身组件视图（`workout-runner.component.html`）的这段视图摘录：
- en: '[PRE28]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It seems that we are setting the `src` attribute of `img` to an expression that
    gets evaluated at runtime. But are we really binding to an attribute? Or is this
    a property? Are properties and attributes different?
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们正在将`img`的`src`属性设置为在运行时评估的表达式。但我们真的是绑定到属性吗？或者这是一个属性？属性和属性是否不同？
- en: In Angular realms, while the preceding syntax looks like it is setting an HTML
    element's attribute, it is in fact doing **property binding**. Moreover, since
    many of us are not aware of the difference between an HTML element's properties
    and its attributes, this statement is very confusing. Therefore, before we look
    at how property bindings work, let's try to grasp the difference between an element's
    property and its attribute.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular领域，虽然前面的语法看起来像是在设置HTML元素的属性，但实际上它正在进行**属性绑定**。此外，由于我们很多人没有意识到HTML元素的属性和其属性之间的区别，这个声明非常令人困惑。因此，在我们查看属性绑定的工作方式之前，让我们先尝试理解元素属性和其属性之间的区别。
- en: Property versus attribute
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性与属性的区别
- en: 'Take any DOM element API and you will find attributes, properties, functions,
    and events. While events and functions are self-explanatory, it is difficult to
    understand the difference between properties and attributes. In daily use, we
    use these words interchangeably, which does not help much either. Take, for example,
    this line of code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 选取任何DOM元素API，你都会发现属性、属性、函数和事件。虽然事件和函数是自解释的，但理解属性和属性之间的区别却很困难。在日常使用中，我们经常互换使用这些词，这也没有太大帮助。以以下这段代码为例：
- en: '[PRE29]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When the browser creates a DOM element (`HTMLInputElement` to be precise) for
    this input textbox, it uses the `value` attribute on `input` to set the initial
    state of the  `value` property of `input` to `Awesome Angular`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器为这个输入文本框创建 DOM 元素（确切地说是 `HTMLInputElement`）时，它使用 `input` 上的 `value` 属性来设置
    `input` 的 `value` 属性的初始状态为 `Awesome Angular`。
- en: After this initialization, any changes to the `value` property of `input` do
    not reflect on the `value` attribute; the attribute always has `Awesome Angular`
    (unless set explicitly again). This can be confirmed by querying the `input` state.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在此初始化之后，对 `input` 的 `value` 属性的任何更改都不会反映在 `value` 属性上；属性始终是 `Awesome Angular`（除非再次明确设置）。这可以通过查询
    `input` 状态来确认。
- en: 'Suppose we change the `input` data to `Angular rocks!` and query the `input`
    element state:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将 `input` 数据更改为 `Angular rocks!` 并查询 `input` 元素状态：
- en: '[PRE30]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `value` property always returns the current input content, which is `Angular
    rocks!`. Whereas this DOM API function:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`value` 属性始终返回当前输入内容，即 `Angular rocks!`。而此 DOM API 函数：'
- en: '[PRE31]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Returns the `value` attribute, and is always the `Awesome Angular` that was
    set initially.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `value` 属性，并且始终是最初设置的 `Awesome Angular`。
- en: The primary role of an element attribute is to initialize the state of the element
    when the corresponding DOM object is created.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 元素属性的主要作用是在创建相应的 DOM 对象时初始化元素的状态。
- en: 'There are a number of other nuances that add to this confusion. These include
    the following:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他细微差别增加了这种混淆。以下是一些例子：
- en: Attribute and property synchronization is not consistent across properties.
    As we saw in the preceding example, changes to the `value` property on `input`
    do not affect the `value` attribute, but this is not true for all property-value
    pairs. The `src` property of an image element is a prime example of this; changes
    to property or attribute values are always kept in sync.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性和属性同步在属性之间并不一致。正如我们在前面的例子中所看到的，对 `input` 上的 `value` 属性的更改不会影响 `value` 属性，但这并不是所有属性值对的普遍情况。图像元素的
    `src` 属性是这种情况的一个主要例子；属性或属性值的更改始终保持同步。
- en: It's surprising to learn that the mapping between attributes and properties
    is also not one-to-one. There are a number of properties that do not have any
    backing attribute (such as `innerHTML`), and there are also attributes that do
    not have a corresponding property defined on the DOM (such as `colspan`).
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令人惊讶的是，属性和属性之间的映射也不是一对一的。有许多属性没有任何后置属性（例如 `innerHTML`），也有属性在 DOM 上没有定义相应的属性（例如
    `colspan`）。
- en: 'Attribute and property mapping adds to this confusion too, as they do not follow
    a consistent pattern. An excellent example of this is available in the Angular
    developer''s guide, which we are going to reproduce here verbatim:'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性和属性映射也增加了这种混淆，因为它们并不遵循一个一致的模式。Angular 开发者指南中有一个很好的例子，我们将在这里逐字复制：
- en: The `disabled` attribute is another peculiar example. A button's `disabled`
    property is `false` by default so the button is enabled. When we add the disabled
    attribute, its presence alone initializes the button's `disabled` property to
    `true` so the button is disabled. Adding and removing the disabled attribute disables
    and enables the button. The value of the attribute is irrelevant, which is why
    we cannot enable a button by writing `<button disabled="false">Still Disabled</button>`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`disabled` 属性是另一个独特的例子。按钮的 `disabled` 属性默认为 `false`，因此按钮是启用的。当我们添加禁用属性时，其存在本身就会将按钮的
    `disabled` 属性初始化为 `true`，从而使按钮被禁用。添加和删除禁用属性会启用和禁用按钮。属性值无关紧要，这就是为什么我们不能通过编写 `<button
    disabled="false">仍被禁用</button>` 来启用按钮。'
- en: The aim of this discussion is to make sure that we understand the difference
    between the properties and attributes of a DOM element. This new mental model
    will help us as we continue to explore the framework's property and attribute
    binding capabilities. Let's get back to our discussion on property binding.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这次讨论的目的是确保我们理解 DOM 元素的属性和属性之间的区别。这个新的思维模型将帮助我们继续探索框架的属性和属性绑定功能。让我们回到我们对属性绑定的讨论。
- en: Property binding continued...
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性绑定继续...
- en: 'Now that we understand the difference between a property and an attribute,
    let''s look at the binding example again:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了属性和属性之间的区别，让我们再次看看绑定示例：
- en: '[PRE32]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `[propertName]` square bracket syntax is used to bind the `img.src` property
    to an Angular expression.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `[propertName]` 方括号语法将 `img.src` 属性绑定到 Angular 表达式。
- en: 'The general syntax for property binding looks as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定的通用语法如下：
- en: '[PRE33]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the case of property binding, the `target` is a property on the DOM element
    or component. With property binding, we can literally bind to any property on
    the element's DOM. The `src` property on the `img` element is what we use; this
    binding works for any HTML element and every property on it.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性绑定的案例中，`target` 是 DOM 元素或组件上的一个属性。使用属性绑定，我们可以直接绑定到元素 DOM 上的任何属性。`img` 元素上的
    `src` 属性就是我们使用的；这种绑定适用于任何 HTML 元素及其上的所有属性。
- en: Expression target can also be an event, as we will see shortly when we explore
    event binding.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式目标也可以是一个事件，正如我们将在探索事件绑定时很快看到的。
- en: Binding source and targetIt is important to understand the difference between
    source and target in an Angular binding. The property appearing inside `[]` is
    a target, sometimes called **binding target**. The target is the consumer of the
    data and always refers to a property on the component/element. The **source**
    expression constitutes the data source that provides data to the target.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定源和目标理解 Angular 绑定中的源和目标之间的区别很重要。出现在 `[]` 内部的属性是一个目标，有时被称为**绑定目标**。目标是数据的消费者，始终指向组件/元素上的一个属性。**源**表达式构成了为目标提供数据的源。
- en: At runtime, the expression is evaluated in the context of the component's/element's
    property (the `WorkoutRunnerComponent.currentExercise.exercise.image` property
    in the preceding case).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，表达式在组件的/元素的属性上下文中被评估（在前面的案例中是 `WorkoutRunnerComponent.currentExercise.exercise.image`
    属性）。
- en: Always remember to add square brackets `[]` around the target. If we don't,
    Angular treats the expression as a string constant and the target is simply assigned
    the string value.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 总是要记得在目标周围添加方括号 `[]`。如果我们不这样做，Angular 会将表达式视为一个字符串常量，并且目标简单地被分配了字符串值。
- en: 'Property binding, event binding, and attribute binding do not use the interpolation
    symbol. The following is invalid: `[src]="{{''/static/images/'' + currentExercise.exercise.image}}".`'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定、事件绑定和属性绑定都不使用插值符号。以下是不合法的：`[src]="{{'/static/images/' + currentExercise.exercise.image}}"`。
- en: If you have worked on AngularJS, property binding together with event binding
    allows Angular to get rid of a number of directives, such as `ng-disable`, `ng-src`,
    `ng-key*`, `ng-mouse*`, and a few others.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过 AngularJS，属性绑定与事件绑定一起使用可以让 Angular 摆脱许多指令，例如 `ng-disable`、`ng-src`、`ng-key*`、`ng-mouse*`
    以及一些其他指令。
- en: 'From a data binding perspective, Angular treats components in the same way
    as it treats native elements. Hence, property binding works on component properties
    too! Components can define **input** and **output properties** that can be bound
    to the view, such as this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据绑定的角度来看，Angular 以与原生元素相同的方式处理组件。因此，属性绑定也适用于组件属性！组件可以定义**输入**和**输出**属性，这些属性可以绑定到视图，例如：
- en: '[PRE34]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can enable property binding using the `bind-` syntax, which is a canonical
    form of property binding. This implies that `[src]="''/assets/images/'' + currentExercise.exercise.image"` is
    equivalent to the following: `bind-src="img/'' + currentExercise.exercise.image"`.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `bind-` 语法启用属性绑定，这是属性绑定的规范形式。这意味着 `[src]="'/assets/images/' + currentExercise.exercise.image"`
    等同于以下：`bind-src="img/' + currentExercise.exercise.image"`。
- en: Property binding, like interpolation, is unidirectional, from the component/element
    source to the view. Changes to the model data are kept in sync with the view.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定，就像插值一样，是单向的，从组件/元素源到视图。模型数据的变化与视图保持同步。
- en: The template view that we just created has only one property binding (on `[src]`).
    The other bindings with square brackets aren't property bindings. We will cover
    them shortly.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的模板视图中只有一个属性绑定（在 `[src]` 上）。其他带有方括号的绑定不是属性绑定。我们将在稍后介绍它们。
- en: Interpolation syntactic sugar over property binding
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值是属性绑定的语法糖
- en: 'We concluded the section on interpolations by describing interpolation as syntactical
    sugar over property binding. The intent was to highlight how both can be used
    interchangeably. The interpolation syntax is terser than property binding and
    hence is very useful. This is how Angular interprets an interpolation:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将插值描述为属性绑定的语法糖来结束关于插值的章节。目的是强调两者可以互换使用。插值语法比属性绑定更简洁，因此非常有用。这就是 Angular 解释插值的方式：
- en: '[PRE35]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Angular translates the interpolation in the first statement into the `textContent`
    property binding (second statement).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 将第一个语句中的插值转换为 `textContent` 属性绑定（第二个语句）。
- en: 'Interpolation can be used in more places than you can imagine. The following
    example contrasts the same binding using interpolation and property binding:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 插值可以在你想象不到的更多地方使用。以下示例对比了使用插值和属性绑定执行相同绑定的例子：
- en: '[PRE36]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: While property binding (and interpolations) makes it easy for us to bind any
    expression to the target property, we should be careful with the expression we
    use. Angular's change detection system will evaluate your expression binding multiple
    times during the life cycle of the application, as long as our component is alive.
    Therefore, while binding an expression to a property target, keep these two guidelines
    in mind.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然属性绑定（和插值）使我们能够轻松地将任何表达式绑定到目标属性，但我们应该小心使用的表达式。Angular的变更检测系统将在应用的整个生命周期中多次评估你的表达式绑定，只要我们的组件是活跃的。因此，在将表达式绑定到属性目标时，请记住以下两个准则。
- en: Quick expression evaluation
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速表达式评估
- en: 'A property binding expression should evaluate quickly. Slow expression evaluation
    can kill your app''s performance. This happens when a function performing CPU
    intensive work is part of an expression. Consider this binding:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定表达式应该快速评估。慢速表达式评估会杀死你的应用性能。这种情况发生在执行CPU密集型工作的函数是表达式的一部分时。考虑这个绑定：
- en: '[PRE37]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Angular will evaluate the preceding `doLotsOfWork()` expression every time it
    performs a change detection run. These change detection runs happen more often
    than we imagine and are based on some internal heuristics, so it becomes imperative
    that the expressions we use evaluate quickly.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Angular每次执行变更检测运行时都会评估前面的`doLotsOfWork()`表达式。这些变更检测运行比我们想象的要频繁，并且基于一些内部启发式算法，因此我们使用的表达式必须快速评估。
- en: Side effect-free binding expressions
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无副作用绑定表达式
- en: 'If a function is used in a binding expression, it should be side effect-free.
    Consider yet another binding:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在绑定表达式中使用函数，则该函数应该是无副作用的。考虑另一个绑定：
- en: '[PRE38]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And the underlying function, `getContent`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 以及其底层函数，`getContent`：
- en: '[PRE39]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `getContent` call changes the state of the component by updating the `timesContentRequested`
    property every time it is called. If this property is used in views such as:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`getContent`调用通过每次调用时更新`timesContentRequested`属性来改变组件的状态。如果这个属性在如下视图中使用：'
- en: '[PRE40]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Angular throws errors such as:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Angular会抛出如下错误：
- en: '[PRE41]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The Angular framework works in two modes, dev and production. If we enable production
    mode in the application, the preceding error does not show up. Look at the framework
    documentation at [http://bit.ly/enableProdMode](http://bit.ly/enableProdMode)
    for more details.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架以两种模式运行，开发模式和产品模式。如果我们启用了应用程序的产品模式，前面的错误就不会显示。查看框架文档[http://bit.ly/enableProdMode](http://bit.ly/enableProdMode)以获取更多详细信息。
- en: The bottom line is that your expression used inside property binding should
    be side effect-free.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 核心问题是你在属性绑定中使用的表达式应该是无副作用的。
- en: Let's now look at something interesting, `[ngStyle]`, which looks like a property
    binding, but it's not. The target specified in `[]` is not a component/element
    property (`div` does not have an `ngStyle` property), it's a directive.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个有趣的东西，`[ngStyle]`，它看起来像属性绑定，但实际上不是。在`[]`中指定的目标不是一个组件/元素属性（`div`没有`ngStyle`属性），而是一个指令。
- en: Two new concepts need to be introduced, **target selection** and **directives**.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 需要介绍两个新概念，**目标选择**和**指令**。
- en: Angular directives
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular指令
- en: 'As a framework, Angular tries to enhance the HTML **DSL** (short for **Domain-Specific
    Language**):'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一款框架，Angular试图增强HTML **DSL**（即**领域特定语言**）：
- en: Components are referenced in HTML using custom tags such as `<abe-workout-runner></abe-workout-runner>`
    (not part of standard HTML constructs). This highlights the first extension point.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HTML中使用自定义标签如`<abe-workout-runner></abe-workout-runner>`（不是标准HTML结构的一部分）来引用组件。这突出了第一个扩展点。
- en: The use of `[]` and `()` for property and event binding defines the second.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`[]`和`()`进行属性和事件绑定定义了第二个。
- en: And then there are **directives**, the third extension point which are further
    classified into **attribute** and **structural directives**, and **components**
    (components are directive too!).
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是**指令**，这是第三个扩展点，它们进一步分为**属性指令**和**结构指令**，以及**组件**（组件也是指令！）。
- en: While components come with their own view, attribute directives are there to
    enhance the appearance and/or behavior of existing elements/components.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然组件自带视图，但属性指令旨在增强现有元素/组件的外观和/或行为。
- en: Structural directives do not have their own view too; they change the DOM layout
    of the elements on which they are applied. We will dedicate a complete section
    later in the chapter to understanding these structural directives.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令没有自己的视图；它们改变它们所应用元素的DOM布局。我们将在本章后面部分用完整章节来理解这些结构指令。
- en: 'The `ngStyle` directive used in the `workout-runner` view is, in fact, an attribute
    directive:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-runner`视图中使用的`ngStyle`指令实际上是一个属性指令：
- en: '[PRE42]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `ngStyle` directive does not have its own view; instead, it allows us to
    set multiple styles (`width` in this case) on an HTML element using binding expressions.
    We will be covering a number of framework attribute directives later in this book.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngStyle`指令没有自己的视图；相反，它允许我们通过绑定表达式在HTML元素上设置多个样式（在这种情况下是`width`）。我们将在本书的后面部分介绍许多框架属性指令。'
- en: Directive nomenclature
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 指令命名法
- en: Directives is an umbrella term used for component directives (also known as
    components), attribute directives, and structural directives. Throughout the book,
    when we use the term directive, we will be referring to either an attribute directive
    or a structural directive depending on the context. Component directives are always
    referred to as components.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 指令是一个总称，用于指代组件指令（也称为组件）、属性指令和结构指令。在本书中，当我们使用“指令”一词时，我们将根据上下文指代属性指令或结构指令。组件指令始终被称为组件。
- en: With a basic understanding of the directive types that Angular has, we can comprehend
    the process of target selection for binding.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在对Angular具有基本指令类型理解的基础上，我们可以理解绑定目标选择的过程。
- en: Target selection for binding
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定目标选择
- en: 'The target specified in `[]` is not limited to a component/element property.
    While the property name is a common target, the Angular templating engine actually
    does heuristics to decide the target type. Angular first searches the registered
    known directives (attribute or structural) that have matching selectors before
    looking for a property that matches the target expression. Consider this view
    fragment:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[]`中指定的目标不仅限于组件/元素属性。虽然属性名是一个常见的目标，但Angular模板引擎实际上会进行启发式搜索以决定目标类型。Angular首先搜索具有匹配选择器的已注册已知指令（属性或结构），然后再寻找与目标表达式匹配的属性。考虑以下视图片段：
- en: '[PRE43]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The search for a target starts with a framework looking at all internal and
    custom directives with a matching selector (`ngStyle`). Since Angular already
    has an `NgStyle` directive, it becomes the target (the directive class name is
    `NgStyle`, whereas the selector is `ngStyle`). If Angular did not have a built-in
    `NgStyle` directive, the binding engine would have looked for a property called
    `ngStyle` on the underlying component.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 目标搜索从框架查看所有具有匹配选择器（`ngStyle`）的内部和自定义指令开始。由于Angular已经有一个`NgStyle`指令，因此它成为目标（指令类名为`NgStyle`，而选择器为`ngStyle`）。如果Angular没有内置的`NgStyle`指令，绑定引擎就会在底层组件上查找名为`ngStyle`的属性。
- en: If nothing matches the target expression, an unknown directive error is thrown*.*
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有匹配目标表达式的内容，则会抛出未知指令错误*.*
- en: That completes our discussion on target selection. The next section is about
    attribute binding.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们对目标选择的讨论。下一节将关于属性绑定。
- en: Attribute binding
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性绑定
- en: The only reason attribute binding exists in Angular is that there are HTML attributes
    that do not have a backing DOM property. The `colspan` and `aria` attributes are
    some good examples of attributes without backing properties. The progress bar
    div in our view uses attribute binding.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，属性绑定存在的唯一原因是存在一些HTML属性没有对应的DOM属性。`colspan`和`aria`属性就是一些没有对应属性的属性的例子。我们视图中的进度条div使用了属性绑定。
- en: If attribute directives are still playing your head, I cannot blame you, it
    can become a bit confusing. Fundamentally, they are different. Attribute directives
    (such as `[ngStyle]`) change the appearance or behavior of DOM elements and as
    the name suggests are directives. There is no attribute or property named `ngStyle`
    on any HTML element. Attribute binding, on the other hand, is all about binding
    to HTML attributes that do not have backing for a DOM property.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性指令还在让你感到困惑，我无法责怪你，这可能会变得有点复杂。从根本上说，它们是不同的。属性指令（如`[ngStyle]`）会改变DOM元素的外观或行为，正如其名称所暗示的那样，它们是指令。任何HTML元素上都没有名为`ngStyle`的属性或属性。另一方面，属性绑定完全是关于绑定到没有DOM属性支持的HTML属性。
- en: 'The *7 Minute Workout* uses attribute binding at two places, `[attr.aria-valuenow]`
    and `[attr.aria-valuemax]`. We may ask a question: can we use standard interpolation
    syntax to set an attribute? No, that does not work! Let''s try it: open `workout-runner.component.html`
    and replace the two aria attributes `attr.aria-valuenow` and `attr.aria-valuemax`
    enclosed in `[]` with this highlighted code:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '*7 分钟锻炼* 在两个地方使用了属性绑定，`[attr.aria-valuenow]` 和 `[attr.aria-valuemax]`。我们可能会问一个问题：我们可以使用标准插值语法来设置属性吗？不，这不起作用！让我们试试：打开
    `workout-runner.component.html` 并将两个被突出显示的 aria 属性 `attr.aria-valuenow` 和 `attr.aria-valuemax`
    包围在 `[]` 中替换为以下代码：'
- en: '[PRE44]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Save the view and if the app is not running, run it. This error will pop up
    in the browser console:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 保存视图，如果应用没有运行，请运行它。此错误将在浏览器控制台中弹出：
- en: '[PRE45]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Angular is trying to search for a property called `ariaValuenow` in the `div`
    that does not exist! Remember, interpolations are actually property bindings.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 正在尝试在不存在 `ariaValuenow` 属性的 `div` 中查找一个名为 `ariaValuenow` 的属性！记住，插值实际上是属性绑定。
- en: 'We hope that this gets the point across: to bind to an HTML attribute, use
    attribute binding.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这能说明问题：要绑定到 HTML 属性，请使用属性绑定。
- en: Angular binds to properties by default and not to attributes.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 默认绑定到属性，而不是绑定到属性。
- en: 'To support attribute binding, Angular uses a prefix notation, `attr`, within
    `[]`. An attribute binding looks as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持属性绑定，Angular 在 `[]` 内使用前缀表示法 `attr`。属性绑定看起来如下所示：
- en: '[PRE46]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Revert to the original aria setup to make attribute binding work:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复原始的 aria 设置以使属性绑定生效：
- en: '[PRE47]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Remember that unless an explicit `attr.` prefix is attached, attribute binding
    does not work.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，除非显式附加了 `attr.` 前缀，否则属性绑定不会生效。
- en: While we have not used style and class-based binding in our workout view, these
    are some binding capabilities that can come in handy. Hence, they are worth exploring.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在我们的锻炼视图中没有使用样式和基于类的绑定，但这些是一些可能派上用场的绑定能力。因此，它们值得探索。
- en: Style and class binding
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式和类绑定
- en: 'We use **class binding** to set and remove a specific class based on the component
    state, as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 **类绑定** 根据组件状态设置和移除特定的类，如下所示：
- en: '[PRE48]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This adds `class-name` when `expression` is `true` and removes it when it is
    `false`. A simple example can look as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `expression` 为 `true` 时添加 `class-name`，当它为 `false` 时移除它。一个简单的例子可以如下所示：
- en: '[PRE49]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Use style bindings to set inline styles based on the component state:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 使用样式绑定根据组件状态设置内联样式：
- en: '[PRE50]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'While we have used the `ngStyle` directive for the workout view, we could have
    easily used style binding as well, as we are dealing with a single style. With
    style binding, the same `ngStyle` expression would become the following:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经使用了 `ngStyle` 指令来处理锻炼视图，但我们也可以轻松地使用样式绑定，因为我们只处理一个样式。使用样式绑定，相同的 `ngStyle`
    表达式将变为以下内容：
- en: '[PRE51]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`width` is a style, and since it takes units too, we extend our target expression
    to include the `%` symbol.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`width` 是一个样式，因为它也接受单位，所以我们扩展我们的目标表达式以包括 `%` 符号。'
- en: 'Remember that `style.` and `class.` are convenient bindings for setting a single
    class or style. For more flexibility, there are corresponding attribute directives:
    `ngClass` and `ngStyle`.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`style.` 和 `class.` 是设置单个类或样式的便捷绑定。为了获得更多灵活性，有相应的属性指令：`ngClass` 和 `ngStyle`。
- en: Earlier in the chapter, we formally introduced directives and their classifications.
    One of the directives types, attribute directives (again, don't confuse them with
    attribute binding, which we introduced in the preceding section) are the focus
    of our attention in the next section.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们正式介绍了指令及其分类。其中一种指令类型，属性指令（再次提醒，不要与我们在上一节中介绍的属性绑定混淆）将是下一节关注的焦点。
- en: Attribute directives
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性指令
- en: Attribute directives are HTML extensions that change the look, feel, or behavior
    of a component/element. As described in the section on Angular directives, these
    directives do not define their own view.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令是 HTML 扩展，可以改变组件/元素的外观、感觉或行为。如 Angular 指令部分所述，这些指令不定义自己的视图。
- en: Other than `ngStyle` and `ngClass` directives, there are a few more attribute
    directives that are part of the core framework. `ngValue`, `ngModel`, `ngSelectOptions`,
    `ngControl`, and `ngFormControl` are some of the attribute directives that Angular
    provides.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `ngStyle` 和 `ngClass` 指令之外，还有一些属性指令是核心框架的一部分。`ngValue`、`ngModel`、`ngSelectOptions`、`ngControl`
    和 `ngFormControl` 是 Angular 提供的一些属性指令。
- en: Since *7 Minute Workout* uses the `ngStyle` directive, it would be wise to dwell
    more on this directive and its close associate `ngClass`.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *7 分钟健身法* 使用了 `ngStyle` 指令，因此深入了解这个指令及其紧密相关的 `ngClass` 是明智的。
- en: While the next section is dedicated to learning how to use the `ngClass` and
    `ngStyle` attribute directives, it is not until Chapter 6, *Angular Directives
    in Depth*, that we learn how to create our own attribute directives.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然下一节是关于学习如何使用 `ngClass` 和 `ngStyle` 属性指令，但我们直到第 6 章 *Angular 指令深入* 才学习如何创建自己的属性指令。
- en: Styling HTML with ngClass and ngStyle
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ngClass 和 ngStyle 样式化 HTML
- en: 'Angular has two excellent directives that allow us to dynamically set styles
    on any element and toggle CSS classes. For the bootstrap progress bar, we use
    the `ngStyle` directive to dynamically set the element''s style, `width`, as the
    exercise progresses:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 有两个优秀的指令，允许我们动态地为任何元素设置样式并切换 CSS 类。对于 Bootstrap 进度条，我们使用 `ngStyle` 指令动态设置元素的样式，`width`，随着练习的进行：
- en: '[PRE52]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`ngStyle` allows us to bind one or more styles to a component''s properties
    at once. It takes an object as a parameter. Each property name on the object is
    the style name, and the value is the Angular expression bound to that property,
    such as the following example:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngStyle` 允许我们一次性将一个或多个样式绑定到组件的属性上。它接受一个对象作为参数。对象上的每个属性名是样式名，值是绑定到该属性的 Angular
    表达式，如下例所示：'
- en: '[PRE53]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The styles can not only bind to component properties (`componentWidth` and `componentHeight`),
    but also be set to a constant value (`'larger'`). The expression parser also allows
    the use of the ternary operator (`?:`); check out `isRequired`.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 样式不仅可以绑定到组件属性（`componentWidth` 和 `componentHeight`），还可以设置为常量值（`'larger'`）。表达式解析器还允许使用三元运算符（`?:`）；查看
    `isRequired`。
- en: 'If styles become too unwieldy in HTML, we also have the option of writing in
    our component a function that returns the object hash, and setting that as an
    expression:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 HTML 中样式变得难以管理，我们也有选择在组件中编写一个函数，该函数返回对象哈希，并将其设置为表达式：
- en: '[PRE54]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Moreover, `getStyles` on the component looks as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，组件上的 `getStyles` 看起来如下：
- en: '[PRE55]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`ngClass` works on the same lines too, except that it is used to toggle one
    or multiple classes. For example, check out the following code:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngClass` 的工作原理也类似，只不过它用于切换一个或多个类。例如，查看以下代码：'
- en: '[PRE56]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `required` class is applied when `inputRequired` is `true` and is removed
    when it evaluates to `false`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `inputRequired` 为 `true` 时应用 `required` 类，当它评估为 `false` 时移除。
- en: Directives (custom or platform) like any other Angular artifact, always belong
    to a module. To use them across modules, the module needs to be imported. Wondering
    where `ngStyle` is defined? `ngStyle` is part of the core framework module, `CommonModule,`,
    and has been imported in the workout runner module definition (`workout-runner.module.ts`).
    `CommonModule` defines a number of handy directives that are used across Angular.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 指令（自定义或平台）就像任何其他 Angular 艺术品一样，始终属于一个模块。要跨模块使用它们，模块需要被导入。想知道 `ngStyle` 在哪里定义吗？`ngStyle`
    是核心框架模块 `CommonModule` 的一部分，并在 `workout-runner.module.ts` 模块定义中导入。`CommonModule`
    定义了多个有用的指令，这些指令在 Angular 中被广泛使用。
- en: Well! That covers everything we had to learn about our newly developed view.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧！这就涵盖了我们需要了解的关于我们新开发视图的所有内容。
- en: And as described earlier, if you are having a problem with running the code,
    look at the Git branch `checkpoint2.2`. If not using Git, download the snapshot
    of `checkpoint2.2` (a ZIP file) from [http://bit.ly/ng2be-checkpoint2-2](http://bit.ly/ng2be-checkpoint2-2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果您在运行代码时遇到问题，请查看 Git 分支 `checkpoint2.2`。如果不使用 Git，请从 [http://bit.ly/ng2be-checkpoint2-2](http://bit.ly/ng2be-checkpoint2-2)
    下载 `checkpoint2.2` 的快照（ZIP 文件）。在首次设置快照时，请参考 `trainer` 文件夹中的 `README.md` 文件。
- en: Time to add some enhancements and learn a bit more about the framework!
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加一些增强功能并学习更多关于框架的知识了！
- en: Learning more about an exercise
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解更多关于练习的信息
- en: For people who are doing this workout for the first time, it will be good to
    detail the steps involved in each exercise. We can also add references to some
    YouTube videos for each exercise to help the user understand the exercise better.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次做这个练习的人来说，详细说明每个练习涉及的步骤会很好。我们还可以为每个练习添加一些 YouTube 视频的引用，以帮助用户更好地理解练习。
- en: We are going to add the exercise description and instructions in the left panel
    and call it the **description panel**. We will also add references to YouTube
    videos in the right panel, which is the video player panel. To make things more
    modular and learn some new concepts, we are going to create independent components
    for each description panel and video panel.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: The model data for this is already available. The `description` and `procedure`
    properties in the `Exercise` class (see `model.ts`) provide the necessary details
    about the exercise. The `videos` array contains some related YouTube video IDs,
    which will be used to fetch these videos.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Adding descriptions and video panels
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Angular app is nothing but a hierarchy of components, similar to a tree
    structure. As of now, *7 Minute Workout* has two components, the root component,
    `AppComponent`, and its child, `WorkoutRunnerComponent`, in line with the HTML
    component layout, which now looks as follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Run the app and do a view source to verify this hierarchy. As we all more components
    to implement new features in the application this component tree grows and branches
    out.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add two subcomponents to `WorkoutRunnerComponent`, one each
    to support the exercise description and exercise videos. While we could have added
    some HTML directly to the `WorkoutRunnerComponent` view, what we are hoping here
    is to learn a bit more about cross-component communication. Let's start with adding
    the description panel on the left and understand how a component can accept inputs.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Component with inputs
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Navigate to the `workour-runner` folder and generate a boilerplate exercise
    description component:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To the generated `exercise-description.component.ts` file, add the highlighted
    code:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `@Input` decorator signifies that the component property is available for
    data binding. Before we dig into the `@Input` decorator, let's complete the view
    and integrate it with `WorkoutRunnerComponent`.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the view definition for exercise description, `exercise-description.component.html`,
    from the Git branch `checkpoint2.3`, in the `workout-runner/exercise-description` folder
    (GitHub location: [http://bit.ly/ng6be-2-3-exercise-description-component-html](http://bit.ly/ng6be-2-3-exercise-description-component-html)).
    Look at the highlighted HTML for the exercise description:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding interpolation references the input properties of `ExerciseDescriptionComponent`:
    `description` and `steps`.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: The component definition is complete. Now, we just need to reference `ExerciseDescriptionComponent`
    in `WorkoutRunnerComponent` and provide values for `description` and `steps` for
    the `ExerciseDescriptionComponent` view to render correctly.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout-runner.component.html` and update the HTML fragments as highlighted
    in the following code. Add a new div called `description-panel` before the `exercise-pane`
    div and adjust some styles on the `exercise-pane` div, as follows:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If the app is running, the description panel should show up on the left with
    the relevant exercise details.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序正在运行，描述面板应显示在左侧，并显示相关的练习详情。
- en: '`WorkoutRunnerComponent` was able to use `ExerciseDescriptionComponent` because
    it has been declared on `WorkoutRunnerModule` (see the `workout-runner.module.ts` declaration
    property). The Angular CLI component generator does this work for us.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`能够使用`ExerciseDescriptionComponent`是因为它已经在`WorkoutRunnerModule`上声明过（参见`workout-runner.module.ts`声明属性）。Angular
    CLI组件生成器为我们完成了这项工作。'
- en: Look back at the `abe-exercise-description` declaration in the preceding view.
    We are referring to the `description` and `steps` properties in the same manner
    as we did with the HTML element properties earlier in the chapter (`<img [src]='expression'
    ...`). Simple, intuitive, and very elegant!
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾前一个视图中的`abe-exercise-description`声明。我们以与本章早期使用HTML元素属性相同的方式引用`description`和`steps`属性（`<img
    [src]='expression' ...>`）。简单、直观且非常优雅！
- en: The Angular data binding infrastructure makes sure that whenever the `currentExercise.exercise.description`
    and `currentExercise.exercise.procedure` properties on `WorkoutRunnerComponent`
    change, the bound properties on `ExerciseDescriptionComponent`, `description`,
    and `steps` are also updated.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: Angular数据绑定基础设施确保每当`WorkoutRunnerComponent`上的`currentExercise.exercise.description`和`currentExercise.exercise.procedure`属性发生变化时，`ExerciseDescriptionComponent`、`description`和`steps`上的绑定属性也会更新。
- en: 'The `@Input` decoration can take a property alias as a parameter, which means
    the following: consider a property declaration such as: `@Input("myAwesomeProperty")
    myProperty:string`. It can be referenced in the view as follows: `<my-component
    [myAwesomeProperty]="expression"....`'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input`装饰器可以接受一个属性别名作为参数，这意味着以下内容：考虑一个属性声明，例如：`@Input("myAwesomeProperty")
    myProperty:string`。它可以在视图中如下引用：`<my-component [myAwesomeProperty]="expression"....>`'
- en: 'The power of the Angular binding infrastructure allows us to use any component
    property as a bindable property by attaching the `@Input` decorator (and `@Output`
    too) to it. We are not limited to basic data types such as `string`, `number`,
    and `boolean`; there can be complex objects too, which we will see next as we
    add the video player:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: Angular绑定基础设施的力量允许我们通过将其附加`@Input`装饰器（以及`@Output`）来使用任何组件属性作为可绑定属性。我们不仅限于基本数据类型，如`string`、`number`和`boolean`；还可以是复杂对象，我们将在添加视频播放器时看到这一点：
- en: The `@Input` decorator can be applied to complex objects too.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input`装饰器也可以应用于复杂对象。'
- en: 'Generate a new component in the `workout-runner` directory for the video player:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-runner`目录下生成一个新的组件用于视频播放器：
- en: '[PRE62]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Update the generated boilerplate code by copying implementation from `video-player.component.ts`
    and `video-player.component.html` available in the Git branch `checkpoint2.3`
    in the `trainer/src/components/workout-runner/video-player` folder (GitHub location:
    [http://bit.ly/ng6be-2-3-video-player](http://bit.ly/ng6be-2-3-video-player)).'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从`video-player.component.ts`和`video-player.component.html`（位于Git分支`checkpoint2.3`中的`trainer/src/components/workout-runner/video-player`文件夹，GitHub位置：[http://bit.ly/ng6be-2-3-video-player](http://bit.ly/ng6be-2-3-video-player)）复制实现来更新生成的模板代码。
- en: 'Let''s look at the implementation for the video player. Open `video-player.component.ts`
    and check out the `VideoPlayerComponent` class:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看视频播放器的实现。打开`video-player.component.ts`并查看`VideoPlayerComponent`类：
- en: '[PRE63]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `videos` input property here takes an array of strings (YouTube video codes).
    While we take the `videos` array as input, we do not use this array directly in
    video player view; instead, we transform the input array into a new array of `safeVideoUrls`
    and bind it. This can be confirmed by looking at the view implementation:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的`videos`输入属性接受一个字符串数组（YouTube视频代码）。虽然我们将`videos`数组作为输入，但我们不会直接在视频播放器视图中使用此数组；相反，我们将输入数组转换成一个新的`safeVideoUrls`数组并绑定它。这可以通过查看视图实现来确认：
- en: '[PRE64]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The view also uses a new Angular directive called `ngFor` to bind to the `safeVideoUrls`
    array. The `ngFor` directive belongs to a class of directives called **structural
    directives**. The directive's job is to take an HTML fragment and regenerate it
    based on the number of elements in the bound collection.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 视图还使用了一个新的Angular指令`ngFor`来绑定到`safeVideoUrls`数组。`ngFor`指令属于一类称为**结构指令**的指令。该指令的职责是接受一个HTML片段，并根据绑定集合中的元素数量重新生成它。
- en: If you are confused about how the `ngFor` directive works with `safeVideoUrls`,
    and why we need to generate `safeVideoUrls` instead of using the `videos` input
    array, wait for a while as we are shortly going to address these queries. But,
    let's first complete the integration of `VideoPlayerComponent` with `WorkoutRunnerComponent`
    to see the final outcome.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `WorkoutRunnerComponent` view by adding the component declaration
    after the `exercise-pane` div:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `VideoPlayerComponent`'s `videos` property binds to the exercise's videos
    collection.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Start/refresh the app and the video thumbnails should show up on the right.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.3`
    for a working version of what we have done thus far. You can also download the
    snapshot of `checkpoint2.3` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-2-3](http://bit.ly/ng6be-checkpoint-2-3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to go back and look at the parts of the `VideoPlayerComponent`
    implementation. We specifically need to understand:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: How the `ngFor` directive works
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why there is a need to transform the input `videos` array into `safeVideoUrls`
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The significance of the Angular component life cycle event `OnChanges` (used
    in the video player)
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To start with, it''s time to formally introduce `ngFor` and the class of directives
    it belongs to: structural directives.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: Structural directives
  id: totrans-500
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third categorization of directives, structural directives, work on the components/elements
    to manipulate their layout.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular documentation describes structural directives in a succinct manner:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '"Instead of defining and controlling a view like a Component Directive, or
    modifying the appearance and behavior of an element like an Attribute Directive,
    the Structural Directive manipulates the layout by adding and removing entire
    element sub-trees."'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Since we have already touched upon component directives (such as `workout-runner`
    and `exercise-description`) and attribute directives (such as `ngClass` and `ngStyle`),
    we can very well contrast their behaviors with structural directives.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: The `ngFor` directive belongs to this class. We can easily identify such directives
    by the `*` prefix. Other than `ngFor`, Angular comes with some other structural
    directives such as `ngIf` and `ngSwitch`.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: The ever-so-useful NgForOf
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every templating language has constructs that allow the templating engine to
    generate HTML (by repetition). Angular has `NgForOf`. The `NgForOf` directive
    is a super useful directive used to duplicate a piece of an HTML fragment n number
    of times. Let''s again look at how we have used `NgForOf` in the video player:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The directive selector for `NgForOf` is `{selector: ''[ngFor][ngForOf]''}`,
    so we can use either `ngFor` or `ngForOf` in the view template. We also at times
    refer to this directive as `ngFor`.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code repeats the `div` fragment for each exercise video (using
    the `safeVideoUrls` array). The `let video of safeVideoUrls` string expression
    is interpreted as follows: take each video in the `safeVideoUrls` array and assign
    it to a template input variable, `video`.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: This input variable can now be referenced inside the `ngFor` template HTML,
    as we do when we set the `src` property binding.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the string assigned to the `ngFor` directive is not a typical
    Angular expression. Instead, it's a **microsyntax**—a micro language, which the
    Angular engine can parse.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about microsyntax in Angular's developer guide: [http://bit.ly/ng6be-micro-syntax](http://bit.ly/ng6be-micro-syntax).
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: This microsyntax exposes a number of iteration context properties that we can
    assign to template input variables and use them inside the `ngFor` HTML block.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'One such example is `index`. `index` increases from 0 to the length of the
    array for each iteration, something similar to a `for` loop, in any programming
    language. The following example shows how to capture it:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Other than `index`, there are some more iteration context variables; these
    include `first`, `last`, `even`, and `odd`. This context data allows us to do
    some nifty stuff. Consider this example:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It applies a `special` class to the first video `div`.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NgForOf` directive can be applied to HTML elements as well as our custom
    components. This is a valid use of `NgForOf`:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Always remember to add an asterisk (`*`) before `ngFor` (and other structural
    directives). `*` has a significance.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Asterisk (*) in structural directives
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `*` prefix is a terser format to represent a structural directive. Take,
    for example, the usage of `ngFor` by the video player. The `ngFor` template:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Actually expands to the following:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `ng-template` tag is an Angular element that has a declaration for `ngFor`,
    a template input variable (`video`), and a property (`ngForOf`) that points to
    the `safeVideoUrls` array. Both the preceding declarations are a valid usage of
    `ngFor`.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Not sure about you, but I prefer the terser first format for `ngFor`!
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: NgForOf performance
  id: totrans-530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since `NgForOf` generates HTML based on collection elements, it is notorious
    for causing performance issues. But we cannot blame the directive. It does what
    it is supposed to do: iterate and generate elements! If the underlying collection
    is huge, UI rendering can take a performance hit, especially if the collection
    changes too often. The cost of continuously destroying and creating elements in
    response to a changing collection can quickly become prohibitive.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: One of the performance tweaks for `NgForOf` allows us to alter the behavior
    of `ngForOf` when it comes to creating and destroying DOM elements (when the underlying
    collection elements are added or removed).
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a scenario where we frequently get an array of objects from the server
    and bind it to the view using `NgForOf`. The default behavior of `NgForOf` is
    to regenerate the DOM every time we refresh the list (since Angular does a standard
    object equality check). However, as developers, we may very well know not much
    has changed. Some new objects may have been added, some removed, and maybe some
    modified. But Angular just regenerates the complete DOM.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: 'To alleviate this situation, Angular allows us to specify a custom **tracking
    function**, which lets Angular know when two objects being compared are equal.
    Have a look at the following function:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: A function such as this can be used in the `NgForOf` template to tell Angular
    to compare the *user* object based on its `id` property instead of doing a reference
    equality check.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we then use the preceding function in the `NgForOf` template:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`NgForOf` will now avoid recreating DOM for users with IDs already rendered.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: Remember, Angular may still update the existing DOM elements if the bound properties
    of a user have changed.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: That's enough on the `ngFor` directive; let's move ahead.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: We still need to understand the role of the `safeVideoUrls` and the `OnChange`
    life cycle events in the `VideoPlayerComponent` implementation. Let's tackle the
    former first and understand the need for `safeVideoUrls`.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: Angular security
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to understand why we need to bind to `safeVideoUrls` instead
    of the `videos` input property is by trying the `videos` array out. Replace the
    existing `ngFor` fragment HTML with the following:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'And look at the browser''s console log (a page refresh may be required). There
    are a bunch of errors thrown by the framework, such as:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '`Error: unsafe value used in a resource URL context (see http://g.co/ng/security#xss)`'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: No prize for guessing what is happening! Angular is trying to safeguard our
    application against a **Cross-Site Scripting** (**XSS**) attack.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: Such an attack enables the attacker to inject malicious code into our web pages.
    Once injected, the malicious code can read data from the current site context.
    This allows it to steal confidential data and also impersonate the logged-in user,
    hence gaining access to privileged resources.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: Angular has been designed to block these attacks by sanitizing any external
    code/script that is injected into an Angular view. Remember, content can be injected
    into a view through a number of mechanisms, including property/attribute/style
    bindings or interpolation.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example of binding HTML markup through a component model to the `innerHTML`
    property of an HTML element (property binding):'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: While the HTML content is emitted, any unsafe content (such as a *script*) if
    present is stripped.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: But what about Iframes? In our preceding example, Angular is blocking property
    binding to Iframe's `src` property too. This is a warning against third-party
    content being embedded in our own site using Iframe. Angular prevents this too.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: 'All in all, the framework defines four security contexts around content sanitization.
    These include:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '**HTML content sanitization**, when HTML content is bound using the `innerHTML`
    property'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Style sanitization**, when binding CSS into the `style` property'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**URL sanitization**, when URLs are used with tags such as `anchor` and `img`'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Resource sanitization**, when using `Iframes` or `script` tags; in this case,
    content cannot be sanitized and hence it is blocked by default'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Angular is trying its best to keep us out of danger. But at times, we know that
    the content is safe to render and hence want to circumvent the default sanitization
    behavior.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: Trusting safe content
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To let Angular know that the content being bound is safe, we use `DomSanitizer`
    and call the appropriate method based on the security contexts just described.
    The available functions are as follows:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustHtml`'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustScript`'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustStyle`'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustUrl`'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bypassSecurityTrustResourceUrl`'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our video player implementation, we use `bypassSecurityTrustResourceUrl`;
    it converts the video URL into a trusted `SafeResourceUrl` object:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `map` method transforms the videos array into a collection of `SafeResourceUrl`
    objects and assigns it to `safeVideoUrls`.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: Each of the methods listed previously takes a string parameter. This is the
    content we want Angular to know is safe. The return object, which could be any
    of `SafeStyle`, `SafeHtml`, `SafeScript`, `SafeUrl`, or `SafeResourceUrl`, can
    then be bound to the view.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: A comprehensive treatment of this topic is available in the framework security
    guide available at [http://bit.ly/ng6be-security](http://bit.ly/ng6be-security).
    A highly recommended read!
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: The last question to answer is why do this in the `OnChanges` Angular life cycle
    event?
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: OnChange life cycle event
  id: totrans-574
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `OnChanges` life cycle event is triggered whenever the component's input(s)
    change. In the case of `VideoPlayerComponent`, it is the `videos` array input
    property that changes whenever a new exercise is loaded. We use this life cycle
    event to recreate the `safeVideoUrls` array and re-bind it to the view. Simple!
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: Video panel implementation is now complete. Let's add a few more minor enhancements
    and explore it a bit more in Angular.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: Formatting exercise steps with innerHTML binding
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the sore points in the current app is the formatting of the exercise
    steps. It's a bit difficult to read these steps.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps should either have a line break (`<br>`) or be formatted as an HTML
    `list` for easy readability. This seems to be a straightforward task, and we can
    just go ahead and change the data that is bound to the step interpolation, or
    write a pipe that can add some HTML formatting using the line delimiting convention
    (`.`). For a quick verification, let''s update the first exercise steps in `workout-runner.component.ts`
    by adding a break (`<br>`) after each line:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As the workout restarts, look at the first exercise steps. The output does
    not match our expectations, as shown here:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.gif)'
  id: totrans-582
  prefs: []
  type: TYPE_IMG
- en: The break tags were literally rendered in the browser. Angular did not render
    the interpolation as HTML; instead, it escaped the HTML characters, and we know
    why, security!
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: How to fix it? Easy! Replace the interpolation with the property binding to
    bind step data to the element's `innerHTML` property (in `exercise-description.html`),
    and you are done!
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Refresh the workout page to confirm.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: Preventing Cross-Site Scripting Security (XSS) issues
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: By using `innerHTML`, we instruct Angular to not escape HTML, but Angular still
    sanitizes the input HTML as described in the security section earlier. It removes
    things such as `<script>` tags and other JavaScript to safeguard against XSS attacks.
    If you want to dynamically inject styles/scripts into HTML, use the `DomSanitizer`
    to bypass this sanitization check.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: Time for another enhancement! It's time to learn about Angular pipes.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the remaining workout duration using pipes
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It will be nice if we can tell the user the time left to complete the workout
    and not just the duration of the exercise in progress. We can add a countdown
    timer somewhere in the exercise pane to show the overall time remaining.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: The approach that we are going to take here is to define a component property
    called `workoutTimeRemaining`. This property will be initialized with the total
    time at the start of the workout and will reduce with every passing second until
    it reaches zero. Since `workoutTimeRemaining` is a numeric value, but we want
    to display a timer in the `hh:mm:ss` format, we need to make a conversion between
    the seconds data and the time format. **Angular pipes** are a great option for
    implementing such a feature.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Angular pipes
  id: totrans-593
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary aim of a pipe is to format the data displayed in the view. **Pipes**
    allow us to package this content transformation logic (formatting) as a reusable
    element. The framework itself comes with multiple predefined pipes, such as `date`,
    `currency`, `lowercase`, `uppercase`, `slice`, and others.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we use a pipe with a view:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'An expression is followed by the pipe symbol (`|`), which is followed by the
    pipe name and then an optional parameter (`inputParam1`) separated by a colon
    (`:`). If the pipe takes multiple inputs, they can be placed one after another
    separated by a colon, such as the inbuilt `slice` pipe, which can slice an array
    or string:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The parameter passed to the pipe can be a constant or a component property,
    which implies we can use template expressions with pipe parameter. See the following
    example:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Here are some examples of the use of the `date` pipe, as described in the Angular
    `date` documentation. Assume that `dateObj` is initialized to *June 15,* 2015
    *21:43:11* and locale is *en-US*:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Some of the most commonly used pipes are the following:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '**date**: As we just saw, the date filter is used to format the date in a specific
    manner. This filter supports quite a number of formats and is locale-aware too.
    To know about the other formats supported by the date pipe, check out the framework
    documentation at [http://bit.ly/ng2-date](http://bit.ly/ng2-date).'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**uppercase** and **lowercase**: These two pipes, as the name suggests, change
    the case of the string input.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**decimal** and **percent**: `decimal` and `percent` pipes are there to format
    decimal and percentage values based on the current browser locale.'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**currency**: This is used to format numeric values as a currency based on
    the current browser locale:'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '**json**: This is a handy pipe for debugging that can transform any input into
    a string using `JSON.stringify`. We made good use of it at the start of this chapter
    to render the `WorkoutPlan` object (see the Checkpoint 2.1 code).'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**slice:** This pipe allows us to split a list or a string value to create
    a smaller trimmed down list/string. We saw an example in the preceding code.'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are not going to cover the preceding pipes in detail. From a development
    perspective, as long as we know what pipes are there and what they are useful
    for, we can always refer to the platform documentation for exact usage instructions.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: Pipe chaining
  id: totrans-612
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A really powerful feature of pipes is that they can be chained, where the output
    from one pipe can serve as the input to another pipe. Consider this example:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The first pipe slices the first 20 characters of `fullName` and the second pipe
    transforms them to uppercase.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen what pipes are and how to use them, why not implement
    one for the *7 Minute Workout* app: a **seconds to time** pipe?'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom pipe - SecondsToTimePipe
  id: totrans-617
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SecondsToTimePipe`, as the name suggests, should convert a numeric value into
    the `hh:mm:ss` format.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder `shared` in the `workout-runner` folder and from the shared
    folder invoke this CLI command to generate the pipe boilerplate:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `shared` folder has been created to add common components/directives/pipes
    that can be used in the `workout-runner` module. It is a convention we follow
    to organize shared code at different levels. In the future, we can create a shared
    folder at the app module level, which has artifacts shared globally. In fact,
    if the second to time pipe needs to be used across other application modules,
    it can also be moved into the app module.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the following `transform` function implementation into `seconds-to-time.pipe.ts`(the
    definition can also be downloaded from the Git branch `checkpoint.2.4` on the
    GitHub site at [http://bit.ly/nng6be-2-4-seconds-to-time-pipe-ts](http://bit.ly/nng6be-2-4-seconds-to-time-pipe-ts)):'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In an Angular pipe, the implementation logic goes into the `transform` function.
    Defined as part of the `PipeTransform` interface, the preceding `transform` function
    transforms the input seconds value into an *hh:mm:ss* string. The first parameter
    to the `transform` function is the pipe input. The subsequent parameters, if provided,
    are the arguments to the pipe, passed using a colon separator (`pipe:argument1:arugment2..`)
    from the view.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: For `SecondsToTimePipe`, while Angular CLI generates a boilerplate argument
    (`args?:any`), we do not make use of any pipe argument as the implementation does
    not require it.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: The pipe implementation is quite straightforward, as we convert seconds into
    hours, minutes, and seconds. Then, we concatenate the result into a string value
    and return the value. The addition of 0 on the left for each of the `hours`, `minutes`,
    and `seconds` variables is done to format the value with a leading 0 in case the
    calculated value for hours, minutes, or seconds is less than 10.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: 'The pipe that we just created is just a standard TypeScript class. It''s the
    Pipe decorator (`@Pipe`) that instructs Angular to treat this class as a pipe:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The pipe definition is complete, but to use the pipe in `WorkoutRunnerComponent`
    the pipe has to be declared on `WorkoutRunnerModule.` Angular CLI has already
    done this for us as part of the boilerplate generation (see the `declaration`
    section in `workout-runner.module.ts`).
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just need to add the pipe in the view. Update `workout-runner.component.html`
    by adding the highlighted fragment:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Surprisingly, the implementation is still not complete! There is one more step
    left. We have a pipe definition, and we have referenced it in the view, but `workoutTimeRemaining`
    needs to update with each passing second for `SecondsToTimePipe` to be effective.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already initialized `WorkoutRunnerComponent`''s `workoutTimeRemaining`
    property in the `start` function with the total workout time:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now the question is: how to update the `workoutTimeRemaining` variable with
    each passing second? Remember that we already have a `setInterval` set up that
    updates `exerciseRunningDuration`. While we can write another `setInterval` implementation
    for `workoutTimeRemaining`, it will be better if a single `setInterval` setup
    can take care of both the requirements.'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a function called `startExerciseTimeTracking` to `WorkoutRunnerComponent`;
    it looks as follows:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: As you can see, the primary purpose of the function is to track the exercise
    progress and flip the exercise once it is complete. However, it also tracks `workoutTimeRemaining`
    (it decrements this counter). The first `if` condition setup just makes sure that
    we clear the timer once all the exercises are done. The inner `if` conditions
    are used to keep `currentExerciseIndex` in sync with the running exercise.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: This function uses a numeric instance variable called `exerciseTrackingInterval`.
    Add it to the class declaration section. We are going to use this variable later
    to implement an exercise pausing behavior.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the complete `setInterval` setup from `startExercise` and replace it
    with a call to `this.startExerciseTimeTracking();`. We are all set to test our
    implementation. If required, refresh the browser and verify the implementation:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  id: totrans-641
  prefs: []
  type: TYPE_IMG
- en: The next section is about another inbuilt Angular directive, `ngIf`, and another
    small enhancement.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: Adding the next exercise indicator using ngIf
  id: totrans-643
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It will be nice for the user to be told what the next exercise is during the
    short rest period between exercises. This will help them prepare for the next
    exercise. So let's add it.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: To implement this feature, we can simply output the title of the next exercise
    from the `workoutPlan.exercises` array. We show the title next to the `Time Remaining`
    countdown section.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the workout div (`class="exercise-pane"`) to include the highlighted
    content, and remove existing `Time Remaining` `h1`:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We wrap the existing `Time Remaining h1` and add another `h3` tag to show the
    next exercise inside a new `div` with some style updates. Also, there is a new
    directive, `ngIf`, in the second `h3`. The `*` prefix implies that it belongs
    to the same set of directives that `ngFor` belongs: **structural directives**.
    Let''s talk a bit about `ngIf`.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ngIf` directive is used to add or remove a specific section of the DOM
    based on whether the expression provided to it returns `true` or `false`. The
    DOM element is added when the expression evaluates to `true` and is destroyed
    otherwise. Isolate the `ngIf` declaration from the preceding view:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The directive expression checks whether we are currently in the rest phase and
    accordingly shows or hides the linked `h3`.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: Also in the same `h3`, we have an interpolation that shows the name of the exercise
    from the `workoutPlan.exercises` array.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: 'A word of caution here: `ngIf` adds and destroys the DOM element, and hence
    it is not similar to the visibility constructs that we employed to show and hide
    elements. While the end result of `style`, `display:none` is the same as that
    of `ngIf`, the mechanism is entirely different:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Versus this line:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'With `ngIf`, whenever the expression changes from `false` to `true`, a complete
    re-initialization of the content occurs. Recursively, new elements/components
    are created and data binding is set up, starting from the parent down to the children.
    The reverse happens when the expression changes from `true` to `false`: all of
    this is destroyed. Therefore, using `ngIf` can sometimes become an expensive operation
    if it wraps a large chunk of content and the expression attached to it changes
    very often. But otherwise, wrapping a view in `ngIf` is more performant than using
    CSS/style-based show or hide, as neither the DOM is created nor the data binding
    expressions are set up when the `ngIf` expression evaluates to `false`.'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: 'New version of Angular support branching constructs too. This allows us to
    implement the **if then else** flow in the view HTML. The following sample has
    been lifted directly from the platform documentation of `ngIf`:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `else` binding points to a `ng-template` with template variable `#elseBlock`.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another directive that belongs in this league: `ngSwitch`. When defined
    on the parent HTML, it can swap the child HTML elements based on the `ngSwitch`
    expression. Consider this example:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We bind the `userType` expression to `ngSwitch`. Based on the value of `userType`
    (`admin`, `powerUser`, or any other `userType`), one of the inner div elements
    will be rendered. The `ngSwitchDefault` directive is a wildcard match/fallback
    match, and it gets rendered when `userType` is neither `admin` nor `powerUser`.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not realized it yet, note that there are three directives working
    together here to achieve switch-case-like behavior:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '`ngSwitch`'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngSwitchCase`'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngSwitchDefault`'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coming back to our next exercise implementation, we are ready to verify the
    implementation, start the app, and wait for the rest period. There should be a
    mention of the next exercise during the rest phase, as shown here:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.gif)'
  id: totrans-669
  prefs: []
  type: TYPE_IMG
- en: The app is shaping up well. If you have used the app and done some physical
    workouts along with it, you will be missing the exercise pause functionality badly.
    The workout just does not stop until it reaches the end. We need to fix this behavior.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: Pausing an exercise
  id: totrans-671
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To pause an exercise, we need to stop the timer. We also need to add a button
    somewhere in the view that allows us to pause and resume the workout. We plan
    to do this by drawing a button overlay over the exercise area in the center of
    the page. When clicked on, it will toggle the exercise state between paused and
    running. We will also add keyboard support to pause and resume the workout using
    the key binding `p` or `P`. Let's update the component.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `WorkoutRunnerComponent` class, add these three functions, and add
    a declaration for the `workoutPaused` variable:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The implementation for pausing is simple. The first thing we do is cancel the
    existing `setInterval` setup by calling `clearInterval(this.exerciseTrackingInterval);`.
    While resuming, we again call `startExerciseTimeTracking`, which again starts
    tracking the time from where we left off.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just need to invoke the `pauseResumeToggle` function for the view. Add
    the following content to `workout-runner.html`:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `click` event handler on the div toggles the workout running state, and
    the `ngClass` directive is used to toggle the class between `ion-md-pause` and
    `ion-md-play`- standard Angular stuff. What is missing now is the ability to pause
    and resume on a *P* key press.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach could be to apply a `keyup` event handler on the div:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'But there are some shortcomings to this approach:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: The `div` element does not have a concept of focus, so we also need to add the
    `tabIndex` attribute on the div to make it work
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even then, it works only when we have clicked on the div at least once
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a better way to implement this; attach the event handler to the global
    `window` event `keyup`. This is how the event binding should be applied on the
    `div`:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Make note of the special `window:` prefix before the `keyup` event. We can
    use this syntax to attach events to any global object, such as the `document`.
    A handy and very powerful feature of Angular binding infrastructure! The `onKeyPressed`
    event handler needs to be added to `WorkoutRunnerComponent`. Add this function
    to the class:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The `$event` object is the standard **DOM event object** that Angular makes
    available for manipulation. Since this is a keyboard event, the specialized class
    is `KeyboardEvent`. The `which` property is matched to ASCII values of `p` or
    `P`. Refresh the page and you should see the play/pause icon when your mouse hovers
    over the exercise image, as follows:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  id: totrans-689
  prefs: []
  type: TYPE_IMG
- en: While we are on the topic of **event binding**, it would be a good opportunity
    to explore Angular's event binding infrastructure
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: The Angular event binding infrastructure
  id: totrans-691
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular event binding allows a component to communicate with its parent through
    events.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: If we look back at the app implementation, what we have encountered thus far
    are the property/attribute bindings. Such bindings allow a component/element to
    take inputs from the outside world. The data flows into the component.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: Event bindings are the reverse of property bindings. They allow a component/element
    to inform the outside world about any state change.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in the pause/resume implementation, event binding employs round brackets
    (`()`) to specify the target event:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This attaches a `click` event handler to the `div` that invokes the expression
    `pauseResumeToggle()` when the `div` is clicked.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: 'Like properties, there is a canonical form for events too. Instead of using
    round brackets, the `on-` prefix can be used: `on-click="pauseResumeToggle()"`'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular supports all types of events. Events related to keyboard inputs, mouse
    movements, button clicks, and touches. The framework even allows us to define
    our own event for the components we create, such as:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We will be covering custom component events in the next chapter, where we will
    add audio support to *7 Minute Workout*.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: It is expected that events have side effects; in other words, an event handler
    may change the state of the component, which in turn may trigger a chain reaction
    in which multiple components react to the state change and change their own state.
    This is unlike a property binding expression, which should be side-effect-free.
    Even in our implementation, clicking on the `div` element toggles the exercise
    run state.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: Event bubbling
  id: totrans-703
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Angular attaches event handlers to standard HTML element events, the event
    propagation works in the same way as standard DOM event propagation works. This
    is also called **event bubbling**. Events on child elements are propagated upwards,
    and hence event binding is also possible on a parent element, as follows:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Clicking on either of the divs results in the invocation of the `doWork` function
    on the parent `div`. Moreover, `$event.target` contains the reference to the `div`
    that dispatched the event.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: Custom events created on Angular components do not support event bubbling.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: 'Event bubbling stops if the expression assigned to the target evaluates to
    a `falsey` value (such as `void`, `false`). Therefore, to continue propagation,
    the expression should evaluate to `true`:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Here too, the `$event` object deserves some special attention.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: Event binding an $event object
  id: totrans-711
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular makes an `$event` object available whenever the target event is triggered.
    This `$event` contains the details of the event that occurred.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to note here is that the shape of the `$event` object is
    decided based on the event type. For HTML elements, it is a DOM event object ([https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events)),
    which may vary based on the actual event.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: But if it is a custom component event, what is passed in the `$event` object
    is decided by the component implementation. We will return to this discussion
    again, in the next chapter.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: We have now covered most of the data binding capabilities of Angular, with the
    exception of two-way binding. A quick introduction to the two-way binding constructs
    is warranted before we conclude the chapter.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: Two-way binding with ngModel
  id: totrans-716
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Two-way binding** helps us keep the model and view in sync. Changes to the
    model update the view and changes to the view update the model. The obvious area
    where two-way binding is applicable is form input. Let''s look at a simple example:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The `ngModel` directive here sets a two-way binding between the `input`'s `value`
    property and the `workout.name` property on the underlying component. Anything
    that the user enters in the preceding  `input` is synced with `workout.name`,
    and any changes to `workout.name` are reflected back on the preceding `input`.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, we can achieve the same result without using the `ngModel` directive
    too, by combining both property and event binding syntax. Consider the next example;
    it works in the same way as `input` before:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: There is a property binding set up on the `value` property and an event binding
    set up on the `input` event that make the bidirectional sync work.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: We will get into more details on two-way binding in Chapter 4,* Personal Trainer*,
    where we build our own custom workouts.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created a diagram that summarizes the data flow patterns for all the
    bindings that we have discussed thus far. Here is a handy diagram to help you
    memorize each of the binding constructs and how data flows:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  id: totrans-725
  prefs: []
  type: TYPE_IMG
- en: We now have a fully functional *7 Minute Workout*, with some bells and whistles
    too, and hopefully you had fun creating the app. It's time to conclude the chapter
    and summarize the lessons.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.4`
    for a working version of what we have done thus far. You can also download a snapshot
    of `checkpoint2.4` (a ZIP file) from this GitHub location: [http://bit.ly/ng6be-checkpoint-2-4](http://bit.ly/ng6be-checkpoint-2-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-728
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter with the aim of creating an Angular app that is more
    complex than the sample we created in the first chapter. The *7 Minute Workout*
    app fitted the bill, and you learned a lot about the Angular framework while building
    this app.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: We started by defining the functional specifications of the *7 Minute Workout*
    app. We then focused our efforts on defining the code structure for the app.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: To build the app, we started off by defining the model of the app. Once the
    model was in place, we started the actual implementation by building an **Angular
    component**. Angular components are nothing but classes that are decorated with
    a framework-specific decorator, `@Component`.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about **Angular modules** and how Angular uses them to organize
    code artifacts.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: Once we had a fully functional component, we created a supporting view for the
    app. We also explored the data binding capabilities of the framework, including
    **property**, **attribute**, **class**, **style,** and **event binding**. Plus,
    we highlighted how **interpolations** are a special case of property binding.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: Components are a special class of directives that have an attached view. We
    touched upon what directives are and the special classes of directives, including
    **attribute** and **structural directives**.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to perform cross-component communication using **input properties**.
    The two child components that we put together (`ExerciseDescriptionComponent`
    and `VideoPlayerComponent`) derived their inputs from the parent `WorkoutRunnerComponent`
    using input properties.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: We then covered another core construct in Angular, **pipes**. We saw how to
    use pipes such as the date pipe and how to create one of our own.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the chapter, we touched upon a number of Angular directives, including
    the following:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: '`ngClass/ngStyle`: For applying multiple styles and classes using Angular binding
    capabilities'
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngFor`: For generating dynamic HTML content using a looping construct'
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngIf`: For conditionally creating/destroying DOM elements'
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngSwitch`: For creating/destroying DOM elements using the switch-case construct'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have a basic *7 Minute Workout* app. For a better user experience, we
    have added a number of small enhancements to it too, but we are still missing
    some good-to-have features that would make our app more usable. From the framework
    perspective, we have purposefully ignored some core/advanced concepts such as
    **change detection**, **dependency injection**, **component** **routing**, and
    data flow patterns, which we plan to cover in the next chapter.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
