<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Introduction to ReasonML</h1>
                </header>
            
            <article>
                
<p class="mce-root">The last decade has seen numerous paradigm shifts in the way we build user interfaces. Web applications have moved from server-side frameworks to client-side frameworks in order to provide better user experiences. Devices and browsers have become powerful enough to run robust client-side applications, and the JavaScript language itself has seen many improvements over the years. Progressive web apps provides a native-like user experience and WebAssembly allows for native-like performance <span class="calibre5">on the web platform. An increasing number of applications are being built for the browser, resulting in </span>larger client-side codebases needing to be maintained.</p>
<p class="mce-root">During this period, several frameworks, libraries, tools, and general best practices gained and then lost popularity, resulting in <strong class="calibre4">JavaScript fatigue</strong> for many developers. Companies are becoming increasingly cautious in committing to newer technologies due to their impact on <span class="calibre5">hiring and retaining engineering talent, as well as</span> productivity<span class="calibre5"> and maintainability. It can be an expensive mistake if you introduce the wrong technology (or the right technology at the wrong time) to your team. </span></p>
<p class="mce-root">For many companies and developers, React has proven to be a solid choice. In 2013, Facebook made the library open source after having used it internally since 2011. They challenged us to rethink best practices (<a href="https://www.youtube.com/watch?v=DgVS-zXgMTk&amp;feature=youtu.be" class="calibre8">https://www.youtube.com/watch?v=DgVS-zXgMTk&amp;feature=youtu.be</a>) and it has since taken over frontend development (<a href="https://medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76" class="calibre8">https://medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76</a>). Encapsulating markup, behavior, and style into reusable components has become a huge productivity and maintainability win. The abstraction of the DOM has allowed for components to be simple, declarative functions of its props that are easy to reason about, compose, and test.</p>
<p class="mce-root"><span class="calibre5">Via React, Facebook has done an incredible job educating the frontend-developer community on traditional functional programming paradigms that make it easier to reason about and maintain code. And now, Facebook believes the time is right for ReasonML.</span></p>
<p class="mce-root"/>
<p class="mce-root">This is a two-year chart from <a href="https://www.npmtrends.com/" class="calibre8">npmtrends.com</a> that shows the number of weekly npm downloads for some of the top JavaScript libraries and frameworks. ReactJS looks to be a clear winner and has reached over 2,500,000 downloads per week:</p>
<p class="cdpaligncenter"><img class="aligncenter" src="assets/b5957f88-9ae0-4aaa-ba2a-f1ec78579b88.png"/></p>
<div class="packt_figref">npmtrends.com</div>
<p class="mce-root">In this chapter, we'll do the following:</p>
<ul class="calibre9">
<li class="calibre10">Discuss what ReasonML is and what problems it tries to solve</li>
<li class="calibre10">Understand some of the reasons why Facebook chose ReasonML as the future of ReactJS</li>
<li class="calibre10">Experiment with ReasonML in an online playground and examine its compiled (JavaScript) output</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is ReasonML?</h1>
                </header>
            
            <article>
                
<div class="packt_quote">Reason is a layer of syntax &amp; tooling on top of OCaml, a language Facebook uses actively. Jordan [Walke] started the concept of Reason before React, in fact. We’re taking it and using it as an actual frontend language (among other uses) because we think that after three and half years, the React experiment has succeeded and people are now ready for Reason...</div>
<div class="packt_quote1"><span>– Cheng Lou, January, 2017 <br class="title-page-name"/></span> <span>(</span><a href="https://www.reactiflux.com/transcripts/cheng-lou/" class="calibre17">https://www.reactiflux.com/transcripts/cheng-lou/</a><span>)</span></div>
<p class="mce-root">Let's expand on this quote. ReasonML is not a new language; it's a new syntax for the OCaml language that is meant to be familiar to JavaScript developers. Reason, as we'll call it from now on, has the exact same AST as OCaml, so Reason and OCaml only differ by syntax. The semantics are the same. By learning Reason, you're also learning OCaml. In fact, there's a command-line tool that converts between OCaml and Reason syntax, called <kbd class="calibre11">refmt</kbd>, which formats Reason/OCaml code similar to JavaScript's prettier—in fact, prettier was inspired by <kbd class="calibre11">refmt</kbd>.</p>
<p class="mce-root">OCaml is a general-purpose programming language with an emphasis on expressiveness and safety. It was initially released in 1996 and has an advanced type system that helps catch your mistakes without getting in the way. Like JavaScript, OCaml features garbage collection for automatic memory management and first-class functions that can be passed around as arguments to other functions. </p>
<p class="mce-root">Reason is also a toolchain that makes getting started easier for those coming from a JavaScript background. This toolchain allows us to take advantage of both the JavaScript and OCaml ecosystems. We will dive deeper here in <a href="4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml" target="_blank" class="calibre8">Chapter 2</a>, <em class="calibre15">Setting Up a Development Environment</em>. For now, we'll experiment directly in the online playground by visiting Reason's online playground at <a href="https://reasonml.github.io/try" class="calibre8">https://reasonml.github.io/try</a>.</p>
<p class="mce-root">Try typing in this Hello World example into the online playground:</p>
<pre class="calibre16">let message = "World";<br class="title-page-name"/>Js.log("Hello " ++ message);</pre>
<p class="mce-root">There are two things you'll notice:</p>
<ul class="calibre9">
<li class="calibre10">The OCaml syntax is automatically generated in the lower-left section of the editor (not shown)</li>
<li class="calibre10">The Reason/OCaml code is compiled to JavaScript directly in the browser:</li>
</ul>
<pre class="calibre18">// Generated by BUCKLESCRIPT VERSION 3.2.0, PLEASE EDIT WITH CARE<br class="title-page-name"/>'use strict';<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>var message = "World";<br class="title-page-name"/><br class="title-page-name"/>console.log("Hello World");<br class="title-page-name"/><br class="title-page-name"/>exports.message = message;<br class="title-page-name"/>/* Not a pure module */</pre>
<p class="mce-root"><span class="calibre5">You may be wondering how the Reason/OCaml code is being compiled from within the browser. BuckleScript, Reason's partner project, compiles the OCaml AST to JavaScript. Since Reason and OCaml both get converted into the same OCaml AST, BuckleScript supports both Reason and OCaml. Furthermore, since BuckleScript is itself written in OCaml, it can be compiled to JavaScript and run directly in the browser.</span></p>
<p class="mce-root">Inspecting the compiled JavaScript reveals just how readable it is. Looking closer, you'll notice that the compiled output has also been optimized: within the <kbd class="calibre11">console.log</kbd> statement, the <kbd class="calibre11">"Hello World"</kbd> string has been inlined directly instead of using the <kbd class="calibre11">message</kbd> variable.</p>
<div class="packt_quote"><span>BuckleScript, using features of the OCaml type-system and compiler implementation is able to provide many optimizations during offline compilation, allowing the runtime code to be extremely fast.</span></div>
<div class="packt_quote1"><span>– BuckleScript docs <br class="title-page-name"/></span>(<a href="https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript" class="calibre17">https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript</a><a href="https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript" class="calibre17">)</a></div>
<p class="mce-root">Notably, BuckleScript also supports string interpolation (<a href="https://bucklescript.github.io/docs/en/common-data-types.html#interpolation" class="calibre8">https://bucklescript.github.io/docs/en/common-data-types.html#interpolation</a>):</p>
<pre class="calibre16">/* The message variable is interpolated */<br class="title-page-name"/>{j|Hello $message|j}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why Reason?</h1>
                </header>
            
            <article>
                
<p class="mce-root">What makes Reason so compelling? What can<span class="calibre5"> Reason do that TypeScript or Flow cannot? Is it just about having a static type-checker? These are some of the questions I had when first getting started with Reason.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Support for immutability and purity</h1>
                </header>
            
            <article>
                
<p class="mce-root">Reason isn't just about having a static type system. Also important is the fact that Reason is immutable by default. Immutability is an important concept in functional programming. <span class="calibre5">In practice, using immutable data structures (data structures that can't change) results in safer, easier-to-reason-about, and more maintainable code than their mutable counterparts. This will be a recurring theme throughout this book.</span></p>
<p class="mce-root"><span class="calibre5">Purity is another important concept in functional programming. A function is said to be</span> pure if its output is determined only by its input, without observable side-effects. In other words, a pure function doesn't do anything outside of returning a value. The following is an example of a pure function:</p>
<pre class="calibre16">let add = (a, b) =&gt; a + b;</pre>
<p class="mce-root">And, this is an example of an impure function:</p>
<pre class="calibre16">let add = (a, b) =&gt; {<br class="title-page-name"/>  Js.log("side-effect");<br class="title-page-name"/>  a + b;<br class="title-page-name"/>};</pre>
<p class="mce-root">The side-effect in this case is writing to the browser's console. That's why, in our preceding <kbd class="calibre11">Hello World</kbd> example, BuckleScript included the <kbd class="calibre11"><span>/* Not a pure module */</span></kbd> comment at the end of the compiled output.</p>
<p class="mce-root">Mutating a global variable is also a side-effect. Consider the following JavaScript:</p>
<pre class="calibre16">var globalObject = {total: 0};<br class="title-page-name"/>const addAndMutate = (a, b) =&gt; globalObject.total = a + b;<br class="title-page-name"/>addAndMutate(40, 2);<br class="title-page-name"/>/* globalObject now is mutated */</pre>
<p class="mce-root">The global object was mutated, and now its <kbd class="calibre11">total</kbd> property is <kbd class="calibre11">42</kbd>. We now have to be aware of all areas where this <kbd class="calibre11">globalObject</kbd> is mutated whenever using it. Forgetting that this object is both global and mutable can lead to hard-to-debug problems. One idiomatic solution to this problem is to move <kbd class="calibre11">globalObject</kbd> into a module where it's no longer global. This way, only that module has access to it. However, we'd still need to be aware of all areas within this module that can update the object.</p>
<p class="mce-root">If <kbd class="calibre11">globalObject</kbd> was immutable instead, there would be no way to mutate it. Therefore, we wouldn't need an awareness of all the areas that can mutate <kbd class="calibre11">globalObject</kbd>, since there wouldn't be any of these areas. We'll see that, with Reason, it's fairly simple and natural to build real applications in this way by creating updated copies of the original data. Consider the following:</p>
<pre class="calibre16">let foo = 42;<br class="title-page-name"/>let foo = foo + 1;<br class="title-page-name"/>Js.log(foo);<br class="title-page-name"/>/* 43 */</pre>
<p class="mce-root">The syntax feels quite natural. As we'll see later in this book, immutability—changing by returning updated copies instead of applying destructive changes in place—fits the React/Redux way of doing things quite well.</p>
<p class="mce-root">The original <kbd class="calibre11">foo</kbd> was not mutated; it was shadowed. Once shadowed, the old <kbd class="calibre11">foo</kbd> binding is unavailable. Bindings can be shadowed in local scopes as well as global scopes:</p>
<pre class="calibre16">let foo = 42;<br class="title-page-name"/><br class="title-page-name"/>{<br class="title-page-name"/>  let foo = 43;<br class="title-page-name"/>  Js.log(foo); /* 43 */<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>Js.log(foo); /* 42 */<br class="title-page-name"/><br class="title-page-name"/>let foo = 43;<br class="title-page-name"/>Js.log(foo); /* 43 */</pre>
<p class="mce-root">Trying to mutate <kbd class="calibre11">foo</kbd> results in a compilation error:</p>
<pre class="calibre16">let foo = 42;<br class="title-page-name"/>foo = 43;<br class="title-page-name"/>/* compilation error */</pre>
<p class="mce-root">We can see that immutability and purity are related topics. Having a language that supports immutability allows you to program in a pure way without side-effects. However, what if there are times when purity would cause the code to become more complex and harder to reason about than using side-effects? <span class="calibre5">You may be relieved to learn that Reason (interchangeable with OCaml throughout the rest of this book) is a pragmatic language that let's us cause side-effects when needed.</span></p>
<div class="packt_quote">The key thing when using a language like [Reason] is not to avoid side-effects, because avoiding side-effects is equivalent to avoiding doing anything useful. It turns out, in reality, programs don't just <em class="calibre19">compute</em> things, they <em class="calibre19">do </em>things. They send messages and they write files and they do all sorts of stuff. The doing of things is automatically involving side-effects. The thing that a language which supports purity gives you, is it gives you the ability to, by and large, segment out the part that is side-effecting to clear and controlled areas of your code, and that makes it much easier to reason about.</div>
<div class="packt_quote1"><span>– Yaron Minsky<br class="title-page-name"/></span> <span>(</span><a href="https://www.youtube.com/watch?v=-J8YyfrSwTk&amp;feature=youtu.be&amp;t=47m29s" class="calibre17">https://www.youtube.com/watch?v=-J8YyfrSwTk&amp;feature=youtu.be&amp;t=47m29s</a><span>)</span></div>
<p class="mce-root">It's also important to know that immutability doesn't come at the cost of performance. Under the hood, there are optimizations in place that keeps Reason's immutable data structures fast.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Module system</h1>
                </header>
            
            <article>
                
<p class="mce-root">Reason has a sophisticated module system that allows for modular development and code organization. <span class="calibre5">A</span><span class="calibre5">ll modules are globally available in Reason, and m</span>odule interfaces can be used to hide implementation details when needed. We will be exploring this concept in <a href="86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml" target="_blank" class="calibre8">Chapter 5</a>, <em class="calibre15">Effective ML</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type system</h1>
                </header>
            
            <article>
                
<p class="mce-root">Reason's type system is sound, which means that, once compiled, there won't be runtime type errors. There is no <kbd class="calibre11">null</kbd> in the language, nor are there any bugs related to <kbd class="calibre11">null</kbd>. In JavaScript, when something is of the <kbd class="calibre11">number</kbd> type, it can also be <kbd class="calibre11">null</kbd>. Reason uses a special type for things that can also be <kbd class="calibre11">null</kbd>, and forces the developer to handle those cases appropriately by refusing to compile otherwise.</p>
<p class="mce-root">So far, we've already written some, albeit basic, Reason code without even talking about types. Reason infers types automatically. As we'll learn throughout this book, the type system is a tool that provides guarantees without getting in our way, and when used properly, can allow us to offload things <span class="calibre5">to the compiler</span> that we used to keep in our heads.</p>
<p class="mce-root">Reason's support for immutable programming, sound type system, and sophisticated module system are big parts of why Reason is so great, and there's something to be said about using all of these features together in one language that was built with these features in mind. When Facebook initially released React, they asked us to give it five minutes (<a href="https://signalvnoise.com/posts/3124-give-it-five-minutes" class="calibre8">https://signalvnoise.com/posts/3124-give-it-five-minutes</a>) and, hopefully, that same frame of mind will pay off here as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cross-platform</h1>
                </header>
            
            <article>
                
<p class="mce-root">Building React applications with Reason is a lovely experience and, what's more, since OCaml is able to compile to native, we will be able to use these same skills to build apps that compile to assembly, iOS/Android, and much more. In fact, Jared Forsyth has already created a game called Gravitron (<a href="https://github.com/jaredly/gravitron" class="calibre8">https://github.com/jaredly/gravitron</a>) that compiles to iOS, Android, web, and macOS from one Reason codebase. That being said, the frontend JavaScript story is much more polished as of this writing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maintainability</h1>
                </header>
            
            <article>
                
<p class="mce-root">Reason may take some time to get comfortable with, but you can think of this time as an investment in the maintenance and confidence of your future product. Although languages with gradual type systems, such as TypeScript, may be easier to get started with, they don't provide the sorts of guarantees that a sound type system such as Reason's can provide. Reason's true benefits cannot be completely conveyed within simple examples, and only really shine when they save you time and energy in reasoning about, refactoring, and maintaining your code. Put it this way; if someone told me they were 99% sure a spider wasn't in my bed, I would still have to check the entire bed because I don't like bugs!</p>
<p class="mce-root">As long as you're 100% in Reason and your code compiles, the type system guarantees there will be no runtime type errors. It's true that when you are interoperating with non-Reason code (JavaScript, for example), you introduce the possibility of runtime type errors. Reason's sound type system allows you to trust that the Reason parts of the application won't cause runtime type errors, which therefore allows you to focus extra attention on ensuring that these areas of the application are safe. In my experience, programming in a dynamic language can feel noticeably dangerous. Reason on the other hand feels like it always has your back.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interoperability</h1>
                </header>
            
            <article>
                
<p class="mce-root">That being said, sometimes—and especially when first learning about type systems—you may be unsure as to how to get your code to compile. Reason, through BuckleScript, allows you to drop down to raw JavaScript when you need to, either via bindings or directly inside your Reason (<kbd class="calibre11">.re</kbd>) files. This gives you the freedom to figure things out as you go along in JavaScript, and then once you're ready, convert that section of the code to type-safe Reason.</p>
<p class="mce-root">BuckleScript also lets us bind to idiomatic JavaScript in a very reasonable way. As you'll learn in <a href="201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml" target="_blank" class="calibre8">Chapter 4</a>, <em class="calibre15">BuckleScript, Belt, and Interoperability</em>, BuckleScript is an incredibly powerful part of Reason.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ES2030</h1>
                </header>
            
            <article>
                
<p class="mce-root">Writing in Reason feels like writing in a future version of JavaScript. Some Reason language features, including the pipe operator (<a href="https://github.com/tc39/proposal-pipeline-operator" class="calibre8">https://github.com/tc39/proposal-pipeline-operator</a>) and pattern matching (<a href="https://github.com/tc39/proposal-pattern-matching" class="calibre8">https://github.com/tc39/proposal-pattern-matching</a>), are currently being proposed to the TC39 Committee to add into the JavaScript language. With Reason, we can take advantage of these features, and much more, today.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Community</h1>
                </header>
            
            <article>
                
<p class="mce-root">The Reason community is, hands down, one of the most helpful, supportive, and inclusive communities I've ever been a part of. If you have a question, or are stuck on something, the Reason Discord channel is the place to go for realtime support.</p>
<div class="packt_infobox">Reason Discord channel:<br class="title-page-name"/>
<br class="title-page-name"/>
<a href="https://discord.gg/reasonml" class="calibre17">https://discord.gg/reasonml</a></div>
<p class="mce-root">Often, when starting with a new technology, talking to someone with experience for five minutes can save you hours of frustration. I've personally asked questions at all hours of the day (and night) and am so incredibly <span class="calibre5">grateful</span> for and amazed by how quickly someone helps me out. Take a moment to join the Discord channel, introduce yourself, ask questions, and share your feedback on how to make Reason better!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Future of ReactJS</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="calibre5">In practice, few real-world applications use </span>just<span class="calibre5"> ReactJS. Additional technologies, such as Babel, ESLint, Redux, Flow/TypeScript, and Immutable.js, are typically brought in to help increase the maintainability of a codebase. Reason replaces the need for these additional technologies with its core language features.</span></p>
<p class="mce-root">ReasonReact is a Reason library that binds to ReactJS and provides a simpler, safer way to build ReactJS components. Just like ReactJS is just JavaScript, ReasonReact is just Reason. Additionally, it's easy to incrementally adopt because it was made by the same person who created ReactJS.</p>
<p class="mce-root">ReasonReact comes with a built in router, Redux-like data management, and JSX. You'll feel quite at home coming from a ReactJS background.</p>
<p class="mce-root">It's important to mention that Reason/ReasonReact is already being used by several companies in production, including within one of the largest codebases in the world. Facebook's messenger.com codebase is already over 50% converted to ReasonReact.</p>
<div class="packt_quote"><span>Every ReasonReact feature has been extensively tested on the messenger.com codebase.<br class="title-page-name"/></span></div>
<div class="packt_quote1"><span>– </span><span>Cheng Lou<br class="title-page-name"/>
(</span><a href="https://reason.town/reason-philosophy" class="calibre17">https://reason.town/reason-philosophy</a><span>)</span></div>
<p class="mce-root">As a result, new releases of Reason and ReasonReact come with code mods that automate much, if not all, of the upgrade process for your code base. New features are thoroughly tested internally at Facebook before they're released to the public, and this results in a pleasant developer experience.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring Reason</h1>
                </header>
            
            <article>
                
<p class="mce-root">Ask yourself whether the following is a statement or an expression:</p>
<pre class="calibre16">let foo = "bar";</pre>
<p class="mce-root">In JavaScript, it's a statement, but in Reason, it's an expression. Another example of an expression is <kbd class="calibre11">4 + 3</kbd>, which can also be represented as <kbd class="calibre11">4 + (2 + 1)</kbd>.</p>
<p class="mce-root">Many things in Reason are expressions, including control structures such as <kbd class="calibre11">if-else</kbd>, <kbd class="calibre11">switch</kbd>, <kbd class="calibre11">for</kbd> and <kbd class="calibre11">while</kbd>:</p>
<pre class="calibre16">let message = if (true) {<br class="title-page-name"/>  "Hello"<br class="title-page-name"/>} else {<br class="title-page-name"/>  "Goodbye"<br class="title-page-name"/>};</pre>
<p class="mce-root">We also have ternaries in Reason. Here is another way to express the preceding code:</p>
<pre class="calibre16">let message = true ? "Hello" : "Goodbye";</pre>
<p class="mce-root">Even anonymous block scopes are expressions that evaluate to the last line's expression:</p>
<pre class="calibre16">let message = {<br class="title-page-name"/>  let part1 = "Hello";<br class="title-page-name"/>  let part2 = "World";<br class="title-page-name"/>  {j|$part1 $part2|j};<br class="title-page-name"/>};<br class="title-page-name"/>/* message evaluates to "Hello World" */<br class="title-page-name"/>/* part1 and part2 are not accessible here */</pre>
<p class="mce-root">A <kbd class="calibre11">tuple</kbd> is an immutable data structure that can hold different types of values and can be of any length:</p>
<pre class="calibre16">let tuple = ("one", 2, "three");</pre>
<p class="mce-root">Let's use what we know so far and dive right in with the <kbd class="calibre11">FizzBuzz</kbd> example from Reason's online playground. <kbd class="calibre11">FizzBuzz</kbd> was a popular interview question to determine whether a candidate is able to code. The challenge is to write a problem that prints the numbers from <kbd class="calibre11">1</kbd> to <kbd class="calibre11">100</kbd>, but instead prints <kbd class="calibre11">Fizz</kbd> for multiples of three, <kbd class="calibre11">Buzz</kbd> for multiples of five, and <kbd class="calibre11">FizzBuzz</kbd> for multiples of both three and five:</p>
<pre class="calibre16">/* Based on https://rosettacode.org/wiki/FizzBuzz#OCaml */<br class="title-page-name"/>let fizzbuzz = (i) =&gt;<br class="title-page-name"/>  switch (i mod 3, i mod 5) {<br class="title-page-name"/>  | (0, 0) =&gt; "FizzBuzz"<br class="title-page-name"/>  | (0, _) =&gt; "Fizz"<br class="title-page-name"/>  | (_, 0) =&gt; "Buzz"<br class="title-page-name"/>  | _ =&gt; string_of_int(i)<br class="title-page-name"/>  };<br class="title-page-name"/><br class="title-page-name"/>for (i in 1 to 100) {<br class="title-page-name"/>  Js.log(fizzbuzz(i))<br class="title-page-name"/>};</pre>
<p class="mce-root">Here, <kbd class="calibre11">fizzbuzz</kbd> is a function that accepts an integer and returns a string. An imperative <kbd class="calibre11">for</kbd> loop logs its output to the console.</p>
<p class="mce-root">In Reason, a function's last expression becomes the function's return value. The <kbd class="calibre11">switch</kbd> expression is the only <kbd class="calibre11">fizzbuzz</kbd> expression, so whatever that evaluates to becomes the output of <kbd class="calibre11">fizzbuzz</kbd>. Like JavaScript, the <kbd class="calibre11">switch</kbd> evaluates an expression and the first matched case gets its branch executed. In this case, the <kbd class="calibre11">switch</kbd> evaluates the tuple expression: <kbd class="calibre11">(i mod 3, i mod 5)</kbd>.</p>
<p class="mce-root">Given <kbd class="calibre11">i=1</kbd>, <kbd class="calibre11">(i mod 3, i mod 5)</kbd> becomes <kbd class="calibre11">(1, 1)</kbd>. Since <kbd class="calibre11">(1, 1)</kbd> isn't matched by <kbd class="calibre11">(0, 0)</kbd>, <kbd class="calibre11">(0, _)</kbd>, or <kbd class="calibre11">(_, 0)</kbd>, in that order, the last case of <kbd class="calibre11">_</kbd> (that is, <em class="calibre15">anything</em>) is matched, and <kbd class="calibre11">"1"</kbd> is returned. Similarly, <kbd class="calibre11">fizzbuzz</kbd> returns <kbd class="calibre11">"2"</kbd> when given <kbd class="calibre11">i=2</kbd>. When given <kbd class="calibre11">i=3</kbd>, <kbd class="calibre11">"Fizz"</kbd> is returned.</p>
<p class="mce-root">Alternatively, we could have implemented <kbd class="calibre11">fizzbuzz</kbd> using <kbd class="calibre11">if-else</kbd>:</p>
<pre class="calibre16">let fizzbuzz = (i) =&gt;<br class="title-page-name"/>  if (i mod 3 == 0 &amp;&amp; i mod 5 == 0) {<br class="title-page-name"/>    "FizzBuzz"<br class="title-page-name"/>  } else if (i mod 3 == 0) {<br class="title-page-name"/>    "Fizz"<br class="title-page-name"/>  } else if (i mod 5 == 0) {<br class="title-page-name"/>    "Buzz"<br class="title-page-name"/>  } else {<br class="title-page-name"/>    string_of_int(i)<br class="title-page-name"/>  };</pre>
<p class="mce-root">However, the switch version is much more readable. And as we'll see later in this chapter, the switch expression, also called <strong class="calibre4">pattern matching</strong>, is much more powerful than we've seen so far.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data structures and types</h1>
                </header>
            
            <article>
                
<p class="mce-root">A type is a set of values. More concretely, <kbd class="calibre11">42</kbd> has the <kbd class="calibre11">int</kbd> type because it's a value that's contained in the set of integers. A float is a number that includes a decimal point, that is, <kbd class="calibre11">42.</kbd> and <kbd class="calibre11">42.0</kbd>. In Reason, integers and floating point numbers have separate operators:</p>
<pre class="calibre16">/* + for ints */<br class="title-page-name"/>40 + 2;<br class="title-page-name"/><br class="title-page-name"/>/* +. for floats */<br class="title-page-name"/>40. +. 2.;</pre>
<p class="mce-root">The same is true for <kbd class="calibre11">-.</kbd>, <kbd class="calibre11">-</kbd>, <kbd class="calibre11">*.</kbd>, <kbd class="calibre11">*</kbd>, <kbd class="calibre11">/.</kbd>, and <kbd class="calibre11">/</kbd>.</p>
<p class="mce-root">Reason uses double quotes for the <kbd class="calibre11">string</kbd> type and single quotes for the <kbd class="calibre11">char</kbd> type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating our own types</h1>
                </header>
            
            <article>
                
<p class="mce-root">We can also create our types:</p>
<pre class="calibre16">type person = (string, int);<br class="title-page-name"/><br class="title-page-name"/>/* or */<br class="title-page-name"/><br class="title-page-name"/>type name = string;<br class="title-page-name"/>type age = int;<br class="title-page-name"/>type person = (name, age);</pre>
<p class="mce-root">Here's how we create a person of the <kbd class="calibre11">person</kbd> type:</p>
<pre class="calibre16">let person = ("Zoe", 3);</pre>
<p class="mce-root">We can also annotate any expression with its type:</p>
<pre class="calibre16">let name = ("Zoe" : string);<br class="title-page-name"/>let person = ((name, 3) : person);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pattern matching</h1>
                </header>
            
            <article>
                
<p class="mce-root">We can use pattern matching on our person:</p>
<pre class="calibre16">switch (person) {<br class="title-page-name"/>| ("Zoe", age) =&gt; {j|Zoe, $age years old|j}<br class="title-page-name"/>| _ =&gt; "another person"<br class="title-page-name"/>};</pre>
<p class="mce-root">Let's use a record instead of a tuple for our person. Records are similar JavaScript objects except they're much lighter and are immutable by default:</p>
<pre class="calibre16"><span>type</span><span> person = {<br class="title-page-name"/>  age: int,<br class="title-page-name"/>  name: string<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>let person = {<br class="title-page-name"/>  name: "Zoe",<br class="title-page-name"/>  age: 3<br class="title-page-name"/>};</span></pre>
<p class="mce-root">We can use pattern matching on records too:</p>
<pre class="calibre16">switch (person) {<br class="title-page-name"/>| {name: "Zoe", age} =&gt; {j|Zoe, $age years old|j}<br class="title-page-name"/>| _ =&gt; "another person"<br class="title-page-name"/>};</pre>
<p class="mce-root">Like JavaScript, <kbd class="calibre11">{name: "Zoe", age: age}</kbd> can be represented as <kbd class="calibre11">{name: "Zoe", age}</kbd>.</p>
<p class="mce-root">We can create a new record from an existing one using the spread ( <kbd class="calibre11">...</kbd> ) operator:</p>
<pre class="calibre16">let person = {...person, age: person.age + 1};</pre>
<p class="mce-root">Records require type definitions before they can be used. Otherwise, the compiler will error with something like the following:</p>
<pre class="calibre16"><span>The record field name can't be found.<br class="title-page-name"/></span></pre>
<p class="mce-root">A record must be the same shape as its type. Therefore, we cannot add arbitrary fields to our <kbd class="calibre11">person</kbd> record:</p>
<pre class="calibre16">let person = {...person, favoriteFood: "broccoli"};<br class="title-page-name"/><br class="title-page-name"/>/*<br class="title-page-name"/><span>  We've found a bug for you!</span>

  This record expression is expected to have type person
  The field favoriteFood does not belong to type person<br class="title-page-name"/>*/</pre>
<p class="mce-root">Tuples and records are examples of product types. In our recent examples, our <kbd class="calibre11">person</kbd> type required both an <kbd class="calibre11">int</kbd> and an <kbd class="calibre11">age</kbd>. Almost all of JavaScript's data structures are product types; one exception is the <kbd class="calibre11">boolean</kbd> type, which is either <kbd class="calibre11">true</kbd> or <kbd class="calibre11">false</kbd>.</p>
<p class="mce-root">Reason's variant type, which is an example of a sum type, allows us to express this or that. We can define the <kbd class="calibre11">boolean</kbd> type as a variant:</p>
<pre class="calibre16">type bool =<br class="title-page-name"/>  | True<br class="title-page-name"/>  | False;</pre>
<p class="mce-root">We can have as many constructors as we need:</p>
<pre class="calibre16">type decision =<br class="title-page-name"/>  | Yes<br class="title-page-name"/>  | No<br class="title-page-name"/>  | Maybe;</pre>
<p class="mce-root"><kbd class="calibre11">Yes</kbd>, <kbd class="calibre11">No</kbd>, and <kbd class="calibre11">Maybe</kbd> are called constructors because we can use them to construct values. They're also commonly called <strong class="calibre4">tags</strong>. Because these tags can construct values, variants are both a type and a data structure:</p>
<pre class="calibre16">let decision = Yes;</pre>
<p class="mce-root">And, of course, we can pattern match on <kbd class="calibre11">decision</kbd>:</p>
<pre class="calibre16">switch (decision) {<br class="title-page-name"/>| Yes =&gt; "Let's go."<br class="title-page-name"/>| No =&gt; "I'm staying here."<br class="title-page-name"/>| Maybe =&gt; "Convince me."<br class="title-page-name"/>};</pre>
<p class="mce-root">If we were to forget to handle a case, the compiler would warn us:</p>
<pre class="calibre16">switch (decision) {<br class="title-page-name"/>| Yes =&gt; "Let's go."<br class="title-page-name"/>| No =&gt; "I'm staying here."<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>/*<br class="title-page-name"/><span>  Warning number 8</span>

  You forgot to handle a possible value here, for example: 
  Maybe<br class="title-page-name"/>*/</pre>
<p class="mce-root">As we'll learn in <a href="4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml" target="_blank" class="calibre8">Chapter 2</a>, <em class="calibre15">Setting Up a Development Environment</em>, the compiler can be configured to turn this warning into an error. Let's see one way to help make our code more resilient to future refactors by taking advantage of these exhaustiveness checks.</p>
<p class="mce-root">Take the following example where we are tasked with calculating the price of a concert venue's seat given its section. Floor seats are $55, while all other seats are $45:</p>
<pre class="calibre16">type seat =<br class="title-page-name"/>  | Floor<br class="title-page-name"/>  | Mezzanine<br class="title-page-name"/>  | Balcony;<br class="title-page-name"/><br class="title-page-name"/>let getSeatPrice = (seat) =&gt;<br class="title-page-name"/>  switch(seat) { <br class="title-page-name"/>  | Floor =&gt; 55<br class="title-page-name"/>  | _ =&gt; 45<br class="title-page-name"/>  };</pre>
<p class="mce-root">If, later, the concert venue allows the sale of seats in the orchestra pit area for $65, we would first add another constructor to <kbd class="calibre11">seat</kbd>:</p>
<pre class="calibre16">type seat =<br class="title-page-name"/>  | Pit<br class="title-page-name"/>  | Floor<br class="title-page-name"/>  | Mezzanine<br class="title-page-name"/>  | Balcony;</pre>
<p class="mce-root">However, due to the usage of the catch-all <kbd class="calibre11">_</kbd> case, our compiler doesn't complain after this change. It would be much better if it did since that would help us during our refactoring process. Stepping through compiler messages after changing type definitions is how Reason (and the ML family of languages in general) makes refactoring and extending code a safer, more pleasant process. This is, of course, not limited to variant types. Adding another field to our <kbd class="calibre11">person</kbd> type would also result in the same process of stepping through compiler messages.</p>
<p class="mce-root">Instead, we should reserve using <kbd class="calibre11">_</kbd> for an infinite number of cases (such as our <kbd class="calibre11">fizzbuzz</kbd> example). We can refactor <kbd class="calibre11">getSeatPrice</kbd> to use explicit cases instead:</p>
<pre class="calibre16">let getSeatPrice = (seat) =&gt;<br class="title-page-name"/>  switch(seat) { <br class="title-page-name"/>  | Floor =&gt; 55<br class="title-page-name"/>  | Mezzanine | Balcony =&gt; 45<br class="title-page-name"/>  };</pre>
<p class="mce-root">Here, we welcome the compiler nicely informing us of our unhandled case and then add it:</p>
<pre class="calibre16">let getSeatPrice = (seat) =&gt;<br class="title-page-name"/>  switch(seat) {<br class="title-page-name"/>  | Pit =&gt; 65<br class="title-page-name"/>  | Floor =&gt; 55<br class="title-page-name"/>  | Mezzanine | Balcony =&gt; 45<br class="title-page-name"/>  };</pre>
<p class="mce-root">Let's now imagine that each seat, even ones in the same section (that is, ones that have the same tag) can have different prices. Well, Reason variants can also hold data:</p>
<pre class="calibre16">type seat =<br class="title-page-name"/>  | Pit(int)<br class="title-page-name"/>  | Floor(int)<br class="title-page-name"/>  | Mezzanine(int)<br class="title-page-name"/>  | Balcony(int);<br class="title-page-name"/><br class="title-page-name"/>let seat = Floor(57);</pre>
<p class="mce-root">And we can access this data with pattern matching:</p>
<pre class="calibre16">let getSeatPrice = (seat) =&gt;<br class="title-page-name"/>  switch (seat) {<br class="title-page-name"/>  | Pit(price)<br class="title-page-name"/>  | Floor(price)<br class="title-page-name"/>  | Mezzanine(price)<br class="title-page-name"/>  | Balcony(price) =&gt; price<br class="title-page-name"/>  };</pre>
<p class="mce-root"/>
<p class="mce-root">Variants are not just limited to one piece of data. Let's imagine that we want our <kbd class="calibre11">seat</kbd> type to store its price as well as whether it's still available. If it's not available, it should store the ticket holder's information:</p>
<pre class="calibre16">type person = {<br class="title-page-name"/>  age: int,<br class="title-page-name"/>  name: string,<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>type seat =<br class="title-page-name"/>  | Pit(int, option(person))<br class="title-page-name"/>  | Floor(int, option(person))<br class="title-page-name"/>  | Mezzanine(int, option(person))<br class="title-page-name"/>  | Balcony(int, option(person));</pre>
<p class="mce-root">Before explaining what the <kbd class="calibre11">option</kbd> type is, let's have a look at its implementation:</p>
<pre class="calibre16">type option('a)<br class="title-page-name"/>  | None<br class="title-page-name"/>  | Some('a);</pre>
<p class="mce-root">The <kbd class="calibre11">'a</kbd> in the preceding code is called a <strong class="calibre4">type variable</strong>. Type variables always start with a <kbd class="calibre11">'</kbd>. This type definition uses a type variable so that it could work for any type. If it didn't, we would need to create a <kbd class="calibre11">personOption</kbd> type that would only work for the <kbd class="calibre11">person</kbd> type:</p>
<pre class="calibre16">type personOption(person)<br class="title-page-name"/>  | None<br class="title-page-name"/>  | Some(person);</pre>
<p class="mce-root">What if we wanted an option for another type as well? Instead of repeating this type declaration over and over, we declare a polymorphic type. A polymorphic type is a type that includes a type variable. The <kbd class="calibre11">'a</kbd> (pronounced alpha) type variable will be swapped with <kbd class="calibre11">person</kbd> in our example. Since this type definition is so common, it's included in Reason's standard library, so there's no need to declare the <kbd class="calibre11">option</kbd> type in your code.</p>
<p class="mce-root">Jumping back to our <kbd class="calibre11">seat</kbd> example, we store its price as an <kbd class="calibre11">int</kbd> and its holder as an <kbd class="calibre11">option(person)</kbd>. If there's no holder, it's still available. We could have an <kbd class="calibre11">isAvailable</kbd> function that would take a <kbd class="calibre11">seat</kbd> and return a <kbd class="calibre11">bool</kbd>:</p>
<pre class="calibre16">let isAvailable = (seat) =&gt;<br class="title-page-name"/>  switch (seat) {<br class="title-page-name"/>  | Pit(_, None)<br class="title-page-name"/>  | Floor(_, None)<br class="title-page-name"/>  | Mezzanine(_, None)<br class="title-page-name"/>  | Balcony(_, None) =&gt; true<br class="title-page-name"/>  | _ =&gt; false<br class="title-page-name"/>  };</pre>
<p class="mce-root">Let's take a step back and look at the implementations of <kbd class="calibre11">getSeatPrice</kbd> and <kbd class="calibre11">isAvailable</kbd>. It's a shame that both functions need to be aware of the different constructors when they don't have anything to do with the price or availability of the seat. Taking another look at our <kbd class="calibre11">seat</kbd> type, we see that <kbd class="calibre11">(int, option(person))</kbd> is repeated for each constructor. Also, there isn't really a nice way to avoid using the <kbd class="calibre11">_</kbd> case in <kbd class="calibre11">isAvailable</kbd>. These are all signs that another type definition might serve our needs better. Let's remove the arguments from the <kbd class="calibre11">seat</kbd> type and rename it <kbd class="calibre11">section</kbd>. We'll declare a new record type, called <kbd class="calibre11">seat</kbd>, with fields for <kbd class="calibre11">section</kbd>, <kbd class="calibre11">price</kbd>, and <kbd class="calibre11">person</kbd>:</p>
<pre class="calibre16">type person = {<br class="title-page-name"/>  age: int,<br class="title-page-name"/>  name: string,<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>type section =<br class="title-page-name"/> | Pit<br class="title-page-name"/> | Floor<br class="title-page-name"/> | Mezzanine<br class="title-page-name"/> | Balcony;<br class="title-page-name"/><br class="title-page-name"/>type seat = {<br class="title-page-name"/>  section, /* same as section: section, */<br class="title-page-name"/>  price: int,<br class="title-page-name"/>  person: option(person)<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>let getSeatPrice = seat =&gt; seat.price;<br class="title-page-name"/><br class="title-page-name"/>let isAvailable = seat =&gt;<br class="title-page-name"/>  switch (seat.person) {<br class="title-page-name"/>  | None =&gt; true<br class="title-page-name"/>  | Some(_person) =&gt; false<br class="title-page-name"/>  };</pre>
<p class="mce-root">Now, our <kbd class="calibre11">getSeatPrice</kbd> and <kbd class="calibre11">isAvailable</kbd> functions have a higher signal-to-noise ratio, and don't need to change when the <kbd class="calibre11">section</kbd> type changes.</p>
<p class="mce-root">As a side note, <kbd class="calibre11">_</kbd> is used to prefix a variable to prevent the compiler from warning us about the variable being unused.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making Invalid States Impossible</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's say that we'd like to add a field to <kbd class="calibre11">seat</kbd> to hold the date a seat was purchased:</p>
<pre class="calibre16">type seat = {<br class="title-page-name"/>  section,<br class="title-page-name"/>  price: int,<br class="title-page-name"/>  person: option(person),<br class="title-page-name"/>  dateSold: option(string)<br class="title-page-name"/>};</pre>
<p class="mce-root">Now, we've introduced the possibility of an invalid state in our code. Here's an example of such a state:</p>
<pre class="calibre16">let seat = {<br class="title-page-name"/>  section: Pit,<br class="title-page-name"/>  price: 42,<br class="title-page-name"/>  person: None,<br class="title-page-name"/>  dateSold: Some("2018-07-16")<br class="title-page-name"/>};</pre>
<p class="mce-root">In theory, the <kbd class="calibre11">dateSold</kbd> field should only hold a date when the <kbd class="calibre11">person</kbd> field holds a ticket holder. The ticket has a sold date, but no owner. We could look through our imaginary implementation to verify that this state would never happen, but there would still be the possibility that we missed something, or that some minor refactor introduced a bug that was overlooked.</p>
<p class="mce-root">Since we now have the power of Reason's type system at our disposal, let's offload this work to the compiler. We are going to use the type system to enforce invariants in our code. If our code breaks these rules, it won't compile.</p>
<p class="mce-root">One giveaway that this invalid state could exist is the use of <kbd class="calibre11">option</kbd> types within our record field. In these cases, there may be a way to use a variant instead such that each constructor only holds the relevant data. In our case, our sold-date and ticket-holder data should only exist when the seat has been sold:</p>
<pre class="calibre16">type person = {<br class="title-page-name"/>  age: int,<br class="title-page-name"/>  name: string,<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>type date = string;<br class="title-page-name"/><br class="title-page-name"/>type section =<br class="title-page-name"/>  | Pit<br class="title-page-name"/>  | Floor<br class="title-page-name"/>  | Mezzanine<br class="title-page-name"/>  | Balcony;<br class="title-page-name"/><br class="title-page-name"/>type status =<br class="title-page-name"/>  | Available<br class="title-page-name"/>  | Sold(date, person);<br class="title-page-name"/><br class="title-page-name"/>type seat = {<br class="title-page-name"/>  section,<br class="title-page-name"/>  price: int,<br class="title-page-name"/>  status<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>let getSeatPrice = (seat) =&gt; seat.price;<br class="title-page-name"/><br class="title-page-name"/>let isAvailable = (seat) =&gt;<br class="title-page-name"/>  switch (seat.status) {<br class="title-page-name"/>  | Available =&gt; true<br class="title-page-name"/>  | Sold(_) =&gt; false<br class="title-page-name"/>  };</pre>
<p class="mce-root">Check out our new <kbd class="calibre11">status</kbd> type. The <kbd class="calibre11">Available</kbd> constructor holds no data, and <kbd class="calibre11">Sold</kbd> holds the sold date as well as the ticket holder.</p>
<p class="mce-root">With this <kbd class="calibre11">seat</kbd> type, there's no way to represent the previous invalid state of having a sold date without a ticket holder. It's also a good sign that our <kbd class="calibre11">seat</kbd> type no longer includes <kbd class="calibre11">option</kbd> types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we got a feel for what Reason is and what problems it tries to solve. We saw how Reason's type inference removes much of the burden associated with statically-typed languages. We learned that the type system is a tool that can be used to provide codebases with powerful guarantees that provide an excellent developer experience. While Reason may take some time to get used to, it's well worth the investment for medium-sized to larger codebases.</p>
<p class="mce-root">In the next chapter, we'll learn about Reason's toolchain when we set up our development environment. In <a href="21586d11-fa31-446f-99f1-dae3beecdb9b.xhtml" target="_blank" class="calibre8">Chapter 3</a>, <em class="calibre15">Creating ReasonReact Components</em>, we'll start to build an application that we'll use throughout the rest of this book. By the end of this book, you'll be comfortable building real-world React applications in Reason.</p>


            </article>

            
        </section>
    </body></html>