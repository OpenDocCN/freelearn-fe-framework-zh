- en: '*Chapter 8*: Routing in React'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：React中的路由'
- en: Currently, we have one screen and one path that our users can visit. When users
    visit Graphbook, they can log in and see their news feed and chats. Another requirement
    for a social network is that users have their own profile pages. We will implement
    this feature in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的用户可以访问一个屏幕和一个路径。当用户访问Graphbook时，他们可以登录并查看他们的新闻源和聊天。社交网络的一个要求是用户有自己的个人资料页面。我们将在本章实现此功能。
- en: We will introduce client-side routing for our React application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的React应用程序介绍客户端路由。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up React Router
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置React Router
- en: Advanced routing with React Router
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Router的高级路由
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter is available in the following GitHub repository:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter08)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter08)'
- en: Setting up React Router
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置React Router
- en: Routing is essential to most web applications. You cannot cover all of the features
    of your application in just one page. It would be overloaded, and your user would
    find it difficult to understand. Sharing links to pictures, profiles, or posts
    is also very important for a social network such as Graphbook. One advantageous
    feature, for example, is being able to send links to specific profiles. This requires
    each profile to have its own **Uniform Resource Locator** (**URL**) and page.
    Otherwise, it will not be possible to share a direct link to a single item of
    your application. It is also crucial to split the content into different pages,
    due to **search engine optimization** (**SEO**).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 路由对于大多数Web应用程序都是必不可少的。你无法在一个页面上涵盖你应用程序的所有功能。这将导致过载，并且用户会发现很难理解。在社交网络如Graphbook中，分享图片、个人资料或帖子的链接也非常重要。例如，一个有利的特性是能够发送到特定个人资料的链接。这要求每个个人资料都有自己的**统一资源定位符**（**URL**）和页面。否则，将无法分享到应用程序单个项目的直接链接。由于**搜索引擎优化**（**SEO**）的原因，将内容拆分到不同的页面也非常关键。
- en: At the moment, we render our complete application to **HyperText Markup Language**
    (**HTML**) in the browser, based on the authentication status. Only the server
    implements a simple routing functionality. Carrying out client-side routing can
    save a lot of work and time for the user if the router merely swaps out the correct
    parts in React, instead of reloading the page completely when following a link.
    It is vital that the application makes use of the HTML5 history implementation
    so that it handles the history of the browser. Importantly, this should also work
    for navigation in different directions. We should be able to go forward and backward
    with the arrow navigation buttons in the browser, without reloading the application.
    No unnecessary page reloads should happen with this solution.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们根据认证状态在浏览器中将完整的应用程序渲染为**超文本标记语言**（**HTML**）。只有服务器实现了简单的路由功能。如果路由器只是简单地替换React中的正确部分，而不是在跟随链接时完全重新加载页面，那么执行客户端路由可以为用户节省大量工作和时间。应用程序利用HTML5历史实现来处理浏览器的历史记录至关重要。重要的是，这也应该适用于不同方向上的导航。我们应该能够使用浏览器中的箭头导航按钮前后导航，而无需重新加载应用程序。此解决方案不应发生不必要的页面重新加载。
- en: Common frameworks that you may know about, such as Angular, Ember, and Ruby
    on Rails, use static routing. That is also the case for Express.js, which we covered
    in [*Chapter 2*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032)*,* *Setting
    Up GraphQL with Express.js*, of this book. **Static routing** means that you configure
    your routing flow and the components to render upfront. Your application then
    processes the routing table in a separate step, renders the required components,
    and presents the results to the user.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道的一些常见框架，如Angular、Ember和Ruby on Rails，使用静态路由。Express.js也是这样，我们在本书的[*第2章*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032)*,*
    *使用Express.js设置GraphQL*中介绍了它。**静态路由**意味着你预先配置你的路由流程和要渲染的组件。然后，你的应用程序在单独的步骤中处理路由表，渲染所需的组件，并将结果呈现给用户。
- en: With the release of version 4 and also the current version 5 of React Router,
    which we are going to use, **dynamic routing** was introduced. The unique thing
    about it is that the routing takes place while the rendering of your application
    is running. It doesn't require the application to first process a configuration
    in order to show the correct components. This approach fits with React's workflow
    well. The routing happens directly in your application, not in a preprocessed
    configuration.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 4 版本和我们现在将要使用的 5 版本 React Router 的发布，引入了**动态路由**。它的独特之处在于，路由发生在你的应用程序渲染运行时。它不需要应用程序首先处理配置以显示正确的组件。这种方法与
    React 的工作流程非常契合。路由直接在你的应用程序中发生，而不是在预处理的配置中。
- en: Installing React Router
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 React Router
- en: In the past, there were a lot of React routers, with various implementations
    and features. As we mentioned previously, we are going to install and configure
    version 5 for this book. If you search for other tutorials on this topic, make
    sure that you follow the instructions for this version. Otherwise, you might miss
    some of the changes that React Router has gone through.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，有很多 React 路由器，具有各种实现和功能。正如我们之前提到的，我们将为这本书安装和配置第 5 版。如果你搜索其他关于这个主题的教程，请确保遵循这个版本的说明。否则，你可能会错过
    React Router 经历的一些变化。
- en: 'To install React Router, simply run `npm` again, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 React Router，只需再次运行 `npm`，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From the package name, you might assume that this is not the main package for
    React. The reason for this is that React Router is a multi-package library. That
    comes in handy when using the same tool for multiple platforms. The core package
    is called `react-router`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从包名来看，你可能会认为这不是 React 的主要包。原因在于 React Router 是一个多包库。当在多个平台上使用相同工具时，这会很有用。核心包被称为
    `react-router`。
- en: There are two further packages. The first one is the `react-router-dom` package,
    which we installed in the preceding code snippet, and the second one is the `react-router-native`
    package. If at some point, you plan to build a React Native app, you can use the
    same routing instead of using the browser's **Document Object Model** (**DOM**)
    for a real mobile app.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个额外的包。第一个是 `react-router-dom` 包，我们在前面的代码片段中已经安装了它，第二个是 `react-router-native`
    包。如果你在某个时候计划构建一个 React Native 应用程序，你可以使用相同的路由，而不是使用浏览器的**文档对象模型**（**DOM**）来构建真正的移动应用程序。
- en: 'The first step that we will take introduces a simple router to get our current
    application working, including different paths for all of the screens. The routes
    that we are going to add are detailed here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要采取的第一步是引入一个简单的路由，以便使我们的当前应用程序工作，包括所有屏幕的不同路径。我们将添加的路由在此处详细说明：
- en: Our posts feed, chats, and the top bar, including the search box, should be
    accessible under the `/app` route of our application. The path is self-explanatory,
    but you could also use the `/` root as the main path.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序的帖子源、聊天和顶部栏，包括搜索框，应该在 `/app` 路由下可访问。路径是自解释的，但你也可以使用 `/` 根路径作为主路径。
- en: The login and signup forms should have a separate path, which will be accessible
    under the `/` root path.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录和注册表单应该有单独的路径，该路径将在 `/` 根路径下可访问。
- en: As we do not have any further screens, we also have to handle a situation in
    which none of the preceding routes match. In that case, we could display a so-called
    404 page, but instead, we are going to redirect to the root path directly.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们没有其他屏幕，我们还需要处理一种情况，即前面的所有路由都不匹配。在这种情况下，我们可以显示一个所谓的 404 页面，但我们将直接重定向到根路径。
- en: 'There is one thing that we have to prepare before continuing. For development,
    we are using the webpack development server, as this is what we configured in
    [*Chapter 1*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017), *Preparing Your
    Development Environment*. To get the routing working out of the box, we will add
    two parameters to the `webpack.client.config.js` file. The `devServer` field should
    look like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们必须准备一件事。对于开发，我们使用 webpack 开发服务器，正如我们在 [*第 1 章*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017)，*准备你的开发环境*
    中配置的那样。为了使路由能够直接工作，我们将向 `webpack.client.config.js` 文件添加两个参数。`devServer` 字段应如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `historyApiFallback` field tells `devServer` to serve the `index.html` file,
    not only for the root path, `http://localhost:3000/`, but also when it would typically
    receive a 404 error (such as for paths like `http://localhost:3000/app`). This
    happens when the path does not match a file or folder that is normal when implementing
    routing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`historyApiFallback`字段告诉`devServer`不仅为根路径`http://localhost:3000/`，而且在它通常会收到404错误（例如对于`http://localhost:3000/app`之类的路径）时也要提供`index.html`文件。这发生在路径不匹配文件或文件夹时，这在实现路由时是正常的。'
- en: 'The `output` field at the top of the `config` file must have a `publicPath`
    property, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`config`文件顶部的`output`字段必须有一个`publicPath`属性，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `publicPath` property tells webpack to prefix the bundle URL to an absolute
    path, instead of a relative path. When this property is not included, the browser
    cannot download the bundle when visiting the sub-directories of our application,
    as we are implementing client-side routing. Let's begin with the first path and
    bind the central part of our application, including the news feed, to the `/app`
    path.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`publicPath`属性告诉webpack将包URL的前缀添加到绝对路径，而不是相对路径。当此属性未包含时，浏览器在访问我们应用程序的子目录时无法下载包，因为我们正在实现客户端路由。让我们从第一个路径开始，将应用程序的中心部分，包括新闻源，绑定到`/app`路径。'
- en: Implementing your first route
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现您的第一个路由
- en: 'Before implementing the routing, we will clean up the `App.js` file. To do
    this, follow these steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现路由之前，我们将清理`App.js`文件。为此，请按照以下步骤操作：
- en: 'Create a `Main.js` file next to the `App.js` file in the `client` folder. Insert
    the following code:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`client`文件夹中，在`App.js`文件旁边创建一个`Main.js`文件。插入以下代码：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you might have noticed, the preceding code is pretty much the same as the
    logged-in condition inside the `App.js` file. The only change is that the `changeLoginState`
    function is taken from the properties and is not directly a method of the component
    itself. That is because we split this part out of the `App.js` file and put it
    in a separate file. This improves reusability for other components that we are
    going to implement.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，前面的代码基本上与`App.js`文件内的登录条件相同。唯一的区别是`changeLoginState`函数是从属性中取出的，而不是组件本身的直接方法。这是因为我们将这部分从`App.js`文件中分离出来，并放入一个单独的文件中。这提高了我们将要实现的其它组件的可重用性。
- en: 'Now, open and replace the `return` statement of the `App` component to reflect
    those changes, as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开并替换`App`组件的`return`语句，以反映以下更改：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you compare the preceding method with the old one, you can see that we have
    inserted a `Router` component, instead of directly rendering either the posts
    feed or the login form. The original components of the `App.js` file are now in
    the previously created `Main.js` file. Here, we pass the `loggedIn` property and
    the `changeLoginState` function to the `Router` component. Remove the dependencies
    at the top, such as the `Chats` and `Feed` components, because we won't use them
    any more thanks to the new `Main` component.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你将先前的方法与旧方法进行比较，你会发现我们插入了一个`Router`组件，而不是直接渲染帖子源或登录表单。`App.js`文件的原有组件现在位于之前创建的`Main.js`文件中。在这里，我们将`loggedIn`属性和`changeLoginState`函数传递给`Router`组件。删除顶部的依赖项，如`Chats`和`Feed`组件，因为我们不再需要它们，多亏了新的`Main`组件。
- en: 'Add the following line to the dependencies of our `App.js` file:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到我们的`App.js`文件的依赖项中：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To get the routing working, we have to implement our custom `Router` component
    first. Generally, it is easy to get the routing running with React Router, and
    you are not required to separate the routing functionality into a separate file,
    but that makes it more readable.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了使路由工作，我们必须首先实现我们的自定义`Router`组件。通常，使用React Router实现路由运行很容易，并且不需要将路由功能分离到单独的文件中，但这使得代码更易读。
- en: 'To do this, create a new `router.js` file in the `client` folder, next to the
    `App.js` file, with the following content:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，在`client`文件夹中，在`App.js`文件旁边创建一个新的`router.js`文件，内容如下：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At the top, we import all of the dependencies. They include the new `Main`
    component and the `react-router` package. Here is a quick explanation of all of
    the components that we are importing from the React Router package:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们导入所有依赖项。它们包括新的`Main`组件和`react-router`包。以下是所有从React Router包中导入的组件的快速说明：
- en: '`BrowserRouter` (or `Router`, for short, as we called it here) is the component
    that keeps the URL in the address bar in sync with the **user interface** (**UI**);
    it handles all of the routing logic.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BrowserRouter`（或简称 `Router`，如我们在这里所称呼）是一个组件，它使地址栏中的 URL 与 **用户界面**（**UI**）保持同步；它处理所有的路由逻辑。'
- en: The `Switch` component forces the first matching `Route` or `Redirect` component
    to be rendered. We need it to stop re-rendering the UI if the user is already
    in the location to which a redirect is trying to navigate. I generally recommend
    that you use the `Switch` component, as it catches unforeseeable routing errors.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Switch` 组件强制渲染第一个匹配的 `Route` 或 `Redirect` 组件。我们需要它来停止在用户已经位于重定向尝试导航到的位置时重新渲染
    UI。我通常建议您使用 `Switch` 组件，因为它可以捕获不可预见的路由错误。'
- en: '`Route` is the component that tries to match the given path to the URL of the
    browser. If this is the case, the `component` property is rendered. You can see
    in the preceding code snippet that we are not setting the `Main` component directly
    as a parameter; instead, we return it from a stateless function. That is required
    because the `component` property of a `Route` component only accepts functions
    and not a component object. This solution allows us to pass the `changeLoginState`
    function to the `Main` component.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Route` 是一个组件，它试图将给定的路径与浏览器的 URL 匹配。如果情况如此，则渲染 `component` 属性。您可以在前面的代码片段中看到，我们并没有直接将
    `Main` 组件作为参数设置；相反，我们从无状态函数中返回它。这是必需的，因为 `Route` 组件的 `component` 属性只接受函数，而不是组件对象。这个解决方案允许我们将
    `changeLoginState` 函数传递给 `Main` 组件。'
- en: '`Redirect` navigates the browser to a given location. The component receives
    a property called `to`, filled by a path starting with `/`. We are going to use
    this component in the next section.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Redirect` 将浏览器导航到指定的位置。该组件接收一个名为 `to` 的属性，它由以 `/` 开头的路径填充。我们将在下一节中使用这个组件。'
- en: The problem with the preceding code is that we are only listening for one route,
    which is `/app`. If you are not logged in, there will be many errors that are
    not covered. The best thing to do would be to redirect the user to the root path,
    where they can log in.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的问题是我们只监听了一个路由，即 `/app`。如果您未登录，将会有许多未覆盖的错误。最好的做法是将用户重定向到根路径，在那里他们可以登录。
- en: Secured routes
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受保护的路由
- en: '**Secured routes** represent a way to specify paths that are only accessible
    if the user is authenticated or has the correct authorization.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**受保护的路由**代表了一种指定只有当用户经过身份验证或具有正确的授权时才能访问的路径的方法。'
- en: 'The recommended solution to implement secure routes in React Router is to write
    a small, stateless function that conditionally renders either a `Redirect` component
    or the component specified on the route that requires an authenticated user. We
    extract the `component` property of the router into the `Component` variable,
    which is a renderable React object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Router 中实现受保护路由的推荐解决方案是编写一个小的、无状态的函数，该函数根据条件渲染 `Redirect` 组件或需要经过身份验证的用户指定的路由上的组件。我们将路由的
    `component` 属性提取到 `Component` 变量中，它是一个可渲染的 React 对象：
- en: 'Insert the following code into the `router.js` file:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码插入到 `router.js` 文件中：
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We call the `PrivateRoute` stateless function. It returns a standard `Route`
    component, which receives all of the properties initially given to the `PrivateRoute`
    function. To pass all properties, we use a destructuring assignment with the `...rest`
    syntax. Using the syntax inside of curly braces on a React component passes all
    fields of the `rest` object as properties to the component. The `Route` component
    is only rendered if the given path is matched.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们调用 `PrivateRoute` 无状态函数。它返回一个标准的 `Route` 组件，该组件接收最初传递给 `PrivateRoute` 函数的所有属性。为了传递所有属性，我们使用
    `...rest` 语法进行解构赋值。在 React 组件的括号内使用该语法将 `rest` 对象的所有字段作为属性传递给组件。只有当给定的路径匹配时，`Route`
    组件才会被渲染。
- en: Furthermore, the rendered component is dependent on the user's `loggedIn` state
    variable, which we have to pass. If the user is logged in, we render the `Component`
    variable without any problems. Otherwise, we redirect the user to the root path
    of our application using the `Redirect` component.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，渲染的组件取决于用户的 `loggedIn` 状态变量，我们必须传递它。如果用户已登录，我们将无问题地渲染 `Component` 变量。否则，我们使用
    `Redirect` 组件将用户重定向到应用程序的根路径。
- en: 'Use the new `PrivateRoute` component in the `return` statement of the `Router`
    component and replace the old `Route` component, as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Router` 组件的 `return` 语句中使用新的 `PrivateRoute` 组件，并替换旧的 `Route` 组件，如下所示：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that we pass the `loggedIn` property by taking the value from the properties
    of the `Router` component itself. It initially receives the `loggedIn` property
    from the `App` component that we edited previously. The great thing is that the
    `loggedIn` variable can be updated from the parent `App` component at any time.
    That means that the `Redirect` component is rendered, and the user is automatically
    navigated to the login form if the user logs out, for example. We do not have
    to write separate logic to implement this functionality.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们是通过从 `Router` 组件本身的属性中取值来传递 `loggedIn` 属性的。它最初从我们之前编辑的 `App` 组件接收 `loggedIn`
    属性。很棒的是，`loggedIn` 变量可以从父 `App` 组件随时更新。这意味着当用户注销时，`Redirect` 组件会被渲染，用户会自动导航到登录表单。我们不需要编写单独的逻辑来实现这个功能。
- en: However, we have now created a new problem. We redirect from `/app` to `/` if
    the user is not logged in, but we do not have any routes set up for the initial
    `'/'` path. It makes sense for this path to either show the login form or to redirect
    the user to `/app` if the user is logged in. The pattern for the new component
    is the same as the preceding code for the `PrivateRoute` component but in the
    opposite direction.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，我们现在又遇到了一个新的问题。当用户未登录时，我们将请求从 `/app` 重定向到 `/`，但我们没有为初始的 `'/'` 路径设置任何路由。这个路径要么显示登录表单，要么在用户登录时将用户重定向到
    `/app`，这样做是有意义的。新组件的模式与 `PrivateRoute` 组件之前的代码相同，但方向相反。
- en: 'Add the new `LoginRoute` component to the `router.js` file, as follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的 `LoginRoute` 组件添加到 `router.js` 文件中，如下所示：
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding condition is inverted to render the original component. If the
    user is not logged in, the login form is rendered. Otherwise, they will be redirected
    to the posts feed.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述条件被反转以渲染原始组件。如果用户未登录，将渲染登录表单。否则，他们将被重定向到帖子源。
- en: 'Add the new path to the router, as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的路径添加到路由中，如下所示：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code looks the same as that of the `PrivateRoute` component, except that
    we now have a new property, called `exact`. If we pass this property to a route,
    the browser''s location has to match 100%. The following table shows a quick example,
    taken from the official React Router documentation:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码看起来与 `PrivateRoute` 组件的代码相同，但我们现在有一个新的属性，称为 `exact`。如果我们向一个路由传递这个属性，浏览器位置必须匹配
    100%。以下表格展示了从官方 React Router 文档中摘取的一个快速示例：
- en: '![](img/B17337_08_Table_8.1.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17337_08_Table_8.1.jpg)'
- en: For the root path, we set `exact` to `true` because otherwise, the path matches
    with any browser's location where `/` is included, as you can see in the preceding
    table.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于根路径，我们将 `exact` 设置为 `true`，因为否则路径会与包含 `/` 的任何浏览器位置匹配，正如您在前面的表中看到的。
- en: Note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are many more configuration options that React Router offers, such as
    enforcing trailing slashes, case sensitivity, and much more. You can find all
    of the options and examples in the official documentation at [https://v5.reactrouter.com/web/api/](https://v5.reactrouter.com/web/api/).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 提供了许多更多的配置选项，例如强制使用尾部斜杠、大小写敏感等。您可以在官方文档中找到所有选项和示例，网址为 [https://v5.reactrouter.com/web/api/](https://v5.reactrouter.com/web/api/)。
- en: Catch-all routes in React Router
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Router 中的通配符路由
- en: Currently, we have two paths set up, which are `/app` and `/`. If a user visits
    a non-existent path, such as `/test`, they will see an empty screen. The solution
    is to implement a route that matches any path. For simplicity, we redirect the
    user to the root of our application, but you could easily replace the redirection
    with a typical 404 page.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经设置了两个路径，即 `/app` 和 `/`。如果用户访问一个不存在的路径，例如 `/test`，他们将看到一个空屏幕。解决方案是实现一个匹配任何路径的路由。为了简单起见，我们将用户重定向到我们应用程序的根目录，但您也可以轻松地将重定向替换为典型的
    404 页面。
- en: 'Add the following code to the `router.js` file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `router.js` 文件中：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `NotFound` component is minimal. It just redirects the user to the root
    path. Add the next `Route` component to the `Switch` component in the `Router`
    component. Ensure that it is the last one on the list. The code is shown here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotFound` 组件很简单。它只是将用户重定向到根路径。将下一个 `Route` 组件添加到 `Router` 组件中的 `Switch` 组件。确保它是列表中的最后一个。代码如下所示：'
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, we are rendering a simple `Route` component in the preceding
    code. What makes the route special is that we are not passing a `path` property
    with it. By default, the `path` property is completely ignored, and the component
    is rendered every time, except if there is a match with a previous component.
    That is why we added the route to the bottom of the `Router` component. When no
    route matches, we redirect the user to the login screen in the root path, or,
    if the user is already logged in, we redirect them to a different screen using
    the routing logic of the root path. Our `LoginRoute` component handles this last
    case.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们在前面的代码中渲染了一个简单的`Route`组件。使这个路由特殊的是我们没有传递一个`path`属性。默认情况下，`path`属性会被完全忽略，组件会在每次渲染时显示，除非与之前的组件匹配。这就是为什么我们将路由添加到`Router`组件的底部。当没有路由匹配时，我们将用户重定向到根路径的登录屏幕，或者如果用户已经登录，我们将使用根路径的路由逻辑将他们重定向到不同的屏幕。我们的`LoginRoute`组件处理最后一个情况。
- en: You can test all changes when starting the frontend with `npm run client` and
    the backend with `npm run server`. We have now moved the current state of our
    application from a standard, single-route application to an application that differentiates
    the login form and the news feed based on the location of the browser.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`npm run client`启动前端和`npm run server`启动后端来测试所有更改。我们现在已经将我们的应用程序从标准单路由应用程序转换为根据浏览器位置区分登录表单和新闻源的应用程序。
- en: In the next section, we will have a look at how we can implement more complicated
    routing by adding parameterized routes and loading the data depending on those
    parameters.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何通过添加参数化路由并根据这些参数加载数据来实现更复杂的路由。
- en: Advanced routing with React Router
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Router的高级路由
- en: The primary goal of this chapter is to build a profile page for your users.
    We need a separate page to show all of the content that a single user has entered
    or created. The content would not fit next to the posts feed. When looking at
    Facebook, we can see that every user has their own address, under which we can
    find the profile page of a specific user. We are going to create our profile page
    in the same way and use the username as the custom path.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是为你用户的个人资料页构建一个页面。我们需要一个单独的页面来显示单个用户输入或创建的所有内容。这些内容不适合放在帖子源旁边。当查看Facebook时，我们可以看到每个用户都有自己的地址，我们可以在其中找到特定用户的个人资料页。我们将以相同的方式创建我们的个人资料页，并使用用户名作为自定义路径。
- en: 'We have to implement the following features:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须实现以下功能：
- en: We add a new parameterized route for the user profile. The path starts with
    `/user/` and follows a username.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为用户个人资料添加一个新的参数化路由。路径以`/user/`开始，后跟一个用户名。
- en: We change the user profile page to send all GraphQL queries, including the `username`
    route parameter, inside of the `variables` field of the GraphQL request.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将用户个人资料页更改为在GraphQL请求的`variables`字段中发送所有GraphQL查询，包括`username`路由参数。
- en: We edit the `postsFeed` query to filter all posts by the `username` parameter
    provided.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们编辑`postsFeed`查询以通过提供的`username`参数过滤所有帖子。
- en: We implement a new GraphQL query on the backend to request a user by their username,
    in order to show information about the user.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在后台实现一个新的GraphQL查询，通过用户名请求用户，以便显示有关用户的信息。
- en: When all of the queries are finished, we render a new user profile header component
    and the posts feed.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当所有查询完成后，我们渲染一个新的用户个人资料头部组件和帖子源。
- en: Finally, we enable navigation between each page without reloading the complete
    page, but only the changed parts.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们启用在每个页面之间导航而无需重新加载整个页面，只需重新加载更改的部分。
- en: Let's start by implementing routing for the profile page in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在下一节中实现个人资料页的路由来开始。
- en: Parameters in routes
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由中的参数
- en: 'We have prepared most of the work required to add a new user route. Open up
    the `router.js` file again. Add the new route, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了添加新用户路由所需的大部分工作。再次打开`router.js`文件。添加新的路由，如下所示：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code contains two new elements, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中包含两个新元素，如下所示：
- en: The path that we entered is `/user/:username`. As you can see, the username
    is prefixed with a colon, telling React Router to pass the value of it to the
    underlying component being rendered.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们输入的路径是`/user/:username`。正如你所见，用户名前有一个冒号作为前缀，这告诉React Router将它的值传递给正在渲染的底层组件。
- en: The component that we rendered previously was a stateless function that returned
    either the `LoginRegisterForm` component or the `Main` component. Neither of these
    received any parameters or properties from React Router. Now, however, it is required
    that all properties of React Router are transferred to the child component. That
    includes the `username` parameter that we just introduced. We use the same destructuring
    assignment with the `props` object to pass all properties to the `User` component.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们之前渲染的组件是一个无状态的函数，它返回`LoginRegisterForm`组件或`Main`组件。这两个组件都没有从React Router接收任何参数或属性。然而，现在要求将React
    Router的所有属性都传递给子组件。这包括我们刚刚引入的`username`参数。我们使用相同的解构赋值与`props`对象来将所有属性传递给`User`组件。
- en: 'Those are all of the changes that we need to accept parameterized paths in
    React Router. We read out the value inside of the new user page component. Before
    implementing it, we import the dependency at the top of `router.js` to get the
    preceding route working, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是我们接受React Router参数化路径所需的所有更改。我们在新的用户页面组件内部读取值。在实现它之前，我们在`router.js`的顶部导入依赖项，以便使前面的路由工作，如下所示：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create the preceding `User.js` file next to the `Main.js` file. As with the
    `Main` component, we are collecting all of the components that we render on this
    page. You should stay with this layout, as you can directly see which main parts
    each page consists of. The `User.js` file should look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main.js`文件旁边创建前面的`User.js`文件。与`Main`组件一样，我们正在收集在这个页面上渲染的所有组件。你应该保持这个布局，因为你可以直接看到每个页面由哪些主要部分组成。`User.js`文件应该看起来像这样：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have all common components including the `Bar` and `Chat` component. If a
    user visits the profile of a friend, they see the common application bar at the
    top. They can access their chats on the right-hand side, like on Facebook. It
    is one of the many situations in which React and the reusability of components
    come in handy.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有所有常见的组件，包括`Bar`和`Chat`组件。如果用户访问朋友的个人资料，他们会在顶部看到常见的应用栏。他们可以在右侧访问他们的聊天，就像在Facebook上一样。这是React和组件的可重用性派上用场的情况之一。
- en: We removed the `Feed` component and replaced it with a new `UserProfile` component.
    Importantly, the `UserProfile` component receives the `username` property. Its
    value is taken from the properties of the `User` component. These properties were
    passed over by React Router. If you have a parameter, such as `username`, in the
    routing path, the value is stored in the `match.params.username` property of the
    child component. The `match` object generally contains all matching information
    of React Router.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除了`Feed`组件，并用新的`UserProfile`组件替换了它。重要的是，`UserProfile`组件接收`username`属性。它的值来自`User`组件的属性。这些属性是通过React
    Router传递的。如果你在路由路径中有一个参数，比如`username`，那么这个值就存储在子组件的`match.params.username`属性中。`match`对象通常包含React
    Router的所有匹配信息。
- en: From this point on, you can implement any custom logic that you want with this
    value. We will now continue with implementing the profile page.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，你可以使用这个值实现任何你想要的自定义逻辑。我们现在将继续实现个人资料页面。
- en: One thing before building the user profile page is to extract the feed rendering
    logic to a separate component to reuse it. Create a `feedlist.js` file inside
    the `post` folder.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建用户个人资料页面之前，需要将渲染逻辑提取到单独的组件中以供重用。在`post`文件夹内创建一个名为`feedlist.js`的新文件。
- en: 'Insert the following code in the `feedlist.js` file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`feedlist.js`文件中插入以下代码：
- en: 'Import the following dependencies at the top, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式在顶部导入以下依赖项：
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, just copy the main parts of the feed list `return` statement, as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，只需复制以下`return`语句中的主要部分，如下所示：
- en: '[PRE17]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'One thing that is missing now is the `loadMore` function, which we also can
    just copy. Just add it straight to the preceding component, as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在缺少的是`loadMore`函数，我们也可以直接复制。只需将其直接添加到前面的组件中，如下所示：
- en: '[PRE18]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Just replace the part on the `Feed.js` file''s `return` statement. It should
    look like this:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需替换`Feed.js`文件`return`语句的部分。它应该看起来像这样：
- en: '[PRE19]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can use this `FeedList` component now where we need to display a feed of
    posts, such as on our user profile page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在需要显示帖子列表的地方使用这个`FeedList`组件，比如在我们的用户个人资料页面上。
- en: 'Follow these steps to build the user''s profile page:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建用户的个人资料页面：
- en: Create a new folder, called `user`, inside the `components` folder.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`文件夹内创建一个名为`user`的新文件夹。
- en: Create a new file, called `index.js`, inside the `user` folder.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user`文件夹内创建一个名为`index.js`的新文件。
- en: 'Import the dependencies at the top of the file, as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式在文件顶部导入依赖项：
- en: '[PRE20]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first three lines should look familiar. Two imported files, however, do
    not exist at the moment, but we are going to change that shortly. The first new
    file is `UserHeader`, which takes care of rendering the avatar image, the name,
    and information about the user. Logically, we request the data that we will display
    in this header through a new Apollo query Hook, called `getUser`.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前三行看起来应该很熟悉。然而，目前有两个导入的文件不存在，但我们很快就会改变这一点。第一个新文件是`UserHeader`，它负责渲染头像图片、用户名和信息。逻辑上，我们通过一个新的Apollo查询钩子`getUser`请求我们将要在该头部显示的数据。
- en: 'Insert the code for the `UserProfile` component that we are building at the
    moment beneath the dependencies, as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们目前正在构建的`UserProfile`组件代码插入到依赖项下方，如下所示：
- en: '[PRE21]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `UserProfile` component is not complex. We are running two Apollo queries
    simultaneously. Both have the `variables` property set. The `useGetPostsQuery`
    Hook receives the username, which initially came from React Router. This property
    is also handed over to `useGetUserQuery`.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`UserProfile`组件并不复杂。我们同时运行两个Apollo查询。这两个查询都设置了`variables`属性。`useGetPostsQuery`钩子接收用户名，它最初来自React
    Router。这个属性也被传递给`useGetUserQuery`。'
- en: Now edit and create Apollo queries, before programming the profile header component.
    Open the `getPosts.js` file from the `queries` folder.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编辑并创建Apollo查询，在编写个人资料头部组件之前。打开`queries`文件夹中的`getPosts.js`文件。
- en: 'To use the username as input to the GraphQL query, we first have to change
    the query string from the `GET_POSTS` variable. Change the first two lines to
    match the following code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将用户名作为GraphQL查询的输入，我们首先必须将查询字符串从`GET_POSTS`变量中更改。将前两行更改为以下代码：
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, replace the last line with the following code to provide a way to pass
    variables to the `useQuery` Hook:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将最后一行替换为以下代码，以提供传递变量到`useQuery`钩子函数的方法：
- en: '[PRE23]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the custom query component receives a `username` property, it is included
    in the GraphQL request. It is used to filter posts by the specific user that we
    are viewing.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果自定义查询组件接收一个`username`属性，它将被包含在GraphQL请求中。它被用来过滤我们正在查看的特定用户发布的帖子。
- en: Create a new `getUser.js` file in the `queries` folder to create a query Hook,
    which we are missing at present.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`queries`文件夹中创建一个新的`getUser.js`文件，创建一个查询钩子，这是我们目前所缺少的。
- en: 'Import all of the dependencies and parse the new query schema with `gql`, as
    follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式在文件顶部导入所有依赖项并使用`gql`解析新的查询模式：
- en: '[PRE24]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding query is nearly the same as the `currentUser` query. We are going
    to implement the corresponding `user` query later, in our GraphQL **application
    programming interface** (**API**).
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的查询几乎与`currentUser`查询相同。我们将在我们的GraphQL **应用程序编程接口**（**API**）中稍后实现相应的`user`查询。
- en: 'The last step is to implement the `UserProfileHeader` component. This component
    renders the `user` property, with all its values. It is just simple HTML markup.
    Copy the following code into the `header.js` file, in the `user` folder:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是实现`UserProfileHeader`组件。这个组件渲染`user`属性及其所有值。它只是简单的HTML标记。将以下代码复制到`user`文件夹中的`header.js`文件：
- en: '[PRE25]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you need help getting the **Cascading Style Sheets** (**CSS**) styling right,
    take a look at the official repository for this book. The preceding code only
    renders the user's data; you could also implement features such as a chat button,
    which would give the user the option to start messaging with other people. Currently,
    we have not implemented this feature anywhere, but it is not necessary to explain
    the principles of React and GraphQL.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在正确设置**层叠样式表**（**CSS**）样式方面需要帮助，请查看这本书的官方仓库。前面的代码仅渲染用户数据；你也可以实现聊天按钮等特性，这样用户就可以选择与其他人开始消息交流。目前，我们还没有在任何地方实现这个特性，但解释React和GraphQL的原则并不必要。
- en: We have finished the new frontend components, but the `UserProfile` component
    is still not working. The queries that we are using here either do not accept
    the `username` parameter or have not yet been implemented.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了新的前端组件，但`UserProfile`组件仍然没有工作。我们在这里使用的查询要么不接受`username`参数，要么尚未实现。
- en: The next section will cover which parts of the backend have to be adjusted.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将涵盖后端需要调整的部分。
- en: Querying the user profile
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询用户资料
- en: 'With the new profile page, we have to update our backend accordingly. Let''s
    take a look at what needs to be done, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的个人资料页面，我们必须相应地更新我们的后端。让我们看看需要做什么，如下所示：
- en: We have to add the `username` parameter to the schema of the `postsFeed` query
    and adjust the resolver function.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须将 `username` 参数添加到 `postsFeed` 查询的模式中，并调整解析函数。
- en: We have to create a schema and a resolver function for the new `UserQuery` component.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须为新的 `UserQuery` 组件创建一个模式和解析函数。
- en: 'We will begin with the `postsFeed` query:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `postsFeed` 查询开始：
- en: 'Edit the `postsFeed` query in the `RootQuery` type of the `schema.js` file
    to match the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `schema.js` 文件中的 `RootQuery` 类型的 `postsFeed` 查询，以匹配以下代码：
- en: '[PRE26]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, I have added `username` as an optional parameter.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我已经将 `username` 添加为一个可选参数。
- en: 'Now, head over to the `resolvers.js` file and take a look at the corresponding
    `resolver` function. Replace the signature of the function to extract the username
    from the variables, as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，前往 `resolvers.js` 文件并查看相应的 `resolver` 函数。将函数签名替换为从变量中提取用户名，如下所示：
- en: '[PRE27]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To make use of the new parameter, add the following lines of code above the
    `return` statement:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用新参数，在 `return` 语句上方添加以下代码行：
- en: '[PRE28]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have already covered the basic Sequelize API and how to query associated
    models by using the `include` parameter in [*Chapter 3*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054),
    *Connecting to the Database*. An important point is how we filter posts associated
    with a user by their username. We''ll do this in the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了基本的 Sequelize API 以及如何使用 `include` 参数在 [*第 3 章*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054)
    中查询关联模型，*连接到数据库*。一个重要点是，我们如何通过用户名过滤与用户关联的帖子。我们将在以下步骤中这样做：
- en: In the preceding code, we fill the `include` field of the `query` object with
    the Sequelize model that we want to join. This allows us to filter the associated
    `User` model in the next step.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们填充了 `query` 对象的 `include` 字段，这是我们想要连接的 Sequelize 模型。这允许我们在下一步中过滤关联的
    `User` 模型。
- en: Then, we create a normal `where` object in which we write the filter condition.
    If you want to filter the posts by an associated table of users, you can wrap
    the model and field names that you want to filter by with dollar signs. In our
    case, we wrap `User.username` with dollar signs, which tells Sequelize to query
    the `User` model's table and filter by the value of the `username` column.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个普通的 `where` 对象，在其中写入过滤条件。如果你想通过关联的用户表来过滤帖子，你可以用美元符号包裹你想要过滤的模型和字段名称。在我们的例子中，我们用美元符号包裹
    `User.username`，这告诉 Sequelize 查询 `User` 模型的表并通过 `username` 列的值进行过滤。
- en: No adjustments are required for the pagination part. The GraphQL query is now
    ready. The great thing about the small changes that we have made is that we have
    just one API function that accepts several parameters, either to display posts
    on a single user profile or to display a list of posts, such as a news feed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分页部分不需要调整。GraphQL 查询现在已准备就绪。我们所做的这些小改动的好处是，我们只有一个接受多个参数的 API 函数，既可以显示单个用户资料上的帖子，也可以显示帖子列表，如新闻源。
- en: 'Let''s move on and implement the new `user` query:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续并实现新的 `user` 查询：
- en: 'Add the following line to the `RootQuery` type in your GraphQL schema:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 GraphQL 模式中的 `RootQuery` 类型中添加以下行：
- en: '[PRE29]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This query only accepts a `username` parameter, but this time it is a required
    parameter in the new query. Otherwise, the query would make no sense since we
    only use it when visiting a user's profile through their username.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此查询仅接受 `username` 参数，但这次它是新查询中的必需参数。否则，查询就没有意义，因为我们只有在通过用户名访问用户资料时才使用它。
- en: 'In the `resolvers.js` file, implement the resolver function using Sequelize,
    as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `resolvers.js` 文件中，使用 Sequelize 实现解析函数，如下所示：
- en: '[PRE30]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code snippet, we use the `findOne` method of the `User` model
    by using Sequelize and search for exactly one user with the username that we provided
    in the parameter.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用 Sequelize 的 `findOne` 方法并搜索我们提供的参数中的用户名，以找到恰好一个用户。
- en: Now that the backend code and the user page are ready, we have to allow the
    user to navigate to this new page. The next section will cover user navigation
    using React Router.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在后台代码和用户页面都已准备就绪，我们必须允许用户导航到这个新页面。下一节将介绍使用 React Router 的用户导航。
- en: Programmatic navigation in React Router
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Router 中的编程导航
- en: 'We created a new site with the user profile, but now we have to offer the user
    a link to get there. The transition between the news feed and the login and registration
    forms is automated by React Router, but not the transition from the news feed
    to a profile page. The user decides whether they want to view the profile of the
    user. React Router has multiple ways to handle navigation. We are going to extend
    the news feed to handle clicks on the username or the avatar image, in order to
    navigate to the user''s profile page. Open the `header.js` file in the `post`
    components folder. Import the `Link` component provided by React Router, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个带有用户资料的新网站，但现在我们必须为用户提供一个链接来访问它。新闻源和登录及注册表单之间的转换由 React Router 自动化，但新闻源到个人资料页面的转换则不是。用户决定他们是否想查看用户的个人资料。React
    Router 有多种处理导航的方式。我们将扩展新闻源以处理对用户名或头像图像的点击，以便导航到用户的个人资料页面。打开 `post` 组件文件夹中的 `header.js`
    文件。导入 React Router 提供的 `Link` 组件，如下所示：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `Link` component is a tiny wrapper around a regular HTML `a` tag. Apparently,
    in standard web applications or websites, there is no complex logic behind hyperlinks;
    you click on them, and a new page is loaded from scratch. With React Router or
    most **single-page application** (**SPA**) **JavaScript** (**JS**) frameworks,
    you can add more logic behind hyperlinks. Importantly, instead of completely reloading
    the pages when navigating between different routes, this now gets handled by React
    Router. There won't be complete page reloads when navigating; instead, only the
    required parts are exchanged, and the GraphQL queries are run. This method saves
    the user expensive bandwidth because it means that we can avoid downloading all
    of the HTML, CSS, and image files again.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Link` 组件是围绕常规 HTML `a` 标签的一个小包装器。显然，在标准网络应用或网站上，超链接后面没有复杂的逻辑；你点击它们，就会从头开始加载一个新页面。使用
    React Router 或大多数 **单页应用** (**SPA**) **JavaScript** (**JS**) 框架，你可以在超链接后面添加更多逻辑。重要的是，在导航到不同路由之间时，不再完全重新加载页面，这现在由
    React Router 处理。导航时不会有完整的页面重新加载；相反，只需交换所需的部件，并运行 GraphQL 查询。这种方法节省了用户昂贵的带宽，因为它意味着我们可以避免再次下载所有的
    HTML、CSS 和图像文件。'
- en: 'To test this, wrap the username and the avatar image in the `Link` component,
    as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个，将用户名和头像图像包裹在 `Link` 组件中，如下所示：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the rendered HTML, the `img` and `div` tags are surrounded by a common `a`
    tag but are handled inside React Router. The `Link` component receives a `to`
    property, which is the destination of the navigation. You have to copy one new
    CSS rule because the `Link` component has changed the markup. The code is illustrated
    in the following snippet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染的 HTML 中，`img` 和 `div` 标签被一个共同的 `a` 标签包围，但它们在 React Router 内部处理。`Link` 组件接收一个
    `to` 属性，它是导航的目的地。你必须复制一条新的 CSS 规则，因为 `Link` 组件已经改变了标记。代码在下面的代码片段中展示：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you test the changes now, clicking on the username or avatar image, you should
    notice that the content of the page dynamically changes but does not entirely
    reload. A further task would be to copy this approach to the user search list
    in the application bar and the chats. Currently, the users are displayed, but
    there is no option to visit their profile pages by clicking on them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在测试这些更改，点击用户名或头像图像，你应该会注意到页面内容动态变化，但不会完全重新加载。一个进一步的任务是将这种方法复制到应用程序栏的用户搜索列表和聊天中。目前，用户被显示出来，但没有选项通过点击它们来访问他们的个人资料页面。
- en: 'Now, let''s take a look at another way to navigate with React Router. If the
    user has reached a profile page, we want them to navigate back by clicking on
    a button in the application bar. First of all, we will create a new `home.js`
    file in the `bar` folder, and we will enter the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用 React Router 导航的另一种方式。如果用户已经到达了个人资料页面，我们希望他们通过点击应用程序栏中的按钮返回。首先，我们将在
    `bar` 文件夹中创建一个新的 `home.js` 文件，并输入以下代码：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We are using multiple React Router techniques here. We export the `Home` component
    through a `withRouter` HOC gives the `Home` component access to the `history`
    object of React Router. That is great because it means that we do not need to
    pass this object from the top of our React tree down to the `Home` component.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了多个 React Router 技术。我们通过 `withRouter` 高阶组件导出 `Home` 组件，这给了 `Home` 组件访问
    React Router 的 `history` 对象的权限。这很棒，因为它意味着我们不需要从 React 树的顶部向下传递这个对象。
- en: Furthermore, we use the `history` object to navigate the user to the news feed.
    In the `render` method, we return a button that, when clicked, runs the `history.push`
    function. This function adds the new path to the history of the browser and navigates
    the user to the `'/app'` main page. The good thing is that it works in the same
    way as the `Link` component and does not reload the entire website.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用`history`对象将用户导航到新闻源。在`render`方法中，我们返回一个按钮，当点击时，运行`history.push`函数。这个函数将新路径添加到浏览器的历史记录中，并将用户导航到`'/app'`主页面。好事是它和`Link`组件的工作方式相同，不会重新加载整个网站。
- en: 'There are a few things to do in order to get the button working, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让按钮工作，需要做一些事情，如下所示：
- en: 'Import the component into the `index.js` file of the `bar` folder, as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件导入到`bar`文件夹的`index.js`文件中，如下所示：
- en: '[PRE35]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, replace the `buttons` `div` tag with the following lines of code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`buttons` `div`标签替换为以下代码行：
- en: '[PRE36]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Wrap the two buttons in a separate `div` tag so that it is easier to align
    them correctly. You can replace the old CSS for the **Logout** button and add
    the following:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个按钮包裹在一个单独的`div`标签中，这样更容易正确地对齐它们。你可以替换旧的CSS样式用于**注销**按钮，并添加以下内容：
- en: '[PRE37]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now that we have everything together, the user can visit the profile page and
    navigate back again. Our final result looks like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经把所有东西都准备好了，用户可以访问个人资料页面并再次导航。我们的最终结果如下：
- en: '![Figure 8.1 – User profile'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – 用户个人资料'
- en: '](img/Figure_8.01_B17337.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.01_B17337.jpg)'
- en: Figure 8.1 – User profile
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 用户个人资料
- en: We have a big profile header for the user and their posts at the bottom of the
    window. At the top, you can see the top bar with the currently logged-in user.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在窗口底部为用户及其帖子有一个大的个人资料标题。在顶部，你可以看到带有当前登录用户的顶部栏。
- en: Remembering the redirect location
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记住重定向位置
- en: When a visitor comes to your page, they have probably followed a link that was
    posted elsewhere. This link is likely to be a direct address for a user, a post,
    or anything else that you offer direct access to. For those that are not logged
    in, we configured the application to redirect that person to the login or signup
    forms. This behavior makes sense. However, once that person has either logged
    in or signed up with a new account, they are then navigated to the news feed.
    A better way of doing this would be to remember the initial destination that the
    person wanted to visit. To do this, we will make a few changes to the router.
    Open the `router.js` file. With all of the routing components provided by React
    Router, we always get access to the properties inside of them. We will make use
    of this and save the last location that we were redirected from.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当访客来到你的页面时，他们可能遵循了在其他地方发布的链接。这个链接很可能是对用户、帖子或其他你提供直接访问内容的直接地址。对于未登录的用户，我们配置了应用程序将那个人重定向到登录或注册表单。这种行为是有意义的。然而，一旦那个人登录或使用新账户注册，他们就会被导航到新闻源。更好的做法是记住那个人最初想要访问的目的地。为了做到这一点，我们将对路由器做一些修改。打开`router.js`文件。使用React
    Router提供的所有路由组件，我们总是可以访问它们内部的属性。我们将利用这一点并保存我们最后重定向的最后一个位置。
- en: 'In the `PrivateRoute` component, swap out the `Redirect` component with the
    following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PrivateRoute`组件中，用以下代码替换`Redirect`组件：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we have added the `state` field. The value that it receives comes from
    the parent `Route` component, which holds the last matched path in the `props.location`
    field generated by React Router. The path can be a user's profile page or the
    news feed since both rely on the `PrivateRoute` component where authentication
    is required. When the preceding redirect is triggered, you receive the `from`
    field inside the router's state.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了`state`字段。它接收的值来自父`Route`组件，该组件持有由React Router生成的`props.location`字段中的最后一个匹配路径。路径可以是用户的个人资料页面或新闻源，因为两者都依赖于需要身份验证的`PrivateRoute`组件。当触发前面的重定向时，你会在路由器的状态中接收到`from`字段。
- en: 'We want to use this variable when the user is logging in. Replace the `Redirect`
    component in the `LoginRoute` component with the following lines of code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在用户登录时使用这个变量。将`LoginRoute`组件中的`Redirect`组件替换为以下代码行：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, I have introduced a small condition for the `pathname` parameter. If the
    `location.state` property is defined, we can rely on the `from` field. Previously,
    we stored the redirect path in the `PrivateRoute` component. If the `location.state`
    property does not exist, the user was not visiting a direct hyperlink but just
    wanted to log in normally. They will be navigated to the news feed with the `/app`
    path.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我为`pathname`参数引入了一个小条件。如果`location.state`属性已定义，我们可以依赖`from`字段。之前，我们在`PrivateRoute`组件中存储了重定向路径。如果`location.state`属性不存在，用户不是直接访问超链接，而是只想正常登录。他们将被导航到带有`/app`路径的新闻源。
- en: Your application should now be able to handle all routing scenarios, and this
    should allow your users to view your site comfortably.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序现在应该能够处理所有路由场景，这应该允许您的用户舒适地查看您的网站。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we transitioned from our one-screen application to a multi-page
    setup. React Router, our main library for routing purposes now has three paths,
    under which we display different parts of Graphbook. Furthermore, we now have
    a catch-all route, in which we can redirect the user to a valid page.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从单屏应用过渡到了多页布局。我们用于路由的主要库React Router现在有三个路径，在这些路径下我们展示了Graphbook的不同部分。此外，我们现在还有一个通配符路由，我们可以将用户重定向到一个有效的页面。
- en: In the next chapter, we will continue with this progression by implementing
    server-side rendering, which needs many adjustments on both the frontend and the
    backend.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过实现服务器端渲染来继续这种进步，这需要在前后端进行许多调整。
