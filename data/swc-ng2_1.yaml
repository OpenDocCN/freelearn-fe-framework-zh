- en: Chapter 1. Getting Started with Angular 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 开始使用Angular 2
- en: On September 18, 2014, the first public commit was pushed to the Angular 2 repository.
    A few weeks later, at **ng-europe**, Igor and Tobias from the core team gave a
    short overview of what Angular 2 was expected to be. The vision at that time was
    far from final; however, one thing was certain—the new version of the framework
    would be entirely different from AngularJS 1.x.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年9月18日，第一个公共提交被推送到Angular 2存储库。几周后，在ng-europe上，核心团队的Igor和Tobias简要概述了Angular
    2的预期。当时的愿景远非最终；然而，有一件事是确定的——新版本的框架将与AngularJS 1.x完全不同。
- en: This announcement brought a lot of questions and controversy. The reasons behind
    the drastic changes were quite clear—AngularJS 1.x was no longer able to take
    full advantage of the evolved Web and to completely satisfy the requirements of
    large-scale JavaScript applications. A new framework would let Angular developers
    capitalize on developments in web technology in simpler and more direct ways.
    Yet, people were concerned. One of the biggest nightmares with backward incompatibility
    for developers is the migration of their current codebases to the new version
    of the third-party software they use. In Angular's case, after that first announcement,
    migration looked daunting, even impossible. Later, at **ng-conf** 2015 and **ng-vegas**,
    different migration strategies were introduced. The Angular community came together
    and shared additional ideas, anticipating the benefits of Angular 2 while preserving
    the things learned from AngularJS 1.x.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这一公告引发了许多问题和争议。变化背后的原因非常明确——AngularJS 1.x不再能充分利用发展中的Web，并且无法完全满足大规模JavaScript应用程序的要求。一个新的框架将让Angular开发人员以更简单、更直接的方式利用Web技术的发展。然而，人们感到担忧。对于开发人员来说，与第三方软件的新版本进行迁移是最大的噩梦之一。在Angular的情况下，宣布后，迁移看起来令人生畏，甚至不可能。后来，在ng-conf
    2015和ng-vegas上，引入了不同的迁移策略。Angular社区汇聚在一起，分享额外的想法，预期Angular 2的好处，同时保留了从AngularJS
    1.x中学到的东西。
- en: This book is a part of that project. Making the upgrade to Angular 2 is non-trivial,
    but it is worth it. The main drivers behind the drastic changes in Angular 2 and
    its lack of backward compatibility are the evolution of the Web, and the lessons
    learned from the usage of AngularJS 1.x in the wild. Switching to Angular 2 will
    help you to learn the new framework by understanding how we got here and why Angular's
    new features make intuitive sense for the modern Web in building high-performance,
    scalable, single-page applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是该项目的一部分。升级到Angular 2并不容易，但是很值得。Angular 2背后的主要驱动因素是Web的发展，以及从在野外使用AngularJS
    1.x中所学到的经验。切换到Angular 2将帮助您通过了解我们是如何到达这里以及为什么Angular的新特性对于构建高性能、可扩展的单页应用程序在现代Web中具有直观意义来学习新框架。
- en: The evolution of the Web – time for a new framework
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web的发展——是时候使用新框架了
- en: In the last couple of years, the Web has evolved in big steps. During the implementation
    of ECMAScript 5, the ECMAScript 6 standard started its development (now known
    as **ECMAScript 2015** or **ES2015**). ES2015 introduced many changes in the language
    such as adding built-in language support for modules, block scope variable definition,
    and a lot of syntactical sugar, such as classes and destructuring.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，网络发展迅速。在实施ECMAScript 5的同时，ECMAScript 6标准开始了开发（现在被称为ECMAScript 2015或ES2015）。ES2015在语言中引入了许多变化，例如为模块添加内置语言支持，块作用域变量定义，以及许多语法糖，如类和解构。
- en: Meanwhile, **Web Components** were invented. Web Components allow us to define
    custom HTML elements and attach behavior to them. Since it is hard to extend the
    existing HTML elements with new ones (such as dialogs, charts, grids, and more)
    mostly because of the time required for consolidation and standardization of their
    APIs, a better solution is to allow developers to extend the existing elements
    the way they want. Web Components provide us with a number of benefits, including
    better encapsulation, better semantics of the markup we produce, better modularity,
    and easier communication between developers and designers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，**Web Components**被发明了。Web Components允许我们定义自定义HTML元素并为其附加行为。由于扩展现有HTML元素（如对话框、图表、网格等）很难，主要是因为需要时间来巩固和标准化它们的API，更好的解决方案是允许开发人员按照他们的意愿扩展现有元素。Web
    Components为我们提供了许多好处，包括更好的封装性，我们生成的标记的更好语义，更好的模块化，以及开发人员和设计人员之间更容易的沟通。
- en: We know that JavaScript is a single-threaded language. Initially, it was developed
    for simple client-side scripting, but over time, its role has shifted quite a
    bit. Now with HTML5, we have different APIs that allow audio and video processing,
    communication with external services through a two-directional communication channel,
    transferring and processing big chunks of raw data, and more. All these heavy
    computations in the main thread may create a poor user experience. They may introduce
    freezing of the user interface when time-consuming computations are being performed.
    This led to the development of **WebWorkers**, which allow the execution of the
    scripts in the background that communicate with the main thread through message
    passing. This way, multi-threaded programming has been brought to the browser.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道JavaScript是一种单线程语言。最初，它是为了简单的客户端脚本而开发的，但随着时间的推移，它的作用发生了很大变化。现在有了HTML5，我们有了不同的API，允许音频和视频处理，通过双向通信渠道与外部服务通信，传输和处理大块原始数据等。主线程中的所有这些繁重计算可能会导致用户体验不佳。当执行耗时计算时，可能会导致用户界面冻结。这导致了**WebWorkers**的开发，它允许在后台执行脚本，并通过消息传递与主线程通信。这样，多线程编程被引入到了浏览器中。
- en: 'Some of these APIs were introduced after the development of AngularJS 1.x had
    begun; that''s why the framework wasn''t build with most of them in mind. However,
    exploiting the APIs gives developers many benefits, such as:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些API是在AngularJS 1.x的开发之后引入的；这就是为什么框架并没有考虑大部分API。然而，利用这些API给开发人员带来了许多好处，比如：
- en: Significant performance improvements.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显著的性能改进。
- en: Development of software with better quality characteristics.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发具有更好质量特征的软件。
- en: Now let's briefly discuss how each of these technologies has been made part
    of the new Angular core and why.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们简要讨论这些技术如何成为新的Angular核心的一部分，以及原因。
- en: The evolution of ECMAScript
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript的发展
- en: Nowadays, browser vendors are releasing new features in short iterations, and
    users receive updates quite often. This helps move the Web forward by allowing
    developers to take advantage of the bleeding-edge technologies, aiming to improve
    the Web. ES2015 is already standardized. The implementation of the latest version
    of the language has already started in the major browsers. Learning the new syntax
    and taking advantage of it will not only increase our productivity as developers,
    but also prepare us for the near future when all the browsers will have full support
    for it. This makes it essential to start using the latest syntax now.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，浏览器供应商以短迭代的方式发布新功能，用户经常收到更新。这有助于推动Web前进，使开发人员能够利用尖端技术，旨在改进Web。ES2015已经标准化。最新版本的语言已经在主要浏览器中开始实现。学习新的语法并利用它不仅会提高我们作为开发人员的生产力，还会为我们在不久的将来当所有浏览器都完全支持它时做好准备。这使得现在开始使用最新的语法至关重要。
- en: Some projects' requirements may enforce us to support older browsers, which
    does not support any ES2015 features. In this case, we can directly write ECMAScript
    5, which has different syntax but equivalent semantics to ES2015\. However, we
    can take advantage of the process of **transpilation**. Using a transpiler in
    our build process allows us to take advantage of the new syntax by writing ES2015
    and translating it to a target language that is supported by the browsers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目的要求可能要求我们支持不支持任何ES2015功能的旧浏览器。在这种情况下，我们可以直接编写ECMAScript 5，它具有不同的语法，但与ES2015具有等效的语义。然而，我们可以利用**转译**的过程。在我们的构建过程中使用转译器可以让我们通过编写ES2015并将其转换为浏览器支持的目标语言来利用新的语法。
- en: AngularJS has been around since 2009\. Back then, the frontend of most websites
    was powered by ECMAScript 3, the last main release of ECMAScript prior to ECMAScript
    5\. This automatically meant that the language used for the framework's implementation
    was ECMAScript 3\. Taking advantage of the new version of the language requires
    porting of the entirety of AngularJS 1.x to ES2015.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS自2009年以来就存在。当时，大多数网站的前端都是由ECMAScript 3驱动的，这是ECMAScript 5之前的最后一个主要版本。这自动意味着框架实现所使用的语言是ECMAScript
    3。利用新版本的语言需要将整个AngularJS 1.x移植到ES2015。
- en: From the beginning, Angular 2 took into account the current state of the Web
    by bringing the latest syntax in the framework. Although Angular 2 is written
    with a superset of ES2016 (TypeScript, which we're going to take a look at in
    a moment), it allows developers to use language of their own preference. We can
    use ES2015 or, if we prefer not to have any intermediate preprocessing of our
    code and simplify the build process, even ECMAScript 5.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，Angular 2就考虑到了Web的当前状态，引入了框架中的最新语法。虽然Angular 2是用ES2016的超集（TypeScript）编写的（我们马上会看一下），但它允许开发人员使用他们自己喜欢的语言。我们可以使用ES2015，或者，如果我们不想对我们的代码进行任何中间预处理并简化构建过程，甚至可以使用ECMAScript
    5。
- en: Web Components
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web组件
- en: The first public draft of Web Components was published on May 22, 2012, about
    three years after the release of AngularJS 1.x. As mentioned, the Web Components
    standard allows us to create custom elements and attach behavior to them. It sounds
    familiar; we've already used similar concept in the development of the user interface
    in AngularJS 1.x applications. Web Components sound like an alternative to Angular
    directives; however, they have more intuitive API, richer functionality, and built-in
    browser support. They introduced a few other benefits such as better encapsulation,
    which is very important, for example, in handling CSS-style collisions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Web Components的第一个公开草案于2012年5月22日发布，大约在发布AngularJS 1.x三年后。正如前面提到的，Web Components标准允许我们创建自定义元素并为其附加行为。听起来很熟悉；我们已经在AngularJS
    1.x应用程序的用户界面开发中使用了类似的概念。Web Components听起来像是Angular指令的替代品；然而，它们具有更直观的API、更丰富的功能和内置的浏览器支持。它们引入了一些其他好处，比如更好的封装，这在处理CSS样式冲突方面非常重要。
- en: A possible strategy for adding Web Components support in AngularJS 1.x is to
    change the directives implementation and introduce primitives of the new standard
    in the DOM compiler. As Angular developers, we know how powerful but also complex
    the directives API is. It includes a lot of properties such as `postLink`, `preLink`,
    `compile`, `restrict`, `scope`, `controller`, and many more, and of course, our
    favorite `transclude`. Approved as standard, Web Components will be implemented
    on a much lower level in the browsers, which introduces plenty of benefits such
    as better performance and native API.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS 1.x中添加Web Components支持的一种可能策略是改变指令的实现，并在DOM编译器中引入新标准的原语。作为Angular开发人员，我们知道指令API是多么强大但也复杂。它包括许多属性，如`postLink`、`preLink`、`compile`、`restrict`、`scope`、`controller`等等，当然还有我们最喜欢的`transclude`。作为标准，Web
    Components将在浏览器中以更低的级别实现，这带来了许多好处，比如更好的性能和本机API。
- en: During the implementation of Web Components, a lot of web specialists met the
    same problems the Angular team did when developing the directives API and came
    up with similar ideas. Good design decisions behind Web Components include the
    **content** element, which deals with the infamous transclusion problem in AngularJS
    1.x. Since both the directives API and Web Components solve similar problems in
    different ways, keeping the directives API on top of Web Components would have
    been redundant and added unnecessary complexity. That's why the Angular core team
    decided to start from the beginning by building on top of Web Components and taking
    full advantage of the new standard. Web Components involves new features, some
    of them not yet implemented by all browsers. In case our application is run in
    a browser, which does not support any of these features natively, Angular 2 emulates
    them. An example for this is the content element polyfilled with the directive,
    `ng-content`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现Web Components时，许多网络专家遇到了与Angular团队在开发指令API时遇到的相同问题，并提出了类似的想法。Web Components背后的良好设计决策包括**content**元素，它解决了AngularJS
    1.x中臭名昭著的transclusion问题。由于指令API和Web Components以不同的方式解决了类似的问题，将指令API保留在Web Components之上将是多余的，并增加了不必要的复杂性。这就是为什么Angular核心团队决定从头开始，构建在Web
    Components之上，并充分利用新标准的原因。Web Components涉及新功能，其中一些尚未被所有浏览器实现。如果我们的应用程序在不支持这些功能的浏览器中运行，Angular
    2会模拟它们。一个例子是使用指令`ng-content`来模拟content元素。
- en: WebWorkers
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebWorkers
- en: JavaScript is known for its event loop. Usually JavaScript programs are executed
    in a single thread and different events are scheduled by being pushed in a queue
    and processed sequentially, in the order of their arrival. However, this computational
    strategy is not effective when one of the scheduled events requires a lot of computational
    time. In such cases the event's handling is going to block the main thread and
    all other events are not going to be handled until the time consuming computation
    is complete and passes the execution to the next one in the queue. A simple example
    of this is a mouse click that triggers an event, in which callback we do some
    audio processing using the HTML5 audio API. If the processed audio track is big
    and the algorithm running over it is heavy, this will affect the user's experience
    by freezing the UI until the execution is complete.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript以其事件循环而闻名。通常，JavaScript程序在单个线程中执行，并且不同的事件被推送到队列中并按顺序依次处理，按照它们到达的顺序。然而，当计划的事件之一需要大量的计算时间时，这种计算策略就不够有效了。在这种情况下，事件的处理将阻塞主线程，并且直到耗时的计算完成并将执行传递给队列中的下一个事件之前，所有其他事件都不会被处理。一个简单的例子是鼠标点击触发一个事件，在回调中我们使用HTML5音频API进行一些音频处理。如果处理的音轨很大，算法运行的负担很重，这将影响用户体验，直到执行完成为止，界面会被冻结。
- en: The WebWorker API was introduced in order to prevent such pitfalls. It allows
    execution of heavy computations inside the context of different thread, which
    leaves the main thread of execution free, capable of handling user input and rendering
    the user interface.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: WebWorker API的引入是为了防止这种陷阱。它允许在不同线程的上下文中执行重型计算，这样可以使主执行线程空闲，能够处理用户输入和渲染用户界面。
- en: 'How can we take advantage of this in Angular? In order to answer this question,
    let''s think about how things work in AngularJS 1.x. What if we have an enterprise
    application, which processes a huge amount of data that needs to be rendered on
    the screen using data binding? For each binding, a new watcher will be added.
    Once the digest loop is run, it will loop over all the watchers, execute the expressions
    associated with them, and compare the returned results with the results gained
    from the previous iteration. We have a few slowdowns here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在Angular中利用这一点？为了回答这个问题，让我们想一想在AngularJS 1.x中的工作原理。假设我们有一个企业应用程序，需要处理大量数据，并且需要使用数据绑定在屏幕上呈现这些数据。对于每个绑定，都会添加一个新的观察者。一旦digest循环运行，它将遍历所有观察者，执行与它们相关的表达式，并将返回的结果与上一次迭代获得的结果进行比较。我们在这里有一些减速：
- en: The iteration over large number of watchers.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对大量观察者进行迭代。
- en: Evaluation of expression in given context.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给定上下文中评估表达式。
- en: Copy of the returned result.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回结果的副本。
- en: Comparison between the current result of the expression's evaluation and the
    previous one.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式评估的当前结果与先前结果之间的比较。
- en: All these steps could be quite slow depending on the size of the input. If the
    digest loop involves heavy computations, why not move it to a WebWorker? Why not
    run the digest loop inside WebWorker, get the changed bindings, and apply them
    to the DOM?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤可能会相当慢，具体取决于输入的大小。如果digest循环涉及重型计算，为什么不将其移动到WebWorker中呢？为什么不在WebWorker中运行digest循环，获取更改的绑定，并将其应用于DOM？
- en: There were experiments by the community, which aimed for this result. However,
    their integration into the framework wasn't trivial. One of the main reasons behind
    the lack of satisfying results was the coupling of the framework with the DOM.
    Often, inside the watchers' callbacks, Angular directly manipulates the DOM, which
    makes it impossible to move the watchers inside WebWorkers since the WebWorkers
    are invoked in an isolated context, without access to the DOM. In AngularJS 1.x,
    we may have implicit or explicit dependencies between the different watchers,
    which require multiple iterations of the digest loop in order to get stable results.
    Combining the last two points, it is quite hard to achieve practical results in
    calculating the changes in threads other than the main thread of execution.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 社区进行了试验，旨在达到这一目标。然而，它们与框架的整合并不是简单的。令人不满意的结果背后的主要原因之一是框架与DOM的耦合。在监视器的回调函数中，Angular经常直接操作DOM，这使得将监视器移动到WebWorkers中变得不可能，因为WebWorkers在隔离的上下文中被调用，无法访问DOM。在AngularJS
    1.x中，我们可能存在不同监视器之间的隐式或显式依赖关系，这需要多次迭代digest循环才能获得稳定的结果。结合最后两点，很难在除执行主线程之外的线程中实现实际结果。
- en: Fixing this in AngularJS 1.x introduces a great deal of complexity in the internal
    implementation. The framework simply was not built with this in mind. Since WebWorkers
    were introduced before the Angular 2 design process started, the core team took
    them in mind from the beginning.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS 1.x中修复这个问题会在内部实现中引入大量的复杂性。这个框架根本就没有考虑到这一点。由于WebWorkers是在Angular 2设计过程开始之前引入的，核心团队从一开始就考虑到了它们。
- en: Lessons learned from AngularJS 1.x in the wild
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在野外学到的AngularJS 1.x的教训
- en: Although the previous section introduced a lot of arguments for the required
    reimplementation of the framework responding to the latest trends, it's important
    to remember that we're not starting completely from scratch. We're taking what
    we've learned from AngularJS 1.x with us. In the period since 2009, the Web is
    not the only thing that evolved. We also started building more and more complex
    applications. Today, single-page applications are not something exotic, but more
    like a strict requirement for all the web applications solving business problems,
    which are aiming for high performance and good user experience.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前一部分介绍了需要重新实现框架以响应最新趋势的许多论点，但重要的是要记住我们并不是完全从零开始。我们将从AngularJS 1.x中学到的东西带到了现在。自2009年以来，Web不是唯一发展的东西。我们还开始构建越来越复杂的应用程序。如今，单页应用程序不再是什么奇特的东西，而更像是解决业务问题的所有Web应用程序的严格要求，它们旨在实现高性能和良好的用户体验。
- en: AngularJS 1.x helped us to build highly-efficient and large-scale single-page
    applications. However, by applying it in various use cases, we've also discovered
    some of its pitfalls. Learning from the community's experience, Angular's core
    team worked on new ideas aiming to answer the new requirements. As we look at
    the new features of Angular 2, let's consider them in the light of the current
    implementation of AngularJS 1.x and think about the things with which we, as Angular
    developers, have struggled and which we have modified over the last few years.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 1.x帮助我们构建了高效和大规模的单页应用程序。然而，通过在各种用例中应用它，我们也发现了一些缺点。从社区的经验中学习，Angular的核心团队致力于新的想法，旨在满足新的需求。当我们看着Angular
    2的新特性时，让我们以AngularJS 1.x的当前实现为背景来考虑它们，并思考我们作为Angular开发人员在过去几年中所挣扎和修改的事情。
- en: Controllers
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: AngularJS 1.x follows the **Model View Controller** (**MVC**) micro-architectural
    pattern. Some may argue that it looks more like **Model View ViewModel** (**MVVM**)
    because of the view model attached as properties to the scope or the current context
    in case of controller as syntax. It could be approached differently again if we
    use the **Model View Presenter pattern** (**MVP**). Because of all the different
    variations of how we can structure the logic in our applications the core team
    called AngularJS 1.x a **Model View Whatever** (**MVW**) framework.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 1.x遵循**模型视图控制器**（**MVC**）微架构模式。有人可能会认为它看起来更像**模型视图视图模型**（**MVVM**），因为视图模型作为作用域或当前上下文附加到作用域或控制器的属性。如果我们使用**模型视图呈现器模式**（**MVP**），它可能会以不同的方式进行处理。由于我们可以在应用程序中构造逻辑的不同变体，核心团队将AngularJS
    1.x称为**模型视图任何**（**MVW**）框架。
- en: The view in any AngularJS application is supposed to be a composition of directives.
    The directives collaborate together in order to deliver fully functional user
    interfaces. Services are responsible for encapsulating the business logic of the
    applications. That's the place where we should put the communication with RESTful
    services through HTTP, real-time communication with WebSockets and even WebRTC.
    Services are the building block where we should implement the domain models and
    business rules of our applications. There's one more component, which is mostly
    responsible for handling user input and delegating the execution to the services—the
    controller.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何AngularJS应用程序中，视图应该是指令的组合。指令共同协作，以提供完全功能的用户界面。服务负责封装应用程序的业务逻辑。这是我们应该与RESTful服务通过HTTP进行通信，与WebSockets进行实时通信甚至WebRTC的地方。服务是我们应该实现应用程序的领域模型和业务规则的构建模块。还有一个组件，主要负责处理用户输入并将执行委托给服务
    - 控制器。
- en: Although the services and directives have well-defined roles, we can often see
    the anti-pattern of the **Massive View Controller**, which is common in iOS applications.
    Occasionally, developers are tempted to access or even manipulate the DOM directly
    from their controllers. Initially, this happens for achieving something simple,
    such as changing the size of an element, or quick and dirty changing elements'
    styles. Another noticeable anti-pattern is duplication of business logic across
    controllers. Often developers tend to copy and paste logic, which should be encapsulated
    inside services.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管服务和指令有明确定义的角色，但我们经常会看到**大型视图控制器**的反模式，这在iOS应用程序中很常见。偶尔，开发人员会尝试直接从他们的控制器访问甚至操作DOM。最初，这是为了实现一些简单的事情，比如更改元素的大小，或者快速而肮脏地更改元素的样式。另一个明显的反模式是在控制器之间复制业务逻辑。开发人员经常倾向于复制和粘贴应该封装在服务中的逻辑。
- en: The best practices for building AngularJS applications state is that the controllers
    should not manipulate the DOM at all, instead all DOM access and manipulations
    should be isolated in directives. If we have some repetitive logic between controllers,
    most likely we want to encapsulate it into a service and inject this service with
    the dependency injection mechanism of AngularJS in all the controllers that need
    that functionality.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 构建AngularJS应用程序的最佳实践是，控制器不应该在任何情况下操作DOM，而是所有DOM访问和操作应该在指令中进行隔离。如果在控制器之间有一些重复的逻辑，很可能我们希望将其封装到一个服务中，并使用AngularJS的依赖注入机制在所有需要该功能的控制器中注入该服务。
- en: This is where we're coming from in AngularJS 1.x. All this said, it seems that
    the functionality of controllers could be moved into the directive's controllers.
    Since directives support the dependency injection API, after receiving the user's
    input, we can directly delegate the execution to a specific service, already injected.
    This is the main reason Angular 2 uses a different approach by removing the ability
    to put controllers everywhere by using the `ng-controller` directive. We'll take
    a look at how AngularJS 1.x controllers' responsibilities could be taken from
    Angular 2 components and directives in [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在AngularJS 1.x中的出发点。尽管如此，似乎控制器的功能可以移动到指令的控制器中。由于指令支持依赖注入API，在接收用户输入后，我们可以直接将执行委托给特定的服务，已经注入。这是Angular
    2使用不同方法的主要原因，通过使用`ng-controller`指令来阻止在任何地方放置控制器。我们将在[第4章](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "第4章。开始使用Angular 2组件和指令")中看看如何从Angular 2组件和指令中取代AngularJS 1.x控制器的职责，*开始使用Angular
    2组件和指令*。
- en: Scope
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域
- en: 'The data-binding in AngularJS is achieved using the `scope` object. We can
    attach properties to it and explicitly declare in the template that we want to
    bind to these properties (one or two-way). Although the idea of the scope seems
    clear, the scope has two more responsibilities, including event dispatching and
    the change detection-related behavior. Angular beginners have a hard time understanding
    what scope really is and how it should be used. AngularJS 1.2 introduced something
    called **controller as syntax**. It allows us to add properties to the current
    context inside the given controller (`this`), instead of explicitly injecting
    the `scope` object and later adding properties to it. This simplified syntax can
    be demonstrated from the following snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS中，数据绑定是通过`scope`对象实现的。我们可以将属性附加到它，并在模板中明确声明我们要绑定到这些属性（单向或双向）。尽管scope的概念似乎很清晰，但scope还有两个额外的责任，包括事件分发和与变更检测相关的行为。Angular初学者很难理解scope到底是什么，以及应该如何使用它。AngularJS
    1.2引入了**controller as语法**。它允许我们向给定控制器内的当前上下文（`this`）添加属性，而不是显式注入`scope`对象，然后再向其添加属性。这种简化的语法可以从以下片段中演示：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Angular 2 took this even further by removing the `scope` object. All the expressions
    are evaluated in the context of given UI component. Removing the entire scope
    API introduces higher simplicity; we don't need to explicitly inject it anymore
    and we add properties to the UI components to which we can later bind. This API
    feels much simpler and more natural.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2更进一步，通过移除`scope`对象来实现。所有表达式都在给定UI组件的上下文中进行评估。移除整个scope API引入了更高的简单性；我们不再需要显式注入它，而是将属性添加到UI组件中，以便稍后绑定。这个API感觉更简单和更自然。
- en: We're going to take more detailed look at the components and the change detection
    mechanism of Angular 2 in [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582 "第4章。开始使用Angular
    2组件和指令")中更详细地了解Angular 2组件和变更检测机制，*开始使用Angular 2组件和指令*。
- en: Dependency Injection
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Maybe the first framework on the market that included **inversion of control**
    (**IoC**) through **dependency injection** (**DI**) in the JavaScript world was
    AngularJS 1.x. DI provides a number of benefits, such as easier testability, better
    code organization and modularization, and simplicity. Although the DI in 1.x does
    an amazing job, Angular 2 takes this even further. Since Angular 2 is on top of
    the latest web standards, it uses the ECMAScript 2016 decorators' syntax for annotating
    the code for using DI. Decorators are quite similar to the decorators in Python
    or annotations in Java. They allow us to *decorate* the behavior of a given object
    by using reflection. Since decorators are not yet standardized and supported by
    major browsers, their usage requires an intermediate transpilation step; however,
    if you don't want to take it, you can directly write a little bit more verbose
    code with ECMAScript 5 syntax and achieve the same semantics.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 也许在JavaScript世界中，市场上第一个包括**控制反转**（**IoC**）和**依赖注入**（**DI**）的框架是AngularJS 1.x。DI提供了许多好处，比如更容易进行测试，更好的代码组织和模块化，以及简单性。尽管1.x中的DI做得很出色，但Angular
    2更进一步。由于Angular 2建立在最新的web标准之上，它使用ECMAScript 2016装饰器语法来注释代码以使用DI。装饰器与Python中的装饰器或Java中的注解非常相似。它们允许我们通过反射来*装饰*给定对象的行为。由于装饰器尚未标准化并且得到主要浏览器的支持，它们的使用需要一个中间的转译步骤；但是，如果你不想这样做，你可以直接使用更加冗长的ECMAScript
    5语法编写代码，并实现相同的语义。
- en: The new DI is much more flexible and feature-rich. It also fixes some of the
    pitfalls of AngularJS 1.x such as the different APIs; in 1.x, some objects are
    injected by position (such as the scope, element, attributes, and controller in
    the directives' link function) and others, by name (using parameters names in
    controllers, directives, services, and filters).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 新的DI更加灵活和功能丰富。它也修复了AngularJS 1.x的一些缺陷，比如不同的API；在1.x中，一些对象是按位置注入的（比如在指令的链接函数中的作用域、元素、属性和控制器），而其他对象是按名称注入的（在控制器、指令、服务和过滤器中使用参数名称）。
- en: We will take a further look at the Angular 2's dependency injection API in [Chapter
    5](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582 "Chapter 5. Dependency
    Injection in Angular 2"), *Dependency Injection in Angular 2*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第5章](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582 "Chapter 5. Dependency
    Injection in Angular 2")中进一步了解Angular 2的依赖注入API，*Angular 2中的依赖注入*。
- en: Server-side rendering
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: The bigger the requirements of the Web are, the more complex the web applications
    become. Building a real-life, single-page application requires writing a huge
    amount of JavaScript, and including all the required external libraries may increase
    the size of the scripts on our page to a few megabytes. The initialization of
    the application may take up to several seconds or even tens of seconds on mobile
    until all the resources get fetched from the server, the JavaScript is parsed
    and executed, the page gets rendered, and all the styles are applied. On low-end
    mobile devices that use a mobile Internet connection, this process may make the
    users give up on visiting our application. Although there are a few practices
    that speed up this process, in complex applications, there's no silver bullet.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Web的需求越大，web应用程序就变得越复杂。构建一个真实的单页面应用程序需要编写大量的JavaScript，并且包括所有必需的外部库可能会增加页面上脚本的大小达到几兆字节。应用程序的初始化可能需要几秒甚至几十秒，直到所有资源从服务器获取，JavaScript被解析和执行，页面被渲染，所有样式被应用。在使用移动互联网连接的低端移动设备上，这个过程可能会让用户放弃访问我们的应用程序。尽管有一些加速这个过程的做法，在复杂的应用程序中，并没有一种万能的解决方案。
- en: In the process of trying to improve the user experience, developers discovered
    something called **server-side rendering**. It allows us to render the requested
    view of a single-page application on the server and directly provide the HTML
    for the page to the user. Later, once all the resources are processed, the event
    listeners and bindings can be added by the script files. This sounds like a good
    way to boost the performance of our application. One of the pioneers in this was
    ReactJS, which allowed pre-rendering of the user interface on the server side
    using Node.js DOM implementations. Unfortunately, the architecture of AngularJS
    1.x does not allow this. The showstopper is the strong coupling between the framework
    and the browser APIs, the same issue we had in running the change detection in
    WebWorkers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在努力改善用户体验的过程中，开发人员发现了一种称为**服务器端渲染**的东西。它允许我们在服务器上渲染单页应用程序的请求视图，并直接向用户提供页面的HTML。稍后，一旦所有资源都被处理，事件监听器和绑定可以由脚本文件添加。这听起来像是提高应用程序性能的好方法。在这方面的先驱之一是ReactJS，它允许使用Node.js
    DOM实现在服务器端预渲染用户界面。不幸的是，AngularJS 1.x的架构不允许这样做。阻碍因素是框架与浏览器API之间的强耦合，这与在WebWorkers中运行变更检测时遇到的问题相同。
- en: Another typical use case for the server-side rendering is for building **Search
    Engine Optimization** (**SEO**)-friendly applications. There were a couple of
    hacks used in the past for making the AngularJS 1.x applications indexable by
    the search engines. One such practice, for instance, is traversal of the application
    with a headless browser, which executes the scripts on each page and caches the
    rendered output into HTML files, making it accessible by the search engines.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染的另一个典型用例是构建**搜索引擎优化**（**SEO**）友好的应用程序。过去有一些技巧用于使AngularJS 1.x应用程序可以被搜索引擎索引。例如，一种做法是使用无头浏览器遍历应用程序，执行每个页面上的脚本并将渲染输出缓存到HTML文件中，使其可以被搜索引擎访问。
- en: Although this workaround for building SEO-friendly applications works, server-side
    rendering solves both of the mentioned issues, improving the user experience and
    allowing us to build SEO-friendly applications much more easily and far more elegantly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管构建SEO友好的应用程序的这种变通方法有效，但服务器端渲染解决了上述两个问题，改善了用户体验，并使我们能够更轻松、更优雅地构建SEO友好的应用程序。
- en: The decoupling of Angular 2 with the DOM allows us to run our Angular 2 applications
    outside the context of the browser. The community took advantage of this by building
    a tool, allowing us to prerender the views of our single-page application on the
    server side and forward them to the browser. At the time of writing the following
    content, the tool is still in the early phases of its development and is outside
    the framework's core. We're going to take a further look at it in [Chapter 8](part0075_split_000.html#27GQ62-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 8. Development Experience and Server-Side Rendering"), *Development Experience
    and Server-Side Rendering*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2与DOM的解耦使我们能够在浏览器之外运行我们的Angular 2应用程序。社区利用这一点构建了一个工具，允许我们在服务器端预渲染我们单页应用程序的视图并将其转发到浏览器。在撰写本文时，该工具仍处于早期开发阶段，不在框架的核心之内。我们将在[第8章](part0075_split_000.html#27GQ62-a118c4c18dd64e8ab73e171b466b6582
    "第8章。开发体验和服务器端渲染"), *开发体验和服务器端渲染*中进一步了解它。
- en: Applications that scale
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可以扩展的应用程序。
- en: 'MVW has been the default choice for building single-page applications since
    Backbone.js appeared. It allows separation of concerns by isolating the business
    logic from the view, allowing us to build well-designed applications. Exploiting
    the observer pattern, MVW allows listening for model changes in the view and updating
    it when changes are detected. However, there are some explicit and implicit dependencies
    between these event handlers, which make the dataflow in our applications not
    obvious and hard to reason about. In AngularJS 1.x, we are allowed to have dependencies
    between the different watchers, which requires the digest loop to iterate over
    all of them a couple of times until the expressions'' results get stable. Angular
    2 makes the data-flow one-directional, which has a number of benefits, including:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 自Backbone.js出现以来，MVW一直是构建单页应用程序的默认选择。它通过将业务逻辑与视图隔离，允许我们构建设计良好的应用程序。利用观察者模式，MVW允许在视图中监听模型的变化，并在检测到变化时进行更新。然而，这些事件处理程序之间存在一些显式和隐式的依赖关系，这使得我们应用程序中的数据流不明显且难以推理。在AngularJS
    1.x中，我们允许在不同的监视器之间存在依赖关系，这要求摘要循环多次迭代，直到表达式的结果稳定。Angular 2使数据流单向化，这带来了许多好处，包括：
- en: More explicit data-flow.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更明确的数据流。
- en: No dependencies between bindings, so no **time to live** (**TTL**) of the digest.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定之间没有依赖关系，因此没有摘要的**生存时间**（**TTL**）。
- en: 'Better performance:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的性能：
- en: The digest loop is run only once.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摘要循环仅运行一次。
- en: We can create apps, which are friendly to immutable/observable models, that
    allows us to make further optimizations.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建友好于不可变/可观察模型的应用程序，这使我们能够进行进一步的优化。
- en: The change in the data-flow introduces one more fundamental change in AngularJS
    1.x architecture.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流的变化在AngularJS 1.x架构中引入了一个更根本的变化。
- en: We may take another perspective on this problem when we need to maintain a large
    codebase written in JavaScript. Although JavaScript's duck typing makes the language
    quite flexible, it also makes its analysis and support by IDEs and text editors
    harder. Refactoring of large projects gets very hard and error-prone because in
    most cases, the static analysis and type inference are impossible. The lack of
    compiler makes typos all too easy, which are hard to notice until we run our test
    suite or run the application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要维护用JavaScript编写的大型代码库时，我们可能会从另一个角度看待这个问题。尽管JavaScript的鸭子类型使语言非常灵活，但它也使得IDE和文本编辑器对其分析和支持更加困难。在大型项目中进行重构变得非常困难和容易出错，因为在大多数情况下，静态分析和类型推断是不可能的。缺乏编译器使得拼写错误变得非常容易，直到我们运行测试套件或运行应用程序之前都很难注意到。
- en: '![Applications that scale](../images/00002.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![可扩展的应用程序](../images/00002.jpeg)'
- en: The Angular core team decided to use TypeScript because of the better tooling
    possible with it and the compile-time type checking, which help us be more productive
    and less error-prone. As the preceding figure shows, TypeScript is a superset
    of ECMAScript; it introduces explicit type annotations and a compiler. The TypeScript
    language is compiled to plain JavaScript, supported by today's browsers. Since
    version 1.6, TypeScript implements the ECMAScript 2016 decorators, which makes
    it the perfect choice for Angular 2.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Angular核心团队决定使用TypeScript，因为它具有更好的工具，并且具有编译时类型检查，这有助于我们更加高效和减少出错。正如前面的图所示，TypeScript是ECMAScript的超集；它引入了显式类型注解和编译器。TypeScript语言被编译为纯JavaScript，受到今天浏览器的支持。自1.6版本以来，TypeScript实现了ECMAScript
    2016装饰器，这使其成为Angular 2的完美选择。
- en: The usage of TypeScript allows much better IDE and text editors support with
    static code analysis and type checking. All this increases our productivity dramatically
    by reducing the mistakes we make and simplifying the refactoring process. Another
    important benefit of TypeScript is the performance improvement we implicitly get
    by the static typing, which allows run-time optimizations by the JavaScript virtual
    machine.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的使用允许更好的IDE和文本编辑器支持，具有静态代码分析和类型检查。所有这些都通过减少我们的错误和简化重构过程，显著提高了我们的生产力。TypeScript的另一个重要好处是通过静态类型，我们隐含地获得了性能改进，这允许JavaScript虚拟机进行运行时优化。
- en: We'll be talking about TypeScript in detail in [Chapter 3](part0027_split_000.html#PNV61-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 3. TypeScript Crash Course"), *TypeScript Crash Course*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](part0027_split_000.html#PNV61-a118c4c18dd64e8ab73e171b466b6582 "Chapter 3. TypeScript
    Crash Course")中详细讨论TypeScript，*TypeScript Crash Course*。
- en: Templates
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: Templates are one of the key features in AngularJS 1.x. They are simple HTML
    and do not require any intermediate processing and compilation, unlike most template
    engines such as mustache. Templates in AngularJS combine simplicity with power
    by allowing us to extend HTML by creating an internal **Domain Specific Language**
    (**DSL**) inside it, with custom elements and attributes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是AngularJS 1.x中的关键特性之一。它们是简单的HTML，不需要任何中间处理和编译，不像大多数模板引擎（如mustache）。AngularJS中的模板通过创建内部的**领域特定语言**（**DSL**）来将简单性与强大性相结合，通过自定义元素和属性来扩展HTML。
- en: However, this is one of the main purposes behind web components as well. We
    already mentioned how and why Angular 2 takes advantage of this new technology.
    Although AngularJS 1.x templates are great, they can still get better! Angular
    2 templates took the best parts of the ones in the previous release of the framework
    and enhanced them by fixing some of their confusing parts.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也是Web组件的主要目的之一。我们已经提到了Angular 2如何以及为什么利用了这项新技术。尽管AngularJS 1.x的模板很棒，但它们仍然可以变得更好！Angular
    2模板继承了框架先前版本中最好的部分，并通过修复其中一些令人困惑的部分来增强它们。
- en: 'For example, let''s say we built a directive and we want to allow the user
    to pass a property to it by using an attribute. In AngularJS 1.x, we can approach
    this in three different ways:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们构建了一个指令，并且我们希望允许用户通过使用属性将属性传递给它。在AngularJS 1.x中，我们可以以三种不同的方式来处理这个问题：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we have a directive `user` and we want to pass the `name` property, we can
    approach in three different ways. We can either pass a literal (in this case,
    the string `"literal"`), a string, which will be evaluated as an expression (in
    our case `"expression"`), or an expression inside `{{ }}`. Which syntax should
    be used completely depends on the directive's implementation, which makes its
    API-tangled and hard to remember.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个指令`user`，并且我们想传递`name`属性，我们可以以三种不同的方式来处理。我们可以传递一个字面量（在这种情况下是字符串`"literal"`），一个字符串，它将被评估为一个表达式（在我们的例子中是`"expression"`），或者一个在`{{
    }}`中的表达式。应该使用哪种语法完全取决于指令的实现，这使得其API复杂且难以记忆。
- en: It is a frustrating task to deal with large amount of components with different
    design decisions on a daily basis. By introducing a common convention, we can
    deal with such problems. However, in order to have good results and consistent
    APIs, the entire community needs to agree with it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每天处理大量具有不同设计决策的组件是一项令人沮丧的任务。通过引入一个共同的约定，我们可以解决这些问题。然而，为了取得良好的结果和一致的API，整个社区都需要同意。
- en: Angular 2 deals with this problem as well by providing special syntax for attributes,
    whose values need to be evaluated in the context of the current component, and
    a different syntax for passing literals.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2也解决了这个问题，提供了特殊的属性语法，其值需要在当前组件的上下文中进行评估，并为传递字面量提供了不同的语法。
- en: 'Another thing we''re used to, based on our AngularJS 1.x experience, is the
    microsyntax used in template directives such as `ng-if`, `ng-for`. For instance,
    if we want to iterate over a list of users and display their names in AngularJS
    1.x, we can use:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还习惯于根据我们的AngularJS 1.x经验，在模板指令中使用微语法，比如`ng-if`、`ng-for`。例如，如果我们想在AngularJS
    1.x中遍历用户列表并显示他们的名字，我们可以使用：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Although this syntax looks intuitive to us, it allows limited tooling support.
    However, Angular 2 approached this differently by bringing a little bit more explicit
    syntax with richer semantics:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种语法对我们来说看起来很直观，但它允许有限的工具支持。然而，Angular 2通过引入更加显式的语法和更丰富的语义来处理这个问题：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding snippet explicitly defines the property, which has to be created
    in the context of the current iteration (`user`), the one we iterate over (`users`).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段明确定义了必须在当前迭代的上下文中创建的属性（`user`），以及我们要迭代的对象（`users`）。
- en: 'However, this syntax is too verbose for typing. Developers can use the following
    syntax, which later gets translated to the more verbose one:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种语法对于输入来说太冗长了。开发人员可以使用以下语法，稍后会被转换为更冗长的语法：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The improvements in the new templates will also allow better tooling for advanced
    support by text editors and IDEs. We're going to discuss Angular 2's templates
    in [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 新模板的改进也将允许文本编辑器和IDE更好地支持高级工具。我们将在[第4章](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "第4章. 开始使用Angular 2组件和指令")中讨论Angular 2的模板，*开始使用Angular 2组件和指令*。
- en: Change detection
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更检测
- en: In the *WebWorkers* section, we already mentioned the opportunity to run the
    digest loop in the context of a different thread, instantiated as WebWorker. However,
    the implementation of the digest loop in AngularJS 1.x is not quite memory-efficient
    and prevents the JavaScript virtual machine from doing further code optimizations,
    which allows significant performance improvements. One such optimization is the
    inline caching ([http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html](http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html)).
    The Angular team did a lot of research discovering different ways the performance
    and the efficiency of the digest loop could be improved. This led to the development
    of a brand new change detection mechanism.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在*WebWorkers*部分，我们已经提到了在不同线程的上下文中运行digest循环的机会，即作为WebWorker实例化。然而，AngularJS
    1.x中digest循环的实现并不是非常节省内存，并且阻止了JavaScript虚拟机进行进一步的代码优化，这可以实现显著的性能改进。其中一种优化是内联缓存（[http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html](http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html)）。Angular团队进行了大量研究，发现了改进digest循环的性能和效率的不同方法。这导致了全新的变更检测机制的开发。
- en: In order to allow further flexibility, the Angular team abstracted the change
    detection and decoupled its implementation from the framework's core. This allowed
    the development of different change detection strategies, empowering different
    features in different environments.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步提高灵活性，Angular团队将变更检测抽象化，并将其实现与框架的核心解耦。这使得可以开发不同的变更检测策略，从而在不同的环境中赋予不同的功能更多的权力。
- en: 'As a result, Angular 2 has two built-in change detection mechanisms:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Angular 2具有两种内置的变更检测机制：
- en: '**Dynamic change detection**: This is similar to the change detection mechanism
    used by AngularJS 1.x. It is used in systems with disallowed `eval()`, such as
    CSP and Chrome extensions.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态变更检测**：这类似于AngularJS 1.x使用的变更检测机制。它用于不允许`eval()`的系统，如CSP和Chrome扩展程序。'
- en: '**JIT change detection**: This generates the code that performs the change
    detection run-time, allowing the JavaScript virtual machine to perform further
    code optimizations.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JIT变更检测**：这会生成执行运行时变更检测的代码，允许JavaScript虚拟机执行进一步的代码优化。'
- en: We're going to take a look at the new change detection mechanisms and how we
    can configure them in [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看新的变更检测机制以及如何在[第4章](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives")中配置它们，*开始使用Angular
    2组件和指令*。
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we considered the main reasons behind the decisions taken by
    the Angular core team and the lack of backward compatibility between the last
    two major versions of the framework. We saw that these decisions were fueled by
    two things—the evolution of the Web and the evolution of the frontend development,
    with the lessons learned from the development of AngularJS 1.x applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们考虑了Angular核心团队做出决定背后的主要原因，以及框架的最后两个主要版本之间缺乏向后兼容性。我们看到这些决定是由两个因素推动的——Web的发展和前端开发的进化，以及从开发AngularJS
    1.x应用程序中学到的经验教训。
- en: In the first section, we learned why we need to use the latest version of the
    JavaScript language, why we want to take advantage of Web Components and WebWorkers,
    and why it's not worth it to integrate all these powerful tools in version 1.x.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中，我们了解了为什么需要使用最新版本的JavaScript语言，为什么要利用Web组件和WebWorkers，以及为什么不值得在1.x版本中集成所有这些强大的工具。
- en: We observed the current direction of frontend development and the lessons learned
    in the last few years. We described why the controller and scope were removed
    from Angular 2, and why AngularJS 1.x's architecture was changed in order to allow
    server-side rendering for SEO-friendly, high-performance, single-page applications.
    Another fundamental topic we took a look at was building large-scale applications,
    and how that motivated single-way data-flow in the framework and the choice of
    the statically-typed language TypeScript.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察了前端开发的当前方向以及过去几年所学到的经验教训。我们描述了为什么在Angular 2中移除了控制器和作用域，以及为什么改变了AngularJS
    1.x的架构，以便允许服务器端渲染，以便创建SEO友好、高性能的单页面应用程序。我们还研究了构建大型应用程序的基本主题，以及这如何激发了框架中的单向数据流和静态类型语言TypeScript的选择。
- en: In the next chapter, we're going to look at the main building blocks of an Angular
    2 application—how they can be used and how they relate to each other. Angular
    2 reuses some of the naming of the components introduced by AngularJS 1.x, but
    generally changes the building blocks of our single-page applications completely.
    We're going to peek at the new components, and compare them with the ones in the
    previous version of the framework. We'll make a quick introduction to directives,
    components, routers, pipes, and services, and describe how they could be combined
    for building classy, single-page applications.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看Angular 2应用程序的主要构建模块——它们如何被使用以及它们之间的关系。Angular 2重新使用了一些由AngularJS
    1.x引入的组件的命名，但通常完全改变了我们单页面应用程序的构建模块。我们将窥探新组件，并将它们与框架先前版本中的组件进行比较。我们将快速介绍指令、组件、路由器、管道和服务，并描述它们如何结合起来构建优雅的单页面应用程序。
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载本书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便文件直接通过电子邮件发送给您。
- en: 'You can download the code files by following these steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下步骤下载代码文件：
- en: Log in or register to our website using your e-mail address and password.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的电子邮件地址和密码登录或注册到我们的网站。
- en: Hover the mouse pointer on the **SUPPORT** tab at the top.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将鼠标指针悬停在顶部的**SUPPORT**选项卡上。
- en: Click on **Code Downloads & Errata**.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击**代码下载和勘误**。
- en: Enter the name of the book in the **Search** box.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**搜索**框中输入书名。
- en: Select the book for which you're looking to download the code files.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择您要下载代码文件的书籍。
- en: Choose from the drop-down menu where you purchased this book from.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择您购买本书的地方。
- en: Click on **Code Download**.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击**代码下载**。
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下载文件后，请确保使用最新版本的以下工具解压或提取文件夹：
- en: WinRAR / 7-Zip for Windows
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinRAR / 7-Zip for Windows
- en: Zipeg / iZip / UnRarX for Mac
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zipeg / iZip / UnRarX for Mac
- en: 7-Zip / PeaZip for Linux
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7-Zip / PeaZip for Linux
