- en: Chapter 4. Styling and Animating Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, you learned how persist pages even after reloading the
    page or restarting the browser. We're at the point now where this could start
    to be a useful system for us. Unfortunately, it still looks rough and unstyled.
  prefs: []
  type: TYPE_NORMAL
- en: That's because, up until now, we've almost completely ignored styles in our
    components. In this chapter, we will change all that!
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to add custom styles and class names to component elements.
    We'll add animations to new and old components. We'll even learn how to combine
    the two to create highly reusable styles and animation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we are able to change and remove pages from our content management system.
    We ended the last chapter by seeding our local storage with a serialized array,
    so we could see it in action. Let's take a step back and make a way to create
    new pages through the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll add an `insert` method and update the `constructor` method of
    `Backend`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The page `id` values aren't really important to us outside the context of our
    React components. So, it's fine to regenerate them as the pages are loaded from
    local storage. We keep track of the internal `id` value, so new pages can be assigned
    a new `id` value when they are created.
  prefs: []
  type: TYPE_NORMAL
- en: The `insert` method pushes a new page object onto the list of pages. We then
    update the `pages` data in local storage so it's available the next time we need
    the pages. And, as with the `update` and `delete` methods, we emit an `update`
    event, so all concerned components will update their state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this `insert` method in `PageAdmin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `render` method, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with the rest of the code we wrote, the interface looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding new pages](img/5268_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding styles to components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of ways we could improve the appearance of our components.
    Let's take the `PageView` component, for example. What would make it better? Perhaps
    if we increased the font size and used a sans serif font, the titles would be
    clearer to read. Perhaps we could increase the margin around each page.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few different ways to style our components. The first is by adding
    styles inline to the `render` method in `PageView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can define a set of styles for each element we want our component to render.
    For the outer `div` element, we define a font size and family. For the `label`
    title, we tell the browser not to wrap text. For each button, we add margins.
    Each style object may be overwritten through properties, owing to the `var value
    = value1 || value2` notation. That's shorthand for saying if `value1` is undefined,
    use `value2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also apply those styles to the list items, so the numbers appear
    in the same manner as the titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note how there are two sets of braces for the `style` object? That's how we
    define objects as properties. In this case, it's an object of styles we want applied
    to each list item.
  prefs: []
  type: TYPE_NORMAL
- en: Changing and reverting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can style our edit form. Let''s replace the modification indicator (asterisk)
    with a button that will simulate the save action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This gives the illusion that clicking on the **Save** button will save something,
    when the save happens regardless. This poses an interesting question—should we
    make the **Cancel** button cancel the edit? Because right now it's just a back
    button masquerading as a cancel button. We should also define an `onSave` function
    to pass to this component.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we'd have to track its initial state. But where would we get this
    initial state? The `PageEditor` component receives the page details through properties,
    so the current state is the same in `PageEditor` as it is in `Backend`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps we should store the state when `PageView` is hidden and `PageEditor`
    is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When the page enters edit mode, we store the unedited title. We should change
    the `onCancel` method to actually cancel a change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `onCancel` property is called, we set the page title to the unedited
    title we stored earlier. We need to bind this new `onSave` method in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This assures that `this` refers to the page component when the `onSave` property
    is later called. We''ll need to pass this new method to the `PageEditor` component
    in the form of a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, instead of both the `PageEditor` buttons calling `this.props.onCancel`,
    they can call their applicable methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Animating new components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, new pages are just appearing. There's no subtle animation to
    ease them in. Let's change that!
  prefs: []
  type: TYPE_NORMAL
- en: We will use a new React component for this, and we can find it in the add-ons
    build of React. Go back to the React scripts you downloaded in the first chapter
    and replace all references to `react.js` with `react-with-addons.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us access to a new component called `CSSTransitionGroup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This new container component watches for changes in its children. When new
    child components are added, they are given a couple of CSS class names, which
    can apply CSS animation. We need to add this animation to the corresponding CSS
    styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since we specified `transitionName="page"`, React adds `page-enter` and `page-leave`
    to the `Page` components, as they enter and leave `PageAdmin`. Note how `150ms`
    in our styles matches `transitionEnterTimeout={150}`? They need to be the same.
    React adds classes such as `page-enter-active` for those `150ms`, and then removes
    them. This ensures that transitions only happen once.
  prefs: []
  type: TYPE_NORMAL
- en: Working with CSS transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's a great time to talk about CSS transitions. We have used them to fade and
    slide new `Page` components in from the left. If you're unfamiliar with how they
    generally work, the code might be confusing and difficult to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few things you should know. The first is that you can transition
    individual CSS properties or all of them at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we only want to transition the background color. The font
    size will immediately jump from `16px` to `18px`. Alternatively, we can transition
    all CSS properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve already seen transition duration, albeit briefly. We can use `ms` or
    `s` as units for these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then there are timing functions. These control how the animation gets from
    0% to 100%. They''re sometimes called curves because of how they''re often demonstrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with CSS transitions](img/5268_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Linear is the most basic of these timing functions, moving evenly from 0% to
    100%. It's also the default `timing` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can see these demonstrated at [http://easings.net](http://easings.net).
  prefs: []
  type: TYPE_NORMAL
- en: You can also define your own curve, in the `cubic-bezier(x1, y1, x2, y2)` form.
    That's a bit advanced for now, but it's good to know in any case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transitions can also be delayed, so they only happen after the desired amount
    of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Altogether, these styles look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the previous section, you can bundle all of these properties together
    into a smaller set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Not all properties can be transitioned. Properties need to have some form of
    granularity. Some common properties are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`background` (applies to color and position)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`border` (applies to color, width, and spacing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bottom`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font` (applies to size and weight)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`left`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`letter-spacing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`line-height`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`margin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max-height`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max-width`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min-height`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min-width`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opacity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outline` (applies to color, offset, and width)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`padding`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`right`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text-indent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text-shadow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`top`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vertical-align`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`visibility`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`word-spacing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`z-index`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing styles with Sass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Style sheets are a great alternative to inline component styles. CSS is wonderfully
    expressive as a language for finding and applying visual characteristics to elements.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it also has drawbacks. The biggest drawback to CSS is that all
    styles are in global scope. Some styles are inherited, and styles applied to elements
    often collide (and cancel each other out).
  prefs: []
  type: TYPE_NORMAL
- en: In small doses, the collisions are avoidable or manageable. In large doses,
    these collisions can cripple productivity. As a stop-gap, CSS supports the `!important`
    keyword. This often leads to ugly hacks, as everyone wants their styles to be
    the most important.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, common values need to be repeated. Until recently, CSS
    didn't even support calculated values. If we wanted an element to have an absolute
    width (for example) in relation to other elements, we had to use JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: These are some of the problems Sass aims to solve. It's a CSS superset language
    (CSS + other features), so it's easy to learn, that is, once you know CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sass style sheets need to be compiled to CSS style sheets before they can be
    used in the browser. Installing a Sass compiler is easy; execute the following
    command to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After that''s done, we''re able to compile Sass style sheets (files ending
    in `.scss`) with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will be turned into CSS, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer to compile React components in the browser and want to do the
    same with Sass, then you can install the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to add the following elements to the head of your page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit of JavaScript to look for the `style` elements with `type="text/sass"`.
    The contents of each of these style elements is passed through `sass.js` and saved
    back into the style elements. Their type is changed back to `text/css`, so the
    browser will recognize the styles as CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should only use this method in development. It creates a lot of work for
    the browser, which can be avoided by pre-compiling Sass for a production environment
    (using tools such as Grunt, Gulp, and webpack).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few other ways in which we can style and animate React components,
    and they all deal with the issue in subtly different ways.
  prefs: []
  type: TYPE_NORMAL
- en: CSS modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CSS modules** allow you to define styles that only apply in a local context
    to individual elements. They look like regular CSS styles, but when they''re applied
    to components, they are altered so that the class names given to components are
    unique. You can read more about CSS modules at [http://glenmaddern.com/articles/css-modules](http://glenmaddern.com/articles/css-modules).'
  prefs: []
  type: TYPE_NORMAL
- en: React style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**React style** is a way of creating inline styles as slightly enhanced objects.
    It lacks support for a few common CSS selectors, but does a good job otherwise.
    You can read more about it at [https://github.com/js-next/react-style](https://github.com/js-next/react-style).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to style React components great and small.
    We used inline styles, CSS style sheets, and even Sass style sheets. You also
    learned how to animate child components in and out of view using CSS transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked briefly at a couple of alternative technologies, which do
    the same things we did in this chapter but in slightly different ways. You may
    prefer one of these methods over all the others, but what is important is to recognize
    that there are many methods we can use to style and animate components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will put all these skills to use as we dive into material
    design. There's lots of styling and animation to come!
  prefs: []
  type: TYPE_NORMAL
