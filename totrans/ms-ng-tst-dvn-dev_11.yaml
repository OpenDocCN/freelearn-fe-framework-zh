- en: <st c="0">11</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">11</st>
- en: <st c="3">Refactoring and Improving Angular Code through TDD</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3">通过TDD重构和改进Angular代码</st>
- en: <st c="54">Refactoring your Angular code</st> <st c="85">using</st> **<st c="91">test-driven
    development</st>** <st c="114">(</st>**<st c="116">TDD</st>**<st c="119">) is
    a systematic and effective approach to improving the quality of your code.</st>
    <st c="200">TDD involves writing tests before writing the actual code, thus ensuring
    that the code addresses the desired requirements and is robust, maintainable,
    and reliable.</st> <st c="365">This methodology is particularly beneficial for
    Angular applications, where it ensures that the code is well structured, efficient,
    and easy</st> <st c="506">to maintain.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54">使用**<st c="91">测试驱动开发</st>** <st c="114">(**<st c="116">TDD</st>**<st
    c="119">)重构您的Angular代码是一种系统化和有效的提高代码质量的方法。</st> <st c="200">TDD涉及在编写实际代码之前编写测试，从而确保代码满足所需的条件，并且是健壮的、可维护的和可靠的。</st>
    <st c="365">这种方法对于Angular应用程序尤其有益，因为它确保代码结构良好、效率高且易于维护。</st>
- en: <st c="518">In this section, we delve into the significance of adopting a “tests
    first” strategy, exploring the advantages of TDD during refactoring processes,
    selecting the optimal tests to create, understanding what</st> <st c="724">constitutes</st>
    **<st c="737">code smells</st>**<st c="748">, emphasizing the importance of addressing
    code smells within Angular projects, and identifying prevalent code smells in</st>
    <st c="869">Angular applications.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨采用“先测试”策略的重要性，探讨重构过程中的TDD优势，选择要创建的最佳测试，理解**<st c="737">代码异味</st>**<st
    c="748">构成的内容，强调在Angular项目中解决代码异味的重要性，以及识别Angular应用程序中普遍存在的代码异味。
- en: <st c="890">In summary, here are the main topics that will be covered in</st>
    <st c="952">this chapter:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="890">总结来说，以下是本章将涵盖的主要主题：</st>
- en: <st c="965">Refactoring Angular code</st> <st c="991">through TDD</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="965">通过TDD重构Angular代码</st>
- en: <st c="1002">Identifying code smells and areas for improvement in</st> <st c="1056">Angular
    applications</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1002">在Angular应用程序中识别代码异味和改进区域</st>
- en: <st c="1076">Iterative improvement – red-green-refactor cycle for continuous</st>
    <st c="1141">code enhancement</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1076">迭代改进 – 用于持续代码增强的红色-绿色-重构周期</st>
- en: <st c="1157">Technical requirements</st>
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1157">技术要求</st>
- en: <st c="1180">To follow along with the examples and exercises in this chapter,
    you will need to have a basic understanding of Angular and TypeScript, as well
    as the following</st> <st c="1342">technical requirements:</st>
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章的示例和练习，你需要对Angular和TypeScript有基本的了解，以及以下技术要求：
- en: <st c="1365">Node.js and npm installed on</st> <st c="1395">your computer</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1365">在您的计算机上安装Node.js和npm</st>
- en: <st c="1408">Angular CLI</st> <st c="1421">installed globally</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1408">全局安装Angular CLI</st>
- en: <st c="1439">A code editor, such as Visual Studio Code, installed on</st> <st
    c="1496">your computer</st>
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1439">在您的计算机上安装代码编辑器，例如Visual Studio Code</st>
- en: <st c="1509">The code files required for this chapter can be found</st> <st
    c="1564">at</st> [<st c="1567">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%2011</st>](https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%2011)<st
    c="1666">.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需代码文件可以在[<st c="1567">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%2011</st>](https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%2011)找到。
- en: <st c="1667">Refactoring Angular code with TDD</st>
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1667">使用TDD重构Angular代码</st>
- en: <st c="1701">Refactoring existing</st> <st c="1722">code in complex Angular
    applications can be a nerve-wracking task.</st> <st c="1790">You want to improve
    the</st> <st c="1813">code’s structure and organization without accidentally breaking
    existing functionalities.</st> <st c="1904">This is where TDD comes into play,
    offering a structured approach to navigate refactoring with confidence.</st> <st
    c="2011">In this section, we’ll see the power of the test-first approach, the
    benefits of TDD in refactoring, and how to choose the right tests</st> <st c="2146">to
    write.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1701">在复杂的 Angular 应用程序中重构现有</st> <st c="1722">代码可能是一项令人紧张的任务。</st> <st
    c="1790">你希望在不妨碍现有功能的情况下改进代码的结构和组织。</st> <st c="1904">这就是测试驱动开发（TDD）发挥作用的地方，它提供了一种结构化的方法，以自信地导航重构。</st>
    <st c="2011">在本节中，我们将看到测试优先方法的力量，TDD 在重构中的好处，以及如何选择正确的测试</st> <st c="2146">来编写。</st>
- en: <st c="2155">The power of the test-first approach</st>
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="2155">测试优先方法的力量</st>
- en: <st c="2192">TDD flips</st> <st c="2202">the traditional coding script.</st>
    <st c="2234">Instead of writing code first and then testing it, TDD emphasizes
    writing tests before making any modifications to the code.</st> <st c="2359">These
    tests essentially define the expected behavior of the code you intend to refactor.</st>
    <st c="2448">Here’s how</st> <st c="2459">it works:</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2192">TDD 翻转了</st> <st c="2202">传统的编码脚本。</st> <st c="2234">与传统先编写代码再测试不同，TDD
    强调在修改代码之前先编写测试。</st> <st c="2359">这些测试本质上定义了你打算重构的代码的预期行为。</st> <st c="2448">以下是它是如何</st>
    <st c="2459">工作的：</st>
- en: '**<st c="2468">The red state</st>**<st c="2482">: You start by writing a test
    for a specific functionality within the code you want to refactor.</st> <st c="2580">This
    initial test will likely fail, signifying that the desired behavior isn’t yet
    implemented.</st> <st c="2676">This</st> *<st c="2681">red</st>* <st c="2684">state
    acts as a</st> <st c="2701">starting point.</st>'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2468">红色状态</st>**：你首先为想要重构的代码中的特定功能编写一个测试。这个初始测试很可能会失败，表明期望的行为尚未实现。这个</st>
    *<st c="2681">红色</st>* <st c="2684">状态作为一个</st> <st c="2701">起点。</st>'
- en: '**<st c="2716">The green state</st>**<st c="2732">: With the failing test as
    your guide, you write just enough code to make the test pass.</st> <st c="2822">This
    initial implementation might be basic, but the focus is on ensuring it accurately
    reflects the intended behavior defined by the test.</st> <st c="2961">Now, the
    test is in a</st> *<st c="2983">green</st>* <st c="2988">state, indicating</st>
    <st c="3007">successful implementation.</st>'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2716">绿色状态</st>**：以失败的测试为指南，你只需编写足够的代码来使测试通过。<st c="2732">这种初始实现可能很基础，但重点是确保它准确反映了测试定义的预期行为。</st>
    <st c="2822">现在，测试处于</st> *<st c="2983">绿色</st>* <st c="2988">状态，表示</st> <st c="3007">成功实现。</st>'
- en: '**<st c="3033">Refactor</st>**<st c="3042">: Here’s where the magic happens.</st>
    <st c="3077">With the safety net of a passing test, you can now refactor the code
    to improve its readability, maintainability, and efficiency.</st> <st c="3207">This
    might involve</st> <st c="3226">the following:</st>'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="3033">重构</st>**：这里是魔法发生的地方。有了通过测试的安全网，你现在可以重构代码，以提高其可读性、可维护性和效率。这可能包括以下内容：</st>
    <st c="3077">以下内容：</st>'
- en: <st c="3240">Breaking down long methods into smaller,</st> <st c="3282">well-defined
    functions</st>
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3240">将长方法分解为更小、</st> <st c="3282">定义良好的函数</st>
- en: <st c="3304">Extracting reusable components or services from</st> <st c="3353">large
    components</st>
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3304">从大型组件中提取可重用组件或服务</st>
- en: <st c="3369">Applying design patterns for better</st> <st c="3406">code organization</st>
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3369">应用设计模式以实现更好的</st> <st c="3406">代码组织</st>
- en: <st c="3423">Simplifying logic to</st> <st c="3445">enhance clarity</st>
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3423">简化逻辑以</st> <st c="3445">增强清晰度</st>
- en: <st c="3460">Throughout</st> <st c="3471">this refactoring stage, the passing
    test ensures that these changes don’t introduce any unintended side effects.</st>
    <st c="3585">Essentially, you’re improving the code’s internal workings without
    altering its external behavior as verified by the test.</st> <st c="3708">As an
    example, let’s start with this block of code from our</st> `<st c="3768">calculator.component.ts</st>`
    <st c="3791">component in the</st> `<st c="3809">Chapter 9</st>` <st c="3818">folder
    (</st>[<st c="3827">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%209/getting-started-angular-</st><st
    c="3951">tdd</st>](https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%209/getting-started-angular-tdd)<st
    c="3955">):</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3460">在整个</st> <st c="3471">重构阶段，通过测试确保这些更改不会引入任何意外的副作用。</st> <st c="3585">本质上，你是在不改变外部行为（由测试验证）的情况下改进代码的内部工作方式。</st>
    <st c="3708">作为一个例子，让我们从我们的</st> `<st c="3768">calculator.component.ts</st>` <st
    c="3791">组件</st> 在 `<st c="3809">第9章</st>` <st c="3818">文件夹（</st>[<st c="3827">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%209/getting-started-angular-</st><st
    c="3951">tdd</st>](https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%209/getting-started-angular-tdd)<st
    c="3955">）中的这一段代码开始：</st>
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="4634">Here is the</st> <st c="4647">source code for the tests corresponding
    to this function in our</st> `<st c="4711">calculator.component.spec.ts</st>`
    <st c="4739">file:</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4634">以下是</st> <st c="4647">对应于我们</st> `<st c="4711">calculator.component.spec.ts</st>`
    <st c="4739">文件中此函数的测试源代码：</st>
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="6629">As a reminder, all</st> <st c="6649">tests are green, as shown
    in the following screenshot of Karma launched on</st> <st c="6724">a browser:</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6629">提醒一下，所有</st> <st c="6649">测试都是绿色的，如下面在浏览器上启动的 Karma 的截图所示：</st>
- en: '![Figure 11.1 – Calculator component test succeeded in the terminal](img/B21146_11_1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 计算器组件测试在终端中成功](img/B21146_11_1.jpg)'
- en: <st c="7953">Figure 11.1 – Calculator component test succeeded in the terminal</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7953">图11.1 – 计算器组件测试在终端中成功</st>
- en: <st c="8018">We will now</st> <st c="8031">refactor the</st> <st c="8044">code</st>
    <st c="8048">of our</st> `<st c="8056">calculate()</st>` <st c="8067">function
    in the</st> `<st c="8084">calculator.component.ts</st>` <st c="8107">component</st>
    <st c="8118">as follows:</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8018">我们现在</st> <st c="8031">将重构</st> <st c="8044">代码</st> <st c="8048">中的</st>
    `<st c="8056">calculate()</st>` <st c="8067">函数</st> 在 `<st c="8084">calculator.component.ts</st>`
    <st c="8107">组件</st> <st c="8118">中，如下所示：</st>
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="8672">Now, what’s</st> <st c="8685">going on with our tests?</st> <st
    c="8710">They’re still all green as the following</st> <st c="8751">screenshot
    shows:</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8672">现在，我们的测试情况如何呢？</st> <st c="8685">它们仍然都是绿色的，如下面的</st> <st c="8751">截图所示：</st>
- en: '![Figure 11.2 – Green tests](img/B21146_11_2.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 绿色测试](img/B21146_11_2.jpg)'
- en: <st c="10014">Figure 11.2 – Green tests</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10014">图11.2 – 绿色测试</st>
- en: <st c="10039">This means that our refactoring is correct because if it wasn’t,
    our tests would be red.</st> <st c="10129">We now understand the importance of
    TDD, because we can concentrate on refactoring our methods with peace of mind.</st>
    <st c="10244">In the next section, we’ll learn some benefits of TDD</st> <st c="10298">in
    refactoring.</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10039">这意味着我们的重构是正确的，因为如果不是这样，我们的测试就会变成红色。</st> <st c="10129">我们现在理解了
    TDD 的重要性，因为我们可以在没有担忧的情况下专注于重构我们的方法。</st> <st c="10244">在下一节中，我们将学习一些在重构中 TDD 的好处。</st>
    <st c="10298">在重构中，TDD 有以下好处：</st>
- en: <st c="10313">Benefits of TDD in refactoring</st>
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10313">重构中 TDD 的好处</st>
- en: <st c="10344">This section delves</st> <st c="10364">into the rewarding benefits
    of utilizing TDD during Angular code refactoring.</st> <st c="10443">Here are
    some</st> <st c="10457">of them:</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10344">本节深入探讨了在 Angular 代码重构期间使用 TDD 的有益好处。</st> <st c="10443">以下是一些</st>
    <st c="10457">好处：</st>
- en: '**<st c="10465">Increased confidence</st>**<st c="10486">: The passing test
    acts as a safety net, allowing you to experiment with different refactoring techniques
    without worrying about breaking existing functionality.</st> <st c="10649">This
    boosts your confidence during</st> <st c="10684">the process.</st>'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="10465">增加信心</st>**<st c="10486">：通过测试，你可以作为一个安全网，让你在不用担心破坏现有功能的情况下尝试不同的重构技术。</st>
    <st c="10649">这增强了你在过程中的信心。</st>'
- en: '**<st c="10696">Improved design</st>**<st c="10712">: Thinking about the tests
    first encourages you to write modular code with well-defined functions.</st> <st
    c="10812">This leads to cleaner and more maintainable code in the</st> <st c="10868">long
    run.</st>'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="10696">改进设计</st>**<st c="10712">：首先考虑测试可以鼓励你编写具有良好定义功能的模块化代码。</st>
    <st c="10812">这导致代码在长期运行中更加干净和易于维护。</st>'
- en: '**<st c="10877">Enhanced maintainability</st>**<st c="10902">: A comprehensive
    test suite becomes a living documentation of the code’s expected behavior.</st>
    <st c="10996">This simplifies future modifications and bug fixes, as you can rely
    on the tests to</st> <st c="11080">catch regressions.</st>'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强可维护性**<st c="10877">：一个全面的测试套件成为代码预期行为的活文档。</st> <st c="10902">这简化了未来的修改和错误修复，因为你可以依赖测试来</st>
    <st c="10996">捕获回归。</st>'
- en: '**<st c="11098">Better code coverage</st>**<st c="11119">: TDD naturally encourages
    you to focus on covering various code paths with tests.</st> <st c="11203">This
    results in more robust applications with fewer</st> <st c="11255">hidden bugs.</st>'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="11098">更好的代码覆盖率</st>**<st c="11119">：TDD自然会鼓励你专注于用测试覆盖各种代码路径。</st>
    <st c="11203">这导致更健壮的应用程序，隐藏的bug更少。</st>'
- en: <st c="11267">Examples in action</st>
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="11267">行动中的示例</st>
- en: <st c="11286">Let’s see how</st> <st c="11300">TDD can be applied to common
    refactoring scenarios</st> <st c="11352">in Angular:</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11286">让我们看看如何</st> <st c="11300">将TDD应用于Angular中常见的重构场景</st> <st c="11352">：</st>
- en: '**<st c="11363">Refactoring a long service method</st>**<st c="11397">: Imagine
    a service method responsible for fetching and processing a massive amount of data.</st>
    <st c="11491">You can write a test that focuses on a specific aspect of the data
    processing logic.</st> <st c="11576">Initially, the test would fail.</st> <st
    c="11608">Then, you’d refactor the service method to extract that logic into a
    separate, well-tested function.</st> <st c="11709">This improves code readability
    and maintainability while the test ensures the core functionality</st> <st c="11806">remains
    intact.</st>'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="11363">重构长服务方法</st>**<st c="11397">：想象一个负责获取和处理大量数据的服务方法。</st> <st
    c="11491">你可以编写一个专注于数据处理逻辑特定方面的测试。</st> <st c="11576">最初，这个测试会失败。</st> <st c="11608">然后，你会重构服务方法，将逻辑提取到单独的、经过良好测试的函数中。</st>
    <st c="11709">这提高了代码的可读性和可维护性，同时测试确保核心功能保持完整。</st>'
- en: '**<st c="11821">Transforming a god component</st>**<st c="11850">: A “god component”
    refers to an overly complex component, often violating the single responsibility
    principle by handling too many responsibilities or functionalities within itself.</st>
    <st c="12034">This term is used to highlight the negative aspects of having components
    that grow too large and become difficult to manage, test, and understand.</st>
    <st c="12181">Such components tend to inject numerous services, perform multiple
    tasks, and can lead to significant maintenance challenges o</st><st c="12307">ver
    time.</st> <st c="12318">This type of component performing a large number of tasks
    can therefore be redesigned by creating services dedicated to specific functionalities.</st>
    <st c="12464">Tests can be written to verify the behavior of the refactored component
    and the newly</st> <st c="12550">created services.</st>'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="11821">转换神组件</st>**<st c="11850">：“神组件”指的是一个过于复杂的组件，通常通过在自身内部处理过多的责任或功能来违反单一职责原则。</st>
    <st c="12034">这个术语用来强调组件变得过大且难以管理、测试和理解的负面方面。</st> <st c="12181">这类组件往往注入许多服务，执行多项任务，并可能导致重大的维护挑战，随着时间的推移。</st>
    <st c="12307">这种执行大量任务的组件可以通过创建专门针对特定功能的服务来重新设计。</st> <st c="12318">因此，可以编写测试来验证重构组件和新</st>
    <st c="12464">创建的服务的行为。</st>'
- en: <st c="12567">Choosing the right tests to write</st>
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="12567">选择要编写的正确测试</st>
- en: <st c="12601">When prioritizing</st> <st c="12619">tests for refactoring with
    TDD, consider</st> <st c="12661">these strategies:</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12601">在优先考虑</st> <st c="12619">使用TDD进行重构的测试时，考虑</st> <st c="12661">以下策略：</st>
- en: '**<st c="12678">Focus on pain points</st>**<st c="12699">: Start with functionalities
    that are causing problems in your codebase, such as areas prone to errors or difficult</st>
    <st c="12816">to understand.</st>'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12678">关注痛点</st>**<st c="12699">：从导致代码库中出现问题（如易出错或难以理解的区域）的功能开始。</st>
    <st c="12816">这些区域通常会导致代码难以维护、测试和理解。</st>'
- en: '**<st c="12830">Start small</st>**<st c="12842">: Begin with smaller, well-defined
    tests that target specific functionalities.</st> <st c="12922">This allows for
    quicker iterations through the</st> <st c="12969">red-green-refactor cycle.</st>'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12830">从小处着手</st>**<st c="12842">：从较小、定义良好的测试开始，这些测试针对特定的功能。</st>
    <st c="12922">这允许更快地通过</st> <st c="12969">红-绿-重构周期。</st>'
- en: '**<st c="12994">Test integration points</st>**<st c="13018">: When refactoring
    components that interact with services or other components, write tests that verify
    these interactions alongside the</st> <st c="13154">component itself.</st>'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12994">测试集成点</st>**<st c="13018">：当重构与服务或其他组件交互的组件时，编写测试以验证这些交互以及组件本身。</st>'
- en: <st c="13172">In the next section, we’ll explain how to identify code smells
    and areas for improvement in</st> <st c="13265">Angular applications.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13172">在下一节中，我们将解释如何识别 Angular 应用程序中的代码异味和改进区域。</st> <st c="13265">Angular
    应用程序。</st>
- en: <st c="13286">Identifying code smells and areas for improvement in Angular applications</st>
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="13286">在 Angular 应用程序中识别代码异味和改进区域</st>
- en: <st c="13360">While your</st> <st c="13372">Angular application might seem functional
    on the surface, there could be underlying issues waiting to erupt.</st> <st c="13481">These
    issues, known as code smells, don’t necessarily cause immediate problems but indicate
    areas in your codebase</st> <st c="13596">that could benefit from refactoring.</st>
    <st c="13633">Just like a cluttered room can be stressful and unproductive, smelly
    code can make it difficult to maintain, understand, and extend your application.</st>
    <st c="13783">This section delves into</st> <st c="13807">the world of code smells
    in Angular applications.</st> <st c="13858">We’ll explore what they are, why they
    matter, and how to identify them proactively.</st> <st c="13942">By understanding
    these code smells, you’ll be equipped to prioritize refactoring efforts using
    TDD, ultimately leading to a cleaner, more maintainable, and robust</st> <st c="14105">code
    base.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13360">虽然你的</st> <st c="13372">Angular 应用程序可能表面上看起来功能正常，但可能存在潜在的等待爆发的問題。</st>
    <st c="13481">这些问题，被称为代码异味，不一定导致立即的问题，但表明你的代码库中</st> <st c="13596">可能从重构中受益的区域。</st>
    <st c="13633">就像杂乱无章的房间会让人感到压力和低效一样，有异味的代码会使维护、理解和扩展应用程序变得困难。</st> <st c="13783">本节深入探讨了</st>
    <st c="13807">Angular 应用程序中的代码异味世界。</st> <st c="13858">我们将探讨它们是什么，为什么它们很重要，以及如何主动识别它们。</st>
    <st c="13942">通过理解这些代码异味，你将能够使用 TDD 优先考虑重构工作，最终导致一个更干净、更可维护和更健壮的</st> <st c="14105">代码库。</st>
- en: <st c="14115">What are code smells?</st>
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="14115">什么是代码异味？</st>
- en: <st c="14137">Imagine</st> <st c="14146">walking into a kitchen where dirty
    dishes are piled up high in the sink, spices are scattered across the counter,
    and expired food lingers in the fridge.</st> <st c="14300">This unpleasant scene
    might not prevent you from cooking a basic meal, but it certainly wouldn’t be
    an enjoyable or efficient experience.</st> <st c="14438">Code smells are analogous
    to this messy kitchen in the software</st> <st c="14502">development world.</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14137">想象一下</st> <st c="14146">走进一个厨房，脏盘子堆满了水池，香料散落在台面上，过期的食物留在冰箱里。</st>
    <st c="14300">这个令人不愉快的场景可能不会阻止你做一顿基本的饭菜，但肯定不会是一个愉快或高效的经历。</st> <st c="14438">代码异味在软件开发世界中类似于这个杂乱的厨房。</st>
- en: '<st c="14520">Coined by Martin Fowler in his book,</st> *<st c="14558">Refactoring:
    Improving the Design of Existing Code</st>*<st c="14608">, code smells are indicators
    of potential problems within your code base.</st> <st c="14682">They don’t necessarily
    represent functional bugs that cause the application to crash.</st> <st c="14768">Instead,
    they signify</st> <st c="14790">areas that could be improved for better readability,
    maintainability, and long-term health of</st> <st c="14884">your code.</st>'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14520">由马丁·福勒在其著作中提出，</st> *<st c="14558">重构：改进现有代码的设计</st>*<st c="14608">，代码异味是代码库中潜在问题的指标。</st>
    <st c="14682">它们不一定代表导致应用程序崩溃的功能性错误。</st> <st c="14768">相反，它们标志着</st> <st c="14790">可能需要改进以获得更好的可读性、可维护性和代码长期健康性的区域。</st>
- en: <st c="14894">Code smells are not bugs, but they can attract bugs in the future.</st>
    <st c="14962">They act like red flags, warning you of potential trouble spots
    that could become problematic as your</st> <st c="15064">application evolves.</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14894">代码异味不是错误，但它们可能会在未来吸引错误。</st> <st c="14962">它们就像红旗，警告你潜在的麻烦区域，这些区域可能会随着你的</st>
    <st c="15064">应用程序的发展而变得有问题。</st>
- en: <st c="15084">Why should we care about code smells in Angular?</st>
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="15084">为什么我们应该关注Angular中的代码异味呢？</st>
- en: <st c="15133">Ignoring a messy kitchen might lead to unpleasant odors, fruit
    flies, and frustration when you need to cook a meal.</st> <st c="15250">Similarly,
    neglecting code smells in your Angular application can</st> <st c="15315">have
    several</st> <st c="15329">negative consequences:</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15133">忽视杂乱的厨房可能会导致烹饪时出现不愉快的气味、果蝇和挫败感。</st> <st c="15250">同样，忽视Angular应用程序中的代码异味可能会导致</st>
    <st c="15315">几个</st> <st c="15329">负面后果：</st>
- en: '**<st c="15351">Decreased maintainability</st>**<st c="15377">: Smelly code
    becomes difficult to understand and modify over time.</st> <st c="15446">As your
    application grows and features are added, the complexity of tangled code can make
    changes cumbersome and</st> <st c="15559">error prone.</st>'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="15351">降低可维护性</st>**<st c="15377">：随着时间的推移，有异味的代码变得难以理解和修改。</st> <st
    c="15446">随着您的应用程序的增长和功能的添加，错综复杂的代码的复杂性可能会使更改变得繁琐并</st> <st c="15559">容易出错。</st>'
- en: '**<st c="15571">Increased debugging time</st>**<st c="15596">: When bugs arise
    in smelly code, it can be challenging to pinpoint the root cause.</st> <st c="15681">The
    lack of clear structure and organization makes it like searching for a needle
    in a haystack, wasting valuable</st> <st c="15795">developer time.</st>'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="15571">增加调试时间</st>**<st c="15596">：当出现有异味的代码中的错误时，确定根本原因可能具有挑战性。</st>
    <st c="15681">缺乏清晰的结构和组织使得寻找错误就像在 haystack 中寻找一根针一样，浪费了宝贵的</st> <st c="15795">开发者时间。</st>'
- en: '**<st c="15810">Reduced team productivity</st>**<st c="15836">: Working with
    smelly code can be frustrating and demotivating for developers.</st> <st c="15916">The
    cognitive overhead of deciphering tangled logic slows down development and</st>
    <st c="15995">hinders collaboration.</st>'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="15810">降低团队生产力</st>**<st c="15836">：与有异味的代码一起工作可能会让开发者感到沮丧和缺乏动力。</st>
    <st c="15916">解读错综复杂的逻辑的认知负担会减慢开发速度并</st> <st c="15995">阻碍协作。</st>'
- en: '**<st c="16017">Technical debt</st>**<st c="16032">: Unattended code smells
    accumulate over time, creating a technical debt that needs to be addressed eventually.</st>
    <st c="16145">This debt can become a significant burden, requiring dedicated resources
    and potentially delaying new</st> <st c="16247">feature development.</st>'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="16017">技术债务</st>**<st c="16032">：随着时间的推移，未处理的代码异味会积累，最终形成需要解决的技术债务。</st>
    <st c="16145">这种债务可能成为一个重大的负担，需要专门的资源，并可能延迟新</st> <st c="16247">功能开发。</st>'
- en: <st c="16267">By proactively</st> <st c="16283">identifying and refactoring
    code smells, you can do</st> <st c="16335">the following:</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16267">通过积极</st> <st c="16283">地识别和重构代码异味，您可以做到以下：</st>
- en: '**<st c="16349">Improve code readability</st>**<st c="16374">: Clean and well-structured
    code is easier to understand for both you and other developers working on the
    project.</st> <st c="16490">This reduces onboarding time for new team members
    and fosters</st> <st c="16552">better collaboration.</st>'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="16349">提高代码可读性</st>**<st c="16374">：干净且结构良好的代码更容易被您和其他在项目上工作的开发者理解。</st>
    <st c="16490">这减少了新团队成员的入职时间，并促进了</st> <st c="16552">更好的协作。</st>'
- en: '**<st c="16573">Enhance maintainability</st>**<st c="16597">: Refactored code
    is easier to modify and adapt as your</st> <st c="16654">application’s requirements
    evolve.</st> <st c="16689">This allows you to introduce new features and bug fixes</st>
    <st c="16745">more efficiently.</st>'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="16573">增强可维护性</st>**<st c="16597">：重构后的代码更容易修改和适应，因为您的</st> <st c="16654">应用程序需求发生变化。</st>
    <st c="16689">这使您能够更有效地引入新功能和错误修复</st> <st c="16745">。</st>'
- en: '**<st c="16762">Reduce debugging time</st>**<st c="16784">: Cleaner code with
    a clear separation of concerns makes it easier to isolate and fix problems when</st>
    <st c="16885">bugs arise.</st>'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="16762">减少调试时间</st>**<st c="16784">：清晰关注点分离的干净代码在出现错误时更容易隔离和修复。</st>
    <st c="16885">当出现错误时。</st>'
- en: '**<st c="16896">Boost team productivity</st>**<st c="16920">: Working with
    well-structured code improves developer experience and satisfaction.</st> <st
    c="17005">This leads to higher productivity and a more positive</st> <st c="17059">development
    environment.</st>'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="16896">提高团队生产力</st>**<st c="16920">：与结构良好的代码一起工作可以改善开发者的体验和满意度。</st>
    <st c="17005">这导致更高的生产力和更积极</st> <st c="17059">的开发环境。</st>'
- en: '**<st c="17083">Minimize technical debt</st>**<st c="17107">: By addressing
    code smells early on, you prevent them from accumulating and becoming a significant
    burden in</st> <st c="17218">the future.</st>'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="17083">最小化技术债务</st>**<st c="17107">：通过早期解决代码异味，您可以防止它们积累并成为未来的一大负担。</st>
    <st c="17218">。</st>'
- en: <st c="17229">In essence, prioritizing code smell refactoring is an investment
    in the long-term health and maintainability of your</st> <st c="17347">Angular
    application.</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17229">本质上，优先考虑代码异味重构是对你</st> <st c="17347">Angular应用程序</st> <st c="17347">长期健康和可维护性的投资。</st>
- en: <st c="17367">Identifying the most common code smells in Angular applications</st>
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="17367">识别Angular应用程序中最常见的代码异味</st>
- en: <st c="17431">Now that we</st> <st c="17443">understand the importance</st>
    <st c="17470">of identifyi</st><st c="17482">ng code smells, let’s take a look
    at some of the most common offenses you might encounter in your</st> <st c="17581">Angular
    application:</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17431">现在我们</st> <st c="17443">理解了识别代码异味的重要性</st> <st c="17470">，让我们看看你可能在你的</st>
    <st c="17482">Angular应用程序</st> <st c="17581">中遇到的常见违规行为：</st>
- en: '**<st c="17601">The long and winding method</st>**<st c="17629">: Imagine a
    method in your service that stretches across dozens of lines, handling various
    tasks.</st> <st c="17728">This is a prime example of a long method, a code smell
    suggesting a lack of modularity.</st> <st c="17816">These methods can be difficult
    to understand, test, and modify.</st> <st c="17880">Refactoring involves breaking
    down such behemoths into smaller, well-defined functions, each focusing on a specific
    task.</st> <st c="18002">This enhances code readability</st> <st c="18033">and
    maintainability.</st>'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="17601">漫长而曲折的方法</st>**<st c="17629">：想象一下你的服务中的一个方法，它跨越了数十行，处理各种任务。</st>
    <st c="17728">这是一个长方法的典型例子，一个表明缺乏模块化的代码异味。</st> <st c="17816">这些方法可能难以理解、测试和修改。</st>
    <st c="17880">重构涉及将这些巨无霸分解成更小、更明确的函数，每个函数都专注于特定的任务。</st> <st c="18002">这提高了代码的可读性</st>
    <st c="18033">和可维护性。</st>'
- en: '**<st c="18053">The god component</st>**<st c="18071">: Have you encountered
    a component overloaded with responsibilities?</st> <st c="18141">This is a “god
    component,” handling everything from data fetching to complex UI logic.</st> <st
    c="18228">Such components become maintenance nightmares as changes in one area
    can ripple through the entire component, causing</st> <st c="18346">unintended
    consequences.</st> <st c="18371">Refactoring can involve</st> <st c="18395">the
    following:</st>'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="18053">神组件</st>**<st c="18071">：你是否遇到过责任过重的组件？</st> <st c="18141">这是一个“神组件”，从数据获取到复杂的UI逻辑都由它处理。</st>
    <st c="18228">这样的组件成为维护噩梦，因为一个区域的变化可能会在整个组件中产生连锁反应，导致</st> <st c="18346">意外的后果。</st>
    <st c="18371">重构可能包括</st> <st c="18395">以下内容：</st>'
- en: '**<st c="18409">Creating dedicated services</st>**<st c="18437">: Extract functionalities
    related to data access, business logic, or calculations into separate services.</st>
    <st c="18544">These services can be reused</st> <st c="18572">by multiple components,
    promoting</st> <st c="18607">better organization.</st>'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="18409">创建专用服务</st>**<st c="18437">：将与数据访问、业务逻辑或计算相关的功能提取到单独的服务中。</st>
    <st c="18544">这些服务可以被多个组件重用</st> <st c="18572">，促进</st> <st c="18607">更好的组织。</st>'
- en: '**<st c="18627">Splitting the component</st>**<st c="18651">: Break down the
    god component into smaller, more focused components, each handling a specific
    aspect of the UI</st> <st c="18764">or functionality.</st>'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="18627">拆分组件</st>**<st c="18651">：将神组件拆分成更小、更专注的组件，每个组件处理UI</st> <st
    c="18764">或功能的一个特定方面。</st>'
- en: '`<st c="19648">10</st>` <st c="19650">used for pagination but its purpose is
    unclear.</st> <st c="19699">Refactoring involves replacing these magic numbers
    with named variables or constants.</st> <st c="19785">For example, use</st> `<st
    c="19802">ITEMS_PER_PAGE</st>` <st c="19816">instead of</st> `<st c="19828">10</st>`<st
    c="19830">, making the code more self-documenting and easier</st> <st c="19881">to
    understand.</st>'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="19648">10</st>` <st c="19650">用于分页，但其目的不明确。</st> <st c="19699">重构涉及用命名变量或常量替换这些魔法数字。</st>
    <st c="19785">例如，使用</st> `<st c="19802">ITEMS_PER_PAGE</st>` <st c="19816">而不是</st>
    `<st c="19828">10</st>`<st c="19830">，使代码更具自文档性，更容易</st> <st c="19881">理解。</st>'
- en: '**<st c="19895">The spaghetti code maze</st>**<st c="19919">: Imagine code
    that winds and twists, lacking clear structure and organization.</st> <st c="20000">This
    is spaghetti code, making it a challenge to navigate, understand, and modify.</st>
    <st c="20083">TDD can be a powerful tool to combat spaghetti code.</st> <st c="20136">By</st>
    <st c="20138">writing tests first and then refactoring the code to meet those
    tests, you can introduce structure and improve the overall organization of your</st>
    <st c="20283">code base.</st>'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="19895">意大利面代码迷宫</st>**<st c="19919">：想象一下蜿蜒曲折、缺乏清晰结构和组织的代码。</st> <st
    c="20000">这就是意大利面代码，使其在导航、理解和修改时具有挑战性。<st c="20083"></st>测试驱动开发（TDD）可以成为对抗意大利面代码的有力工具。<st
    c="20136"></st>通过首先编写测试，然后重构代码以满足这些测试，你可以引入结构并改善代码库的整体组织。<st c="20138"></st>'
- en: '<st c="20293">In the next section, we</st> <st c="20318">will learn about iterative
    improvement: the red-green-refactor cycle for continuous</st> <st c="20402">code
    enhancement.</st>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习迭代改进：持续代码增强的红色-绿色-重构循环。<st c="20293"></st>
- en: <st c="20419">Iterative improvement – red-green-refactor cycle for continuous
    code enhancement</st>
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代改进 – 持续代码增强的红色-绿色-重构循环<st c="20419"></st>
- en: <st c="20500">Refactoring</st> <st c="20513">existing code in Angular applications
    can be a daunting task.</st> <st c="20575">You want to improve the code’s structure
    and organization, but the fear of introducing regressions (bugs) often looms large.</st>
    <st c="20700">This is where TDD steps in, offering a structured and iterative
    approach to</st> <st c="20775">navigate refactoring with confidence.</st> <st
    c="20814">At the heart of TDD lies the “red-green-refactor” cycle, a</st> <st
    c="20873">powerful technique for making incremental improvements to your code
    base while ensuring its functionality</st> <st c="20979">remains intact.</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular应用程序中重构现有代码可能是一项艰巨的任务。<st c="20500"></st>你希望改进代码的结构和组织，但引入回归（错误）的恐惧常常笼罩心头。<st
    c="20513"></st>这就是TDD介入的地方，它提供了一种结构化和迭代的途径，以自信地导航重构。<st c="20575"></st>在TDD的核心是“红色-绿色-重构”循环，这是一种强大的技术，可以在确保功能完整的同时，对代码库进行增量改进。<st
    c="20700"></st>它通过在重构代码之前编写测试，然后将代码重构以满足这些测试，可以引入结构并改善代码库的整体组织。<st c="20775"></st>在TDD的核心是“红色-绿色-重构”循环，这是一种强大的技术，可以在确保功能完整的同时，对代码库进行增量改进。<st
    c="20814"></st>它通过在重构代码之前编写测试，然后将代码重构以满足这些测试，可以引入结构并改善代码库的整体组织。<st c="20873"></st>它通过在重构代码之前编写测试，然后将代码重构以满足这些测试，可以引入结构并改善代码库的整体组织。<st
    c="20979"></st>
- en: <st c="20994">Imagine you’re a sculptor working on a large block of marble.</st>
    <st c="21057">The red-green-refactor cycle is like your roadmap to transforming
    that raw material into a masterpiece.</st> <st c="21161">Here’s a breakdown of
    each stage and its significance in the context of refactoring</st> <st c="21245">Angular
    code:</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你是一位正在处理一块大块大理石的雕塑家。<st c="20994"></st>红色-绿色-重构循环就像你的路线图，将这块原材料变成杰作。<st c="21057">以下是每个阶段及其在重构Angular代码的上下文中的重要性的分解：</st>
    <st c="21161"></st> <st c="21245">：</st>
- en: <st c="21258">Red – setting the stage with failing tests</st>
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="21258">红色 – 使用失败的测试设定舞台</st>
- en: <st c="21301">The cycle begins</st> <st c="21319">with red, signifying a failing
    test.</st> <st c="21356">This might seem counterintuitive – why write a</st> <st
    c="21403">test that’s destined to fail?</st> <st c="21433">The purpose of this
    initial red test is to define the desired behavior of the code you intend to refactor.</st>
    <st c="21540">Think of it as a blueprint outlining the functionality you want
    to achieve.</st> <st c="21616">He</st><st c="21618">re’s what creating a red</st>
    <st c="21644">test entails:</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21301">循环从红色开始</st> <st c="21319">，表示失败的测试。</st> <st c="21356">这可能会显得有些不合常理——为什么编写注定要失败的测试呢？<st
    c="21403"></st>这个初始红色测试的目的是定义你打算重构的代码的预期行为。</st> <st c="21433"></st>把它想象成一份概述你想要实现的功能的蓝图。</st>
    <st c="21540"></st>以下是创建红色测试涉及的内容：<st c="21616"></st><st c="21618">他</st><st c="21644">的</st>：
- en: '**<st c="21657">Identify the refactoring target</st>**<st c="21689">: Start
    by pinpointing a specific area of your Angular application that exhibits code
    smells or requires improvement.</st> <st c="21808">This could be a long method
    in service, a god component handling numerous tasks, or duplicated</st> <st c="21903">code
    snippets.</st>'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="21657">确定重构目标</st>**<st c="21689">：首先确定Angular应用程序中一个特定的区域，该区域表现出代码异味或需要改进。</st>
    <st c="21808">这可能是服务中的长方法、处理许多任务的上帝组件，或者重复的代码片段。<st c="21903"></st>'
- en: '**<st c="21917">Define the expected outcome</st>**<st c="21945">: Clearly outline
    what the refactored code should do.</st> <st c="22000">What data should it process?</st>
    <st c="22029">How should it interact with the UI?</st> <st c="22065">Write a test
    that reflects this expected behavior.</st> <st c="22116">Remember, this test will
    initially fail, as the desired functio</st><st c="22179">nality isn</st><st c="22190">’t</st>
    <st c="22194">implemented yet.</st>'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="21917">定义预期结果</st>**<st c="21945">：清楚地概述重构后的代码应该做什么。</st> <st c="22000">它应该处理哪些数据？</st>
    <st c="22029">它应该如何与UI交互？</st> <st c="22065">编写一个反映这种预期行为的测试。</st> <st c="22116">记住，这个测试最初会失败，因为所需的功能尚未实现。</st>'
- en: <st c="22210">A failing red test</st> <st c="22229">serves a critical purpose.</st>
    <st c="22257">It establishes a baseline – a clear understanding of the functionality
    that’s currently missing.</st> <st c="22354">This provides a safety net during
    the refactoring process.</st> <st c="22413">As you make code changes, the failing
    test ensures you’re on the right track and haven’t accidentally broken</st> <st
    c="22522">existing functionalities.</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22210">失败的红色测试</st> <st c="22229">发挥着至关重要的作用。</st> <st c="22257">它建立了一个基线——对当前缺失的功能有清晰的理解。</st>
    <st c="22354">这为重构过程提供了一个安全网。</st> <st c="22413">当你进行代码更改时，失败的测试确保你走在正确的轨道上，并且没有意外破坏</st>
    <st c="22522">现有功能。</st>
- en: <st c="22547">Green – making the test pass with minimal code</st>
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="22547">绿色——用最少的代码使测试通过</st>
- en: <st c="22594">Once you</st> <st c="22604">have your red test in place, it’s
    time to move to the green stage.</st> <st c="22671">Here, the objective is to
    write just enough code to make the failing test pass.</st> <st c="22751">Don’t
    get caught up in writing perfectly optimized or elegant code at this point.</st>
    <st c="22833">Focus on the core functionality defined by the test.</st> <st c="22886">Here
    are some key considerations for the</st> <st c="22927">green stage:</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22594">一旦你</st> <st c="22604">设置了红色测试，就到了进入绿色阶段的时候。</st> <st c="22671">在这里，目标是编写足够的代码来使失败的测试通过。</st>
    <st c="22751">在这个阶段，不要陷入编写完美优化或优雅的代码。</st> <st c="22833">专注于测试定义的核心功能。</st> <st
    c="22886">以下是绿色阶段的一些关键考虑因素：</st>
- en: '**<st c="22939">Simple implementations</st>**<st c="22962">: The initial code
    you write to make the test pass might be basic.</st> <st c="23030">It doesn’t
    have to be the most efficient or well-structured solution yet.</st> <st c="23104">The
    priority is to get the test passing and establish a baseline</st> <st c="23169">for
    refactoring.</st>'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="22939">简单实现</st>**<st c="22962">：你最初编写的代码以使测试通过可能是基本的。</st> <st c="23030">它不必是最有效或结构良好的解决方案。</st>
    <st c="23104">优先级是让测试通过并建立重构的基线</st> <st c="23169">。</st>'
- en: '**<st c="23185">Focus on functionality</st>**<st c="23208">: Ensure the code
    you write fulfills the specific behavior outlined in the test.</st> <st c="23290">Don’t
    introduce unnecessary f</st><st c="23319">eatures or</st> <st c="23330">logic
    at</st> <st c="23340">this stage.</st>'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="23185">关注功能</st>**<st c="23208">：确保你编写的代码满足测试中概述的特定行为。</st> <st c="23290">在这个阶段，不要引入不必要的功能或</st>
    <st c="23319">逻辑。</st>'
- en: <st c="23351">A passing green test signifies a crucial milestone.</st> <st c="23404">It
    verifies that the core functionality you’re refactoring is now implemented, albeit
    potentially in a basic form.</st> <st c="23519">This green test acts as a safety
    net throughout the refactoring process.</st> <st c="23592">As you make further
    code changes, you can rely on the test to ensure you haven’t strayed from the</st>
    <st c="23690">desired outcome.</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23351">通过绿色测试标志着重要的里程碑。</st> <st c="23404">它验证了你正在重构的核心功能现在已实现，尽管可能只是基本形式。</st>
    <st c="23519">这个绿色测试在整个重构过程中充当安全网。</st> <st c="23592">当你进行进一步的代码更改时，你可以依赖这个测试来确保你没有偏离</st>
    <st c="23690">预期的结果。</st>
- en: <st c="23706">Refactor – transforming the code with confidence</st>
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="23706">重构——自信地转换代码</st>
- en: <st c="23755">With a</st> <st c="23763">passing green test as your safety net,
    you’ve reached the heart of the cycle – the refactor stage.</st> <st c="23862">Here’s
    where you can unleash your refactoring skills to improve the code’s readability,
    maintainability, and efficiency.</st> <st c="23983">Here are some potential areas
    you might want to focus on</st> <st c="24040">during refactoring:</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="24059">Modularize long methods</st>**<st c="24083">: Break down those
    long, monolithic methods into smaller, well-defined functions.</st> <st c="24166">This
    enhances code readability and makes it easier to understand the</st> <st c="24235">logic
    flow.</st>'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="24246">Extract reusable components and services</st>**<st c="24287">:
    If your component has become a god component handling numerous tasks, consider
    extracting functionalities into dedicated services or reusable components.</st>
    <st c="24444">This promotes better organization and separation</st> <st c="24493">of
    concerns.</st>'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="24505">Eliminate duplication</st>**<st c="24527">: Identify and refactor
    repetitive code snippets into reusable components, services, or utility functions.</st>
    <st c="24635">This reduces code redundancy and</st> <st c="24668">simplifies maintenance.</st>'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="24691">Apply design patterns</st>**<st c="24713">: Consider incorporating
    design patterns that promote better code structure and organization.</st> <st
    c="24808">This can make your code more maintainable and easier to understand for</st>
    <st c="24879">other developers.</st>'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="24896">Simplify logic</st>**<st c="24911">: Look for opportunities
    to streamline complex logic and enhance code clarity.</st> <st c="24991">This
    can involve using more descriptive variable names, breaking down complex conditional
    statements, or utilizing</st> <st c="25106">helper functions.</st>'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25123">Throughout the refactoring process, keep the green test in mind.</st>
    <st c="25189">Repeat this cycle iteratively, tackling one aspect of the code at
    a time.</st> <st c="25263">Each completed cycle leaves you with cleaner, more
    maintainable code, with robust tests guaranteeing its continued functionality.</st>
    <st c="25393">The emphasis on small, incremental changes promotes a more controlled,
    less error-prone</st> <st c="25481">refactoring process.</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25501">Summary</st>
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="25509">In conclusion, refactoring and improving Angular code through
    TDD is a powerful approach to enhancing the quality, maintainability, and efficiency
    of your Angular applications.</st> <st c="25687">By following the TDD methodology,
    developers can ensure that their code is robust, well structured, and easy to
    understand.</st> <st c="25811">This approach not only helps in identifying and
    addressing code smells but also in developing a solid foundation for future enhancements
    and modifications.</st> <st c="25967">TDD encourages developers to write tests
    before writing the actual code, ensuring that the code meets the defined requirements
    and behaves as expected.</st> <st c="26119">This iterative process of writing
    tests, making them pass, and then refactoring the code for improvement is at the
    heart of TDD.</st> <st c="26248">It fosters a culture of continuous improvement,
    where code is always in a state that is ready for</st> <st c="26346">further development.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，通过TDD重构和改进Angular代码是一种强大的方法，可以提升Angular应用程序的质量、可维护性和效率。<st c="25687">遵循TDD方法论，开发者可以确保他们的代码健壮、结构良好且易于理解。</st>这种方法不仅有助于识别和解决代码问题，而且为未来的增强和修改奠定了坚实的基础。<st
    c="25967">TDD鼓励开发者先编写测试，然后再编写实际代码，确保代码满足定义的要求并按预期行为。</st>编写测试、使测试通过，然后对代码进行重构以改进，这是TDD的核心。<st
    c="26248">它培养了一种持续改进的文化，代码始终处于准备进一步开发的状态。</st>
- en: <st c="26366">Moreover, TDD facilitates the development of isolated, testable
    units of code, making it easier to identify and fix issues early in the development
    process.</st> <st c="26524">This is particularly beneficial in Angular applications,
    where components, services, and modules often have complex dependencies and interactions.</st>
    <st c="26671">By testing these units in isolation, developers can ensure that
    each part of the application works correctly before integrating them into the</st>
    <st c="26813">larger system.</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，TDD（测试驱动开发）促进了独立、可测试的代码单元的开发，使得在开发早期阶段更容易识别和修复问题。<st c="26524">这在Angular应用程序中尤其有益，因为组件、服务和模块通常具有复杂的依赖关系和交互。</st>通过单独测试这些单元，开发者可以确保在将它们集成到更大的系统之前，应用程序的每个部分都能正确工作。<st
    c="26813"></st>
- en: <st c="26827">Furthermore, TDD promotes the development of high-quality, maintainable
    code by encouraging developers to write clear, concise, and well-documented tests.</st>
    <st c="26983">These tests serve as documentation, making it easier for other developers
    (or even the original developers in the future) to understand the purpose and
    functionality of</st> <st c="27152">the code.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，TDD通过鼓励开发者编写清晰、简洁且文档齐全的测试，促进了高质量、可维护的代码的开发。<st c="26983">这些测试作为文档，使得其他开发者（甚至未来的原始开发者）更容易理解代码的目的和功能。</st>
- en: <st c="27161">In the context of Angular, TDD can be particularly effective in
    developing services, components, and pipes, as demonstrated in the examples provided.</st>
    <st c="27312">By starting with a clear definition of what the code should do,
    developers can write tests that guide the implementation process, ensuring that
    the code meets the desired specifications.</st> <st c="27499">This approach not
    only leads to better-designed code but also makes the development process more
    efficient</st> <st c="27606">and enjoyable.</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular的背景下，TDD在开发服务、组件和管道方面特别有效，如提供的示例所示。<st c="27312">通过明确定义代码应该做什么，开发者可以编写指导实现过程的测试，确保代码满足所需的规范。</st>这种方法不仅导致代码设计得更好，而且使开发过程更加高效和愉快。<st
    c="27606"></st>
- en: <st c="27620">In summary, refactoring and improving Angular code through TDD
    is a valuable practice that can significantly enhance the quality of your Angular
    applications.</st> <st c="27780">By adopting TDD, developers can ensure that their
    code is robust, maintainable, and ready for future enhancements.</st> <st c="27895">This
    approach not only benefits the current development cycle but also sets a solid
    foundation for future development efforts, making it a worthwhile investment for
    any</st> <st c="28064">Angular developer.</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，通过TDD重构和改进Angular代码是一种有价值的实践，可以显著提升Angular应用程序的质量。<st c="27780">通过采用TDD，开发者可以确保他们的代码健壮、可维护，并准备好未来的增强。</st>这种方法不仅有利于当前的开发周期，而且为未来的开发工作奠定了坚实的基础，对于任何Angular开发者来说都是一项值得的投资。<st
    c="28064"></st>
- en: <st c="28082">This is the end of the book.</st> <st c="28112">This book serves
    as a comprehensive guide for developers looking to adopt or improve their TDD
    practices in Angular projects.</st> <st c="28238">By following the principles
    and techniques described in this book, developers can significantly improve the
    reliability, performance, and maintainability of their Angular applications.</st>
    <st c="28423">The book emphasizes the value of a thorough testing strategy, the
    importance of using the right tools and practices, and the benefits of adopting
    a test-first approach to development.</st> <st c="28607">Whether you’re new to
    Angular or an experienced developer looking to hone your skills, this book offers
    valuable insights and practical advice for mastering TDD</st> <st c="28768">in
    Angular.</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28082">这是本书的结尾。</st> <st c="28112">本书为希望采用或改进他们在Angular项目中TDD实践的开发商提供了一本全面的指南。</st>
    <st c="28238">通过遵循本书中描述的原则和技术，开发商可以显著提高他们Angular应用程序的可靠性、性能和可维护性。</st> <st c="28423">本书强调了全面测试策略的价值、使用正确工具和实践的重要性，以及采用测试优先的开发方法的好处。</st>
    <st c="28607">无论你是Angular的新手还是一个希望磨练技能的有经验的开发者，本书都提供了掌握Angular中TDD的宝贵见解和实用建议。</st>
    <st c="28768">。</st>
