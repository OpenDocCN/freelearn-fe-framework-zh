- en: '*Chapter 10*: Building a Website with React'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：使用React构建网站'
- en: In this last chapter of this book, we will talk about *React* in general, especially
    the role that *React* plays in web development. We will approach this topic from
    three aspects to see how *React* puts resources together to build a site. First,
    we will take a look at how *React* embraces new *JavaScript ES6* features, such
    as arrow function and template strings. Then, we will walk through how a component
    can be styled using a *CSS-in-JS* approach via libraries such as `styled-JSX`
    and `styled-components`. Last, but not least, we will also get to know JSX code
    and how it is used to transform the *HTML*-like lines into *JavaScript* expressions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章，我们将一般性地讨论 *React*，特别是 *React* 在网页开发中所扮演的角色。我们将从三个角度来探讨这个问题，看看 *React*
    如何将资源整合起来构建一个网站。首先，我们将看看 *React* 如何拥抱新的 *JavaScript ES6* 功能，如箭头函数和模板字符串。然后，我们将通过使用
    `styled-JSX` 和 `styled-components` 等库的 *CSS-in-JS* 方法来展示如何对组件进行样式化。最后，但同样重要的是，我们还将了解JSX代码以及它是如何被用来将类似
    *HTML* 的行转换为 *JavaScript* 表达式的。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The function of *React*
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*React* 的功能'
- en: Embracing *JavaScript* *ES6*
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥抱 *JavaScript* *ES6*
- en: Adopting CSS-in-JS approach
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用 *CSS-in-JS* 方法
- en: Going from *HTML* to JSX
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 *HTML* 到 JSX
- en: Questions and answers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题和答案
- en: Exploring functions of React
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索React的功能
- en: In this section, we will start with an exploration of the function React serves
    in the website development field. By doing that we hope to get a more accurate
    description about how React can help us.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从探索React在网站开发领域所起的作用开始。通过这样做，我们希望对React如何帮助我们有一个更准确的描述。
- en: The book has been dedicated to introducing a state into a function component
    under *React*, especially the hook mechanism. We hope that by reading this book,
    you get to know how to design hooks in the right way.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书致力于介绍在 *React* 中将状态引入函数组件，特别是钩子机制。我们希望通过阅读本书，你能了解如何正确地设计钩子。
- en: 'When comparing *React* to other UI frameworks, have you heard that sometimes
    people refer to it as a utility rather than a framework? There''s no clear definition
    of what should be called a framework and what shouldn''t. Judging by the amount
    of *React* source code and how it wires with other systems, we can hardly treat
    it as a utility library. But at the same time, we also should remember the goal
    that *React* established with in the first place, because knowing this will help
    you to use this technology in the right way. Let''s take a look at the usage:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 *React* 与其他UI框架进行比较时，你是否听说过有时人们将其称为工具库而不是框架？对于什么应该被称为框架以及什么不应该被称为框架并没有明确的定义。根据
    *React* 源代码的数量以及它与其它系统的连接方式，我们几乎不能将其视为一个工具库。但与此同时，我们也应该记住 *React* 在一开始就设定的目标，因为了解这一点将帮助你正确地使用这项技术。让我们看看用法：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code is how we start all *React* projects. It searches for a *DOM*
    element and renders a component under it. Moreover, afterward, the screen under
    that element gets "managed" by *React*. This means that *React* overwrites everything
    under that element and refreshes upon any state change inside the component.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是我们开始所有 *React* 项目的步骤。它搜索一个 *DOM* 元素，并在其下渲染一个组件。此外，在该元素之后，该元素下的屏幕将由 *React*
    “管理”。这意味着 *React* 会覆盖该元素下的所有内容，并在组件内部任何状态变化时刷新。
- en: 'Therefore, the preceding `ReactDOM.render` method is the line to integrate
    *React* with your project. As you see, this line is powerful. In fact, it can
    be used multiple times for one project. Consider the following *HTML* page:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的 `ReactDOM.render` 方法是将 *React* 集成到你的项目的关键行。正如你所见，这一行非常强大。实际上，它可以在一个项目中多次使用。考虑以下
    *HTML* 页面：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Instead of controlling the whole site, we want to replace each `slider` instance
    with something more feature-rich:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想控制整个网站，而是想用功能更丰富的组件替换每个 `slider` 实例：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can go through the elements matching the `slider` instance in the *HTML*.
    For each element found, we take its `value` attribute and send it to a component
    with `ReactDOM.render`. Wow! All sliders are managed by *React*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 *HTML* 中遍历与 `slider` 实例匹配的元素。对于找到的每个元素，我们取其 `value` 属性并发送到一个使用 `ReactDOM.render`
    的组件。哇！所有滑块都由 *React* 管理。
- en: Although having multiple `render` instances is not a typical approach, we build
    a **Single Page Application** (**SPA**). This does give us one important message;
    that is, from the technical aspect, the goal of *React* is to replace and manage
    *DOM* elements on the screen. To make this happen, a new root fiber is created
    internally for each element so the engine knows where to start updating when a
    dispatch arrives.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然拥有多个 `render` 实例不是一种典型的方法，但我们构建了一个 **单页应用程序** (**SPA**)。这确实给我们一个重要的信息；那就是从技术角度来看，*React*
    的目标是替换和管理屏幕上的 *DOM* 元素。为了实现这一点，每个元素都会在内部创建一个新的根纤维，以便在接收到分发时，引擎知道从哪里开始更新。
- en: We know by now what *React* is designed to do. Let's take a quick look at how
    much effort it takes to do this – for instance, what are all the dependencies
    to invoke the `render` statement?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们已经知道了 *React* 的设计目的是什么。让我们快速看看完成这个任务需要多少努力——例如，调用 `render` 语句的所有依赖项是什么？
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To kick off the engine, we need a `render` function provided by the `react-dom`
    package. The component can be designed somewhere else, which requires the utilities
    of the `react` package, such as `createElement` and `useState`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动引擎，我们需要由 `react-dom` 包提供的 `render` 函数。组件可以设计在其他地方，这需要 `react` 包的实用工具，如 `createElement`
    和 `useState`：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Other than `react-dom` and `react` packages, it's the `document` object that
    we need to locate and manipulate the *DOM* element. But normally, as long as we
    have a browser session, we assume the `document` is available.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `react-dom` 和 `react` 包，我们还需要定位和操作 *DOM* 元素的 `document` 对象。但通常情况下，只要我们有一个浏览器会话，我们就假设
    `document` 是可用的。
- en: In short, there are two dependency packages. The `react` package is used for
    defining a component. With it, the component definition can be output into a format
    that the engine can understand. The `react-dom` package is used to render and
    manage the component to the screen. This means that before you kick off the engine,
    you don't need `react-dom`. Most of the development time is spent using the `react`
    package to define our components. From this exercise, we should clearly see the
    function of *React* as a utility library.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，有两个依赖包。`react` 包用于定义组件。使用它，组件定义可以输出为引擎可以理解的格式。`react-dom` 包用于将组件渲染和管理到屏幕上。这意味着在启动引擎之前，你不需要
    `react-dom`。大部分的开发时间都花在用 `react` 包定义我们的组件上。从这个练习中，我们应该清楚地看到 *React* 作为实用库的功能。
- en: To build a website with *React*, we need to do all the things that a web developer
    needs to do, that is, designing the site layout with *HTML*, making the site look
    beautiful with *CSS*, and adding business logic and interaction to engage the
    user with *JavaScript*. So, the question becomes how all these building blocks
    fit in the new component ecosystem. Let's take a look at them one at a time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要用 *React* 建立一个网站，我们需要做所有网络开发者需要做的事情，即用 *HTML* 设计网站布局，用 *CSS* 使网站看起来美观，并用 *JavaScript*
    添加业务逻辑和交互来吸引用户。因此，问题变成了所有这些构建块如何适应新的组件生态系统。让我们逐一看看它们。
- en: Embracing JavaScript ES6
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥抱 JavaScript ES6
- en: '*React* is written in the *JavaScript* language. *JavaScript* has been evolving
    for the past 20 years. With usage in frameworks such as jQuery, Angular, *React*,
    and Node.js, *JavaScript* is one of the most popular and influential programming
    languages.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*React* 是用 *JavaScript* 语言编写的。*JavaScript* 在过去 20 年中一直在发展。随着在 jQuery、Angular、*React*
    和 Node.js 等框架中的应用，*JavaScript* 成为了最受欢迎和最有影响力的编程语言之一。'
- en: 'The latest *JavaScript* is based on ECMAScript 2015, which is also known as
    *ES6*. This brought a few important features to *JavaScript*, and *React* has
    quickly adopted these features quite nicely. The following are just a few of the
    features:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最新的 *JavaScript* 基于 ECMAScript 2015，也称为 *ES6*。这给 *JavaScript* 带来了一些重要的特性，而 *React*
    也迅速很好地采用了这些特性。以下只是其中的一些特性：
- en: Arrow function
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数
- en: Spread and rest
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展和剩余参数
- en: Object enhancement
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象增强
- en: Template strings
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板字符串
- en: Destructuring
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构
- en: Let and const
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`let` 和 `const`'
- en: Modules
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Symbols
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号
- en: If you are considering using *JavaScript* as your main language, it's recommended
    that in your free time, you go over all the preceding materials because they are
    commonly used by *React* apps. We'll go over each of these features in the following
    sections.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在考虑将 *JavaScript* 作为你的主要语言，建议你在空闲时间回顾所有前面的材料，因为它们在 *React* 应用中很常见。我们将在接下来的章节中逐一介绍这些特性。
- en: Arrow function
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'The arrow function is a new syntax for function expressions. A typical function
    can be defined with a `function` keyword:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数是函数表达式的全新语法。一个典型的函数可以用 `function` 关键字定义：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*ES6* introduces a more compact way of defining the preceding function with
    an arrow (`=>`):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*ES6* 引入了一种更紧凑的方式来定义前面的函数，使用箭头（`=>`）：'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding arrow version omits the word `function` and makes a function
    look more like an object. The arrow function is often used as a callback:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的箭头版本省略了单词 `function`，使函数看起来更像一个对象。箭头函数通常用作回调：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code returns a new array with each element doubled. When we make
    a dispatch in *React*, we also tend to use the arrow syntax:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码返回一个新数组，每个元素都加倍。当我们进行 *React* 的调度时，我们也倾向于使用箭头语法：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that the `return` statement can be omitted if the arrow function returns
    a single expression. We can compare the preceding line with the regular function
    form:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果箭头函数返回一个单一的表达式，则可以省略 `return` 语句。我们可以将上一行与常规函数形式进行比较：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It''s apparent that the arrow function tends to be compact while working as
    an object. Being an object implies that we can pass it freely to anywhere via
    a function input argument. Sometimes, you also see a chained version, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，箭头函数在作为对象工作时往往更紧凑。作为一个对象意味着我们可以通过函数输入参数自由地将其传递到任何地方。有时，你也会看到链式版本，如下所示：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding line is equivalent to the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行等价于以下行：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You may find the arrow function quite expressive. The book basically uses this
    format solely. Only in one case does the book revert to the regular function format:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得箭头函数非常具有表现力。这本书基本上只使用这种格式。只有在一个情况下，这本书才会回到常规函数格式：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can invoke the function before the declaration in general, the compiler
    wouldn''t complain. However, this wouldn''t work for the arrow function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们可以在声明之前调用函数，编译器不会抱怨。然而，这对于箭头函数来说是不行的：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is because `fn` needs to be declared first before it can be referenced.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `fn` 需要先声明，然后才能被引用。
- en: 'The arrow function, though more compact and expressive, does carry some caveats
    compared to the regular function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规函数相比，尽管箭头函数更紧凑、更具表现力，但也存在一些需要注意的问题：
- en: It sets the `this` object upon creation instead of invocation.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在创建时设置 `this` 对象，而不是在调用时。
- en: It does not set the `arguments` object after invocation.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在调用后不会设置 `arguments` 对象。
- en: It cannot be used as a `constructor` function.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能用作 `constructor` 函数。
- en: Spread and rest
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展开和剩余
- en: Pretty new to the *Javascript* language, spread is a way to express all the
    parts of an item, and rest is a way to express the rest of the part of an item
    apart from the first few parts.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *JavaScript* 语言来说相当新颖，展开是一种表达一个项目所有部分的方式，而剩余则是表达除了前几个部分之外的项目剩余部分的方式。
- en: '*ES6* introduces quite a few features to allow our code to be more expressive.
    One of the features is to use a `...` keyword, as hardly anybody bothers to remember
    the exact feature name. Let''s take a look at one example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*ES6* 引入了许多特性，使我们的代码更具表现力。其中一个特性是使用 `...` 关键字，因为几乎没有人会费心去记住确切的特性名称。让我们来看一个例子：'
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, the `b` variable gets all the elements from the `a`
    array, spreads them into five elements, and then appends the new element so that
    the new array carries six elements in total. You can use this with an object as
    well:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，变量 `b` 从数组 `a` 中获取所有元素，将它们展开成五个元素，然后添加新的元素，使得新的数组总共包含六个元素。你也可以用对象来做这件事：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, the `b` variable gets all the properties from the `a`
    object, spreads them, and then adds the new `age` property so that the new object
    carries three properties in total.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，变量 `b` 从对象 `a` 中获取所有属性，展开它们，然后添加新的 `age` 属性，使得新的对象总共包含三个属性。
- en: Note that both usages of the spread operator create a new variable, either an
    array or an object. When it comes to quickly creating another variable out of
    an existing variable, this new syntax becomes quite popular.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两种用法都创建了一个新的变量，要么是一个数组，要么是一个对象。当涉及到从现有变量快速创建另一个变量时，这种新语法变得相当流行。
- en: '*React* uses this feature quite often in component design:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*React* 在组件设计中经常使用这个特性：'
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding component uses the `props` object to capture a list of props
    other than `title`. This becomes useful for the following reasons:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 之前组件使用 `props` 对象来捕获除 `title` 之外的其他属性列表。这有几个有用的原因：
- en: We do not have to care about the number of other props present in the list.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不必关心列表中其他属性的数量。
- en: We can send this list further down into the children component.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将这个列表发送到子组件中。
- en: 'There''s another similar *ES6* feature called the `rest` operator which behaves
    similarly to the `spread` operator. This is when `...` is applied to a function''s
    input argument list:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与 `spread` 操作符行为相似的 *ES6* 功能是 `rest` 操作符。这是当 `...` 应用于函数的输入参数列表时：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding `abc` function, we used a `...` rest operator to obtain additional
    arguments.. The `rest` variable holds an array, and when we invoke the function
    with more than two arguments, the additional arguments get populated into this
    array.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `abc` 函数中，我们使用了 `...` 剩余操作符来获取额外的参数。`rest` 变量包含一个数组，当我们用超过两个参数调用函数时，额外的参数会被填充到这个数组中。
- en: Object enhancement
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象增强
- en: 'With *ES6*, an object is extended to support quite a few features. Let''s take
    a look at some of them. One of the features is that we can use a shorthand version
    while making an assignment to a property under an object:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *ES6* 中，对象被扩展以支持相当多的功能。让我们看看其中的一些。其中一个功能是，在给对象属性赋值时，我们可以使用简写版本：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we write the preceding code in the old way, it would be equivalent to the
    following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用旧的方式编写前面的代码，它将等同于以下代码：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the property name matches the assignment variable name, *ES6* allows us
    to write the property name only once. This becomes handy in practice, and because
    of this, it''s common to see people take advantage of it by creating a temporary
    variable to match with the property name:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性名与赋值变量名匹配，*ES6* 允许我们只写一次属性名。这在实践中非常有用，因此，人们常常通过创建一个临时变量来匹配属性名来利用这一点：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Another enhancement to an object is to support an expression as the property
    name:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的另一个增强是支持将表达式用作属性名：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code is what we write to support a form submission. Don''t confuse
    the last line of that code with the following version:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是我们用来支持表单提交的代码。不要将那段代码的最后一行与以下版本混淆：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that the difference between these two is the bracket around `name`. Without
    the bracket, `name` would assign the value to the "`name`" property. However,
    in the `[name]` version, it would assign the value to a property with a name stored
    in a `name` variable. If `name` carries a "`first`" word, then the `[name]` version
    would become the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个之间的区别在于 `name` 周围的括号。如果没有括号，`name` 将会将值赋给 "`name`" 属性。然而，在 `[name]` 版本中，它将会将值赋给一个名为
    `name` 变量中存储的属性名。如果 `name` 包含了 "`first`" 这个词，那么 `[name]` 版本将变成以下这样：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Basically, this enables us to use any *JavaScript* expression as the property
    key. This was not possible before, so we used to write the following to remedy
    the issue:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这使得我们可以将任何 *JavaScript* 表达式用作属性键。在此之前这是不可能的，所以我们通常编写以下代码来解决这个问题：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Template strings
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板字符串
- en: 'It used to be cumbersome to construct a long string in *JavaScript* without
    sacrificing the raw format of the string. To address this problem, *ES6* added
    the template strings, which allow a string to be enclosed by the back-tick (`''`),
    a strange character that we use often when working with *Markdown* files. With
    this syntax, a string can be written in the following way:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *JavaScript* 中构建长字符串而不会牺牲字符串的原始格式曾经很麻烦。为了解决这个问题，*ES6* 添加了模板字符串，允许字符串被反引号（`'`）包围，这是我们处理
    *Markdown* 文件时经常使用的奇怪字符。使用这种语法，字符串可以按照以下方式编写：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'What''s interesting about the template, beyond the regular quoted string using
    `"` or `''`, is that it supports a paragraph of text written across multiple lines
    while preserving the line breaks:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串有趣的地方，除了使用 `"` 或 `'` 的常规引号字符串之外，还支持跨多行编写的文本段落，同时保留换行符：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This makes it useful when we want to introduce a paragraph of long text without
    formatting its content. The template strings also work with any *JavaScript* expression:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在不需要格式化内容的情况下引入一段长文本变得很有用。模板字符串也支持任何 *JavaScript* 表达式：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we replaced the incidence of `${what}` with the `"This"`
    string in the template. Essentially, what's written inside `${}` can be any *JavaScript*
    expression.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将模板中的 `${what}` 替换成了 `"This"` 字符串。本质上，`${}` 内部可以写任何 *JavaScript* 表达式。
- en: 'One common usage of the template strings is to convert another format into
    a string:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串的一个常见用法是将另一种格式转换为字符串：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can see in the preceding code that this becomes handy when we need to assemble
    a string such as a dynamic `url`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的代码中看到，当我们需要组装一个如动态 `url` 这样的字符串时，这变得非常有用。
- en: 'We can apply the preceding code to a more complex version, such as the *CSS*
    content:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前面的代码应用于更复杂的情况，例如*CSS*内容：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code uses a different form called tagged templates, and `css`
    is what''s referred to as a tagged function. Here''s another example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了一种不同的形式，称为标签模板，`css`被称为标签函数。这里还有一个例子：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code defines an `image` tagged function, which transforms `strings`
    into another format – in our case, an image element statement. From this, you
    can see that tagged templates can be useful as a utility to alleviate the pain
    of generating strings. In the *Adopting CSS-in-JS* approach section that follows,
    we shall see more examples of this.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码定义了一个`image`标签函数，它将`strings`转换为另一种格式——在我们的例子中，是一个图像元素声明。从这一点可以看出，标签模板可以作为工具，减轻生成字符串的痛苦。在接下来的*Adopting
    CSS-in-JS*方法部分，我们将看到更多这样的例子。
- en: Destructuring
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解构赋值
- en: The word "destructuring" is an awkward word to say and maybe we can't even find
    it in the dictionary.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: “解构赋值”这个词听起来有些别扭，也许我们甚至找不到它在字典中的条目。
- en: 'However, you might have used this feature quite a few times in the past:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能过去已经多次使用过这个特性：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Essentially, destructuring allows you to destruct an object and assign the
    dissembled elements to variables. The preceding code is destructuring usage applied
    to an array, which is equivalent to the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，解构赋值允许你解构一个对象，并将拆分的元素分配给变量。前面的代码是应用于数组的解构赋值用法，相当于以下代码：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can see that during the destructuring process, we follow the given structure
    to select the needed elements. Similarly, it can be applied to an object:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在解构过程中，我们遵循给定的结构来选择所需的元素。同样，它也可以应用于对象：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding statement translates to the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的声明可以翻译为以下内容：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Although we can continue to use the old method, destructuring is much easier
    and quicker to use. Keep in mind that the element you select has to exist; otherwise,
    you can get an `undefined`, as shown in the following case:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们还可以继续使用旧方法，但解构赋值使用起来要容易得多，也快得多。请记住，你选择的元素必须存在；否则，你可能会得到一个`undefined`，如下面的例子所示：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Another useful feature with destructuring is that you can rename a property
    if you want to store it under another name:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 解构赋值的一个有用特性是，如果你想用另一个名字存储属性，你可以重命名它：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding line translates to the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行可以翻译为以下内容：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Essentially, the `firstName` variable is used for the assignment instead of
    `first`, even though `first` is the property name under the object.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`firstName`变量用于赋值，而不是`first`，尽管`first`是对象下的属性名。
- en: 'Quite often, destructuring is used in combination with other *ES6* features,
    such as the spread operator:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 解构赋值经常与其他*ES6*特性结合使用，例如扩展运算符：
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We see this preceding statement quite often in *React* code, so let me explain
    each part of it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*React*代码中经常看到这个前面的声明，所以让我解释一下它的每个部分：
- en: '`...name` is to spread all properties of the `name` object.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`...name`是将`name`对象的全部属性展开。'
- en: '`last` is the enhanced object syntax to add the `last` property.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last`是增强的对象语法，用于添加`last`属性。'
- en: '`{ ...name, last }` creates a new object out of the existing one.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ ...name, last }`是从现有对象中创建一个新的对象。'
- en: '`first` is destructuring the `first` property out of the new object.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first`是从新对象中解构出`first`属性。'
- en: 'Wow, there''s a lot going on! Maybe we can write it in an equivalent version
    using the old method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这里有很多事情在进行中！也许我们可以用旧方法写一个等效版本：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Essentially, the new syntax takes only one line instead of three lines, but
    shockingly the outcome is much more accurate and expressive.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，新语法只需要一行代码，而不是三行，但令人惊讶的是，结果要准确得多，表达也更丰富。
- en: If you are new to this feature, don't hesitate in slowing down a bit while composing
    each part. The reason for that is, you will not only gain knowledge on what the
    new syntax provides but also you won't miss any logic accidentally.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个特性还不熟悉，不要犹豫，在编写每个部分时放慢一点速度。这样做的原因是，你不仅会了解新语法提供了什么知识，而且也不会不小心错过任何逻辑。
- en: let and const
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: let 和 const
- en: Using *JavaScript* in the past, you may have been confused by the `var`, `let`,
    and `const` keywords. Which one are you supposed to use to declare a variable?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去使用*JavaScript*时，你可能对`var`、`let`和`const`关键字感到困惑。你应该使用哪一个来声明一个变量？
- en: 'One thing to first get out of way is that `var` isn''t used often anymore;
    it''s there mostly for backward compatibility because it uses a strange scope
    rule. Instead, we should all use `let` and `const` because they are based on block
    scopes that developers are more comfortable using:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要明确的一点是，`var` 已经不再常用；它主要存在是为了向后兼容，因为它使用了一个奇怪的作用域规则。相反，我们应该都使用 `let` 和 `const`，因为它们基于块作用域，这是开发者更习惯使用的：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code, the `a` variable lives in the scope of the function and
    the `b` variable lives in the scope of the condition statement. Both references
    are valid in the scope specified by the `{}` parent enclosing block. If you try
    to reference either `a` or `b` outside of their defined scope, the compiler now
    throws an error. The same applies to the `i` variable, defined using `let` under
    the loop. If we had used `var`, it would make `i` accessible within the entire
    function body.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`a` 变量存在于函数的作用域中，而 `b` 变量存在于条件语句的作用域中。这两个引用在由 `{}` 父包围块指定的作用域内都是有效的。如果你试图在它们定义的作用域之外引用
    `a` 或 `b`，编译器现在会抛出一个错误。同样适用于使用 `let` 在循环中定义的 `i` 变量。如果我们使用 `var`，它会使 `i` 在整个函数体中可访问。
- en: 'As the names imply, you use `let` for a variable that needs to change later
    on and `const` for things you don''t expect to change. Here''s an example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所暗示的，你需要使用 `let` 来表示稍后需要改变的变量，而使用 `const` 来表示你预期不会改变的项。以下是一个例子：
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, if you change `x` to `6` later on, it's totally fine.
    But the compiler will raise an error if you try to change `n` to `"def"`. This
    applies to any primitive value, such as a number or a string.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果你稍后更改 `x` 为 `6`，这是完全正常的。但是，如果你尝试将 `n` 更改为 `"def"`，编译器会抛出一个错误。这适用于任何原始值，如数字或字符串。
- en: 'When it comes to a non-primitive value, such as an object or an array, it gets
    a bit complicated:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到非原始值，如对象或数组时，事情会变得有些复杂：
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Can you differentiate what the difference is between the preceding two lines?
    What is a variable object and what is a constant object?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你能区分前两行之间的区别吗？什么是变量对象，什么是常量对象？
- en: 'If an object is declared with `const`, it means only the object itself can''t
    be used to point to another memory space:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象是用 `const` 声明的，这意味着只能使用该对象本身来指向另一个内存空间：
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the preceding code, we defined an `obj` constant. Later on, if we attempt
    to overwrite `obj`, the compiler will throw an error. However, if we modify its
    content via a key, it''s still valid. Similarly, we can expect this behavior from
    an array:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个 `obj` 常量。稍后，如果我们尝试重写 `obj`，编译器会抛出一个错误。然而，如果我们通过键修改其内容，它仍然是有效的。同样，我们可以期待数组有类似的行为：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You might find this behavior a bit strange, but it actually is designed pretty
    consistently for all objects and arrays when it comes to their initialization,
    comparison, and so on.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得这种行为有点奇怪，但实际上，它在所有对象和数组初始化、比较等方面设计得相当一致。
- en: 'If you see an array or object defined with a `let` statement, it should tell
    you that they can be overwritten later on:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到用 `let` 语句定义的数组或对象，它应该告诉你它们可以在稍后重写：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is the main difference between the `let` and `const` statements.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `let` 和 `const` 语句之间的主要区别。
- en: Modules
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: 'There''s one thing a developer can''t live without these days, which is code
    imported from another file. However, *JavaScript* didn''t support this until *ES6*
    finally introduced a module system similar to what module loaders such as *AMD*
    or *CommonJS* provide. The idea is that we can export something from a file for
    reuse, as shown in this example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的开发者无法离开的一个东西就是从另一个文件导入的代码。然而，*JavaScript* 直到 *ES6* 才引入了一个类似于 *AMD* 或 *CommonJS*
    这样的模块系统。其理念是我们可以从一个文件中导出一些内容以供重用，如下例所示：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding code is quite common in a *React* application. Basically, it
    defines a `Title` component in a separate file and exports it as a default. From
    another file, we can import it and use it through an `import`, like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在 *React* 应用程序中相当常见。基本上，它在一个单独的文件中定义了一个 `Title` 组件，并将其作为默认值导出。从另一个文件中，我们可以通过
    `import` 导入它并使用它，如下所示：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is the main mechanism for pulling all the files together and compiling
    them into a single `index.js` file because it actually imports all of them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将所有文件拉在一起并编译成单个 `index.js` 文件的主要机制，因为它实际上导入了所有这些文件。
- en: 'Sometimes, we also want to export other materials along with `default`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们还想与 `default` 一起导出其他材料：
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the preceding code, we exported `Title` as `default`, and we also exported
    `TitleType` as a non-default. This means that we can cherry-pick things and import
    them individually:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将`Title`导出为`default`，同时将`TitleType`作为非默认导出。这意味着我们可以挑选事物并单独导入它们：
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This capability becomes handy when we store a bunch of related utility functionalities
    in a single file and export them one by one:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在单个文件中存储大量相关实用功能并将它们逐个导出时，这种能力变得非常方便：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To avoid the name collision, upon import, we can use the aliasing import via
    the `as` keyword:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免名称冲突，在导入时，我们可以使用`as`关键字进行别名导入：
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Symbol
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号
- en: 'Symbol is a new *JavaScript* feature that sounds like a game term. In fact,
    it is a special primitive type. Normally, we could have a string as a property
    key:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 符号是一个听起来像游戏术语的新*JavaScript*特性。实际上，它是一种特殊的原始类型。通常，我们可以将字符串作为属性键：
- en: '[PRE52]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Anyone who writes the preceding line can access the value stored under the
    `name` property. But what if we want to restrict access to only people who know
    a key? You may ask, "what do you mean by that? Isn''t the `"name"` string public
    to anyone?" That is the point – we want to create a key that not everyone can
    recreate easily. Here''s what we will do:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编写上述行的人都可以访问存储在`name`属性下的值。但如果我们只想限制只有知道钥匙的人才能访问，你会问：“你这是什么意思？`"name"`字符串不是对任何人都是公开的吗？”这正是我们要表达的意思——我们想要创建一个不是每个人都能轻易重新创建的钥匙。以下是我们将要做的：
- en: '[PRE53]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the preceding code, a `Symbol` with the "`name`" string is created to serve
    as a key. We can still access this symbolized property under `obj` if we have
    the exact key. But it won''t work if you create another key like that and try
    to access the property, like so:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，创建了一个带有"`name`"字符串的`Symbol`作为钥匙。如果我们有确切的钥匙，我们仍然可以访问`obj`下的这个符号化属性。但如果你创建另一个类似的钥匙并尝试访问属性，那么它就不会起作用，如下所示：
- en: '[PRE54]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Hmm, aren''t we using the same code again? Why can''t we access the same key?
    The answer lies in the following comparison:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们不是又用同样的代码了吗？为什么我们无法访问相同的键？答案在于以下比较：
- en: '[PRE55]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding comparison between two `Symbol(''name'')statements` returns `false`!
    This means you can''t expect to recreate the `"name"` key by writing it again;
    you can only have the original key you create in the first place or query through
    it from all registered keys in the system via `Symbol.for`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`Symbol('name')`语句之间的比较返回`false`！这意味着你不能期望通过再次编写它来重新创建`"name"`键；你只能拥有最初创建的原始键，或者通过`Symbol.for`从系统中所有注册的键中查询它：
- en: '[PRE56]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Once we find the key in the system, we can then access the property:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在系统中找到该键，我们就可以访问该属性：
- en: '[PRE57]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Ahh. This is interesting, isn't it?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 哎。这很有趣，不是吗？
- en: A symbol is a primitive that cannot be recreated and is guaranteed to be unique!
    This means that it can serve as a unique key to a door. If the key is not present,
    then the door can't be opened.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 符号是一个无法重新创建的原始类型，并且保证是唯一的！这意味着它可以作为一个独特的门钥匙。如果钥匙不存在，那么门就无法打开。
- en: This becomes useful when we don't want any developer to mistakenly access some
    memory or assign a value. It also becomes useful to transfer this key to another
    project or repository in a unique way. I will show you an example of how *React*
    uses it in the next section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不希望任何开发者意外访问某些内存或分配值时，这很有用。它还可以以独特的方式将此键转移到另一个项目或仓库中。我将在下一节中展示*React*如何使用它的一个例子。
- en: So far, we have gone over a couple of topics from *ES6*, including arrow functions,
    object enhancement, template strings, destructuring, `let` and `const`, modules,
    and symbols. But there's actually more to *ES6*, such as promise, proxy, generators,
    and weak map. We used promise when we referred to an API and used proxy in [*Chapter
    9*](B17963_09_Epub.xhtml#_idTextAnchor314), *Use Custom* *Hooks to Reuse Logic*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了*ES6*的一些主题，包括箭头函数、对象增强、模板字符串、解构、`let`和`const`、模块和符号。但实际上*ES6*还有更多，比如promise、proxy、generators和weak
    map。当我们提到API时使用了promise，在[*第9章*](B17963_09_Epub.xhtml#_idTextAnchor314)中使用了proxy，*使用自定义*
    *Hooks来重用逻辑*。
- en: One thing for sure is that *React* really takes advantage of the latest *JavaScript*
    language. If you practice them often, one thing you will find is that code becomes
    more expressive without losing its accuracy.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一件事可以肯定的是，*React*确实充分利用了最新的*JavaScript*语言。如果你经常练习，你会发现代码变得更加表达，同时不失其准确性。
- en: In the next section, we'll see how *React* uses materials from non-*JavaScript*
    languages, such as *CSS*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到*React*如何使用来自非*JavaScript*语言的材料，例如*CSS*。
- en: Adopting CSS-in-JS approach
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用CSS-in-JS方法
- en: 'When we build an application in *React*, at one point, we need to find a way
    to apply *CSS* styles to our code, right? If you have *CSS* experience in the
    past, one approach we''re familiar with is to use *CSS* classes to style styles.
    Consider the following *CSS* snippet stored in a file with a .`css` extension:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 *React* 中构建应用程序时，在某个时候，我们需要找到一种方法来将 *CSS* 样式应用到我们的代码中，对吧？如果你过去有 *CSS* 经验，我们熟悉的一种方法是使用
    *CSS* 类来设置样式。考虑以下存储在具有 .`css` 扩展名的文件中的 *CSS* 片段：
- en: '[PRE58]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can apply this style to a *React* element via a prop called `className`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个名为 `className` 的属性将此样式应用到 *React* 元素上：
- en: '[PRE59]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`class` is a reserved keyword for *JavaScript* and therefore can''t be used.
    Instead, *React* chooses to use a different word, `className`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`class` 是 *JavaScript* 的保留关键字，因此不能使用。相反，*React* 选择使用不同的单词，`className`。'
- en: Though this old method continues to work, there's one issue about the uniqueness
    of the `title` class. *CSS* can be applied to all the `title` elements on the
    screen, but it can't skip an element inside a component that we don't want to
    be styled. From the *CSS* perspective, the `title` class is exposed to be styled
    globally.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个旧方法仍然有效，但关于 `title` 类的唯一性问题。*CSS* 可以应用到屏幕上所有的 `title` 元素，但它不能跳过我们不想被样式的组件内部的元素。从
    *CSS* 的角度来看，`title` 类被暴露出来以进行全局样式化。
- en: Using a component design, it's just natural that we would want to apply the
    style to this component only! For example, the `title` style we defined can be
    only valid inside the `Title` component. Believe it or not, having a scope is
    the foundation of the component design.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件设计，我们自然会想要只将样式应用到这个组件上！例如，我们定义的 `title` 样式只能在 `Title` 组件内有效。信不信由你，有作用域是组件设计的基础。
- en: 'One way to make the style unique to the component is to bake the style inline
    along with the element using a `style` prop:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使样式对组件独特的一种方法是将样式内联与元素一起使用 `style` 属性：
- en: '[PRE60]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'But the problem of the preceding hardcoded approach is also quite obvious.
    It''s just not feasible to write a large amount of styles inline. This is where
    the *CSS-in-JS* approach comes into play. The idea is to utilize a template string
    to write the *CSS* using the old method. Okay, we just introduced the template
    strings from one of the *ES6* features:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 但前面硬编码方法的问题也很明显。直接在内联中编写大量样式是不切实际的。这正是 *CSS-in-JS* 方法发挥作用的地方。想法是利用模板字符串使用旧方法编写
    *CSS*。好吧，我们刚刚从 *ES6* 的一个特性中介绍了模板字符串：
- en: '[PRE61]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: There's almost no learning curve to use the preceding string. Thus, this approach
    has been adopted by the community quickly and implemented by a couple of libraries,
    such as `styled-JSX` and `styled-components`. We will introduce both in this section,
    so let's get started.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面字符串的学习曲线几乎不存在。因此，这种方法很快被社区采用，并被几个库实现，例如 `styled-JSX` 和 `styled-components`。我们将在本节中介绍这两个库，让我们开始吧。
- en: styled-SX
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: styled-SX
- en: '`styled-JSX` is a *CSS-in-JS* library that allows us to write scoped *CSS*
    for a component where the style doesn''t affect other components, thus allowing
    us to amend styles without worrying about making changes to other components on
    the screen.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`styled-JSX` 是一个 *CSS-in-JS* 库，它允许我们为组件编写作用域内的 *CSS*，这样样式就不会影响到其他组件，从而允许我们修改样式而不用担心会影响到屏幕上的其他组件。'
- en: 'Let''s take the same `Title` component and see how it''s done with `styled-JSX`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用相同的 `Title` 组件来看看如何使用 `styled-JSX` 来实现：
- en: '[PRE62]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: It introduces a special `style` tag with a `jsx` prop, and underneath it, the
    styles can be written as *CSS* code. The styles are only injected once, even if
    the `Title` component is used more than once.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 它引入了一个特殊的 `style` 标签，带有 `jsx` 属性，在其下方，样式可以写成 *CSS* 代码。即使 `Title` 组件被多次使用，样式也只注入一次。
- en: 'This semi-inline approach of styles can be quite efficient when it comes to
    prototyping an application. Instead of putting the *CSS* inline with the component,
    we can put the styles in a separate file, like so:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到原型设计应用程序时，这种半内联的样式方法可以非常高效。我们不必将 *CSS* 与组件内联，我们可以将样式放在一个单独的文件中，如下所示：
- en: '[PRE63]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can import it into the `Title` component:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其导入到 `Title` 组件中：
- en: '[PRE64]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This gives us some freedom to write the CSS either inline or in a separate file.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一些自由来编写 CSS，无论是内联还是单独的文件。
- en: 'One important thing to note is that the styles we wrote so far do not apply
    to child components by default:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的事情需要注意，我们迄今为止编写的样式默认情况下不适用于子组件：
- en: '[PRE65]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The preceding code wouldn''t make any `span` element displayed with a green
    color. To get it working, we can use a `global` attribute:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码不会使任何 `span` 元素以绿色颜色显示。为了使其工作，我们可以使用一个 `global` 属性：
- en: '[PRE66]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`styled-JSX` is quite a unique library that makes styling easy in *React*.
    Moreover, since the styles are actually written in a *JavaScript* string, it can
    be manipulated at runtime. We''ll demonstrate this feature in the next package,
    `styled-components`, since this feature works for both packages.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`styled-JSX` 是一个相当独特的库，它使得在 *React* 中进行样式设计变得简单。此外，由于样式实际上是用 *JavaScript* 字符串编写的，因此可以在运行时进行操作。我们将在下一个包
    `styled-components` 中展示这一功能，因为该功能适用于这两个包。'
- en: styled-components
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: styled-components
- en: 'There''s another library implementing the *CSS-in-JS* strategy called `styled-components`.
    This book has adopted this approach for all examples requiring styles. Instead
    of using a `style` tag, it actually allows us to define the *CSS* in a separate
    component:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个名为 `styled-components` 的库实现了 *CSS-in-JS* 策略。本书为所有需要样式的示例采用了这种方法。它不是使用 `style`
    标签，而是实际上允许我们在单独的组件中定义 *CSS*：
- en: '[PRE67]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the preceding code, `styled.h1` is a tagged template function that outputs
    a component with an embedded `h1` element.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`styled.h1` 是一个标签模板函数，它输出一个包含嵌入式 `h1` 元素的组件。
- en: 'Moreover, `styled-components` allows *CSS* to apply to the children by default,
    which is very different from the `styled-JSX` package:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`styled-components` 允许 *CSS* 默认应用于子元素，这与 `styled-JSX` 包不同：
- en: '[PRE68]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The preceding code sets the `span` element with a green color. This reminds
    us of Sass or SCSS code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码设置了 `span` 元素的绿色颜色。这让我们想起了 Sass 或 SCSS 代码。
- en: 'One interesting benefit that the *CSS-in-JS* solution provides is that the
    *JavaScript* string can be blended with other *JavaScript* expressions to support
    dynamic styles at runtime:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*CSS-in-JS* 解决方案提供的一个有趣的好处是，*JavaScript* 字符串可以与其他 *JavaScript* 表达式混合，以支持运行时动态样式：'
- en: '[PRE69]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The preceding code defines a `big` prop that can be sent to the `TitleStyle`
    component where, based on the `big` value, `fontSize` can be switched between
    `3em` and `1.5em`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个 `big` 属性，可以发送到 `TitleStyle` 组件，根据 `big` 的值，`fontSize` 可以在 `3em` 和
    `1.5em` 之间切换。
- en: The dynamic *CSS* support makes it possible to create themeable components quite
    easily in *React*, and also opens the door for animating components that require
    a value change over time.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 动态 *CSS* 支持使得在 *React* 中轻松创建可主题化的组件成为可能，同时也为需要随时间变化值以进行动画的组件打开了大门。
- en: Now that we have seen how *React* brings *CSS* into *JavaScript* to blend the
    two technologies together, let's move on to *HTML* and see how it can be brought
    into *React*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了 *React* 如何将 *CSS* 带入 *JavaScript* 以融合这两种技术，那么让我们继续探讨 *HTML*，看看它如何被引入
    *React*。
- en: Going from HTML to JSX
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 HTML 到 JSX
- en: 'One barrier for a developer adopting *React*, especially if they are used to
    working with other web technologies, is that *HTML* isn''t imported into the project
    anymore. There''s not a file with a `.html` extension, except the entry `index.html`
    file, which most of the time only has one line of *HTML* inside, like so:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个开发者来说，采用 *React* 是一个障碍，尤其是如果他们习惯于使用其他网络技术的话。因为 *HTML* 已经不再被导入到项目中了。除了入口文件
    `index.html`，没有其他带有 `.html` 扩展名的文件，而这个入口文件通常只包含一行 *HTML*，如下所示：
- en: '[PRE70]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: But that's it. If there was a project manager that liked to review *HTML* or
    even work on it, they can't do that anymore. This missing *HTML* file could be
    one of the reasons why teams are hesitant to adopt *React*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 但仅此而已。如果有一个项目经理喜欢审查 *HTML* 或甚至参与其中，他们现在不能再这样做。缺少的 *HTML* 文件可能是团队犹豫采用 *React*
    的原因之一。
- en: However, *HTML* has a similar problem to *CSS.* They don't have scopes that
    we have in programming languages. Even worse, a piece of *HTML*, once written,
    is almost turned into *DOM* elements instantly. So, a component-based system has
    to come up with a way to add a layer in between.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*HTML* 与 *CSS* 有着类似的问题。它们在编程语言中拥有的作用域在这里并不存在。更糟糕的是，一旦写好一段 *HTML*，几乎会立即转换为
    *DOM* 元素。因此，基于组件的系统必须想出一种方法在中间添加一层。
- en: 'How did *React* solve this problem? It chose to take the *HTML* in – no surprise.
    But one amazing job that *React* did is that it kept the experience of writing
    these statements as close as possible to *HTML*. Technically, *React* made the
    smooth transformation from a piece of *HTML* to a piece of *JavaScript* code possible.
    Sometimes, we don''t notice this, nor can we tell the difference:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*React*是如何解决这个问题？它选择了接受*HTML*，这并不令人惊讶。但*React*所做的令人惊讶的工作之一是，它使编写这些语句的体验尽可能接近*HTML*。技术上，*React*使将一段*HTML*转换成一段*JavaScript*代码的平滑转换成为可能。有时，我们并没有注意到这一点，也无法区分它们：'
- en: '[PRE71]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The preceding code is what we use inside a function component. The format does
    look like a piece of *HTML*. What''s seen by the compiler is the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是我们在一个函数组件内部使用的。格式看起来像一段*HTML*。编译器看到的是以下内容：
- en: '[PRE72]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: After the compiler transformation, it becomes a *JavaScript* expression of a
    `createElement` function, taking three input arguments.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译器转换之后，它变成了一个`createElement`函数的*JavaScript*表达式，该函数接受三个输入参数。
- en: The magic of how this transformation happens is done through a compiler with
    a *Babel* plugin. When the compiler builds the code, Babel converts the code into
    an abstract syntax tree, a token format, and then stitches them back together
    and puts them into the *JavaScript* format.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换发生的魔法是通过一个带有*Babel*插件的编译器完成的。当编译器构建代码时，Babel将代码转换成抽象语法树、标记格式，然后将它们重新拼接并放入*JavaScript*格式中。
- en: Note
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are interested in knowing what a compiler does, you can visit [https://babeljs.io/repl](https://babeljs.io/repl)
    and try it out yourself.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对了解编译器做了什么感兴趣，可以访问[https://babeljs.io/repl](https://babeljs.io/repl)并亲自尝试。
- en: We are going to take a look at this `createElement` function closely now. The
    first input argument of the `createElement` function is the `type` of the element,
    which is taken from the element tag `h1`. The second one is the `props`, which
    is an object containing the `title` property. Last, but not least, the third one
    is the `children`; in our case, it's a string containing `"Hello World"`. Let's
    walk through these input arguments in more detail, since each of them is an essential
    part of *React*!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将仔细研究这个`createElement`函数。`createElement`函数的第一个输入参数是元素的`type`，它来自元素标签`h1`。第二个是`props`，它是一个包含`title`属性的对象。最后但同样重要的是，第三个是`children`；在我们的例子中，它是一个包含`"Hello
    World"`的字符串。让我们更详细地了解一下这些输入参数，因为它们都是*React*的必要组成部分！
- en: Props
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'The `props` input argument is one of the most important *React* mechanisms.
    We have been talking about props all the time, and this is where they receive
    their first-hand values. It''s because `createElement` is a *JavaScript* function
    that we can wire any *JavaScript* expression to the props:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`props`输入参数是*React*最重要的机制之一。我们一直在谈论属性，这就是它们接收第一手值的地方。这是因为`createElement`是一个*JavaScript*函数，我们可以将任何*JavaScript*表达式连接到属性上：'
- en: '[PRE73]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the preceding code, it's apparent now how a `title` prop and a `count` state
    are sent to `createElement` as part of the props.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，现在很明显，`title`属性和`count`状态是如何作为属性的一部分发送给`createElement`的。
- en: 'This also explains why we can''t use the `class` reserved word as the prop
    to style the component:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这也解释了为什么我们不能使用`class`保留字作为属性来样式化组件：
- en: '[PRE74]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The preceding code would raise a compiler error due to the `class` key.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码会因为`class`键而引发编译器错误。
- en: Children
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子元素
- en: 'The `children` input argument is the reason that we can nest one element under
    another element:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`children`输入参数是我们可以在一个元素下嵌套另一个元素的原因：'
- en: '[PRE75]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'What the compiler sees is the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器看到的是以下内容：
- en: '[PRE76]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note from the preceding output that there are two usages of `createElement`,
    one for the `h1` element and one for the child `span` element. The second `createElement`
    function is used as the `children` argument of the first `createElement` function.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意从上述输出中可以看到，`createElement`有两种用法，一个用于`h1`元素，另一个用于子`span`元素。第二个`createElement`函数被用作第一个`createElement`函数的`children`参数。
- en: Now, it's not too difficult to see a long list of elements nested and returned
    from a component via `createElement` functions. Technically, even without the
    compiler's help, you can code your component manually with this nested writing.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不难看到通过`createElement`函数从组件中返回的嵌套元素的长列表。技术上，即使没有编译器的帮助，你也可以手动使用这种嵌套编写代码。
- en: 'Though a single element can be nested under, there can be cases where more
    than one element needs to be nested under another one:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管单个元素可以嵌套在下面，但有时可能需要将多个元素嵌套在另一个元素下面：
- en: '[PRE77]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'For the preceding *JavaScript* expression involving an array, the array would
    be sent to the `children` of `createElement`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前述涉及数组的*JavaScript*表达式，该数组将被发送到`createElement`的`children`：
- en: '[PRE78]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Essentially, the `children` input argument can support the following formats:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`children`输入参数可以支持以下格式：
- en: A `"Hello World"` string
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`"Hello World"`字符串
- en: A single element via `createElement`
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`createElement`创建单个元素
- en: An array of elements with either of the preceding format
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以前述格式之一为格式的元素数组
- en: '*React* also allows you to add any number of children in another way:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*React*还允许你以另一种方式添加任意数量的子元素：'
- en: '[PRE79]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In the preceding code, we can stack the children in the input argument list,
    starting from the third input argument.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们可以从第三个输入参数开始，在输入参数列表中堆叠子元素。
- en: Element type
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素类型
- en: 'An element type, the first input argument to `createElement`, can be a simple
    string representing an *HTML* tag, such as `h1` and `span`. However, it can also
    take other formats, such as a function:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 元素类型，`createElement`的第一个输入参数，可以是一个简单的字符串，表示一个*HTML*标签，例如`h1`和`span`。然而，它也可以采用其他格式，例如一个函数：
- en: '[PRE80]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'What the compiler sees of the preceding code is the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器看到的前述代码如下：
- en: '[PRE81]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Note `Child` in the preceding code – the function itself is sent to `createElement`
    as the element type! This is how *React* allows you to create an element out of
    a custom component. Because of this, it means we can support a dynamic element
    type at runtime:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前述代码中的`Child`——函数本身被发送到`createElement`作为元素类型！这就是*React*允许你从自定义组件创建元素的方式。正因为如此，这意味着我们可以在运行时支持动态元素类型：
- en: '[PRE82]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In the preceding code, instead of returning either `<Child1 />` or `<Child2
    />`, we first determine the type of `Child` component at the runtime and then
    return the instance from this `<Child />` component. This is all possible because
    the component type is a *JavaScript* variable:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们不是返回`<Child1 />`或`<Child2 />`，而是首先确定`Child`组件的类型，然后从这个`<Child />`组件返回实例。这一切都是因为组件类型是一个*JavaScript*变量：
- en: '[PRE83]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The preceding code confirms what the compiler sees. The `Child` component type
    is determined at runtime.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码确认了编译器看到的内容。`Child`组件类型是在运行时确定的。
- en: Now that we have seen the `createElement` function and its three input arguments,
    let's take a close look at what it returns.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了`createElement`函数及其三个输入参数，让我们仔细看看它返回的内容。
- en: React element
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React元素
- en: As the `createElement` name indicates, the function returns a root element with
    a tree of elements under it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如`createElement`的名称所示，该函数返回一个带有其下元素树的根元素。
- en: 'Is the element a *DOM* element? No, it''s called a *React* element. Though
    the *React* documentation doesn''t talk too much about it, we''ll reveal it a
    bit briefly here:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个元素是*DOM*元素吗？不，它被称为*React*元素。尽管*React*文档没有过多地谈论它，但我们将在这里简要地揭示它：
- en: '[PRE84]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The preceding code is a short definition of the *React* element definition.
    As you can see, it's basically an object. We've been introduced to `type` and
    `props`, but what the heck is `$$typeof`? Apparently, this is not something that
    *React* wants anyone to tamper with.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码是*React*元素定义的简短定义。正如你所见，它基本上是一个对象。我们已经介绍了`type`和`props`，但`$$typeof`是什么东西呢？显然，这不是*React*希望任何人都能篡改的东西。
- en: It turns out *React* supports various categories of elements. For the lack of
    a better word, let's call `$$typeof` another type, an internal type. The one we
    used most often was `react.element`, and it's defined as a `Symbol`. We just introduced
    `Symbol` in the previous section. Basically, `react.element` is a unique primitive
    value that, once created, can be used but not changed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，*React*支持各种元素类别。由于没有更好的词，让我们把`$$typeof`称为另一种类型，即内部类型。我们最常用的一个是`react.element`，它被定义为`Symbol`。我们之前已经介绍了`Symbol`。基本上，`react.element`是一个独特的原始值，一旦创建，就可以使用但不能更改。
- en: 'You may ask, "what are other types are there?" Actually, there are two dozen
    of them; here are just a few that might interest you:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，“还有其他类型吗？”实际上，有二十多种；这里只是列出一些可能对你感兴趣的：
- en: '`react.element`'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react.element`'
- en: '`react.portal`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react.portal`'
- en: '`react.fragment`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react.fragment`'
- en: '`react.provider`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react.provider`'
- en: '`react.suspense`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react.suspense`'
- en: '`react.memo`'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react.memo`'
- en: '`react.lazy`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react.lazy`'
- en: Why do we need all these different types?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要所有这些不同的类型？
- en: 'Most of the application implementation is more or less around updating a `react.element`,
    but when it comes to special cases, it requires a different updating algorithm.
    Let''s take a look at the following example:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序实现或多或少都是围绕更新`react.element`进行的，但当涉及到特殊情况时，它需要一个不同的更新算法。让我们看看以下示例：
- en: '[PRE85]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In the preceding code, `Provider` creates an element with a `react.provider`
    type. Under it, `<>` creates an element with a `react.fragment` type, and under
    it, `div` creates two elements with a `react.element` type. The entire component
    is wrapped in a `memo` element with a `react.memo` type. This gives you a rough
    idea of where different *React* elements are used.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Provider` 创建了一个具有 `react.provider` 类型的元素。在其下方，`<>` 创建了一个具有 `react.fragment`
    类型的元素，再下面，`div` 创建了两个具有 `react.element` 类型的元素。整个组件被一个具有 `react.memo` 类型的 `memo`
    元素包裹。这给你一个大致的概念，了解不同的 *React* 元素在哪里被使用。
- en: In short, what returns from the JSX code block are *React* elements. These *React*
    elements are what is fed into the *React* engine.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，从 JSX 代码块返回的是 *React* 元素。这些 *React* 元素是输入到 *React* 引擎中的内容。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started with the function of *React* in web development.
    We went into three aspects of it. First, we went through the latest *ES6* features
    of *JavaScript*, such as the arrow function and template strings. Next, we learned
    the *CSS-in-JS* approach to bring *CSS* into *JavaScript*, using libraries such
    as `styled-JSX` and `styled-components`. Last, but not least, we learned how *HTML*-like
    JSX code is transformed and returned as *React* elements. All in all, we saw how
    *React* pulls all these resources together, including *JavaScript*, *CSS*, and
    *HTML*, to help us build a site.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从 *React* 在 Web 开发中的作用开始。我们探讨了它的三个方面。首先，我们了解了 *JavaScript* 的最新 *ES6*
    功能，如箭头函数和模板字符串。接下来，我们学习了将 *CSS* 带入 *JavaScript* 的 *CSS-in-JS* 方法，使用如 `styled-JSX`
    和 `styled-components` 这样的库。最后，但同样重要的是，我们学习了如何将类似 *HTML* 的 JSX 代码转换并返回为 *React*
    元素。总的来说，我们看到了 *React* 如何将这些资源（包括 *JavaScript*、*CSS* 和 *HTML*）整合在一起，帮助我们构建网站。
- en: Questions and answers
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和答案
- en: 'The following are some questions and answers to refresh your knowledge:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些问题和答案，以帮助你巩固知识：
- en: What is *React*?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 *React*？
- en: It's a tool that allows us to design a component and manage its update with
    a render engine.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个允许我们使用渲染引擎设计和更新组件的工具。
- en: What is *JavaScript ES6*?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 *JavaScript ES6*？
- en: '*JavaScript* has all the latest features published as *ES6*. *React* takes
    advantage of them, using features such as the arrow function, template strings,
    and destructuring. Using them in your project would make your code more efficient,
    expressive, and maintainable.'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*JavaScript* 包含了作为 *ES6* 发布的所有最新功能。*React* 利用这些功能，使用箭头函数、模板字符串和结构化等特性。在项目中使用它们可以使你的代码更高效、更易于表达和维护。'
- en: What's *CSS-in-JS*?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 *CSS-in-JS*？
- en: '*CSS-in-JS* refers to one opinionated but popular way to apply styles to a
    *React* component. The styles applied are localized to the component and don''t
    collide with any other components. Moreover, the styles can be wired with any
    *JavaScript* expression to support dynamic styles at runtime.'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*CSS-in-JS* 指的是一种有见地但流行的将样式应用于 *React* 组件的方法。应用的样式仅限于组件，不会与其他组件冲突。此外，样式可以与任何
    *JavaScript* 表达式连接，以支持运行时动态样式。'
- en: What is JSX code?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSX 代码是什么？
- en: '*React* allows us to use JSX code to write *HTML*-like code. Practically, they
    look quite similar, except JSX allows us to transform these statements into native
    *JavaScript* expressions that accept element types, props, and children from the
    input argument and return *React* elements that the engine can put into effect.'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*React* 允许我们使用 JSX 代码编写类似 *HTML* 的代码。实际上，它们看起来非常相似，只不过 JSX 允许我们将这些语句转换为接受元素类型、属性和子元素从输入参数的本地
    *JavaScript* 表达式，并返回引擎可以生效的 *React* 元素。'
