["```js\n    import { createCookie } from '@remix-run/node';const visitorCookie = createCookie('visitor-cookie', {  maxAge: 60 * 5, // 5 minutes});\n    ```", "```js\n    type VisitorCookieData = {  redirectUrl?: string;};\n    ```", "```js\n    export async function getVisitorCookieData(request: Request): Promise<VisitorCookieData> {  const cookieHeader = request.headers.get('Cookie');  const cookie = await visitorCookie.parse(cookieHeader);  return cookie && cookie.redirectUrl ? cookie : { redirectUrl: undefined };}\n    ```", "```js\n    export async function setVisitorCookieData(data: VisitorCookieData, headers = new Headers()): Promise<Headers> {  const cookie = await visitorCookie.serialize(data);  headers.append('Set-Cookie', cookie);  return headers;}\n    ```", "```js\n    import { setVisitorCookieData } from '~/modules/session/session.server.ts';\n    ```", "```js\n    export async function requireUserId(request: Request) {  const session = await getUserSession(request);  const userId = session.get('userId');  if (!userId || typeof userId !== 'string') {url property on the Request object to access the URL the user wanted to visit before the redirect.\n    ```", "```js\n    import { getVisitorCookieData } from '~/modules/visitors.server';\n    ```", "```js\n    try {  const user = await loginUser({ email, password });  /dashboard instead.\n    ```", "```js\n    const PAGE_SIZE = 10;\n    ```", "```js\n    const userId = await requireUserId(request);const url = new URL(request.url);const searchString = url.searchParams.get('q');@prisma/client`.\n\n    ```", "```js\n\n    ```", "```js\n    const where: Prisma.ExpenseWhereInput = {  userId,  title: {    contains: searchString ? searchString : '',  },};const [count, expenses] = $transaction utility instead of Promise.all for the additional performance benefit of making one big call to the database instead of two.\n    ```", "```js\n    return json({ count, expenses });\n    ```", "```js\n    const useSearchParams hook to read the page query parameter:\n\n    ```", "```js\n\n    ```", "```js\n    {showPagination && (  <Form expense-search feature.The `page` search parameter. Since the form uses GET, the route’s `loader` function is called (not its `action`).We could also use anchor tags instead of a form. Both initiate an HTTP GET request. The reason we decided to use a form here is so that we can utilize HTML button elements. We want to show the `disabled` attribute.Note that we include a hidden input field for the expense search filter parameter called `q`. This is necessary as we would otherwise reset the search filter when navigating between the different pages. By persisting the filter, the pagination works together with the search functionality and allows us to navigate between different pages of the filtered expenses list.\n    ```", "```js\n    <Form method=\"get\" action={location.pathname}>  <input type=\"hidden\" name=\"page\" value={1} />  <SearchInput name=\"q\" type=\"search\" label=\"Search by title\" defaultValue={searchQuery} key={searchQuery} /></Form>\n    ```", "```js\nconst isOnFirstPage = pageNumber === 1;const showPagination = count > PAGE_SIZE || !isOnFirstPage;\n```"]