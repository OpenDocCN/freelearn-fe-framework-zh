["```js\n{\n  drawCommand: \"drawLine\",\n  id: 123,\n  x1: 100,\n  y1: 100,\n  x2: 200,\n  y2: 100\n}\n{\n  drawCommand: \"rotate\",\n  id: 234,\n  previousAngle: 0,\n  newAngle: 90\n}\n```", "```js\n    import React from \"react\";\n    import ReactDOM from \"react-dom\";\n    import {\n      initializeReactContainer,\n      render,\n      element,\n    } from \"./reactTestExtensions\";\n    import { AnimatedLine } from \"../src/AnimatedLine\";\n    import { horizontalLine } from \"./sampleInstructions\";\n    const turtle = { x: 10, y: 10, angle: 10 };\n    describe(\"AnimatedLine\", () => {\n      beforeEach(() => {\n        initializeReactContainer();\n      });\n      const renderSvg = (component) =>\n        render(<svg>{component}</svg>);\n      const line = () => element(\"line\");\n    });\n    ```", "```js\n    it(\"draws a line starting at the x1,y1 co-ordinate of the command being drawn\", () => {\n      renderSvg(\n        <AnimatedLine\n          commandToAnimate={horizontalLine}\n          turtle={turtle}\n        />\n      );\n      expect(line()).not.toBeNull();\n      expect(line().getAttribute(\"x1\")).toEqual(\n        horizontalLine.x1.toString()\n      );\n      expect(line().getAttribute(\"y1\")).toEqual(\n        horizontalLine.y1.toString()\n      );\n    });\n    ```", "```js\n    import React from \"react\";\n    export const AnimatedLine = ({\n      commandToAnimate: { x1, y1 }\n    }) => (\n      <line x1={x1} y1={y1} />\n    );\n    ```", "```js\n    it(\"draws a line ending at the current position of the turtle\", () => {\n      renderSvg(\n        <AnimatedLine\n          commandToAnimate={horizontalLine}\n          turtle={{ x: 10, y: 20 }}\n        />\n      );\n      expect(line().getAttribute(\"x2\")).toEqual(\"10\");\n      expect(line().getAttribute(\"y2\")).toEqual(\"20\");\n    });\n    ```", "```js\n    export const AnimatedLine = ({\n      commandToAnimate: { x1, y1 },\n      turtle: { x, y }\n    }) => (\n      <line x1={x1} y1={y1} x2={x} y2={y} />\n    );\n    ```", "```js\n    it(\"sets a stroke width of 2\", () => {\n      renderSvg(\n        <AnimatedLine\n          commandToAnimate={horizontalLine}\n          turtle={turtle}\n        />\n      );\n      expect(\n        line().getAttribute(\"stroke-width\")\n      ).toEqual(\"2\");\n    });\n    it(\"sets a stroke color of black\", () => {\n      renderSvg(\n        <AnimatedLine\n          commandToAnimate={horizontalLine}\n          turtle={turtle}\n        />\n      );\n      expect(\n        line().getAttribute(\"stroke\")\n      ).toEqual(\"black\");\n    });\n    ```", "```js\n    export const AnimatedLine = ({\n      commandToAnimate: { x1, y1 },\n      turtle: { x, y }\n    }) => (\n      <line\n        x1={x1}\n        y1={y1}\n        x2={x}\n        y2={y}\n        strokeWidth=\"2\"\n        stroke=\"black\"\n      />\n    );\n    ```", "```js\nconst myCallback = time => {\n  // animating code here\n};\nwindow.requestAnimationFrame(myCallback);\n```", "```js\nlet startTime;\nlet endTimeMs = 2000;\nconst myCallback = time => {\n  if (startTime === undefined) startTime = time;\n  const elapsed = time - startTime;\n  // ... modify visual state here ...\n  if (elapsed < endTimeMs) {\n    window.requestAnimationFrame(myCallback);\n  }\n};\n// kick off the first animation frame\nwindow.requestAnimationFrame(myCallback);\n```", "```js\n    it(\"initially places the turtle at 0,0 with angle 0\", () => {\n      renderWithStore(<Drawing />);\n      expect(Turtle).toBeRenderedWithProps({\n        x: 0,\n        y: 0,\n        angle: 0\n      });\n    });\n    ```", "```js\n    const { drawCommands } = useSelector(\n      ({ script }) => script\n    );\n    ```", "```js\n    import React, { useState } from \"react\";\n    ```", "```js\n    const [turtle, setTurtle] = useState({\n      x: 0,\n      y: 0,\n      angle: 0\n    });\n    ```", "```js\n    beforeEach(() => {\n      ...\n      jest\n        .spyOn(window, \"requestAnimationFrame\");\n    });\n    ```", "```js\n    describe(\"movement animation\", () => {\n      const horizontalLineDrawn = {\n        script: {\n          drawCommands: [horizontalLine],\n          turtle: { x: 0, y: 0, angle: 0 },\n        },\n      };\n      it(\"invokes requestAnimationFrame when the timeout fires\", () => {\n        renderWithStore(<Drawing />, horizontalLineDrawn);\n        expect(window.requestAnimationFrame).toBeCalled();\n      });\n    });\n    ```", "```js\n    import React, { useState, useEffect } from \"react\";\n    ```", "```js\n    export const Drawing = () => {\n      ...\n      useEffect(() => {\n        requestAnimationFrame();\n      }, []);\n      return ...\n    };\n    ```", "```js\n    import { act } from \"react-dom/test-utils\";\n    ```", "```js\n    import { AnimatedLine } from \"../src/AnimatedLine\";\n    jest.mock(\"../src/AnimatedLine\", () => ({\n      AnimatedLine: jest.fn(\n        () => <div id=\"AnimatedLine\" />\n      ),\n    }));\n    ```", "```js\n    const triggerRequestAnimationFrame = time => {\n      act(() => {\n        const mock = window.requestAnimationFrame.mock\n        const lastCallFirstArg =\n          mock.calls[mock.calls.length - 1][0]\n        lastCallFirstArg(time);\n      });\n    };\n    ```", "```js\n    it(\"renders an AnimatedLine with turtle at the start position when the animation has run for 0s\", () => {\n      renderWithStore(<Drawing />, horizontalLineDrawn);\n      triggerRequestAnimationFrame(0);\n      expect(AnimatedLine).toBeRenderedWithProps({\n        commandToAnimate: horizontalLine,\n        turtle: { x: 100, y: 100, angle: 0 }\n      });\n    });\n    ```", "```js\n    const commandToAnimate = drawCommands[0];\n    const isDrawingLine =\n      commandToAnimate &&  \n      isDrawLineCommand(commandToAnimate);\n    useEffect(() => {\n      const handleDrawLineFrame = time => {\n        setTurtle(turtle => ({\n          ...turtle,\n          x: commandToAnimate.x1,\n          y: commandToAnimate.y1,\n        }));\n      };\n      if (isDrawingLine) {\n        requestAnimationFrame(handleDrawLineFrame);\n      }\n    }, [commandToAnimate, isDrawingLine]);\n    ```", "```js\n    import { AnimatedLine } from \"./AnimatedLine\";\n    ```", "```js\n    <AnimatedLine\n      commandToAnimate={commandToAnimate}\n      turtle={turtle}\n    />\n    ```", "```js\n    it(\"does not render AnimatedLine when not moving\", () => {\n      renderWithStore(<Drawing />, {\n        script: { drawCommands: [] }\n      });\n      expect(AnimatedLine).not.toBeRendered();\n    });\n    ```", "```js\n    {isDrawingLine ? (\n      <AnimatedLine\n        commandToAnimate={commandToAnimate}\n        turtle={turtle}\n    /> : null}\n    ```", "```js\n    it(\"renders an AnimatedLine with turtle at a position based on a speed of 5px per ms\", () => {\n      renderWithStore(<Drawing />, horizontalLineDrawn);\n      triggerRequestAnimationFrame(0);\n      triggerRequestAnimationFrame(250);\n      expect(AnimatedLine).toBeRenderedWithProps({\n        commandToAnimate: horizontalLine,\n        turtle: { x: 150, y: 100, angle: 0 }\n      });\n    });\n    ```", "```js\n    const distance = ({ x1, y1, x2, y2 }) =>\n      Math.sqrt(\n        (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)\n      );\n    const movementSpeed = 5;\n    ```", "```js\n    useEffect(() => {\n      let duration;\n      const handleDrawLineFrame = time => {\n        setTurtle(...);\n      };\n      if (isDrawingLine) {\n        duration =\n          movementSpeed * distance(commandToAnimate);\n        requestAnimationFrame(handleDrawLineFrame);\n      }\n    }, [commandToAnimate, isDrawingLine]);\n    ```", "```js\n    useEffect(() => {\n      let duration;\n      const handleDrawLineFrame = time => {\n        const { x1, x2, y1, y2 } = commandToAnimate;\n        setTurtle(turtle => ({\n          ...turtle,\n          x: x1 + ((x2 - x1) * (time / duration)),\n          y: y1 + ((y2 - y1) * (time / duration)),\n        }));\n      };\n      if (isDrawingLine) {\n        ...\n      }\n    }, [commandToAnimate, isDrawingLine]);\n    ```", "```js\n    it(\"calculates move distance with a non-zero animation start time\", () => {\n      const startTime = 12345;\n      renderWithStore(<Drawing />, horizontalLineDrawn);\n      triggerRequestAnimationFrame(startTime);\n      triggerRequestAnimationFrame(startTime + 250);\n      expect(AnimatedLine).toBeRenderedWithProps({\n        commandToAnimate: horizontalLine,\n        turtle: { x: 150, y: 100, angle: 0 }\n      });\n    });\n    ```", "```js\n    useEffect(() => {\n      let start, duration;\n      const handleDrawLineFrame = time => {\n        if (start === undefined) start = time;\n        const elapsed = time - start;\n        const { x1, x2, y1, y2 } = commandToAnimate;\n        setTurtle(turtle => ({\n          ...turtle,\n          x: x1 + ((x2 - x1) * (elapsed / duration)),\n          y: y1 + ((y2 - y1) * (elapsed / duration)),\n        }));\n      };\n      if (isDrawingLine) {\n        ...\n      }\n    }, [commandToAnimate, isDrawingLine]);\n    ```", "```js\n    it(\"invokes requestAnimationFrame repeatedly until the duration is reached\", () => {\n      renderWithStore(<Drawing />, horizontalLineDrawn);\n      triggerRequestAnimationFrame(0);\n      triggerRequestAnimationFrame(250);\n      triggerRequestAnimationFrame(500);\n      expect(\n        window.requestAnimationFrame.mock.calls \n      ).toHaveLength(3);\n    });\n    ```", "```js\n    const handleDrawLineFrame = (time) => {\n      if (start === undefined) start = time;\n      if (time < start + duration) {\n        const elapsed = time - start;\n        const { x1, x2, y1, y2 } = commandToAnimate;\n        setTurtle(...);\n        requestAnimationFrame(handleDrawLineFrame);\n      }\n    };\n    ```", "```js\n    describe(\"after animation\", () => {\n      it(\"animates the next command\", () => {\n        renderWithStore(<Drawing />, {\n          script: {\n            drawCommands: [horizontalLine, verticalLine]\n          }\n        });\n        triggerRequestAnimationFrame(0);\n        triggerRequestAnimationFrame(500);\n        expect(AnimatedLine).toBeRenderedWithProps(\n          expect.objectContaining({\n            commandToAnimate: verticalLine,\n          })\n        );\n      });\n    });\n    ```", "```js\n    const [\n      animatingCommandIndex,\n      setAnimatingCommandIndex\n    ] = useState(0);\n    ```", "```js\n    const commandToAnimate = \n      drawCommands[animatingCommandIndex];\n    ```", "```js\n    if (time < start + duration) {\n      ...\n    } else {\n      setAnimatingCommandIndex(\n        animatingCommandIndex => animatingCommandIndex + 1\n      );\n    }\n    ```", "```js\n    it(\"places line in StaticLines\", () => {\n      renderWithStore(<Drawing />, {\n        script: {\n          drawCommands: [horizontalLine, verticalLine]\n        }\n      });\n      triggerRequestAnimationFrame(0);\n      triggerRequestAnimationFrame(500);\n      expect(StaticLines).toBeRenderedWithProps({ \n        lineCommands: [horizontalLine]\n      });\n    });\n    ```", "```js\n    const lineCommands = drawCommands\n      .slice(0, animatingCommandIndex)\n      .filter(isDrawLineCommand);\n    ```", "```js\n    it(\"calls cancelAnimationFrame on reset\", () => {\n      renderWithStore(<Drawing />, {\n        script: { drawCommands: [horizontalLine] }\n      });\n      renderWithStore(<Drawing />, {\n        script: { drawCommands: [] }\n      });\n      expect(window.cancelAnimationFrame).toBeCalledWith(\n        cancelToken\n      );\n    });\n    ```", "```js\n    describe(\"Drawing\", () => {\n      const cancelToken = \"cancelToken\";\n      beforeEach(() => {\n        ...\n        jest\n          .spyOn(window, \"requestAnimationFrame\")\n          .mockReturnValue(cancelToken);\n        jest.spyOn(window, \"cancelAnimationFrame\");\n      });\n    });\n    ```", "```js\n    useEffect(() => {\n      let start, duration, cancelToken;\n      const handleDrawLineFrame = time => {\n        if (start === undefined) start = time;\n        if (time < start + duration) {\n          ...\n          cancelToken = requestAnimationFrame(\n            handleDrawLineFrame\n          );\n        } else {\n          ...\n        }\n      };\n      if (isDrawingLine) {\n        duration =\n          movementSpeed * distance(commandToAnimate);\n        cancelToken = requestAnimationFrame(\n          handleDrawLineFrame\n        );\n      }\n      return () => {\n        cancelAnimationFrame(cancelToken);\n      }\n    });\n    ```", "```js\n    it(\"does not call cancelAnimationFrame if no line animating\", () => {\n      jest.spyOn(window, \"cancelAnimationFrame\");\n      renderWithStore(<Drawing />, {\n        script: { drawCommands: [] }\n      });\n      renderWithStore(<React.Fragment />);\n      expect(\n        window.cancelAnimationFrame\n      ).not.toHaveBeenCalled();\n    });\n    ```", "```js\n    return () => {\n      if (cancelToken) {\n        cancelAnimationFrame(cancelToken);\n      }\n    };\n    ```", "```js\n    describe(\"rotation animation\", () => {\n      const rotationPerformed = {\n        script: { drawCommands: [rotate90] },\n      };\n      it(\"rotates the turtle\", () => {\n        renderWithStore(<Drawing />, rotationPerformed);\n        triggerRequestAnimationFrame(0);\n        triggerRequestAnimationFrame(500);\n        expect(Turtle).toBeRenderedWithProps({\n          x: 0,\n          y: 0,\n          angle: 90\n        });\n      });\n    });\n    ```", "```js\n    const isRotateCommand = command =>\n      command.drawCommand === \"rotate\";\n    ```", "```js\n    const isRotating =\n      commandToAnimate &&\n        isRotateCommand(commandToAnimate);\n    ```", "```js\n    const handleRotationFrame = time => {\n      setTurtle(turtle => ({\n        ...turtle,\n        angle: commandToAnimate.newAngle\n      }));\n    };\n    ```", "```js\n    useEffect(() => {\n      ...\n      if (isDrawingLine) {\n        ...\n      } else if (isRotating) {\n        requestAnimationFrame(handleRotationFrame);\n      }\n    }, [commandToAnimate, isDrawingLine, isRotating]);\n    ```", "```js\n    it(\"rotates part-way at a speed of 1s per 180 degrees\", () => {\n      renderWithStore(<Drawing />, rotationPerformed);\n      triggerRequestAnimationFrame(0);\n      triggerRequestAnimationFrame(250);\n      expect(Turtle).toBeRenderedWithProps({\n        x: 0,\n        y: 0,\n        angle: 45\n      });\n    });\n    ```", "```js\n    const rotateSpeed = 1000 / 180;\n    ```", "```js\n    } else if (isRotating) {\n      duration =\n        rotateSpeed *\n        Math.abs(\n          commandToAnimate.newAngle -\n            commandToAnimate.previousAngle\n        );\n     requestAnimationFrame(handleRotationFrame);\n    }\n    ```", "```js\n    const handleRotationFrame = (time) => {\n      const {\n        previousAngle, newAngle\n      } = commandToAnimate;\n      setTurtle(turtle => ({\n        ...turtle,\n        angle:\n          previousAngle +\n          (newAngle - previousAngle) * (time / duration)\n      }));\n    };\n    ```", "```js\n    it(\"calculates rotation with a non-zero animation start time\", () => {\n      const startTime = 12345;\n      renderWithStore(<Drawing />, rotationPerformed);\n      triggerRequestAnimationFrame(startTime);\n      triggerRequestAnimationFrame(startTime + 250);\n      expect(Turtle).toBeRenderedWithProps({\n        x: 0,\n        y: 0,\n        angle: 45\n      });\n    });\n    ```", "```js\n    const handleRotationFrame = (time) => {\n      if (start === undefined) start = time;\n      const elapsed = time - start;\n      const {\n       previousAngle, newAngle\n      } = commandToAnimate;\n      setTurtle(turtle => ({\n        ...turtle,\n        angle:\n          previousAngle +\n          (newAngle - previousAngle) *\n          (elapsed / duration)\n      }));\n    };\n    ```", "```js\n    it(\"invokes requestAnimationFrame repeatedly until the duration is reached\", () => {\n      renderWithStore(<Drawing />, rotationPerformed);\n      triggerRequestAnimationFrame(0);\n      triggerRequestAnimationFrame(250);\n      triggerRequestAnimationFrame(500);\n      expect(\n        window.requestAnimationFrame.mock.calls \n      ).toHaveLength(3);\n    });\n    ```", "```js\n    const handleRotationFrame = (time) => {\n      if (start === undefined) start = time;\n      if (time < start + duration) {\n        ...\n      } else {\n        setTurtle(turtle => ({\n          ...turtle,\n          angle: commandToAnimate.newAngle\n        }));\n      }\n    };\n    ```", "```js\n    it(\"animates the next command once rotation is complete\", async () => {\n      renderWithStore(<Drawing />, {\n        script: {\n          drawCommands: [rotate90, horizontalLine]\n        }\n      });\n      triggerRequestAnimationFrame(0);\n      triggerRequestAnimationFrame(500);\n      triggerRequestAnimationFrame(0);\n      triggerRequestAnimationFrame(250);\n      expect(Turtle).toBeRenderedWithProps({\n        x: 150,\n        y: 100,\n        angle: 90\n      });\n    });\n    ```", "```js\n    } else {\n      setTurtle(turtle => ({\n        ...turtle,\n        angle: commandToAnimate.newAngle\n      }));\n      setAnimatingCommandIndex(\n        (animatingCommandToIndex) =>\n          animatingCommandToIndex + 1\n      );\n    }\n    ```"]