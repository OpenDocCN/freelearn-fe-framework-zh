- en: <st c="0">4</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4<st c="0"></st>
- en: <st c="2">Mocking and Stubbing Dependencies in Angular Tests</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Angular 测试中模拟和存根依赖<st c="2"></st>
- en: <st c="52">To write effective and reliable tests for Angular applications, it’s
    essential to understand how to handle dependencies.</st> <st c="174">Dependencies
    can often introduce complexity and make testing difficult.</st> <st c="246">However,
    by taking advantage of techniques such as mocking and stubbing, we can better
    control our tests and ensure the accuracy and stability of</st> <st c="392">our
    application.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为 Angular 应用编写有效和可靠的测试，理解如何处理依赖是至关重要的。<st c="52"></st>依赖通常会增加复杂性并使测试变得困难。<st
    c="174">然而，通过利用模拟和存根等技术，我们可以更好地控制我们的测试并确保应用程序的准确性和稳定性。<st c="246"></st> <st c="392"></st>
- en: <st c="408">In this chapter, we’ll explore the concept of spies and method substitutes.</st>
    <st c="485">Spies allow us to monitor and verify the behavior of dependencies
    during testing.</st> <st c="567">We’ll learn how to create spies using the Jasmine
    test framework and use them to find out whether certain methods have been called,
    how many times they’ve been called, and with what parameters.</st> <st c="761">In
    addition, we’ll discover the power of method substitutes, which allow us to replace
    the implementation of a method with our own</st> <st c="892">custom logic.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨间谍和方法替代的概念。<st c="408"></st> <st c="485">间谍允许我们在测试期间监控和验证依赖的行为。<st
    c="567">我们将学习如何使用 Jasmine 测试框架创建间谍，并使用它们来找出某些方法是否被调用，它们被调用了多少次，以及调用时使用了什么参数。<st
    c="761">此外，我们还将发现方法替代的力量，它允许我们用自己的自定义逻辑替换方法的实现。<st c="892"></st>
- en: <st c="905">Next, we’ll take a look at</st> `<st c="933">TestBed</st>` <st c="940">providers
    and how they allow us to inject simulated dependencies into our tests.</st> <st
    c="1022">TestBed is a powerful Angular testing utility that allows us to create
    a test module and configure it with the necessary dependencies.</st> <st c="1157">We’re
    going to learn how to create and configure</st> <st c="1206">TestBed providers
    to replace real dependencies with simulated versions.</st> <st c="1278">This technique
    allows us to isolate the component or service under test and control the behavior
    of</st> <st c="1378">its dependencies.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看 TestBed 提供者和它们如何允许我们将模拟依赖注入到测试中。<st c="905"></st> `<st c="933">TestBed</st>`
    <st c="940">提供者允许我们创建一个测试模块，并使用必要的依赖来配置它。<st c="1022">TestBed 是一个强大的 Angular 测试实用工具，它允许我们创建一个测试模块，并使用必要的依赖来配置它。<st
    c="1157">我们将学习如何创建和配置 TestBed 提供者，用模拟版本替换真实依赖。<st c="1206"></st> <st c="1278">这种技术允许我们将测试的组件或服务隔离出来，并控制其依赖的行为。</st>
- en: <st c="1395">Finally, we’ll explore how to handle asynchronous operations and
    complex scenarios when setting up dependencies.</st> <st c="1509">We’ll discover
    the</st> `<st c="1528">async</st>` <st c="1533">and</st> `<st c="1538">fakeAsync</st>`
    <st c="1547">utilities provided by the Angular testing framework and see how to
    use them to manage asynchronous code in our tests.</st> <st c="1666">In addition,
    we’ll discuss strategies for handling complex scenarios, such as dependencies
    with multiple methods or dependencies that require specific</st> <st c="1817">initialization
    steps.</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨在设置依赖时如何处理异步操作和复杂场景。<st c="1395"></st> <st c="1509">我们将发现 Angular 测试框架提供的
    `<st c="1528">async</st>` <st c="1533">和 `<st c="1538">fakeAsync</st>` <st c="1547">实用工具，并了解如何使用它们来管理测试中的异步代码。<st
    c="1666">此外，我们还将讨论处理复杂场景的策略，例如具有多个方法的依赖或需要特定初始化步骤的依赖。</st>
- en: <st c="1838">In summary, here are the main topics that will be covered in</st>
    <st c="1900">this chapter:</st>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本章将涵盖以下主要主题：<st c="1838"></st> <st c="1900"></st>
- en: <st c="1913">Monitoring and controlling dependency calls using method stubs</st>
    <st c="1977">and stubs</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法存根和存根来监控和控制依赖调用<st c="1913"></st> <st c="1977"></st>
- en: <st c="1986">Injecting mocked dependencies using</st> <st c="2023">TestBed providers</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TestBed 提供者注入模拟依赖<st c="1986"></st> <st c="2023"></st>
- en: <st c="2040">Handling async operations and</st> <st c="2071">complex scenarios</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异步操作和复杂场景<st c="2040"></st> <st c="2071"></st>
- en: <st c="2088">Technical requirements</st>
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求<st c="2088"></st>
- en: <st c="2111">To follow along with the examples and exercises in this chapter,
    you will need to have a basic understanding of Angular and TypeScript.</st> <st
    c="2248">You will also need</st> <st c="2267">the following:</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章中的示例和练习，你需要对 Angular 和 TypeScript 有基本的了解。<st c="2111"></st>你还需要以下内容：<st
    c="2248"></st> <st c="2267"></st>
- en: <st c="2281">Node.js and npm installed on</st> <st c="2311">your computer</st>
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的计算机上安装了Node.js和npm
- en: <st c="2324">Angular CLI</st> <st c="2337">installed globally</st>
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局安装了Angular CLI
- en: <st c="2355">A code editor, such as Visual Studio Code, installed on</st> <st
    c="2412">your computer</st>
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的计算机上安装了代码编辑器，例如Visual Studio Code
- en: <st c="2425">The code files of this chapter can be found</st> <st c="2470">at</st>
    [<st c="2473">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%204</st>](https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%204)<st
    c="2571">.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%204](https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%204)找到。
- en: <st c="2572">Monitoring and controlling dependency calls using method stubs
    and spies</st>
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用方法占位符和间谍监控和控制依赖调用
- en: <st c="2645">One crucial aspect</st> <st c="2664">of testing</st> <st c="2676">in
    Angular applications is the ability to monitor and control dependency calls.</st>
    <st c="2756">Dependencies are external resources or services that a piece of code
    relies on to function correctly.</st> <st c="2858">Monitoring and controlling
    these dependency calls allows developers to ensure that their code interacts correctly
    with external systems and handles different</st> <st c="3016">scenarios gracefully.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular应用程序的测试中，一个关键方面是能够监控和控制依赖调用。依赖项是代码正确运行所依赖的外部资源或服务。监控和控制这些依赖调用允许开发者确保他们的代码与外部系统正确交互，并优雅地处理不同的场景。
- en: <st c="3037">Spies and method stubs are two powerful techniques within Angular’s
    testing framework that enable developers to achieve this level of control.</st>
    <st c="3181">Spies allow developers to monitor function calls, record information
    about those calls, and assert expectations about their usage.</st> <st c="3312">On
    the other hand, method stubs provide a way to replace real dependencies with simplified
    versions, allowing developers to control the behavior of those dependencies</st>
    <st c="3479">during testing.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍和方法占位符是Angular测试框架中的两种强大技术，使开发者能够实现这种程度的控制。间谍允许开发者监控函数调用，记录有关这些调用的信息，并断言对其使用的期望。另一方面，方法占位符提供了一种用简化版本替换真实依赖的方法，允许开发者在测试期间控制这些依赖的行为。
- en: <st c="3494">By using spies, developers can verify that the correct functions
    are called with the right parameters and that they are called the expected number
    of times.</st> <st c="3652">This is particularly useful when testing code that
    interacts with external APIs or databases</st><st c="3744">. Method stubs, on
    the other hand, enable developers to simulate different scenarios and provide
    predefined responses to method calls.</st> <st c="3879">This allows for thorough
    testing of edge cases and ensures the</st> <st c="3942">code’s robustness.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用间谍，开发者可以验证是否以正确的参数调用了正确的函数，并且它们被调用的次数符合预期。这在测试与外部API或数据库交互的代码时特别有用。另一方面，方法占位符使开发者能够模拟不同的场景，并为方法调用提供预定义的响应。这允许对边缘情况进行彻底的测试，并确保代码的健壮性。
- en: <st c="3960">In this section, we’ll explore the concepts of spies and method
    stubs in the Angular testing framework.</st> <st c="4065">We’ll dive into their
    applications and show their usefulness in monitoring and controlling dependency
    calls.</st> <st c="4174">Still based on our project related to a calculator application,
    we’ll demonstrate how spies and method substitutes can be used to create reliable
    and complete</st> <st c="4333">tests, with</st> <st c="4345">an emphasis on the</st>
    <st c="4364">principles of</st> **<st c="4378">test-driven</st>** **<st c="4390">development</st>**
    <st c="4401">(</st>**<st c="4403">TDD</st>**<st c="4406">).</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Angular测试框架中间谍和方法的占位符概念。我们将深入探讨它们的应用，并展示它们在监控和控制依赖调用中的实用性。仍然基于我们与计算器应用相关的项目，我们将演示如何使用间谍和方法替代品来创建可靠和完整的测试，重点在于**测试驱动开发**（TDD）的原则。
- en: <st c="4409">Method stubs and spies</st>
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法占位符和间谍
- en: <st c="4432">Method stubs, also</st> <st c="4451">known as fake or dummy objects,
    are used to replace real dependencies with simplified versions during testing.</st>
    <st c="4563">By providing predefined responses to method calls, method substitutes
    enable developers to isolate and control the behavior of the code</st> <st c="4699">under
    test.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="4432">方法存根，也</st>` `<st c="4451">被称为模拟或哑对象，在测试期间用来用简化版本替换真实依赖。</st>`
    `<st c="4563">通过提供对方法调用的预定义响应，方法替代表示开发者可以隔离和控制被测试代码的行为</st>` `<st c="4699">。</st>`'
- en: <st c="4710">In the calculator application, let’s consider a scenario in which
    the user performs a division operation with a divisor equal to zero.</st> <st
    c="4846">We want to make sure that the application handles this scenario correctly.</st>
    <st c="4921">By creating a method plug for the divide function, we can simulate
    the divide-by-zero scenario and check that the application displays an appropriate</st>
    <st c="5071">error message.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="4710">在计算器应用程序中，让我们考虑一个用户执行除法操作，除数等于零的场景。</st>` `<st c="4846">我们想要确保应用程序能够正确处理这个场景。</st>`
    `<st c="4921">通过为除法函数创建一个方法插件，我们可以模拟除以零的场景，并检查应用程序是否显示适当的</st>` `<st c="5071">错误消息。</st>`'
- en: <st c="5085">At present, our calculator’s division operation does not handle
    the exception related to division</st> <st c="5184">by zero.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="5085">目前，我们的计算器的除法操作没有处理除以零相关的异常。</st>`'
- en: <st c="5192">In our</st> `<st c="5200">calculator.component.spec.ts</st>` <st
    c="5228">test file, we’re going to add the test that allows us to raise this exception.</st>
    <st c="5308">Since we’re following TDD principles, the test should</st> <st c="5362">fail
    naturally.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`<st c="5192">calculator.component.spec.ts</st>` `<st c="5200">测试文件</st>`
    `<st c="5228">中，我们将添加一个测试，使我们能够引发这个异常。</st>` `<st c="5308">由于我们遵循TDD原则，测试应该</st>`
    `<st c="5362">自然失败。</st>`
- en: <st c="5377">After running our test, we notice that the test has indeed failed,
    as shown in the</st> <st c="5461">following screenshot:</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="5377">运行我们的测试后，我们注意到测试确实失败了，如下面的截图所示：</st>` `<st c="5461">：</st>`'
- en: '![Figure 4.1 – Division-by-zero test case](img/B21146_04_1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 除以零测试用例](img/B21146_04_1.jpg)'
- en: <st c="5745">Figure 4.1 – Division-by-zero test case</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="5745">图4.1 – 除以零测试用例</st>`'
- en: '![Figure 4.2 – Division-by-zero test case failed](img/B21146_04_2.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 除以零测试用例失败](img/B21146_04_2.jpg)'
- en: <st c="6446">Figure 4.2 – Division-by-zero test case failed</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="6446">图4.2 – 除以零测试用例失败</st>`'
- en: <st c="6492">To correct this, we need to update our</st> `<st c="6532">CalculatorService</st>`<st
    c="6549">. In our present scenario, there’s a clever approach to refrain from
    direct interaction with our core service and ensure</st> <st c="6669">that everything
    is operational prior to any such action.</st> <st c="6727">This approach involves
    the utilization of a method</st> <st c="6778">stub concept.</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="6492">为了纠正这个问题，我们需要更新我们的</st>` `<st c="6532">CalculatorService</st>`
    `<st c="6549">。在我们的当前场景中，有一个巧妙的方法可以避免直接与我们的核心服务交互，并确保</st>` `<st c="6669">在采取任何此类行动之前一切正常运作。</st>`
    `<st c="6727">这种方法涉及使用一个方法</st>` `<st c="6778">存根概念。</st>`'
- en: <st c="6791">Basically, we’ll point our</st> `<st c="6819">CalculatorService</st>`
    <st c="6836">ser</st><st c="6840">vice at a fake service that will enable us to
    check the correctness of the logic we want to implement before modifying the service
    itself.</st> <st c="6980">In fact, this fake service will simply be a stub method
    that replaces the classic division of our basic</st> `<st c="7084">CalculatorService</st>`
    <st c="7101">service.</st> <st c="7111">To start with, you’ll need to com</st><st
    c="7144">ment out all the tests linked to other operators in our</st> `<st c="7201">calculator.component.spec.ts</st>`
    <st c="7229">file, if you already have some.</st> <st c="7262">Next, we’ll declare
    this</st> <st c="7287">stub method:</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="6791">基本上，我们将我们的</st>` `<st c="6819">CalculatorService</st>` `<st c="6836">服务</st>`
    `<st c="6840">指向一个模拟服务，这将使我们能够在修改服务本身之前检查我们想要实现的逻辑的正确性。</st>` `<st c="6980">实际上，这个模拟服务将仅仅是一个存根方法，用来替换我们基本</st>`
    `<st c="7084">CalculatorService</st>` `<st c="7101">服务的经典除法。</st>` `<st c="7111">首先，你需要注释掉所有与我们的</st>`
    `<st c="7144">calculator.component.spec.ts</st>` `<st c="7229">文件中其他运算符相关的测试，如果你已经有了的话。</st>`
    `<st c="7262">接下来，我们将声明这个</st>` `<st c="7287">存根方法：</st>`'
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="7446">Then, in the</st> `<st c="7460">describe</st>` <st c="7468">method,
    within the</st> `<st c="7488">configureTestingModule</st>` <st c="7510">method,
    we will replace our</st> `<st c="7539">CalculatorService</st>` <st c="7556">provider
    with</st> <st c="7571">the following:</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7446">然后，在</st> `<st c="7460">描述</st>` <st c="7468">方法中，在</st> `<st c="7488">configureTestingModule</st>`
    <st c="7510">方法内，我们将替换我们的</st> `<st c="7539">CalculatorService</st>` <st c="7556">提供者，如下所示：</st>
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="7666">Finally, here is</st> <st c="7684">the test case for our fake</st>
    `<st c="7711">calculatorServiceStub</st>` <st c="7732">service, which contains
    our stub</st> `<st c="7766">divide</st>` <st c="7772">method:</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7666">最后，这是</st> <st c="7684">我们伪造的</st> `<st c="7711">calculatorServiceStub</st>`
    <st c="7732">服务</st>的测试用例，其中包含我们的</st> `<st c="7766">divide</st>` <st c="7772">方法：</st>
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="8044">Here’s the complete code for implementing our</st> <st c="8091">fake
    service:</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8044">以下是实现我们的</st> <st c="8091">伪造服务</st>的完整代码：</st>
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="9792">Let’s go through</st> <st c="9810">the code.</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9792">让我们看一下</st> `<st c="9810">代码。</st>`
- en: <st c="9819">The</st> `<st c="9824">calculatorServiceStub</st>` <st c="9845">object
    is created to mock the</st> `<st c="9876">divide</st>` <st c="9882">method of
    the</st> `<st c="9897">CalculatorService</st>` <st c="9914">service.</st> <st
    c="9924">The</st> `<st c="9928">divide</st>` <st c="9934">method takes two parameters,</st>
    `<st c="9964">a</st>` <st c="9965">and</st> `<st c="9970">b</st>`<st c="9971">,
    and performs the division operation.</st> <st c="10010">In this case, the stub
    checks whether</st> `<st c="10048">b</st>` <st c="10049">is equal to zero.</st>
    <st c="10068">If it is, an</st> <st c="10081">error is thrown to simulate the</st>
    <st c="10113">division-by-zero scenario.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9819">`<st c="9824">calculatorServiceStub</st>` <st c="9845">对象被创建来模拟</st>
    `<st c="9876">divide</st>` <st c="9882">方法</st>的</st> `<st c="9897">CalculatorService</st>`
    <st c="9914">服务。</st> `<st c="9924">divide</st>` <st c="9934">方法接受两个参数，</st> `<st
    c="9964">a</st>` <st c="9965">和</st> `<st c="9970">b</st>`<st c="9971">，并执行除法操作。</st>
    `<st c="10010">在这种情况下，存根检查</st> `<st c="10048">b</st>` <st c="10049">是否等于零。</st>
    `<st c="10068">如果是，则抛出一个</st> `<st c="10081">错误</st>` <st c="10081">来模拟除以零的场景。</st>
- en: <st c="10139">The last</st> `<st c="10149">expect</st>` <st c="10155">statement
    checks whether the</st> `<st c="10185">result</st>` <st c="10191">property of
    the component is equal to</st> `<st c="10230">'Division by zero'</st>`<st c="10248">.
    This verifies that the error message is correctly displayed when division by</st>
    <st c="10327">zero occurs.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10139">最后的</st> `<st c="10149">expect</st>` <st c="10155">语句检查组件的</st>
    `<st c="10185">result</st>` <st c="10191">属性是否等于</st> `<st c="10230">'Division
    by zero'</st>`<st c="10248">。这验证了当发生除以零时，错误信息被正确显示。</st>
- en: <st c="10339">Notice that our test execution has failed.</st> <st c="10383">This
    is a typing problem, as</st> `<st c="10412">result</st>` <st c="10418">is of the
    type</st> `<st c="10434">number</st>` <st c="10440">and</st> <st c="10445">not</st>
    `<st c="10449">string</st>`<st c="10455">.</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10339">请注意，我们的测试执行已失败。</st> `<st c="10383">这是一个打字错误，因为</st> `<st c="10412">result</st>`
    <st c="10418">是</st> `<st c="10434">number</st>` <st c="10440">类型，而不是</st> `<st
    c="10445">string</st>`<st c="10455">。</st>
- en: <st c="10456">So, we’re going to write the minimum amount of code we need in
    our</st> `<st c="10524">CalculatorComponent</st>` <st c="10543">to solve</st>
    <st c="10553">the problem:</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10456">因此，我们将编写我们</st> `<st c="10524">CalculatorComponent</st>` <st c="10543">中需要的最小代码量来解决</st>
    <st c="10553">问题：</st>
- en: '![Figure 4.3 – Updating the declaration of the result property](img/B21146_04_3.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 更新结果属性的声明](img/B21146_04_3.jpg)'
- en: <st c="10592">Figure 4.3 – Updating the declaration of the result property</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10592">图 4.3 – 更新结果属性的声明</st>
- en: <st c="10652">After running the tests, notice that all the tests have turned
    green, as shown in</st> <st c="10735">our screenshot:</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10652">运行测试后，请注意，所有测试都已变为绿色，如图</st> <st c="10735">我们的截图所示：</st>
- en: '![Figure 4.4 – Division-by-zero test case succeeded](img/B21146_04_4.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 除以零测试用例成功](img/B21146_04_4.jpg)'
- en: <st c="11130">Figure 4.4 – Division-by-zero test case succeeded</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11130">图 4.4 – 除以零测试用例成功</st>
- en: <st c="11179">Now we’re going to refactor, as required by the principles of
    TDD.</st> <st c="11247">We’re going to create a</st> `<st c="11271">stubs</st>`
    <st c="11276">folder in our project’s</st> `<st c="11301">core</st>` <st c="11305">folder
    and create a</st> `<st c="11326">calculator.service.stub.ts</st>` <st c="11352">file</st>
    <st c="11358">in it.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11179">现在我们将按照 TDD 原则的要求进行重构。</st> <st c="11247">我们将在项目的</st> `<st c="11301">core</st>`
    <st c="11305">文件夹中创建一个名为</st> `<st c="11326">stubs</st>` <st c="11376">的文件夹，并在其中创建一个</st>
    `<st c="11352">calculator.service.stub.ts</st>` <st c="11358">文件。</st>
- en: '![Figure 4.5 – calculator.service.stub.ts file arborescence](img/B21146_04_5.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – calculator.service.stub.ts 文件结构](img/B21146_04_5.jpg)'
- en: <st c="11443">Figure 4.5 – calculator.service.stub.ts file arborescence</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11443">图 4.5 – calculator.service.stub.ts 文件结构</st>
- en: <st c="11500">Once the file has</st> <st c="11518">been created, we will move
    the source code of our fake stub-based service from</st> `<st c="11598">calculator.component.spec.ts</st>`
    <st c="11626">into our</st> `<st c="11636">calculator.service.stub.ts</st>` <st
    c="11662">file</st> <st c="11668">like this:</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11500">一旦文件创建完成，我们将把基于模拟的服务的源代码从</st> `<st c="11598">calculator.component.spec.ts</st>`
    <st c="11626">移动到我们的</st> `<st c="11636">calculator.service.stub.ts</st>` <st
    c="11662">文件中</st> <st c="11668">如下：</st>
- en: '![Figure 4.6 – calculator.service.stub.ts code source](img/B21146_04_6.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – calculator.service.stub.ts 代码源](img/B21146_04_6.jpg)'
- en: <st c="11891">Figure 4.6 – calculator.service.stub.ts code source</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11891">图 4.6 – calculator.service.stub.ts 代码源</st>
- en: <st c="11942">Since it’s a service, we’ll be using the dependency injection
    technique, as we’ll see in more detail in the next section.</st> <st c="12065">At
    this stage, here’s what we’ll do in a couple</st> <st c="12113">of steps:</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11942">由于它是一个服务，我们将使用依赖注入技术，正如我们将在下一节中更详细地看到的那样。</st> <st c="12065">在这个阶段，我们将分几个步骤来做：</st>
    <st c="12113">几个步骤：</st>
- en: <st c="12122">Create a class in</st> `<st c="12141">calculator.service.stub.ts</st>`
    <st c="12167">called</st> `<st c="12175">CalculatorServiceStub</st>`<st c="12196">.</st>
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="12122">在</st> `<st c="12141">calculator.service.stub.ts</st>` <st c="12167">中创建一个名为</st>
    `<st c="12175">CalculatorServiceStub</st>`<st c="12196">的类。</st>
- en: <st c="12197">Implement all the operator methods of our</st> <st c="12240">calculator
    application.</st>
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="12197">实现我们</st> <st c="12240">计算器应用程序</st>的所有运算符方法。
- en: <st c="12263">Here’s what</st> <st c="12276">the source code</st> <st c="12292">looks
    like:</st>
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="12263">以下是源代码的</st> <st c="12276">样子：</st>
- en: '[PRE4]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="12631">After updating our fake service, we’ll go into our</st> `<st c="12683">calculator.component.spec.ts</st>`
    <st c="12711">test file to replace the provider</st> <st c="12746">like this:</st>
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="12631">在更新我们的模拟服务后，我们将进入我们的</st> `<st c="12683">calculator.component.spec.ts</st>`
    <st c="12711">测试文件，以替换提供者</st> <st c="12746">如下：</st>
- en: '[PRE5]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="12925">Now we can uncomment all the methods in our</st> `<st c="12970">calculator.component.spec.ts</st>`
    <st c="12998">file, except</st> <st c="13011">the</st> `<st c="13016">it('should
    display error message for division by zero')</st>` <st c="13071">test case.</st>
    <st c="13083">Notice that all</st> <st c="13099">our tests are green, as shown
    in the</st> <st c="13136">following figure:</st>
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="12925">现在我们可以取消注释我们</st> `<st c="12970">calculator.component.spec.ts</st>`
    <st c="12998">文件中的所有方法，除了</st> <st c="13011">测试用例</st> `<st c="13016">it('should
    display error message for division by zero')</st>` <st c="13071">。</st> <st c="13083">注意，所有</st>
    <st c="13099">我们的测试都是绿色的，如图所示：</st>
- en: '![Figure 4.7 – CalculatorComponent succeeded using CalculatorServiceStub test
    cases](img/B21146_04_7.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 使用 CalculatorServiceStub 测试用例成功测试 CalculatorComponent](img/B21146_04_7.jpg)'
- en: <st c="13646">Figure 4.7 – CalculatorComponent succeeded using CalculatorServiceStub
    test cases</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13646">图 4.7 – 使用 CalculatorServiceStub 测试用例成功测试 CalculatorComponent</st>
- en: <st c="13727">Spies and method stubs are powerful tools in Angular’s testing
    framework that enable developers to monitor and control the behavior of dependencies
    in their applications.</st> <st c="13899">By incorporating these techniques into
    the TDD process, developers can write more comprehensive and reliable tests, ensuring
    the functionality and stability of their Angular applications.</st> <st c="14087">The
    calculator app example illustrates how spies and method stubs can be applied to
    simulate different scenarios and validate the behavior of the code under test.</st>
    <st c="14250">In the next section, we’ll take a closer look at how to inject mocked
    dependencies</st> <st c="14332">using</st> <st c="14339">TestBed providers.</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13727">间谍和方法存根是Angular测试框架中的强大工具，使开发者能够监控和控制其应用程序中依赖项的行为。</st> <st c="13899">通过将这些技术融入TDD过程，开发者可以编写更全面、更可靠的测试，确保其Angular应用程序的功能性和稳定性。</st>
    <st c="14087">计算器应用程序示例说明了间谍和方法存根如何应用于模拟不同场景并验证测试代码的行为。</st> <st c="14250">在下一节中，我们将更详细地探讨如何使用TestBed提供者注入模拟依赖项</st>
    <st c="14332">。</st> <st c="14339">TestBed提供者。</st>
- en: <st c="14357">Injecting mocked dependencies using TestBed providers</st>
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="14357">使用TestBed提供者注入模拟依赖项</st>
- en: <st c="14411">Mocked dependencies</st> <st c="14431">are simplified</st> <st
    c="14447">versions of external services or resources that mimic the behavior of
    the actual dependencies.</st> <st c="14542">By injecting these mocked dependencies
    using TestBed providers, developers can control their behavior during testing,
    ensuring reliable and thorough testing without relying on</st> <st c="14718">external
    systems.</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14411">模拟依赖项</st> <st c="14431">是简化版的外部服务或资源，它们模仿实际依赖项的行为。</st> <st c="14447">通过使用TestBed提供者注入这些模拟依赖项，开发者可以在测试期间控制它们的行为，确保可靠和彻底的测试，而不依赖于</st>
    <st c="14718">外部系统。</st>
- en: <st c="14735">In this section, we will explore the concept of TestBed providers
    in Angular’s testing framework.</st> <st c="14834">We will delve into their applications
    and showcase how they enable developers to inject mocked dependencies into their
    code.</st> <st c="14959">By doing so, we can create isolated and controlled testing
    environments, adhering to the principles</st> <st c="15059">of TDD.</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14735">在本节中，我们将探讨Angular测试框架中TestBed提供者的概念。</st> <st c="14834">我们将深入研究其应用，并展示它们如何使开发者能够将模拟依赖项注入到其代码中。</st>
    <st c="14959">通过这样做，我们可以创建隔离且可控的测试环境，遵循TDD的原则。</st>
- en: <st c="15066">By injecting mocked dependencies using TestBed providers, developers
    can focus on testing specific units of code without worrying about the complexities
    of the actual dependencies.</st> <st c="15248">This approach allows for easier
    debugging, improved test coverage, and better overall</st> <st c="15334">code
    quality.</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15066">通过使用TestBed提供者注入模拟依赖项，开发者可以专注于测试特定的代码单元，而无需担心实际依赖项的复杂性。</st> <st
    c="15248">这种方法使得调试更加容易，提高了测试覆盖率，并提高了整体</st> <st c="15334">代码质量。</st>
- en: <st c="15347">Throughout this section, we will emphasize the principles of TDD
    and demonstrate the usage of TestBed providers in a practical example, using our
    calculator app.</st> <st c="15510">By understanding and utilizing TestBed providers
    effectively, developers can write reliable, maintainable, and thoroughly tested</st>
    <st c="15639">Angular applications.</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15347">在本节中，我们将强调TDD的原则，并通过使用我们的计算器应用程序的实际示例来展示TestBed提供者的使用。</st> <st
    c="15510">通过理解和有效利用TestBed提供者，开发者可以编写可靠、可维护且经过彻底测试的</st> <st c="15639">Angular应用程序。</st>
- en: <st c="15660">Let’s consider adding the ability to calculate the square root
    of a number to our calculator application, while still relying on our</st> `<st
    c="15794">CalculatorService</st>` <st c="15811">service.</st> <st c="15821">In
    this case, we’ll focus on the square root functionality of the</st> <st c="15887">calculator
    application.</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15660">让我们考虑向我们的计算器应用程序添加计算数字平方根的功能，同时仍然依赖于我们的</st> `<st c="15794">CalculatorService</st>`
    <st c="15811">服务。</st> <st c="15821">在这种情况下，我们将专注于计算器应用程序的平方根功能。</st>
- en: <st c="15910">First, we need to create a mock service that mimics the behavior
    of the actual square root service.</st> <st c="16011">We can create a simple class
    that returns predefined square root values for different inputs.</st> <st c="16105">This
    class, named</st> `<st c="16123">MockSquareRootService</st>`<st c="16144">, will
    be created in the</st> `<st c="16169">mocks</st>` <st c="16174">folder, which
    we’ll create at the same arborescence level as the</st> `<st c="16240">stubs</st>`
    <st c="16245">folder, as demonstrated in the</st> <st c="16277">following screenshot:</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15910">首先，我们需要创建一个模拟服务来模拟实际平方根服务的行为。</st> <st c="16011">我们可以创建一个简单的类，为不同的输入返回预定义的平方根值。</st>
    <st c="16105">这个类，命名为</st> `<st c="16123">MockSquareRootService</st>`<st c="16144">，将被创建在</st>
    `<st c="16169">mocks</st>` <st c="16174">文件夹中，我们将在这个文件夹与</st> `<st c="16240">stubs</st>`
    <st c="16245">文件夹相同的层次结构级别创建它，如以下截图所示：</st>
- en: '![Figure 4.8 – mock-square-root.service.mock.ts file arborescence](img/B21146_04_8.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8 – mock-square-root.service.mock.ts文件层次结构](img/B21146_04_8.jpg)'
- en: <st c="16373">Figure 4.8 – mock-square-root.service.mock.ts file arborescence</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16373">图4.8 – mock-square-root.service.mock.ts文件层次结构</st>
- en: <st c="16436">Here’s an example of a mock square</st> <st c="16472">root service:</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16436">这里是一个模拟平方根服务的示例</st> <st c="16472">根服务：</st>
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="16669">Next, we</st> <st c="16679">will</st> <st c="16683">configure
    the test module using TestBed providers to replace the real square root service
    with the simulated version in</st> `<st c="16804">calculator.component.spec.ts</st>`<st
    c="16832">. Here’s an example of how to configure the</st> <st c="16876">test
    module:</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16669">接下来，我们</st> <st c="16679">将</st> <st c="16683">使用TestBed提供者配置测试模块，用模拟版本替换</st>
    `<st c="16804">calculator.component.spec.ts</st>`<st c="16832">中的实际平方根服务。</st>
    <st c="16876">以下是如何配置测试模块的示例：</st>
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="17130">In the preceding code, we provide the</st> `<st c="17169">CalculatorService</st>`
    <st c="17186">service token and specify the</st> `<st c="17217">useClass</st>`
    <st c="17225">property with</st> `<st c="17240">MockSquareRootService</st>` <st
    c="17261">service.</st> <st c="17271">This configuration tells TestBed to use
    the mock service whenever the code under test requests an instance of the actual
    square</st> <st c="17399">root service.</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17130">在前面的代码中，我们提供了</st> `<st c="17169">CalculatorService</st>` <st
    c="17186">服务令牌，并使用</st> `<st c="17217">useClass</st>` <st c="17225">属性指定了</st>
    `<st c="17240">MockSquareRootService</st>` <st c="17261">服务。</st> <st c="17271">此配置告诉TestBed，当测试代码请求实际平方根服务的实例时，使用模拟服务。</st>
- en: <st c="17412">Now, when we run our tests for the calculator app, any code that
    depends on the square root service will receive an instance of the mocked service.</st>
    <st c="17561">We can control the behavior of the service during testing, ensuring
    that the calculator app correctly performs square root calculations under different
    scenarios.</st> <st c="17724">Here’s some example code for the</st> `<st c="17757">MockSquareRootService</st>`
    <st c="17778">service that mimics the behavior of the</st> `<st c="17819">CalculatorService</st>`
    <st c="17836">service</st> <st c="17845">by</st> <st c="17848">returning predefined
    square root values for</st> <st c="17892">different inputs:</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17412">现在，当我们为计算器应用程序运行测试时，任何依赖于平方根服务的代码都将接收到模拟服务的实例。</st> <st c="17561">我们可以在测试期间控制服务的行为，确保计算器应用程序在不同场景下正确执行平方根计算。</st>
    <st c="17724">以下是一个</st> `<st c="17757">MockSquareRootService</st>` <st c="17778">服务的示例代码，该服务通过为不同的输入返回预定义的平方根值来模拟</st>
    `<st c="17819">CalculatorService</st>` <st c="17836">服务的行为</st> <st c="17845">，如下所示：</st>
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="18215">Let’s finish writing our test on the square roots of numbers by
    adding this sequence to our test</st> <st c="18313">file,</st> `<st c="18319">calculator.component</st><st
    c="18339">.spec.ts</st>`<st c="18347">:</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18215">让我们通过将此序列添加到我们的测试</st> <st c="18313">文件中，</st> `<st c="18319">calculator.component</st><st
    c="18339">.spec.ts</st>`<st c="18347">，来完成对数字平方根的测试编写：</st>
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="18594">To make it functional, you need to add the</st> `<st c="18638">squareRoot()</st>`
    <st c="18650">method to</st> `<st c="18661">calculator.component.ts</st>` <st
    c="18684">and</st> `<st c="18689">calculator.service.ts</st>`<st c="18710">. I
    won’t do this in the current project, as the aim is to show how to set up a</st>
    <st c="18790">mock briefly.</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18594">为了使其功能正常，您需要将</st> `<st c="18638">squareRoot()</st>` <st c="18650">方法添加到</st>
    `<st c="18661">calculator.component.ts</st>` <st c="18684">和</st> `<st c="18689">calculator.service.ts</st>`<st
    c="18710">中。我不会在当前项目中这样做，因为目的是简要展示如何设置模拟。</st>
- en: <st c="18803">TestBed providers in Angular allow you to inject mocked dependencies
    into your tests.</st> <st c="18890">This is a</st> <st c="18900">powerful</st>
    <st c="18909">feature that enables you to control the behavior of external dependencies
    and isolate the code</st> <st c="19004">under test.</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18803">Angular 中的 TestBed 提供者允许您将模拟依赖项注入到测试中。</st> <st c="18890">这是一个</st>
    <st c="18900">强大的</st> <st c="18909">功能，它使您能够控制外部依赖项的行为并隔离待测试的代码。</st>
- en: <st c="19015">When configuring the testing module using</st> `<st c="19058">TestBed.configureTestingModule</st>`<st
    c="19088">, you can provide a list of providers that specify the tokens for the
    dependencies you want to mock.</st> <st c="19189">You can then use either the</st>
    `<st c="19217">useClass</st>` <st c="19225">or</st> `<st c="19229">useValue</st>`
    <st c="19237">property to provide a mock or stub implementation for</st> <st c="19292">each
    dependency.</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19015">当使用</st> `<st c="19058">TestBed.configureTestingModule</st>`<st
    c="19088">配置测试模块时，您可以提供一个提供者列表，指定您想要模拟的依赖项的令牌。</st> <st c="19189">然后，您可以使用</st>
    `<st c="19217">useClass</st>` <st c="19225">或</st> `<st c="19229">useValue</st>`
    <st c="19237">属性为每个依赖项提供一个模拟或存根实现。</st>
- en: <st c="19308">By providing a mock implementation, you can define the behavior
    of the dependency during testing.</st> <st c="19407">This allows you to simulate
    different scenarios and control the return values or error conditions of the dependency.</st>
    <st c="19524">You can also verify the interaction between the code under test
    and the dependency by using spies or other</st> <st c="19631">testing techniques.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19308">通过提供模拟实现，您可以在测试期间定义依赖项的行为。</st> <st c="19407">这允许您模拟不同的场景并控制依赖项的返回值或错误条件。</st>
    <st c="19524">您还可以通过使用间谍或其他</st> <st c="19631">测试技术来验证待测试代码与依赖项之间的交互。</st>
- en: <st c="19650">Injecting mocked dependencies using TestBed providers helps to
    improve the reliability and stability of your tests.</st> <st c="19767">It allows
    you to focus on testing the specific functionality of your code without relying
    on the actual implementation of external dependencies.</st> <st c="19912">This
    makes your tests more deterministic and less prone to failures caused by changes
    in the behavior of</st> <st c="20017">the dependencies.</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19650">使用 TestBed 提供者注入模拟依赖项有助于提高测试的可靠性和稳定性。</st> <st c="19767">它允许您专注于测试代码的特定功能，而不依赖于外部依赖项的实际实现。</st>
    <st c="19912">这使得您的测试更加确定，并且不太可能因依赖项行为的变化而失败。</st>
- en: <st c="20034">Overall, TestBed providers provide a convenient way to inject
    mocked dependencies into your Angular tests.</st> <st c="20142">They allow you
    to control the behavior of external dependencies and isolate the code under test,
    resulting in more reliable and focused tests.</st> <st c="20285">We’ll be taking
    a hands-on approach in the chapters to come.</st> <st c="20346">The aim here is
    to understand the relevance of asynchronous</st> <st c="20406">tasks and</st>
    <st c="20416">why we need to be careful when implementing tests about them.</st>
    <st c="20478">In the next section, we will manage asynchronous operations and</st>
    <st c="20542">complex scenarios.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20034">总的来说，TestBed 提供者提供了一种方便的方法将模拟依赖项注入到您的 Angular 测试中。</st> <st c="20142">它们允许您控制外部依赖项的行为并隔离待测试的代码，从而实现更可靠和专注的测试。</st>
    <st c="20285">在接下来的章节中，我们将采取动手实践的方法。</st> <st c="20346">本节的目标是理解异步任务的相关性以及为什么在实现关于它们的测试时需要小心。</st>
    <st c="20406">在下一节中，我们将管理异步操作和</st> <st c="20416">复杂场景。</st>
- en: <st c="20560">Handling async operations and complex scenarios</st>
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="20560">处理异步操作和复杂场景</st>
- en: <st c="20608">Testing asynchronous</st> <st c="20630">operations and complex
    scenarios is a crucial part of ensuring the reliability and functionality of modern
    software applications.</st> <st c="20760">In today’s software development landscape,
    applications often rely on asynchronous operations, such as promises and observables,
    to handle data fetching, processing, and user interactions.</st> <st c="20949">Additionally,
    complex scenarios, involving intricate workflows, conditional logic, and multiple
    dependencies, need to be thoroughly tested to ensure the application behaves as
    expected in</st> <st c="21137">various scenarios.</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20608">测试异步操作和复杂场景是确保现代软件应用程序可靠性和功能性的关键部分。</st> <st c="20630">在当今的软件开发领域，应用程序通常依赖于异步操作（如承诺和可观察者）来处理数据获取、处理和用户交互。</st>
    <st c="20760">此外，涉及复杂工作流程、条件逻辑和多个依赖关系的复杂场景需要彻底测试，以确保应用程序在各种场景下都能按预期行为。</st> <st
    c="20949">此外，涉及复杂工作流程、条件逻辑和多个依赖关系的复杂场景需要彻底测试，以确保应用程序在各种场景下都能按预期行为。</st> <st c="21137">此外，涉及复杂工作流程、条件逻辑和多个依赖关系的复杂场景需要彻底测试，以确保应用程序在各种场景下都能按预期行为。</st>
- en: <st c="21155">Testing these asynchronous operations and complex scenarios requires
    the use of specialized techniques and tools to handle the unique challenges they
    present.</st> <st c="21315">In the context of Angular, a popular JavaScript framework,
    developers have access to a comprehensive testing framework that provides powerful
    utilities for testing</st> <st c="21479">such scenarios.</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21155">测试这些异步操作和复杂场景需要使用专门的技巧和工具来处理它们所提出的独特挑战。</st> <st c="21315">在 Angular（一个流行的
    JavaScript 框架）的上下文中，开发者可以访问一个全面的测试框架，该框架提供了强大的实用工具来测试</st> <st c="21479">此类场景。</st>
- en: <st c="21494">In this section, we will explore the importance of testing asynchronous
    operations, such as promises and observables, and complex scenarios in Angular
    applications.</st> <st c="21660">We will delve into various techniques and best
    practices for effectively testing these scenarios, ensuring reliable and comprehensive</st>
    <st c="21794">test coverage.</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨在 Angular 应用程序中测试异步操作（如承诺和可观察者）以及复杂场景的重要性。<st c="21660">我们将深入研究各种技术和最佳实践，以确保有效地测试这些场景，从而实现可靠和全面的测试覆盖率。</st>
- en: <st c="21808">Understanding asynchronous operations</st>
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="21808">理解异步操作</st>
- en: <st c="21846">Asynchronous</st> <st c="21860">operations are tasks that can
    be executed independently of the main program flow.</st> <st c="21942">They are
    typically used to handle time-consuming operations, such as network requests,
    file I/O, or database queries.</st> <st c="22060">Instead of waiting for these
    operations to complete, the program can continue executing other tasks, improving
    overall performance</st> <st c="22191">and responsiveness.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21846">异步操作</st>是可以在主程序流程之外独立执行的任务。<st c="21860">它们通常用于处理耗时操作，如网络请求、文件
    I/O 或数据库查询。</st> <st c="21942">而不是等待这些操作完成，程序可以继续执行其他任务，从而提高整体性能</st> <st c="22191">和响应性。</st>
- en: <st c="22210">One common approach to handling asynchronous operations is through
    callbacks.</st> <st c="22289">A callback is a function that is passed to another
    function as an argument and executed once the asynchronous operation is complete.</st>
    <st c="22422">This allows us to define what should happen after the operation
    finishes.</st> <st c="22496">However, managing callbacks can lead to callback
    hell, making the code hard to read and maintain.</st> <st c="22594">To solve this
    problem,</st> `<st c="22617">promises</st>` <st c="22625">were born.</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22210">处理异步操作的一种常见方法是通过回调。</st> <st c="22289">回调是一个函数，它作为参数传递给另一个函数，并在异步操作完成后执行。</st>
    <st c="22422">这允许我们定义操作完成后应该发生什么。</st> <st c="22496">然而，管理回调可能导致回调地狱，使代码难以阅读和维护。</st>
    <st c="22594">为了解决这个问题，</st> `<st c="22617">承诺</st>` <st c="22625">应运而生。</st>
- en: <st c="22636">Promises provide a more structured way to handle asynchronous
    operations.</st> <st c="22711">A promise represents the eventual completion or
    failure of an asynchronous operation and allows us to attach callbacks to handle
    these outcomes.</st> <st c="22856">Promises offer a more readable and maintainable
    way to work with asynchronous code by chaining methods,</st> <st c="22959">such
    as</st> `<st c="22968">.then()</st>` <st c="22975">and</st> `<st c="22980">.catch()</st>`<st
    c="22988">.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22636">承诺提供了一种更结构化的方式来处理异步操作。</st> <st c="22711">承诺表示异步操作最终完成或失败，并允许我们附加回调来处理这些结果。</st>
    <st c="22856">通过链式方法（如</st> <st c="22968">.then()</st> <st c="22975">和</st> <st
    c="22980">.catch()</st>）<st c="22988">，承诺提供了一种更易于阅读和维护的方式来处理异步代码。</st>
- en: <st c="22989">However, a new way of implementing promises has been introduced
    in new versions of JavaScript.</st> `<st c="23085">async</st>`<st c="23090">/</st>`<st
    c="23092">await</st>` <st c="23097">is a clean and concise syntax for working
    with asynchronous operations.</st> <st c="23170">It allows us to write asynchronous
    code that looks like synchronous code, making it easier to reason about and maintain.</st>
    <st c="23291">Using the</st> `<st c="23301">async</st>` <st c="23306">keyword,
    we can define functions that can pause and resume execution using the</st> `<st
    c="23386">await</st>` <st c="23391">keyword, which waits for a promise to be resolved</st>
    <st c="23442">or rejected.</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22989">然而，JavaScript新版本中引入了一种新的实现Promise的方法。</st> `<st c="23085">async</st>`<st
    c="23090">/</st>`<st c="23092">await</st>` <st c="23097">是一种简洁的语法，用于处理异步操作。</st>
    <st c="23170">它允许我们编写看起来像同步代码的异步代码，使其更容易推理和维护。</st> <st c="23291">使用</st> `<st
    c="23301">async</st>` <st c="23306">关键字，我们可以定义使用</st> `<st c="23386">await</st>`
    <st c="23391">关键字定义的函数，该关键字等待Promise解决</st> <st c="23442">或拒绝。</st>
- en: <st c="23454">In addition, another</st> <st c="23476">approach to asynchronous
    operations is to pass observables.</st> <st c="23536">Observables are a powerful
    tool for managing data flows and asynchronous operations in reactive programming.</st>
    <st c="23645">They represent a sequence of values that can be observed over time.</st>
    <st c="23713">Observables can output multiple values asynchronously and provide
    a wide range of operators for transforming, filtering, and combining data streams.</st>
    <st c="23862">They are commonly used in frameworks such as Angular to handle events,
    HTTP requests, and other asynchronous operations</st> <st c="23982">with RxJS.</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23454">此外，另一种实现异步操作的方法是传递可观察对象。</st> <st c="23476">可观察对象是管理响应式编程中数据流和异步操作的有力工具。</st>
    <st c="23645">它们代表随时间观察到的值序列。</st> <st c="23713">可观察对象可以异步输出多个值，并提供一系列用于转换、过滤和组合数据流的操作符。</st>
    <st c="23862">它们在Angular等框架中常用，用于处理事件、HTTP请求和其他使用RxJS的异步操作</st> <st c="23982">。</st>
- en: <st c="23992">Asynchronous operations and observables also enable concurrency
    and parallelism in our code.</st> <st c="24086">Concurrency refers to the ability
    to execute multiple tasks at the same time, while parallelism</st> <st c="24182">refers
    to executing tasks simultaneously across multiple processors or threads.</st>
    <st c="24262">Asynchronous programming and observables allow us to handle multiple
    operations concurrently, improving performance in applications that require heavy
    computation</st> <st c="24425">or I/O.</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23992">异步操作和可观察对象也使我们的代码能够实现并发和并行。</st> <st c="24086">并发指的是同时执行多个任务的能力，而并行</st>
    <st c="24182">则是指在多个处理器或线程上同时执行任务。</st> <st c="24262">异步编程和可观察对象使我们能够并发处理多个操作，从而提高需要大量计算</st>
    <st c="24425">或I/O的应用程序的性能。</st>
- en: <st c="24432">Handling asynchronous operations</st>
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="24432">处理异步操作</st>
- en: <st c="24465">Let’s consider that our</st> <st c="24490">calculator application
    that performs addition, subtraction, multiplication, and division now has a service
    that performs these operations and returns the result as</st> <st c="24654">an
    observable.</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="24465">让我们考虑一下，我们的</st> <st c="24490">计算器应用程序，它执行加法、减法、乘法和除法操作，现在有一个执行这些操作并将结果作为</st>
    `<st c="24654">可观察对象返回的服务。</st>` '
- en: <st c="24668">First, let’s assume we have another calculator service called</st>
    `<st c="24731">CalculatorAsyncService</st>`<st c="24753">, which we’ll create
    in the</st> `<st c="24781">services</st>` <st c="24789">folder.</st> <st c="24798">We
    need to execute this command line in the terminal once in the</st> `<st c="24863">services</st>`
    <st c="24871">folder:</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24668">首先，假设我们还有一个名为</st> `<st c="24731">CalculatorAsyncService</st>`<st
    c="24753">的计算器服务，我们将在</st> `<st c="24781">services</st>` <st c="24789">文件夹中创建它。</st>
    <st c="24798">我们需要在</st> `<st c="24863">services</st>` <st c="24871">文件夹中运行以下命令行一次：</st>
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: it('should add two numbers', fakeAsync(() => {
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: it('should add two numbers', fakeAsync(() => {
- en: let result = 0;
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let result = 0;
- en: service.add(1, 2).subscribe((val) => {
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: service.add(1, 2).subscribe((val) => {
- en: result = val;
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = val;
- en: '});'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '});'
- en: expect(result).toBe(3);
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: expect(result).toBe(3);
- en: '}));'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '}));'
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: it('should add two numbers', fakeAsync(() => {
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: it('should add two numbers', fakeAsync(() => {
- en: let result = 0;
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let result = 0;
- en: 'service.add(1, 2).subscribe((val: number) => {'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'service.add(1, 2).subscribe((val: number) => {'
- en: result = val;
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = val;
- en: '});'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '});'
- en: expect(result).toBe(3);
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: expect(result).toBe(3);
- en: '}));'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '}));'
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'add(a: number, b: number): Observable<number> {'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'add(a: number, b: number): Observable<number> {'
- en: return of(a + b);
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return of(a + b);
- en: '}'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: it('should subtract two numbers', fakeAsync(() => {
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: it('应该减去两个数字', fakeAsync(() => {
- en: let result = 0;
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let result = 0;
- en: 'service.subtract(5, 3).subscribe((val: number) => {'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'service.subtract(5, 3).subscribe((val: number) => {'
- en: result = val;
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = val;
- en: '});'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}));'
- en: expect(result).toBe(2);
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: expect(result).toBe(2);
- en: '}));'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '}));'
- en: it('should multiply two numbers', fakeAsync(() => {
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: it('应该乘以两个数字', fakeAsync(() => {
- en: let result = 0;
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let result = 0;
- en: 'service.multiply(3, 4).subscribe((val: number) => {'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'service.multiply(3, 4).subscribe((val: number) => {'
- en: result = val;
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = val;
- en: '});'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '});'
- en: expect(result).toBe(12);
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: expect(result).toBe(12);
- en: '}));'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '}));'
- en: it('should divide two numbers', fakeAsync(() => {
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: it('应该除以两个数字', fakeAsync(() => {
- en: let result = 0;
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let result = 0;
- en: 'service.divide(10, 2).subscribe((val: number) => {'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'service.divide(10, 2).subscribe((val: number) => {'
- en: result = val;
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = val;
- en: '});'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '});'
- en: expect(result).toBe(5);
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: expect(result).toBe(5);
- en: '}));'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '}));'
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'subtract(a: number, b: number): Observable<number> {'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'subtract(a: number, b: number): Observable<number> {'
- en: return of(a - b);
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return of(a - b);
- en: '}'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'multiply(a: number, b: number): Observable<number> {'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'multiply(a: number, b: number): Observable<number> {'
- en: return of(a * b);
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return of(a * b);
- en: '}'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'divide(a: number, b: number): Observable<number> {'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'divide(a: number, b: number): Observable<number> {'
- en: return of(a / b);
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return of(a / b);
- en: '}'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'it(''should throw an error when dividing by zero'', fakeAsync(() => { let error
    = { message: '''' }; ;'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'it(''当除以零时应该抛出错误'', fakeAsync(() => { let error = { message: '''' }; ;'
- en: service.divide(10, 0).subscribe({
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: service.divide(10, 0).subscribe({
- en: 'error: (err) => (error = err),'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'error: (err) => (error = err),'
- en: '});'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '});'
- en: expect(error).toBeTruthy();
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: expect(error).toBeTruthy();
- en: expect(error.message).toBe('Cannot divide by zero');
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: expect(error.message).toBe('Cannot divide by zero');
- en: '}));'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '}));'
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'divide(a: number, b: number): Observable<number> {'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'divide(a: number, b: number): Observable<number> {'
- en: if (b === 0) {
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (b === 0) {
- en: return throwError(() => new Error('Cannot divide by zero'));
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return throwError(() => new Error('Cannot divide by zero'));
- en: '}  return of(a / b).pipe('
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '}  返回(a / b).pipe('
- en: catchError((error) => {
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: catchError((error) => {
- en: return throwError(() => error);
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return throwError(() => error);
- en: '})'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '})'
- en: );
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
