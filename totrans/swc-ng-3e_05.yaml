- en: Getting Started with Angular Components and Directives
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 组件和指令入门
- en: At this point, we're already familiar with the core building blocks that Angular
    provides for the development of single-page applications and the relations between
    them. However, we've touched only the surface by introducing the general idea
    behind Angular's concepts and the basic syntax used for their definition. In this
    chapter, we'll take a deep dive into Angular's components and directives.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经熟悉了 Angular 为单页应用开发提供的核心构建块及其之间的关系。然而，我们只是触及了表面，通过介绍 Angular 概念背后的基本思想和它们定义的基本语法。在本章中，我们将深入探讨
    Angular 的组件和指令。
- en: 'In the following sections, we will cover these topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将涵盖以下主题：
- en: Enforcing separation of concerns with the building blocks that Angular provides
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular 提供的构建块强制执行关注点分离
- en: The appropriate use of directives or components when interacting with the DOM
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 DOM 交互时适当使用指令或组件
- en: Exploring built-in directives and developing custom ones
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索内置指令并开发自定义指令
- en: An in-depth look at components and their templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解组件及其模板
- en: Content projection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容投影
- en: View children versus content children
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图子元素与内容子元素
- en: The component's life cycle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的生命周期
- en: Using template references
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板引用
- en: Configuring Angular's change detection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Angular 的变更检测
- en: The "Hello world!" application in Angular
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 中的 `"Hello world!"` 应用程序
- en: Now, let's build our first `"Hello world!"` application in Angular and TypeScript.
    Before we start, let's set up our environment!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 Angular 和 TypeScript 中构建我们的第一个 `"Hello world!"` 应用程序。在我们开始之前，让我们设置我们的环境！
- en: Setting up our environment
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的环境
- en: The core team of Angular developed a brand new CLI tool for Angular, which allows
    us to bootstrap our applications with a few commands. Although we will introduce
    it in the final chapter, until then, in order to boost our learning experience,
    we will use the code located at [https://github.com/mgechev/switching-to-angular](https://github.com/mgechev/switching-to-angular).
    This repository includes all the examples in this book, in one big application.
    It has all the required dependencies declared in `package.json`, the definition
    of basic gulp tasks, such as the development server, the transpilation of our
    TypeScript code to ECMAScript 5, and live-reload.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的核心团队为 Angular 开发了一个全新的 CLI 工具，它允许我们通过几个命令启动我们的应用程序。尽管我们将在最后一章介绍它，但在那之前，为了增强我们的学习体验，我们将使用位于
    [https://github.com/mgechev/switching-to-angular](https://github.com/mgechev/switching-to-angular)
    的代码。这个仓库包含本书中的所有示例，在一个大应用中。它声明了所有必需的依赖项在 `package.json` 中，定义了基本的 gulp 任务，如开发服务器、将我们的
    TypeScript 代码转换为 ECMAScript 5 的转换，以及实时重新加载。
- en: The code for this book is based on Angular Seed ([https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed)).
    Although the project provides a solid foundation, it may introduce a tooling overhead
    for Angular and TypeScript beginners. Once we get familiar with the fundamentals
    of Angular, I'd strongly recommend that you use the official Angular CLI as a
    starting point for your first project, available at [https://github.com/angular/angular-cli](https://github.com/angular/angular-cli).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码基于 Angular Seed ([https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed))。尽管该项目提供了一个坚实的基础，但它可能为
    Angular 和 TypeScript 初学者引入了工具开销。一旦我们熟悉了 Angular 的基础知识，我强烈建议您使用官方的 Angular CLI
    作为您第一个项目的起点，可在 [https://github.com/angular/angular-cli](https://github.com/angular/angular-cli)
    找到。
- en: In order to set up the `switching-to-angular` project, you'll need Git, Node.js
    v6.x.x or newer, and `npm`, up and running on your computer. If you have an older
    version of Node.js installed, I recommend that you take a look at nvm (the Node.js
    version manager, which is available at [https://github.com/creationix/nvm](https://github.com/creationix/nvm))
    or n ([https://www.npmjs.com/package/n](https://www.npmjs.com/package/n)). Using
    these tools, you'll be able to have multiple versions of Node.js on your machine
    and switch between them with a single command via the command line.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置 `switching-to-angular` 项目，您需要在您的计算机上安装 Git、Node.js v6.x.x 或更高版本，以及 `npm`。如果您安装了较旧的
    Node.js 版本，我建议您查看 nvm（Node.js 版本管理器，可在 [https://github.com/creationix/nvm](https://github.com/creationix/nvm)
    找到）或 n ([https://www.npmjs.com/package/n](https://www.npmjs.com/package/n))。使用这些工具，您将能够在您的计算机上拥有多个
    Node.js 版本，并通过命令行使用单个命令在它们之间切换。
- en: Installing the sample project repository
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装示例项目仓库
- en: 'Let''s start by setting up the `switching-to-angular` project. Open your terminal
    and enter the following commands:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先设置`switching-to-angular`项目。打开你的终端并输入以下命令：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line will clone the `switching-to-angular` project into a directory
    called `switching-to-angular`; after that, we enter into that directory.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将`switching-to-angular`项目克隆到名为`switching-to-angular`的目录中；之后，我们进入该目录。
- en: The last step before being able to run the seed project is to install all the
    required dependencies using `npm`. This step may take a while depending on your
    internet connection, so be patient and do not interrupt it. If you encounter any
    problems, do not hesitate to raise the issues at [https://github.com/mgechev/switching-to-angular/issues](https://github.com/mgechev/switching-to-angular/issues).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够运行种子项目之前，最后一步是使用`npm`安装所有必需的依赖项。这一步可能需要一段时间，这取决于你的网络连接，所以请耐心等待，不要中断它。如果你遇到任何问题，请不要犹豫，在[https://github.com/mgechev/switching-to-angular/issues](https://github.com/mgechev/switching-to-angular/issues)提出问题。
- en: 'The last step left is to start the development server. For this, run the following
    command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是启动开发服务器。为此，运行以下命令：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When the process of the transpilation is completed, your browser will automatically
    open the `http://localhost:5555/dist/dev` URL. You should now see a view similar
    to what is shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当转换过程完成后，你的浏览器将自动打开`http://localhost:5555/dist/dev` URL。你现在应该看到一个类似于以下截图的视图：
- en: '![](img/25fcdd91-0dce-41a0-a4b8-7b3973291b24.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25fcdd91-0dce-41a0-a4b8-7b3973291b24.png)'
- en: Figure 1
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: Using Angular and TypeScript
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular和TypeScript
- en: 'Now, let''s play around with the files we already have. Navigate to the `app/ch5/hello-world`
    directory inside `switching-to-angular`. Then, open `app.ts` and replace its content
    with the following snippet:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们玩一玩我们已有的文件。导航到`switching-to-angular`中的`app/ch5/hello-world`目录。然后，打开`app.ts`并将它的内容替换为以下片段：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s take a look at the code line by line:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看代码：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Initially, we import the `@Component` and `@NgModule` decorators from the `@angular/core`
    module, `BrowserModule` from `@angular/platform-browser` and the `platformBrowserDynamic`
    object from `@angular/platform-browser-dynamic`. Later, we use `@Component` to
    decorate the `App` class. To the `@Component` decorator, we pass an object literal
    where we reference to an external template.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们从`@angular/core`模块导入`@Component`和`@NgModule`装饰器，从`@angular/platform-browser`导入`BrowserModule`，以及从`@angular/platform-browser-dynamic`导入`platformBrowserDynamic`对象。稍后，我们使用`@Component`装饰`App`类。我们将一个对象字面量传递给`@Component`装饰器，其中引用了一个外部模板。
- en: As the next step, we define the view of the component. However, note that in
    this case, we use `templateUrl` instead of simply inlining the template of the
    component.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们定义组件的视图。然而，请注意，在这种情况下，我们使用`templateUrl`而不是简单地内联组件的模板。
- en: Open `app.html` and replace the file's content with `<h1>Hello {{target}}!</h1>`.
    Since we can use a template by both inlining it (with `template`) and setting
    its URL (`templateUrl`), in some sense, the API of the component is similar to
    that of the AngularJS directives.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app.html`并将文件的内容替换为`<h1>Hello {{target}}!</h1>`。由于我们可以通过内联（使用`template`）和设置其URL（`templateUrl`）两种方式使用模板，从某种意义上说，组件的API与AngularJS指令的API相似。
- en: In the last line of the snippet, we bootstrap the application by providing the
    root module.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段的最后一行，我们通过提供根模块来启动应用程序。
- en: 'Now, let''s take a look at `index.html` in order to get a sense of what goes
    on when we start the application:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看`index.html`，以便了解当我们启动应用程序时会发生什么：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that inside the body of the page, we use the `my-app` element with content and
    a text node with the `"Loading..."` value. The `"Loading..."` label will be visible
    until the application gets bootstrapped and the main component gets rendered.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在页面的主体中，我们使用带有内容和值为`"Loading..."`的文本节点的`my-app`元素。在应用程序初始化并渲染主组件之前，`"Loading..."`标签将是可见的。
- en: The `<%= INIT %>` and `<-- inject:js...` template placeholders inject content
    that is specific to individual demos. They are not Angular specific, but instead,
    aim to prevent code duplications in the code samples attached to the book because
    of the shared structure between them. In order to see how this specific HTML file
    has been transformed, open `/dist/dev/ch5/hello-world/index.html`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`<%= INIT %>`和`<-- inject:js...`模板占位符注入针对个别演示的内容。它们不是Angular特定的，而是旨在防止由于它们之间的共享结构而在书籍附带的代码示例中重复代码。为了了解这个特定的HTML文件是如何被转换的，请打开`/dist/dev/ch5/hello-world/index.html`。'
- en: Using Angular directives
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular指令
- en: We have already built our simple `"Hello world!"` app. Now, let's start building
    something that is closer to a real-life application. By the end of this section,
    we'll have a simple application that lists a number of items we need to do and
    greets us at the header of the page.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了简单的`"Hello world!"`应用。现在，让我们开始构建更接近真实应用的东西。在本节结束时，我们将拥有一个简单的应用，列出我们需要完成的任务，并在页面标题处向我们问候。
- en: 'Let''s start by developing the root component. The two modifications from the
    preceding example that we need to make are renaming the `target` property to `name`
    and adding a list of `todos` to the controller definition of the component:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们开发根组件。与前一个示例相比，我们需要进行的两个修改是将`target`属性重命名为`name`，并将`todos`列表添加到组件的控制定义中：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The only thing that is left is updating the template in order to consume the
    provided data. We're already familiar with the `ng-repeat` directive from AngularJS.
    It allows us to loop over a list of items using a microsyntax, which is later
    interpreted by AngularJS.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的事情是更新模板以消费提供的数据。我们已经熟悉了AngularJS中的`ng-repeat`指令。它允许我们使用微语法遍历一个项目列表，该微语法随后被AngularJS解释。
- en: However, the directive doesn't carry enough semantics, so it is hard to build
    tools that perform static code analysis and help us improve our development experience.
    Since the `ng-repeat` directive is quite useful, Angular kept the idea and improved
    it further in order to allow more sophisticated tooling by introducing further
    semantics on top of it. It allows IDEs and text editors to perform better static
    code analysis. Such support will prevent us from making typos in the code we write
    and allow us to have a smoother development experience.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个指令的语义还不够充分，因此很难构建执行静态代码分析并帮助我们改进开发体验的工具。由于`ng-repeat`指令非常有用，Angular保留了这一想法，并通过在其之上引入更多的语义来进一步改进它，以允许更复杂的工具。它允许IDE和文本编辑器执行更好的静态代码分析。这种支持将防止我们在编写的代码中犯拼写错误，并允许我们拥有更流畅的开发体验。
- en: 'In `app.html`, add the following content:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.html`中添加以下内容：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that in Angular version 2.x.y, the framework was using `template` instead
    of `ng-template`. Since the semantics of the `template` element in the context
    of Angular is different compared to its semantics in the context of the HTML standard,
    in version 4 of Angular, the `template` element was deprecated and renamed to
    `ng-template`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Angular 2.x.y版本中，框架使用的是`template`而不是`ng-template`。由于`template`元素在Angular的上下文中的语义与其在HTML标准上下文中的语义不同，在Angular的第四版中，`template`元素被弃用并重命名为`ng-template`。
- en: 'Now, after you refresh your browser, you should see the following result:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你刷新浏览器后，你应该看到以下结果：
- en: '![](img/867d95db-0273-410b-b2f0-cf36cdc47979.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/867d95db-0273-410b-b2f0-cf36cdc47979.png)'
- en: Figure 2
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: So far, so good! The only new things left to expain in the last snippets are
    the attributes of the `ng-template` element that we're not familiar with, such
    as `ngFor`, `let-todo`, and `[ngForOf]`. Let's take a look at them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！在最后的代码片段中，唯一剩下要解释的新特性是`ng-template`元素的一些我们不熟悉的属性，例如`ngFor`、`let-todo`和`[ngForOf]`。让我们来看看它们。
- en: The ngFor directive
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ngFor指令
- en: The `ngFor` directive allows us to loop over a collection of items and not only
    does exactly what `ng-repeat` does in AngularJS, but also brings some extra semantics.
    Notice that the `ngForOf` attribute is surrounded by brackets. At first, these
    brackets may seem like invalid HTML. However, according to the HTML specification,
    their use is permitted in attribute names. The only thing the W3C validator will
    complain about is the fact that the `ng-template` element doesn't own such attributes;
    however, browsers won't have problems processing the markup.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor`指令允许我们遍历一个项目集合，不仅完全实现了AngularJS中的`ng-repeat`的功能，还带来了一些额外的语义。请注意，`ngForOf`属性被括号包围。起初，这些括号可能看起来像是无效的HTML。然而，根据HTML规范，它们在属性名称中使用是允许的。W3C验证器唯一会抱怨的是，`ng-template`元素并不拥有这样的属性；然而，浏览器在处理标记时不会有问题。'
- en: The semantics behind these brackets is that the value of the attribute surrounded
    by them is an expression, which needs to be evaluated.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些括号背后的语义是，它们包围的属性的值是一个表达式，需要被评估。
- en: Improved semantics of the directives syntax
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令语法语义的改进
- en: 'In [Chapter 2](ced71b5c-e25d-4781-8aab-81ef0a053b14.xhtml), *Get Going with
    Angular*, we mentioned the opportunity for improved tooling in Angular. A big
    issue in AngularJS is the different ways in which we can use directives. This
    requires an understanding of the attribute values, which can be literals, expressions,
    callbacks, or a microsyntax. In Angular, this problem is eliminated by introducing
    a few simple conventions that are built into the framework:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ced71b5c-e25d-4781-8aab-81ef0a053b14.xhtml)“开始使用Angular”中，我们提到了在Angular中改进工具的机会。AngularJS的一个大问题是我们可以使用指令的不同方式。这需要理解属性值，这些值可以是字面量、表达式、回调或微语法。在Angular中，通过引入一些简单且内置于框架中的约定来解决这个问题：
- en: '`propertyName="value"`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`propertyName="value"`'
- en: '`[propertyName]="expression"`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[propertyName]="expression"`'
- en: '`(eventName)="handler()"`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(eventName)="handler()"`'
- en: In the first line, the `propertyName` attribute accepts a string literal as
    a value. Angular will not process the attribute's value any further; it will use
    it the way it is set in the template.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，`propertyName`属性接受一个字符串字面量作为值。Angular不会进一步处理属性值；它将以模板中设置的方式使用它。
- en: The second syntax, `[propertyName]="expression"`, gives a hint to Angular that
    the value of the attributes should be handled as an expression. When Angular finds
    an attribute surrounded by brackets, it will interpret the expression in the context
    of the component associated with the template. In short, if we want to set a nonstring
    value or the result of an expression as value of a given property, we will need
    to use this syntax.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种语法`[propertyName]="expression"`向Angular提供了一个提示，即属性的值应该被处理为一个表达式。当Angular发现被括号包围的属性时，它将在与模板关联的组件的上下文中解释该表达式。简而言之，如果我们想要设置一个非字符串值或表达式的结果作为给定属性的值，我们需要使用这种语法。
- en: The previous example shows how we can bind to events. The semantics behind `(eventName)="handler()"`
    is that we want to invoke the `handler()` expression each time when an event with
    the `eventName` name is triggered.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子展示了我们如何绑定到事件。`(eventName)="handler()"`后面的语义是，每当触发具有`eventName`名称的事件时，我们希望调用`handler()`表达式。
- en: We will discuss more examples later in this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论更多示例。
- en: 'Angular provides alternative canonical syntax, which allows us to define the
    bindings of the elements without using brackets. For instance, the property binding
    can be expressed using the following code: `<input [value]="foo">`. It can also
    be expressed using this: `<input bind-value="foo">`. Similarly, we can express
    the event bindings with the following code: `<button (click)="handle()">Click
    me</button>`. They can also be expressed using this: `<button on-click="handle()">Click
    me</button>`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了一个替代的规范语法，允许我们定义元素的绑定而不使用括号。例如，属性绑定可以使用以下代码表示：`<input [value]="foo">`。它也可以用以下方式表示：`<input
    bind-value="foo">`。同样，我们可以使用以下代码表示事件绑定：`<button (click)="handle()">Click me</button>`。它们也可以用以下方式表示：`<button
    on-click="handle()">Click me</button>`。
- en: Declaring variables inside a template
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模板内部声明变量
- en: The final thing left from the preceding template is the `let-todo` attribute.
    Using this syntax, we are telling Angular that we want to declare a new variable
    called `todo` and bind it to the individual items from the collection we get from
    the evaluation of the expression set as the value of `[ngForOf]`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个模板留下的最后一件事是`let-todo`属性。使用这种语法，我们告诉Angular我们想要声明一个名为`todo`的新变量，并将其绑定到从评估设置为`[ngForOf]`值的表达式所得到的集合中的各个项。
- en: Using syntax sugar in templates
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模板中使用语法糖
- en: Although the template syntax gives meaning of the code to the IDEs or text editors
    we use, it is quite verbose. Angular provides an alternative syntax, which will
    be desugared to the one shown in the preceding snippet.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模板语法给我们所使用的IDE或文本编辑器提供了代码的意义，但它相当冗长。Angular提供了一个替代语法，它将被转换为前面片段中显示的语法。
- en: 'There are a few Angular directives that require a `ng-template` element, for
    example, `ngForOf`, `ngIf`, and `ngSwitch`. Since such directives are used often,
    there''s an alternative syntax for them. Instead of typing the entire `ng-template`
    element explicitly, we can simply prefix the directive with `*`. This will allow
    us to change our `ngForOf` directive syntax usage as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些Angular指令需要`ng-template`元素，例如`ngForOf`、`ngIf`和`ngSwitch`。由于这些指令经常使用，因此存在它们的替代语法。我们不需要显式地键入整个`ng-template`元素，只需在指令前加上`*`前缀即可。这将允许我们更改`ngForOf`指令的语法使用，如下所示：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Later, this template will be desugared by Angular to the more verbose syntax
    described earlier. Since the less verbose syntax is easier to read and write,
    its use is considered as the best practice.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，Angular 将这个模板转换为前面描述的更冗长的语法。由于更简洁的语法更容易阅读和编写，其使用被认为是最佳实践。
- en: The `*` character allows us to remove the `ng-template` element and put the
    directive directly on the top-level child element of the `ng-template` element
    (in the previous example, the `li` list item).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 字符允许我们移除 `ng-template` 元素，并将指令直接放在 `ng-template` 元素的顶级子元素上（在先前的示例中，是 `li`
    列表项）。'
- en: Defining Angular directives
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 Angular 指令
- en: Now that we've built a simple Angular component, let's continue our journey
    by understanding the Angular directives.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了一个简单的 Angular 组件，让我们继续我们的旅程，通过理解 Angular 指令来继续前进。
- en: Using Angular directives, we can apply different behavioral or structural changes
    over the DOM. In this example, we will build a simple tooltip directive.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular 指令，我们可以在 DOM 上应用不同的行为或结构变化。在这个例子中，我们将构建一个简单的提示指令。
- en: In contrast to components, directives do not have templates. Another core difference
    between these two concepts is that the given HTML element may have only a single
    component, but multiple directives on it. In other words, directives augment the
    elements compared to components that are the actual elements in our views.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与组件相比，指令没有模板。这两个概念之间的另一个核心区别是，给定的 HTML 元素可能只有一个组件，但可以有多个指令。换句话说，与实际元素相比，指令增强了元素。
- en: 'Angular''s official style guide recommends using directives as attributes,
    prefixed with a namespace. Keeping this in mind, we will use the tooltip directive
    in the following way:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的官方风格指南建议使用带有命名空间的指令作为属性。考虑到这一点，我们将在以下方式中使用提示指令：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding snippet, we use the tooltip directive over the `div` element.
    As a namespace, its selector uses the `sa` string.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的片段中，我们在 `div` 元素上使用了提示指令。作为一个命名空间，其选择器使用 `sa` 字符串。
- en: Since the focus of the book is an efficient and intuitive learning of Angular's
    concepts, the code snippets may not completely align with the Angular style guide.
    However, for production applications, following best practices is essential. You
    can find the official Angular style guide at [https://angular.io/styleguide](https://angular.io/styleguide).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的重点是高效直观地学习 Angular 的概念，代码片段可能不完全符合 Angular 风格指南。然而，对于生产应用程序，遵循最佳实践是至关重要的。您可以在
    [https://angular.io/styleguide](https://angular.io/styleguide) 找到官方 Angular 风格指南。
- en: 'Now, let''s develop a tooltip directive! Before implementing it, we need to
    import a couple of symbols from `@angular/core`. Open a new TypeScript file called
    `app.ts` and enter the following content; we''ll fill the placeholders later:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开发一个提示指令！在实现它之前，我们需要从 `@angular/core` 中导入几个符号。打开一个名为 `app.ts` 的新 TypeScript
    文件，并输入以下内容；我们稍后会填充占位符：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding line, we import the following definitions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行中，我们导入了以下定义：
- en: '`ElementRef`: This allows us to inject the element reference (we''re not limited
    to the DOM only) to the host element of the directive. In the sample usage of
    the preceding tooltip, as `ElementRef`, we will get an Angular wrapper of the
    `div` element, which holds the `saTooltip` attribute.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ElementRef`: 这允许我们将元素引用（我们不仅限于 DOM）注入到指令的宿主元素中。在先前的示例用法中，作为 `ElementRef`，我们将得到一个
    Angular 包装的 `div` 元素，它包含 `saTooltip` 属性。'
- en: '`Directive`: This decorator allows us to add the metadata required for the
    new directives we define.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Directive`: 这个装饰器允许我们添加我们定义的新指令所需的元数据。'
- en: '`HostListener(eventname)`: This is a method decorator that accepts an event
    name as an argument. During initialization of the directive, Angular will add
    the decorated method as an event handler for the `eventname` events fired by the
    host element.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HostListener(eventname)`: 这是一个方法装饰器，它接受一个事件名称作为参数。在指令初始化期间，Angular 会将装饰的方法添加为对宿主元素发出的
    `eventname` 事件的处理器。'
- en: 'Let''s look at the implementation of the directive:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看指令的实现：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Setting the directive's inputs
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置指令的输入
- en: In the previous code example, we declare a directive with the `saTooltip` selector.
    Note that Angular's HTML compiler is case sensitive, which means that it will
    distinguish `[satooltip]` and `[saTooltip]` as different selectors. After that,
    we declare the input of the directive using the `@Input` decorator over the `saTooltip`
    property. The semantics behind this code is that we declare a property called
    `saTooltip` and bind it to the value of the result that we got from the evaluation
    of the expression passed to the `saTooltip` attribute.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们使用 `saTooltip` 选择器声明了一个指令。请注意，Angular 的 HTML 编译器是区分大小写的，这意味着它会将
    `[satooltip]` 和 `[saTooltip]` 作为不同的选择器区分开来。之后，我们通过在 `saTooltip` 属性上使用 `@Input`
    装饰器来声明指令的输入。此代码背后的语义是，我们声明了一个名为 `saTooltip` 的属性，并将其绑定到传递给 `saTooltip` 属性的表达式评估结果值。
- en: The `@Input` decorator accepts a single argument, that is, the name of the attribute
    we want to bind to. In case we don't pass an argument, Angular will create a binding
    between the attribute with the same name as the property itself. We will explain
    the input and output concepts in detail later in this chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input` 装饰器接受一个单一参数，即我们想要绑定的属性的名称。如果我们没有传递参数，Angular 将在属性本身具有相同名称的属性之间创建绑定。我们将在本章的后面详细解释输入和输出概念。'
- en: Understanding the directive's constructor
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解指令的构造函数
- en: 'The constructor declares two private properties: `el` of the `ElementRef` type
    and `overlay` of the `Overlay` type. The `Overlay` class implements logic to manage
    the overlays of the tooltips and will be injected using the DI mechanism of Angular.
    In order to declare it as available for injection, we will need to declare the
    top-level component in the following way:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数声明了两个私有属性：`el` 是 `ElementRef` 类型，`overlay` 是 `Overlay` 类型。`Overlay` 类实现了管理提示框覆盖的逻辑，并将通过
    Angular 的 DI 机制进行注入。为了将其声明为可注入的，我们需要以下方式声明顶级组件：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will take a look at the dependency injection mechanism of Angular in the
    next chapter, where we will explain the way in which we can declare the dependencies
    of our services, directives, and components. The implementation of the `Overlay`
    class is not important for the purpose of this chapter. However, if you're interested
    in it, you can find it at `ch5/tooltip/app.ts`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中探讨 Angular 的依赖注入机制，我们将解释如何声明我们的服务、指令和组件的依赖关系。对于本章的目的而言，`Overlay` 类的实现并不重要。然而，如果你对此感兴趣，可以在
    `ch5/tooltip/app.ts` 中找到它。
- en: Better encapsulation of directives with NgModules
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NgModules 更好地封装指令
- en: 'In order to make the tooltip directive available to the Angular''s compiler,
    we will need to explicitly declare where we intend to use it. For instance, take
    a look at the `AppModule` class at `ch5/tooltip/app.ts`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使提示指令对 Angular 编译器可用，我们需要显式声明我们打算在哪里使用它。例如，查看 `AppModule` 类在 `ch5/tooltip/app.ts`
    中的情况：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To the `@NgModule` decorator, we pass an object literal that has the `declarations`
    property. This property contains a list of all the directives that will be available
    in all component subtrees with roots of any of the components listed in the `bootstrap`
    array. Another way to extend the list of available directives is to import a module.
    For instance, the `BrowserModule` module includes some very commonly used directives
    for the browser environment.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个对象字面量传递给 `@NgModule` 装饰器，该对象字面量具有 `declarations` 属性。此属性包含了一个列表，其中包含了所有将在
    `bootstrap` 数组中列出的任何组件的根组件的所有子组件中可用的指令。另一种扩展可用指令列表的方法是导入一个模块。例如，`BrowserModule`
    模块包含了一些在浏览器环境中非常常用的指令。
- en: At first, it might seem annoying that you should explicitly declare all the
    directives that are used in your modules; however, this enforces better encapsulation.
    In AngularJS, all directives are in a global namespace. This means that all the
    directives defined in the application are accessible in all the templates. This
    brings in some problems, for example, name collision. In order to deal with this
    issue, we often introduce naming conventions, for instance, the `"ng-"` prefix
    of all the directives defined by AngularJS and `"ui-"` for all directives coming
    with the Angular UI.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，你可能觉得必须显式声明模块中使用的所有指令可能会很烦人；然而，这强制了更好的封装。在 AngularJS 中，所有指令都在一个全局命名空间中。这意味着在应用程序中定义的所有指令都可以在所有模板中访问。这带来了一些问题，例如名称冲突。为了处理这个问题，我们经常引入命名约定，例如，AngularJS
    定义的指令都使用 `"ng-"` 前缀，而所有随 Angular UI 一起提供的指令都使用 `"ui-"`。
- en: Currently, by explicitly declaring all the directives that are used within a
    given module, we create a namespace specific to the individual components' subtrees
    (that is, the directives will be visible to the given root component and all of
    its successor components). Preventing name collisions is not the only benefit
    we get; it also helps us with better semantics of the code that we produce, since
    we're always aware of the directives accessible by the given component when we
    know in which module it's declared. We can find all the accessible directives
    of the given component by following the path from the component to the top module
    and taking the union of all the values of `declarations` and the declarations
    of `imports` of the modules. Given that components are extended from directives,
    we need to explicitly declare all the used components as well.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，通过显式声明给定模块中使用的所有指令，我们为各个组件的子树创建一个特定的命名空间（即，指令将对给定的根组件及其所有后续组件可见）。防止名称冲突不是我们得到的唯一好处；它还帮助我们提高我们产生的代码的语义性，因为我们总是知道给定组件在哪个模块中声明时可以访问哪些指令。我们可以通过从组件到顶级模块的路径找到给定组件的所有可访问指令，并取所有`declarations`和模块的`imports`声明的并集。鉴于组件是从指令扩展的，我们需要显式声明所有使用的组件。
- en: The `BrowserModule` module exports the built-in directives provided by Angular
    by exporting the `CommonModule` module that contains them. This list of predefined
    directives includes `NgClass`, `NgFor`, `NgIf`, `NgStyle`, `NgSwitch`, `NgSwitchWhen`,
    and `NgSwitchDefault`. Their names are quite self-explanatory; we'll take a look
    at how we can use some of them later in this chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`BrowserModule`模块通过导出包含它们的`CommonModule`模块来导出Angular提供的内置指令。这个预定义指令列表包括`NgClass`、`NgFor`、`NgIf`、`NgStyle`、`NgSwitch`、`NgSwitchWhen`和`NgSwitchDefault`。它们的名字相当直观；我们将在本章后面看看我们如何使用其中的一些。'
- en: Using NgModules for declaring reusable components
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NgModules声明可重用组件
- en: With NgModules, we can achieve a good degree of encapsulation. By explicitly
    exporting the public components, directives, pipes, and services, we can hide
    some of the implementation details of our modules. This way, we can implement
    reusable modules and expose only their public interface, and we do not reveal
    any low-level components to the user of the module.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NgModules，我们可以实现良好的封装度。通过显式导出公共组件、指令、管道和服务，我们可以隐藏我们模块的一些实现细节。这样，我们可以实现可重用模块，仅暴露它们的公共接口，并且不对模块用户透露任何底层组件。
- en: 'In order to get a better idea, let''s take a look at the following example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，让我们看一下以下示例：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding snippet, we declare the `Zippy`, `ZippyHeader`, and `App` components. `Zippy`
    is a component that has a header and a content; we can toggle the visibility of
    the content by clicking on the header. In the `ZippyHeader` component, we can
    implement some logic for handling the click events and/or visualizing the header.
    In the `App` component, we use the `Zippy` component by passing text for its header
    and content, like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了`Zippy`、`ZippyHeader`和`App`组件。`Zippy`是一个具有标题和内容的组件；我们可以通过点击标题来切换内容的可见性。在`ZippyHeader`组件中，我们可以实现一些逻辑来处理点击事件和/或可视化标题。在`App`组件中，我们通过传递文本作为其标题和内容来使用`Zippy`组件，如下所示：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to create a working Angular application, we will need to declare an
    `NgModule` decorator, which somehow references all the three components. We can
    approach this in two main ways:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个可工作的Angular应用程序，我们需要声明一个`NgModule`装饰器，它以某种方式引用所有三个组件。我们可以通过两种主要方式来处理这个问题：
- en: Declare a single `NgModule` decorator and include all the three components inside
    of its list of declarations.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个单独的`NgModule`装饰器，并将所有三个组件包含在其声明列表中。
- en: 'Declare two NgModules:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个NgModules：
- en: One that declares the `Zippy` and `ZippyHeader` components, called `ZippyModule`
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明`Zippy`和`ZippyHeader`组件，称为`ZippyModule`
- en: Another one that declares the `App` component and imports the `ZippyModule`
    module
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个声明`App`组件并导入`ZippyModule`模块的例子
- en: 'The second approach has a couple of advantages: in `ZippyModule`, we can declare
    both `Zippy` and `ZippyHeader`, but we can export only `Zippy` because `ZippyHeader`
    is used internally, within `Zippy`, and we don''t have to expose it to the user.
    By declaring the `ZippyModule` module, we can import it into other modules in
    our application where we want to reuse the `Zippy` component, or we can even extract
    it as a separate `npm` module and reuse it in multiple applications.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法有几个优点：在`ZippyModule`中，我们可以声明`Zippy`和`ZippyHeader`，但只能导出`Zippy`，因为`ZippyHeader`是在`Zippy`内部使用的，我们不需要将其暴露给用户。通过声明`ZippyModule`模块，我们可以将其导入到我们的应用程序中的其他模块，以便重用`Zippy`组件，或者甚至将其提取为单独的`npm`模块，在多个应用程序中重用。
- en: 'The second approach will look like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法看起来是这样的：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the example, in the `ZippyModule` module, we declare both `Zippy` and `ZippyHeader`,
    but we export only `Zippy`. We also import the `CommonModule` module from `@angular/common`
    in order to reuse Angular's built-in directives (for instance, `NgIf` is exported
    by `CommonModule`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，在`ZippyModule`模块中，我们声明了`Zippy`和`ZippyHeader`，但只导出`Zippy`。我们还从`@angular/common`中导入`CommonModule`模块，以便重用Angular的内置指令（例如，`NgIf`由`CommonModule`导出）。
- en: In the `AppModule` class, all we need to do is to import `ZippyModule`, and
    this way, we'll be able to use all of its exports and providers. We'll discuss
    providers further in the next chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AppModule`类中，我们只需要导入`ZippyModule`，这样我们就能使用其所有导出和提供者。我们将在下一章进一步讨论提供者。
- en: Note that good practices suggest that we should implement each individual component
    into a separate file. For the sake of simplicity in the examples for this book,
    we've violated this practice. For a list of best practices, visit [https://angular.io/styleguide](https://angular.io/styleguide).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，良好的实践建议我们应该将每个单独的组件实现到单独的文件中。为了简化本书的示例，我们违反了这一实践。有关最佳实践的列表，请访问[https://angular.io/styleguide](https://angular.io/styleguide)。
- en: Using the custom element schema
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义元素模式
- en: 'Now, let''s suppose we want to add a timer to our page and reuse a web component
    that we have already built. In this case, our application can look something like
    this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想在页面上添加一个计时器并重用我们已构建的Web组件。在这种情况下，我们的应用程序可能看起来像这样：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, if we run our application, we''ll get the following error:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们的应用程序，我们会得到以下错误：
- en: '![](img/3c603b6a-fc1f-4084-a4c5-302a8d9c3e66.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c603b6a-fc1f-4084-a4c5-302a8d9c3e66.png)'
- en: Figure 3
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图3
- en: When Angular parses the template of the `App` component, it will find `<simple-timer></simple-timer>`.
    It is not an element defined by the HTML specification, and it doesn't match any
    of the selectors of the directives declared or imported in the `AppModule` class,
    so the framework will throw an error.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当Angular解析`App`组件的模板时，它会找到`<simple-timer></simple-timer>`。它不是由HTML规范定义的元素，也不匹配`AppModule`类中声明或导入的任何指令的选择器，因此框架将抛出错误。
- en: 'So, how we can use Angular with custom components? The solution is to use the
    `schemas` property of the object literal we pass to `@NgModule`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使用Angular与自定义组件呢？解决方案是使用我们传递给`@NgModule`的对象字面量的`schemas`属性：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This way, we change the default schema that Angular uses for the validation
    of the elements and their attributes during parsing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们改变了Angular在解析元素及其属性时用于验证的默认模式。
- en: By default, the framework will throw an error if it finds an element that doesn't
    match the element selector of any of the imported or declared directive, or an
    element defined by the HTML5 spec.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果框架发现一个不匹配任何导入或声明的指令元素选择器，或者由HTML5规范定义的元素的元素，它将抛出错误。
- en: Creating custom Angular components
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义Angular组件
- en: Now, let's build a simple to-do application in order to demonstrate the syntax
    to define components.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个简单的待办事项应用程序，以演示定义组件的语法。
- en: 'Our to-do items will have the following format:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务项将具有以下格式：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s start by importing everything we will need:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入我们将需要的所有内容：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s declare the component and the metadata associated with it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们声明组件及其相关的元数据：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we specify that the selector of the `Todo` component will be the `todo-app`
    element. Later, we add the template URL, which points to the `app.html` file.
    After that, we use the `styles` property; this is the first time we encounter
    it. As we can guess from its name, it is used to set the styles of the component.
    Finally, we add `encapsulation`. This is a feature of Angular which allows us
    to have control over the scope of the defined styles.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定 `Todo` 组件的选择器将是 `todo-app` 元素。稍后，我们添加模板 URL，它指向 `app.html` 文件。之后，我们使用
    `styles` 属性；这是我们第一次遇到它。从其名称可以猜测，它用于设置组件的样式。最后，我们添加 `encapsulation`。这是 Angular
    的一项功能，它允许我们控制定义的样式的范围。
- en: Introducing the component's view encapsulation
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍组件的视图封装
- en: As we know, Angular is inspired from web components, whose core feature is the
    shadow DOM. The shadow DOM allows us to encapsulate the styles of our web components
    without allowing them to leak outside the component's scope; Angular provides
    this feature. If we want Angular to use the shadow DOM, we can use `ViewEncapsulation.Native`.
    However, at the time of writing this book, the shadow DOM is not supported by
    all browsers; if we want to have the same level of encapsulation without using
    the shadow DOM, we can set the value of the encapsulation property to `ViewEncapsulation.Emulated`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，Angular 受到 Web 组件的启发，其核心特性是 Shadow DOM。Shadow DOM 允许我们在不使其泄漏到组件范围之外的情况下封装我们的
    Web 组件的样式；Angular 提供了这一功能。如果我们希望 Angular 使用 Shadow DOM，我们可以使用 `ViewEncapsulation.Native`。然而，在撰写本书时，并非所有浏览器都支持
    Shadow DOM；如果我们想在不使用 Shadow DOM 的情况下达到相同的封装级别，我们可以将封装属性的值设置为 `ViewEncapsulation.Emulated`。
- en: If we don't want to have any encapsulation at all, we can use `ViewEncapsulation.None`.
    By default, the renderer uses encapsulation of the `Emulated` type.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想有任何封装，我们可以使用 `ViewEncapsulation.None`。默认情况下，渲染器使用 `Emulated` 类型的封装。
- en: Implementing the component's controllers
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现组件的控制器
- en: 'Now, let''s continue with the implementation of the application:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续实现应用程序：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here is part of the implementation of the controller associated with the template
    of the `Todo` application. Inside the class declaration, we initialized the `todos`
    property to an array with two `todo` items.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与 `Todo` 应用程序模板关联的控制器实现的一部分。在类声明中，我们将 `todos` 属性初始化为一个包含两个 `todo` 项的数组。
- en: 'Now, let''s update the template and render these items. Here''s how this is
    done:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新模板并渲染这些项。这是如何完成的：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the template, we iterate over all the `todo` items inside the `todos` property
    of the controller. For each `todo` item, we create a checkbox that can `toggle`
    the completion status of the item; we also render the label of the `todo` item
    with the interpolation directive. Here, we can notice a syntax that was explained
    earlier:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们遍历控制器中 `todos` 属性内的所有 `todo` 项。对于每个 `todo` 项，我们创建一个可以切换项完成状态的复选框；我们还使用插值指令渲染
    `todo` 项的标签。在这里，我们可以注意到之前解释过的语法：
- en: We bind to the change event of the checkbox using `(change)="statement"`
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `(change)="statement"` 绑定到复选框的更改事件。
- en: We bind to the property of the `todo` item using `[checked]="expr"`
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `[checked]="expr"` 绑定到 `todo` 项的属性。
- en: 'In order to have a line across the completed `todo` items, we bind to the `class.completed`
    property of the element. Since we want to apply the `completed` class to all the
    completed to-do items, we use `[class.completed]="todo.completed"`. This way,
    we declare that we want to apply the `completed` class depending on the value
    of the `todo.completed` expression. Here is how our application looks now:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在完成的 `todo` 项上有一条横线，我们绑定到元素的 `class.completed` 属性。由于我们希望将 `completed` 类应用到所有完成的待办事项上，我们使用
    `[class.completed]="todo.completed"`。这样，我们声明我们希望根据 `todo.completed` 表达式的值来应用 `completed`
    类。现在，我们的应用程序看起来是这样的：
- en: '![](img/35ff6a9c-2e44-4543-a093-5e02f6854ec3.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35ff6a9c-2e44-4543-a093-5e02f6854ec3.png)'
- en: Figure 4
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4
- en: 'Similar to the class binding syntax, Angular allows us to bind to the element''s
    styles and attributes of the element. For instance, we can bind to the `colspan`
    attribute of the `td` element using the following line of code: `<td [attr.colspan]="colspanCount"></td>`. In
    the same way, we can bind to any `style` property using `<div [style.backgroundImage]="expression"></td>`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与类绑定语法类似，Angular 允许我们绑定到元素的样式和属性。例如，我们可以使用以下代码行绑定到 `td` 元素的 `colspan` 属性：`<td
    [attr.colspan]="colspanCount"></td>`。同样，我们可以使用 `<div [style.backgroundImage]="expression"></td>`
    绑定到任何 `style` 属性。
- en: Handling user actions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户操作
- en: 'So far, so good! Now, let''s implement the `toggleCompletion` method. This
    method accepts the index of the to-do item as an argument:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！现在，让我们实现 `toggleCompletion` 方法。该方法接受待办事项的索引作为参数：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In `toggleCompletion`, we simply toggle the `completed` Boolean value associated
    with the current to-do item, which is specified by the index passed as an argument
    to the method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `toggleCompletion` 中，我们只是简单地切换与当前待办事项关联的 `completed` 布尔值，该值由传递给方法的方法参数指定的索引指定。
- en: 'Now, let''s add a text input to add the new to-do items:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个文本输入来添加新的待办事项：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The input here defines a new variable called `newtodo`. Now, we can reference
    the input element using the `newtodo` identifier inside the template. Once the
    user clicks on the button, the `addTodo` method defined in the controller will
    be invoked with the value of the `newtodo` input as an argument. Inside the statement
    that is passed to the `(click)` attribute, we also reset the value of the `newtodo`
    input by setting it to the empty string.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里定义的新变量名为 `newtodo`。现在，我们可以在模板内部使用 `newtodo` 标识符来引用输入元素。一旦用户点击按钮，控制器中定义的 `addTodo`
    方法将被调用，并将 `newtodo` 输入的值作为参数。在传递给 `(click)` 属性的语句中，我们还将 `newtodo` 输入的值重置为空字符串。
- en: Note that directly manipulating DOM elements is not considered as the best practice
    since it will prevent our component from running properly outside the browser
    environment. We will explain how we can migrate this application to web workers
    in [Chapter 9](b9d6c03a-d141-4201-afc6-339a41a38715.xhtml), *Tooling and Development
    Experience*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，直接操作DOM元素不被认为是最佳实践，因为它将阻止我们的组件在浏览器环境之外正确运行。我们将在第9章中解释如何将此应用程序迁移到web workers，*工具和开发经验*。
- en: 'Now, let''s define the `addTodo` method:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义 `addTodo` 方法：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Inside it, we create a new to-do item using the object literal syntax.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们使用对象字面量语法创建一个新的待办事项。
- en: The only thing left in our application is to implement the removal of the existing
    to-do items. Since it is quite similar to the functionality used to toggle the
    completion of the to-do items, I'll leave its implementation as a simple exercise
    for the reader.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，剩下要做的就是实现现有待办事项的删除。由于它与切换待办事项完成状态的功能非常相似，我将将其实现留给读者作为一个简单的练习。
- en: Using inputs and outputs
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用输入和输出
- en: 'By refactoring our `todo` application, we will demonstrate how we can take
    advantage of the directives'' inputs and outputs:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重构我们的 `todo` 应用程序，我们将展示如何利用指令的输入和输出：
- en: '![](img/9efdd73b-a5ad-4303-91d8-582bfabaf8de.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9efdd73b-a5ad-4303-91d8-582bfabaf8de.png)'
- en: Figure 5
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图5
- en: We can think of the inputs as properties (or even arguments) that the given
    directive accepts. The outputs could be considered as events that it triggers.
    When we use a directive provided by a third-party library, mostly, we care about
    its inputs and outputs because they define its API.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将输入视为给定指令接受的属性（甚至参数）。输出可以被视为它触发的事件。当我们使用第三方库提供的指令时，我们主要关心其输入和输出，因为它们定义了其API。
- en: Inputs refer to values that parameterize the directive's behavior and/or view.
    On the other hand, outputs refer to events that the directive fires when something
    special happens.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 输入指的是参数化指令行为和/或视图的值。另一方面，输出指的是当发生特殊事件时指令触发的事件。
- en: Determining the inputs and outputs
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定输入和输出
- en: 'Now, let''s divide our monolithic to-do application into separate components
    that communicate with each other. In the following screenshot, you can see the
    individual components, which when composed together, implement the functionality
    of the application:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的单体待办事项应用程序分解成相互通信的单独组件。在下面的屏幕截图中，您可以查看各个组件，当它们组合在一起时，实现了应用程序的功能：
- en: '![](img/046b7f78-e340-444b-94ad-f23e18106427.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/046b7f78-e340-444b-94ad-f23e18106427.png)'
- en: Figure 6
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图6
- en: The outer rectangle represents the entire `Todo` application. The first nested
    rectangle contains the component that is responsible for entering labels of the
    new to-do items, and the one below it lists the individual items stored in the
    root component.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 外部矩形表示整个 `Todo` 应用程序。第一个嵌套矩形包含负责输入新待办事项标签的组件，下面的矩形列出了存储在根组件中的单个项目。
- en: 'Having said this, we can define these three components as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，我们可以将这些三个组件定义为以下内容：
- en: '`TodoApp`: This is responsible for maintaining the list of to-do items (adding
    new items and toggling the completion status).'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoApp`：负责维护待办事项列表（添加新项目和切换完成状态）。'
- en: '`InputBox`: This is responsible for entering the label of the new to-do item.
    It has the following inputs and outputs:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputBox`：这个组件负责输入新的待办事项的标签。它有以下输入和输出：'
- en: 'Inputs: a placeholder for the textbox and a label for the submit button'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入：文本框的占位符和提交按钮的标签
- en: 'Outputs: the content of the textbox once the submit button is clicked'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出：提交按钮点击后文本框的内容
- en: '`TodoList`: This is responsible for rendering the individual to-do items. It
    has the following inputs and outputs:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoList`：这个组件负责渲染单个待办事项。它有以下输入和输出：'
- en: 'Inputs: This is a list of to-do items'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入：这是一个待办事项列表
- en: 'Outputs: This is the completion status of a to-do item'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出：这是待办事项的完成状态
- en: Now, let's begin with the implementation!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始实现！
- en: Defining the inputs and outputs
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义输入和输出
- en: 'Let''s use a bottom-up approach, and start with the `InputBox` component. Before
    that, we need a couple of imports from Angular''s `@angular/core` package:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采用自下而上的方法，从`InputBox`组件开始。在此之前，我们需要从Angular的`@angular/core`包中导入几个组件：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this snippet, we import the `@Component`, `@Input`, and `@Output` decorators
    and the `EventEmitter` class. As their names state, `@Input` and `@Output` are
    used for declaring the directive's inputs and outputs. `EventEmitter` is a generic
    class (that is, accepting a type parameter), which when combined with properties
    decorated with `@Output`, allows them to `emit` values.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们导入了`@Component`、`@Input`、`@Output`装饰器和`EventEmitter`类。正如它们的名称所表明的，`@Input`和`@Output`用于声明指令的输入和输出。`EventEmitter`是一个泛型类（即接受类型参数），当与用`@Output`装饰的属性结合使用时，允许它们`emit`值。
- en: 'As the next step, let''s take a look at the `InputBox` component''s declaration:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，让我们看看`InputBox`组件的声明：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that in the template, we declare a text input and keep a reference to
    it using the `todoInput` identifier, and set its placeholder property to the value
    that we got from the evaluation of the `inputPlaceholder` identifier. This is
    the first input that we need to declare:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在模板中，我们声明一个文本输入，并使用`todoInput`标识符保持对其的引用，并将其占位符属性设置为从`inputPlaceholder`标识符评估得到的值。这是我们需要声明的第一个输入：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Similarly, we declare the other input of the `buttonLabel` component, which
    we use as a value of the label of the button:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们声明`buttonLabel`组件的其他输入，我们将其用作按钮标签的值：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding template, we bind the click event of the button to the `emitText(todoInput.value);
    todoInput.value = '''';` statement. The `emitText` method should be defined in
    the component''s controller; once it is invoked, it should `emit` the value of
    the text input. Here is how we can implement this behavior:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，我们将按钮的点击事件绑定到`emitText(todoInput.value); todoInput.value = '';`语句。`emitText`方法应该在组件的控制器中定义；一旦调用，它应该`emit`文本输入的值。以下是实现此行为的方法：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Initially, we declare an output called `inputText`. As its value, we set a new
    instance of the `EventEmitter<string>` type that we create.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们声明一个名为`inputText`的输出。作为其值，我们设置一个我们创建的`EventEmitter<string>`类型的新实例。
- en: Note that all the outputs of all the components need to be instances of `EventEmitter`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有组件的所有输出都需要是`EventEmitter`的实例。
- en: Inside the `emitText` method, we invoke the `emit` method of  `inputText` and
    as its argument, we pass the value of the text input.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在`emitText`方法内部，我们调用`inputText`的`emit`方法，并将其作为参数传递文本输入的值。
- en: 'Now, let''s define the `TodoList` component in the same fashion:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以同样的方式定义`TodoList`组件：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since the value of the object literal passed to the `@Component` decorator is
    not essential for the purpose of this section, we omitted it. The complete implementation
    of this example can be found at `ch5/inputs-outputs/app.ts`. Let's take a look
    at the body of the `TodoList` class. Similarly, to the `InputBox` component, we
    define the `todos` input. We also define the `toggle` output by declaring the
    `toggle` property, setting its value to a new instance of the `EventEmitter<Todo>` type
    and decorating it with the `@Output` decorator.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于传递给`@Component`装饰器的对象字面量的值对于本节的目的不是必需的，所以我们省略了它。这个示例的完整实现可以在`ch5/inputs-outputs/app.ts`中找到。让我们看看`TodoList`类的主体。同样，与`InputBox`组件一样，我们定义了`todos`输入。我们还通过声明`toggle`属性，将其值设置为`EventEmitter<Todo>`类型的新实例，并用`@Output`装饰器装饰它来定义`toggle`输出。
- en: Passing inputs and consuming the outputs
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递输入和消费输出
- en: Now, let's combine the components we defined in the previous section and implement
    the complete application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将上一节中定义的组件组合起来，实现完整的应用程序。
- en: 'The last component we need to take a look at is `TodoApp`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要查看的最后一个组件是`TodoApp`：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Initially, we define the `TodoApp` class and decorate it with the `@Component`
    decorator. Note that in order to use the `InputBox` and `TodoList` components,
    we will need to include them in the `declarations` property of the decorator of
    the module, which declares `TodoApp`. The magic of how these components collaborate
    together happens in the template:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们定义`TodoApp`类并用`@Component`装饰器装饰它。注意，为了使用`InputBox`和`TodoList`组件，我们需要将它们包含在声明`TodoApp`的模块的`declarations`属性中。这些组件如何协作的魔法发生在模板中：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, we use the `InputBox` component and pass values to the `inputPlaceholder`
    and `buttonLabel` inputs. Note that just like we saw earlier, if we want to pass
    an expression as a value to any of these inputs, we will need to surround them
    with brackets (that is, `[inputPlaceholder]="expression"`). In this case, the
    expression will be evaluated in the context of the component that owns the template,
    and the result will be passed as an input to the component that owns the given
    property.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`InputBox`组件并将值传递给`inputPlaceholder`和`buttonLabel`输入。注意，就像我们之前看到的，如果我们想将这些值作为表达式传递给任何这些输入，我们需要用括号包围它们（即`[inputPlaceholder]="expression"`）。在这种情况下，表达式将在拥有模板的组件的上下文中进行评估，并将结果作为输入传递给拥有给定属性的组件。
- en: Right after we pass the value for the `buttonLabel` input, we consume the `inputText`
    output by setting the value of the `(inputText)` attribute to the `addTodo($event)`
    expression. The value of `$event` will equal the value we passed to the `emit`
    method of the `inputText` object inside the `emitText` method of `InputBox` (in
    case we bind to a native event, the value of the event object will be the native
    event object itself).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在传递`buttonLabel`输入的值之后，我们通过将`(inputText)`属性的值设置为`addTodo($event)`表达式来消费`inputText`输出。`$event`的值将等于我们在`InputBox`的`emitText`方法内部传递给`emit`方法的`inputText`对象的值（如果我们绑定到原生事件，事件对象的值将是原生事件对象本身）。
- en: 'In the same way, we pass the input of the `TodoList` component and handle its
    toggle output. Now, let''s define the logic behind the `TodoApp` component:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们传递`TodoList`组件的输入并处理其切换输出。现在，让我们定义`TodoApp`组件背后的逻辑：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `addTodo` method, we simply push a new to-do item to the `todos` array.
    The implementation of `toggleCompletion` is even simpler: we toggle the value
    of the completed flag that is passed as an argument to the to-do item. Now, we
    are familiar with the basics of the components'' inputs and outputs.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addTodo`方法中，我们只是简单地将一个新的待办事项推送到`todos`数组。`toggleCompletion`的实现甚至更简单：我们切换作为待办事项参数传递的完成标志的值。现在，我们已经熟悉了组件的输入和输出的基础知识。
- en: Event bubbling
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件冒泡
- en: 'In Angular, we have the same bubbling behavior we''re used to in the DOM. For
    instance, let''s suppose we have the following template:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，我们有与DOM中相同的冒泡行为。例如，假设我们有以下模板：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The template declaration of the `input-box` component looks like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`input-box`组件的模板声明看起来是这样的：'
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once the user clicks on the button defined within the template of the `input-box`
    component, the `handleClick($event)` expression will be evaluated.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击`input-box`组件模板中定义的按钮时，将评估`handleClick($event)`表达式。
- en: Further, the `target` property of the first argument of `handleClick` will be
    the button itself, but the `currentTarget` property will be the `input-box` element.
    The event will bubble the same way if we're not using Angular. At some point,
    it will reach the document unless a handler along the way doesn't stop its propagation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`handleClick`的第一个参数的`target`属性将是按钮本身，但`currentTarget`属性将是`input-box`元素。如果不使用Angular，事件将以相同的方式冒泡。在某个时刻，它将到达文档，除非在传播过程中某个处理程序没有停止其传播。
- en: In contrast, if we have a custom `@Output` decorator, the event will not bubble
    and instead of a DOM event object, the value of the `$event` variable will be
    the value that we pass to the `emit` method of the output.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果我们有一个自定义的`@Output`装饰器，事件将不会冒泡，并且`$event`变量的值将是我们传递给输出`emit`方法的值，而不是DOM事件对象。
- en: Renaming the inputs and outputs
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重命名输入和输出
- en: 'Now, we will explore how we can rename the directives'' inputs and outputs.
    Let''s suppose that we have the following definition of the `TodoList` component:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨如何重命名指令的输入和输出。假设我们有以下`TodoList`组件的定义：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output of the component is called `toggle`; the method that handles changes
    in the checkboxes responsible for toggling completion of the individual to-do
    items is also called `toggle`. This code will not be compiled, as in the `TodoList`
    controller, we have two identifiers named in the same way. We have two options
    here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的输出称为 `toggle`；处理切换复选框以切换单个待办事项完成状态的方法也称为 `toggle`。由于在 `TodoList` 控制器中我们有两个相同命名的标识符，这段代码将无法编译。我们有两个选择：
- en: We can rename the method
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以重命名方法
- en: We can rename the property
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以重命名属性
- en: 'If we rename the property, this will change the name of the component''s output
    as well. So, the following line of code will no longer work:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重命名属性，这将同时改变组件输出的名称。因此，以下代码行将不再工作：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'What we can do instead is rename the `toggle` property and explicitly set the
    name of the output using the `@Output` decorator:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的替代方法是重命名 `toggle` 属性，并使用 `@Output` 装饰器显式设置输出的名称：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This way, we will be able to trigger the `toggle` output using the `toggleEvent`
    property.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们将能够通过 `toggleEvent` 属性触发 `toggle` 输出。
- en: Note that such renames can be confusing and are not considered as best practices.
    For a complete set of best practices, visit [https://angular.io/styleguide](https://angular.io/styleguide).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这样的重命名可能会造成混淆，并且不被视为最佳实践。有关最佳实践的完整集合，请访问 [https://angular.io/styleguide](https://angular.io/styleguide)。
- en: 'Similarly, we can rename the component''s inputs using the following code snippet:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用以下代码片段重命名组件的输入：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, it doesn''t matter that we renamed the input and output properties of
    `TodoList`; it still has the same public interface:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们重命名了 `TodoList` 的输入和输出属性并不重要；它仍然具有相同的公共接口：
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: An alternative syntax to define inputs and outputs
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义输入和输出的替代语法
- en: 'The `@Input` and `@Output` decorators are syntax sugar for easier declaration
    of the directive''s `inputs` and outputs. The original syntax for this purpose
    is as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input` 和 `@Output` 装饰器是为了更方便地声明指令的 `inputs` 和 `outputs` 而提供的语法糖。用于此目的的原生语法如下：'
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Using `@Input` and `@Output`, the preceding syntax is equivalent to this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@Input` 和 `@Output`，前面的语法等同于以下语法：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Although both have the same semantics, according to the best practices, we should
    use the latter one, because it is easier to read and understand.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两者具有相同的语义，但根据最佳实践，我们应该使用后者，因为它更容易阅读和理解。
- en: Explaining Angular's content projection
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释 Angular 的内容投影
- en: Content projection is an important concept when developing user interfaces.
    It allows us to project pieces of content into different places of the user interface
    of our application. Web components solve this problem with the `content` element.
    In AngularJS, it is implemented with the infamous transclusion.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 内容投影是开发用户界面时的重要概念。它允许我们将内容片段投影到我们应用程序用户界面的不同位置。网络组件通过 `content` 元素解决这个问题。在 AngularJS
    中，它通过臭名昭著的转包含实现。
- en: Angular is inspired by modern web standards, especially web components, which
    led to the adoption of some of the methods of content projection used there. In
    this section, we'll look at them in the context of Angular using the `ng-content`
    directive.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 受到现代网络标准的启发，特别是网络组件，这导致了那里使用的一些内容投影方法的采用。在本节中，我们将使用 `ng-content` 指令在
    Angular 的上下文中查看它们。
- en: Basic content projection in Angular
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 中的基本内容投影
- en: 'Let''s suppose we''re building a component called `fancy-button`. This component
    will use the standard HTML button element and add some extra behavior to it. Here
    is the definition of the `fancy-button` component:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在构建一个名为 `fancy-button` 的组件。此组件将使用标准的 HTML 按钮元素并添加一些额外的行为。以下是 `fancy-button`
    组件的定义：
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Inside of the `@Component` decorator, we set the inline template of the component
    together with its selector. Now, we can use the component with the following markup:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `@Component` 装饰器内部，我们设置组件的内联模板及其选择器。现在，我们可以使用以下标记来使用该组件：
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: On the screen, we will see a standard HTML button that has a label with the
    `Click me` content. This is not a very flexible way to define reusable UI components.
    Most likely, the users of the fancy button will need to change the content of
    the label to something, depending on their application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上，我们将看到一个带有 `Click me` 内容标签的标准 HTML 按钮。这不是定义可重用 UI 组件的非常灵活的方式。很可能会看到，fancy
    按钮的用户需要根据他们的应用程序更改标签的内容。
- en: 'In AngularJS, we were able to achieve this result with `ng-transclude`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AngularJS 中，我们能够通过 `ng-transclude` 实现此结果：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In Angular, we have the `ng-content` element:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，我们有`ng-content`元素：
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we can pass custom content to the fancy button by executing this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过执行以下操作将自定义内容传递给花哨的按钮：
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As a result, the content between the opening and closing `fancy-button` tags
    will be placed where the `ng-content` directive resides.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`fancy-button`标签的开启和关闭标签之间的内容将被放置在`ng-content`指令所在的位置。
- en: Projecting multiple content chunks
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投影多个内容块
- en: Another typical use case of content projection is when we pass content to a
    custom Angular component or AngularJS directive and we want different parts of
    this content to be projected to different locations in the template.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 内容投影的另一个典型用例是我们将内容传递给自定义Angular组件或AngularJS指令，并且我们希望将内容的不同部分投影到模板的不同位置。
- en: 'For instance, let''s suppose we have a `panel` component that has a title and
    a body, and we can use it in the following way:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个具有标题和主体的`panel`组件，我们可以按以下方式使用它：
- en: '[PRE49]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The template of our `panel` component looks like this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`panel`组件的模板看起来像这样：
- en: '[PRE50]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In AngularJS 1.5, we are able to do this using multislot transclusion, which
    was implemented in order to allow us to have a smoother transition to Angular.
    Let''s take a look at how we can proceed in Angular in order to define such a
    `panel` component:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS 1.5中，我们可以通过使用多插槽转义来实现这一点，这是为了使我们能够更平滑地过渡到Angular。让我们看看我们如何在Angular中定义这样的`panel`组件：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the template, we have a `div` element with the `panel` class, which wraps
    the two nested `div` elements, respectively—one for the title of `panel` and one
    for the content of `panel`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们有一个具有`panel`类的`div`元素，它分别包裹着两个嵌套的`div`元素——一个用于`panel`的标题，一个用于`panel`的内容。
- en: In order to project the content of the `section` element with the `panel-title` class
    name to where the title should be, we will need to use the `ng-content` element.
    As its `selector` attribute, we will need to use a CSS selector, which matches
    the element whose content we want to project (in this case, the selector should
    be `.panel-title` or `section.panel-title`).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将具有`panel-title`类名的`section`元素的内容投影到标题应该出现的位置，我们需要使用`ng-content`元素。作为其`selector`属性，我们需要使用一个CSS选择器，该选择器匹配我们想要投影内容的元素（在这种情况下，选择器应该是`.panel-title`或`section.panel-title`）。
- en: In case we set the value of the `selector` attribute to `.panel-title`, it will
    match all the elements with the `.panel-title` classes that reside inside the
    target `panel` element. After this, `ng-content` will grab their content and set
    them as its own content.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`selector`属性的值设置为`.panel-title`，它将匹配所有位于目标`panel`元素内部的具有`.panel-title`类的元素。之后，`ng-content`将获取它们的内容并将它们设置为它自己的内容。
- en: Nesting components
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套组件
- en: We've already built a few simple applications as a composition of components
    and directives. We saw that components are basically directives with views, so
    we can implement them by nesting or composing other directives and components.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了一些简单的应用程序，这些应用程序是由组件和指令组成的。我们了解到组件基本上是带有视图的指令，因此我们可以通过嵌套或组合其他指令和组件来实现它们。
- en: 'The following figure illustrates this with a structural diagram:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 下图通过结构图说明了这一点：
- en: '![](img/f9dd1a8c-9475-4c25-9e6a-7fb75ca9c1bc.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9dd1a8c-9475-4c25-9e6a-7fb75ca9c1bc.png)'
- en: Figure 7
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图7
- en: 'The composition could be achieved by nesting directives and components within
    the components templates, taking advantage of the nested nature of the used markup.
    For instance, let''s say we have a component with the `sample-component` selector,
    which has the following definition:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在组件模板内嵌套指令和组件，利用所使用的标记的嵌套特性，我们可以实现组合。例如，假设我们有一个具有`sample-component`选择器的组件，其定义如下：
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The template of the `Sample` component has a single-child element with the `view-child` tag
    name.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sample`组件的模板具有一个带有`view-child`标签名的单子元素。'
- en: 'On the other hand, we can use the `Sample` component inside the template of
    another component, and since it can be used as an element, we can also nest other
    components or directives inside of it:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以在另一个组件的模板中使用`Sample`组件，并且由于它可以作为一个元素使用，我们也可以在其内部嵌套其他组件或指令：
- en: '[PRE53]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This way, the `sample-component` component has two different types of successors:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`sample-component`组件有两种不同类型的后继者：
- en: Successors defined within its template
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其模板内定义的后继者
- en: Successors passed as nested elements between its opening and closing tags
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其开启和关闭标签之间传递的嵌套元素作为后继者
- en: In the context of Angular, the direct children elements defined within the component's
    template are called **view children** and the ones nested between its opening
    and closing tags are called **content children**.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 的上下文中，组件模板内定义的直接子元素被称为 **视图子元素**，而嵌套在其开闭标签之间的元素被称为 **内容子元素**。
- en: Using view children and content children
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视图子元素和内容子元素
- en: 'Let''s take a look at the implementation of a sample `Tabs` component, which
    uses the following structure:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例 `Tabs` 组件的实现，它使用以下结构：
- en: '[PRE54]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The preceding structure is composed of three components:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 上述结构由三个组件组成：
- en: '`Tab` component'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tab` 组件'
- en: '`TabTitle` component'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TabTitle` 组件'
- en: '`TabContent` component'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TabContent` 组件'
- en: 'Let''s take a look at the implementation of the `TabTitle` component:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `TabTitle` 组件的实现：
- en: '[PRE55]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There's nothing new in this implementation. We define a `TabTitle` component,
    which has a single property called `tabSelected`. It is of the `EventEmitter` type and
    will be triggered once the user clicks on the tab title.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中没有什么新的内容。我们定义了一个 `TabTitle` 组件，它有一个名为 `tabSelected` 的单个属性。它属于 `EventEmitter`
    类型，当用户点击标签标题时将被触发。
- en: 'Now, let''s take a look at the `TabContent` component:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `TabContent` 组件：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This has an even simpler implementation—all we do is project the DOM passed
    to the `tab-content` element inside `ng-content`, and hide it once the value of
    the `isActive` property becomes `false`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个更简单的实现——我们只是将传递给 `tab-content` 元素的 DOM 在 `ng-content` 内部投影，一旦 `isActive`
    属性的值变为 `false`，就隐藏它。
- en: 'The interesting part of the implementation is the `Tabs` component itself:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 实现中的有趣部分是 `Tabs` 组件本身：
- en: '[PRE57]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In this snippet, we have a decorator that we haven''t used yet: the `@ContentChildren`
    decorator. The `@ContentChildren` property decorator fetches the content children
    of the given component. This means that we can get references to all `TabTitle`
    and `TabContent` instances from within the instance of the `Tabs` component and
    get them in the order in which they are declared in the markup. There''s an alternative
    decorator called `@ViewChildren`, which fetches all the view children of the given
    element. Let''s take a look at the difference between view children and content
    children before we explain the implementation further.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们有一个我们还没有使用过的装饰器：`@ContentChildren` 装饰器。`@ContentChildren` 属性装饰器获取给定组件的内容子元素。这意味着我们可以从
    `Tabs` 组件的实例中获取所有 `TabTitle` 和 `TabContent` 实例的引用，并按它们在标记中声明的顺序获取它们。还有一个名为 `@ViewChildren`
    的替代装饰器，它获取给定元素的所有视图子元素。在我们进一步解释实现之前，让我们看看视图子元素和内容子元素之间的区别。
- en: View child versus content child
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图子元素与内容子元素
- en: 'Although both concepts sound similar, they have quite different semantics.
    In order to understand them better, let''s take a look at the following example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个概念听起来很相似，但它们的语义却相当不同。为了更好地理解它们，让我们看看以下示例：
- en: '[PRE58]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here, we''ve defined two components: `UserBadge` and `UserRating`. Let''s define
    a parent component, which comprises both the components:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个组件：`UserBadge` 和 `UserRating`。让我们定义一个父组件，它包含这两个组件：
- en: '[PRE59]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Note that the template of the view of `UserPanel` contains only the `UserBadge`
    component''s selector. Now, let''s use the `UserPanel` component in our application:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`UserPanel` 视图的模板中只包含 `UserBadge` 组件的选择器。现在，让我们在我们的应用程序中使用 `UserPanel` 组件：
- en: '[PRE60]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The template of our main `App` component uses the `UserPanel` component and
    nests the `UserRating` component inside it. Now, let''s suppose we want to get
    a reference to the instance of the `UserRating` component that is used inside
    the `user-panel` element in the template of `App` and a reference to the `UserBadge`
    component, which is used inside the template of `UserPanel`. In order to do this,
    we can add two more properties to the `UserPanel` controller and add the `@ContentChild`
    and `@ViewChild` decorators to them with the appropriate arguments:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主 `App` 组件的模板使用了 `UserPanel` 组件，并在其中嵌套了 `UserRating` 组件。现在，假设我们想要获取在 `App`
    组件模板的 `user-panel` 元素中使用的 `UserRating` 组件实例的引用，以及用于 `UserPanel` 组件模板中的 `UserBadge`
    组件的引用。为了做到这一点，我们可以在 `UserPanel` 控制器中添加两个额外的属性，并将 `@ContentChild` 和 `@ViewChild`
    装饰器添加到它们上，并使用适当的参数：
- en: '[PRE61]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The semantics of the `badge` property declaration is *get the instance of the
    first child component of the `UserBadge` type, which is used inside the `UserPanel`*
    *template.* Accordingly, the semantics of the `rating` property's declaration
    is *get the instance of the first child component of the **`UserRating` type,
    which is nested inside the `UserPanel`* *host element.*
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`badge`属性声明的语义是*获取`UserBadge`类型的第一个子组件的实例，该类型在`UserPanel`* *模板中使用。相应地，`rating`属性声明的语义是*获取嵌套在`UserPanel`*
    *宿主元素中的`**UserRating**`类型的第一个子组件的实例。'
- en: Now, if you run this code, you'll note that the values of the `badge` and `rating`
    properties are still equal to the `undefined` value inside the controller's constructor.
    This is because they are still not initialized in this phase of the component's
    life cycle. The life cycle hooks that we can use in order to get a reference to
    these child components are `ngAfterViewInit` and `ngAfterContentInit`. We can
    use these hooks simply by adding definitions of the `ngAfterViewInit` and `ngAfterContentInit`
    methods to the component's controller. We will make a complete overview of the
    life cycle hooks that Angular provides shortly.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行这段代码，你会注意到`badge`和`rating`属性的值在控制器构造函数内仍然是`undefined`值。这是因为在这个组件生命周期的这个阶段，它们还没有被初始化。我们可以用来获取这些子组件引用的生命周期钩子是`ngAfterViewInit`和`ngAfterContentInit`。我们可以通过在组件控制器中添加`ngAfterViewInit`和`ngAfterContentInit`方法的定义来使用这些钩子。我们将在不久的将来对Angular提供的生命周期钩子做一个全面的概述。
- en: To recap, we can say that the content children of the given components are the
    child elements that are nested within the component's host element. In contrast,
    the view children directives of the given component are the elements used within
    its template.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾，我们可以这样说，给定组件的内容子元素是嵌套在组件宿主元素内的子元素。相比之下，给定组件的视图子元素指令是其模板中使用的元素。
- en: 'In order to get a platform independent reference to a DOM element, again, we
    can use `@ContentChild` and `@ViewChild`. For instance, if we have the following
    template: `<input #todo>` we can get a reference to the `input` using `@ViewChild(''todo'')`.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '为了获取一个平台无关的DOM元素的引用，同样，我们可以使用`@ContentChild`和`@ViewChild`。例如，如果我们有以下模板：`<input
    #todo>`，我们可以使用`@ViewChild(''todo'')`来获取`input`的引用。'
- en: Since we are already familiar with the core differences between view children
    and content children, now we can continue with our tabs implementation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经熟悉了视图子元素和内容子元素之间的核心区别，现在我们可以继续我们的标签实现。
- en: 'In the tabs component, instead of using the `@ContentChild` decorator, we use
    `@ContentChildren`. We do this because we have multiple content children and we
    want to get them all:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tabs`组件中，我们不是使用`@ContentChild`装饰器，而是使用`@ContentChildren`。我们这样做是因为我们有多个子内容，我们想要获取它们全部：
- en: '[PRE62]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Another main difference that we will note is that the types of the `tabTitles`
    and `tabContents` properties are `QueryList` with their respective type parameter
    and not the component's type itself. We can think of the `QueryList` data structure
    as a JavaScript array—we can apply the same high-order functions (`map`, `filter`,
    `reduce`, and so on) over it and loop over its elements; however, `QueryList`
    is also observable, that is, we can observe it for changes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将注意到的另一个主要区别是`tabTitles`和`tabContents`属性的类型是带有相应类型参数的`QueryList`，而不是组件本身的类型。我们可以将`QueryList`数据结构视为一个JavaScript数组——我们可以对其应用相同的高阶函数（`map`、`filter`、`reduce`等）并遍历其元素；然而，`QueryList`也是可观察的，也就是说，我们可以观察其变化。
- en: 'As the final step of our `Tabs` definition, let''s take a peek at the implementation
    of the `ngAfterContentInit` and `select` methods:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们`Tabs`定义的最后一步，让我们看看`ngAfterContentInit`和`select`方法的实现：
- en: '[PRE63]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the first line of the method's implementation, we loop all `tabTitles` properties
    and take the observable's references. These objects have a method called `subscribe`,
    which accepts a callback as an argument. Once the `.emit()` method of the `EventEmitter`
    instance (that is, the `tabSelected` property of any tab) is called, the callback
    passed to the `subscribe` method will be invoked.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法实现的第 一行，我们遍历所有`tabTitles`属性并获取可观察对象的引用。这些对象有一个名为`subscribe`的方法，它接受一个回调作为参数。一旦调用`EventEmitter`实例的`.emit()`方法（即任何标签的`tabSelected`属性），传递给`subscribe`方法的回调将被调用。
- en: 'Now, let''s take a look at the implementation of the `select` method:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`select`方法的实现：
- en: '[PRE64]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the first line here, since `tabContents` is of the `QueryList<TabContent>` type,
    we get its array representation. After that, we set the `isActive` flag of the
    current active tab to `false` and select the next active one. In the last line
    in the implementation of the `select` method, we trigger the selected event of
    the `Tabs` component by invoking `this.tabChanged.emit` with the index of the
    currently selected tab.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的第一行，由于`tabContents`是`QueryList<TabContent>`类型，我们得到其数组表示。之后，我们将当前活动标签的`isActive`标志设置为`false`并选择下一个活动标签。在`select`方法的实现中的最后一行，我们通过调用`this.tabChanged.emit`并传递当前选中标签的索引来触发`Tabs`组件的选中事件。
- en: Hooking into the component's life cycle
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂钩到组件的生命周期
- en: Components in Angular have a well-defined life cycle, which allows us to hook
    into different phases of it and have further control over our application. We
    can do this by implementing specific methods in the component's controller. In
    order to be more explicit, thanks to the expressiveness of TypeScript, we can
    implement different interfaces associated with the life cycle's phases. Each of
    these interfaces has a single method, which is associated with the phase itself.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的组件具有明确的生命周期，这允许我们挂钩到其不同阶段，并进一步控制我们的应用程序。我们可以通过在组件控制器中实现特定方法来实现这一点。为了更加明确，多亏了TypeScript的表达性，我们可以实现与生命周期阶段相关的不同接口。每个接口都有一个与阶段本身相关联的单个方法。
- en: 'The following diagram shows all the phases we can hook into:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了我们可以挂钩的所有阶段：
- en: '![](img/603bcc04-bfef-4c74-acc8-866dd17df571.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/603bcc04-bfef-4c74-acc8-866dd17df571.png)'
- en: Figure 8
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图8
- en: 'Let''s take a look at the different life cycle hooks:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看不同的生命周期挂钩：
- en: '`OnChanges`: This hook will be invoked once a change in the input properties
    of a given component is detected. For instance, let''s take a look at the following
    component:'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnChanges`：此挂钩将在检测到给定组件的输入属性发生变化时被调用。例如，让我们看看以下组件：'
- en: '[PRE65]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can use it like this:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用它：
- en: '[PRE66]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once the value of the expression associated with the `[title]` attribute is
    changed, the `ngOnChanges` hook will be invoked. We can implement it using this
    code snippet:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦与`[title]`属性关联的表达式的值发生变化，`ngOnChanges`挂钩将被调用。我们可以使用以下代码片段来实现它：
- en: '[PRE67]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The preceding snippet will display all the changed bindings and their old values.
    In order to be more explicit in the implementation of the hook, we can use interfaces:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将显示所有更改的绑定及其旧值。为了在挂钩的实现中更加明确，我们可以使用接口：
- en: '[PRE68]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: All the interfaces representing the individual life cycle hooks declare a single
    method with the name of the interface itself prefixed with `ng`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 表示单个生命周期挂钩的所有接口声明了一个以接口本身名称前缀为`ng`的单个方法。
- en: In the upcoming list, we'll use the term life cycle hook, both for interface
    and/or the method, except if we won't imply anything specifically for only one
    of them.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的列表中，我们将使用术语生命周期挂钩，无论是接口还是/或方法，除非我们不会对其中任何一个具体说明。
- en: '`OnInit`: This hook will be invoked once the given component is initialized.
    We can implement it using the `OnInit` interface with its `ngOnInit` method.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnInit`：此挂钩将在给定组件初始化时被调用。我们可以使用`OnInit`接口及其`ngOnInit`方法来实现它。'
- en: '`DoCheck`: This will be invoked when the change detector of the given component
    is invoked. It allows us to implement our own change detection algorithm for the
    given component. Note that `DoCheck` and `OnChanges` should not be implemented
    together on the same directive.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoCheck`：这将在被调用时触发给定组件的更改检测器。它允许我们为给定组件实现自己的更改检测算法。请注意，`DoCheck`和`OnChanges`不应在同一指令上一起实现。'
- en: '`OnDestroy`: If we implement the `OnDestroy` interface with its `ngOnDestroy`
    method, we can hook into the destroy life cycle phase of a component. This method
    will be invoked once the component is detached from the component tree.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDestroy`：如果我们实现了`OnDestroy`接口及其`ngOnDestroy`方法，我们就可以挂钩到组件的销毁生命周期阶段。该方法将在组件从组件树中分离时被调用。'
- en: 'Now, let''s take a look at the life cycle hooks associated with the component''s
    content and view children:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看与组件的内容和视图子组件相关的生命周期挂钩：
- en: '`AfterContentInit`: If we implement the `ngAfterContentInit` life cycle hook,
    we will be notified when the component''s content is fully initialized. This is
    the phase when the properties decorated with `ContentChild` or `ContentChildren`
    will be initialized.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterContentInit`：如果我们实现了`ngAfterContentInit`生命周期挂钩，我们将被通知组件的内容已完全初始化。这是当带有`ContentChild`或`ContentChildren`装饰的属性被初始化的阶段。'
- en: '`AfterContentChecked</span>`: By implementing this hook, we''ll be notified
    each time the content of the given component has been checked by the change detection
    mechanism of Angular.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterContentChecked`：通过实现此钩子，每当给定组件的内容被 Angular 的变更检测机制检查时，我们都会收到通知。'
- en: '`AfterViewInit`: If we implement this life cycle hook with its `ngAfterViewInit`
    method, we will be notified when the component''s view is initialized. This is
    the phase when the properties decorated with `ViewChild` or `ViewChildren` will
    be initialized.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterViewInit`：如果我们通过 `ngAfterViewInit` 方法实现此生命周期钩子，我们将在组件的视图初始化时收到通知。这是装饰了
    `ViewChild` 或 `ViewChildren` 的属性初始化的阶段。'
- en: '`AfterViewChecked`: This is similar to `AfterContentChecked`. The `AfterViewChecked`
    hook will be invoked once the view of our component is checked.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterViewChecked`：这与 `AfterContentChecked` 类似。当我们的组件视图被检查后，`AfterViewChecked`
    钩子将被调用。'
- en: Order of execution of the life cycle hooks
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期钩子的执行顺序
- en: 'In order to trace the order of execution of the callbacks associated with each
    hook, let''s take a peek at the `ch5/life-cycle/app.ts` example:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 为了追踪与每个钩子关联的回调的执行顺序，让我们看一下 `ch5/life-cycle/app.ts` 示例：
- en: '[PRE69]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `Panel` component implements all the hooks without explicitly implementing
    the interfaces associated with them for the sake of simplicity. Keep in mind that
    it's considered best practice to implement the interfaces of the individual life
    cycle hooks we use.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，`Panel` 组件实现了所有钩子，而没有明确实现与之相关的接口。请记住，实现我们使用的各个生命周期钩子的接口被认为是最佳实践。
- en: 'We can use the component in the following template:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下模板中使用组件：
- en: '[PRE70]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the preceding example, we have a panel and a button. Upon each click of the
    button, the panel will be either removed or appended to the view by the `ngIf`
    directive.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有一个面板和一个按钮。每当按钮被点击时，`ngIf` 指令将根据需要将面板从视图中移除或添加到视图中。
- en: During the application initialization, if the result of the `"counter % 2 ==
    0"` expression is evaluated to `true`, the `ngOnChanges` method will be invoked.
    This happens because the values of the title and caption properties will be set
    for the first time.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序初始化期间，如果 `"counter % 2 == 0"` 表达式的结果评估为 `true`，则将调用 `ngOnChanges` 方法。这是因为标题和标题属性值将首次被设置。
- en: Right after this, the `ngOnInit` method will be called, since the component
    has been initialized. Once the component's initialization is completed, the change
    detection will be triggered, which will lead to the invocation of the `ngDoCheck`
    method that allows us to hook custom logic for detecting changes in the state.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，将调用 `ngOnInit` 方法，因为组件已经被初始化。一旦组件的初始化完成，变更检测将被触发，这将导致调用允许我们挂钩自定义逻辑以检测状态变化的
    `ngDoCheck` 方法。
- en: After the `ngDoCheck` method, the change detector will perform a check on the
    component's content (`ngAfterContentInit` and `ngAfterContentChecked` will be
    invoked in this order). Right after this, the same will happen for the component's
    view (`ngAfterViewInit` followed by `ngAfterViewChecked`).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ngDoCheck` 方法之后，变更检测器将对组件的内容进行检查（将按顺序调用 `ngAfterContentInit` 和 `ngAfterContentChecked`）。紧接着，同样的事情也会发生在组件的视图中（`ngAfterViewInit`
    后跟 `ngAfterViewChecked`）。
- en: Once the expression of the `ngIf` directive is evaluated to `false`, the entire
    component will be detached from the view, which will lead to the invocation of
    the `ngOnDestroy` hook.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `ngIf` 指令的表达式评估为 `false`，整个组件将从视图中分离，这将导致调用 `ngOnDestroy` 钩子。
- en: On the next click, if the value of the expression of `ngIf` is equal to `true`,
    the same sequence of calls of the life cycle hooks as the one during the initialization
    phase will be executed.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次点击时，如果 `ngIf` 表达式的值为 `true`，则将执行与初始化阶段相同的生命周期钩子调用序列。
- en: Defining generic views with TemplateRef
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TemplateRef 定义通用视图
- en: 'We are already familiar with the concepts of inputs, content children, and
    view children, and we also know when we can get a reference to them in the component''s
    life cycle. Now, we will combine them and introduce a new concept: `TemplateRef`.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了输入、内容子项和视图子项的概念，也知道在组件的生命周期中何时可以获取它们的引用。现在，我们将它们结合起来，并介绍一个新概念：`TemplateRef`。
- en: 'Let''s take a step back and take a look at the last to-do application we developed
    earlier in this chapter. In the following screenshot, you can see what its UI
    looks like:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退后一步，回顾一下本章前面开发的最后一个待办事项应用程序。在下面的屏幕截图中，您可以查看其 UI 的外观：
- en: '![](img/3090e812-1395-45df-8dc1-33bf865f769d.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3090e812-1395-45df-8dc1-33bf865f769d.png)'
- en: Figure 9
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图9
- en: If we take a look at its implementation in `ch5/inputs-outputs/app.ts`, we'll
    see that the template used to render the individual to-do items is defined inside
    the template of the entire to-do application.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看其在`ch5/inputs-outputs/app.ts`中的实现，我们会看到用于渲染单个待办事项的模板是在整个待办应用模板内部定义的。
- en: What if we want to use a different layout to render the to-do items? We can
    do this by creating another component called `Todo`, which encapsulates the responsibility
    of rendering them. Then, we can define separate `Todo` components for the different
    layouts we want to support. This way, we need to have *n* different components
    for *n* different layouts, even though we need to change only their templates.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用不同的布局来渲染待办事项，我们可以通过创建另一个名为`Todo`的组件来实现，该组件封装了渲染它们的职责。然后，我们可以为想要支持的每个布局定义单独的`Todo`组件。这样，我们只需要为每个布局定义不同的组件，尽管我们只需要更改它们的模板。
- en: Angular comes with a more elegant solution. Earlier in this chapter, we have
    already discussed the `ng-template` element. Angular allows us to reference such
    `ng-template` elements and use them by passing them as content children.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了一个更优雅的解决方案。在本章的早期，我们已经讨论了`ng-template`元素。Angular允许我们引用这样的`ng-template`元素，并通过将它们作为内容子元素传递来使用它们。
- en: 'Here is how we can pass the custom layout to our refactored `TodoApp` component:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何将自定义布局传递给我们的重构`TodoApp`组件的：
- en: '[PRE71]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In the template, we declare a variable called `todo`; later in the template,
    we can use it to reference to the current to-do object.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们声明了一个名为`todo`的变量；在模板的后面部分，我们可以用它来引用当前的待办事项对象。
- en: 'Now, let''s take a look at how we can get a reference to this template in the
    controller of the `TodoApp` component:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在`TodoApp`组件的控制器中获取这个模板的引用：
- en: '[PRE72]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: All we do here is define a property called `itemsTemplate` and decorate it with
    the `@ContentChild` decorator. During the component's life cycle (more accurately,
    in `ngAfterContentInit`), the value of `itemsTemplate` will be set to a reference
    of the template that we passed as the content of the `todo-app` element.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是定义一个名为`itemsTemplate`的属性，并用`@ContentChild`装饰器装饰它。在组件的生命周期中（更准确地说，在`ngAfterContentInit`中），`itemsTemplate`的值将被设置为传递给`todo-app`元素内容的模板的引用。
- en: 'There is one more problem though: we need the template in the `TodoList` component,
    since that''s the place where we render the individual to-do items. What we can
    do is define another input of the `TodoList` component and pass the template directly
    from `TodoApp`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 但是还有一个问题：我们需要在`TodoList`组件中使用模板，因为那是渲染单个待办事项的地方。我们可以做的是定义`TodoList`组件的另一个输入，并直接从`TodoApp`传递模板：
- en: '[PRE73]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We need to pass it as an input from the template of `TodoApp`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从`TodoApp`的模板中传递它：
- en: '[PRE74]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The only thing left is to use this template reference in the template of the
    `TodoList` application:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是要在`TodoList`应用的模板中使用这个模板引用：
- en: '[PRE75]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We have explained the extended syntax of the `ngForOf` directive in the previous
    sections of this chapter. The preceding snippet shows one more property of this
    directive that we can set: the `template` property. By default, the template of
    the `ngForOf` directive is the element it is used on. By specifying a template
    reference we can use the passed `TemplateRef` class instead.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的前几节中已经解释了`ngForOf`指令的扩展语法。前面的代码片段展示了这个指令的一个更多属性，我们可以设置：`template`属性。默认情况下，`ngForOf`指令的模板是它所使用的元素。通过指定一个模板引用，我们可以使用传递的`TemplateRef`类。
- en: 'Let''s desugar the preceding syntax from even further:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步简化前面的语法：
- en: '[PRE76]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We pass the template that we want to use by setting the `[ngForTemplate]` input
    of the `NgForOf` directive, which we place on top of the `ng-template` element.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过设置`NgForOf`指令的`[ngForTemplate]`输入来传递我们想要使用的模板，我们将它放置在`ng-template`元素之上。
- en: 'The template declaration, on the other hand, looks like this:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，模板声明看起来是这样的：
- en: '[PRE77]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: There are a few things which look similar—we have `ng-template` in both places,
    as well as the `let-todo` binding. As we would expect, the `let-todo` attribute
    will bind the current to-do item to the `todo` variable. Notice that we do not
    set any value to the `let-todo` attribute; this will implicitly bind the `todo`
    variable to the `$implicit` property of the context of the `NgForOf` directive
    (that is, `NgForOfContext`). In fact, we don't need to keep the attribute names
    the same, for example, in the external template we pass to `NgForOf`, we can use
    `let-current` and we will get the exact same behavior. As soon as we don't set
    a value to this attribute, Angular will assign it to the `$implicit` property
    of the context.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些看起来相似的东西——我们在这两个地方都有 `ng-template`，以及 `let-todo` 绑定。正如我们所期望的，`let-todo` 属性将当前待办事项绑定到
    `todo` 变量。请注意，我们没有为 `let-todo` 属性设置任何值；这将隐式地将 `todo` 变量绑定到 `NgForOf` 指令上下文的 `$implicit`
    属性（即 `NgForOfContext`）。实际上，我们不需要保持属性名称相同，例如，在传递给 `NgForOf` 的外部模板中，我们可以使用 `let-current`，我们将得到完全相同的行为。一旦我们不设置此属性的值，Angular
    将将其分配给上下文的 `$implicit` 属性。
- en: 'The context though, provides few more properties: `index` (index of the current
    element we''re iterating over), `even` (if the current index is an even number),
    `odd` (if the current index is an odd number), and others. If we want to get access
    to any of them within our `TemplateRef` class, we need to change its declaration
    to the following:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，上下文还提供了更多属性：`index`（正在迭代的当前元素的索引）、`even`（如果当前索引是偶数）、`odd`（如果当前索引是奇数）以及其他属性。如果我们想在
    `TemplateRef` 类中访问它们，我们需要将其声明更改为以下内容：
- en: '[PRE78]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This way, we can associate the `index` property provided by `NgForOfContext`
    to the `i` variable in our `TemplateRef`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以将 `NgForOfContext` 提供的 `index` 属性关联到我们的 `TemplateRef` 中的 `i` 变量。
- en: Now let's continue our journey by exploring the Angular's change detection mechanism!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续我们的旅程，通过探索 Angular 的变更检测机制来继续前进！
- en: Understanding and enhancing the change detection
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和增强变更检测
- en: We have already briefly described the change detection mechanism of the framework.
    We said that compared with AngularJS, where it runs in the context of the *scope*,
    in Angular, it runs in the context of the individual components. Another concept
    we mentioned is the zones, which basically intercept all the asynchronous calls
    that we make using the browser APIs and provide execution context for the change
    detection mechanism of the framework. Zones fix the annoying problem that we have
    in AngularJS, where when we use APIs outside of Angular, we needed to explicitly
    invoke the `digest` loop.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简要描述了框架的变更检测机制。我们说，与在 *scope* 上下文中运行的 AngularJS 相比，在 Angular 中，它是运行在单个组件的上下文中的。我们提到的另一个概念是区域，它基本上拦截我们使用浏览器
    API 所做的所有异步调用，并为框架的变更检测机制提供执行上下文。区域解决了 AngularJS 中令人烦恼的问题，即当我们使用 Angular 之外的 API
    时，我们需要显式调用 `digest` 循环。
- en: In [Chapter 2](ced71b5c-e25d-4781-8aab-81ef0a053b14.xhtml), *Get Going with
    Angular* and [Chapter 3](7bc2aa38-2853-468a-8e03-c25387eb03aa.xhtml), *The Building
    Blocks of an Angular Application*, we discussed that the code that performs change
    detection over our components is being generated, either runtime (**just-in-time**)
    or as part of our build process (**ahead-of-time**). AOT compilation works great
    for environments with strict **CSP** (short for, **Content-Security-Policy**)
    because of the disabled dynamic evaluation of JavaScript; it also provides much
    better performance since Angular will not have to compile the components' templates.
    We will explain it in detail in [Chapter 9](b9d6c03a-d141-4201-afc6-339a41a38715.xhtml)*,
    Tooling and Development Experience*.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ced71b5c-e25d-4781-8aab-81ef0a053b14.xhtml)《开始使用 Angular》和[第三章](7bc2aa38-2853-468a-8e03-c25387eb03aa.xhtml)《Angular
    应用程序的构建块》中，我们讨论了执行组件变更检测的代码是在运行时（**即时**）还是作为我们的构建过程（**提前**）的一部分被生成的。AOT 编译在具有严格
    **CSP**（即 **内容安全策略**）的环境下表现良好，因为禁用了 JavaScript 的动态评估；它还提供了更好的性能，因为 Angular 不必编译组件的模板。我们将在[第九章](b9d6c03a-d141-4201-afc6-339a41a38715.xhtml)《工具和开发体验》中详细解释。
- en: In this section, we'll explore another property of the `@Component` decorator's
    configuration object, which provides us further control over the change detection
    mechanism of the framework by changing its strategy. By explicitly setting the
    strategy, we are able to prevent the change detection mechanism from running over
    a component's subtrees, which in some cases can bring great performance benefits.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨`@Component`装饰器的配置对象另一个属性，它通过更改策略提供进一步的控制，从而对框架的变更检测机制进行控制。通过显式设置策略，我们能够防止变更检测机制在组件的子树中运行，在某些情况下可以带来极大的性能提升。
- en: The order of execution of the change detectors
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更检测器的执行顺序
- en: Now, let's briefly describe the order in which the change detectors are invoked
    in a given component tree.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要描述在给定组件树中调用变更检测器的顺序。
- en: 'For this purpose, we will use the last implementation of the to-do application
    we have, but this time, we''ll extract the logic to render the individual to-do
    items into a separate component called `TodoItem`. In the following diagram, we
    can see the application''s structure, also known as, component tree:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将使用我们已有的待办应用最后的一个实现，但这次，我们将渲染单个待办事项的逻辑提取到一个名为`TodoItem`的单独组件中。在下面的图中，我们可以看到应用程序的结构，也称为组件树：
- en: '![](img/b2dbd1f0-8a02-434d-b064-c681d41ba564.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2dbd1f0-8a02-434d-b064-c681d41ba564.png)'
- en: Figure 10
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 图10
- en: 'At the top level is the `TodoApp` component, which has two children: `InputBox`
    and `TodoList`. The `TodoList` component renders the individual to-do items using
    the `TodoItem` components. The implementation details are not important for our
    purpose, so we will ignore them.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶层是`TodoApp`组件，它有两个子组件：`InputBox`和`TodoList`。`TodoList`组件使用`TodoItem`组件渲染单个待办事项。对于我们的目的，实现细节并不重要，所以我们将其忽略。
- en: 'Now, we need to realize that there is an implicit dependency between the state
    of the parent component and its children. For instance, the state of the `TodoList`
    component depends completely on the to-do items that are located at its parent:
    the `TodoApp` component. There''s a similar dependency between `TodoItem` and
    `TodoList` since the `TodoList` component passes the individual to-do items to
    a separate instance of the `TodoItem` component. This means that if the list of
    to-do items in `TodoList` changes, this will automatically reflect some of the
    `TodoItem` components:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要认识到父组件的状态与其子组件之间存在隐式依赖关系。例如，`TodoList`组件的状态完全依赖于其父组件`TodoApp`中定位的待办事项。`TodoItem`和`TodoList`之间也存在类似的依赖关系，因为`TodoList`组件将单个待办事项传递给`TodoItem`组件的单独实例。这意味着如果`TodoList`中的待办事项列表发生变化，这将自动反映一些`TodoItem`组件：
- en: '![](img/fb1f6569-5a5e-4efd-b07a-58f492fcdea0.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb1f6569-5a5e-4efd-b07a-58f492fcdea0.png)'
- en: Figure 11
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图11
- en: Owing to our last observation, the order of execution of the change detectors
    attached to the individual components is like the one shown in the preceding figure.
    Once the change detection mechanism runs, initially it will perform a check over
    the `TodoApp` component. Right after this, the `InputBox` component will be checked
    for changes, followed by the `TodoList` component. In the end, Angular will invoke
    the change detector of the `TodoItem` component.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前的观察，附加到各个组件上的变更检测器的执行顺序类似于前面图示中的顺序。一旦变更检测机制运行，最初它将对`TodoApp`组件进行检查。紧接着，将检查`InputBox`组件的变更，然后是`TodoList`组件。最后，Angular将调用`TodoItem`组件的变更检测器。
- en: You can trace the order of execution in the `ch5/change_detection_strategy_order/app.ts`
    example, where each individual component logs a message once its `ngDoCheck` method
    is invoked.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`ch5/change_detection_strategy_order/app.ts`示例中追踪执行顺序，其中每个组件在其`ngDoCheck`方法被调用时都会记录一条消息。
- en: Note that only the components have an instance of a change detector attached
    to them; directives use the change detector of their parent component.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有组件才有附加变更检测器的实例；指令使用其父组件的变更检测器。
- en: Understanding Angular's change detection strategies
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Angular的变更检测策略
- en: The change detection strategies that Angular provides are `Default` and `OnPush`.
    We will describe how we can take advantage of `OnPush` in detail, since it is
    very powerful when working with immutable data.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供的变更检测策略有`Default`和`OnPush`。我们将详细描述如何利用`OnPush`，因为它在处理不可变数据时非常强大。
- en: 'Now, let''s import the TypeScript enum, which can be used to configure the
    strategy used for the individual components:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们导入TypeScript枚举，它可以用来配置用于单个组件的策略：
- en: '[PRE79]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, we can configure the `TodoList` component to use the `OnPush` strategy:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以配置`TodoList`组件使用`OnPush`策略：
- en: '[PRE80]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This way, the change detection will be skipped until the component doesn't receive
    inputs that have different values. Note that comparison uses equality check, which
    means that it'll compare primitive types by their value and objects by comparing
    their references. You can go to [http://localhost:5555/dist/dev/ch5/change_detection_strategy_broken/](http://localhost:5555/dist/dev/ch5/change_detection_strategy_broken/)
    and see the inconsistent behavior of the `TodoList` component. When you add a
    new to-do item in the input and click on the Add button, it won't immediately
    appear in the list.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，变更检测将跳过，直到组件接收到具有不同值的输入。请注意，比较使用的是相等检查，这意味着它将通过值比较基本类型，通过引用比较对象。您可以访问[http://localhost:5555/dist/dev/ch5/change_detection_strategy_broken/](http://localhost:5555/dist/dev/ch5/change_detection_strategy_broken/)并查看`TodoList`组件的不一致行为。当您在输入中添加一个新的待办事项并在添加按钮上点击时，它不会立即出现在列表中。
- en: By default, the change detection will always check for changes.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，变更检测将始终检查变更。
- en: Introducing immutable data structures and OnPush
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍不可变数据结构和OnPush
- en: Now, we will describe the `OnPush` change detection strategy. It is extremely
    useful when the result that the given component produces depends only on its inputs.
    In such cases, we can pass an immutable data to its inputs in order to make sure
    that it will not be mutated by any component. This way, by having a component
    that depends only on its immutable inputs and doesn't produce any side effects,
    we can make sure that it produces different user interfaces only once it receives
    different inputs (that is, with different references).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将描述`OnPush`变更检测策略。当给定组件产生的结果仅依赖于其输入时，它非常有用。在这种情况下，我们可以向其输入传递不可变数据，以确保它不会被任何组件修改。这样，通过拥有仅依赖于其不可变输入且不产生任何副作用组件，我们可以确保它仅在接收到不同的输入（即不同的引用）时才产生不同的用户界面。
- en: In this section, we will apply the `OnPush` strategy to the `TodoList` component.
    Since it depends only on its inputs (the `todos` input), we want to make sure
    that its change detection will be performed only once it receives a new reference
    of the `todos` collection.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将`OnPush`策略应用于`TodoList`组件。由于它仅依赖于其输入（`todos`输入），我们想要确保其变更检测仅在接收到`todos`集合的新引用时执行。
- en: The essence of an immutable data is that it cannot change. This means that once
    we create the `todos` collection, we cannot change it; instead, the `add` (or,
    in our case, `push`) method will return a new collection—a *copy* of the initial
    collection with the new item included.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据的核心是它不能改变。这意味着一旦我们创建了`todos`集合，我们就不能改变它；相反，`add`（或在我们的情况下，`push`）方法将返回一个新的集合——包含新项目的初始集合的副本。
- en: This may seem like a huge overhead to copy the entire collection on each change.
    In big applications, this may have a big performance impact. However, we don't
    need to copy the entire collection. There are libraries that implement the immutable
    data structure using smarter algorithms, for example, persistent data structures.
    Persistent data structures are beyond the scope of the current content. Further
    information about them can be found in most computer science textbooks for advanced
    data structures. The good thing is that we don't have to understand their implementation
    in depth in order to use them. There is a library called `Immutable.js` that implements
    a few commonly used immutable data structures. In our case, we will use the immutable
    list. Generally, the immutable list behaves just like a normal list, but on each
    operation that is supposed to mutate it, it returns a new immutable list.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来在每个变更时复制整个集合是一个巨大的开销。在大应用中，这可能会对性能产生重大影响。然而，我们不需要复制整个集合。有一些库使用更智能的算法实现不可变数据结构，例如持久数据结构。持久数据结构超出了当前内容的范围。关于它们的信息可以在大多数计算机科学教科书中找到，特别是关于高级数据结构的部分。好事是，我们不需要深入理解它们的实现就可以使用它们。有一个名为`Immutable.js`的库实现了几个常用的不可变数据结构。在我们的情况下，我们将使用不可变列表。通常，不可变列表的行为就像一个普通列表，但在每个应该修改它的操作中，它都会返回一个新的不可变列表。
- en: 'This means that if we have a list called `foo`, which is immutable, and append
    a new item to the list, we will get a new reference:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们有一个名为 `foo` 的不可变列表，并向列表中添加一个新项目，我们将得到一个新的引用：
- en: '[PRE81]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In order to take advantage of immutability, we will need to install `Immutable.js`
    using `npm`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用不可变性，我们需要使用 `npm` 安装 `Immutable.js`。
- en: The library is already a part of the project that contains the code for the
    book. You can find a reference to `Immutable.js` in `package.json`, located in
    the root of the project. You can take a look at `ch5/change_detection_strategy/app.ts`
    to see how we include the immutable collections in our TypeScript application.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 该库已经是包含书籍代码的项目的一部分。你可以在项目的根目录下的 `package.json` 中找到 `Immutable.js` 的引用。你可以查看
    `ch5/change_detection_strategy/app.ts` 来了解我们如何在 TypeScript 应用程序中包含不可变集合。
- en: Now, it's time to refactor our to-do application and make it use immutable data.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候重构我们的待办事项应用程序并使其使用不可变数据了。
- en: Using immutable data in Angular
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Angular 中使用不可变数据
- en: 'Let''s take a look at how we currently keep the to-do items in the `TodoApp`
    component:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们目前如何在 `TodoApp` 组件中保持待办事项：
- en: '[PRE82]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We use an array of `Todo` items. The JavaScript array is mutable, which means
    that if we pass it to a component that uses the `OnPush` strategy, it is not safe
    to skip the change detection in case we get the same input reference. For instance,
    we may have two components that use the same list of to-do items. Both components
    can modify the list since it is mutable. This will lead to an inconsistent state
    for any of the components in case their change detection is not performed. That''s
    why we need to make sure that the list that holds the items is immutable. All
    we need to do in the `TodoApp` component in order to make sure that it holds its
    data in an immutable data structure is this:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Todo` 项的数组。JavaScript 数组是可变的，这意味着如果我们将其传递给使用 `OnPush` 策略的组件，在得到相同的输入引用时跳过更改检测是不安全的。例如，我们可能有使用相同待办事项列表的两个组件。由于列表是可变的，这两个组件都可以修改列表。这将在不执行更改检测的情况下导致任何组件的不一致状态。这就是为什么我们需要确保包含项目的列表是不可变的。为了确保
    `TodoApp` 组件以不可变数据结构持有其数据，我们只需在 `TodoApp` 组件中做以下操作：
- en: '[PRE83]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In this way, we construct the `todos` property as an immutable list, which contains
    immutable objects; all we need to do is to invoke the function `fromJS` exported
    by `Immutable.js`. It will recursively turn any JavaScript object into an immutable
    object.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们将 `todos` 属性构建为一个包含不可变对象的不可变列表；我们所需做的只是调用由 `Immutable.js` 导出的函数 `fromJS`。它将递归地将任何
    JavaScript 对象转换为不可变对象。
- en: 'Next, since the mutation operations of the immutable list return a new list,
    we need to make a slight modification in `addTodo` and `toggleTodoCompletion`:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，由于不可变列表的变异操作返回一个新的列表，我们需要在 `addTodo` 和 `toggleTodoCompletion` 方法中做一点修改：
- en: '[PRE84]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `addTodo` function looks exactly the same as before, except that we set
    the result of the `push` method as a value to the `todos` property.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`addTodo` 函数看起来与之前完全相同，只是我们将 `push` 方法的返回结果设置为 `todos` 属性的值。'
- en: In `toggleTodoCompletion`, we use the `update` method of the immutable list.
    As the first argument, we pass the index of the to-do item we want to modify,
    and the second argument is a callback that does the actual modification. Note
    that since we use immutable data in this case, we copy the modified to-do item.
    This is required because it tells the `update` method that the item with the given
    index has been changed (since it is immutable, it is considered as changed only
    when it has a new reference), which means that the entire list has been changed.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `toggleTodoCompletion` 中，我们使用不可变列表的 `update` 方法。作为第一个参数，我们传递要修改的待办事项的索引，第二个参数是一个执行实际修改的回调函数。请注意，由于在这种情况下我们使用不可变数据，我们复制了修改后的待办事项。这是必需的，因为它告诉
    `update` 方法，给定索引的项目已被更改（由于它是不可变的，只有当它有一个新的引用时才被认为是更改），这意味着整个列表已更改。
- en: 'This was the complex part! Now, let''s take a look at the `TodoList` component''s
    definition:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分很复杂！现在，让我们看看 `TodoList` 组件的定义：
- en: '[PRE85]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Finally, we need to modify the way we access the properties of the immutable
    to-do items inside the templates:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要修改我们在模板中访问不可变待办事项属性的方式：
- en: '[PRE86]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The change we made here is that instead of using direct property access, such
    as `todo.completed`, we invoke the `get` method of the object by passing the property
    name associated with the value we want to get, in this case `"completed"`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的修改是，而不是使用直接属性访问，例如 `todo.completed`，我们通过传递与我们要获取的值相关的属性名来调用对象的 `get`
    方法，在这种情况下是 `"completed"`。
- en: Inside the `@Component` decorator, we set the `changeDetection` property to
    the value of the `OnPush` strategy. This means that the component will run its
    change detector only when any of its inputs gets a new reference. Everything else,
    except the property access, inside of the template of the component stays exactly
    the same since `ngForOf` internally uses ES2015 iterators to loop over the items
    in the provided collection. They are supported by `Immutable.js`, so no changes
    in the template are required.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@Component`装饰器内部，我们将`changeDetection`属性设置为`OnPush`策略的值。这意味着组件只有在任何输入获得新引用时才会运行其变更检测器。由于`ngForOf`内部使用ES2015迭代器遍历提供的集合中的项，并且由`Immutable.js`支持，因此组件模板内的其他一切（除了属性访问）都保持完全相同，无需对模板进行任何更改。
- en: Since we need the index of the changed item instead of its reference (the one
    we use in the `update` method of the `todos` collection in `TodoApp`), we change
    the type of the output of the component to `EventEmitter<number>`. In `toggleCompletion`,
    we emit the index of the changed to-do item.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要更改项的索引而不是其引用（我们在`TodoApp`的`todos`集合的`update`方法中使用的那种），我们将组件输出的类型更改为`EventEmitter<number>`。在`toggleCompletion`中，我们发出更改的待办事项项的索引。
- en: This is how we optimized our simple to-do application by preventing the change
    detection mechanism from running in the entire right subtree, in case the parent
    component hasn't pushed an input with a new reference.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是通过防止在父组件未推送带有新引用的输入时，在整个右侧子树中运行变更检测机制，我们优化了我们的简单待办事项应用的方式。
- en: Summary
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we went through the core building blocks of an Angular application:
    directives and components. We built a couple of sample components, which showed
    us the syntax to be used for the definition of these fundamental concepts. We
    also described the life cycle of each directive and the core set of features the
    given directive and component have. As the next step, we saw how we can enhance
    the performance of our application using the `OnPush` change detection strategy
    with an immutable data.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Angular应用程序的核心构建块：指令和组件。我们构建了一些示例组件，这展示了定义这些基本概念所使用的语法。我们还描述了每个指令的生命周期以及给定指令和组件的核心功能集。作为下一步，我们看到了如何使用不可变数据通过`OnPush`变更检测策略来提高我们应用程序的性能。
- en: The next chapter is completely dedicated to the Angular services and the dependency
    injection mechanism of the framework. We will take a look at how we can define
    and instantiate custom injectors and how we can take advantage of the dependency
    injection mechanism in our directives and components.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章完全致力于Angular服务和框架的依赖注入机制。我们将探讨如何定义和实例化自定义注入器，以及我们如何在我们的指令和组件中利用依赖注入机制。
