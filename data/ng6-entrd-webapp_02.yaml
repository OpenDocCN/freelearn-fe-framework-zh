- en: Create a Local Weather Web Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建本地天气Web应用程序
- en: In this chapter, we will be designing and building a simple Local Weather app
    with Angular and a third-party web API, using an iterative development methodology.
    You will focus on delivering value first, while learning about the nuances and
    optimal ways of using Angular, TypeScript, Visual Studio Code, Reactive Programming,
    and RxJS. Before we dive into coding, we will go over the philosophy behind Angular
    and ensure that your development environment is optimized and can enable collaboration
    and effortless information radiation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用迭代开发方法设计和构建一个简单的本地天气应用程序，使用Angular和第三方Web API。您将专注于首先提供价值，同时学习使用Angular、TypeScript、Visual
    Studio Code、响应式编程和RxJS的微妙之处和最佳方式。在我们开始编码之前，我们将介绍Angular背后的哲学，并确保您的开发环境经过优化，可以实现协作和轻松的信息辐射。
- en: Each section of this chapter will introduce you to new concepts, best practices,
    and optimal ways of leveraging these technologies and cover the bases to close
    any knowledge gaps you may have about web and modern JavaScript development basics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的每个部分都将向您介绍新概念、最佳实践和利用这些技术的最佳方式，并涵盖关闭您可能对Web和现代JavaScript开发基础知识的任何知识空白的基础知识。
- en: In this chapter, you will learn Angular fundamentals to build a simple web app
    and become familiar with the new Angular platform and full-stack architecture.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习Angular的基础知识，以构建一个简单的Web应用程序，并熟悉新的Angular平台和全栈架构。
- en: 'In this chapter, you will learn the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学到以下内容：
- en: Get introduced to Angular and the philosophy behind it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Angular及其背后的哲学
- en: Configuring a repository with an optimal folder structure for full-stack development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为全栈开发配置具有最佳文件夹结构的存储库
- en: Using Angular CLI to generate your Angular web application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular CLI生成您的Angular Web应用程序
- en: Optimizing Visual Code for Angular & TypeScript development
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化Visual Code以进行Angular和TypeScript开发
- en: Planning out your roadmap using Waffle as a GitHub-connected Kanban board
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Waffle作为与GitHub连接的看板板来规划您的路线图
- en: Crafting a new UI element to display current weather information using components
    and interfaces
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打造一个新的UI元素来显示当前天气信息，使用组件和接口
- en: Using Angular Services and HttpClient to retrieve data from OpenWeatherMap APIs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular服务和HttpClient从OpenWeatherMap API检索数据
- en: Leveraging observable streams to transform data using RxJS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用可观察流使用RxJS转换数据
- en: 'The code samples provided in this book require Angular version 5 and 6\. Angular
    5 code is runtime compatible with Angular 6\. Angular 6 will be supported in LTS
    until October 2019\. The most up-to-date versions of the code repositories may
    be found at the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的代码示例需要使用Angular 5和6版本。Angular 5的代码与Angular 6兼容。Angular 6将在LTS中得到支持，直到2019年10月。代码存储库的最新版本可以在以下位置找到：
- en: For Chapters 2 to 6, LocalCast Weather, at: [Github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第2到6章，LocalCast Weather，请访问：[Github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
- en: For Chapters 7 to 12, LemonMart, at: [Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第7到12章，LemonMart，请访问：[Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
- en: Introduction to Angular
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Angular
- en: Angular is an open source project maintained by Google and a community of developers.
    The new Angular platform is vastly different from the legacy framework you may
    have used in the past. A collaboration with Microsoft makes TypeScript, which
    is a superset of JavaScript, the default development language, enabling developers
    to target legacy browsers such as Internet Explorer 11, while writing modern JavaScript
    code that is supported in evergreen browsers such as Chrome, Firefox, and Edge.
    The legacy versions of Angular, versions in the 1.x.x range, are now referred
    to as AngularJS. Version 2.0.0 and higher versions are simply called Angular. Where
    AngularJS is a monolithic JavaScript **Single Page Application** (**SPA**) framework,
    Angular is a platform that is capable of targeting browsers, hybrid-mobile frameworks,
    desktop applications, and server-side rendered views.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是由谷歌和一群开发者社区维护的开源项目。新的Angular平台与您过去可能使用过的遗留框架大不相同。与微软的合作使得TypeScript成为默认的开发语言，它是JavaScript的超集，使开发者能够针对旧版浏览器（如Internet
    Explorer 11）编写现代JavaScript代码，同时在Chrome、Firefox和Edge等最新浏览器中得到支持。Angular的遗留版本，即1.x.x范围内的版本，现在被称为AngularJS。2.0.0及更高版本简称为Angular。AngularJS是一个单页应用程序（SPA）框架，而Angular是一个能够针对浏览器、混合移动框架、桌面应用程序和服务器端渲染视图的平台。
- en: Each minor version increment in AngularJS meant risky updates with costly deprecations and
    major new features delivered at uncertain intervals. This led to an unpredictable,
    ever evolving framework with seemingly no guiding hand to carry code bases forward.
    If you used AngularJS, you likely got stuck on a particular version, because the
    specific architecture of your code base made it very difficult to move to a new
    version. In the spring/summer of 2018, the last major update to AngularJS will
    be released with version 1.7\. This release will mark the beginning of the end
    for the legacy framework, with a planned end-of-life in July 2021.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS中，每个次要版本增量都意味着风险更新，伴随着昂贵的废弃和不确定间隔的主要新功能。这导致了一个不可预测的、不断发展的框架，似乎没有指导手来推动代码库向前发展。如果你使用过AngularJS，你可能会卡在一个特定的版本上，因为你的代码库的特定架构使得很难迁移到新版本。在2018年春/夏季，AngularJS的最后一个主要更新将发布版本1.7。这个发布将标志着这个遗留框架的终结，计划在2021年7月终止支持。
- en: 'Angular improves upon AngularJS in every way imaginable. The platform follows
    semver, as defined at [https://semver.org/](https://semver.org/), where minor
    version increments denote new feature additions and potential deprecation notices
    for the second next major version, but no breaking changes. Furthermore, the Angular
    team at Google has committed to a deterministic release schedule for major version
    increments to be released every 6 months. After this 6-month development window,
    starting with Angular 4, all major releases receive **long-term support** (**LTS**)
    with bug fixes and security patches for an additional 12 months. From release
    to end-of-life, each major version is supported for 18 months. Refer to the following
    chart for the tentative release and support schedule for AngularJS and Angular:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在各个方面都比AngularJS有所改进。该平台遵循语义版本控制，如[https://semver.org/](https://semver.org/)所定义，其中次要版本增量表示新功能添加和可能废弃通知的第二个下一个主要版本，但不会有破坏性的变化。此外，谷歌的Angular团队已经承诺了一个确定的发布计划，每6个月发布一次主要版本增量。从Angular
    4开始，在这6个月的开发窗口之后，所有主要版本都将获得长期支持（LTS），为期12个月的错误修复和安全补丁。从发布到终止支持，每个主要版本都将获得18个月的支持。请参考以下图表，了解AngularJS和Angular的暂定发布和支持计划：
- en: '![](Images/bbf1891b-b82c-4980-81fb-98864e5e4312.png)Tentative Angular Release
    and Support Schedule'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/bbf1891b-b82c-4980-81fb-98864e5e4312.png)暂定的Angular发布和支持计划'
- en: So, what does this mean for you? You can be confident that the code you write
    in Angular will be supported and backwards compatible for an approximate time
    frame of 24 months, even if you make no changes to it. So, if you wrote an Angular
    app in version 4 in April 2017, your code is now runtime compatible with Angular
    5, which itself is supported until April 2019\. In order to upgrade your Angular
    4 code to Angular 6, you will need to ensure that you're not using any of the
    deprecated APIs that were announced as deprecated in Angular 5\. In reality, the
    deprecations are minor and unless you are working with low-level APIs for a highly
    specialized user experience, the time and effort it takes to update your code
    base should be minimal. However, this is a promise made by Google and not a contract.
    The Angular team has a major incentive to ensure backwards compatibility, because
    Google runs around 600+ Angular apps with a single version of Angular active at
    any one time throughout the organization. This means, by the time you read this,
    all of those 600+ apps will be running in Angular 6\. You may think Google has
    infinite resources to make this happen, but like any other organization, they
    too have limited resources and not every app is actively maintained with a dedicated
    team. This means the Angular team must ensure compatibility through automated
    tests and make it as painless as possible to move through major releases going
    forward. In Angular 6, the update process was made much easier with the introduction
    of `ng update`. In the future, the team will release automated CLI tools to make
    upgrades of deprecated functionality a reasonable endeavor.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这对你意味着什么呢？你可以放心，你在 Angular 中编写的代码将在大约 24 个月的时间范围内得到支持，并且向后兼容，即使你对其不做任何更改。因此，如果你在
    2017 年 4 月编写了一个 Angular 4 版本的应用程序，你的代码现在可以在 Angular 5 中运行，而 Angular 5 本身将在 2019
    年 4 月之前得到支持。要将你的 Angular 4 代码升级到 Angular 6，你需要确保你没有使用在 Angular 5 中宣布为废弃的任何 API。实际上，这些废弃的内容很少，除非你正在使用低级别的
    API 来实现高度专业化的用户体验，否则更新代码库所需的时间和精力应该是最小的。然而，这是谷歌所做出的承诺，而不是一份合同。Angular 团队有很大的动力来确保向后兼容，因为谷歌在整个组织中运行着
    600 多个 Angular 应用程序，每次只有一个版本的 Angular 处于活动状态。这意味着，当你阅读这篇文章时，所有这 600 多个应用程序都将在
    Angular 6 中运行。你可能认为谷歌有无限的资源来实现这一点，但像任何其他组织一样，他们也有有限的资源，并非每个应用程序都有专门的团队进行积极维护。这意味着
    Angular 团队必须通过自动化测试来确保兼容性，并尽可能地减少未来的主要版本更新所需的工作量。在 Angular 6 中，通过引入 `ng update`，更新过程变得更加简单。未来，团队将发布自动化的
    CLI 工具，以使废弃功能的升级成为一个合理的努力。
- en: 'This is great news for developers and organizations alike. Now, instead of
    being perpetually stuck on a legacy version of Angular, you can actually plan
    and allocate the necessary resources to keep moving your application to the future
    without costly rewrites. As I wrote in a 2017 blog post, *The Best New Feature
    of Angular 4*, at [bit.ly/NgBestFeature](http://bit.ly/NgBestFeature), the message
    is clear:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这对开发人员和组织来说都是个好消息。现在，你不必永远停留在 Angular 的旧版本上，而是可以计划并分配必要的资源，将你的应用程序移向未来，而无需进行昂贵的重写。正如我在
    2017 年的一篇博客文章中所写的那样，《Angular 4 的最佳新功能》，链接在 [bit.ly/NgBestFeature](http://bit.ly/NgBestFeature)，信息很明确：
- en: '**For Developers & Managers: **Angular is here to stay, so you should be investing
    your time, attention, and money in learning it – even if you’re currently in love
    with some other framework.**For Decision Makers (CIOs, CTOs, etc.): **Plan to
    begin your transition to Angular in the next 6 months. It’ll be an investment
    you’ll be able to explain to business minded people, and your investment will
    pay dividends for many years to come, long after the initial LTS window expires,
    with graceful upgrade paths to Angular vNext and beyond.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于开发人员和经理：**Angular会一直存在，所以你应该投入时间、注意力和金钱来学习它-即使你目前热爱其他框架。**对于决策者（CIO，CTO等）：**计划在接下来的6个月内开始过渡到Angular。这将是一个可以向商业人士解释的投资，并且您的投资将在最初的LTS窗口到期后的多年内产生回报，具有优雅的升级路径到Angular
    vNext及更高版本。'
- en: So, why does Google (Angular) and Microsoft (TypeScript, Visual Studio Code)
    give away such technologies for free? There are multiple reasons, some including
    demonstration of technical proves to retain and attract talent, proving and debugging
    new ideas and tools with millions of developers at scale, and ultimately allowing
    developers to more easily create great web experiences that ultimately drive more
    business for Google and Microsoft. I personally don't see any nefarious intent
    here and welcome open, mature, and high-quality tools that I can tinker with and
    bend to my own will, if necessary, and not have to pay for a support contract
    for a proprietary piece of tech.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么谷歌（Angular）和微软（TypeScript，Visual Studio Code）免费提供这样的技术？有多种原因，其中一些包括展示技术证明以留住和吸引人才，通过与数百万开发人员一起验证和调试新的想法和工具，并最终使开发人员更容易地创建出色的网络体验，从而为谷歌和微软带来更多业务。我个人认为这里没有任何恶意意图，并且欢迎开放、成熟和高质量的工具，我可以随意摆弄并根据自己的意愿进行调整，如果必要的话，而不必为专有技术的支持合同付费。
- en: Beware, looking for Angular help on the web may be tricky. You'll note that
    most of the time, Angular is referred to as Angular 2 or Angular 4\. At times,
    both Angular and AngularJS are simply referred to as AngularJS. This, of course,
    is incorrect. The documentation for Angular is at [angular.io](https://angular.io). If
    you land on [angularjs.org](https://angularjs.org/), you'll be reading about the
    legacy AngularJS framework.For the latest updates on the upcoming Angular releases,
    view the official Release Schedule at: [Github.com/angular/angular/blob/master/docs/RELEASE_SCHEDULE.md](https://github.com/angular/angular/blob/master/docs/RELEASE_SCHEDULE.md).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在网上寻找Angular帮助可能会有些棘手。您会注意到大多数时候，Angular被称为Angular 2或Angular 4。有时，Angular和AngularJS都简称为AngularJS。当然，这是不正确的。Angular的文档在[angular.io](https://angular.io)。如果您登陆[angularjs.org](https://angularjs.org/)，您将看到有关传统AngularJS框架的信息。有关即将发布的Angular版本的最新更新，请查看官方发布计划：[Github.com/angular/angular/blob/master/docs/RELEASE_SCHEDULE.md](https://github.com/angular/angular/blob/master/docs/RELEASE_SCHEDULE.md)。
- en: Angular's philosophy
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular的哲学
- en: The philosophy behind Angular is to err on the side of configuration over convention.
    Convention-based frameworks, although may seem elegant from the outside, make
    it really difficult for newcomers to pick up the framework. Configuration-based
    frameworks, however, aim to expose their inner workings through explicit configuration
    elements and hooks, where you can attach your custom behavior to the framework.
    In essence, Angular tries to be non-magical, where AngularJS was a lot of magic.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的哲学是在配置和约定之间犯错误。基于约定的框架，虽然从外部看起来可能很优雅，但对新手来说很难掌握框架。然而，基于配置的框架旨在通过显式配置元素和钩子公开其内部工作原理，您可以将自定义行为附加到框架上。实质上，Angular试图不那么神奇，而AngularJS则有很多魔力。
- en: This results in a lot of verbose coding. This is a good thing. Terse code is
    the enemy of maintainability, only benefiting the original author. However, as
    Andy Hunt and David Thomas put it in the Pragmatic Programmer,
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了大量冗长的编码。这是件好事。简洁的代码是可维护性的敌人，只有原始作者受益。然而，正如Andy Hunt和David Thomas在《实用程序员》中所说的，
- en: Remember that you (and others after you) will be reading the code many hundreds
    of times, but only writing it a few times.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你（以及之后的人）将会读取代码很多次，但只会写入几次。
- en: Verbose, decoupled, cohesive, and encapsulated code is the key to future proofing
    your code. Angular, through its various mechanisms, enables the proper execution
    of these concepts. It gets rid of many custom conventions invented in AngularJS,
    such as `ng-click`, and introduces a more intuitive language that builds on the
    existing HTML elements and properties. As a result, `ng-click` becomes `(click)`,
    extending HTML rather than replacing it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 冗长、解耦、内聚和封装的代码是未来保护你的代码的关键。Angular通过其各种机制，实现了这些概念的正确执行。它摒弃了在AngularJS中发明的许多自定义约定，比如`ng-click`，并引入了一个更直观的语言，建立在现有的HTML元素和属性之上。因此，`ng-click`变成了`(click)`，扩展了HTML而不是替换它。
- en: What's new in Angular 6?
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 6有什么新功能？
- en: 'Most, if not all, of the content, patterns, and practices in this book are
    compatible with Angular 4 and up. Angular 6 is the latest version of Angular,
    which brings a lot of under-the-cover improvements to the platform and overall
    stability and cohesion across the ecosystem. The development experience is being
    vastly improved with additional CLI tools that make it easier to update versions
    of packages and faster build times to improve your code-build-view feedback cycle.
    With Angular 6, all platform tools are version synced to 6.0, making it easier
    to reason about the ecosystem. In the following chart, you can see how this makes
    it easier to communicate tooling compatibility:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大部分内容、模式和实践都与Angular 4及以上版本兼容。Angular 6是最新版本的Angular，为平台带来了许多底层改进，提高了整体稳定性和生态系统的内聚性。通过额外的CLI工具，开发体验得到了极大的改善，这些工具使得更新软件包版本和加快构建时间更加容易，从而改善了代码-构建-视图的反馈循环。有了Angular
    6，所有平台工具都与6.0版本同步，这样更容易理清生态系统。在下表中，你可以看到这样做如何使得工具兼容性更容易沟通：
- en: '|  | **Previously** | **With v6** |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|  | **之前** | **v6时** |'
- en: '| **CLI** | 1.7 | 6.0 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **CLI** | 1.7 | 6.0 |'
- en: '| **Angular** | 5.2.10 | 6.0 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **Angular** | 5.2.10 | 6.0 |'
- en: '| **Material** | 5.2.4 | 6.0 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **Material** | 5.2.4 | 6.0 |'
- en: Angular CLI 6.0 comes with major new capabilities, such as `ng update` and `ng
    add` commands; `ng update` makes it much easier to update your version of Angular,
    npm dependencies, RxJS, and Angular Material, including some deterministic code rewriting
    capabilities to apply name changes to APIs or functions. The topic of updating
    your version of Angular is covered in depth in [Chapter 4](374c123d-2621-42e2-b301-ed67c9c7d708.xhtml),
    *Staying Up to Date with Angular Updates.* `ng add` brings schematics support
    to the Angular CLI. With schematics, you can write custom code to add new capabilities
    to an Angular app, adding any dependencies, boilerplate configuration code, or
    scaffolding. A great example is to be able to add Angular Material to your project
    by executing `ng add @angular/material`. The topic of adding Angular Material
    to your project is covered in depth in [Chapter 5](5e0df0e8-57a6-47dc-86c8-d56f6e35021e.xhtml),* Enhance
    Angular App with Angular Material*. A standalone Material Update tool aims to
    make Angular Material updates less painful, found at [Github.com/angular/material-update-tool](https://github.com/angular/material-update-tool),
    but expect this functionality to be merged into `ng update`. Further schematics
    can bring their own `generate` commands to CLI, making your life easier and code
    base more consistent over time. In addition, version 4 of Webpack is configured
    to build your Angular application into smaller modules with scope hosting, shortening
    the first-paint time of your app.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI 6.0带来了重大的新功能，比如`ng update`和`ng add`命令；`ng update`使得更新Angular版本、npm依赖、RxJS和Angular
    Material变得更加容易，包括一些确定性的代码重写能力，以应用对API或函数的名称更改。关于更新Angular版本的主题在[第4章](374c123d-2621-42e2-b301-ed67c9c7d708.xhtml)中有详细介绍，*与Angular更新保持最新*。`ng
    add`为Angular CLI带来了原理图支持。通过原理图，您可以编写自定义代码，为Angular应用添加新的功能，添加任何依赖项、样板配置代码或脚手架。一个很好的例子是通过执行`ng
    add @angular/material`来将Angular Material添加到您的项目中。关于将Angular Material添加到您的项目中的主题在[第5章](5e0df0e8-57a6-47dc-86c8-d56f6e35021e.xhtml)中有详细介绍，*使用Angular
    Material增强Angular应用*。一个独立的Material更新工具旨在使Angular Material的更新变得不那么痛苦，可以在[Github.com/angular/material-update-tool](https://github.com/angular/material-update-tool)找到，但预计这个功能将合并到`ng
    update`中。进一步的原理图可以为CLI带来自己的`generate`命令，使您的生活更加轻松，代码库随着时间的推移更加一致。此外，Webpack的第4版被配置为将您的Angular应用构建为更小的模块，并具有范围托管，缩短了应用的首次绘制时间。
- en: The major theme of Angular 6 is under-the-hood performance improvements and
    Custom Elements support. Version 6 improves upon v5 in terms of the base bundle
    size by 12% at 65 KB, which improves load times a whopping 21-40% from Fast 3G
    to Fiber connections. As your applications grows, Angular takes advantage of a
    better tree-shaking technique to further prune unused code out of your final deliverable.
    Speed is a UX feature in Angular 6\. This is accomplished with better support
    for Angular **Component Development Kit** (**CDK**), Angular Material, Animations,
    and i18n. Angular Universal allows for server-side assisted fast startup times,
    and Angular **Progressive Web App** (**PWA**) support takes advantage of native
    platform features such as caching and offline, so in subsequent visits, your app
    remains fast. RxJS 6 support allows for the tree-shakeable `pipe` command, reducing
    bundle sizes more often, and fix the behavior of `throttle` as I caution you in [Chapter
    6](2d361227-9c8f-4487-bb14-592ca16c0f5a.xhtml),* Reactive Forms and Component
    Interaction, *among numerous bug fixes and performance improvements. TypeScript
    2.7 brings in better support for importing different types of JavaScript packages
    and more advanced features to catch coding errors during build time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 6的主要主题是在幕后进行性能改进和自定义元素支持。版本6在基本捆绑包大小方面比v5提高了12%，达到65 KB，这将从快速3G到光纤连接的加载时间提高了21-40%。随着您的应用程序增长，Angular利用更好的摇树技术来进一步修剪最终可交付的未使用代码。速度是Angular
    6的UX功能。这是通过更好地支持Angular **Component Development Kit** (**CDK**), Angular Material,
    Animations, and i18n来实现的。Angular Universal允许服务器端辅助快速启动时间，并且Angular **Progressive
    Web App** (**PWA**)支持利用本机平台功能，如缓存和离线，因此在随后的访问中，您的应用程序保持快速。RxJS 6支持可摇树的`pipe`命令，更频繁地减少捆绑包大小，并修复了`throttle`的行为，我在[第6章](2d361227-9c8f-4487-bb14-592ca16c0f5a.xhtml)中警告您，*Reactive
    Forms and Component Interaction,*以及众多的错误修复和性能改进。TypeScript 2.7带来了更好的支持，可以导入不同类型的JavaScript包，并在构建时捕获编码错误的更高级功能。
- en: Custom Elements support, part of the Web Components spec, is huge. With Angular
    Elements, you can code an Angular component and reuse that component in *any *other
    web application using *any* web technology, in essence declaring your very own
    custom HTML element. These custom elements would be cross-compatible with any
    HTML-based tool chain, including other web application libraries or frameworks. For
    this to work, the entire Angular framework needs to be packaged alongside your
    new custom element. This is not feasible in Angular 6, because that will mean
    tacking on at least 65 KB, each and every time you create a new user control.
    Furthermore, in early 2018, only Chrome supports Custom Elements without polyfills
    adding more payload to make these custom elements work. Due to its experimental
    nature, I do not cover custom elements in this book. Future updates of Angular,
    in late 2018 or early 2019, should bring in the Ivy rendering engine, enabling
    base bundle sizes as small as 2.7 KB, resulting in lightning fast load times and
    making it feasible to ship Angular-based Custom Elements. In this time frame,
    tooling to build such components easily and native browser support for Custom
    Elements will also improve, including Firefox and Safari support, leaving Microsoft
    Edge the last browser to implement the standard.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元素支持是Web组件规范的一部分，非常重要。使用Angular Elements，您可以编写一个Angular组件，并在*任何*其他使用*任何*Web技术的Web应用程序中重用该组件，从本质上来说，声明您自己的自定义HTML元素。这些自定义元素将与任何基于HTML的工具链兼容，包括其他Web应用程序库或框架。为了使其工作，整个Angular框架需要与您的新自定义元素一起打包。这在Angular
    6中是不可行的，因为这意味着每次创建新用户控件都至少需要增加65 KB。此外，在2018年初，只有Chrome支持自定义元素，而无需添加polyfills以使这些自定义元素工作。由于其实验性质，我在本书中不涉及自定义元素。Angular的未来更新，可能在2018年底或2019年初，应该会引入Ivy渲染引擎，使基本捆绑包大小最小为2.7
    KB，从而实现闪电般快速的加载时间，并使得可以发布基于Angular的自定义元素。在这个时间范围内，构建这样的组件的工具和自定义元素的本地浏览器支持也将得到改进，包括Firefox和Safari的支持，使得Microsoft
    Edge成为最后一个实现该标准的浏览器。
- en: Always check [https://caniuse.com](https://caniuse.com) before getting too excited
    about a new web technology to ensure that you are indeed able to use that feature
    in browsers that you must support.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在对新的Web技术感到兴奋之前，始终在[https://caniuse.com](https://caniuse.com)上检查，以确保您确实能够在必须支持的浏览器中使用该功能。
- en: Regardless of [Angular.io](https://Angular.io) being updated with custom elements
    to demonstrate the feasibility of the technology, the documentation website attracts
    1 million+ unique visitors per month, so it should help work out some of the kinks
    as it matures. Custom elements are great use cases to host interactive code samples
    alongside static content. In early 2018, [Angular.io](https://Angular.io) started
    using [StackBlitz.io](https://StackBlitz.io) for interactive code samples. This
    is an amazing website, in essence a Visual Studio Code IDE in the cloud, where
    you can experiment with different ideas or run GitHub repositories without needing
    to locally pull or execute any code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管[Angular.io](https://Angular.io)已更新以演示自定义元素的可行性，但该文档网站每月吸引了100多万独立访问者，因此应该有助于解决一些难题，使其更加成熟。自定义元素是托管交互式代码示例的绝佳用例，可以与静态内容一起使用。在2018年初，[Angular.io](https://Angular.io)开始使用[StackBlitz.io](https://StackBlitz.io)进行交互式代码示例。这是一个令人惊叹的网站，本质上是一个云中的Visual
    Studio Code IDE，您可以在其中尝试不同的想法或运行GitHub存储库，而无需本地拉取或执行任何代码。
- en: The Angular ecosystem also welcomes the NgRx library, bringing Redux-like state
    management to Angular based on RxJS. Such state management is necessary for building
    offline-first applications in PWA and Mobile contexts. However, PWAs are not well
    supported in iOS's Safari browser and will not find widespread adoption until
    the new IE6 of browsers decides to join the party. Furthermore, NgRx, is an abstraction
    over already confusing and sophisticated tooling like RxJS. Given my positive
    attitude toward minimal tooling and a lack of clear necessity for RxJS beyond
    niche audience, I will not be covering this tool. RxJS is powerful and capable
    enough to unlock sophisticated and scalable patterns to help you build a great
    Angular application, as demonstrated in the lead up to [Chapter 10](99f040e3-89f0-4ac8-a849-4cef38e7a992.xhtml),
    *Angular App Design and Recipes*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Angular生态系统也欢迎NgRx库，它基于RxJS为Angular带来了类似Redux的状态管理。这种状态管理对于在PWA和移动环境中构建离线优先应用是必要的。然而，在iOS的Safari浏览器中，PWA的支持并不好，并且在新的IE6浏览器决定加入之前，PWA不会得到广泛的应用。此外，NgRx是对已经令人困惑和复杂的工具如RxJS的抽象。鉴于我对最小化工具的积极态度，以及对RxJS在利基受众之外缺乏明确必要性，我不会涉及这个工具。RxJS足够强大和有能力解锁复杂和可扩展的模式，帮助您构建出色的Angular应用，正如在[第10章](99f040e3-89f0-4ac8-a849-4cef38e7a992.xhtml)中所展示的，*Angular应用设计和配方*。
- en: Angular Material 6 adds new user controls such as tree and badge, while making
    the library a lot more stable with a slew of bug fixes, completeness of functionality,
    and theming in existing components. Angular Flex Layout 6 brings in polyfills,
    enabling Internet Explorer 11 support CSS Flexbox. This makes Angular apps using
    Material and Flex Layout fully compatible with the last major legacy browser technology
    that still persists in enterprises and governments despite leaving mainstream
    support in January 2018 alongside Windows 8.1 and being superseded 16 times by
    Microsoft Edge. Angular 6 itself can be configured to be compatible down to IE9
    using polyfills. This is great news for developers, who must support such legacy
    browsers and still be able to use modern technologies to build their solutions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material 6添加了新的用户控件，如树和徽章，同时通过一系列错误修复、功能完整性和现有组件的主题化，使库更加稳定。Angular
    Flex Layout 6引入了polyfills，使Internet Explorer 11支持CSS Flexbox。这使得使用Material和Flex
    Layout的Angular应用程序完全兼容于仍然存在于企业和政府中的最后一个主要遗留浏览器技术，尽管在2018年1月与Windows 8.1一起离开了主流支持，并被Microsoft
    Edge取代了16次。Angular 6本身可以通过polyfills配置为与IE9兼容。这对于必须支持这些遗留浏览器并且仍然能够使用现代技术构建解决方案的开发人员来说是个好消息。
- en: Some exciting, new ancillary tooling is also released that can enable high frequency,
    high performance, or large enterprise use cases. The Nx CLI tool, built by former
    Angular team members, brings an opinionated development environment setup to Angular,
    suitable for consultants and large organizations that must ensure a consistent
    environment. This book follows a similar pattern and aims to educate you in establishing
    a consistent architecture and design pattern to apply across your applications.
    Google's Bazel build tool enables incremental builds, so portions of your application
    that haven't changed don't need to be rebuilt, vastly improving build times for
    larges projects and allowing for packaging of libraries to be shared between Angular
    applications.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还发布了一些令人兴奋的新的辅助工具，可以实现高频率、高性能或大型企业用例。由前Angular团队成员开发的Nx CLI工具为Angular带来了一个有见地的开发环境设置，适用于顾问和必须确保一致环境的大型组织。这本书遵循类似的模式，旨在教育您建立一致的架构和设计模式，以应用于您的应用程序。Google的Bazel构建工具实现了增量构建，因此未更改的应用程序部分无需重新构建，大大提高了大型项目的构建时间，并允许在Angular应用程序之间共享库的打包。
- en: I hope you are as excited as I am about Angular 6 and the future possibilities
    it unlocks. Now, let's put all that aside and dive deep into getting things done
    by building a simple Angular application that can display the current weather.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您和我一样对Angular 6和它所解锁的未来可能性感到兴奋。现在，让我们把这一切放在一边，深入研究通过构建一个简单的Angular应用程序来完成事情。
- en: Angular in Full-Stack Architecture
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全栈架构中的Angular
- en: 'In this chapter, we will design, architect, create a backlog, and establish
    the folder structure for your Angular project that will be able communicate with
    a REST API. This app will be designed to demonstrate the uses of the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为您的Angular项目设计、架构、创建一个待办事项，并建立文件夹结构，以便与REST API进行通信。这个应用程序将被设计来演示以下用途：
- en: Angular CLI tool (ng)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角CLI工具（ng）
- en: Angular Reuse of UI through components
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角组件的UI重用
- en: Angular HttpClient
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角HTTP客户端
- en: Angular Router
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角路由器
- en: Angular Reactive Forms
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角反应形式
- en: Material Autocomplete
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材料自动完成
- en: Material Toolbar
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材料工具栏
- en: Material Sidenav
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材料Sidenav
- en: Regardless of your backend technology, I recommend that your frontend always
    resides in its own repository and is served using its own web server that is not
    depended on your API server.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用的是什么后端技术，我建议您的前端始终驻留在自己的存储库中，并且使用自己的Web服务器进行提供，而不依赖于您的API服务器。
- en: First things first, you need a vision and a road map to act upon.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要一个愿景和一个路线图来行动。
- en: Wireframe design
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线框设计
- en: 'There are some great tools out there to do rough looking mock-ups to demonstrate
    your idea with surprising amounts of rich functionality. If you have a dedicated
    UX designer, such tools are great for creating quasi prototypes. However, as a
    full-stack developer, I find the best tool out there to be pen and paper. This
    way, you don''t have to learn yet another tool (YAL), and it is a far better alternative
    having no design at all. Putting things on paper will save you from costly coding
    detours down the line and if you can validate your wireframe design with users
    ahead of time, even better. I will call my app LocalCast Weather, but get creative
    and pick your own name. Behold, the wireframe design for your weather app:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些很棒的工具可以制作粗略的模型，以展示您的想法，并具有令人惊讶的丰富功能。如果您有专门的UX设计师，这些工具非常适合创建准原型。然而，作为全栈开发人员，我发现最好的工具是纸和笔。这样，您就不必学习另一个工具（YAL），而且没有设计要比有设计好得多。把东西写在纸上会让您避免在后续过程中进行昂贵的编码绕路，如果您能提前验证用户的线框设计，那就更好了。我将我的应用称为LocalCast
    Weather，但请发挥创意，选择您自己的名称。以下是您天气应用的线框设计：
- en: '![](Images/67bb08ec-66f3-459e-9bce-40d743225cf2.png)Wireframe for LocalCast.
    Intentionally hand-drawn.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: LocalCast的线框。故意手绘。
- en: The wireframe shouldn't be anything fancy. I recommend starting with a hand-drawn
    design, which is very quick to do and carries over the rough outlines effectively.
    There are great wireframing tools out there and I will be suggesting and using
    a couple of them throughout this book, however in the first days of your project,
    every hour matters. Granted, this kind of rough design may never leave the boundaries
    of your team, but please know that nothing beats getting that instantaneous feedback
    and collaboration by putting your ideas down on paper or a whiteboard.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 线框不应该是什么花哨的东西。我建议从手绘设计开始，这样做非常快速，并且可以有效地传递粗略的轮廓。有很多很棒的线框工具，我将在本书中建议并使用其中的一些，但是在项目的最初几天，每个小时都很重要。可以肯定，这种粗糙的设计可能永远不会离开您团队的范围，但请知道，没有什么比将您的想法写在纸上或白板上更能获得即时的反馈和协作。
- en: High level architecture
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级架构
- en: No matter how small or large your project is, and frankly most of the times
    you will not be able to accurately predict this ahead of time, it is critical
    to start with a sound architecture that can scale if duty calls, but is not so
    burdensome that it will add days of effort to the execution of a simple app idea.
    The key is to ensure proper decoupling from the get go. In my view, there are
    two types of decoupling, one is a soft-decoupling, where essentially a *Gentlemen's
    Agreement* is made to not mix concerns and try and not mess up the code base.
    This can apply to the code you write, all the way to infrastructure-level interactions.
    If you maintain your frontend code under the same code structure as your backend
    code and if you let your REST server serve up your frontend application, then
    you are only practicing soft-decoupling.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您的项目大小如何，坦率地说，大多数时候您都无法提前准确预测，从一个健壮的架构开始至关重要，如果需要，它可以扩展，但不会增加执行一个简单应用想法的工作量。关键是确保从一开始就进行适当的解耦。在我看来，有两种解耦方式，一种是软解耦，基本上是达成“绅士协议”，不混合关注点，尽量不搞乱代码库。这可以适用于您编写的代码，一直到基础设施级别的交互。如果您将前端代码保持在与后端代码相同的代码结构下，并且让您的REST服务器提供前端应用程序，那么您只是在练习软解耦。
- en: 'You should instead practice hard-decoupling, which means frontend code lives
    in a separate repository, never calls the database directly, and is hosted on
    its own web server altogether. This way, you can be certain that at all times,
    your REST APIs or your frontend code is entirely replaceable independent of each
    other. Practicing hard-decoupling has monetary and security benefits as well.
    The serving and scaling needs of your frontend application are guaranteed to be
    different from your backend, so you will be able to optimize your host environment
    appropriately and save money. If you white list access to your REST APIs to only
    the calls originating from your frontend servers, you will vastly improve your
    security. Consider the high-level architecture diagram for our LocalCast Weather
    app below:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你应该练习硬解耦，这意味着前端代码存放在一个单独的存储库中，从不直接调用数据库，并且完全托管在自己的网络服务器上。这样，你可以确保在任何时候，你的REST
    API或前端代码是完全可以独立替换的。练习硬解耦也有经济和安全方面的好处。前端应用的服务和扩展需求肯定与后端不同，因此您将能够适当优化您的主机环境并节省金钱。如果您将对REST
    API的访问白名单限制为仅允许来自前端服务器的调用，您将大大提高安全性。请考虑下面我们LocalCast Weather应用的高级架构图：
- en: '![](Images/41e34a04-4d6b-4647-8d54-6d1679ade8db.jpg)LocalCast High-Level Architecture'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/41e34a04-4d6b-4647-8d54-6d1679ade8db.jpg)LocalCast高级架构'
- en: The high-level architecture shows that our Angular web application is completely
    decoupled from any backend. It is hosted on its own web server, can communicate
    to a web API such as **OpenWeatherMap**, or optionally be paired with a backend
    infrastructure to unlock rich and customized features that a web API alone can't
    provide, such as storing per user preferences or complimenting OpenWeatherMap's
    dataset with our own.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 高级架构显示，我们的Angular web应用程序完全与任何后端解耦。它托管在自己的网络服务器上，可以与Web API（如**OpenWeatherMap**）通信，或者选择与后端基础设施配对，以解锁丰富和定制的功能，这是仅仅使用Web
    API无法提供的，比如存储每个用户的偏好或者用我们自己的数据集补充OpenWeatherMap的数据集。
- en: Folder structure
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件夹结构
- en: I advise against keeping your frontend and backend code in the same code repository.
    Using the same repository leads to bizarre dependencies when you need to enable
    Continuous Integration or deploy your code to production. In order to get an integrated
    development experience with the ability to quickly switch between repositories,
    you can use IDE features, such as VS Code Workspace, to open multiple repositories
    under the same tree-structure at once.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议不要将前端和后端代码放在同一个代码存储库中。在同一个存储库中使用会导致奇怪的依赖关系，当你需要启用持续集成或将代码部署到生产环境时。为了获得集成的开发体验，并能够快速在存储库之间切换，您可以使用IDE功能，比如VS
    Code Workspace，一次打开多个存储库在同一树状结构下。
- en: If you must use a single repository, create separate folders for backend code
    and frontend code, named `server` and `web-app`, respectively. The benefit of
    doing this at a minimum is great, because team members can start working on either
    the frontend or the backend without stepping over each other's toes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须使用单个存储库，为后端代码和前端代码创建单独的文件夹，分别命名为`server`和`web-app`。这样做的好处至少是很大的，因为团队成员可以在不互相干扰的情况下开始在前端或后端上工作。
- en: Follow the instructions in the next two sections to set up your application
    correctly. If you already have a robust development directory setup and you're
    a Git pro, then skip over to the *Generate Your Angular Application* section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 按照接下来的两个部分的说明正确设置您的应用程序。如果您已经有一个强大的开发目录设置，并且您是一个Git专家，那么跳过到*生成您的Angular应用程序*部分。
- en: Set up your development directory
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置您的开发目录
- en: Setting up a dedicated `dev` directory is a life saver. Since all the data under
    this directory will be backed up using GitHub, you can safely configure your antivirus,
    cloud sync, or backup software to ignore it. This will help greatly reduce CPU,
    disk, and network utilization. As a full-stack developer, you're likely to be
    multitasking a lot, so avoiding unnecessary activity will have a net positive
    impact on performance, power, and data consumption on a daily basis, especially
    if your development environment is a laptop that is either resource starved or
    you wish to squeeze as much battery life as possible when you're on the move.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个专门的`dev`目录是一个救命稻草。因为这个目录下的所有数据都将使用GitHub进行备份，您可以安全地配置您的防病毒软件、云同步或备份软件来忽略它。这将大大减少CPU、磁盘和网络的利用率。作为一个全栈开发人员，您很可能会经常进行多任务处理，因此避免不必要的活动将对性能、功耗和数据消耗产生净正面影响，尤其是如果您的开发环境是一台资源匮乏的笔记本电脑，或者当您在移动时希望尽可能延长电池续航时间。
- en: Creating a `dev` folder directly under the `c:\` drive is very important, because
    Windows, or rather NTFS, isn't able handle file paths longer than 260 characters. This
    may seem adequate at first, but when you install npm packages in a folder structure
    that is already deep in the hierarchy, the `node_modules` folder structure can
    get deep enough to hit this limit very easily. With npm 3+, a new, flatter package
    installation strategy was introduced, which helps with npm-related issues, but
    being as close to the `root` folder as possible will help tremendously with any
    tool. In late 2016, there were reports that Microsoft may introduce an Enable
    NTFS long paths group policy to remedy this situation, but as of late 2017, this
    has not landed on Windows 10.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在`c:\`驱动器下创建一个`dev`文件夹非常重要，因为Windows，或者说NTFS，无法处理超过260个字符的文件路径。这一开始可能看起来足够，但当您在已经深层次的文件夹结构中安装npm包时，`node_modules`文件夹结构很容易达到这个限制。使用npm
    3+，引入了一种新的、更扁平的包安装策略，这有助于解决npm相关的问题，但尽可能靠近`root`文件夹将对任何工具都有很大帮助。在2016年末，有报道称微软可能会引入一个“启用NTFS长路径”的组策略来解决这个问题，但截至2017年底，这在Windows
    10上还没有实现。
- en: 'Create your `dev` folder using the following commands:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建您的`dev`文件夹：
- en: 'For Windows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In Unix-based operating systems, `~` (pronounced tilde) is a shortcut to the
    current users `home` directory, which resides under `/Users/your-user-name`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Unix的操作系统中，`~`（读作波浪线）是当前用户`home`目录的快捷方式，位于`/Users/your-user-name`下。
- en: 'For macOS:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于macOS：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that your development directory is ready, let's start with generating your
    Angular application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的开发目录已准备就绪，让我们开始生成您的Angular应用程序。
- en: Generate your Angular application
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成您的Angular应用程序
- en: The Angular CLI (Angular CLI) is an official Angular project to ensure that
    newly created Angular applications have a uniform architecture, following the
    best practices perfected by the community over time. This means that any Angular
    application you encounter going forward should have the same general shape. Angular
    CLI goes beyond initial code generation. You will be using it frequently to create
    new components, directives, pipes, services, modules, and more. Angular CLI will
    also help you during development with live-reloading features so that you can
    quickly see the results of your changes. Angular CLI can also test, lint, and
    build optimized versions of your code for a production release. Furthermore, as
    new Angular versions are released, Angular CLI will help you upgrade your code,
    by automatically rewriting portions of it so that it remains compatible with potential
    breaking changes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI（Angular命令行界面）是一个官方的Angular项目，以确保新创建的Angular应用程序具有统一的架构，遵循社区多年来完善的最佳实践。这意味着您今后遇到的任何Angular应用程序都应该具有相同的一般形状。Angular
    CLI不仅限于初始代码生成。您将经常使用它来创建新的组件、指令、管道、服务、模块等。Angular CLI还将在开发过程中帮助您进行实时重新加载，以便您可以快速查看更改的结果。Angular
    CLI还可以测试、检查代码，并构建优化版本的代码以进行生产发布。此外，随着新版本的Angular发布，Angular CLI将帮助您升级您的代码，自动重写部分代码，以使其与潜在的破坏性更改保持兼容。
- en: Installing Angular CLI
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Angular CLI
- en: The documentation at [https://angular.io/guide/quickstart](https://angular.io/guide/quickstart) will
    guide you to install `@angular/cli` as a global npm package. Do *not* do this.
    Overtime, as Angular CLI is upgraded, it is a constant irritant to have to keep
    the global and the in-project version in sync. If you don't, the tool complains
    endlessly. Additionally, if you are working on multiple projects, you will have
    varying versions of Angular CLI overtime. As a result, your commands may not return
    the results you expect or your team members get.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://angular.io/guide/quickstart](https://angular.io/guide/quickstart)上的文档将指导您安装`@angular/cli`作为全局npm软件包。不要这样做。随着Angular
    CLI的升级，不断地保持全局和项目内版本同步是一个不断的烦恼。如果不这样做，工具会不断地抱怨。此外，如果您正在处理多个项目，随着时间的推移，您将拥有不同版本的Angular
    CLI。因此，您的命令可能不会返回您期望的结果，或者您的团队成员会受到影响。'
- en: The strategy detailed in the next section will make your initial configuration
    of your Angular project a bit more complicated than it needs to be; however, you'll
    be more than making up for this pain if you return to a project a few months or
    a year later. In that case, you will be able to use the version of the tool that
    you last used on that project, instead of some future version that may require
    upgrades that you're not willing to perform. In the next section, you will apply
    this best practice to initialize your Angular app.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节详细介绍的策略将使您的Angular项目的初始配置比必要的复杂一些；然而，如果您在几个月或一年后返回项目，您将能够使用您在该项目上最后使用的工具版本，而不是可能需要进行升级的未来版本。在下一节中，您将应用这一最佳实践来初始化您的Angular应用程序。
- en: Initializing Angular app
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化Angular应用程序
- en: 'Now, we will initialize the application for development using `npx`, which
    is already installed on your system when you installed the latest version of Node
    LTS:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`npx`初始化应用程序进行开发，当您安装最新版本的Node LTS时，它已经安装在您的系统上：
- en: Under your `dev` folder, execute `npx @angular/cli new local-weather-app`
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`dev`文件夹下，执行`npx @angular/cli new local-weather-app`
- en: 'On your terminal, you should see a success message similar to this:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端上，您应该看到类似于以下的成功消息：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Your project folder—`local-weather-app`—has been initialized as a Git repository
    and scaffolded with the initial file and folder structure, which should look like
    this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目文件夹`local-weather-app`已经初始化为Git存储库，并使用了初始的文件和文件夹结构，应该看起来像这样：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The alias for `@angular/cli` is `ng`. If you were to install Angular CLI globally,
    you would have simply executed `ng new local-weather-app`, but we didn't do this.
    So it is important to remember that going forward, you will be executing the `ng` command,
    but this time under the `local-weather-app` directory. The latest version of Angular
    CLI has been installed under the `node_modules/.bin` directory, so you can run
    `ng` commands such as `npx ng generate component my-new-component` and continue
    working in an effective manner.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`@angular/cli`的别名是`ng`。如果您要全局安装Angular CLI，您只需执行`ng new local-weather-app`，但我们没有这样做。因此，重要的是要记住，今后您将执行`ng`命令，但这次是在`local-weather-app`目录下。最新版本的Angular
    CLI已经安装在`node_modules/.bin`目录下，因此您可以运行`ng`命令，比如`npx ng generate component my-new-component`，并继续以有效的方式工作。'
- en: If you are on macOS, you can further improve your development experience by
    implementing shell auto fallback, which removes the necessity of having to use
    the `npx` command. If an unknown command is found, npx will take over the request.
    If the package already locally exists under `node_modules/.bin`, the npx will
    pass along your request to the correct binary. So, you will just be able to run
    commands like `ng g c my-new-component` as if they're globally installed. Refer
    to npx's readme on how to set this up at [npmjs.com/package/npx#shell-auto-fallback](https://www.npmjs.com/package/npx#shell-auto-fallback).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是macOS，您可以通过实现shell自动回退来进一步改善开发体验，这样就不需要使用`npx`命令了。如果找到未知命令，npx将接管请求。如果包已经在`node_modules/.bin`下本地存在，npx将把您的请求传递给正确的二进制文件。因此，您只需像全局安装一样运行命令，比如`ng
    g c my-new-component`。请参考npx的自述文件，了解如何在[npmjs.com/package/npx#shell-auto-fallback](https://www.npmjs.com/package/npx#shell-auto-fallback)上设置这一点。
- en: Publishing Git Repository using GitHub Desktop
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GitHub桌面发布Git存储库
- en: 'GitHub Desktop allows you to create a new repository directly within the application:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub桌面允许您直接在应用程序中创建新存储库：
- en: Open GitHub for Desktop
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开GitHub桌面
- en: File | Add local repository...
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件 | 添加本地存储库...
- en: Locate the `local-weather-app` folder by clicking on Choose...
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击Choose...来定位`local-weather-app`文件夹
- en: Click on Add repository
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击添加存储库
- en: Note that Angular CLI already created the first commit for you in the History
    tab
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，Angular CLI已经在历史选项卡中为您创建了第一个提交
- en: 'Finally, click on Publish repository, as shown:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击发布存储库，如图所示：
- en: '![](Images/c4aebec3-835d-4533-88ea-8063784d4b99.png)GitHub Desktop'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/c4aebec3-835d-4533-88ea-8063784d4b99.png)GitHub桌面'
- en: Inspecting and updating package.json
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查和更新package.json
- en: '`Package.json` is the single most important configuration file that you should
    be keenly aware of at all times. Your project''s scripts, runtime, and development
    dependencies are stored in this file.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Package.json`是您应该随时密切关注的最重要的配置文件。您的项目脚本、运行时和开发依赖项都存储在这个文件中。'
- en: 'Open `package.json` and locate the `name` and `version` properties:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`package.json`并找到`name`和`version`属性：
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Rename your app to whatever you wish; I will be using `localcast-weather`
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的应用程序重命名为您希望的任何名称；我将使用`localcast-weather`
- en: Set your version number to `1.0.0`
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的版本号设置为`1.0.0`
- en: '`npm` uses semantic versioning (semver), where version number digits represent
    Major.Minor.Patch increments. Semver starts version numbers at `1.0.0` for any
    published API, though it doesn''t prevent 0.x.x versioning. As the author of a
    web application, the versioning of your app has no real impact on you, outside
    of internal tooling, team, or company communication purposes. However, the versioning
    of your dependencies is highly critical to the reliability of your application.
    In summary, Patch versions should just be bug fixes. Minor versions add functionality
    without breaking the existing features, and major version increments are free
    to make incompatible API changes. However, in reality, any update is risky to
    the tested behavior of your application. This is why the `package-lock.json` file
    stores the entire dependency tree of your application, so the exact state of your
    application can be replicated by other developers or Continuous Integration servers.
    For more information, visit: [https://semver.org/](https://semver.org/).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm`使用语义化版本（semver），其中版本号数字表示主要.次要.补丁增量。Semver从`1.0.0`开始为任何发布的API设置版本号，尽管它不会阻止0.x.x版本。作为Web应用程序的作者，您的应用程序的版本对您没有真正影响，除了内部工具、团队或公司沟通目的。但是，您的依赖项的版本对您的应用程序的可靠性非常关键。总之，补丁版本应该只是错误修复。次要版本增加功能而不会破坏现有功能，主要版本增量可以进行不兼容的API更改。然而，在现实中，任何更新都会对应用程序的测试行为构成风险。这就是为什么`package-lock.json`文件存储了应用程序的整个依赖树，以便其他开发人员或持续集成服务器可以复制应用程序的确切状态。欲了解更多信息，请访问：[https://semver.org/](https://semver.org/)。'
- en: 'In the following code block, observe that the `scripts` property contains a
    collection of helpful starter scripts that you can expand on. The `start` and
    `test` commands are npm defaults, so they can just be executed by `npm start`
    or `npm test`. However, the other commands are custom commands that must be prepended
    with the `run` keyword. For example, in order to build your application, you must
    use `npm run build`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，可以看到`scripts`属性包含一组有用的启动脚本，您可以进行扩展。`start`和`test`命令是npm的默认命令，因此可以通过`npm
    start`或`npm test`来执行。但是，其他命令是自定义命令，必须在前面加上`run`关键字。例如，要构建您的应用程序，您必须使用`npm run
    build`：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Before the introduction of npx, if you wanted to use Angular CLI without a global
    install, you would have to run it with `npm run ng -- g c my-new-component`. The
    double-dashes are needed to let npm know where the command-line tool name ends
    and options begin. For example, in order to start your Angular application on
    a port other than the default `4200`, you will need to run `npm start -- --port
    5000`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在npx引入之前，如果您想要在没有全局安装的情况下使用Angular CLI，您必须使用`npm run ng -- g c my-new-component`来运行它。双破折号是必需的，以便让npm知道命令行工具名称在哪里结束并开始选项。例如，要在除默认端口`4200`之外的端口上启动您的Angular应用程序，您需要运行`npm
    start -- --port 5000`。
- en: 'Update your `package.json` file to run your development version of the app
    from a little used port like `5000` as the new default behavior:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的`package.json`文件，以便从一个不常用的端口（如`5000`）运行您的应用的开发版本作为新的默认行为：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Under the `dependencies` property, you can observe your runtime dependencies.
    These are libraries that will get packaged up alongside your code and shipped
    to the client browser. It''s important to keep this list to a minimum:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dependencies`属性下，您可以观察到您的运行时依赖项。这些库将与您的代码一起打包并发送到客户端浏览器。保持此列表最小化非常重要：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, all Angular components are on the same version. As
    you install additional Angular components or upgrade individual ones, it is advisable
    to keep all Angular packages on the same version. This is especially easy to do
    since npm 5 doesn't require the `--save` option anymore to permanently update
    the package version. For example, just executing `npm install @angular/router`
    is sufficient to update the version in `package.json`. This is a positive change
    overall, since what you see in `package.json` will match what is actually installed.
    However, you must be careful, because npm 5 will also automatically update `package-lock.json`,
    which will propagate your, potentially unintended, changes to your team members.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，所有Angular组件都是相同版本。当您安装额外的Angular组件或升级单个组件时，建议将所有Angular包保持在相同的版本。这特别容易做到，因为npm
    5不再需要`--save`选项来永久更新软件包版本。例如，只需执行`npm install @angular/router`就足以更新`package.json`中的版本。总的来说，这是一个积极的变化，因为您在`package.json`中看到的将与实际安装的内容匹配。但是，您必须小心，因为npm
    5还将自动更新`package-lock.json`，这将传播您可能无意的更改给您的团队成员。
- en: 'Your development dependencies are stored under the `devDependencies` property.
    When installing new tools to your project, you must take care to append the command
    with `--save-dev` so that your dependency will be correctly categorized. Dev dependencies
    are only used during development and are not shipped to the client browser. You
    should familiarize yourself with every single one of these packages and their
    specific purpose. If you are unfamiliar with a package shown as we move on, your
    best resource to learn more about them is [https://www.npmjs.com/](https://www.npmjs.com/):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您的开发依赖项存储在`devDependencies`属性下。在向项目安装新工具时，您必须小心地在命令后面添加`--save-dev`，以便正确分类您的依赖关系。开发依赖项仅在开发过程中使用，不会发送到客户端浏览器。您应该熟悉每一个这些软件包及其具体目的。如果您对我们继续显示的软件包不熟悉，了解更多关于它们的最佳资源是[https://www.npmjs.com/](https://www.npmjs.com/)：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The characters in front of the version numbers have specific meanings in semver.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号前面的字符在semver中具有特定含义。
- en: Tilde `~` enables tilde ranges when all three digits of the version number are
    defined, allowing for patch version upgrades to be automatically applied
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 波浪号`~`在定义版本号的所有三个数字时启用波浪范围，允许自动应用补丁版本升级。
- en: Up-caret character `^` enables caret ranges, allowing for minor version upgrades
    to be automatically applied
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上插字符`^`使插入范围生效，允许自动应用次要版本升级
- en: Lack of any character signals npm to install that exact version of the library
    on your machine
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少任何字符会提示npm在您的计算机上安装该库的确切版本
- en: 'You may notice that major version upgrades aren''t allowed to happen automatically.
    In general, updating packages can be risky. In order to ensure, no package is
    updating without your explicit knowledge, you may install exact versions packages
    by using npm''s `--save-exact` option. Let''s experiment with this behavior by
    installing an npm package that I published called, `dev-norms`, a CLI tool that
    generates a markdown file with sensible default norms for your team to have a
    conversation around, as shown here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，不允许自动进行主要版本升级。一般来说，更新软件包可能存在风险。为了确保没有软件包在您明确知识的情况下进行更新，您可以使用npm的`--save-exact`选项安装确切版本的软件包。让我们通过安装我发布的一个名为`dev-norms`的npm软件包来尝试这种行为，这是一个生成团队围绕的合理默认规范的markdown文件的CLI工具，如下所示：
- en: Under the `local-weather-app` directory, execute `npm install dev-norms --save-dev
    --save-exact`. Note that `"dev-norms": "1.3.6"` or similar has been added to `package.json` with `package-lock.json` automatically
    updated to reflect the changes accordingly.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`local-weather-app`目录下，执行`npm install dev-norms --save-dev --save-exact`。请注意，`"dev-norms":
    "1.3.6"`或类似的内容已添加到`package.json`中，并且`package-lock.json`已自动更新以相应地反映这些更改。'
- en: After the tool is installed, execute `npx dev-norms create`. A file named `dev-norms.md` has
    been created containing the aforementioned developer norms.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工具安装完成后，执行`npx dev-norms create`。创建了一个名为`dev-norms.md`的文件，其中包含上述的开发者规范。
- en: Save your changes to `package.json`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存对`package.json`的更改。
- en: Working with stale packages comes with its own risks. With npm 6, the `npm audit`
    command has been introduced to make you aware of any vulnerabilities discovered
    in packages you're using. During `npm install` if you receive any vulnerability
    notices, you may execute `npm audit` to find out details about any potential risk.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用过时的软件包会带来自己的风险。在npm 6中，引入了`npm audit`命令，以让您了解您正在使用的软件包中发现的任何漏洞。在`npm install`期间，如果收到任何漏洞通知，您可以执行`npm
    audit`以了解任何潜在风险的详细信息。
- en: In the next section, you will commit the changes you have made to Git.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将提交您对Git所做的更改。
- en: Commiting code using VS Code
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用VS Code提交代码
- en: In order to commit your changes to Git and then synchronize your commits to
    GitHub, you can use VS Code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提交您的更改到Git，然后将您的提交同步到GitHub，您可以使用VS Code。
- en: 'Switch over to the Source Control pane, marked as 1 here:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到源代码控制窗格，在此处标记为1：
- en: '![](Images/e771b503-a971-4ce4-ae81-957de6a252b1.png)Visual Studio Code Source
    Control pane'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/e771b503-a971-4ce4-ae81-957de6a252b1.png)Visual Studio Code源代码控制窗格
- en: Enter a commit message in 2
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在2中输入提交消息
- en: Click on the check-mark icon to commit your changes in 3
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击3中的复选标记图标提交您的更改
- en: Finally, synchronize your changes with your GitHub repository by clicking on
    the refresh icon in 4.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过单击4中的刷新图标将您的更改与GitHub存储库同步。
- en: Going forward, you can do most Git operations from within VS Code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，您可以在VS Code中执行大多数Git操作。
- en: Running your Angular app
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行您的Angular应用程序
- en: 'Run your Angular app to check whether it works. During development, you can
    execute `npm start`, through the `ng serve` command; this action will transpile,
    package, and serve the code on localhost with live-reloading enabled:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 运行您的Angular应用程序以检查它是否正常工作。在开发过程中，您可以通过`ng serve`命令执行`npm start`；此操作将在localhost上转译、打包和提供启用了实时重新加载的代码：
- en: Execute `npm start`
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm start`
- en: Navigate to `http://localhost:5000`
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:5000`
- en: 'You should see a rendered page similar to this:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到一个类似于此的呈现页面：
- en: '![](Images/10bd04de-9c6d-4a91-b4b0-a20e77386d26.png)Default Angular CLI landing
    page'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/10bd04de-9c6d-4a91-b4b0-a20e77386d26.png)默认的Angular CLI登陆页面
- en: Stop your application by pressing *Ctrl* + *C* in the integrated terminal.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在集成终端中按下*Ctrl* + *C*来停止应用程序。
- en: Optimizing VS Code for Angular
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化用于Angular的VS Code
- en: 'Saving files all the time can get tedious. You can enable automatic saving
    by doing the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一直保存文件可能会变得乏味。您可以通过以下方式启用自动保存：
- en: Open VS Code
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开VS Code
- en: Toggle the setting under File | Auto Save
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到“文件”|“自动保存”下的设置。
- en: You can further customize many aspects of VS Code's behavior by launching Preferences. The
    keyboard shortcut to launch Preferences is *Ctrl* + *,* on Windows and ⌘ + *,*
    on macOS.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过启动“首选项”来进一步自定义VS Code行为的许多方面。在Windows上启动首选项的键盘快捷键是*Ctrl* + *，*，在macOS上是⌘
    + *，*。
- en: IDE settings
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDE设置
- en: You can share such settings with your coworkers by creating a `.vscode` folder
    in the root of your project directory and placing a `settings.json` file in it.
    If you commit this file to the repository, everyone will share the same IDE experience.
    Unfortunately, individuals aren't able to override these settings with their own
    local preferences, so ensure that shared settings are minimal and are agreed upon
    as a team norm.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在项目目录的根目录中创建一个`.vscode`文件夹并在其中放置一个`settings.json`文件来与同事共享这些设置。如果您将此文件提交到存储库，每个人都将共享相同的IDE体验。不幸的是，个人无法使用自己的本地偏好覆盖这些设置，因此请确保共享设置是最小化的，并且作为团队规范达成一致。
- en: 'Here are the customizations that I use for an optimal, battery-life conscious
    Angular development experience:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我用于实现最佳、节省电池寿命的Angular开发体验的自定义设置：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Additionally, you may enable the following settings in VS Code for a richer
    development experience:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以在VS Code中启用以下设置，以获得更丰富的开发体验：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: IDE extensions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDE扩展
- en: For a *magical* development experience with VS Code and Angular, you should
    install the Angular Essentials extension pack created and curated by John Papa.
    John Papa is one of the leading champions and thought leaders in the Angular community.
    He continuously and relentlessly seeks the best possible development experience
    you can attain so that you are more productive and happier as a developer. He
    is a resource to trust and take very seriously. I highly recommend you follow
    him on twitter at `@john_papa`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用VS Code和Angular进行*神奇*开发体验，您应该安装由John Papa创建和策划的Angular Essentials扩展包。John
    Papa是Angular社区中的领军者和思想领袖之一。他不断不懈地寻求最佳的开发体验，以便您作为开发人员更加高效和快乐。他是一个值得信赖并且非常认真对待的资源。我强烈建议您在Twitter上关注他`@john_papa`。
- en: 'Similar to settings, you can also share recommended extensions via a JSON file.
    These are the extensions that I use for Angular development:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与设置类似，您还可以通过JSON文件共享推荐的扩展。以下是我用于Angular开发的扩展：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: VS Code will also recommend some extensions for you to install. I would caution
    against installing too many extensions, as these will noticeably start slowing
    down the launch performance and optimal operation of VS Code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code还会建议您安装一些扩展。我建议不要安装太多扩展，因为这些扩展会明显地减慢VS Code的启动性能和最佳运行。
- en: Coding style
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码风格
- en: You can customize the coding style enforcement and code generation behavior
    in VS Code and Angular CLI. When it comes to JavaScript, I prefer StandardJS settings,
    which codifies a minimal approach to writing code, while maintaining great readability.
    This means 2-spaces for tabs and no semicolons. In addition to the reduced keystrokes,
    StandardJS also takes less space horizontally, which is especially valuable when
    your IDE can only utilize half of the screen with the other half taken up by the
    browser. You can read more about StandardJS at: [https://standardjs.com/](https://standardjs.com/).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在VS Code和Angular CLI中自定义编码风格执行和代码生成行为。在JavaScript方面，我更喜欢StandardJS设置，它规范了一种编写代码的最简化方法，同时保持了良好的可读性。这意味着使用2个空格作为制表符，而不使用分号。除了减少按键次数外，StandardJS在水平方面也占用更少的空间，这在您的IDE只能利用屏幕的一半，另一半被浏览器占用时尤其有价值。您可以在以下网址了解更多关于StandardJS的信息：[https://standardjs.com/](https://standardjs.com/)。
- en: 'With the default settings, your code will look like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认设置，您的代码将如下所示：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With StandardJS settings, your code will look like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用StandardJS设置，您的代码将如下所示：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Ultimately, this is an optional step for you. However, my code samples will
    follow the StandardJS style. You can start making the configuration changes by
    following these steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这对您来说是一个可选的步骤。但是，我的代码示例将遵循StandardJS风格。您可以通过以下步骤开始进行配置更改：
- en: Install the Prettier - Code formatter extension
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Prettier - Code formatter扩展
- en: Update `.vscode/extensions.json` file with the new extension
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的扩展更新`.vscode/extensions.json`文件
- en: Execute `npm i -D prettier`
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm i -D prettier`
- en: You can use `i` for `install` and `-D` instead of the more verbose `--save-dev`
    option. However, if you mistype `-D` as `-d`, you will end up saving the package
    as a production dependency.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`i`代替更冗长的`--save-dev`选项进行`install`，并使用`-D`代替。但是，如果你将`-D`误输入为`-d`，你最终会将该包保存为生产依赖项。
- en: 'Edit `package.json` with a new script, update the existing ones, and create
    new formatting rules:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`package.json`添加一个新的脚本，更新现有的脚本，并创建新的格式规则：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'macOS and Linux users must modify the `standardize` script to add single-quotes
    around `**/*.ts` for the script to correctly traverse the directory. In macOS
    and Linux, the correct script looks like `"standardize": "prettier ''**/*.ts''
    --write"`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'macOS和Linux用户必须修改`standardize`脚本，为了正确遍历目录，必须在`**/*.ts`周围添加单引号。在macOS和Linux中，正确的脚本看起来像这样`"standardize":
    "prettier ''**/*.ts'' --write"`。'
- en: 'Similarly, update `tslint.json` with new formatting rules:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，使用新的格式规则更新`tslint.json`：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Execute `npm run standardize` to update all your files to the new style
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm run standardize`来更新所有文件到新的样式
- en: Observe all the file changes in GitHub Desktop
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察GitHub Desktop中的所有文件更改
- en: Going forward, every time you execute `npm start` or `npm run build`, the new
    `standardize` script will automatically run and keep the formatting of your files
    in shape
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 今后，每当你执行`npm start`或`npm run build`时，新的`standardize`脚本将自动运行并保持文件的格式。
- en: Commit and push your changes to your repository
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交并推送你的更改到你的存储库
- en: 'As you type in new code or generate new components using Angular CLI, you will
    encounter double-quotes or semicolons being underlined with a red-squiggly line
    to indicate an issue. In most of those cases, a yellow bulb icon will appear next
    to the issue. If you click on the bulb, you will see an action to Fix: Unnecessary
    semicolon or a similar message. You can either take advantage of these auto-fixers
    or press *Shift* + *Alt* + *F* to run the Prettier Format Document command on
    the entire file. In the following screenshot, you can see the auto-fixer in action
    with the yellow bulb and the corresponding contextual menu:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入新代码或使用Angular CLI生成新组件时，你会遇到双引号或分号被下划线标记为问题。在大多数情况下，问题旁边会出现一个黄色的灯泡图标。如果你点击灯泡，你会看到一个修复动作：不必要的分号或类似的消息。你可以利用这些自动修复程序，或者按下*Shift*
    + *Alt* + *F*来运行整个文件的Prettier格式文档命令。在下面的截图中，你可以看到自动修复程序的运行情况，有黄色的灯泡和相应的上下文菜单：
- en: '![](Images/28378c58-35a6-4666-ba48-4e85e1364fec.png)VS Code Auto-Fixer'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/28378c58-35a6-4666-ba48-4e85e1364fec.png)VS Code自动修复程序'
- en: Planning a feature road map using Waffle
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Waffle规划功能路线图
- en: Building a rough plan of action before you start coding is a very important
    so that you and your colleagues or clients are aware of the road map you're planning
    to execute. Whether you're building an app for yourself or for someone else, a
    living backlog of features will always serve as a great reminder when you get
    back to a project after a break or serve as an information radiator that prevent
    constant requests for status updates.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前制定一个大致的行动计划非常重要，这样你和你的同事或客户就会意识到你计划执行的路线图。无论是为自己还是为他人构建应用程序，功能的活动积压总是会在你休息后回到项目时作为一个很好的提醒，或者作为一个信息辐射器，防止不断的状态更新请求。
- en: In Agile development, you may have used various ticketing systems or tools that
    surface or Kanban boards. My favorite tool is Waffle.io, [https://waffle.io/](https://waffle.io/),
    because it directly integrates with your GitHub repository's issues and keeps
    track of status of issues via labels. This way, you can keep using the tool of
    your choice to interact with your repository and still, effortlessly, radiate
    information. In the next section, you will set up a Waffle project to achieve
    this goal.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷开发中，您可能已经使用了各种票务系统或工具，比如表面或看板。我的最爱工具是Waffle.io，因为它直接与您的GitHub存储库的问题集成，并通过标签跟踪问题的状态。这样，您可以继续使用您选择的工具与存储库进行交互，并轻松地传递信息。在下一节中，您将设置一个Waffle项目来实现这个目标。
- en: Setting up a Waffle project
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Waffle项目
- en: 'We will now set up our Waffle project:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将设置我们的Waffle项目：
- en: Go to Waffle.io [https://waffle.io/](https://waffle.io/).
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Waffle.io [https://waffle.io/](https://waffle.io/)。
- en: Click on Login or Get Started for Free.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击登录或免费开始。
- en: Select Public & Private Repos to allow access to all of your repositories.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择公共和私有存储库以允许访问所有存储库。
- en: Click on Create Project.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建项目。
- en: Search for the local-weather-app repository and select it.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索本地天气应用存储库并选择它。
- en: Hit Continue.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击继续。
- en: 'You will get two starter layout templates, as shown in the following image:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得两个起始布局模板，如下图所示：
- en: '![](Images/9cb448bb-d7e6-48ae-bde1-ce3cbb174c7a.png)Waffle.io Default Board
    Layouts'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/9cb448bb-d7e6-48ae-bde1-ce3cbb174c7a.png)Waffle.io默认看板布局'
- en: For this simple project, you will be selecting Basic. However, the Advanced
    layout demonstrates how you can modify the default setup of Waffle, by adding
    additional columns such as Review, to account for testers or product owners participating
    in the process. You can further customize any board to fit your existing process.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的项目，您将选择基本。但是，高级布局演示了如何修改Waffle的默认设置，例如添加额外的列，比如Review，以考虑参与过程的测试人员或产品所有者。您可以进一步自定义任何看板以适应您现有的流程。
- en: Select the Basic layout and click on Create Project.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择基本布局，然后点击创建项目。
- en: You will see a new board created for you.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到为您创建的新看板。
- en: '![](Images/59ab5b31-7f09-446d-9f1e-69d1bb6afed0.png)Empty Waffle Board'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/59ab5b31-7f09-446d-9f1e-69d1bb6afed0.png)空的Waffle看板'
- en: By default, Waffle will serve as a Kanban board. Allowing you to move a task
    from one state to another. However, the default view will show all the issues
    that are present on the repository. To use Waffle as a Scrum board, you need to
    assign issues to GitHub milestones that will represent sprints. You can then use
    the filtering functionality to only display issues from that milestone, or put
    another way from the current sprint.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Waffle将作为看板。允许您将任务从一个状态移动到另一个状态。但是，默认视图将显示存储库中存在的所有问题。要将Waffle用作Scrum板，您需要将问题分配给GitHub里程碑，这将代表冲刺。然后，您可以使用过滤功能仅显示来自该里程碑的问题，或者换句话说，来自当前冲刺的问题。
- en: On Waffle, you can attach story points to issues by clicking on the ![](Images/743fa9fd-b4cb-44e6-952c-a53cedda025f.jpg) scale
    icon. The columns will automatically show totals and card orders, which represent
    priority, and they will be retained from session to session. Furthermore, you
    can switch to the Metrics view to get Milestone Burndown and Throughput graphs
    and statistics.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在Waffle上，您可以通过点击![](Images/743fa9fd-b4cb-44e6-952c-a53cedda025f.jpg)比例图标将故事点附加到问题上。列将自动显示总数和卡片顺序，代表优先级，并且将从会话到会话保留。此外，您可以切换到指标视图以获取里程碑燃尽和吞吐量图表和统计信息。
- en: Creating issues for your Local Weather app
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的本地天气应用创建问题
- en: We will now create a backlog of issues that you will use to keep track of your
    progress as you implement the design of your application. When creating issues,
    you should focus on delivering functional iterations that bring some value to
    the user. The technical hurdles you must clear to achieve those results are of
    no interest to your users or clients.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个问题的积压，您将使用它来跟踪您实施应用程序设计的进展。在创建问题时，您应该专注于提供对用户有价值的功能迭代。您必须克服的技术障碍对您的用户或客户没有兴趣。
- en: 'Here are the features we plan to be building in our first release:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们计划在第一个发布版本中构建的功能：
- en: Display Current Location weather information for the current day
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示当前位置当天的天气信息
- en: Display forecast information for current location
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示当前位置的天气预报信息
- en: Add city search capability so that users can see weather information from other
    cities
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加城市搜索功能，以便用户可以查看其他城市的天气信息
- en: Add a preferences pane to store the default city for the user
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加首选项窗格以存储用户的默认城市
- en: Improve the UX of the app with Angular Material
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular Material改进应用程序的用户体验
- en: 'Go ahead with creating your issues on Waffle or on GitHub; whichever you prefer
    is fine. While creating the scope for Sprint 1, I had some other ideas for features,
    so I just added those issues, but I did not assign them to a person or a milestone.
    I also went ahead and added story points to the issues I intended to work on.
    The following is what the board looks like, as I''m to begin working on the first
    story:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 继续在Waffle或GitHub上创建您的问题；无论您喜欢哪个都可以。在创建Sprint 1的范围时，我对功能有一些其他想法，所以我只是添加了这些问题，但我没有分配给任何人或者里程碑。我还继续为我打算处理的问题添加了故事点。以下是看板的样子，因为我要开始处理第一个故事：
- en: '![](Images/afcc6387-02dc-4e09-9f46-0c45a106a8e2.png)A snapshot of the initial
    state of the board at [https://waffle.io/duluca/local-weather-app](https://waffle.io/duluca/local-weather-app)Ultimately,
    Waffle provides an easy-to-use GUI so that non-technical people can easily interact
    with GitHub issues. By allowing non-technical people to participate in the development
    process on GitHub, you unlock the benefit of GitHub becoming the single source
    of information for your entire project. Questions, answers, and discussions around
    features and issues are all tracked as part of GitHub issues, instead of being
    lost in emails. You can also store wiki type documentation on GitHub, so by centralizing
    all project-related information, data, conversations, and artifacts on GitHub,
    you are greatly simplifying a potentially complicated interaction of multiple
    systems that require continued maintenance, at a high cost. For private repositories
    and on-premise Enterprise installations, GitHub has a very reasonable cost. If
    you''re sticking with open source, as we are in this chapter, all these tools
    are free.As a bonus, I created a rudimentary wiki page on my repository at [https://github.com/duluca/local-weather-app/wiki](https://github.com/duluca/local-weather-app/wiki).
    Note that you can''t upload images to `README.md` or wiki pages. To get around
    this limitation, you can create a new issue, upload an image in a comment, and
    copy and paste the URL for it to embed images to `README.md` or wiki pages. In
    the sample wiki, I followed this technique to embed the wireframe design into
    the page.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/afcc6387-02dc-4e09-9f46-0c45a106a8e2.png)看板的初始状态快照在[https://waffle.io/duluca/local-weather-app](https://waffle.io/duluca/local-weather-app)。最终，Waffle提供了一个易于使用的GUI，以便非技术人员可以轻松地与GitHub问题进行交互。通过允许非技术人员参与GitHub上的开发过程，您可以解锁GitHub成为整个项目的唯一信息来源的好处。关于功能和问题的问题，答案和讨论都作为GitHub问题的一部分进行跟踪，而不是在电子邮件中丢失。您还可以在GitHub上存储维基类型的文档，因此通过在GitHub上集中所有与项目相关的信息，数据，对话和工件，您大大简化了可能需要持续维护的多个系统的复杂交互，成本高昂。对于私有存储库和本地企业安装，GitHub的成本非常合理。如果您坚持使用开源，就像我们在本章中一样，所有这些工具都是免费的。作为奖励，我在我的存储库[https://github.com/duluca/local-weather-app/wiki](https://github.com/duluca/local-weather-app/wiki)上创建了一个基本的维基页面。请注意，您无法将图像上传到`README.md`或维基页面。为了解决这个限制，您可以创建一个新问题，在评论中上传图像，并复制并粘贴其URL以将图像嵌入`README.md`或维基页面。在示例维基中，我遵循了这种技术将线框设计嵌入页面中。
- en: With a concrete road map in place, you're now ready to start implementing your
    application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有了具体的路线图，现在你可以开始实施你的应用程序了。
- en: Crafting UI elements using components and interfaces
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件和接口来制作UI元素
- en: You will be leveraging Angular components, interfaces, and services to build
    the current weather feature in a decoupled, cohesive, and encapsulated manner.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您将利用Angular组件，接口和服务以一种解耦的，内聚的和封装的方式构建当前天气功能。
- en: The landing page of an Angular app, by default, resides in `app.component.html`.
    So, start by editing the template of `AppComponent` with rudimentary HTML, laying
    out the initial landing experience for the application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Angular应用程序的默认登陆页面位于`app.component.html`中。因此，首先通过编辑`AppComponent`的模板，使用基本的HTML来布置应用程序的初始登陆体验。
- en: We are now beginning the development of Feature 1: Display Current Location
    weather information for the current day, so, you can move the card in Waffle to
    the In Progress column.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始开发Feature 1：显示当前位置的当天天气信息，所以你可以将卡片移动到Waffle的In Progress列。
- en: 'We will add a header as an `h1` tag, followed by the tagline of our app as
    a `div` and placeholders for where we may want to display the current weather,
    as demonstrated as shown in the following code block:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个`h1`标签作为标题，然后是我们应用的标语作为`div`，以及用于显示当前天气的占位符，如下面的代码块所示：
- en: '[PRE18]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At this point, you should run `npm start` and navigate to `http://localhost:5000` on your
    browser so that you can observe the changes you're making in real time.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该运行`npm start`并在浏览器中导航到`http://localhost:5000`，以便您可以实时观察您所做的更改。
- en: Discover OpenWeatherMap APIs
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现OpenWeatherMap API
- en: Since `httpClient` is strongly typed, we need to create a new interface that
    conforms to the shape of the API we'll call. To be able to do this, you need to
    familiarize yourself with the Current Weather Data API.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`httpClient`是强类型的，我们需要创建一个符合我们将调用的API形状的新接口。为了能够做到这一点，您需要熟悉当前天气数据API。
- en: 'Read documentation by navigating to [http://openweathermap.org/current](http://openweathermap.org/current):'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到[http://openweathermap.org/current](http://openweathermap.org/current)阅读文档：
- en: '![](Images/c2cf5e84-5346-44a8-b651-b8f3403adff4.png)OpenWeatherMap Current
    Weather Data API Documentation'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/c2cf5e84-5346-44a8-b651-b8f3403adff4.png)OpenWeatherMap当前天气数据API文档'
- en: 'You will be using the API named By city name, which allows you to get current
    weather data by providing the city name as a parameter. So, your web request will
    look like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用名为“按城市名称”的API，该API允许您通过提供城市名称作为参数来获取当前天气数据。因此，您的网络请求将如下所示：
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'On the documentation page, click on the link under Example of API calls, and
    you will see a sample response like the following:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文档页面上，点击“API调用示例”下的链接，您将看到类似以下的示例响应：
- en: '[PRE20]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Given the existing `ICurrentWeather` interface that you have already created,
    this response contains more information than you need. So you will write a new
    interface that conforms to the shape of this response, but only specify the pieces
    of data you will use. This interface will only exist in the `WeatherService` and
    we won't export it, since the other parts of the application don't need to know
    about this type.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到您已经创建的现有`ICurrentWeather`接口，此响应包含的信息比您需要的要多。因此，您将编写一个新接口，符合此响应的形状，但只指定您将使用的数据部分。此接口将仅存在于`WeatherService`中，我们不会导出它，因为应用程序的其他部分不需要了解此类型。
- en: Create a new interface named `ICurrentWeatherData` in `weather.service.ts` between
    the `import` and `@Injectable` statements
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`weather.service.ts`中的`import`和`@Injectable`语句之间创建一个名为`ICurrentWeatherData`的新接口
- en: 'The new interface should like this:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新接口应该像这样：
- en: '[PRE21]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With the `ICurrentWeatherData` interface, we are defining new anonymous types
    by adding children objects to the interface with varying structures. Each of these
    objects can be individually extracted out and defined as their own named interface.
    Especially, note that `weather` will be an array of the anonymous type that has
    the `description` and `icon` properties.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ICurrentWeatherData`接口，我们通过向接口添加具有不同结构的子对象来定义新的匿名类型。这些对象中的每一个都可以单独提取出来，并定义为自己的命名接口。特别要注意的是，`weather`将是具有`description`和`icon`属性的匿名类型的数组。
- en: Adding an Angular component
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个Angular组件
- en: We need to display the current weather information, where `<div>current weather</div>`
    is located. In order to achieve this, you need to build a component that will
    be responsible for displaying the weather data.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要显示当前天气信息，位置在`<div>current weather</div>`处。为了实现这一点，您需要构建一个负责显示天气数据的组件。
- en: 'The reason behind creating a separate component is an architectural best practice
    that is codified in the **Model-View-ViewModel** (**MVVM**) design pattern. You
    may have heard of the **Model-View-Controller** (**MVC**) pattern before. Vast
    majority of web-based code written circa 2005-2015 has been written following
    the MVC pattern. MVVM differs, in important ways, from the MVC pattern. As I have
    explained in my 2013 article on DevPro:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 创建单独组件的原因是架构最佳实践，这在**Model-View-ViewModel**（**MVVM**）设计模式中得到了体现。你可能之前听说过**Model-View-Controller**（**MVC**）模式。大多数在2005年至2015年左右编写的基于Web的代码都是按照MVC模式编写的。MVVM与MVC模式在重要方面有所不同。正如我在2013年的DevPro文章中所解释的：
- en: '[An effective implementation of MVVM] inherently enforces proper separation
    of concerns. Business logic is clearly separated from presentation logic. So when
    a View is developed, it stays developed, because fixing a bug in one View''s functionality
    doesn''t impact other views. On the flip side, if [you use] visual inheritance
    effectively and [create] reusable user controls, fixing a bug in one place can
    fix issues throughout the application.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[有效实现MVVM]本质上强制执行关注点的正确分离。业务逻辑与展示逻辑清晰分离。因此，当一个视图被开发时，它就会保持开发状态，因为修复一个视图功能中的错误不会影响其他视图。另一方面，如果[你使用]视觉继承有效并[创建]可重用的用户控件，修复一个地方的错误可以解决整个应用程序中的问题。'
- en: Angular provides an effective implementation of MVVM.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了MVVM的有效实现。
- en: ViewModels neatly encapsulate any presentation logic and allow for simpler View
    code by acting as a specialized version of the model. The relationship between
    a View and ViewModel is straightforward, allowing for more natural ways to wrap
    UI behavior in reusable user controls.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModels清晰地封装任何展示逻辑，并通过作为模型的专业版本来简化View代码。View和ViewModel之间的关系很直接，可以更自然地将UI行为包装在可重用的用户控件中。
- en: You can read further about the architectural nuance, with illustrations, at [http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC)阅读更多关于架构细微差别的内容和插图。
- en: 'Next, you will create your very first Angular component, which will include
    the View and the ViewModel, using Angular CLI''s `ng generate` command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建你的第一个Angular组件，其中将包括View和ViewModel，使用Angular CLI的`ng generate`命令：
- en: In the terminal, execute `npx ng generate component current-weather`
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，执行`npx ng generate component current-weather`
- en: Ensure that you are executing `ng` commands under the `local-weather-app` folder,
    and not under the `root` project folder. In addition, note that `npx ng generate
    component current-weather` can be rewritten as `ng g c current-weather`. Going
    forward, this book will utilize the shorthand format and expect you to prepend `npx`,
    if necessary.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在`local-weather-app`文件夹下执行`ng`命令，而不是在`root`项目文件夹下执行。此外，请注意`npx ng generate
    component current-weather`可以重写为`ng g c current-weather`。今后，本书将使用简写格式，并期望你在必要时加上`npx`。
- en: 'Observe the new files created in your `app` folder:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察在你的`app`文件夹中创建的新文件：
- en: '[PRE22]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A generated component has four parts:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的组件有四个部分：
- en: '`current-weather.component.css` contains any CSS that is specific to the component
    and is an optional file'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather.component.css`包含特定于组件的任何CSS，并且是一个可选文件。'
- en: '`current-weather.component.html` contains the HTML template that defines the
    look of the component and rendering of the bindings, and can be considered the
    View, in combination with any CSS styles used'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather.component.html`包含定义组件外观和绑定渲染的HTML模板，并且可以被视为View，结合使用的任何CSS样式。'
- en: '`current-weather.component.spec.ts` contains Jasmine-based unit tests that
    you can extend to test your component functionality'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather.component.spec.ts`包含基于Jasmine的单元测试，你可以扩展以测试你的组件功能。'
- en: '`current-weather.component.ts` contains the `@Component` decorator above the class
    definition and is the glue that ties together the CSS, HTML, and JavaScript code
    together. The class itself can be considered the ViewModel, pulling data from
    services and performing any necessary transformations to expose sensible bindings
    for the View, as shown as follows:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather.component.ts`包含了类定义上方的`@Component`装饰器，它是将CSS、HTML和JavaScript代码粘合在一起的粘合剂。类本身可以被视为ViewModel，从服务中提取数据并执行任何必要的转换，以公开视图的合理绑定，如下所示：'
- en: '[PRE23]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the component you're planning to write is a simple one, you can rewrite it
    using inline styles and an inline template, to simplify the structure of your
    code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划编写的组件很简单，可以使用内联样式和内联模板重写它，以简化代码结构。
- en: 'Update `CurrentWeatherComponent` with an inline template and styles:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内联模板和样式更新`CurrentWeatherComponent`：
- en: '[PRE24]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you executed the generate command, in addition to creating the component,
    the command also added the new module you created to `app.module.ts`, avoiding
    an otherwise tedious task of wiring up components together:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行生成命令时，除了创建组件，该命令还将您创建的新模块添加到`app.module.ts`中，避免了将组件连接在一起的繁琐任务。
- en: '[PRE25]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The bootstrap process of Angular is, admittedly, a bit convoluted. This is the
    chief reason Angular CLI exists. `index.html` contains an element named `<app-root>`.
    When Angular begins execution, it first loads `main.ts`, which configures the
    framework for browser use and loads the app module. App module then loads all
    its dependencies and renders within the aforementioned `<app-root>` element. In
    [Chapter 7](b35a976c-1709-4f43-9c4e-1cf957e7ca6c.xhtml), *Create a Router-First
    Line-of-Business App*, when we build a line-of-business app, we will create our
    own feature modules to take advantage of the scalability features of Angular.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的引导过程，诚然有点复杂。这也是Angular CLI存在的主要原因。`index.html`包含一个名为`<app-root>`的元素。当Angular开始执行时，它首先加载`main.ts`，该文件配置了用于浏览器的框架并加载了应用模块。应用模块然后加载所有依赖项，并在前述的`<app-root>`元素内呈现。在[第7章](b35a976c-1709-4f43-9c4e-1cf957e7ca6c.xhtml)中，*创建一个以路由为首的业务应用程序*，当我们构建一个业务应用程序时，我们将创建自己的功能模块，以利用Angular的可扩展性特性。
- en: 'Now, we need to display our new component on the initial `AppComponent` template,
    so it is visible to the end user:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在初始的`AppComponent`模板上显示我们的新组件，以便最终用户可以看到：
- en: 'Add the `CurrentWeatherComponent` to `AppComponent` by replacing `<div>current
    weather</div>` with `<app-current-weather></app-current-weather>`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过用`<app-current-weather></app-current-weather>`替换`<div>current weather</div>`，将`CurrentWeatherComponent`添加到`AppComponent`中：
- en: '[PRE26]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If everything worked correctly, you should see this:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常，您应该会看到这个：
- en: '![](Images/0ae2d6b8-f075-4af4-a501-c31dd137408d.png)Initial render of your
    local weather appNote the icon and name in the tab of the browser window. As a
    web development norm, in the `index.html` file, update the `<title>` tag and the
    `favicon.ico` file with the name and icon of your application to customize the
    browser tab information. If your favicon doesn''t update, append the `href` attribute
    with a unique version number, such as `href="favicon.ico?v=2"`. As a result, your
    app will start looking like a real web app, instead of a CLI-generated starter
    project.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/0ae2d6b8-f075-4af4-a501-c31dd137408d.png)您的本地天气应用程序的初始渲染请注意浏览器窗口标签中的图标和名称。作为Web开发的规范，在`index.html`文件中，使用应用程序的名称和图标更新`<title>`标签和`favicon.ico`文件，以自定义浏览器标签信息。如果您的favicon没有更新，请在`href`属性后附加一个唯一的版本号，例如`href="favicon.ico?v=2"`。结果，您的应用程序将开始看起来像一个真正的Web应用程序，而不是一个由CLI生成的起始项目。'
- en: Define your model using interfaces
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用接口定义您的模型
- en: 'Now that your `View` and `ViewModel` are in place, you need to define your
    `Model`. If you look back on the design, you will see that the component needs
    to display:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的`View`和`ViewModel`已经就位，你需要定义你的`Model`。如果你回顾设计，你会发现组件需要显示：
- en: City
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 城市
- en: Country
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国家
- en: Current date
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前日期
- en: Current image
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前图片
- en: Current temperature
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前温度
- en: Current weather description
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前天气描述
- en: 'You will first create an interface that represents this data structure:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先创建一个代表这个数据结构的接口：
- en: In the terminal, execute `npx ng generate interface ICurrentWeather`
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，执行`npx ng generate interface ICurrentWeather`
- en: 'Observe a newly generated file named `icurrent-weather.ts` with an empty interface
    definition that looks like this:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察一个新生成的名为`icurrent-weather.ts`的文件，其中包含一个空的接口定义，看起来像这样：
- en: '[PRE27]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is not an ideal setup, since we may add numerous interfaces to our app
    and it can get tedious to track down various interfaces. Over time, as you add
    concrete implementations of these interfaces as classes, then it will make sense
    to put classes and their interfaces in their own files.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个理想的设置，因为我们可能会向我们的应用程序添加许多接口，追踪各种接口可能会变得乏味。随着时间的推移，当你将这些接口的具体实现作为类添加时，将把类和它们的接口放在自己的文件中是有意义的。
- en: Why not just call the interface `CurrentWeather`? This is because later on we
    may create a class to implement some interesting behavior for `CurrentWeather`.
    Interfaces establish a contract, establishing the list of available properties
    on any class or interface that implements or extends the interface. It is always
    important to be aware of when you're using a class versus an interface. If you
    follow the best practice to always start your interface names with a capital `I`,
    you will always be conscious of what type of an object you are passing around.
    Hence, the interface is named `ICurrentWeather`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接将接口命名为`CurrentWeather`？这是因为以后我们可能会创建一个类来实现`CurrentWeather`的一些有趣的行为。接口建立了一个契约，确定了任何实现或扩展接口的类或接口上可用属性的列表。始终要意识到何时使用类与接口是非常重要的。如果你遵循最佳实践，始终以大写`I`开头命名你的接口，你将始终意识到你正在传递的对象的类型。因此，接口被命名为`ICurrentWeather`。
- en: Rename `icurrent-weather.ts` to `interfaces.ts`
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`icurrent-weather.ts`重命名为`interfaces.ts`
- en: Correct the capitalization of the interface name to `ICurrentWeather`
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将接口名称的大写改正为`ICurrentWeather`
- en: 'Also, implement the interface as follows:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，按照以下方式实现接口：
- en: '[PRE28]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This interface and its eventual concrete representation as a class is the Model
    in MVVM. So far, I have highlighted how various parts of Angular fit the MVVM
    pattern; going forward, I will be referring to these parts with their actual names.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口及其最终的具体表示作为一个类是MVVM中的模型。到目前为止，我已经强调了Angular的各个部分如何符合MVVM模式；未来，我将用它们的实际名称来引用这些部分。
- en: Now, we can import the interface into the component and start wiring up the
    bindings in the template of `CurrentWeatherComponent`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将接口导入到组件中，并开始在`CurrentWeatherComponent`的模板中连接绑定。
- en: Import `ICurrentWeather`
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`ICurrentWeather`
- en: Switch back to the `templateUrl` and ``styleUrls``
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回`templateUrl`和`styleUrls`
- en: Define a local variable called `current` with type `ICurrentWeather`
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`current`的局部变量，类型为`ICurrentWeather`
- en: '[PRE29]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you just type `current: ICurrentWeather`, you can use the auto-fixer to
    automatically insert the import statement.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你只是输入`current: ICurrentWeather`，你可以使用自动修复程序自动插入导入语句。'
- en: In the constructor, you will temporarily populate the current property with
    dummy data to test your bindings.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，你将临时用虚拟数据填充当前属性以测试你的绑定。
- en: 'Implement dummy data as a JSON object and declare its adherence to `ICurrentWeather`
    using the as operator:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将虚拟数据实现为一个JSON对象，并使用as运算符声明其遵守`ICurrentWeather`：
- en: '[PRE30]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `src/assets` folder, create a subfolder named `img` and place an image
    of your choice to reference in your dummy data.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/assets`文件夹中，创建一个名为`img`的子文件夹，并放置一张你选择的图片以在虚拟数据中引用。
- en: 'You may forget the exact properties in the interface you created. You can get
    a quick peek at them by holding *Ctrl* + hover-over the interface name with your
    mouse, as shown:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会忘记你创建的接口中的确切属性。你可以通过按住*Ctrl*并将鼠标悬停在接口名称上来快速查看它们，如下所示：
- en: '![](Images/9875716b-28c2-4286-8436-3365b3357d40.png)*Ctrl* + hover-over the
    interface'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/9875716b-28c2-4286-8436-3365b3357d40.png)*Ctrl* + 悬停在接口上'
- en: Now you update the template to wire up your bindings with a rudimentary HTML-based
    layout.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以更新模板，将你的绑定与基本的基于HTML的布局连接起来。
- en: 'Implement the template:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现模板：
- en: '[PRE31]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To change the display formatting of `current.date`, we used the `DatePipe` above,
    passing in `'fullDate'` as the format option. In Angular, various out-of-the-box
    and custom pipe `|` operators can be used to change the appearance of data without
    actually changing the underlying data. This is a very powerful, convenient, and
    flexible system to share such user interface logic without writing repetitive
    boilerplate code. In the preceding example, we could pass in `'shortDate'` if
    we wanted to represent the current date in a more compact form. For more information
    on various `DatePipe` options, refer to the documentation at [https://angular.io/api/common/DatePipe](https://angular.io/api/common/DatePipe). To
    format `current.temperature` so that no fractional values are shown, you can use
    `DecimalPipe`. The documentation is at [https://angular.io/api/common/DecimalPipe](https://angular.io/api/common/DecimalPipe).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改`current.date`的显示格式，我们使用了上面的`DatePipe`，传入`'fullDate'`作为格式选项。在Angular中，各种内置和自定义管道`|`操作符可用于改变数据的外观，而不实际改变基础数据。这是一个非常强大、方便和灵活的系统，可以在不编写重复的样板代码的情况下共享用户界面逻辑。在上面的例子中，如果我们想以更紧凑的形式表示当前日期，我们可以传入`'shortDate'`。有关各种`DatePipe`选项的更多信息，请参阅[https://angular.io/api/common/DatePipe](https://angular.io/api/common/DatePipe)上的文档。要格式化`current.temperature`，以便不显示小数值，可以使用`DecimalPipe`。文档在[https://angular.io/api/common/DecimalPipe](https://angular.io/api/common/DecimalPipe)。
- en: Note that you can render ℃ and ℉ using their respective HTML codes: ![](Images/3aead4cb-5060-4f39-99ff-77e8378a22e7.png) for
    ℃ and ![](Images/e8c94057-be77-44bd-9f19-f7c814114fa2.png) for ℉.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以使用它们各自的HTML代码来渲染℃和℉： ![](Images/3aead4cb-5060-4f39-99ff-77e8378a22e7.png) 代表℃， ![](Images/e8c94057-be77-44bd-9f19-f7c814114fa2.png) 代表℉。
- en: 'If everything worked correctly, you app should be looking similar to this screenshot:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常，你的应用程序应该看起来类似于这个截图：
- en: '![](Images/39d31e79-3c3f-482d-993a-01450525f3d9.png)App after wiring up bindings
    with dummy data'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/39d31e79-3c3f-482d-993a-01450525f3d9.png)绑定虚拟数据后的应用程序'
- en: Congratulations, you have successfully wired up your first component.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，你已成功连接了你的第一个组件。
- en: Using Angular Services and HttpClient to retrieve data
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular服务和HttpClient来检索数据
- en: 'Now you need to connect your `CurrentWeather` component to the `OpenWeatherMap`
    APIs. In the upcoming sections, we will go over the following steps to accomplish
    this goal:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要将你的`CurrentWeather`组件连接到`OpenWeatherMap`的API。在接下来的章节中，我们将介绍以下步骤来实现这个目标：
- en: Create a new Angular Service
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Angular服务
- en: Import `HttpClientModule` and inject it into the service
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`HttpClientModule`并将其注入到服务中
- en: Discover the `OpenWeatherMap` API
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发现`OpenWeatherMap` API
- en: Create a new interface that conforms to the shape of the API
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个符合API形状的新接口
- en: Write a `get` request
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`get`请求
- en: Inject the new service into the `CurrentWeather` component
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新服务注入到`CurrentWeather`组件中
- en: Call the service from the `init` function of the `CurrentWeather` component
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`CurrentWeather`组件的`init`函数中调用服务
- en: Finally, map the API data to the local `ICurrentWeather` type using RxJS functions
    so that it can be consumed by your component
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 RxJS 函数将 API 数据映射到本地的`ICurrentWeather`类型，以便组件可以使用它
- en: Creating a new Angular Service
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的 Angular 服务
- en: Any code that touches outside of the boundaries of a component should exist
    in a service; this includes inter-component communication, unless there's a parent-child
    relationship, and API calls of any kind and any code that cache or retrieve data
    from a cookie or the browser's localStorage. This is a critical architectural
    pattern that keeps your application maintainable in the long term. I expand upon
    this idea in my DevPro MVVM article at [http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 任何触及组件边界之外的代码都应该存在于一个服务中；这包括组件间的通信，除非存在父子关系，以及任何缓存或从 cookie 或浏览器的 localStorage
    中检索数据的代码。这是一个关键的架构模式，可以使您的应用在长期内易于维护。我在我的 DevPro MVVM 文章中对这个想法进行了扩展，网址为 [http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC)。
- en: 'To create an Angular service, do this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 Angular 服务，执行以下操作：
- en: In the terminal, execute `npx ng g s weather --flat false`
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行 `npx ng g s weather --flat false`
- en: 'Observe the new `weather` folder created:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察新创建的`weather`文件夹：
- en: '[PRE32]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A generated service has two parts:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的服务有两部分：
- en: '`weather.service.spec.ts` contains Jasmine-based unit tests that you can extend
    to test your service functionality.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weather.service.spec.ts` 包含了基于 Jasmine 的单元测试，您可以扩展以测试您的服务功能。'
- en: '`weather.service.ts` contains the `@Injectable` decorator above the class definition,
    which makes it possible to inject this service into other components, leveraging
    Angular''s provider system. This will ensure that our service will be a singleton,
    meaning only instantiated once, no matter how many times it is injected elsewhere.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weather.service.ts` 包含了类定义之上的`@Injectable`装饰器，这使得可以将此服务注入到其他组件中，利用 Angular
    的提供者系统。这将确保我们的服务是单例的，意味着无论它被注入到其他地方多少次，它只会被实例化一次。'
- en: 'The service is generated, but it''s not automatically provided. To do this,
    follow these steps:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 服务已经生成，但没有自动提供。要做到这一点，请按照以下步骤操作：
- en: Open `app.module.ts`
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.module.ts`
- en: Type in `WeatherService` inside the providers array
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 providers 数组中输入`WeatherService`
- en: 'Use the auto-fixer to import the class for you:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自动修复程序为您导入类：
- en: '[PRE33]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you installed the recommended extension TypeScript Hero, the import statement
    will be automatically added for you. You won't have to use the auto-fixer to do
    it. Going forward, I will not call out the need to import modules.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您安装了推荐的扩展程序 TypeScript Hero，导入语句将会自动添加。您不必使用自动修复程序来完成。今后，我将不再提到导入模块的需要。
- en: Inject dependencies
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入依赖项
- en: 'In order to make API calls, you will be leveraging the `HttpClient` module
    in Angular. The official documentation ([https://angular.io/guide/http](https://angular.io/guide/http))
    explains the benefits of this module succinctly:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行 API 调用，您将在 Angular 中利用`HttpClient`模块。官方文档 ([https://angular.io/guide/http](https://angular.io/guide/http))
    简洁地解释了这个模块的好处：
- en: '"With HttpClient, @angular/common/http provides a simplified API for HTTP functionality
    for use with Angular applications, building on top of the XMLHttpRequest interface
    exposed by browsers. Additional benefits of HttpClient include testability support,
    strong typing of request and response objects, request and response interceptor
    support, and better error handling via APIs based on Observables."'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: “使用 HttpClient，@angular/common/http 为 Angular 应用程序提供了一个简化的 HTTP 功能 API，构建在浏览器暴露的
    XMLHttpRequest 接口之上。HttpClient 的额外好处包括可测试性支持，请求和响应对象的强类型化，请求和响应拦截器支持，以及基于 Observables
    的更好的错误处理。”
- en: 'Let''s start with importing the `HttpClientModule` in to our app, so we can
    inject the `HttpClient` within the module into the `WeatherService`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将`HttpClientModule`导入到我们的应用程序开始，这样我们就可以在模块中将`HttpClient`注入到`WeatherService`中：
- en: 'Add `HttpClientModule` to `app.module.ts`, as follows:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`HttpClientModule`添加到`app.module.ts`中，如下所示：
- en: '[PRE34]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Inject `HttpClient` provided by the `HttpClientModule` in the  `WeatherService`, as
    follows:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WeatherService`中注入`HttpClient`，由`HttpClientModule`提供，如下所示：
- en: '[PRE35]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, `httpClient` is ready for use in your service.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`httpClient`已经准备好在您的服务中使用。
- en: Storing environment variables
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储环境变量
- en: 'It''s easy to miss, but the sample URL from previous sections contains a required `appid` parameter.
    You must store this key in your Angular app. You can store it in the weather service,
    but in reality, applications need to be able to target different sets of resources
    as they move from development to testing, staging, and production environments.
    Out of the box, Angular provides two environments: one `prod` and the other one
    as the default.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易忽略，但是前几节中的示例URL包含一个必需的`appid`参数。您必须将此密钥存储在您的Angular应用程序中。您可以将其存储在天气服务中，但实际上，应用程序需要能够在从开发到测试、暂存和生产环境的不同资源集之间切换。Angular提供了两个环境：一个是`prod`，另一个是默认的。
- en: Before you can continue, you need to sign up for a free `OpenWeatherMap` account
    and retrieve your own `appid`. You can read the documentation for `appid` at [http://openweathermap.org/appid ](http://openweathermap.org/appid)for
    more detailed information.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您需要注册一个免费的`OpenWeatherMap`帐户并检索您自己的`appid`。您可以阅读[http://openweathermap.org/appid](http://openweathermap.org/appid)上的`appid`文档以获取更详细的信息。
- en: Copy your `appid`, which will have a long string of characters and numbers
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制您的`appid`，它将包含一长串字符和数字
- en: Store your `appid `in `environment.ts`
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的`appid`存储在`environment.ts`中
- en: 'Configure `baseUrl` for later use:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为以后使用配置`baseUrl`：
- en: '[PRE36]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In code, we use a camel-case `appId` to keep our coding style consistent. Since
    URL parameters are case-insensitive, `appId` will work as well as `appid`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们使用驼峰命名法`appId`来保持我们的编码风格一致。由于URL参数不区分大小写，`appId`和`appid`都可以使用。
- en: Implementing an HTTP GET operation
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现HTTP GET操作
- en: 'Now, we can implement the GET call in the Weather service:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在天气服务中实现GET调用：
- en: Add a new function to the `WeatherService` class named `getCurrentWeather`
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WeatherService`类中添加一个名为`getCurrentWeather`的新函数
- en: Import the `environment` object
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`environment`对象
- en: Implement the `httpClient.get` function
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`httpClient.get`函数
- en: 'Return the results of the HTTP call:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回HTTP调用的结果：
- en: '[PRE37]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note the use of ES2015's String Interpolation feature. Instead of building your
    string by appending variables to one another like `environment.baseUrl + 'api.openweathermap.org/data/2.5/weather?q='
    + city + ',' + country + '&appid=' + environment.appId`, you can use the backtick
    syntax to wrap ``your string``. Inside the backticks, you can have newlines and
    also directly embed variables into the flow of your string by wrapping them with
    the `${dollarbracket}` syntax. However, when you introduce a newline in your code,
    it will be interpreted as a literal newline—`\n`. In order to break up the string
    in your code, you may add a backslash `\`, but then the next line of your code
    can have no indentation. It is easier to just concatenate multiple templates,
    as shown in the preceding code sample.Note the use TypeScript Generics with the
    get function using the caret syntax like `<TypeName>`. Using generics is development-time
    quality of life feature. By providing the type information to the function, input
    and/or return variables types of that function will be displayed as your write
    your code and validated during development and also at compile time.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意ES2015的字符串插值特性的使用。您可以使用反引号语法包裹``您的字符串``，而不是通过将变量追加到一起来构建字符串，例如`environment.baseUrl
    + 'api.openweathermap.org/data/2.5/weather?q=' + city + ',' + country + '&appid='
    + environment.appId`。在反引号内，您可以有换行，并且还可以直接嵌入变量到字符串流中，方法是用`${dollarbracket}`语法将它们包裹起来。但是，当您在代码中引入换行时，它将被解释为字面换行—`\n`。为了在代码中断开字符串，您可以添加反斜杠`\`，但是接下来的代码行不能有缩进。更容易的方法是连接多个模板，就像前面的代码示例中所示的那样。请注意，在`get`函数中使用了TypeScript泛型，使用了尖括号语法，如`<TypeName>`。使用泛型是开发时的生活质量特性。通过向函数提供类型信息，该函数的输入和/或返回变量类型将在编写代码时显示并在开发和编译时进行验证。
- en: Retrieving service data from a component
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从组件中检索服务数据
- en: 'To be able to use the `getCurrentWeather` function in the `CurrentWeather`
    component, you need to inject the service into the component:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在`CurrentWeather`组件中使用`getCurrentWeather`函数，您需要将服务注入到组件中：
- en: Inject the `WeatherService` into the constructor of the `CurrentWeatherComponent`
    class
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`WeatherService`注入到`CurrentWeatherComponent`类的构造函数中
- en: 'Remove the existing code that created the dummy data in the constructor:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除在构造函数中创建虚拟数据的现有代码：
- en: '[PRE38]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Call the `getCurrentWeather` function inside the `ngOnInit` function:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ngOnInit`函数中调用`getCurrentWeather`函数：
- en: '[PRE39]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Fair warning, do not expect this code to be working just yet. You should see
    an error, so let's understand what's going in the next segment.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 公平警告，不要指望这段代码立即能够工作。您应该会看到一个错误，所以让我们在下一部分中了解发生了什么。
- en: Angular components have a rich collection of life cycle hooks that allow you
    to inject your custom behavior, when a component is being rendered, refreshed,
    or destroyed. `ngOnInit()` is the most common life cycle hook you will be using.
    It is only called once, when a component is first instantiated or visited. This
    is where you will want to perform your service calls. For a deeper understanding
    of component life cycle hooks, check out the documentation at [https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks).Note
    that the anonymous function you have passed to `subscribe` is an ES2015 arrow
    function. If you're not familiar with arrow functions, it may be confusing at
    first. Arrow functions are actually quite elegant and simple.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Angular组件具有丰富的生命周期钩子集合，允许您在组件被渲染、刷新或销毁时注入自定义行为。`ngOnInit()`是您将要使用的最常见的生命周期钩子。它只会在组件首次实例化或访问时被调用。这是您希望执行服务调用的地方。要深入了解组件生命周期钩子，请查看文档[https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks)。请注意，您传递给`subscribe`的匿名函数是ES2015的箭头函数。如果您不熟悉箭头函数，一开始可能会感到困惑。箭头函数实际上非常简洁和简单。
- en: 'Consider the following arrow function:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下箭头函数：
- en: '`(data) => { this.current = data }`'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`(data) => { this.current = data }`'
- en: 'You can rewrite it simply as:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简单地重写它为：
- en: '`function(data) { this.current = data }`'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`function(data) { this.current = data }`'
- en: 'There''s a special condition—when you write an arrow function that simply transforms
    a piece of data, such as this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊条件——当您编写一个简单转换数据的箭头函数时，比如这样：
- en: '`(data) => { data.main.temp }`'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`(data) => { data.main.temp }`'
- en: 'This function effectively takes `ICurrentWeatherData` as an input and returns
    the temp property. The return statement is implicit. If you rewrite it as a regular
    function, it will look like this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能有效地将`ICurrentWeatherData`作为输入，并返回temp属性。返回语句是隐式的。如果将其重写为常规函数，它将如下所示：
- en: '`function(data) { return data.main.temp }`'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`function(data) { return data.main.temp }`'
- en: When the `CurrentWeather` component loads, `ngOnInit` will fire once, which
    will call the `getCurrentWeather` function that returns an object with a type
    of `Observable<ICurrentWeatherData>`. An Observable, as described in the official
    documentation, *is the most basic building block of RxJS* that represents an event
    emitter, which will emit any data received over time with the type of `ICurrentWeatherData`.
    The `Observable` object by itself is benign and will not cause a network event
    to be fired unless it is being listened to. You can read more about Observables
    at [reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将触发一次，这将调用`getCurrentWeather`函数，该函数返回一个类型为`Observable<ICurrentWeatherData>`的对象。如官方文档所述，Observable是RxJS的最基本构建块，表示事件发射器，它将以`ICurrentWeatherData`类型随时间发出接收到的任何数据。`Observable`对象本身是无害的，除非被监听，否则不会引发网络事件。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)上阅读更多关于Observables的信息。
- en: By calling `.subscribe` on the Observable, you're essentially attaching a listener
    to the emitter. You've implemented an anonymous function within the `subscribe`
    method, which will get executed whenever a new piece of data is received and an
    event is emitted. The anonymous function takes a data object as a parameter, and,
    the specific implementation in this case, assigns the piece of data to the local
    variable named current. Whenever current is updated, the template bindings you
    implemented earlier will pull in the new data and render it on the view. Even
    though `ngOnInit` executes only once, the subscription to the Observable persists.
    So whenever there's new data, the current variable will be updated and the view
    will rerender to display the latest data.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Observable上调用`.subscribe`，实质上是将侦听器附加到发射器上。您在`subscribe`方法中实现了一个匿名函数，每当接收到新数据并发出事件时，该函数将被执行。匿名函数以数据对象作为参数，并且在这种情况下的具体实现中，将数据分配给名为current的局部变量。每当current更新时，您之前实现的模板绑定将拉取新数据并在视图上呈现它。即使`ngOnInit`只执行一次，对Observable的订阅仍然存在。因此，每当有新数据时，current变量将被更新，并且视图将重新呈现以显示最新数据。
- en: The root cause of the error at hand is that the data that is being emitted is
    of type `ICurrentWeatherData`; however, our component only understands data that
    is shaped as described by the `ICurrentWeather` interface. In the next section,
    you will need to dig deeper into RxJS to understand how best to accomplish that
    task.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 手头错误的根本原因是正在发出的数据是`ICurrentWeatherData`类型；但是，我们的组件只能理解按照`ICurrentWeather`接口描述的形状的数据。在下一节中，您需要深入了解RxJS，以了解如何最好地完成该任务。
- en: 'Beware, VS Code and CLI sometimes stop working. As previously noted, as you
    code, the `npm start` command is running in the integrated terminal of VS Code.
    Angular CLI, in combination with the Angular Language Service plug-in, continuously
    watches for code changes and transpiles your TypeScript code to JavaScript, so
    you can observe your changes with live-reloading in the browser. The great thing
    is that when you make coding errors, in addition to the red underlining in VS
    Code, you will also see some red text in the terminal or even the browser, because
    the transpilation has failed. In most cases, when correcting the error, the red
    underlining will go away and Angular CLI will automatically retranspile your code
    and everything will work. However, under certain scenarios, you will note that
    VS Code will fail to pick typing changes in the IDE, so you won''t get autocompletion
    help or the CLI tool will get stuck with message saying webpack: Failed to compile.
    You have two main strategies to recover from such conditions:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，VS Code 和 CLI 有时会停止工作。如前所述，当您编写代码时，`npm start` 命令正在 VS Code 的集成终端中运行。Angular
    CLI 与 Angular Language Service 插件结合，不断监视代码更改并将您的 TypeScript 代码转译为 JavaScript，因此您可以在浏览器中实时查看您的更改。很棒的是，当您出现编码错误时，除了在
    VS Code 中的红色下划线外，您还会在终端或甚至浏览器中看到一些红色文本，因为转译失败了。在大多数情况下，纠正错误后，红色下划线将消失，Angular
    CLI 将自动重新转译您的代码，一切都会正常工作。然而，在某些情况下，您会注意到 VS Code 无法在 IDE 中捕捉到输入更改，因此您将无法获得自动补全帮助，或者
    CLI 工具会卡在显示“webpack: Failed to compile”的消息上。您有两种主要策略来从这种情况中恢复：'
- en: Click on the terminal and hit *Ctrl* + *C*to stop running the CLI task and restart
    by executing `npm start`
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击终端并按 *Ctrl* + *C* 停止运行 CLI 任务，然后通过执行 `npm start` 重新启动
- en: If **#1** doesn't work, quit VS Code with *Alt* + *F4* for Windows or ⌘ + *Q*
    for macOS and restart it
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 **#1** 不起作用，请使用 *Alt* + *F4*（Windows）或 ⌘ + *Q*（macOS）退出 VS Code 并重新启动它
- en: Given Angular and VS Code's monthly releases cycles, I'm confident that in time
    the tooling can only improve.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 Angular 和 VS Code 的每月发布周期，我相信随着时间的推移，工具只会变得更好。
- en: Transform data using RxJS
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RxJS 转换数据
- en: RxJS stands for Reactive Extensions, which is a modular library that enables
    reactive programming, which itself is an asynchronous programming paradigm and
    allows for manipulation of data streams through transformation, filtering, and
    control functions. You can think of reactive programming as an evolution of event-based
    programming.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 代表响应式扩展，这是一个模块化库，可以实现响应式编程，这本身是一种异步编程范式，并允许通过转换、过滤和控制函数来操作数据流。您可以将响应式编程视为事件驱动编程的演变。
- en: Understanding Reactive programming
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解响应式编程
- en: In Event-Driven programming, you would define an event handler and attach it
    to an event source. In more concrete terms, if you had a save button, which exposes
    an `onClick` event, you would implement a `confirmSave` function, which when triggered,
    would show a popup to ask the user Are you sure?. Look at the following figure
    for a visualization of this process.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动编程中，您会定义一个事件处理程序并将其附加到事件源。更具体地说，如果您有一个保存按钮，它公开了一个 `onClick` 事件，您将实现一个 `confirmSave`
    函数，当触发时，会显示一个弹出窗口询问用户“您确定吗？”。请看下图以可视化此过程。
- en: '![](Images/087093d4-6cc4-4942-b53f-61a0cbce08f8.png)Event-Driven Implementation'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/087093d4-6cc4-4942-b53f-61a0cbce08f8.png)事件驱动实现'
- en: In short, you would have an event firing once per user action. If the user clicks
    on the save button many times, this pattern would gladly render as many popups
    as there are clicks, which doesn't make much sense.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，您将有一个事件在每次用户操作时触发。如果用户多次点击保存按钮，这种模式将愉快地渲染出与点击次数相同的弹出窗口，这并没有太多意义。
- en: The publish-subscribe (pub/sub) pattern is a different type of event-driven
    programming. In this case, we can write multiple handlers to act on the result
    of a given event all simultaneously. Let's say that your app just received some
    updated data. The publisher will go through its list of subscribers and pass on
    the updated data to each of them. Refer to the following diagram, how can updated
    data event trigger an `updateCache` function that can update your local cache
    with new data, a `fetchDetails` function that can retrieve further details about
    the data from the server, and also a `showToastMessage` function that can inform
    the user that the app just received new data. All these events can happen asynchronously;
    however, the `fetchDetails` and `showToastMessage` functions will be receiving
    more data than they really need, and it can get really convoluted to try to compose
    these events in different ways to modify application behavior.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅（pub/sub）模式是一种不同类型的事件驱动编程。在这种情况下，我们可以编写多个处理程序来同时处理给定事件的结果。假设您的应用程序刚刚收到了一些更新的数据。发布者将遍历其订阅者列表，并将更新的数据传递给它们每一个。参考以下图表，更新的数据事件如何触发一个`updateCache`函数，该函数可以使用新数据更新本地缓存，一个`fetchDetails`函数，该函数可以从服务器检索有关数据的更多详细信息，以及一个`showToastMessage`函数，该函数可以通知用户应用程序刚刚收到了新数据。所有这些事件都可以异步发生；但是，`fetchDetails`和`showToastMessage`函数将接收比它们实际需要的更多数据，并且尝试以不同方式组合这些事件以修改应用程序行为可能会变得非常复杂。
- en: '![](Images/cfdf8261-a38b-401f-97b8-3f23210b81bf.png)Pub/Sub Pattern Implementation'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/cfdf8261-a38b-401f-97b8-3f23210b81bf.png)发布-订阅模式实现'
- en: In reactive programming, everything is treated as a stream. A stream will contain
    events that happen over time and these events can contain some data or no data.
    The following diagram visualizes a scenario where your app is listening for mouse
    clicks from the user. Uncontrolled streams of user clicks are meaningless. You
    exert some control over this stream by applying the `throttle` function to it,
    so you only get updates every 250 **milliseconds** (**ms**). If you subscribe
    to this new event, every 250 ms, you will receive a list of click events. You
    may try to extract some data from each click event, but in this case, you're only
    interested in the number of click events that happened. We can shape the raw event
    data into number of clicks using the `map` function.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式编程中，一切都被视为流。流将包含随时间发生的事件，这些事件可以包含一些数据或没有数据。以下图表可视化了一个场景，您的应用程序正在监听用户的鼠标点击。无序的用户点击流是没有意义的。通过对其应用`throttle`函数，您可以对此流施加一些控制，以便每250毫秒只获取更新。如果订阅此新事件，每250毫秒，您将收到一个点击事件列表。您可以尝试从每个点击事件中提取一些数据，但在这种情况下，您只对发生的点击事件数量感兴趣。我们可以使用`map`函数将原始事件数据转换为点击次数。
- en: Further down the stream, we may only be interested in listening for events with
    two or more clicks in it, so we can use the `filter` function to only act on what
    is essentially a double-click event. Every time our filter event fires, it means
    that the user intended to double-click, and you can act on that information by
    popping up an alert. The true power for streams comes from the fact that you can
    choose to act on the event at any time as it passes through various control, transformation,
    and filter functions. You can choose to display click data on an HTML list using
    `*ngFor` and Angular's `async` pipe, so the user can monitor the types of click
    data being captured every 250ms.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在流的下游，我们可能只对包含两个或更多点击的事件感兴趣，因此我们可以使用`filter`函数仅对本质上是双击事件的事件进行操作。每当我们的过滤事件触发时，这意味着用户打算双击，您可以通过弹出警报来对此信息进行操作。流的真正力量来自于您可以选择在任何时候对事件进行操作，因为它通过各种控制、转换和过滤函数。您可以选择使用`*ngFor`和Angular的`async`管道在HTML列表上显示点击数据，以便用户可以每250毫秒监视被捕获的点击数据类型。
- en: '![](Images/e47a3a03-78c2-45ee-ae01-35bae1e77478.png)A Reactive Data Stream
    Implementation'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/e47a3a03-78c2-45ee-ae01-35bae1e77478.png)一个响应式数据流实现'
- en: Implementing Reactive transformations
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施响应式转换
- en: 'To avoid future mistakes in returning the unintended type of data from your
    service, you need to update the `getCurrentWeather` function to define the return
    type to be `Observable<ICurrentWeather>` and import the `Observable` type, as
    shown:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免将意外类型的数据从您的服务中返回，您需要更新`getCurrentWeather`函数以定义返回类型为`Observable<ICurrentWeather>`，并导入`Observable`类型，如下所示：
- en: '[PRE40]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, VS Code will let you know that Type `Observable<ICurrentWeatherData>` is
    not assignable to type `Observable<ICurrentWeather>`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，VS Code会提醒您，`Observable<ICurrentWeatherData>`类型无法赋值给`Observable<ICurrentWeather>`类型：
- en: Write a transformation function named `transformToICurrentWeather` that can
    convert `ICurrentWeatherData` to `ICurrentWeather`
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`transformToICurrentWeather`的转换函数，可以将`ICurrentWeatherData`转换为`ICurrentWeather`
- en: 'Also, write a helper function named `convertKelvinToFahrenheit` that converts
    the API provided Kelvin temperature to Fahrenheit:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，编写一个名为`convertKelvinToFahrenheit`的辅助函数，将API提供的开尔文温度转换为华氏度：
- en: '[PRE42]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that you need to be converting the icon property to an image URL at this
    stage. Doing this in the service helps preserve encapsulation, binding the icon
    value to the URL in the view template will break the **Separation of concerns**
    (**SoC**) principle. If you wish to create truly modular, reusable, and maintainable
    components, you must remain vigilant and strict in terms of enforcing SoC. The
    documentation for Weather Icons and details of how the URL should be formed, including
    all the available icons can be found at [http://openweathermap.org/weather-conditions](http://openweathermap.org/weather-conditions).On
    a separate note, the argument can be made that Kelvin to Fahrenheit conversion
    is actually a view concern, but we have implemented it in the service. This argument
    holds water, especially considering that we have a planned feature to be able
    to toggle between Celsius and Fahrenheit. A counter argument would be that at
    this time, we only need to display in Fahrenheit and it is part of the job of
    the weather service to be able to convert the units. This argument makes sense
    as well. The ultimate implementation will be to write a custom Angular Pipe and
    apply it in the template. A pipe can easily bind with the planned toggle button
    as well. However, at this time, we only need to display in Fahrenheit and I would
    err on the side of *not*over-engineering a solution.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您需要在此阶段将图标属性转换为图像URL。在服务中执行此操作有助于保持封装性，将图标值绑定到视图模板中的URL将违反**关注点分离**（**SoC**）原则。如果您希望创建真正模块化、可重用和可维护的组件，您必须在执行SoC方面保持警惕和严格。有关天气图标的文档以及URL应如何形成的详细信息，包括所有可用的图标，可以在[http://openweathermap.org/weather-conditions](http://openweathermap.org/weather-conditions)找到。另外，可以提出这样的论点，即从开尔文到华氏的转换实际上是一个视图关注点，但我们已经在服务中实现了它。这个论点是站得住脚的，特别是考虑到我们计划的功能可以在摄氏度和华氏度之间切换。另一个论点是，此时，我们只需要以华氏度显示，并且天气服务的工作部分是能够转换单位。这个论点也是有道理的。最终的实现将是编写一个自定义的Angular管道，并在模板中应用它。管道也可以轻松地与计划中的切换按钮绑定。然而，此时，我们只需要以华氏度显示，我会倾向于*不*过度设计解决方案。
- en: Update `ICurrentWeather.date` to the `number` type
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ICurrentWeather.date`更新为`number`类型
- en: While writing the transformation function, you will note that the API returns
    the date as a number. This number represents time in seconds since the UNIX epoch
    (timestamp), which is January 1st, 1970 00:00:00 UTC. However, `ICurrentWeather`
    expects a `Date` object. It is easy enough to convert the timestamp by passing
    it into the constructor of the `Date` object like `new Date(data.dt)`. This is
    fine, but also unnecessary, since Angular's `DatePipe` can directly work with
    the timestamp. In the name of relentless simplicity and maximally leveraging the
    functionality of the frameworks we use, we will update `ICurrentWeather` to use
    `number`. There's also a performance and memory benefit to this approach if you're
    transforming massive amounts of data, but that concern is not applicable here. There's
    one caveat—JavaScript's timestamp is in milliseconds, but the server value is
    in seconds, so a simple multiplication during the transformation is still required.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写转换函数时，您会注意到API将日期返回为数字。这个数字代表自UNIX纪元（时间戳）以来的秒数，即1970年1月1日00:00:00 UTC。然而，`ICurrentWeather`期望一个`Date`对象。通过将时间戳传递给`Date`对象的构造函数进行转换是很容易的，就像`new
    Date(data.dt)`。这样做没问题，但也是不必要的，因为Angular的`DatePipe`可以直接处理时间戳。为了追求简单和充分利用我们使用的框架的功能，我们将更新`ICurrentWeather`以使用`number`。如果您正在转换大量数据，这种方法还有性能和内存上的好处，但这个问题在这里并不适用。有一个例外——JavaScript的时间戳是以毫秒为单位的，但服务器的值是以秒为单位的，所以在转换过程中仍然需要进行简单的乘法运算。
- en: 'Import the RxJS `map` operator right below the other import statements:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其他导入语句下方导入RxJS的`map`操作符：
- en: '[PRE43]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It may seem odd to have to manually import the `map` operator. RxJS is a very
    capable framework with a wide API surface. Observable alone has over 200 methods
    attached to it. Including all of these methods by default creates development
    time issues with too many functions to choose from and also, it negatively impacts
    the size of the final deliverable, including app performance and memory use. So
    you must add each operator you intend to use individually.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 手动导入`map`操作符可能看起来有点奇怪。RxJS是一个非常强大的框架，具有广泛的API表面。仅Observable本身就有200多个附加方法。默认情况下包括所有这些方法会在开发时创建太多的函数选择问题，并且还会对最终交付的大小、应用程序性能和内存使用产生负面影响。因此，您必须单独添加您打算使用的每个操作符。
- en: Apply the `map` function to data stream returned by  `httpClient.get` method
    through a `pipe`
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`pipe`将`map`函数应用于`httpClient.get`方法返回的数据流。
- en: 'Pass the `data` object into the `transformToICurrentWeather` function:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`data`对象传递给`transformToICurrentWeather`函数：
- en: '[PRE44]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now incoming data can be transformed as it flows through the stream, ensuring
    that the `OpenWeatherMap` Current Weather API data is in the correct shape, so
    it can be consumed by the `CurrentWeather` component.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，传入的数据可以在流经过程中进行转换，确保`OpenWeatherMap`当前天气API数据的格式正确，以便`CurrentWeather`组件可以使用。
- en: Ensure that your app compiles successfully
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的应用成功编译
- en: 'Inspect the results in the browser:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中检查结果：
- en: '![](Images/acb5fa9f-0a66-4115-ac92-88f29e710067.png)Displaying Live Data from
    OpenWeatherMap'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/acb5fa9f-0a66-4115-ac92-88f29e710067.png)从OpenWeatherMap显示实时数据'
- en: Finally, you should see that your app is able to pull live data from `OpenWeatherMap`
    and correctly transform server data into the format you expect.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您应该看到您的应用能够从`OpenWeatherMap`获取实时数据，并正确地将服务器数据转换为您期望的格式。
- en: You have completed the development of Feature 1: Display Current Location weather
    information for the current day. Commit your code and move the card in Waffle
    to the Done column.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经完成了Feature 1的开发：显示当前位置的当天天气信息。提交您的代码并将卡片移动到Waffle的Done列。
- en: 'Finally, we can move this task to the Done column:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以将此任务移动到Done列：
- en: '![](Images/ae1e16d3-ee5c-4476-b31a-59a191e05af7.png)Waffle.io Kanban Board
    Status'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/ae1e16d3-ee5c-4476-b31a-59a191e05af7.png)Waffle.io看板状态'
- en: Summary
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations, in this chapter, you created your first Angular application
    with a flexible architecture while avoiding over-engineering. This was possible
    because we first built a road map and codified it in a Kanban board that is visible
    to your peers and colleagues. We stayed focused on implementing the first feature
    we put in progress and didn't deviate from the plan.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，在本章中，您创建了您的第一个具有灵活架构的Angular应用，同时避免了过度工程化。这是可能的，因为我们首先制定了一个路线图，并将其编码在一个可见于您的同行和同事的看板中。我们专注于实施我们正在进行中的第一个功能，并且没有偏离计划。
- en: You can now use Angular CLI and an optimized VS Code development environment
    to help you reduce the amount of coding you need to do. You can leverage TypeScript
    anonymous types and observable streams to accurately reshape complicated API data
    into a simple format without having to create one-use interfaces.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用Angular CLI和优化的VS Code开发环境来帮助您减少需要编写的代码量。您可以利用TypeScript匿名类型和可观察流来准确地将复杂的API数据重塑为简单的格式，而无需创建一次性接口。
- en: You learned to avoid coding mistakes by proactively declaring input and return
    types of functions and working with generic functions. You used the date and decimal
    pipes to ensure that the data is formatted as desired, while keeping formatting-related
    concerns mostly in the template, where this kind of logic belongs.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 您学会了通过主动声明函数的输入和返回类型以及使用通用函数来避免编码错误。您使用日期和小数管道来确保数据按预期格式化，同时将与格式相关的问题大部分放在模板中，这种逻辑属于模板。
- en: Finally, you used interfaces to communicate between components and services
    without leaking the external data structure to internal components. By applying
    all these techniques in combination, which Angular, RxJS, and TypeScript have
    allowed us to do, you have ensured proper separation of concerns and encapsulation.
    As a result, the `CurrentWeather` component is now a truly reusable and composable
    component; this is not an easy feat to achieve.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您使用接口在组件和服务之间进行通信，而不会将外部数据结构泄漏到内部组件。通过结合应用所有这些技术，Angular、RxJS和TypeScript允许我们做到这一点，您已经确保了关注点的正确分离和封装。因此，“CurrentWeather”组件现在是一个真正可重用和可组合的组件；这并不是一件容易的事情。
- en: If you don't ship it, it never happened. In the next chapter, we will prepare
    this Angular app for a production release by troubleshooting application errors,
    ensuring automated unit and e2e tests pass and containerizing the Angular app
    with Docker, so it can be published on the web.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有发布它，那就从未发生过。在下一章中，我们将通过解决应用程序错误、确保自动化单元测试和端到端测试通过，并使用Docker将Angular应用程序容器化，以便可以在网络上发布。
