- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Managing Data with React Router
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Router管理数据
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下几点：
- en: Use React Router to fetch or send data without using `useEffect()` or `useState()`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Router获取或发送数据，而不使用 `useEffect()` 或 `useState()`
- en: Share data between different routes without using React’s context feature
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不使用React的context功能的情况下，在不同路由间共享数据
- en: Update the UI based on the current data submission status
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据当前数据提交状态更新UI
- en: Create page and action routes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建页面和动作路由
- en: Improve the user experience by deferring the loading of non-critical data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过延迟加载非关键数据来提高用户体验
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the preceding chapter, you learned how to use React Router to load different
    components for different URL paths. This is an important feature as it allows
    you to build multipage websites while still using React.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何使用React Router为不同的URL路径加载不同的组件。这是一个重要的特性，因为它允许你在使用React的同时构建多页面网站。
- en: Routing is a crucial feature for many web applications, and React Router is
    therefore a very important package. But just as most websites need routing, almost
    all websites need to fetch and manipulate data. For example, HTTP requests in
    most websites are sent to load data (such as a list of products or blog posts)
    or to mutate data (for example, to create a product or a blog post).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 路由对于许多Web应用来说是一个关键特性，因此React Router是一个非常重要的包。但就像大多数网站需要路由一样，几乎所有的网站都需要获取和操作数据。例如，在大多数网站中，HTTP请求是用来加载数据（例如产品列表或博客文章）或修改数据（例如创建产品或博客文章）的。
- en: In *Chapter 8* , *Handling Side Effects* , you learned that you can use the
    `useEffect()` Hook and various other React features to send HTTP requests from
    inside a React application. But if you’re using React Router, you get some new,
    even more powerful tools for working with data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第8章* ，*处理副作用* 中，你学习了可以使用 `useEffect()` Hook 和其他各种React特性在React应用内部发送HTTP请求。但如果你使用React
    Router，你将获得一些新的、甚至更强大的工具来处理数据。
- en: This chapter will explore which new features are made available by React Router
    and how they may be used to simplify the process of fetching or sending data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨React Router提供了哪些新功能，以及如何使用这些功能简化数据获取或发送的过程。
- en: Data Fetching and Routing Are Tightly Coupled
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据获取和路由紧密耦合
- en: As mentioned previously, most websites do need to fetch (or send) data, and
    most websites do need more than one page. But it’s important to realize that these
    two concepts are typically closely related.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，大多数网站确实需要获取（或发送）数据，并且大多数网站确实需要多个页面。但重要的是要认识到这两个概念通常是紧密相关的。
- en: Whenever a user visits a new page (such as `/posts` ), it’s likely that some
    data will need to be fetched. In the case of a `/posts` page, the required data
    is probably a list of blog posts that is retrieved from a backend server. The
    rendered React component (such as `Posts` ) must therefore send an HTTP request
    to the backend server, wait for the response, handle the response (as well as
    potential errors), and, ultimately, display the fetched data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户访问新页面（例如 `/posts` ）时，很可能需要获取一些数据。在 `/posts` 页面的情况下，所需的数据可能是一份从后端服务器检索到的博客文章列表。因此，渲染的React组件（例如
    `Posts` ）必须向后端服务器发送HTTP请求，等待响应，处理响应（以及潜在的错误），并最终显示获取到的数据。
- en: Of course, not all pages need to fetch data. Landing pages, “About Us” pages,
    and “Terms & Use” pages probably don’t need to fetch data when a user visits them.
    Instead, data on those pages is likely to be static. It might even be included
    in the source code as it doesn’t change frequently.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非所有页面都需要获取数据。着陆页、“关于我们”页面和“条款与使用”页面在用户访问时可能不需要获取数据。相反，这些页面上的数据可能是静态的。甚至可能包含在源代码中，因为它不经常改变。
- en: But many pages do need to get data from a backend every time they’re loaded—for
    instance, “Products,” “News,” “Events,” or other infrequently updated pages like
    the “User Profile.”
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但许多页面确实需要在每次加载时从后端获取数据——例如，“产品”、“新闻”、“活动”或其他不经常更新的页面，如“用户资料”。
- en: And data fetching isn’t everything. Most websites also contain features that
    require data submission—be it a blog post that can be created or updated, product
    data that’s administered, or a user comment that can be added. Hence, sending
    data to a backend is also a very common use case.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 数据获取并非一切。大多数网站还包含需要提交数据的功能——无论是可以创建或更新的博客文章，管理的产品数据，还是可以添加的用户评论。因此，向后端发送数据也是一个非常常见的用例。
- en: And beyond requests, components might also need to interact with other browser
    APIs, such as `localStorage` . For example, user settings might need to be fetched
    from storage as a certain page loads.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了请求之外，组件可能还需要与其他浏览器 API 交互，例如 `localStorage`。例如，用户设置可能需要在页面加载时从存储中检索。
- en: Naturally, all these interactions happen on pages. But it might not be immediately
    obvious how tightly data fetching and submission are coupled to routing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，所有这些交互都在页面上发生。但可能并不立即明显数据获取和提交与路由是如何紧密相连的。
- en: Most of the time, data is fetched when a route becomes active, i.e., when a
    component (the page component) is rendered for the first time. Sure, users might
    also be able to click a button to refresh the data, but while this is optional,
    data fetching upon initial page load is almost always required.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，数据是在路由变为活动状态时获取的，即当组件（页面组件）首次渲染时。当然，用户也可能能够点击按钮来刷新数据，但尽管这是可选的，在页面初始加载时获取数据几乎是必需的。
- en: And when it comes to sending data, there is also a close connection to routing.
    At first sight, it’s not clear how it’s related because, while it makes sense
    to fetch data upon page load, it’s less likely that you will need to send some
    data immediately (except perhaps tracking or analytics data).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到发送数据时，它与路由也有密切的联系。乍一看，可能不清楚它们是如何相关的，因为虽然页面加载时获取数据是有意义的，但立即发送一些数据的需求可能较少（除非可能是跟踪或分析数据）。
- en: But it’s very likely that *after* sending data, you will want to navigate to
    a different page, meaning that it’s actually the other way around, and instead
    of initiating data fetching as a page loads, you want to load a different page
    after sending some data. For example, after an administrator enters some product
    data and submits the form, they should typically be redirected to a different
    page (for example, from `/products/new` to the `/products` page).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在发送数据后，你很可能想要导航到不同的页面，这意味着实际上情况正好相反，你希望在发送一些数据后加载不同的页面。例如，在管理员输入一些产品数据并提交表单后，他们通常会被重定向到不同的页面（例如，从
    `/products/new` 到 `/products` 页面）。
- en: 'The connection between data fetching, submission, and routing can therefore
    be summarized by the following points:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，数据获取、提交和路由之间的关系可以总结如下：
- en: '**Data fetching** often should be initiated when a route becomes active (if
    that page needs data)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据获取**通常应该在路由变为活动状态时启动（如果该页面需要数据）'
- en: After **submitting data** , the user should often be redirected to another route
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**提交数据**后，用户通常会被重定向到另一个路由
- en: Because these concepts are tightly coupled, React Router provides extra features
    that vastly simplify the process of working with data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些概念紧密相连，React Router 提供了额外的功能，极大地简化了与数据交互的过程。
- en: Sending HTTP Requests without React Router
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不使用 React Router 发送 HTTP 请求
- en: Working with data is not just about sending HTTP requests. As mentioned in the
    previous section, you may also need to store or retrieve data via `localStorage`
    or perform some other operation as a page gets loaded. But sending HTTP requests
    is an especially common scenario and will therefore be the main use case considered
    for the majority of this chapter. Nonetheless, it’s vital to keep in mind that
    what you learn in this chapter is not limited to sending HTTP requests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据交互不仅仅是发送 HTTP 请求。如前所述，你可能还需要通过 `localStorage` 或执行其他操作来存储或检索数据，当页面加载时。但是，发送
    HTTP 请求是一个特别常见的场景，因此将是本章主要考虑的使用案例。然而，重要的是要记住，本章所学的内容并不仅限于发送 HTTP 请求。
- en: As you will see, React Router provides various features that help with sending
    HTTP requests (or using other data fetching and manipulation APIs), but you can
    also send HTTP requests (or interact with `localStorage` or other APIs) without
    these features. Indeed, *Chapter 8* , *Handling Side Effects* , already taught
    you how HTTP requests can be sent from inside React components with the help of
    `useEffect()` .
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将看到的，React Router 提供了各种功能来帮助发送 HTTP 请求（或使用其他数据获取和操作 API），但你也可以在没有这些功能的情况下发送
    HTTP 请求（或与 `localStorage` 或其他 API 交互）。实际上，*第 8 章*，*处理副作用*，已经教你如何使用 `useEffect()`
    在 React 组件内部发送 HTTP 请求。
- en: When using React Router’s data fetching capabilities, you can get rid of `useEffect()`
    and manual state management.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 React Router 的数据获取功能时，你可以摆脱 `useEffect()` 和手动状态管理。
- en: '**Note**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'Besides jumping back in this book, you can also revisit how data fetching with
    `useEffect()` works via this code example on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/01-data-fetching-classic](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/01-data-fetching-classic)
    .'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Loading Data with React Router
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With React Router, fetching data can be simplified down to this, shorter, code
    snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Believe it or not, it really *is* that much less code than in the examples shown
    in *Chapter 8* . Back then, when using `useEffect()` , separate state slices had
    to be managed to handle loading and error states as well as the received data.
    Though, to be fair, the content that should be displayed in case of an error is
    missing here. It’s in a separate file (which will be shown later), but it would
    only add three extra lines of code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet, you see a couple of new features that haven’t
    been covered yet in the book. The `loader()` function and the `useLoaderData()`
    Hook are added by React Router. These features, along with many others that will
    be explored throughout this chapter, are made available by the React Router package.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'With that library installed, you can set an extra `loader` prop on your route
    definitions. This prop accepts a function that will be executed by React Router
    whenever this route (or one of its child routes, if defined) is activated:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function can be used to perform any data fetching or other tasks required
    to successfully display the page component. The logic for getting that required
    data can therefore be extracted from the component and moved into a separate function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Since many websites have dozens or even hundreds of routes, adding these loader
    functions inline in the route definition objects quickly leads to complex and
    confusing route definitions. For this reason, you will typically add (and export)
    the `loader()` function in the same file that contains the component that needs
    the data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'When setting up the route definitions, you can then import the component and
    its `loader` function and use it like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Assigning an alias ( `postsLoader` , in this example) to the imported `loader`
    function is optional but recommended since you most likely have multiple `loader`
    functions from different components, which would otherwise lead to name clashes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Technically, you don’t need to name your functions `loader` . You could use
    any name and assign them as values for the `loader` property in the route definition.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: But using `loader` as a function name does not just follow the convention; it
    also has the advantage that React Router’s built-in lazy loading support (covered
    in the previous chapter) lazy-loads the `loader` function when needed. It fails
    to do that if you pick any other name.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: With this `loader` defined, React Router will execute the `loader()` function
    whenever a route is activated. To be precise, the `loader()` function is called
    before the component function is executed (that is, before the component is rendered).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了此`loader`之后，React Router将在激活任何路由时执行`loader()`函数。更准确地说，`loader()`函数是在组件函数执行之前被调用的（即，在组件渲染之前）。
- en: '![img](img/B31339_14_01.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_14_01.png)'
- en: 'Figure 14.1: The Posts component is rendered after the loader is executed'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：在`loader`执行之后渲染`Posts`组件
- en: This also explains why the `Posts` component example at the beginning of this
    section contained no code that handled any loading state. There simply *is* no
    loading state since a component function is only executed after its loader has
    finished (and the data is available). React Router won’t finish the page transition
    until the `loader()` function has finished its job (though, as you will learn
    toward the end of this chapter, there is a way of changing this behavior).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这也解释了为什么本节开头提到的`Posts`组件示例中没有处理任何加载状态的代码。因为实际上*根本就没有加载状态*，因为组件函数只有在它的`loader`完成（并且数据可用）之后才会执行。React
    Router不会完成页面转换，直到`loader()`函数完成其工作（尽管，如你将在本章末尾学到的那样，有一种方法可以改变这种行为）。
- en: The `loader()` function can perform any operation of your choice (such as sending
    an HTTP request, or reaching out to browser storage via the `localStorage` API).
    Inside that function, you should return the data that should be exposed to the
    component function. It’s also worth noting that the `loader()` function can return
    any kind of data. It may also return a `Promise` object that then resolves to
    any kind of data. In that case, React Router will automatically wait for the `Promise`
    to be fulfilled before executing the related route component function. The `loader()`
    function can thus perform both asynchronous and synchronous tasks.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`loader()`函数可以执行任何你选择的操作（例如发送HTTP请求，或通过`localStorage` API访问浏览器存储）。在该函数内部，你应该返回应该暴露给组件函数的数据。还值得注意的是，`loader()`函数可以返回任何类型的数据。它也可能返回一个`Promise`对象，该对象随后解析为任何类型的数据。在这种情况下，React
    Router将自动等待`Promise`得到解决，在`useLoaderData()`被调用时提供解析后的数据。因此，`loader()`函数可以执行异步和同步任务。'
- en: '**Note**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: It’s important to understand that the `loader()` function, like all the other
    code that makes up your React app, executes on the client side (that is, in the
    browser of a website visitor). Therefore, you may perform any action that could
    be performed anywhere else (for example, inside `useEffect()` ) in your React
    app as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '重要的是要理解，`loader()`函数，就像构成你的React应用的其它所有代码一样，在客户端执行（即在网站访问者的浏览器中）。因此，你可以在你的React应用中执行任何可以在任何其他地方执行的操作（例如，在`useEffect()`中）。 '
- en: You must not try to run code that belongs to the server side. Directly reaching
    out to a database, writing to the file system, or performing any other server-side
    tasks will fail or introduce security risks, meaning that you might accidentally
    expose database credentials on the client side.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你绝对不应该尝试运行属于服务器端的代码。直接访问数据库、写入文件系统或执行任何其他服务器端任务都会失败或引入安全风险，这意味着你可能会意外地在客户端暴露数据库凭证。
- en: Getting Access to Loaded Data
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取加载的数据
- en: 'Of course, the component that belongs to a `loader` (that is, the component
    that’s part of the same route definition) needs the data returned by the `loader`
    . This is why React Router offers a new Hook for accessing that data: the `useLoaderData()`
    Hook.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，属于`loader`的组件（即属于同一路由定义的组件）需要`loader`返回的数据。这就是为什么React Router提供了一个新的Hook来访问这些数据：`useLoaderData()`
    Hook。
- en: When called inside a component function, this Hook yields the data returned
    by the `loader` that belongs to the active route. If that returned data is a `Promise`
    , React Router (as mentioned earlier) will automatically wait for that `Promise`
    to resolve and provide the resolved data when `useLoaderData()` is called.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当在组件函数内部调用此Hook时，它将返回属于活动路由的`loader`返回的数据。如果返回的数据是一个`Promise`，React Router（如前所述）将自动等待该`Promise`解决，并在`useLoaderData()`被调用时提供解析后的数据。
- en: The `loader()` function may also return an HTTP response object (or a `Promise`
    resolving to a `Response` ) object. This is the case in the preceding example
    because the `fetch()` function yields a `Promise` that resolves to an object of
    type `Response` . In that instance, React Router automatically extracts the response
    body and provides direct access to the data that was attached to the response
    (via `useLoaderData()` ).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`loader()` 函数也可能返回一个 HTTP 响应对象（或一个解析为 `Response` 的 `Promise`）。在先前的例子中就是这样，因为
    `fetch()` 函数产生一个解析为 `Response` 类型的对象的 `Promise`。在这种情况下，React Router 自动提取响应体，并提供直接访问附加到响应中的数据（通过
    `useLoaderData()`）。'
- en: '**Note**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'If a response should be returned, the returned object must adhere to the standard
    `Response` interface, as defined here: [https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)
    .'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应该返回响应，返回的对象必须遵循这里定义的标准 `Response` 接口：[https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)。
- en: Returning responses might be strange at first. After all, the `loader()` code
    is still executed inside the browser (not on a server). Therefore, technically,
    no request was sent, and no response should be required (since the entire code
    is executed in the same environment, that is, the browser).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 返回响应可能一开始会显得有些奇怪。毕竟，`loader()` 代码仍然在浏览器内部执行（而不是在服务器上）。因此，技术上没有发送请求，也不应该需要响应（因为整个代码都在同一个环境中执行，即浏览器）。
- en: For that reason, you can but don’t have to return a response; you may return
    any kind of value. React Router just also supports responses as one possible return
    value type.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以返回响应，但不必这样做；您可以返回任何类型的值。React Router 也支持响应作为可能的返回值类型之一。
- en: '`useLoaderData()` can be called in any component rendered by the currently
    active route component. That may be the route component itself ( `Posts` , in
    the preceding example), but it may also be any nested component.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`useLoaderData()` 可以在任何由当前活动路由组件渲染的组件中调用。这可能就是路由组件本身（在先前的例子中是 `Posts`），也可能是任何嵌套组件。'
- en: 'For example, `useLoaderData()` can also be used in a `PostsList` component
    that’s included in the `Posts` component (which has a `loader` added to its route
    definition):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`useLoaderData()` 也可以在包含在 `Posts` 组件中的 `PostsList` 组件中使用（该组件在其路由定义中添加了 `loader`）：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For this example, the `Posts` component file looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，`Posts` 组件文件看起来是这样的：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This means that `useLoaderData()` can be used in exactly the place where you
    need the data. The `loader()` function can also be defined wherever you want but
    it must be added to the route where the data is required.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `useLoaderData()` 可以在您需要数据的确切位置使用。`loader()` 函数也可以定义在任何您想要的地方，但它必须添加到需要数据的路由中。
- en: '**Note**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Depending on the React Router version being used, you might get a warning related
    to “No HydrateFallback” element being provided. You can ignore this warning as
    it only matters when using server-side rendering.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用的 React Router 版本，您可能会收到有关“未提供 'No HydrateFallback' 元素”的警告。您可以忽略这个警告，因为它仅在服务器端渲染时才有意义。
- en: '**Note**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You can also explore this code example on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/02-data-fetching-react-router](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/02-data-fetching-react-router)
    .'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在 GitHub 上探索这个代码示例：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/02-data-fetching-react-router](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/02-data-fetching-react-router)。
- en: Loading Data for Dynamic Routes
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态路由的数据加载
- en: For most websites, it’s unlikely that static, pre-defined routes alone will
    be sufficient to meet your needs. For instance, if you created a blogging site
    with exclusively static routes, you would be limited to a simple list of blog
    posts on `/posts` . To add more details about a selected blog post on routes such
    as `/posts/1` or `/posts/2` (for posts with different `id` values) you would need
    to include dynamic routes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数网站来说，仅使用静态、预定义的路由很可能不足以满足您的需求。例如，如果您创建了一个仅使用静态路由的博客网站，您将仅限于在 `/posts` 路径上的简单博客文章列表。要添加关于在
    `/posts/1` 或 `/posts/2`（对于具有不同 `id` 值的文章）等路径上所选博客文章的更多详细信息，您需要包含动态路由。
- en: 'Of course, React Router also supports data fetching with the help of the `loader()`
    function for dynamic routes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，React Router 也支持通过 `loader()` 函数帮助动态路由进行数据获取：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `PostDetails` component and its `loader` function can be implemented like
    this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostDetails` 组件及其 `loader` 函数可以像这样实现：'
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If it looks very similar to the `Posts` component in the *Loading Data with
    React Router* section, that’s no coincidence. Because the `loader()` function
    works in exactly the same way, there is just one extra feature being used to get
    hold of the dynamic path segment value: a `params` object that’s made available
    by React Router.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also explore this code example on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/03-dynamic-routes](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/03-dynamic-routes)
    .'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: When adding a `loader()` function to a route definition, React Router calls
    that function whenever the route becomes active, right before the component is
    rendered. When executing that function, React Router passes an object that contains
    extra information as an argument to `loader()` .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'This object passed to `loader()` includes two main properties:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: A `request` property that contains an object with more details about the request
    that led to the route activation
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `params` property that yields an object containing a key-value map of all
    dynamic route parameters for the active route
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `request` object doesn’t matter for this example and will be discussed in
    the next section. But the `params` object contains an `id` property that carries
    the `id` value of the post for which the route is loaded. The property is named
    `id` because, in the route definition, `/posts/:id` was chosen as a path. If a
    different placeholder name had been chosen, a property with that name would have
    been available on `params` (for example, for `/posts/:postId` , this would be
    `params.postId` ). This behavior is similar to the `params` object yielded by
    `useParams()` , as explained in *Chapter 13* , *Multipage Apps with React Router*
    .
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: With the help of the `params` object and the post `id` , the appropriate post
    `id` can be included in the outgoing request URL (for the `fetch()` request),
    and hence the correct post data can be loaded from the backend API. Once the data
    arrives, React Router will render the `PostDetails` component and expose the loaded
    post via the `useLoaderData()` Hook.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Loaders, Requests, and Client-Side Code
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding section, you learned about a `request` object being provided
    to the `loader()` function. Getting such a `request` object might be confusing
    because React Router is a client-side library—all the code executes in the browser,
    not on a server. Therefore, no request should reach the React app (as HTTP requests
    are sent from the client to the server, not between JavaScript functions on the
    client side).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: And, indeed, there is no request being sent via HTTP. Instead, React Router
    creates a request object via the browser’s built-in `Request` interface to use
    it as a “data vehicle.” This request is not sent via HTTP, but it’s used as a
    value for the `request` property on the data object that is passed to your `loader()`
    function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the built-in `Request` interface, visit [https://developer.mozilla.org/en-US/docs/Web/API/Request](https://developer.mozilla.org/en-US/docs/Web/API/Request)
    .
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: This `request` object will be unnecessary in many `loader` functions, but there
    are occasional scenarios in which you can extract useful information from that
    object—information that might be needed in the `loader` to fetch the right data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can use the `request` object and its `url` property to get
    access to any search parameters (query parameters) that may be included in the
    currently active page’s URL:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this code snippet, the `request` value is used to get hold of a query parameter
    value that’s used in the React app URL. That value is then used in an outgoing
    request.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: However, it is vital that you keep in mind that the code inside your `loader()`
    function, just like all your other React code, always executes on the client side.
    If, instead, you want to execute code on a server (and, for example, fetch data
    on the server side), you need to use **server-side rendering** ( **SSR** ) or
    some React framework that implements SSR, like Next.js. SSR and Next.js will be
    covered in the next chapter, *Chapter 15* , *Server-side Rendering & Building
    Fullstack Apps with Next.js* , and the chapters thereafter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Layouts Revisited
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Router supports the concept of layout routes. These are routes that contain
    other routes and render those other routes as nested children. As you may recall,
    this concept was introduced in *Chapter 13* , *Multipage Apps with React Router*
    .
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Conveniently, layout routes can also be used for sharing data across nested
    routes. Consider this example website:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_02.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: A website with a header, a sidebar, and some main content'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: This website has a header with a navigation bar, a sidebar showing a list of
    available posts, and a main area that displays the currently selected blog post.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'This example includes two layout routes that are nested into each other:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The root layout route, which includes the top navigation bar that is shared
    across all pages
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A posts layout route, which includes the sidebar and the main content of its
    child routes (for example, the details for a selected post)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The route definitions code looks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this setup, both the `<Posts />` and the `<PostDetails />` components are
    rendered next to the sidebar (since the sidebar is part of the `<PostsLayout />`
    element).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting part is that the `/posts` route (i.e., the layout route) loads
    the post data, as it has the `postsLoader` assigned to it, and so the `PostsLayout`
    component file looks like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since layout routes are also regular routes, you can add `loader()` functions
    and use `useLoaderData()` just as you could in any other route. However, because
    layout routes are activated for multiple child routes, their data is also displayed
    for different routes. In the preceding example, the list of blog posts is always
    displayed on the left side of the screen, no matter if a user visits `/posts`
    or `/posts/10` :'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_03.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: The same layout and data are used for different child routes'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, the layout and data used do not change as different child
    routes are activated. React Router also avoids unnecessary data re-fetching (for
    the blog posts list data) as you switch between child routes. It’s smart enough
    to realize that the surrounding layout hasn’t changed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Reusing Data across Routes
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Layout routes do not just help you share components and markup. They also allow
    you to load and share data across a layout route and its child routes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `PostDetails` component (that is, the component that’s rendered
    for the `/posts/:id` route) needs the data for a single post, and that data can
    be retrieved via a `loader` attached to the `/posts/:id` route:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This example was discussed earlier in this chapter in the *Loading Data for
    Dynamic Routes* section. This approach is fine, but in some situations, this extra
    HTTP request can be avoided. For example, the following route configuration can
    be simplified, and the extra `postDetailsLoader` on the child route can be avoided:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the `PostsLayout` route already fetches a list of all posts.
    That layout component is also active for the `PostDetails` route. In such a scenario,
    fetching a single post is unnecessary, since all the data has already been fetched
    for the list of posts. Of course, a specific `postDetailsLoader` loader for the
    `PostDetails` child route would be required if the request for the list of posts
    (by `postsLoader` on the `PostsLayout` route) didn’t yield all the data required
    by `PostDetails` .
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: But if all the data is available, React Router allows you to tap into the loader
    data of a parent route component via the `useRouteLoaderData()` Hook.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'This Hook can be used like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`useRouteLoaderData()` requires a route identifier as an argument. It requires
    an identifier assigned to the ancestor route that contains the data that should
    be reused. You can assign such an identifier via the `id` property to your routes
    as part of the route definitions code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `useRouteLoaderData()` Hook then returns the same data `useLoaderData()`
    yields in that route to which you added the `id` . In this example, it would provide
    a list of blog posts.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'In `PostDetails` , this Hook can therefore be used like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `useParams()` Hook is used to get access to the dynamic route parameter
    value, and the `find()` method is used on the list of posts to identify a single
    post with a fitting `id` property. In this example, you would thus avoid sending
    an unnecessary HTTP request by reusing data that’s already available.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the `postDetailsLoader` that was part of the `/posts/:id` route definition
    can be removed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Handling Errors
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first example at the very beginning of this chapter (where the HTTP request
    was sent with the help of `useEffect()` ), the code did not just handle the success
    case but also possible errors. In all the React Router-based examples since then,
    error handling has been omitted. Error handling was not discussed up to this point
    because, while React Router plays an important role in error handling, it’s vital
    to first gain a solid understanding of how React Router works in general and how
    it helps with data fetching. But, of course, errors can’t always be avoided and
    definitely should not be ignored.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, handling errors is also very straightforward and easy when using
    React Router’s data capabilities. You can set an `errorElement` property on your
    route definitions and define the element that should be rendered when an error
    occurs:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This `errorElement` property can be set on any route definition of your choice,
    or even multiple route definitions simultaneously. React Router will render the
    `errorElement` of the route closest to the place where the error was thrown.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding snippet, no matter which route produced an error, it would
    always be the root route’s `errorElement` that was displayed (since that’s the
    only route definition with an `errorElement` ). But if you also added an `errorElement`
    to the `/posts` route, and the `:id` route produced an error, it would be the
    `errorElement` of the `/posts` route that was shown on the screen, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This allows you, the developer, to set up fine-grained error handling.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the component used as a value for the `errorElement` , you can get access
    to the error that was thrown via the `useRouteError()` Hook:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this simple yet effective error-handling solution, React Router allows
    you to avoid managing error states yourself. Instead, you simply define a standard
    React element (via the `element` prop) that should be displayed when things go
    right and an `errorElement` to be displayed if things go wrong.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Onward to Data Submission
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far, you’ve learned a lot about data fetching. But as mentioned earlier
    in this chapter, React Router also helps with data submission.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example component:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This component renders a `<form>` element that allows users to enter the details
    for a new post. Due to the following route configuration, the component is displayed
    whenever the `/posts/new` route becomes active:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Without React Router’s data-related features, you might handle form submission
    like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Just as before when fetching data, this requires quite a bit of code and logic
    to be added to the component function. You must manually extract the submitted
    data, send the HTTP request, and navigate to a different page after receiving
    an HTTP response.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you might also need to manage loading state and potential errors
    (excluded in the preceding example).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Again, React Router offers some help. Where a `loader()` function can be added
    to handle data loading, an `action()` function can be defined to handle data submission.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the new `action()` function, the preceding example component looks
    like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code might be similar in length but it has the advantage of moving all
    the data submission logic out of the component function into a special `action()`
    function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the addition of the `action()` function, the example code snippet includes
    the following important changes and features:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: A `<Form>` component that’s used instead of `<form>` .
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `method` prop is set on the `<Form>` (to `"post"` ).
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The submitted data is extracted as `FormData` by calling `request.formData()`
    .
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user is redirected via a newly added `redirect()` function (instead of `useNavigate()`
    and `navigate()` ).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But what are these elements about?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Working with action() and Form Data
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like `loader()` , `action()` is a special function that can be added to
    route definitions, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With the `action` prop set on a route definition, the assigned function is automatically
    called whenever a `<Form>` (not `<form>` !) targeting this route is submitted.
    `Form` is a component provided by React Router that should be used instead of
    the default `<form>` element.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Internally, `Form` uses the default `<form>` element but prevents the browser
    default of creating and sending an HTTP request upon form submission. Instead,
    React Router creates a `FormData` object and calls the `action()` function defined
    for the route that’s targeted by the `<Form>` , passing a request object, based
    on the built-in `Request` interface, to it. The passed request object contains
    the form data generated by React Router. Later in this chapter, in the *Controlling
    Which <Form> Triggers Which Action* section, you’ll learn how to control which
    `action()` function of which route will be executed by React Router.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Handling form submissions with the help of “actions” might sound familiar— *Chapter
    9* , *Handling User Input & Forms with Form Actions* , discussed a similar concept.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: But whereas *Chapter 9* discussed a feature built into React (which was not
    related or dependent on routing), this chapter explores a core concept of React
    Router.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, you can use either approach for handling form submissions. Or you
    could use none of the two and instead handle the `submit` event manually via `onSubmit`
    .
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: But when using routing with React Router, you’ll often end up with cleaner,
    more concise code that integrates smoothly with other routing features like redirects
    when using React Router’s `<Form>` component and `action()` function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The form data object that is created by calling `request.formData()` includes
    all form input values entered into the submitted form. To be registered, an input
    element such as `<input>` , `<select>` , or `<textarea>` must have the `name`
    attribute assigned to it. The values set for those `name` attributes can later
    be used to extract the entered data.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The `request` object (that contains the form data) received by the `action()`
    function is created by React Router when the form is submitted.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The `Form` component defines the HTTP method of the request object. By setting
    the `Form` 's `method` prop to either `"get"` (the default) or `"post"` , you
    control what happens when the form is submitted. When setting `method="get"` (or
    when not setting `method` at all), a regular URL navigation will occur—just as
    if a link to a certain path were clicked. Any entered form values will be encoded
    as URL search parameters in that case. To trigger an `action()` function, `<Form>`
    's `method` must be set to `"post"` instead.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s important to understand that the request is not sent via HTTP
    since `action()` , just like `loader()` or the component function, still executes
    in the browser rather than on a server.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'The `action()` function then receives an object with a `request` property that
    contains the created request object with the included form data. This `request`
    object can be used to extract the values entered into the form input fields like
    this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The built-in `formData()` method yields a `Promise` that resolves to a `FormData`
    object that offers a `get()` method that can be used to get an entered value by
    its identifier (that is, by the `name` attribute value set on the input element).
    For example, the value entered into `<input name="title">` could be retrieved
    via `formData.get('title')` .
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can follow the approach chosen in the preceding code snippet
    and convert the `formData` object to a simple key-value object via `Object.fromEntries(formData)`
    . This object ( `postData` , in the preceding example) contains the names set
    on the form input elements as properties and the entered values as values for
    those properties (meaning that `postData.title` would yield the value entered
    in `<input name="title">` ).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: React Router also supports the other main HTTP verbs ( `"patch"` , `"put"` ,
    and `"delete"` ), and setting `method` to one of these verbs will indeed also
    trigger the `action()` function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful when working with multiple forms that should trigger the
    same `action()` . By using different methods, you can use one single action to
    run different code based on the value extracted from `request.method` inside the
    `action()` function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: But it’s worth noting that using methods other than `'get'` and `'post'` is
    not in line with the HTML standard. Therefore, React Router could remove support
    for these methods in the future.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Hence, when working with multiple forms that trigger the same `action()` , a
    more stable solution can be to include a hidden input field with a unique identifier
    (e.g., `<input type="hidden" name="_method" value="DELETE">` ). This value can
    then be extracted and used (e.g., in an `if` statement) in the `action()` function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'The extracted data can then be used for any operations of your choice. That
    could be an extra validation step or an HTTP request sent to some backend API,
    where the data may get stored in a database or file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, once all intended steps are performed, the `action()` function must
    return a value—any value of any type, but at least `null` . Not returning anything
    (i.e., omitting the `return` statement) is not allowed. Though, as with the `loader()`
    function, you may also return a response, for example, a redirect response like
    this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Indeed, for actions, it’s highly likely that you will want to navigate to a
    different page once the action has been performed (e.g., once an HTTP request
    to an API has been sent). This may be required to navigate the user away from
    the data input page to a page that displays all available data entries (for example,
    from `/posts/new` to `/posts` ).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: To simplify this common pattern, React Router provides a `redirect()` function
    that yields a response object that causes React Router to switch to a different
    route. You can therefore return the result of calling `redirect()` in your `action()`
    function to ensure that the user is navigated to a different page. It’s the equivalent
    of calling `navigate()` (via `useNavigate()` ) when manually handling form submissions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this snippet, React Router’s `redirect()` function is used instead of manually
    constructing a `Response` object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Returning Data Instead of Redirecting
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, your `action()` functions may return anything. You don’t have
    to return a response object. While it is quite common to return a redirect response,
    you may occasionally want to return some raw data instead.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: One scenario in which you might *not* want to redirect the user is after validating
    the user’s input. Inside the `action()` function, before sending the entered data
    to some API, you may wish to validate the provided values first. If an invalid
    value (such as an empty title) is detected, a great user experience is typically
    achieved by keeping the user on the route with the `<Form>` . The values entered
    by the user shouldn’t be cleared and lost; instead, the form should be updated
    to present useful validation error information to the user. This information can
    be passed from the `action()` to the component function so that it can be displayed
    there (for example, next to the form input fields).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'In situations like this, you can return a “normal” value (that is, not a redirect
    response) from your `action()` function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, a `validationErrors` array is returned if the entered `title`
    or `text` values are empty.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Data returned by an `action()` function can be used in the route component
    (or any other nested component) via the `useActionData()` Hook:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`useActionData()` works a lot like `useLoaderData()` , but unlike `useLoaderData()`
    , it’s not guaranteed to yield any data. This is because while `loader()` functions
    always get called before the route component is rendered, the `action()` function
    only gets called once the `<Form>` is submitted.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, `useActionData()` is used to get access to the `validationErrors`
    returned by `action()` . If `validationErrors` is truthy (that is, is not `undefined`
    ), the array will be mapped to a list of error items that are displayed to the
    user:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_04.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: Validation errors are output below the input fields'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The `action()` function is therefore quite versatile in that you can use it
    to perform an action and redirect away as well as to conduct more than one operation
    and return different values for different use cases.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Controlling Which <Form> Triggers Which Action
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, in the section *Working with action() and Form Data*
    , you learned that when `<Form>` is used instead of `<form>` , React Router will
    execute the targeted `action()` function. But which `action()` function is targeted
    by `<Form>` ?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, it’s the `action()` function assigned to the route that also renders
    the form (either directly or via some descendent component). Consider this route
    definition:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this definition, the `newPostAction()` function would be triggered whenever
    any `<Form>` inside of the `NewPost` component (or any nested component) is submitted.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases, this default behavior is exactly what you want. But you can
    also target `action()` functions defined on other routes by setting the `action`
    prop on `<Form>` to the path of the route that contains the `action()` that should
    be executed:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This form would cause React Router to execute the `action` belonging to the
    `/save-data` route—even though the `<Form>` component may be rendered as part
    of a component that belongs to a different route (e.g., `/posts` ).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting, though, that targeting a different route will lead to a
    page transition to that route’s path, even if your action does not return a redirect
    response. In a later section of this chapter, entitled *Behind-the-Scenes Data
    Fetching and Submission* , you will learn how that behavior can be avoided.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Reflecting the Current Navigation Status
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After submitting a form, the `action()` function that’s triggered may need some
    time to perform all intended operations. Sending HTTP requests to APIs in particular
    can take up to a few seconds.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it’s not a great user experience if the user doesn’t get any feedback
    about the current data submission status. It’s not immediately clear if anything
    happened at all after the submit button was clicked.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'For that reason, you might want to show a loading spinner or update the button
    caption while the `action()` function is running. Indeed, one common way of providing
    user feedback is to disable the submit button and change its caption like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_05.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: The submit button is grayed out'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: You can get the current React Router status (that is, whether it’s currently
    transitioning to another route or executing an `action()` function) via the `useNavigation()`
    Hook. This Hook provides a navigation object that contains various pieces of routing-related
    information.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Most importantly, this object has a `state` property that yields a string describing
    the current navigation status. This property is set to one of the following three
    possible values:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '`submitting` : If an `action()` function is currently executing'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loading` : If a `loader()` function is currently executing (for example, because
    of a `redirect()` response)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`idle` : If no `action()` or `loader()` functions are currently being executed'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can therefore use this `state` property to find out whether React Router
    is currently navigating to a different page or executing an `action()` . Hence,
    the submit button can be updated as shown in the preceding screenshot via this
    code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, the `isSubmitting` constant is `true` if the current navigation
    state is anything but `'idle'` . This constant is then used to disable the submit
    button (via the `disabled` attribute) and adjust the button’s caption.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Submitting Forms Programmatically
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, you won’t want to instantly trigger an `action()` when a form
    is submitted—for example, if you need to ask the user for confirmation first such
    as when triggering actions that delete or update data.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: For such scenarios, React Router allows you to submit a form (and therefore
    trigger an `action()` function) programmatically. Instead of using the `Form`
    component provided by React Router, you handle the form submission manually using
    the default `<form>` element. As part of your code, you can then use a `submit()`
    function provided by React Router’s `useSubmit()` Hook to trigger the `action()`
    manually once you’re ready for it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, the `action()` is manually triggered by programmatically submitting
    data via the `submit()` function provided by `useSubmit()` . This approach is
    required as it would otherwise be impossible to ask the user for confirmation
    (via the browser’s `window.confirm()` method).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Because data is submitted programmatically, the default `<form>` element should
    be used and the `submit` event handled manually. As part of this process, the
    browser’s default behavior of sending an HTTP request must also be prevented manually.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Typically, using `<Form>` instead of programmatic submission is preferable.
    But in certain situations, such as the preceding example, being able to control
    form submission manually can be useful.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Behind-the-Scenes Data Fetching and Submission
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also situations in which you may need to trigger an action or load
    data without causing a page transition.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'A Like button would be an example. When it’s clicked, a process should be triggered
    in the background (such as storing information about the user and the liked post),
    but the user should not be directed to a different page:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_06.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.6: A Like button below a post'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this behavior, you could wrap the button into a `<Form>` and, at
    the end of the `action()` function, simply redirect back to the page that is already
    active.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: But technically, this would still lead to an extra navigation action. Therefore,
    `loader()` functions would be executed and other possible side-effects might occur
    (the current scroll position could be lost, for example). For that reason, you
    might want to avoid this kind of behavior.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, React Router offers a solution: the `useFetcher()` Hook, which
    yields an object that contains a `submit()` method. Unlike the `submit()` function
    provided by `useSubmit()` , the `submit()` method yielded by `useFetcher()` is
    meant for triggering actions (or `loader()` functions) without starting a page
    transition.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'A Like button, as described previously, can be implemented like this (with
    the help of `useFetcher()` ):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `fetcher` object returned by `useFetcher()` has various properties. For
    example, it also contains properties that provide information about the current
    status of the triggered action or loader (including any data that may have been
    returned).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'But this object also includes two important methods:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '`load()` : To trigger the `loader()` function of a route (e.g., `fetcher.load(''/route-path'')`
    )'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`submit()` : To trigger an `action()` function with the provided data and configuration'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the code snippet above, the `submit()` method is called to trigger the action
    defined on the `/posts/<post-id>/like` route. Without `useFetcher()` (i.e., when
    using `useSubmit()` or `<Form>` ), React Router would switch to the selected route
    path when triggering its action. With `useFetcher()` , this is avoided, and the
    action of that route can be called from inside another route (meaning the action
    defined for `/posts/<post-id>/like` is called while the `/posts/<post-id>` route
    is active).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'This also allows you to define routes that don’t render any element (that is,
    in which there is no page component) and, instead, only contain a `loader()` or
    `action()` function. For example, the `/posts/<post-id>/like` route file ( `pages/like.js`
    ) looks like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As mentioned in the code snippet, any data may be returned in this action. But
    you must at least return `null` —avoiding the `return` statement and not returning
    anything is not allowed and will cause an error.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s registered as a route as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This works because this `action()` is only triggered via the `submit()` method
    provided by `useFetcher()` . `<Form>` and the `submit()` function yielded by `useSubmit()`
    would instead initiate a route transition to `/posts/<post-id>/like` . Without
    the `element` property being set on the route definition, this transition would
    lead to an empty page, as shown here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_07.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.7: An empty (nested) page is displayed, along with a warning message'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Because of the extra flexibility it offers, `useFetcher()` can be very useful
    when building highly interactive user interfaces. It’s not meant as a replacement
    for `useSubmit()` or `<Form>` , but rather, as an additional tool for situations
    where no route transition is required or wanted.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Deferring Data Loading
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point in the chapter, all data fetching examples have assumed that
    a page should only be displayed once all its data has been fetched. That’s why
    there was never any loading state that would have been managed (and hence no loading
    fallback content that would have been displayed).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: In many situations, this is exactly the behavior you want as it does not often
    make sense to show a loading spinner or similar fallback content for a fraction
    of a second just to then replace it with the actual page data.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: But there are also situations in which the opposite behavior might be desirable—for
    example, if you know that a certain page will take quite a while to load its data
    (possibly due to a complex database query that must be executed on the backend)
    or if you have a page that loads different pieces of data and some pieces are
    much slower than others.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: In such scenarios, it may make sense to render the page component even though
    some data is still missing. React Router also supports this use case by allowing
    you to defer data loading, which, in turn, enables the page component to be rendered
    before the data is available.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Deferring data loading is as simple as returning a promise from the loader
    (instead of awaiting it there):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this example, `getPosts()` is a function that returns a (slow) `Promise`
    :'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: React Router allows you to return raw promises. When doing so, you can wait
    for the actual values yielded by those promises in the client-side code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the component function where `useLoaderData()` is used, you must also
    use a new component provided by React Router: the `Await` component. It’s used
    like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `<Await>` element takes a `resolve` prop that receives a value of type `Promise`
    from the loader data. It’s wrapped by the `<Suspense>` component provided by React.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: The value passed to resolve is a `Promise` that was stored in the object returned
    by the `loader()` function. There, a key named posts was used to hold that `Promise`
    . The value for that key was the `Promise` returned by `getPosts()` . It’s this
    `Promise` that’s passed as a value to `resolve` via `<Await resolve={data.posts}>`
    . If a different key name were used (e.g., `blogPosts` ), that key name had to
    be referenced when setting `resolve` (e.g., `<Await resolve={data.blogPosts}>`
    ).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '`Await` automatically waits for the `Promise` to resolve before then calling
    the function that’s passed to `<Await>` as a child (that is, the function passed
    between the `<Await>` opening and closing tags). This function is executed by
    React Router once the data of the deferred operation is available. Therefore,
    inside that function, `loadedPosts` is received as a parameter, and the final
    user interface elements can be rendered.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The `Suspense` component that’s used as a wrapper around `<Await>` defines some
    fallback content that is rendered as long as the deferred data is not yet available.
    In *Chapter 10* , *Behind the Scenes of React and Optimization Opportunities*
    , the `Suspense` component was used to show some fallback content until the missing
    code was downloaded. Now, it’s used to bridge the time until the required data
    is available.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 14.8* , when returning a `Promise` (and using `<Await>`
    ) like this, other parts of the website, that are not loaded via `<Await>` , are
    already rendered and displayed while waiting for the posts data.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_08.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: Post details are already visible while the list of posts is loading'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Another big advantage of returning a `Promise` and awaiting it in the client-side
    code is that you can easily combine multiple fetching processes and control which
    processes should be deferred and which ones should not. For example, a route might
    be fetching different pieces of data. If only one process tends to be slow, you
    could defer only the slow one like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, `getUserData()` is not deferred because the `await` keyword
    is added in front of it. Therefore, JavaScript waits for that `Promise` (the `Promise`
    returned by `getUserData()` ) to resolve before returning from `loader()` . Hence,
    the route component is rendered once `getUserData()` finishes but before `getPosts()`
    is done.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Key Takeaways
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Router can help you with data fetching and submission.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can register `loader()` functions for your routes, causing data fetching
    to be initialized as a route becomes active.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loader()` functions return data (or responses, wrapping data) that can be
    accessed via `useLoaderData()` in your component functions.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loader()` data can be used across components via `useRouteLoaderData()` .'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also register `action()` functions on your routes that are triggered
    upon form submissions.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To trigger `action()` functions, you must use React Router’s `<Form>` component
    or submit data programmatically via `useSubmit()` or `useFetcher()` .
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useFetcher()` can be used to load or submit data without initiating a route
    transition.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When fetching slow data, you can return promises without awaiting them in the
    `loader()` to defer loading some or all of a route’s data.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s Next?
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fetching and submitting data are extremely common tasks, especially when building
    more complex React applications.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Typically, those tasks are closely connected to route transitions, and React
    Router is the perfect tool for handling this kind of operation. That’s why the
    React Router package offers powerful data management capabilities that vastly
    simplify these processes.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how React Router assists you with fetching or submitting
    data and which advanced features help you handle both basic and more complex data
    manipulation scenarios.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, this chapter concludes the list of core React Router features you
    need to know.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The next chapters will explore React’s server-side capabilities and how you
    may build fullstack applications with React, load data on a server, and use the
    Next.js framework.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Knowledge!
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to the examples found at
    [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/exercises/questions-answers.md)
    :'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: How are data fetching and submission related to routing?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the purpose of `loader()` functions?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the purpose of `action()` functions?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the difference between `<Form>` and `<form>` ?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the difference between `useSubmit()` and `useFetcher()` ?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the idea behind returning promises instead of awaiting them in a `loader()`
    ?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply What You Learned
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apply your knowledge about routing, combined with data manipulation, to the
    following activity.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 14.1: A To-Dos App'
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, your task is to create a basic to-do list web app that allows
    users to manage their daily to-do tasks. The finished page must allow users to
    add to-do items, update to-do items, delete to-do items, and view a list of to-do
    items.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'The following paths must be supported:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '`/` : The main page, responsible for loading and displaying a list of to-do
    items'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/new` : A page, opened as a modal above the main page, allowing users to add
    a new to-do item'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/:id` : A page, also opened as a modal above the main page, allowing users
    to update or delete a selected to-do item'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no to-do items exist yet, a fitting info message should be shown on the `/`
    page. If users try to visit `/:id` with an invalid to-do ID, an error modal should
    be displayed.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: For this activity, there is no backend API you could use. Instead, use `localStorage`
    to manage the to-do data. Keep in mind that the `loader()` and `action()` functions
    are executed on the client side and can therefore use any browser APIs, including
    `localStorage` .
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: You will find example implementations for adding, updating, deleting, and getting
    to-do items from `localStorage` at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/data/todos.js](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/data/todos.js)
    .
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Also, don’t be confused by the pages that open as modals above other pages.
    Ultimately, these are simply nested pages, styled as modal overlays. In case you
    get stuck, you can use the example `Modal` wrapper component found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/components/Modal.jsx](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/components/Modal.jsx)
    .
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: For this activity, you can write all CSS styles on your own if you so choose.
    But if you want to focus on the React and JavaScript logic, you can also use the
    finished CSS file from the solution at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/index.css](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/index.css)
    .
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: If you use that file, explore it carefully to ensure you understand which IDs
    or CSS classes might need to be added to certain JSX elements of your solution.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the activity, perform the following steps:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Create a new React project and install the React Router package.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create components (with the content shown in the screenshots below) that will
    be loaded for the three required pages. Also, add links (or programmatic navigation)
    between these pages.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable routing and add the route definitions for the three pages.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `loader()` functions to load (and use) all the data needed by the individual
    pages.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `action()` functions for adding, updating, and deleting to-dos.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint:* If you need to submit multiple forms for different actions from the
    same page, you could include a hidden input field that sets some value you can
    check for in your `action()` function, e.g., `<input type="hidden" name="_method"
    value="DELETE">` . Alternatively, you can also set `<Form method="delete">` (or
    set it to `"patch"` , `"put"` , or other HTTP verbs) and check for `request.method`
    in your `action()` function.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Add error handling in case data loading or saving fails.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The finished pages should look like this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_09.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.9: The main page displaying a list of to-dos'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_10.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.10: The /new page, opened as a modal, allowing users to add a new
    to-do'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_11.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.11: The /:id page, also opened as a modal, allowing users to edit
    or delete a to-do'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_12.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.12: An info message, displayed if no to-dos were found'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: The full code, and solution, to this activity can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/activities/practice-1)
    .
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
