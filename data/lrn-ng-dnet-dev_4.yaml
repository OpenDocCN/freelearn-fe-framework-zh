- en: Chapter 4. Using TypeScript with Angular
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四章. 使用TypeScript与Angular
- en: This chapter discusses the fundamentals of TypeScript and the benefits of using
    TypeScript to write Angular applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了TypeScript的基本原理以及使用TypeScript编写Angular应用程序的好处。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: What is TypeScript?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是TypeScript？
- en: Basic types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本类型
- en: Interfaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Generics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型
- en: Decorators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: TypeScript and Angular
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript和Angular
- en: What is TypeScript?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是TypeScript？
- en: '* * *'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: TypeScript is an open source programming language developed and maintained by
    Microsoft. It is a superset of JavaScript, and facilitates writing object-oriented
    programming. It should be compiled with JavaScript to run on any browser.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是由微软开发和维护的开源编程语言。它是JavaScript的超集，并且方便编写面向对象的编程。它应该与JavaScript一起编译，以在任何浏览器上运行。
- en: TypeScript provides the greatest tooling and advanced autocompletion, navigation,
    and refactoring. It is used to develop the JavaScript application for the client
    side and server side. With classes, modules, and interfaces, we can build robust
    components using TypeScript.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript提供了最好的工具和高级的自动完成、导航和重构功能。它用于开发客户端和服务器端的JavaScript应用程序。借助类、模块和接口，我们可以使用TypeScript构建强大的组件。
- en: The main advantage it provides over JavaScript is that it enables compile time
    type checking for errors. Unexpected runtime errors can be avoided due to casting
    issues. Also, it provides syntactic sugar for writing object-oriented programming.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它相对于JavaScript提供的主要优势在于，它能够在编译时进行类型检查以避免错误。由于类型转换问题，可以避免意外的运行时错误。此外，它提供了写面向对象编程的语法糖。
- en: Basic types
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本类型
- en: '* * *'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: In a programming language, we deal with various small units of data, such as
    `numbers`, `sting`, andÂ `Boolean` values. TypeScript supports these types of
    data, as in JavaScript, with enumeration and structure types.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言中，我们处理各种小单位的数据，比如`numbers`、`sting`和布尔值。TypeScript支持这些类型的数据，与JavaScript一样，支持枚举和结构类型。
- en: Boolean
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'The `boolean` data type can hold either `true` or `false`. Declaring and initializing
    this data type is quite easy and is illustrated as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数据类型可以保存`true`或`false`。声明和初始化这种数据类型非常简单，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the `isSaved` variable is declared asÂ `boolean` and is assigned with
    the valueÂ `false`. If the developer assigns a string value to theÂ `isSaved`
    variable by mistake, the TypeScript will show an error and highlight the statement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`isSaved`变量被声明为`boolean`类型，并赋值为`false`。如果开发人员错误地将一个字符串值赋给`isSaved`变量，TypeScript会显示错误并突出显示该语句。
- en: Number
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字
- en: 'The number data type holds floating-point values. Similar to JavaScript, TypeScript
    considers all numbers as floating-point values. Declaring and initializing the
    number data type variable can be done as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数字数据类型保存浮点值。与JavaScript类似，TypeScript将所有数字视为浮点值。声明和初始化数字数据类型变量可以使用以下方法：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, the `price` variable is declared asÂ `number` and is assigned the value
    101\. Number type can hold values such as decimal, binary, hexadecimal, and octal
    literals, as shown:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`price`变量被声明为`number`类型，并赋值为101。Number类型可以包含十进制、二进制、十六进制和八进制等不同的值，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: String
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: 'The string data type can hold a sequence of characters. Declaring and initializing
    the `string` variable is very simple, as illustrated:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串数据类型可以保存一系列字符。声明和初始化`string`变量非常简单，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we declared a variable named `authorName` as `string`, and assigned it
    the "`Rajesh Gunasundaram`" value. TypeScript supports the `string` value surrounded
    either byÂ double quotes (") or single quotes (').
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为`authorName`的变量，类型为`string`，并赋值为"`Rajesh Gunasundaram`"。TypeScript支持使用双引号(")或单引号(')括起来的`string`值。
- en: Array
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: 'The array data type is meant to hold the collection of values of specific types.
    In TypeScript, we can define `array` in two ways, which are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数组数据类型用于保存特定类型的值的集合。在TypeScript中，我们可以以两种方式定义`array`，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This statement declares an array variable of the `number` type using square
    brackets ([]) after the `number`Â data type, and it is assigned a series of even
    numbers from 2 to 10\. The second way to define array is this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句声明了一个`number`类型的数组变量，使用`number`数据类型后的方括号([])，并赋值为从2到10的一系列偶数。定义数组的第二种方法是这样的：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This statement uses the generic array type that uses the `Array` keyword followed
    by angle brackets (<>) that wrap the `number` data type.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句使用了泛型的数组类型，它使用了`Array`关键字后面跟着包裹`number`数据类型的尖括号（<>）。
- en: Enum
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举
- en: 'The enum data type will have a named set of values. We use enumerators to give
    friendly names to constants that identify certain values:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举数据类型将具有一组命名的值。我们使用枚举器为识别某些值的常量提供友好名称：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we have the `enum` type `Day` variable that holds the series of values
    representing each day of a week. The second statement shows how to access a particular
    `enum` value in a day and assign the same to another variable.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`enum`类型`Day`变量，它包含代表一周中每一天的值的系列。第二个语句展示了如何访问一天中的特定`enum`值并将其赋值给另一个变量。
- en: Any
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任意
- en: 'The `Any` data type is a dynamic data type that can hold `Any` value. TypeScript
    throws compile time errors if you assign a string-type variable to an integer-type
    variable. If you are unsure about what value a variable willÂ hold, and you would
    like to opt out of compiler checking for the type in the assignment, you can use
    the `Any` data type:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any`数据类型是一个可以容纳`任何`值的动态数据类型。如果将string类型的变量赋给整数类型的变量，TypeScript会抛出编译时错误。如果您不确定变量将持有什么值，并且希望在赋值时免除编译器对类型的检查，您可以使用`Any`数据类型：'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we used an array of the any type so that it can hold any type, such as
    `number`, `string`, and `boolean`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了任意类型的数组，因此它可以容纳任何类型，比如`number`，`string`和`boolean`。
- en: Void
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任何
- en: 'The void is actually nothing. It can be used as the return type of a function
    to declare that this function will not return any value:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Void实际上是什么都没有。它可用作函数的返回类型，声明这个函数不会返回任何值：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Interfaces
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: '* * *'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: An interface is an abstract type that defines the behavior of a class. ItÂ provides
    a type definition for an object that can be exchanged between clients. This enables
    the client to only exchange an object that is compiledÂ with the interface type
    definition; otherwise, we get a compile time error.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是定义类行为的抽象类型。它为可以在客户端之间交换的对象提供类型定义。这使得客户端只能交换符合接口类型定义的对象；否则，我们会得到编译时错误。
- en: 'In TypeScript, interfaces define contracts of an object within your code and
    the code outside your project. Let''s see how to use TypeScript with an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，接口定义了您代码内部和项目外部的对象的约束。让我们看一个示例，介绍如何在TypeScript中使用：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The type-checker verifies the `addCustomer` method call and examines its parameter.
    The `addCustomer` expects an object with the `name` property of the `string` type.
    However, the client that calls `addCustomer` passed an object with two parameters:Â `id`
    and `name`, respectively.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器验证了`addCustomer`方法调用并检查了其参数。`addCustomer`期望一个具有`string`类型的`name`属性的对象。然而，调用`addCustomer`的客户端传递了一个具有`id`和`name`两个参数的对象。
- en: However, the compiler ignores checkingÂ the `id` property as it is not available
    in the parameter type of the `addCustomer` method. WhatÂ matters for the compiler
    is that the required properties are present.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编译器会忽略对`id`属性的检查，因为它不在`addCustomer`方法的参数类型中。对于编译器来说，重要的是所需的属性是否存在。
- en: 'Let''s rewrite the method applying `interface` as a parameter type, as demonstrated:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示将`interface`作为参数类型重写方法：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Optional properties
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选属性
- en: 'In some scenarios, we may want to pass values only for minimal parameters.
    In such cases, we can define the properties in an interface as optional properties,
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能只想为最小的参数传递值。在这种情况下，我们可以将接口中的属性定义为可选属性，如下所示：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the `bonus` property has been defined as an optional property by concatenating
    a question mark (?) at the end of the `name` property.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`bonus`属性通过在`name`属性末尾添加问号（?）来定义为可选属性。
- en: Function type interfaces
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数类型接口
- en: 'We just saw how to define properties in interfaces. Similarly, we can also
    define function types in interfaces. We can define function types in interfaces
    just by giving the signature of the function with the return type. Note that in
    the following code snippet, we have not added the function name:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何在接口中定义属性。类似地，我们也可以在接口中定义函数类型。我们可以通过给出带有返回类型的函数签名来在接口中定义函数类型。请注意，在下面的代码片段中，我们没有添加函数名：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, `AddCustomerFunc`Â is ready. Let''s define a function type variable,Â `AddCustomerFunc`,
    and assign a function of the same signature to it as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`AddCustomerFunc`准备好了。让我们定义一个函数类型变量，`AddCustomerFunc`，并将具有相同签名的函数赋值给它，如下所示：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The parameter name in the function signature can vary but not the data type.
    For example, we can alter the `fn` and `ln` function parameters of the string
    type, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名中的参数名可以变化，但数据类型不能变化。例如，我们可以修改字符串类型的`fn`和`ln`函数参数，如下所示：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, if we change the data type of the parameter or the return type of the function
    here, the compiler will throw an error about the parameter not matching or the
    return type not matching with the `AddCustomerFunc` interface.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们改变此处参数的数据类型或函数的返回类型，编译器将抛出关于参数不匹配或返回类型不匹配`AddCustomerFunc`接口的错误。
- en: Array type interfaces
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数组类型接口**'
- en: 'We can also define an interface for array types. We can specify the data type
    for the `index` array and the data type to the array item, as shown:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为数组类型定义一个接口。我们可以指定`index`数组的数据类型和数组项的数据类型，如下所示：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: TypeScript supports two types of `index`, namely `number`, and `string`. This
    array type interface also enforces that the return type of the array should match
    the declaration.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript支持`number`和`string`两种类型的`index`。此数组类型接口还强制数组的返回类型与声明匹配。
- en: Class type interfaces
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**类类型接口**'
- en: 'Class type interfaces define the contract for classes. A class that implements
    an interface should meet the requirements of the interface:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 类型接口定义了类的约定。实现接口的类应满足接口的要求：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The class type interface only deals with public members of the class. So, it
    is not possible to add private members to the interface.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类类型接口只处理类的公共成员。因此，不可能向接口添加私有成员。
- en: Extending interfaces
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**扩展接口**'
- en: 'Interfaces can be extended; extending an interface makes it share the properties
    of another interface, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以进行扩展；扩展一个接口使其共享另一个接口的属性，如下所示：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the `Employee` interface extends the `Manager` interface and shares its
    `hasPower` with the `Employee` interface.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Employee`接口扩展了`Manager`接口，并将`hasPower`与`Employee`接口共享。
- en: Hybrid type interface
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**混合类型接口**'
- en: 'Hybrid type interfaces are used when we want to use anÂ object both as a function
    and as an object. We can call an object like a function if it implements a hybrid
    type interface, or we can use it as an object and access its properties. This
    type of interface enables you to use an interface as an object and a function,
    as illustrated:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望将对象既作为函数又作为对象使用时，就会使用混合类型接口。如果对象实现了混合类型接口，我们可以像调用函数一样调用对象，或者我们可以将其作为对象使用并访问其属性。这种类型的接口使您能够将一个接口用作对象和函数，如下所示：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Classes
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**Classes**'
- en: '* * *'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: A class is an extensible template that is used to create objects with member
    variables to hold the state of the object and member functions that deal with
    the behavior of the object.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类是一个可扩展的模板，用于创建具有成员变量以保存对象状态和处理对象行为的成员函数的对象。
- en: 'The current version of JavaScript supports only function-based and prototype-based
    inheritance to build reusable components. The next version of JavaScript ECMAScript
    6 supports object-oriented programming by adding the syntactic sugar for prototype-based
    class definitions and inheritance. However, TypeScript enabled developers to write
    code using object-oriented programming techniques, and it compiles the code down
    to JavaScript, which is compatible with all browsers and platforms:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的JavaScript仅支持基于函数和基于原型的继承来构建可重用组件。JavaScript的下一个版本ECMAScript 6支持面向对象编程，通过添加原型化类定义和继承的语法糖。然而，TypeScript使开发人员能够使用面向对象编程技术编写代码，并将代码编译为与所有浏览器和平台兼容的JavaScript：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This `Customer` class has three members: a `name` property, a constructor,
    and a `logCustomer` method. The last statement outside the `Customer` class creates
    an instance of the `customer` class using the `new` keyword.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此`Customer`类有三个成员：`name`属性、构造函数和`logCustomer`方法。`Customer`类外的最后一条语句使用`new`关键字创建`customer`类的一个实例。
- en: Inheritance
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**Inheritance**'
- en: '* * *'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Inheritance is the concept of inheriting some behaviors of another class or
    object. It helps achieve code reusability and build hierarchy in relationships
    of classes or objects. Also, inheritance helps you cast similar classes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是指继承另一个类或对象的一些行为的概念。它有助于实现代码的可重用性，并建立类或对象之间的关系层次结构。此外，继承可以帮助您对相似的类进行强制转换。
- en: JavaScript of ES5 standard doesn't support classes, and so, class inheritance
    is not possible in JavaScript. However, we can implement prototype inheritance
    instead of class inheritance. Let's see inheritance in ES5 with examples.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ES5标准的JavaScript不支持类，因此在JavaScript中无法进行类继承。但是，我们可以通过原型继承来实现类继承。让我们看看ES5中的继承示例。
- en: 'First, create a function named `Animal`, as follows. Here, we create a function
    named `Animal` with two methods: `sleep` and `eat`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`Animal`的函数，如下所示。在这里，我们创建一个名为`Animal`的函数，其包含两个方法：`sleep`和`eat`：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s extend this `Animal` function using the prototype, as shown:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用原型扩展这个`Animal`函数，如下所示：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we can create an instance of `Animal` and call the extended function bark,
    as demonstrated:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建`Animal`的实例并调用扩展函数bark，如下所示：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can use the `Object.Create` method to clone a prototype of the parent and
    create a child object. Then, we can extend the child object by adding methods.
    Let''s create an object named `Dog` and inherit it from `Animal`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Object.Create`方法来克隆父级原型并创建一个子对象。然后，我们可以通过添加方法来扩展子对象。让我们创建一个名为`Dog`的对象，并从`Animal`继承它：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let''s clone the prototype of `Animal` and inherit all the behavior in
    the `Dog` function. Then, we can call the `Animal` method using the `Dog` instance,
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们克隆`Animal`的原型，并继承`Dog`函数中的所有行为。然后，我们可以使用`Dog`实例调用`Animal`方法，如下所示：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Inheritance in TypeScript
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TypeScript中的继承
- en: We just saw how to implement an inheritance in JavaScript using a prototype.
    Now, we will see how an inheritance can be implemented in TypeScript.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何使用原型在JavaScript中实现继承。现在，我们将看到如何在TypeScript中实现继承。
- en: 'In TypeScript, similar to extending interfaces, we can also extend a class
    by inheriting another class, as illustrated:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，类接口可以扩展，而且我们也可以通过继承另一个类来扩展一个类，如下所示：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we are able to access the methods of `SimpleCalculator` using the instance
    of `ComplexCalculator` as it extends `SimpleCalculator`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们能够通过扩展`SimpleCalculator`的实例来访问`SimpleCalculator`的方法，因为`ComplexCalculator`扩展了`SimpleCalculator`。
- en: Private/Public modifiers
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 私有/公共修饰符
- en: 'In TypeScript, all members in a class are `public` by default. We have to add
    the `private` keyword explicitly to control the visibility of the members:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，类中的所有成员默认都是`public`的。我们必须明确添加`private`关键字来控制成员的可见性：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that in the `SimpleCalculator` class, we defined `x` and `y` as `private`
    properties, which will not be visible outside the class. In `ComplexCalculator`,
    we defined `x` and `y` using parameter properties. These parameter properties
    will enable us to create and initialize the member in one statement. Here, `x`
    and `y` are created and initialized in the constructor itself without writing
    any further statements inside it. Also,Â `x` and `y` are private in order to hide
    themÂ from exposure to consuming classes or modules.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`SimpleCalculator`类中，我们将`x`和`y`定义为`private`属性，这将不会在类外可见。在`ComplexCalculator`中，我们使用参数属性定义了`x`和`y`。这些参数属性将使我们能够在一个语句中创建和初始化成员。在这里，`x`和`y`在构造函数中创建并初始化，而不需要在其中写任何其他语句。同时，`x`和`y`是私有的，以便将它们隐藏起来以避免被外部类或模块访问。
- en: Accessors
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问器
- en: 'We can also implement `getters` and `setters` to the properties to control
    accessing them from the client. We can intercept some process before setting a
    value to a property variable or before getting a value of the property variable:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对属性实现`getters`和`setters`，以控制客户端对它们的访问。我们可以在设置属性变量的值之前或获取属性变量值之前拦截一些过程：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, the `setter` for the `name` property ensures that the customer `name`
    can be updated. Otherwise, it will show an alert message that it is not possible.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`name`属性的`setter`确保顾客的`name`可以更新。否则，它将显示一个不可能的警报消息。
- en: Static properties
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态属性
- en: 'These type of properties are not instance specific and are accessed by a class
    name instead of using the `this` keyword:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的属性不是特定于实例的，并且通过类名而不是使用`this`关键字来访问：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we declared a `static` variable,Â `bonusPercentage`, accessed using the
    `Customer` class name in the `calculateBonus` method. The `bonusPercentage` property
    is not instance specific.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个`static`变量`bonusPercentage`，在`calculateBonus`方法中使用`Customer`类名访问它。`bonusPercentage`属性不是特定于实例的。
- en: Modules
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: '* * *'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: JavaScript is a powerful and dynamic language. Due to the liberty of dynamic
    programming in JavaScript as per ES5 and earlier standards, it is our duty to
    structure and organize code. It will make the maintainability of code easier and
    also enable us to easily locate the code of a specific functionality we need.
    We can organize code by applying a modular pattern. Code can be separated into
    various modules, and the relevant code can be put in each module.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种强大而动态的语言。由于根据ES5和更早的标准在JavaScript中进行动态编程的自由，我们有责任结构化和组织代码。这将使代码的可维护性更容易，并且还可以使我们轻松地定位特定功能的代码。我们可以通过应用模块化模式来组织代码。代码可以分为各种模块，并且相关代码可以放在每个模块中。
- en: 'TypeScript made it easier to implement modular programming using the keyword
    module as per ECMAScript 6 specifications. Modules enable you to control the scope
    of variables, code reusability, and encapsulation. TypeScript supports two types
    of modules: internal and external.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript使得按照ECMAScript 6规范实现模块化编程变得更容易。模块使您能够控制变量的范围，代码的重用性和封装性。TypeScript支持两种类型的模块：内部和外部。
- en: Namespaces
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'We can create namespaces in TypeScript using the namespace keyword, as illustrated.
    All the classes defined under namespace will be scoped under that particular namespace
    and will not be attached to the global scope:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `namespace` 关键字在 TypeScript 中创建命名空间，如下所示。在命名空间下定义的所有类都将在该特定命名空间下使用，并且不会附加到全局范围下：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To make the `Product` class available outside the namespace, we need to add
    an `export` keyword when defining the `Product` class, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 `Product` 类在命名空间外部可用，我们在定义 `Product` 类时需要添加 `export` 关键字，如下所示：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can also share the namespace across files by adding a `reference` statement
    at the beginning of the code in the referring files, as shown:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过在引用文件的代码开头添加 `reference` 语句来跨文件共享命名空间，如下所示：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Modules
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块
- en: 'TypeScript also supports modules. As we deal with a large number of external
    JavaScript libraries, this module will really help us refer and organize our code.
    Using the `import` statement, we can import external modules, as illustrated:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript也支持模块。由于我们处理大量的外部JavaScript库，这个模块将帮助我们引用和组织我们的代码。使用 `import` 语句，我们可以导入外部模块，如下所示：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we just imported the previously created module, `Inventory`, and created
    an instance of `Product`Â assigned to the `p`Â variable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是导入了先前创建的模块 `Inventory`，并创建了一个分配给变量 `p` 的 `Product` 实例。
- en: Functions
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: JavaScript that follows ES5 specificaitons does not support classes and modules.
    However, we tried to achieve the scoping of variables and modularity using functional
    programming in JavaScript. Functions are the building blocks of an application
    in JavaScript.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循ES5规范的JavaScript不支持类和模块。但是，我们尝试使用JavaScript中的函数式编程来实现变量的作用域和模块化。函数是JavaScript应用程序的构建块。
- en: 'Though TypeScript supports classes and modules, functions play a key role in
    defining a specific logic. We can define both theÂ `function` and `Anonymous`
    functions in JavaScript as shown:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TypeScript支持类和模块，但函数在定义特定逻辑方面起着关键作用。我们可以在JavaScript中定义`function`和`匿名`函数，如下所示：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In TypeScript, we define functions with the type of the parameters and the
    return type using function arrow notation, which is also supported in ES6; it''sÂ done
    like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，我们使用函数箭头符号定义参数的类型和返回类型，这也适用于 ES6；表示如下：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Optional and default parameters
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选和默认参数
- en: 'Consider thatÂ we have a function with three parameters, and sometimes, we
    may only pass values for the first two parameters in the function. In TypeScript,
    we can handle such scenarios using the optional parameter. We can define the first
    two parameters as normal and theÂ third parameter as optional, as given in the
    following code snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个具有三个参数的函数，并且有时在函数中可能只为前两个参数传递值。在 TypeScript 中，我们可以使用可选参数处理这种情况。我们可以将前两个参数定义为正常参数，将第三个参数定义为可选参数，如下面的代码片段所示：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, `middleName` is the optional parameter, and it can be ignored when calling
    the function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`middleName` 是可选参数，在调用函数时可以忽略它。
- en: 'Now, let''s see how to set default parameters in a function. If a value is
    not supplied to a parameter in the `function`, we can define it to take the default
    value that is configured:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在函数中设置默认参数。如果没有为参数提供值，我们可以定义它为配置的默认值：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, `middleName` is the default parameter that will have `'No Middle Name'`
    by default if the value is not supplied by the caller.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`middleName`是默认参数，如果调用者未提供值，则默认值为`'No Middle Name'`。
- en: Rest parameters
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 剩余参数
- en: 'Using the rest parameter, you can pass an array of values to the function.
    This can be used in scenarios where you are unsure about how many values will
    be supplied to the function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用剩余参数，可以将值的数组传递给函数。这在您不确定将向函数提供多少值的场景中可以使用：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, note that the `restOfClient` rest parameter is prefixed with an ellipsis
    (...), and it can hold an array of strings. In the caller of the function, only
    the value of the first parameter that is supplied will be assigned to the `firstClient`
    parameter, and the remaining values will be assigned to `restOfClient` as array
    values.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，注意`restOfClient`剩余参数前缀带有省略号（...），它可以保存一个字符串数组。在函数的调用者中，只有提供的第一个参数的值将被赋给`firstClient`参数，并且剩余的值将被分配给`restOfClient`作为数组值。
- en: Generics
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型
- en: '* * *'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Generics come inÂ very handy whenÂ developing reusable components that can
    work against any data type. So, the client that consumes this component will decide
    what type of data it should act upon. Let''s create a simple function that returns
    whatever data is passed to it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发可对抗任何数据类型的可重用组件时，泛型非常有用。因此，使用此组件的客户端将决定它应该对哪种类型的数据进行操作。让我们创建一个简单的函数，该函数返回传递给它的任何数据类型：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see, we need individual methods to process each data type. We can
    implement the same in a single function using the `any` data type, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们需要个别方法来处理每种数据类型。我们可以使用`any`数据类型在单个函数中实现相同的功能，如下所示：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is similar to generics. However, we don't have control over the return
    type. If we pass a number and we can't predict whether the number will be returned
    or not by the function, The return type can be of any type.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这与泛型类似。然而，我们对返回类型没有控制。如果我们传递一个数字，并且无法预测函数是否会返回该数字，函数的返回类型可以是任意类型。
- en: 'Generics offer a special variable of the `T`Â type. Applying this type to the
    function, as shown, enables the client to pass the data type they would like this
    function to process:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型提供了`T`类型的特殊变量。将此类型应用到函数中，如所示，使客户端能够传递他们希望该函数处理的数据类型：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'So, the client can call this function for various data types, as shown:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，客户端可以为各种数据类型调用此函数，如所示：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that the data type to be processed is passed by wrapping it in angle brackets
    (`<>`) in the function call.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在函数调用中，应该将要处理的数据类型通过尖括号（`<>`）进行包裹传递。
- en: Generic interfaces
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型接口
- en: 'We can also define generic interfaces using the type variable `T`, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用类型变量`T`来定义泛型接口，如下所示：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we defined a generic interface and the `myFunc` variable of the `GenericFunc`
    type, passing the number data type for the type variable `T`. Then, this variable
    is assigned with a function named `func`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个泛型接口和`myFunc`变量的`GenericFunc`类型，将数字数据类型传递给类型变量`T`。然后，将该变量分配给名为`func`的函数。
- en: Generic classes
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型类
- en: 'Similar to generic interfaces, we can also define generic classes. We define
    classes with a generic type in angle brackets (`<>`), as shown:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与泛型接口类似，我们也可以定义泛型类。我们使用尖括号（`<>`）中的泛型类型来定义类，如下所示：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, the generic class is instantiated by passing the generic data type as
    `number`. So, the `add` function will process and add two numbers passed as parameters.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过将泛型数据类型传递为`number`，实例化了泛型类。因此，`add`函数将处理并加上作为参数传递的两个数字。
- en: Decorators
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: '* * *'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Decorators enable us to extend a class or object by adding behaviors without
    modifying the code. Decorators wrap the class with extra functionality. TheyÂ can
    be attached to a class, property, method, parameter, and accessor. In ECMAScript
    2016, decorators are proposed to modify the behavior of a class. Decorators are
    prefixed with the `@` symbol and a decorator name that resolves to a function
    called at `runtime`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器使我们能够通过添加行为来扩展类或对象，而无需修改代码。装饰器用额外功能包装类。它们可以附加到类、属性、方法、参数和访问器。在ECMAScript
    2016中，装饰器被提议用于修改类的行为。装饰器用`@`符号和解析为在`runtime`调用的函数的装饰器名称进行前缀。
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Class decorators
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类装饰器
- en: 'Class decorators are declared before the class declaration. Class decorators
    can observe, modify, and replace the definition of a class by applying to the
    constructor of that class. The signature of `ClassDecorator` in TypeScript is
    as illustrated:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 类装饰器是在类声明之前声明的。类装饰器可以通过应用于该类的构造函数来观察、修改和替换类的定义。TypeScript中`ClassDecorator`的签名如下所示：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Consider a `Customer` class, and we would like that class to be freezed. Its
    existing properties should not be removed andÂ new properties should not be added.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个`Customer`类，我们希望该类被冻结。其现有属性不应被移除，也不应添加新属性。
- en: 'We can create a separate class that can take any object and freeze it. We can
    then decorate the customer class with `@freezed` to prevent adding new properties
    or removing the existing properties from the class:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个单独的类，可以接受任何对象并将其冻结。然后，我们可以使用`@freezed`装饰器来装饰`Customer`类，以防止从类中添加新属性或移除现有属性：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, the freezed decorator takes the `target`, that is, the `Customer` class
    that is being decorated and freezes it when it is executed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`freezed`装饰器获取`target`，即正在被装饰的`Customer`类，并在执行时将其冻结。
- en: Method decorators
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法装饰器
- en: 'Method decorators are declared before the method declaration. This decorator
    is used to modify, observe, or replace a method definition and is applied to the
    property descriptor for the method. The following code snippet shows a simple
    class with an applied method decorator:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 方法装饰器是在方法声明之前声明的。此装饰器用于修改、观察或替换方法定义，并且应用于方法的属性描述符。下面的示例代码显示了一个应用了方法装饰器的简单类：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The method decorator function takes three arguments: `target`, `key`, and `value`.
    The `target`Â argument holds the method that is being decorated; `key` holds the
    name of the method being decorated, and `value` is the property descriptor of
    the specified property if it exists on the object.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 方法装饰器函数接受三个参数：`target`，`key`和`value`。`target`参数保存了正在被装饰的方法；`key`保存了被装饰方法的名称，`value`是指定对象上存在的特定属性的属性描述符。
- en: When the `increment` method is called, the `logging` decorator is invoked and
    the `values` parameters are passed to it. The `logging` method will log details
    about the arguments passed to the console.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`increment`方法时，`logging`装饰器被调用，并且`values`参数被传递给它。`logging`方法将在控制台上记录有关传递的参数的详细信息。
- en: Accessor decorators
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问器装饰器
- en: 'Accessor decorators are prefixed before the accessor declaration. These decorators
    are used to observe, modify, or replace an accessor definition and are applied
    to the property descriptor. The following code snippet shows a simple class with
    the accessor decorator applied:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'Accessor decorators are prefixed before the accessor declaration. These decorators
    are used to observe, modify, or replace an accessor definition and are applied
    to the property descriptor. The following code snippet shows a simple class with
    the accessor decorator applied:'
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `logging` function sets the `Boolean` value to the `logging` property descriptor.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging`函数将`Boolean`值设置为`logging`属性描述符。'
- en: Property decorators
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性装饰器
- en: 'Property decorators are prefixed to property declarations. The signature of
    `PropertyDecorator` in the TypeScript source code is this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 属性装饰器是前缀到属性声明。在TypeScript源代码中，`PropertyDecorator`的签名是这样的：
- en: '[PRE53]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `_value`Â variable holds the value of the property that is being decorated.
    Both theÂ `getter` and `setter` functions will have access to the `_value` variable,
    and here, we can manipulate the `_value`Â variableÂ by adding extra behaviors.
    I have concatenated `#` in `getter` to return hash tagged first name. Then, we
    delete the original property from the class prototype using the `delete` operator.
    A new property will be created with the original property name andÂ the extra
    behavior.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`_value`变量保存了被装饰的属性的值。`getter`和`setter`函数都可以访问`_value`变量，在这里，我们可以通过添加额外行为来操纵`_value`变量。我在`getter`中连接了`#`来返回标记的名字。然后，使用`delete`操作符从类原型中删除原始属性。然后，一个新属性将会被创建，拥有原始属性名和额外的行为。'
- en: Parameter decorators
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数装饰器
- en: 'Parameter decorators are prefixed to parameter declarations, and they are applied
    to a function for a class constructor or method declaration. This is the signature
    of `ParameterDecorator`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 参数装饰器是前缀到参数声明，并且它们应用于类构造函数或方法声明的函数。这是`ParameterDecorator`的签名：
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s define the `Customer` class and use a parameter decorator to decorate
    a parameter in order to make it required, and validate whether the value has been
    served:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义`Customer`类，并使用参数装饰器来装饰一个参数，以使其必需，并验证其是否被提供：
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here, the name parameter has been decorated with `@logging`. The parameter
    decorator implicitly takes three inputs, namelyÂ `prototype` of the class that
    has this decorator, `name` of the method that has this decorator, and `index`
    of the parameter that is being decorated. The `logging` function implementation
    of the parameter decorator is as illustrated:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，name 参数已经被 `@logging` 装饰器修饰。参数装饰器隐式接收三个输入，即带有该装饰器的类的原型，带有该装饰器的方法的名称，以及被装饰的参数的索引。参数装饰器
    `logging` 的实现如下所示：
- en: '[PRE58]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, `target` is the class that has the decorator, `key` is the function name,
    and `index` contains the parameter index. This code just logs `target`, `key`,
    and `index` to the console.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`target` 是带有装饰器的类，`key` 是函数名，`index` 包含参数索引。这段代码仅将 `target`、`key` 和 `index`
    记录在控制台中。
- en: TypeScript and Angular
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript 和 Angular
- en: '* * *'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: As you have seen in this chapter, TypeScript comes with strong type-checking
    capabilities and supports object-oriented programming. Due to such advantages,
    the Angular team has chosen TypeScript to build Angular. Angular was completely
    rewritten from the core using TypeScript, and its architecture and coding pattern
    was completely changed, as you saw in [Chapter 2](Learning%20Angular%20for%20.NET%20Developers_split_000.html#),
    *Angular building blocks part 1*, and [Chapter 3](Learning%20Angular%20for%20.NET%20Developers_split_000.html#),
    *Angular building blocks part 2*. So, writing an Angular app using TypeScript
    is the best choice.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章中所见，TypeScript 具有强大的类型检查能力，并支持面向对象编程。由于这些优势，Angular 团队选择了 TypeScript 来构建
    Angular。Angular 完全重写了核心代码，使用 TypeScript，并且它的架构和编码模式完全改变了，就像你在 [第2章](Learning%20Angular%20for%20.NET%20Developers_split_000.html#)
    和 [第3章](Learning%20Angular%20for%20.NET%20Developers_split_000.html#) 中看到的，*Angular
    基本构件部分1* 和 *Angular 基本构件部分2*。因此，使用 TypeScript 编写 Angular 应用是最佳选择。
- en: 'We can implement modules in Angular similar to modules in TypeScript. Components
    in an Angular application are actually a TypeScript class decorated with `@Component`.
    Modules can be imported to the current class file using import statements. The
    `export` keyword is used to indicate that this component can be imported and accessed
    in another module. The sample component code that is developed using TypeScript
    is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Angular 中实现类似 TypeScript 中的模块。Angular 应用中的组件实际上是一个带有 `@Component` 装饰器的
    TypeScript 类。使用 import 语句可以将模块导入到当前的类文件中。`export` 关键字用于指示该组件可以在另一个模块中被导入和访问。使用
    TypeScript 开发的示例组件代码如下所示：
- en: '[PRE59]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: '* * *'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Voila! Now you've learned the fundamentals of the TypeScript language. We started
    by discussing what is TypeScript and itsÂ advantages. Then, you learned about
    the various data types in TypeScript with examples. We also walked through object-oriented
    programming in TypeScript and interfaces, classes, modules, functions, and generics
    with examples. Next, you learned about the various types of decorators andÂ their
    implementation withÂ examples. Finally, we sawÂ why we shouldÂ use TypeScript
    for Angular and the benefit of using TypeScript to write Angular applications.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Voila! 现在你已经学会了 TypeScript 语言的基础知识。我们首先讨论了 TypeScript 是什么以及它的优势。然后，你学习了 TypeScript
    中各种数据类型，并附有示例。我们还深入讲解了 TypeScript 中的面向对象编程和接口、类、模块、函数和泛型，并提供了示例。接下来，你学习了各种类型的装饰器及其实现方法，并给出了示例。最后，我们看到了为什么我们应该使用
    TypeScript 来编写 Angular 应用以及使用 TypeScript 编写 Angular 应用的好处。
- en: In the next chapter, we will discuss how to create an Angular single-page application
    using Visual Studio.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何使用 Visual Studio 创建 Angular 单页面应用程序。
