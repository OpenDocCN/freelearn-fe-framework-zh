- en: '27'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '27'
- en: Controlling Image Display
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制图像显示
- en: So far, the examples in this book haven’t rendered any images on mobile screens.
    This doesn’t reflect the reality of mobile applications. Web applications display
    lots of images. If anything, native mobile applications rely on images even more
    than web applications because images are a powerful tool when you have a limited
    amount of space.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中的示例还没有在移动屏幕上渲染任何图像。这并不反映移动应用程序的现实。Web应用程序显示了很多图像。如果有什么不同的话，原生移动应用程序比Web应用程序更依赖于图像，因为当您有限的空间时，图像是一种强大的工具。
- en: In this chapter, you’ll learn how to use the React Native `Image` component,
    starting with loading images from different sources. Then, you’ll learn how you
    can use the `Image` component to resize images, and how you can set placeholders
    for lazily loaded images. Finally, you’ll learn how to implement icons using the
    `@expo/vector-icons` package. These sections cover the most common use cases for
    using images and icons in apps.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用React Native的`Image`组件，从加载不同来源的图像开始。然后，您将学习如何使用`Image`组件来调整图像大小，以及如何为懒加载的图像设置占位符。最后，您将学习如何使用`@expo/vector-icons`包实现图标。这些部分涵盖了在应用程序中使用图像和图标的最常见用例。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中介绍以下主题：
- en: Loading images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载图像
- en: Resizing images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整图像大小
- en: Lazy image loading
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载图像
- en: Rendering icons
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染图标
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code and image files for this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter27](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter27).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码和图像文件，网址为[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter27](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter27)。
- en: Loading images
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载图像
- en: Let’s get started by figuring out how to load images. You can render the `<Image>`
    component and pass its properties just like any other React component. But this
    particular component needs image blob data to be of any use. A **BLOB** (short
    for **Binary Large Object**) is a data type used to store large, unstructured
    binary data. BLOBs are commonly used to store multimedia files like images, audio,
    and video.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先弄清楚如何加载图像。您可以像任何其他React组件一样渲染`<Image>`组件并传递其属性。但这个特定的组件需要图像blob数据才能发挥作用。**BLOB**（代表**Binary
    Large Object**，即二进制大对象）是一种用于存储大型、非结构化二进制数据的数据类型。BLOB通常用于存储多媒体文件，如图像、音频和视频。
- en: 'Let’s look at some code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are two ways to load the blob data into an `<Image>` component. The first
    approach loads the image data from the network. This is done by passing an object
    with a **URI** property to the `source` code. The second `<Image>` component in
    this example is using a local image file. It does this by calling `require()`
    and passing the result to the `source` code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以将blob数据加载到`<Image>`组件中。第一种方法是从网络中加载图像数据。这是通过将具有**URI**属性的对象传递给`source`代码来完成的。本例中的第二个`<Image>`组件正在使用本地图像文件。它是通过调用`require()`并将结果传递给`source`代码来实现的。
- en: 'Now, let’s see what the rendered result looks like:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看渲染结果是什么样的：
- en: '![Picture 1](img/B19636_27_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/B19636_27_01.png)'
- en: 'Figure 27.1: Image loading'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图27.1：图像加载
- en: 'Here’s the style that was used with these images:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这些图像使用的样式：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that without the `width` and `height` style properties, images will not
    render. In the next section, you’ll learn how image resizing works when the `width`
    and `height` values are set.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果没有设置`width`和`height`样式属性，图像将不会渲染。在下一节中，您将了解当设置`width`和`height`值时图像缩放是如何工作的。
- en: Resizing images
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整图像大小
- en: The `width` and `height` style properties of `Image` components determine the
    size of what’s rendered on the screen. For example, you’ll probably have to work
    with images at some point that have a larger resolution than you want to be displayed
    in your React Native application. Simply setting the `width` and `height` style
    properties on the `Image` is enough to properly scale the image.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image`组件的`width`和`height`样式属性决定了屏幕上渲染的大小。例如，您可能需要在某个时候处理分辨率比您希望在React Native应用程序中显示的更大的图像。只需在`Image`上设置`width`和`height`样式属性就足以正确缩放图像。'
- en: 'Let’s look at some code that lets you dynamically adjust the dimensions of
    an image using controls:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码，这些代码允许您使用控件动态调整图像的尺寸：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s what the image looks like if you’re using the default 100 x 100 dimensions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用默认的100 x 100维度，图像看起来是这样的：
- en: '![Picture 2](img/B19636_27_02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/B19636_27_02.png)'
- en: 'Figure 27.2: 100 x 100 image'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图27.2：100 x 100图像
- en: 'Here’s a scaled-down version of the image:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是缩小后的图像版本：
- en: '![Picture 3](img/B19636_27_03.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/B19636_27_03.png)'
- en: 'Figure 27.3: 50 x 50 image'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图27.3：50 x 50图像
- en: 'Lastly, here’s a scaled-up version of the image:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是一个放大后的图像版本：
- en: '![Picture 4](img/B19636_27_04.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片4](img/B19636_27_04.png)'
- en: 'Figure 27.4: 150 x 150 image'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图27.4：150 x 150图像
- en: There’s a `resizeMode` property that you can pass to `Image` components. This
    determines how the scaled image fits within the dimensions of the actual component.
    You’ll see this property in action in the *Rendering icons* section of this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`resizeMode`属性可以传递给`Image`组件。这决定了缩放后的图像如何适应实际组件的尺寸。您将在本章的*渲染图标*部分看到这个属性的用法。
- en: As you can see, the dimensions of the images are controlled by the `width` and
    `height` style properties. Images can even be resized while the app is running
    by changing these values. In the next section, you’ll learn how to lazily load
    images.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，图像的尺寸由`width`和`height`样式属性控制。在应用运行时，可以通过更改这些值来调整图像大小。在下一节中，您将学习如何懒加载图像。
- en: Lazy image loading
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载图像
- en: Sometimes, you don’t necessarily want an image to load at the exact moment that
    it’s rendered; for example, you might be rendering something that’s not visible
    on the screen yet. Most of the time, it’s perfectly fine to fetch the image source
    from the network before it’s actually visible. But if you’re fine-tuning your
    application and discover that loading lots of images over the network causes performance
    issues, you can use the lazy loading strategy.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能不希望在图像渲染的精确时刻加载图像；例如，您可能正在渲染屏幕上尚未可见的内容。大多数时候，在图像实际可见之前从网络上获取图像源是完全可以接受的。但如果您正在微调应用程序并发现通过网络加载大量图像会导致性能问题，您可以使用懒加载策略。
- en: I think the more common use case in a mobile context is handling a scenario
    where you’ve rendered one or more images where they’re visible, but the network
    is slow to respond. In this case, you will probably want to render a placeholder
    image so that the user sees something right away, rather than an empty space.
    So, let’s get started.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为在移动环境中更常见的用例是处理您已经渲染了一个或多个图像，但网络响应缓慢的场景。在这种情况下，您可能希望渲染一个占位图，以便用户立即看到一些内容，而不是空白空间。那么，让我们开始吧。
- en: 'Firstly, you can implement an abstraction that wraps the actual image that
    you want to show once it’s loaded. Here’s the code for this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以实现一个抽象，它封装了加载后要显示的实际图像。以下是该代码：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, here, you can see the placeholder image will be rendered only while the
    original image isn’t loaded:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这里，您可以看到占位图仅在原始图像未加载时才会被渲染：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This component renders a `View` component with two `Image` components inside
    it. It also has a loaded state, which is initially `false`. When `loaded` is `false`,
    the placeholder image is rendered. The `loaded` state is set to `true` when the
    `onLoad()` handler is called. This means that the placeholder image is removed
    and the main image is displayed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件渲染一个包含两个`Image`组件的`View`组件。它还有一个加载状态，初始值为`false`。当`loaded`为`false`时，将渲染占位图。当调用`onLoad()`处理程序时，将`loaded`状态设置为`true`。这意味着占位图将被移除，主图像将显示出来。
- en: 'Now, let’s use the `LazyImage` component that we’ve just implemented. You’ll
    render the image without a `source`, and the placeholder image should be displayed.
    Let’s add a button that gives the lazy image a `source`. When it loads, the placeholder
    image should be replaced. Here’s what the main `app` module looks like:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们刚刚实现的`LazyImage`组件。您将渲染没有`source`的图像，并且应该显示占位图。让我们添加一个按钮，为懒加载图像提供一个`source`。当它加载时，占位图应该被替换。以下是主`app`模块的外观：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is what the screen looks like initially:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是屏幕的初始状态：
- en: '![Picture 5](img/B19636_27_05.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片5](img/B19636_27_05.png)'
- en: 'Figure 27.5: Initial state of the image'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图27.5：图像的初始状态
- en: 'Then, click the **Load Remote** button to eventually see the image that we
    actually want:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击**加载远程**按钮，最终看到我们真正想要的图像：
- en: '![Picture 6](img/B19636_27_06.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片6](img/B19636_27_06.png)'
- en: 'Figure 27.6: Loaded image'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图27.6：已加载图像
- en: You might notice that, depending on your network speed, the placeholder image
    remains visible, even after you click the **Load Remote** button. This is by design
    because you don’t want to remove the placeholder image until you know for sure
    that the actual image is ready to be displayed. Now, let’s render some icons in
    our React Native application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，根据您的网络速度，占位符图像在您点击 **加载远程** 按钮后仍然可见。这是设计上的考虑，因为您不希望在确定实际图像准备好显示之前移除占位符图像。现在，让我们在我们的
    React Native 应用程序中渲染一些图标。
- en: Rendering icons
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染图标
- en: In the final section of this chapter, you’ll learn how to render icons in React
    Native components. Using icons to indicate meaning makes web applications more
    usable. So, why should native mobile applications be any different?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，您将学习如何在 React Native 组件中渲染图标。使用图标来表示意义可以使网络应用程序更易于使用。那么，为什么原生移动应用程序会有所不同呢？
- en: 'We’ll use the `@expo/vector-icons` package to pull various vector font packages
    into your React Native app. This package is already part of the Expo project that
    we’re using as the base of the app, and now, you can import `Icon` components
    and render them. Let’s implement an example that renders several **FontAwesome**
    icons based on a selected icon category:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `@expo/vector-icons` 包将各种矢量字体包拉入您的 React Native 应用程序。这个包已经是我们在应用程序基础上使用的
    Expo 项目的组成部分，现在，您可以导入 `Icon` 组件并将它们渲染出来。让我们实现一个示例，根据选择的图标类别渲染几个 **FontAwesome**
    图标：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we have defined all necessary logic to store and update the icon data.
    Next, we will apply it to the layout:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经定义了所有必要的逻辑来存储和更新图标数据。接下来，我们将将其应用于布局：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When you run this example, you should see something that looks like the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此示例时，您应该看到以下内容：
- en: '![Picture 7](img/B19636_27_07.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7](img/B19636_27_07.png)'
- en: 'Figure 27.7: Rendering icons'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 27.7：渲染图标
- en: Summary
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned about handling images in our React Native applications.
    Images in a native application are just as important in a native mobile context
    as they are in a web context: they improve the user experience.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在 React Native 应用程序中处理图像。在原生移动环境中，图像与在 Web 环境中一样重要：它们改善了用户体验。
- en: We learned about the different approaches to loading images, as well as how
    to resize them. We also learned how to implement a lazy image, which displays
    a placeholder image while the actual image is loading. Finally, we learned how
    to use icons in a React Native app. These skills will help you manage images and
    make your app more informative.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了加载图像的不同方法，以及如何调整图像大小。我们还学习了如何实现懒加载图像，在实际图像加载时显示占位符图像。最后，我们学习了如何在 React
    Native 应用程序中使用图标。这些技能将帮助您管理图像，并使您的应用程序更具信息性。
- en: In the next chapter, we’ll learn about local storage in React Native, which
    is handy when our app goes offline.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习 React Native 中的本地存储，当我们的应用程序离线时，这非常有用。
