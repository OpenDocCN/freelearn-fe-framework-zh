- en: '*Chapter 3*: Hooking into React'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：Hooking into React'
- en: In the previous chapter, we learned to perform actions inside a function component
    with our crafted states. In this chapter, we will go through the challenges we
    face in creating a good state solution, and then see how *React* builds the solution
    with the underlying Hook. We will then introduce what a hook is and get to know
    it, as well as its calling order, and learn how to avoid running into conditional
    hook issues in real applications. The chapter also includes two bonus topics in
    the *Appendix* section, *React Fiber* and *Current and WorkInProgress Scenes*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何在函数组件内部使用我们自定义的状态来执行操作。在本章中，我们将探讨在创建良好的状态解决方案时面临的挑战，然后看看React如何通过底层的Hook构建解决方案。然后我们将介绍什么是hook，并了解它的调用顺序，以及如何在实际应用中避免遇到条件hook问题。本章还包括附录部分的两篇附加主题，*React
    Fiber* 和 *Current and WorkInProgress Scenes*。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating good state solution
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建良好的状态解决方案
- en: Introducing a React Hook
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍React Hook
- en: What is a hook?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是hook？
- en: Questions and answers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问答
- en: Appendix
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附录
- en: Creating a good state solution
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建良好的状态解决方案
- en: States are quite capable. A component without states is like a function without
    variables. It would lack capabilities of reasoning. A piece of UI logic relies
    on states to work upon continuous interactions from users.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 状态非常强大。一个没有状态组件就像一个没有变量的函数。它将缺乏推理能力。一块UI逻辑依赖于状态来处理来自用户的连续交互。
- en: 'We built a custom state in the previous chapter as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们按照以下方式构建了一个自定义状态：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Though this approach works, there are a few problems we need to address before
    we can be seriously considered using it with *React*. We'll mention these problems
    one by one as follows.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法可行，但在我们可以认真考虑使用React之前，我们需要解决一些问题。我们将逐一提及这些问题。
- en: 'The location where the states are allocated is the first major problem:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 状态分配的位置是第一个主要问题：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding `states` variable is allocated as a global variable, but normally
    we'd be first interested in states specific to a component. In other words, we
    need to find a place to define local states.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `states` 变量被分配为一个全局变量，但通常我们首先感兴趣的会是特定于组件的状态。换句话说，我们需要找到一个地方来定义局部状态。
- en: 'The second problem of using states is the unique key to identify each of them:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用状态的第二大问题是每个状态的唯一键：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As in the preceding state usage, after we name the state `comp_a`, we have to
    carry this key for any actions involving this state. In a typical application,
    we could have lots of states like that; if each has to be defined with a unique
    string, we would have to come up with a lot of unique names. It would be quite
    some work to keep track of all the used names, not to mention that the variable
    holding the state inside the function component already has a name, `a`. It's
    a bit cumbersome to have both the variable name and key string.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在先前的状态使用中一样，在将状态命名为`comp_a`之后，我们必须为涉及此状态的任何操作携带这个键。在一个典型的应用中，我们可能有大量的状态；如果每个都必须用唯一的字符串定义，我们就必须想出很多唯一的名称。跟踪所有使用的名称的工作量会相当大，更不用说函数组件内部持有状态的变量已经有一个名字，`a`。同时拥有变量名和键字符串会有些繁琐。
- en: 'Other than these two major problems, there are other minor things we need to
    consider. In demonstrating the usage of the state, we render the `Title` component
    when we need to request a new update:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个主要问题之外，还有一些其他的小事情我们需要考虑。在演示状态的使用时，当我们需要请求新的更新时，我们会渲染`Title`组件：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Explicitly knowing which component we need to update for each action we perform
    can be a challenge to developers. It would be better if the engine can help us
    here to hide away this detail by figuring out what the components are that need
    to be updated. This is exactly what *React* does best; we should wire it with
    the engine to perform the right update. Last but not least, we know that the states
    can be used for different purposes since the underlying concept is a persistency
    mechanism. If done properly, we should be able to create some sort of infrastructure
    upon which we can add additional functionalities.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 明确知道我们为每个执行的操作需要更新哪个组件可能对开发者来说是一个挑战。如果引擎能帮助我们在这里隐藏这个细节，找出需要更新的组件，那就更好了。这正是React最擅长的；我们应该将其与引擎连接起来以执行正确的更新。最后但同样重要的是，我们知道状态可以用于不同的目的，因为其底层概念是一个持久化机制。如果做得恰当，我们应该能够创建某种基础设施，在此基础上我们可以添加额外的功能。
- en: The preceding is a list of issues that a good state solution should consider.
    With these in mind, let's take a look at how *React* approaches this state problem.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前面列出的都是一个好的状态解决方案应该考虑的问题。考虑到这些，让我们看看 *React* 是如何处理这个状态问题的。
- en: Introducing a React Hook
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 React Hook
- en: The state is mostly local to a component, at least as far as this book is mostly
    concerned. The natural place for storage would be under a component instance because
    a component in *React* defines a piece of UI. So, where is the component instance
    of a function component in *React* stored?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 状态主要位于组件内部，至少就本书的内容而言是这样的。存储状态的天然位置应该是在组件实例下，因为 *React* 中的组件定义了一块 UI。那么，*React*
    中函数组件的组件实例存储在哪里呢？
- en: It turns out that a component isn't the smallest unit in *React*. There's a
    more granular structure called fiber, which is used to represent a piece of element.
    A fiber performs all the tasks for this element. The element can be as simple
    as `h1`, `div` elements, or it can be an artificial element that does things differently.
    For instance, a "fragment" element can group other elements without displaying
    itself, or a "memo" element can remember all the elements from the last update.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，组件并不是 *React* 中的最小单元。有一个更细粒度的结构叫做纤维，它用于表示一个元素。纤维为这个元素执行所有任务。元素可以是像 `h1`、`div`
    这样的简单元素，也可以是执行不同操作的伪元素。例如，“片段”元素可以组合其他元素而不显示自己，或者“memo”元素可以记住上一次更新中的所有元素。
- en: Actually, a function component is one of the artificial elements that a fiber
    represents. What a function component does is allow us to define what elements
    it can display, so whenever it's invoked, it can figure out what DOM elements
    the screen needs to update. You can find more information in *Appendix A – React
    Fiber* at the end of this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，函数组件是纤维表示的伪元素之一。函数组件的作用是允许我们定义它可以显示的元素，所以每次它被调用时，它都能确定屏幕需要更新哪些 DOM 元素。你可以在本章末尾的
    *附录 A – React Fiber* 中找到更多信息。
- en: 'So, now we find the unit for a component instance; that''s exactly where *React*
    decides to store states. *React* stores them under a `memoizedState` property
    using a Hook structure, as shown in *Figure 3.1*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们找到了组件实例的单位；这正是 *React* 决定存储状态的地方。*React* 使用 Hook 结构在 `memoizedState`
    属性下存储它们，如图 3.1 所示：
- en: '![Figure 3.1 – Hooks under a fiber'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – 纤维下的 Hooks'
- en: '](img/Figure_3.01_B17963.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.01_B17963.jpg)'
- en: Figure 3.1 – Hooks under a fiber
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 纤维下的 Hooks
- en: The Hook we introduce here is a structure (or a class) to hold a state. This
    is not exactly the *React* hook (function) we will introduce later. Unfortunately,
    *React* uses the same word at both places. To distinguish them, we intentionally
    use *Hook* (with an uppercase *H*) for the structure and *hook* (with a lowercase
    *h*) for the function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里引入的 Hook 是一个用于保存状态的（或类）结构。这并不完全等同于我们稍后将要介绍的 *React* Hook（函数）。不幸的是，*React*
    在这两个地方都使用了相同的词。为了区分它们，我们故意使用 *Hook*（带大写 *H*）来表示结构，而使用 *hook*（带小写 *h*）来表示函数。
- en: The main functionality of a Hook structure is to hold a single state under the
    `state` property. Instead of having multiple states in an array (or an object),
    multiple states are linked together using a linked list, as shown in *Figure 3.2*.
    One Hook points to another one via its `next` property. When it reaches the end
    of the list, the `next` property of the last Hook is set to be `null`. This is
    how a typical linked list works in programming. The first Hook, if any, is stored
    under the `memoizedState` of the fiber; this way, a fiber can find all Hooks following
    the first one.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Hook 结构的主要功能是在 `state` 属性下保存单个状态。而不是在数组（或对象）中保存多个状态，多个状态通过链表链接在一起，如图 3.2 所示。一个
    Hook 通过其 `next` 属性指向另一个 Hook。当它到达列表的末尾时，最后一个 Hook 的 `next` 属性被设置为 `null`。这就是编程中典型的链表工作方式。如果有的话，第一个
    Hook 存储在纤维的 `memoizedState` 下；这样，纤维就可以找到第一个之后的所有 Hooks。
- en: '![Figure 3.2 – Hooks in a Linked List'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – 链表中的 Hooks'
- en: '](img/Figure_3.02_B17963.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.02_B17963.jpg)'
- en: Figure 3.2 – Hooks in a Linked List
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 链表中的 Hooks
- en: A fiber needs to be updated for the engine to know whether there is any change
    to the screen. In the update function, this is where the Hook gets initialized.
    So next, let's take a look at the update function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让引擎知道屏幕上是否有任何变化，需要更新纤维。在更新函数中，这就是 Hook 初始化的地方。所以接下来，让我们看看更新函数。
- en: Updating a function component
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新函数组件
- en: '*React* updates a function component through an `updateFunctionComponent` function.
    The input arguments accept a `Component` function and its `props` input:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*React*通过`updateFunctionComponent`函数更新一个函数组件。输入参数接受一个`Component`函数及其`props`输入：'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The main job of the update function is to invoke `Component(props)` to know
    the new `children` element. Taking a `Title` component as an example, when it
    gets to be updated, the `updateFunctionComponent` function invokes `Title()`.
    With that, the engine compares the element returned and what's on the screen and
    commits the difference.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 更新函数的主要任务是调用`Component(props)`以了解新的`children`元素。以`Title`组件为例，当它需要更新时，`updateFunctionComponent`函数会调用`Title()`。有了这个，引擎会比较返回的元素和屏幕上的元素，并提交差异。
- en: There are two global variables defined in the preceding update function. They
    are quite easy to follow. `updatingFiber` represents the current fiber that is
    under update by the engine, and `prevHook` points to the previously worked Hook
    for this fiber. Before the component is invoked, `updatingFiber` is populated
    by the engine, such as `Title`, and `prevHook` is set to be `null`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的更新函数中定义了两个全局变量。它们很容易理解。`updatingFiber`代表当前由引擎更新的纤维，`prevHook`指向这个纤维之前工作的Hook。在组件被调用之前，`updatingFiber`由引擎填充，例如`Title`，而`prevHook`被设置为`null`。
- en: The first time a component is updated, as in a mount, is when the first Hook
    for this fiber is created.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 组件第一次更新，就像挂载一样，是创建这个纤维的第一个Hook的时候。
- en: Creating a Hook at the mount
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在挂载时创建Hook
- en: 'To mount a Hook under the currently updating fiber, *React* creates a new Hook
    object and appends it to the linked list:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要在当前正在更新的纤维下挂载一个Hook，*React*会创建一个新的Hook对象并将其附加到链表中：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding `mountHook` function, an empty Hook object is allocated first
    with both `state` and `next` set to `null`. If it's the first Hook to the fiber,
    as `preHook` is `null`, it gets stored under `memoizedState` of the fiber. Otherwise,
    it gets appended to the previous Hook's `next` property. After that, the allocated
    Hook is returned.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`mountHook`函数中，首先分配了一个空的Hook对象，并将`state`和`next`都设置为`null`。如果是第一个到达纤维的Hook，由于`preHook`是`null`，它会被存储在纤维的`memoizedState`下。否则，它会被附加到前一个Hook的`next`属性上。之后，返回分配的Hook。
- en: Obtaining a Hook at the update
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在更新时获取Hook
- en: 'In any other update after the mount, we can access Hooks that *React* created
    at the mount:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在挂载之后的任何其他更新中，我们可以访问*React*在挂载时创建的Hook：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding `updateHook` function, a Hook object is obtained by looking
    for the first `memoizedState` Hook under the fiber. After the first Hook, it is
    obtained by following the `next` property of `prevHook`. *React* also keeps `prevHook`
    up to date as we move along the list. The Hook obtained is returned.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`updateHook`函数中，通过在纤维下查找第一个`memoizedState` Hook来获取一个Hook对象。在第一个Hook之后，它通过跟随`prevHook`的`next`属性来获取。*React*也会在我们沿着列表移动时保持`prevHook`的最新状态。获取到的Hook会被返回。
- en: Using a Hook
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Hook
- en: Now that we have made the Hook persistent to all updates, we can put it to work
    in a function component, similar to the `_getM` or `_getM2` functions we crafted
    in the previous chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使Hook对所有更新持久化，我们可以在函数组件中使用它，类似于我们在上一章中编写的`_getM`或`_getM2`函数。
- en: 'Let''s create a `_useHook` function this time that accepts an `initialState`
    value:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这次创建一个接受`initialState`值的`_useHook`函数：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Based on whether the component is under the mount or not via an `isFiberMounting`
    flag, the preceding `_useHook` function obtains a persistent Hook. If it's at
    the mount, *React* assigns `initialState` to the Hook. For any other update, the
    Hook does not get touched. For all cases, `state` under the Hook is returned.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根据组件是否处于挂载状态，通过`isFiberMounting`标志，前面的`_useHook`函数获取一个持久化的Hook。如果是挂载状态，*React*将`initialState`分配给Hook。对于任何其他更新，Hook不会被修改。在所有情况下，Hook下的`state`都会被返回。
- en: You may wonder how *React* determines the `isFiberMounting` flag; since it's
    wired more deeply with the engine, we put this material in *Appendix B – Current
    and WorkInProgress Scenes* at the end of this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道*React*是如何确定`isFiberMounting`标志的；因为它与引擎的连接更深，所以我们把这个材料放在本章末尾的*附录B – 当前和WorkInProgress场景*中。
- en: So far we have gone through how *React* implements the Hook under the engine.
    We just bit the hard part, now let us take a look how we can use it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了*React*在引擎下如何实现Hook。我们刚刚咬下了硬骨头，现在让我们看看我们如何使用它。
- en: What is a Hook?
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Hook？
- en: 'Now that we have revealed the stripped-down version of the *React* Hook infrastructure
    and crafted a function using it, let''s give it a spin in a function component:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经揭示了简化版的 *React* 钩子基础设施，并使用它创建了一个函数，让我们在一个函数组件中试一试：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding `a` variable is assigned a `0` number upon the mount, and then
    it serves as a state for the rest of the updates.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在挂载时，前一个 `a` 变量被分配一个 `0` 数字，然后它作为后续更新的状态。
- en: '`_useHook` is technically a *React* hook function. Though it''s not an officially
    supported one, and we crafted it here to demonstrate the infrastructure, it has
    everything about being a hook function. Let''s take a close look at it.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`_useHook` 技术上是一个 *React* 钩子函数。虽然它不是官方支持的钩子，但我们在这里创建它来演示基础设施，但它具有钩子函数的所有特性。让我们仔细看看它。'
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To distinguish the educational hook that we crafted from the officially supported
    hook, we prefixed the hook name with `_`, as in `_useHook`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分我们创建的教育性钩子与官方支持的钩子，我们用 `_` 前缀命名钩子，例如 `_useHook`。
- en: We’ll further explain the nature of a hook being a function as well as its calling
    order in the following section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节进一步解释钩子作为函数的本质以及其调用顺序。
- en: A hook is a function
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 钩子是一个函数
- en: A hook is a function that takes input arguments and returns a value, and it
    carries a `use` name prefix by convention.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子是一个接受输入参数并返回值的函数，并且按照惯例带有 `use` 前缀。
- en: 'If we take `useHook` as a generic hook, the following are sample usages of
    hooks with different input arguments:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `useHook` 视为一个通用钩子，以下是用不同输入参数使用钩子的示例用法：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A hook takes zero or any number of input arguments. An input argument can be
    used for the initial condition, as the `initialState` parameter in `_useHook`.
    It's important to know that not all input arguments are used for initialization
    purposes because, as you can see in the implementation, input arguments such as
    `initialState` are sent to each update, but it's up to the update whether the
    input argument needs to be used.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子可以接受零个或任意数量的输入参数。输入参数可以用作初始条件，例如在 `_useHook` 中的 `initialState` 参数。重要的是要知道，并非所有输入参数都用于初始化目的，因为，正如你在实现中可以看到的，例如
    `initialState` 这样的输入参数会被发送到每次更新中，但更新是否需要使用输入参数取决于更新本身。
- en: 'As a function, a hook can return a value if needed. The returned value can
    be designed in any format:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 作为函数，钩子如果需要的话可以返回一个值。返回值可以设计成任何格式：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Not all hooks return a value. If a value is returned, it can be `null`, a number,
    a string, an array, an object, or any JavaScript expression.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有钩子都返回值。如果返回值，它可以是一个 `null`、一个数字、一个字符串、一个数组、一个对象或任何 JavaScript 表达式。
- en: Since one return value can become another's input argument, it's not uncommon
    to see a chain usage of hooks, such as the following.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个返回值可以成为另一个的输入参数，因此看到钩子的链式使用并不罕见，如下所示。
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous code, `i` and `j` are returned from two hooks and then injected
    into another hook to come up with `k` through input arguments. Also, a `text`
    prop is sent to a hook as an input argument. Practically, a hook statement does
    not differ too much from a local assignment statement.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`i` 和 `j` 是从两个钩子返回的，然后通过输入参数注入到另一个钩子中，从而得到 `k`。此外，一个 `text` 属性被作为输入参数发送到钩子。实际上，钩子语句与局部赋值语句并没有太大的区别。
- en: All in all, a hook technically is a function. Don't be intimidated by it just
    because it's a hook. Most of the things you know about functions apply to hooks.
    That being said, a hook is a special function, and it comes with one caveat to
    be aware of – its calling order.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，从技术上讲，钩子是一个函数。不要因为它是钩子就感到害怕。你了解的大部分关于函数的知识都适用于钩子。话虽如此，钩子是一个特殊的函数，它有一个需要注意的注意事项——其调用顺序。
- en: A hook's calling order
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 钩子的调用顺序
- en: 'By now, we know that a hook function can be used many times in a function component
    without causing conflicts because each state points to a separate memory space:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道钩子函数可以在函数组件中使用多次而不会引起冲突，因为每个状态都指向一个独立的内存空间：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Remember when we were crafting our naive version of `_getM2` to support multiple
    states, we had to use a key to distinguish the `a` variable from the `b` variable?
    Now, with the Hook infrastructure, we don't do that anymore. Have you wondered
    how it is possible without a state key?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们创建 `_getM2` 的原始版本以支持多个状态时，我们必须使用一个键来区分 `a` 变量和 `b` 变量吗？现在，有了钩子基础设施，我们不再这样做。你有没有想过没有状态键是如何做到这一点的？
- en: 'At the mount, before a first hook function for `a` is used in the function
    component, there''s no Hook created yet:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在挂载时，在函数组件中使用 `a` 的第一个钩子函数之前，还没有创建任何钩子：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After running the preceding statement, *React* creates one Hook and puts it
    under the fiber. Then, it sees another hook function for `b`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的语句后，*React* 创建了一个钩子并将其放在纤维之下。然后，它看到了另一个针对 `b` 的钩子函数：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After seeing the preceding statement, *React* creates another Hook and puts
    it after the first Hook following the linked list. We are done with the first
    mount update.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到前面的语句后，*React* 创建了另一个钩子并将其放在第一个钩子之后，按照链表顺序。第一次挂载更新已完成。
- en: Now it comes to the second update; when it sees the first hook function for
    `a` again, it looks into the linked Hooks under the fiber and grabs the first
    Hook. Similarly, when it sees the second hook function for `b`, it continues looking
    into the list and finds the second Hook following the first one.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是第二次更新；当它再次看到 `a` 的第一个钩子函数时，它会查看纤维下的链式钩子并获取第一个钩子。同样，当它看到 `b` 的第二个钩子函数时，它会继续查看列表并找到第一个钩子之后的第二个钩子。
- en: Essentially, *React* does not use a key because the order of the list serves
    as a key and the key is called the calling order of the hooks. As long as the
    first hook for `a` calls first and the second hook for `b` calls second, the location
    of the states stored under the list is marked correctly. So we don't have to consciously
    keep track of the key because after we write all the hook statements, the calling
    order should already be determined.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，*React* 不使用键，因为列表的顺序充当键，键被称为钩子的调用顺序。只要 `a` 的第一个钩子首先调用，`b` 的第二个钩子其次调用，列表下存储的状态位置就会被正确标记。因此，我们不必有意识地跟踪键，因为在我们写下所有钩子语句之后，调用顺序应该已经确定。
- en: This design without an explicit key provided by the developer is quite easy
    to use. Except there's one caveat; if we can avoid running into it, this design
    works like a charm practically.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种没有开发者提供显式键的设计相当容易使用。除了有一个需要注意的地方；如果我们能避免遇到它，这种设计在实际中就像魔法一样有效。
- en: So, here's the caveat. This calling order isn't fixed during the code compilation;
    instead, it's determined at the runtime. What's the difference? The difference
    is that the runtime thing can be changed. To give you an example, we can set up
    a case using an `if` statement.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里有一个需要注意的地方。这个调用顺序在代码编译期间并不是固定的；相反，它在运行时确定。有什么区别？区别在于运行时的事情是可以改变的。为了给你一个例子，我们可以使用一个
    `if` 语句来设置一个案例。
- en: Conditional hook issue
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件钩子问题
- en: 'Let''s say we have the following `Title` component with two usages of hooks:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下 `Title` 组件，它使用了两次钩子：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code logic, what we intend to do is store the `'a'` and `'b'`
    chars in the `a` and `b` variables, respectively. Except, when the flag is `false`,
    an empty char `' '` is stored in the `a` variable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码逻辑中，我们的意图是将 `'a'` 和 `'b'` 字符分别存储在 `a` 和 `b` 变量中。但是，当 `flag` 为 `false`
    时，空字符 `' '` 被存储在 `a` 变量中。
- en: 'To confirm whether the code works, let''s make two updates to this component
    while flipping the `flag` prop. Suppose for the first update that the `flag` prop
    is set as `true` and for the second update, it gets changed to `false`. For this
    setup, it generates the following timeline sketch:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认代码是否工作，让我们在翻转 `flag` 属性的同时对这个组件进行两次更新。假设第一次更新时 `flag` 属性设置为 `true`，而第二次更新时它被更改为
    `false`。对于这个设置，它生成了以下时间线草图：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At the first update, both `a` and `b` variables were assigned correctly. But
    when it came to the second update, the `b` variable was set to the `'a'` char.
    This is a bit weird since we never asked to set the `'a'` char to the `b` variable
    in the code. How could that happen?!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次更新时，变量 `a` 和 `b` 都被正确分配。但当进行第二次更新时，变量 `b` 被设置为 `'a'` 字符。这有点奇怪，因为我们从未在代码中要求将
    `'a'` 字符设置为变量 `b`。这是怎么发生的?!
- en: 'How could a `_useHook(''b'')` statement end up returning an `''a''` char, and
    where does the `''a''` char even come from? To answer the questions, we need to
    dig down into the Hooks under the fiber behind the `Title` component:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`_useHook(''b'')` 语句怎么会返回一个 `''a''` 字符，而 `''a''` 字符又是从哪里来的？为了回答这些问题，我们需要深入挖掘
    `Title` 组件背后的纤维下的钩子：'
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding timeline sketch, we printed out the states stored under two
    Hooks. `Hook1` stored the `''a''` char and `Hook2` stored the `''b''` char for
    both updates. Let''s take a close look at the second update; what the compiler
    sees is the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的时间线草图中，我们打印出了两个钩子下存储的状态。`Hook1` 存储了 `'a'` 字符，`Hook2` 存储了 `'b'` 字符，对于两次更新。让我们仔细看看第二次更新；编译器看到的是以下代码：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding arrangement of the code, we hardcode the `flag` prop with
    `false`. Because of that, the first usage of a hook for `a` is omitted, and we
    end up with one hook statement for `b` only. You can see this information in *Figure
    3.3*, where we have both Hooks and what each hook statement reads:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码排列中，我们硬编码了`flag`属性为`false`。正因为如此，`a`钩子的第一次使用被省略了，我们最终只有一个针对`b`的钩子语句。你可以在*图
    3.3*中看到这个信息，其中我们展示了两个钩子以及每个钩子语句读取的内容：
- en: '![Figure 3.3 – Conditional Hook mismatch I'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – 条件钩子不匹配 I'
- en: '](img/Figure_3.03_B17963.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.03_B17963.jpg)'
- en: Figure 3.3 – Conditional Hook mismatch I
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 条件钩子不匹配 I
- en: In the first update, the `a` and `b` variables read from `Hook1` and `Hook2`.
    But in the second update, due to the first hook statement going, the `b` variable
    shifts and reads from `Hook1`. In this update, nothing reads from `Hook2` either.
    Therefore, the `b` variable reads the `'a'` char now.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次更新中，`a`和`b`变量从`Hook1`和`Hook2`读取。但在第二次更新中，由于第一个钩子语句执行，`b`变量发生了偏移并从`Hook1`读取。在这个更新中，也没有任何内容从`Hook2`读取。因此，`b`变量现在读取的是`'a'`字符。
- en: Playground – Conditional hook I
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 条件钩子 I
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/RwLrxbp](https://codepen.io/windmaomao/pen/RwLrxbp).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎尝试这个在线示例：[https://codepen.io/windmaomao/pen/RwLrxbp](https://codepen.io/windmaomao/pen/RwLrxbp)。
- en: 'In this case, we changed the `flag` prop from `T` to `F`; we can also test
    this conditional case by changing the `flag` prop from `F` to `T`. Let''s look
    at the timeline sketch if we do that:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将`flag`属性从`T`更改为`F`；我们也可以通过将`flag`属性从`F`更改为`T`来测试这个条件情况。如果我们这样做，让我们看看时间线草图：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'From the preceding run, we printed out the `a` and `b` variables as well as
    two Hooks states. You can see that the `a` variables read the `''b''` char in
    the second update! We can make the case clearer using *Figure 3.4*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的运行中，我们打印了`a`和`b`变量以及两个钩子状态。你可以看到，在第二次更新中，`a`变量读取了`'b'`字符！我们可以使用*图 3.4*来更清楚地说明这个情况：
- en: '![Figure 3.4 – Conditional Hook mismatch II'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 条件钩子不匹配 II'
- en: '](img/Figure_3.04_B17963.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.04_B17963.jpg)'
- en: Figure 3.4 – Conditional Hook mismatch II
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 条件钩子不匹配 II
- en: What happened to this case is the following. In the first update, we had one
    hook usage for `b` since the flag is `F`. Since this is the mount, the `'b'` char
    was initialized to `Hook1`, and `Hook2` was omitted. When it came to the second
    update, since `Hook1` had been initialized already, the value can't be initialized
    again, thus it continued to hold the `'b'` char. And `Hook2` this time got finally
    initialized with the `'b'` char. This is why both `a` and `b` stored the `'b'`
    char after the second update. Pretty mind-blowing, isn't it? In a way, this case
    is worse than the previous one, of course; both are incorrectly implemented.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个情况发生了以下情况。在第一次更新中，由于标志是`F`，我们为`b`有一个钩子使用。由于这是挂载，`'b'`字符被初始化为`Hook1`，而`Hook2`被省略了。当进行第二次更新时，由于`Hook1`已经被初始化，其值不能再次初始化，因此它继续保留`'b'`字符。而这次`Hook2`最终被初始化为`'b'`字符。这就是为什么在第二次更新后，`a`和`b`都存储了`'b'`字符。这真是太令人震惊了，不是吗？从某种意义上说，这个情况比之前的情况更糟，当然；两者都是错误实现的。
- en: From these two cases, we can conclude that using the `if` statement with the
    hook statement leads to strange behavior. And this is all because the calling
    order of hooks gets changed from update to update, hence the state keys get messed
    up and the states can't be read as intended.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从这两个案例中，我们可以得出结论，使用`if`语句与钩子语句会导致奇怪的行为。而且这完全是因为钩子的调用顺序在更新之间发生了变化，因此状态键被搞混了，状态不能按预期读取。
- en: Playground – Conditional hook II
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 条件钩子 II
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/oNGbEzq](https://codepen.io/windmaomao/pen/oNGbEzq).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎尝试这个在线示例：[https://codepen.io/windmaomao/pen/oNGbEzq](https://codepen.io/windmaomao/pen/oNGbEzq)。
- en: 'In fact, it''s not only `if`; any hook statement involving a condition cannot
    be used. Here''s another example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，不仅仅是`if`；任何涉及条件的钩子语句都不能使用。这里有一个另一个例子：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, we embedded a hook inside a loop iterating an `arr` array.
    Guess how many hook statements we would run into for this case? Not sure? Yes,
    you guessed right – we don't know how many elements the `arr` prop contains; it
    can only be determined at runtime. We will not walk through this case in detail,
    but you can see the code can easily run into a strange issue if the length of
    `arr` changes from 0 to 1, or 1 to 2, and so on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在迭代 `arr` 数组的循环中嵌入了一个钩子。猜猜这个情况下我们会遇到多少个钩子语句？不确定？是的，你猜对了 – 我们不知道 `arr`
    属性包含多少个元素；这只能在运行时确定。我们不会详细说明这个情况，但你可以看到，如果 `arr` 的长度从 0 变为 1，或从 1 变为 2，等等，代码很容易遇到奇怪的问题。
- en: '*React* gives their recommendation in their documentation online: *"Don''t
    call hooks inside loops, conditions, or nested functions. Instead, always use
    hooks at the top level of your React function, before any early returns."* Now
    you have a deeper understanding of why they said that.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*React* 在其在线文档中给出了他们的建议："不要在循环、条件或嵌套函数中调用钩子。相反，始终在 React 函数的最顶层使用钩子，在所有早期返回之前。"
    现在你对为什么他们会这么说有了更深的理解。'
- en: '*React* is fully aware of the severity of this issue because it could jeopardize
    the usage of a hook. Therefore, at the code compilation, the compiler actually
    alerts the developer when it spots the usage of conditional hook usage. Moreover,
    if it ever misses catching the case, at runtime, *React* monitors the hook list
    to find out whether there''s any messing up of hook orders upon a new update.
    If it finds one, you see a warning, as shown in *Figure 3.5*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*React* 完全清楚这个问题的严重性，因为它可能会危及钩子的使用。因此，在代码编译时，编译器实际上会在发现条件钩子使用时提醒开发者。此外，如果在编译时错过了捕捉到的情况，在运行时，*React*
    会监控钩子列表，以确定在新的更新中是否有钩子顺序的混乱。如果它发现了一个，你将看到一个警告，如图 *3.5* 所示：'
- en: '![Figure 3.5 – React runtime warning for a conditional hook'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – React 条件钩子运行时警告'
- en: '](img/Figure_3.05_B17963.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.05_B17963.jpg)'
- en: Figure 3.5 – React runtime warning for a conditional hook
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – React 条件钩子运行时警告
- en: Avoiding conditional hooks
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用条件钩子
- en: So now we know we shouldn't have written any conditional hook statements, but
    how can we avoid it? Or, put another way, if we must implement some conditional
    logic involving hooks, what's the right way to do it?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们不应该编写任何条件钩子语句，但我们如何避免它？或者，换一种说法，如果我们必须实现涉及钩子的某些条件逻辑，正确的做法是什么？
- en: The solution to this problem isn't difficult. We can still write conditional
    statements, just not conditional hook statements. As long as we have a fixed number
    of hooks and a consistent calling order, we can write the hook statement however
    we want.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案并不困难。我们仍然可以写条件语句，只是不能写条件钩子语句。只要我们有固定数量的钩子和一致的调用顺序，我们就可以随意编写钩子语句。
- en: 'Let''s try to fix our examples, starting with setting `flag` from `T` to `F`
    first. Instead of declaring `_useHook` conditionally, we can declare two of them
    beforehand:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试修复我们的示例，首先从将 `flag` 从 `T` 设置为 `F` 开始。我们可以在之前声明两个 `_useHook` 而不是有条件地声明：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, we use an auxiliary `_a` variable to hold an `'a'` char.
    The `b` variable holds a `'b'` char as before. This way, no matter what, both
    hooks are maintained with a fixed calling order in all updates.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用一个辅助的 `_a` 变量来持有 `'a'` 字符。`b` 变量仍然持有 `'b'` 字符。这样，无论什么情况，所有钩子都在所有更新中保持固定的调用顺序。
- en: 'Now, with that, we can relocate the conditional logic part for `a` after the
    hook statements. We can verify whether this works by looking at the generated
    timeline sketch:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这个，我们可以将 `a` 的条件逻辑部分重新定位到钩子语句之后。我们可以通过查看生成的时间线草图来验证这是否有效：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly, we can generate the timeline for changing `flag` from `F` to `T`
    :'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以生成将 `flag` 从 `F` 更改为 `T` 的时间线：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Both cases turn out to be correctly implemented now. The `a` variable can hold
    the `'a'` char or an empty `' '` based on `flag`, and the `b` variable holds the
    `'b'` char always.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在两种情况都正确实现了。`a` 变量可以根据 `flag` 的值持有 `'a'` 字符或空 `' '`，而 `b` 变量始终持有 `'b'` 字符。
- en: Playground – Conditional hook I
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 条件钩子 I
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/KKXVQWV](https://codepen.io/windmaomao/pen/KKXVQWV).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自由地在这个在线示例[https://codepen.io/windmaomao/pen/KKXVQWV](https://codepen.io/windmaomao/pen/KKXVQWV)中玩耍。
- en: Playground – Conditional hook II
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 条件钩子 II
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/MWEKQQJ](https://codepen.io/windmaomao/pen/MWEKQQJ).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自由地在这个在线示例[https://codepen.io/windmaomao/pen/MWEKQQJ](https://codepen.io/windmaomao/pen/MWEKQQJ)中玩耍。
- en: 'This writing of moving hook statements to the front of the function is recommended
    by *React*, and it can be applied to the loop case as well:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将钩子语句移动到函数前面的写法是 *React* 推荐的，并且也可以应用于循环情况：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we don't know the length of `arr`, so it's better not
    to loop through each hook statement inside the loop. Instead, we can store the
    entire `arr` to a state and then iterate this array afterward. This way, we eliminate
    the possibility of having a variable number of hook statements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们不知道 `arr` 的长度，所以最好不要在循环中遍历每个钩子语句。相反，我们可以将整个 `arr` 存储到状态中，然后迭代这个数组。这样，我们消除了有变量数量的钩子语句的可能性。
- en: Luckily, the previously mentioned caveat is the only issue *React* hooks have,
    and if we run into a conditional statement, we can apply the "right" way by putting
    the hook statement on the front of the function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，之前提到的注意事项是 *React* 钩子唯一的缺陷，如果我们遇到条件语句，我们可以通过将钩子语句放在函数的前面来应用“正确”的方式。
- en: In short, a *React* hook is a special function that allows persistent states
    for a function component. Out of the box, *React* provides quite a few hooks based
    on this infrastructure. Starting in the next chapter, we will get to know some
    of the common ones in detail, including `useState`, `useEffect`, `useMemo`, `useContext`,
    and `useRef`. And in [*Chapter 9*](B17963_09_Epub.xhtml#_idTextAnchor314), *Use
    Custom Hooks to Reuse Logic*, we will get toknow how to create our own custom
    hooks to meet our specific needs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，*React* 钩子是一个特殊的函数，它允许函数组件拥有持久的状态。开箱即用，*React* 提供了相当多的基于这个基础设施的钩子。从下一章开始，我们将详细了解其中的一些常见钩子，包括
    `useState`、`useEffect`、`useMemo`、`useContext` 和 `useRef`。在 [*第 9 章*](B17963_09_Epub.xhtml#_idTextAnchor314)
    “使用自定义钩子重用逻辑”中，我们将了解如何创建我们自己的自定义钩子来满足我们的特定需求。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned what makes a good state solution, and got
    to know how *React* builds the Hook to provide this solution. You also learned
    what a hook is and its calling order, as well as how to avoid running into a conditional
    hook issuein real applications.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了什么构成了一个好的状态解决方案，并了解了 *React* 如何构建 Hook 来提供这个解决方案。你还学习了钩子是什么以及它的调用顺序，以及如何在实际应用中避免遇到条件钩子问题。
- en: In the next chapter, we will get into our first hook in the *React* family,
    with which *React* allows us to define a state to drive a UI display.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解 *React* 家族的第一个钩子，通过它 *React* 允许我们定义一个状态来驱动 UI 显示。
- en: Questions and answers
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和答案
- en: 'Here are some questions and answers to refresh your knowledge:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些问题和答案来刷新你的知识：
- en: What is a *React* hook?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 *React* 钩子？
- en: A *React* hook is a special function that allows us to have persistent states
    for a function component. The calling order of hooks is used as an internal key
    of the states, thus, when we use hooks, we don't need to specify a key. We can
    have as many hooks as we want under one function component, and each hook can
    be used for a different purpose.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*React* 钩子是一个特殊的函数，它允许我们在函数组件中拥有持久的状态。钩子的调用顺序被用作状态的内部键，因此，当我们使用钩子时，我们不需要指定一个键。我们可以在一个函数组件下拥有尽可能多的钩子，每个钩子可以用于不同的目的。'
- en: How can we avoid conditional hooks?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何避免条件钩子？
- en: Each hook with a specific calling order gets stored under the hook list. *React*
    doesn't allow the change of this calling order at runtime, thus we should avoid
    it when using hooks inside a condition, a loop, or any structure that varies its
    calling order. Instead, we can move all hook statements to the front section of
    the function to pre-bake their calling orders while leaving the conditional logic
    afterward before the return statement.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个具有特定调用顺序的钩子都会存储在钩子列表中。*React* 不允许在运行时更改这个调用顺序，因此我们应该避免在条件、循环或任何改变调用顺序的结构中使用钩子。相反，我们可以将所有的钩子语句移动到函数的前面部分，预先确定它们的调用顺序，然后在返回语句之前留下条件逻辑。
- en: Appendix
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: Appendix A – React Fiber
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录 A – React Fiber
- en: During the user session with a website, a series of actions is generated. We'd
    expect to have these actions dispatched and have changes applied back to the **Document
    Object Model** (**DOM**). This cycle is what makes it a typical web experience.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户与网站的会话期间，会生成一系列操作。我们期望这些操作被分发，并将更改应用到 **文档对象模型** (**DOM**) 上。这个周期使得它成为一个典型的网络体验。
- en: '![Figure 3.6 – React Fiber with Render and Commit phrases'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – 带有 Render 和 Commit 语句的 React Fiber](img/Figure_3.06_B17963.jpg)'
- en: '](img/Figure_3.06_B17963.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: Figure 3.6 – React Fiber with Render and Commit phrases
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 带有 Render 和 Commit 语句的 React Fiber
- en: What *React* does for us is to allow the dispatched action to update the changes
    to be reflected on the screen. *React* splits each update into two major phrases,
    the **Render** and the **Commit**, illustrated in the preceding figure. What a
    render does is go through all elements one by one and collect all the changes,
    whereas a commit applies the changes to the UI in one shot.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*React* 为我们做的事情是允许分发的动作更新屏幕上的更改。*React* 将每次更新分为两个主要阶段，**渲染** 和 **提交**，如图所示。渲染所做的就是逐个遍历所有元素并收集所有更改，而提交则一次性将更改应用到
    UI 上。'
- en: This engine has a codename, *Fiber*. To facilitate all this, *React* creates
    an internal object called a fiber to represent each element. As we have introduced,
    the element can be a classical element, such as a DOM element, or an artificial
    one, such as a function component. The benefits of having a layer between the
    physical DOM and *React* element are twofold.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这台引擎有一个代号，*Fiber*。为了方便所有这些操作，*React* 创建了一个内部对象，称为纤维，来表示每个元素。正如我们之前所介绍的，元素可以是经典元素，例如
    DOM 元素，也可以是人工元素，例如函数组件。在物理 DOM 和 *React* 元素之间有一个层的好处是双重的。
- en: A function component (or a class component) is easier for developers to organize
    their UI as well as their logic into a functional unit. Having a fiber wrapping
    a unit like that can offer some generic element behavior as well as add special
    handling to a specific element. For instance, we have introduced `updateFunctionComponent`
    for updating a function component, but for other elements, there are different
    update functions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组件（或类组件）更容易让开发者将 UI 以及逻辑组织成一个功能单元。有一个纤维包裹这样的单元可以提供一些通用元素行为，并为特定元素添加特殊处理。例如，我们介绍了
    `updateFunctionComponent` 用于更新函数组件，但对于其他元素，有不同的更新函数。
- en: On the other hand, adding an extra layer to the UI engine allows optimization.
    In fact, React Fiber does not update to the screen blindly. In the first update,
    as in the mount, each fiber is created and all DOM elements get created from scratch.
    This update should be very close to the classical update.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在 UI 引擎中添加一个额外的层允许优化。实际上，React Fiber 并不会盲目地更新到屏幕上。在第一次更新，就像挂载一样，每个纤维都会被创建，所有
    DOM 元素都会从头开始创建。这次更新应该非常接近经典的更新。
- en: However, everything else differs afterward. For a new update, the assumption
    is that only a small part of the screen needs adjusting. So, before *React* updates
    the screen, it goes through all fibers stored in the previous update and compares
    them with the new rendered elements. This comparison is referred to as reconciliation,
    which is to compare the new elements with previous DOM elements to come up with
    the new DOM changes that need to be applied in this update. *React* makes this
    reconciliation very efficient so that only necessary changes are applied to the
    screen.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，之后的一切都不同了。对于新的更新，假设只有屏幕的一小部分需要调整。因此，在 *React* 更新屏幕之前，它会遍历之前更新中存储的所有纤维，并将它们与新的渲染元素进行比较。这种比较被称为协调，即比较新元素与之前的
    DOM 元素，以确定在本次更新中需要应用的新 DOM 变更。*React* 使这种协调非常高效，以便只将必要的更改应用到屏幕上。
- en: The optimization is not only limited to reconciliation. To make sure things
    can be done efficiently, a fiber also serves as a unit of work. During each update,
    all fibers are sent to a pipeline where each fiber gets worked on one by one.
    There are certain advantages of doing that. The update work thus isn't treated
    as one or nothing anymore. The engine can finish 9 out of 10 units without hurting
    the integrity of the update job because it can now pause when it's out of resources
    and come back to finish the last unit once it gets enough computational time.
    One of the direct benefits is gaining a quick response to more urgent work in
    the browser.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 优化不仅限于协调。为了确保事情可以高效完成，纤维也充当了工作单元。在每次更新期间，所有纤维都会被发送到一个管道中，每个纤维依次被处理。这样做有一些优势。因此，更新工作不再被视为非此即彼。引擎可以在资源不足时暂停，一旦获得足够的计算时间，就会回来完成最后一个单元。其中一个直接的好处是能够快速响应对浏览器中更紧急的工作。
- en: Appendix B – Current and WorkInProgress Scenes
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录 B – 当前和工作进行中场景
- en: When we said that *React* internally creates a fiber for each element, we lied.
    Actually, for each element, *React* creates two fibers, and the name for these
    two fibers are `current` and `workInProgress`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说 *React* 在内部为每个元素创建一个纤维时，我们是在撒谎。实际上，对于每个元素，*React* 会创建两个纤维，这两个纤维的名字分别是 `current`
    和 `workInProgress`。
- en: 'Imagine the user screen is like a stage with a curtain. The stage facing the
    audience is a current scene, while there''s another work-in-progress scene behind
    the curtain where it can prepare what''s next to show to the audience. While the
    audience enjoys watching the current scene, the work-in-progress scene is getting
    prepared at the same time. Only when the time is right is there a wheeler that
    rotates the current scene behind and pushes the work-in-progress scene to face
    the audience, as shown in *Figure 3.7*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下用户屏幕就像一个有幕布的舞台。面向观众的舞台是当前场景，而幕布后面还有一个正在准备下一个要展示给观众的内容的工作中场景。当观众享受观看当前场景时，工作中场景也在同时准备。只有当时机成熟时，才会有一个轮子旋转当前场景背后的幕布，并将工作中场景推向观众，如图*图3.7*所示：
- en: '![Figure 3.7 – React two scenes with current and workInProgress'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 – React的当前和workInProgress两个场景'
- en: '](img/Figure_3.07_B17963.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.07_B17963.jpg]'
- en: Figure 3.7 – React two scenes with current and workInProgress
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – React的当前和workInProgress两个场景
- en: This is a well-known mechanism behind any show business, including a computer
    screen. *React* is no exception. In order to facilitate the smoothness of a screen
    transition before/after the commit, it uses two scenes in memory, named `current`
    and `workInProgress`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种在所有商业表演背后的常见机制，包括计算机屏幕。*React*也不例外。为了在提交前/后的屏幕过渡中提供平滑性，它使用内存中的两个场景，分别命名为`current`和`workInProgress`。
- en: Initially, both scenes are empty, since the show hasn't started yet. We work
    on the `workInProgress` scene while `current` is empty; this step is called the
    `workInProgress` is done, the stage rotates so that `workInProgress` becomes `current`.
    In programming, it's just a pointer assignment.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，这两个场景都是空的，因为表演还没有开始。我们在`workInProgress`场景上工作，而`current`是空的；这一步骤被称为`workInProgress`完成，阶段旋转，使得`workInProgress`成为`current`。在编程中，这只是一种指针赋值。
- en: Upon any future action, the `workInProgress` scene starts to be prepared again.
    This time, `workInProgress` doesn't need to be created from scratch since it can
    clone unchanged things from `current`, and this step is called the `workInProgress`
    is done, the stage rotates so that `workInProgress` becomes the new `current`
    scene.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何未来的操作之后，`workInProgress`场景开始再次准备。这次，由于可以从`current`中克隆未更改的内容，因此不需要从头创建`workInProgress`，这一步骤被称为`workInProgress`完成，阶段旋转，使得`workInProgress`成为新的`current`场景。
- en: 'During either the mount or the update, we pick `workInProgress` to work for
    the future scene while leaving `current` as the finished work from last time,
    except that during the mount, there''s nothing in `current`. So, to tell whether
    any component is under the mount or the update, we can check whether `current`
    is empty:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在挂载（mount）或更新（update）过程中，我们选择`workInProgress`来处理未来的场景，同时将`current`保留为上一次完成的作业，除了在挂载期间，`current`中没有任何内容。因此，为了判断任何组件是否处于挂载或更新状态，我们可以检查`current`是否为空：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Unless you work on the engine, you wouldn't be given two scenes at the same
    time since the developer outside of the core works on `workInProgress` while the
    user watches `current`. To all of them, there's only one scene.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你在引擎上工作，否则你不会同时获得两个场景，因为核心外的开发者工作在`workInProgress`上，而用户观看`current`。对他们所有人来说，只有一个场景。
