- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Building Forms Like a Pro
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 像专业人士一样构建表单
- en: '**Forms** are at the core of many frontend applications. They allow you to
    collect user input to save and act upon data provided by your application users.
    Building forms is one of the aspects where Angular excels. Angular provides two
    different approaches for building forms, both with tools to validate individual
    form fields as well as the validity of the entire form.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**表单**是许多前端应用的核心。它们允许您收集用户输入以保存并处理您的应用用户提供的数据。构建表单是Angular擅长的方面之一。Angular提供了两种不同的构建表单的方法，这两种方法都提供了工具来验证单个表单字段以及整个表单的有效性。'
- en: In this chapter, you will learn how to create Angular **template-driven** and
    **reactive forms**, synchronize your form fields with your application state,
    validate forms and individual form fields, and learn about advanced concepts such
    as dynamic form creation. By the end of this chapter, you will be able to create
    forms like a pro!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何创建Angular的**模板驱动**和**响应式**表单，同步您的表单字段与应用程序状态，验证表单和单个表单字段，并了解动态表单创建等高级概念。到本章结束时，您将能够像专业人士一样创建表单！
- en: 'This chapter will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Understanding the different types of forms in Angular
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Angular中不同类型的表单
- en: Building template-driven forms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建模板驱动表单
- en: Building reactive forms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建响应式表单
- en: Creating forms dynamically
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态创建表单
- en: Understanding the different types of forms in Angular
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Angular中不同类型的表单
- en: 'Angular provides two different types of forms: template-driven forms and reactive
    forms. This section will discuss the differences between template-driven and reactive
    forms and help you assess what approach best fits your situation.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了两种不同类型的表单：模板驱动表单和响应式表单。本节将讨论模板驱动表单和响应式表单之间的区别，并帮助您评估哪种方法最适合您的需求。
- en: Let’s start by explaining the key characteristics of both approaches for building
    forms.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解释一下构建表单的两种方法的关键特点。
- en: Characteristics of template-driven forms
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板驱动表单的特点
- en: Template-driven forms are a way to build forms where the HTML template plays
    a central role. Template-driven forms implicitly define form controls and validation
    rules in the HTML template using directives. This means the form controls and
    validation rules are created and managed by the directives you place on the HTML
    elements instead of manually creating the form controls and validations inside
    your TypeScript files and directly communicating with the form API yourself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模板驱动表单是一种构建表单的方式，其中HTML模板扮演着核心角色。模板驱动表单在HTML模板中隐式定义表单控件和验证规则，使用指令。这意味着表单控件和验证规则是由您放置在HTML元素上的指令创建和管理的，而不是在TypeScript文件中手动创建表单控件和验证，并直接与表单API进行通信。
- en: The template-driven approach relies on two-way data binding using the `ngModel`
    directive to synchronize changes in the data model for both user input and programmatic
    changes. When you add the `ngModel` directive to an HTML element, the directive
    creates and manages a `FormControl` instance for you. These `FormControl` classes
    that are created by the `ngModel` directive are used to track and validate the
    status of individual form fields inside your form.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模板驱动的方法依赖于使用`ngModel`指令进行双向数据绑定，以同步用户输入和程序性更改的数据模型中的变化。当您将`ngModel`指令添加到HTML元素时，该指令会为您创建并管理一个`FormControl`实例。这些由`ngModel`指令创建的`FormControl`类用于跟踪和验证表单中单个字段的状态。
- en: When using template-driven forms, the form data is mutable, meaning you don’t
    update the form values using the form API, but you directly change values that
    are used within the `FormControl` instances.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用模板驱动表单时，表单数据是可变的，这意味着您不是使用表单API来更新表单值，而是直接更改在`FormControl`实例中使用的值。
- en: Important note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It’s also important to note that the data flow for template-driven forms is
    asynchronous and updates through events and subscriptions. While this asynchronous
    behavior is managed for you, it’s good to know because it can affect tests and
    sometimes lead to unexpected behavior if you aren’t aware that the data flow is
    asynchronous.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，模板驱动表单的数据流是异步的，通过事件和订阅进行更新。虽然这种异步行为由系统管理，但了解这一点很重要，因为它可能会影响测试，并且如果您不知道数据流是异步的，有时会导致意外的行为。
- en: Template-driven forms are easy and quick to build and work very well combined
    with Signals (we will learn more about Signals in [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129)),
    which can reduce the number of times change detection is triggered, improving
    performance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 模板驱动的表单易于构建且快速，与信号（我们将在[*第7章*](B21625_07.xhtml#_idTextAnchor129)中了解更多关于信号的内容）结合使用效果很好，可以减少触发变更检测的次数，从而提高性能。
- en: However, the data model and form controls of template-driven forms are complex
    to reuse and test; also, when building large forms, your HTML template becomes
    bloated. When creating forms that need rigorous testing, reusable form models
    and controls, or forms that need a dynamic way of being constructed, reactive
    forms might be the better fit.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，模板驱动的表单的数据模型和表单控件复用和测试起来比较复杂；此外，在构建大型表单时，你的HTML模板可能会变得臃肿。当创建需要严格测试、可重用表单模型和控件或需要动态构建方式的表单时，响应式表单可能更为合适。
- en: Characteristics of reactive forms
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应式表单的特点
- en: Reactive forms provide a flexible, model-driven approach to creating forms.
    Reactive forms facilitate more programmatic control compared to template-driven
    forms. When using the reactive approach, you explicitly define the form model
    by creating `FormGroup`, `FormControl`, and `FormArray` instances in your TypeScript
    files. The explicit nature of reactive forms allows for more complex logic, easy
    testing, and better reusability of form controls and models. In reactive forms,
    validation rules are also explicitly defined using `Validator` classes or custom
    validators, allowing for more complex validations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式表单提供了一种灵活的、以模型驱动的创建表单的方法。与模板驱动的表单相比，响应式表单提供了更多的程序化控制。在使用响应式方法时，你通过在TypeScript文件中创建`FormGroup`、`FormControl`和`FormArray`实例来显式定义表单模型。响应式表单的显式特性允许实现更复杂的逻辑、易于测试以及更好的表单控件和模型的重用性。在响应式表单中，验证规则也通过`Validator`类或自定义验证器显式定义，从而允许更复杂的验证。
- en: Reactive forms provide fine-grained control over the form’s state, allowing
    you to set, get, and manipulate values programmatically. Once a form and its form
    controls have been created, you cannot directly modify the values. This makes
    reactive forms immutable. Immutable forms provide a more reliable data model,
    which, in turn, leads to fewer bugs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式表单提供了对表单状态的精细控制，允许你通过程序方式设置、获取和操作值。一旦创建了一个表单及其表单控件，就不能直接修改其值。这使得响应式表单不可变。不可变的表单提供了一个更可靠的数据模型，这反过来又导致错误更少。
- en: Because you directly define the form models in your TypeScript files using the
    form API, the form models that are created for reactive forms can easily be reused
    and tested. Reactive forms are straightforward when it comes to writing tests
    because you can directly use the form API in your tests, just like you do in your
    component classes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你直接使用表单API在你的TypeScript文件中定义表单模型，因此为响应式表单创建的表单模型可以很容易地复用和测试。在编写测试时，响应式表单非常简单，因为你可以直接在测试中使用表单API，就像你在组件类中做的那样。
- en: Reactive forms have a synchronous data flow between the view (by *view*, we
    mean the HTML template that’s displayed in the browser) and the data model. As
    a result, Angular knows precisely when to run change detection on reactive forms,
    improving performance.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式表单在视图（我们所说的视图是指浏览器中显示的HTML模板）和数据模型之间具有同步的数据流。因此，Angular可以精确地知道何时在响应式表单上运行变更检测，从而提高性能。
- en: While the reactive approach requires more initial setup compared to template-driven
    forms, reactive forms are better suited for large, complex forms where additional
    control, testing, and reusability of form controls and models are crucial.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与模板驱动的表单相比，响应式表单虽然需要更多的初始设置，但在处理大型、复杂的表单时更为合适，因为在这种情况下，额外的控制、测试以及表单控件和模型的可重用性至关重要。
- en: Key differences between template-driven forms and reactive forms
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板驱动的表单和响应式表单之间的主要差异
- en: 'The following table outlines the differences between template-driven and reactive
    forms:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下表概述了模板驱动的表单和响应式表单之间的差异：
- en: '|  | **Template-Driven Forms** | **Reactive Forms** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|  | **模板驱动的表单** | **响应式表单** |'
- en: '| Form, model, and validation creation | Implicitly using directives in the
    HTML template | Explicitly using classes in TypeScript files |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 表单、模型和验证创建 | 隐式使用HTML模板中的指令 | 显式使用TypeScript文件中的类 |'
- en: '| Setting up and creating the form | Easy and simple to set up | Needs more
    initial setup and can feel more complex |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 设置和创建表单 | 易于设置和简单 | 需要更多的初始设置，可能感觉更复杂 |'
- en: '| Data model | Unstructured and mutable | Structured and immutable |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 数据模型 | 非结构化和可变 | 结构化和不可变 |'
- en: '| Data flow | Asynchronous | Synchronous |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 数据流 | 异步 | 同步 |'
- en: '| Compatible with Signals | Good | Not good |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 与信号兼容 | 好 | 不好 |'
- en: '| Testability | Difficult to unit test | Easy to test using the form API |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 测试性 | 单元测试困难 | 使用表单 API 容易测试 |'
- en: '| Reusability and dynamic creation of the form | Harder to reuse or build dynamically
    | Easy to reuse and build dynamically |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 表单的可重用性和动态创建 | 更难重用或动态构建 | 容易重用和动态构建 |'
- en: 'Table 4.1: Key differences between template-driven forms and reactive forms'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1：模板驱动表单和响应式表单之间的关键区别
- en: Now that you know the key characteristics of Angular template-driven and reactive
    forms, let’s do a deep dive and learn how you can create both types of forms.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 Angular 模板驱动和响应式表单的关键特性，让我们深入探讨并学习如何创建这两种类型的表单。
- en: Building template-driven forms
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建模板驱动表单
- en: In this section, we will build a template-driven form. You will learn how to
    bind data to input fields, group form fields, and perform built-in and custom
    validation rules in template-driven forms. You will also learn how template-driven
    forms work behind the scenes to get a better understanding of template-driven
    forms.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个模板驱动表单。你将学习如何将数据绑定到输入字段，分组表单字段，并在模板驱动表单中执行内置和自定义验证规则。你还将了解模板驱动表单在幕后是如何工作的，以更好地理解模板驱动表单。
- en: By the end of this section, you’ll be able to build robust template-driven forms
    and create a template-driven form to add expenses to our demo application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，你将能够构建健壮的模板驱动表单，并为我们的演示应用程序创建一个模板驱动表单来添加费用。
- en: Creating a forms library with a form component
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建带有表单组件的表单库
- en: Before we start creating the form, we need a new library. We will generate the
    new library using the custom Nx generator we made in [*Chapter 1*](B21625_01.xhtml#_idTextAnchor014).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建表单之前，我们需要一个新的库。我们将使用我们在[*第一章*](B21625_01.xhtml#_idTextAnchor014)中制作的自定义
    Nx 生成器来生成新的库。
- en: You can debate about how to separate the forms library. You can either create
    one library that holds all the forms of a specific domain, you can create a forms
    library for each application in a particular domain, or you can create a new library
    for each form.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以就如何分离表单库进行辩论。你可以创建一个包含特定领域所有表单的库，为特定领域的每个应用程序创建一个表单库，或者为每个表单创建一个新的库。
- en: Using a single library for each form is the best way to use the Nx caching and
    incremental build systems, but it also has some extra overhead in terms of development
    and maintenance. If your organization has a lot of forms that are reused among
    multiple applications, splitting them up into individual libraries might be worth
    the extra setup as it will speed up your builds and pipelines.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用每个表单的单个库是使用 Nx 缓存和增量构建系统的最佳方式，但它也在开发和维护方面带来了一些额外的开销。如果你的组织有很多在多个应用程序之间重用的表单，将它们拆分到单独的库中可能值得额外的设置，因为它将加快你的构建和管道。
- en: 'For our example, I will create a forms library dedicated to the *expenses-registration*
    *application* so that the library will contain all the forms for this specific
    application:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我将创建一个专门用于 *expenses-registration* *应用程序* 的表单库，以便该库将包含此特定应用程序的所有表单：
- en: Run the custom Nx generator to create the library. Name it `expenses-registration-forms`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行自定义 Nx 生成器以创建库。将其命名为`expenses-registration-forms`。
- en: Select **finance** for the domain and **ui** for the type. Then, click **Generate**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择域为**finance**，类型为**ui**。然后，点击**生成**。
- en: Once the library has been generated, restart VS Code so that the Nx schematics
    are updated with your new library.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦生成了库，重新启动 VS Code，以便 Nx 规范与你的新库更新。
- en: We will create a component for our template-driven form using the Nx generator.
    Name the component `add-expense`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 Nx 生成器为我们的模板驱动表单创建一个组件。将组件命名为`add-expense`。
- en: Select the newly created library for the project, check the **standalone** checkbox,
    click **Show all options**, and select **OnPush** for the **changeDetection**
    option.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择为项目创建的新库，勾选**独立**复选框，点击**显示所有选项**，并为**changeDetection**选项选择**OnPush**。
- en: Click **Generate** in the top-right corner.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角点击**生成**。
- en: Once the component has been generated, export it into the `index.ts` file of
    the library. I like to end the component selector for forms with `form`, so I
    will rename the component selector `bt-libs-ui-add-expense-form`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦生成了组件，将其导出到库的`index.ts`文件中。我喜欢以`form`结束表单选择器，所以我将组件选择器重命名为`bt-libs-ui-add-expense-form`。
- en: Now that we’ve created the library and component, we can start creating the
    template-driven form.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了库和组件，我们可以开始创建模板驱动的表单。
- en: Creating a template-driven form
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模板驱动的表单
- en: 'We will start by creating a simple HTML form and slowly convert it into an
    Angular template-driven form. Add this to your `add-expense.component.html` file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个简单的HTML表单，然后逐步将其转换为Angular模板驱动的表单。将以下内容添加到您的`add-expense.component.html`文件中：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can replace the **dots** with any additional form fields you want. In this
    example, I will have four fields: **description**, **amount excluding VAT**, **VAT
    percentage**, and **date**.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用任何您想要的额外表单字段替换**点**。在这个例子中，我将拥有四个字段：**描述**、**不含增值税的金额**、**增值税百分比**和**日期**。
- en: 'You can find the complete form and styling in this book’s GitHub repository:
    [https://github.com/PacktPublishing/Effective-Angular/tree/feature/chapter-four/building-forms-like-a-pro](https://github.com/PacktPublishing/Effective-Angular/tree/feature/chapter-four/building-forms-like-a-pro).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub仓库中找到完整的表单和样式：[https://github.com/PacktPublishing/Effective-Angular/tree/feature/chapter-four/building-forms-like-a-pro](https://github.com/PacktPublishing/Effective-Angular/tree/feature/chapter-four/building-forms-like-a-pro)。
- en: Import the `AddExpenseForm` class into `expenses-overview-page.component.ts`
    and add the component selector in the corresponding HTML file to display our HTML
    form. When you click the submit button, you’ll notice that the page is reloaded;
    this is the default native behavior when submitting forms. Yet, when building
    modern applications using frameworks such as Angular, we expect a better user
    experience where we process form submissions without page reloads, just like when
    we route to pages without reloading the page.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将`AddExpenseForm`类导入到`expenses-overview-page.component.ts`中，并在相应的HTML文件中添加组件选择器以显示我们的HTML表单。当您点击提交按钮时，您会注意到页面被重新加载；这是提交表单时的默认原生行为。然而，当使用Angular等框架构建现代应用程序时，我们期望更好的用户体验，即在不重新加载页面的情况下处理表单提交，就像我们路由到页面而不重新加载页面一样。
- en: 'We’ll start converting our native HTML form into an Angular template-driven
    form by importing `FormsModule`. This `FormsModule` contains all the directives
    we need to build our template-driven forms. If you’re building with `NgModules`,
    you must import `FormsModule` in the corresponding `NgModule`. We’re using standalone
    components, so we’ll import `FormsModule` into components where we build a form.
    Add `FormsModule` inside the `imports` array of the component decorator of our
    newly created `add-expense` component:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过导入`FormsModule`开始将我们的原生HTML表单转换为Angular模板驱动的表单。这个`FormsModule`包含了我们构建模板驱动的表单所需的所有指令。如果您正在使用`NgModules`构建，您必须在相应的`NgModule`中导入`FormsModule`。我们正在使用独立组件，因此我们将`FormsModule`导入到构建表单的组件中。将`FormsModule`添加到我们新创建的`add-expense`组件的组件装饰器的`imports`数组中：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<form #addExpenseForm="ngForm">………</form>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '<form #addExpenseForm="ngForm">………</form>'
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: export interface AddExpense {
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: export interface AddExpense {
- en: 'description: string;'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 'description: string;'
- en: 'amountExclVat: number | null;'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'amountExclVat: number | null;'
- en: 'vatPercentage: number | null;'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'vatPercentage: number | null;'
- en: 'date: Date | null;'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: Date | null;'
- en: '}'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '@Input() expenseToAdd: AddExpense = { description: '''', amountExclVat: null,
    vatPercentage: null, date: null }'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '@Input() expenseToAdd: AddExpense = { description: '''', amountExclVat: null,
    vatPercentage: null, date: null }'
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <input ngModel directive, just like we did with two-way data binding for inputs
    and outputs in *Chapter 2*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <input ngModel指令，就像我们在*第2章*中为输入和输出进行双向数据绑定时所做的那样。
- en: 'Just like using two-way data binding for input values, you can also split this
    `ngModel` into a separate input and output, like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用双向数据绑定来绑定输入值一样，您也可以将这个`ngModel`拆分为单独的输入和输出，如下所示：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Important note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Using the input and output separately can be useful when you’re working with
    Signals or when you want to perform additional logic before binding the input
    value to the data model.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用输入和输出分离可以在处理信号或在进行数据模型绑定之前执行额外逻辑时非常有用。
- en: 'When you create your input fields, adding the `name` attribute to the field
    is important as this provides a unique key for the `ngForm` instance to track
    the form field. You will get an error in your browser console if you don’t add
    the `name` attribute. Now, go ahead and add the `ngModel` directive and `name`
    attribute for all the fields in your form. After adding all the `ngModel` directives
    and `name` attributes, you can confirm that two-way data binding works by temporarily
    adding the following code to your HTML template:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建输入字段时，向字段添加 `name` 属性很重要，因为这为 `ngForm` 实例提供了一个唯一的键来跟踪表单字段。如果您没有添加 `name`
    属性，您的浏览器控制台将显示错误。现在，继续添加 `ngModel` 指令和 `name` 属性到您表单中的所有字段。在添加所有 `ngModel` 指令和
    `name` 属性后，您可以通过临时将以下代码添加到您的 HTML 模板中来确认双向数据绑定是否工作：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After adding the preceding code to your HTML template, the `expenseToAdd` object
    is displayed as JSON on your screen. When you start to type in the form inputs,
    you can see the properties of the `expenseToAdd` object being updated. Vice versa,
    when you assign values to the properties of `expenseToAdd` in your component class,
    the form is also updated, and just like that, you’ve created a form with two-way
    data binding.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在将前面的代码添加到您的 HTML 模板后，`expenseToAdd` 对象将在您的屏幕上以 JSON 格式显示。当您开始在表单输入框中键入时，您可以看到
    `expenseToAdd` 对象的属性正在更新。反之，当您在组件类中为 `expenseToAdd` 的属性赋值时，表单也会更新，就这样，您已经创建了一个具有双向数据绑定的表单。
- en: The `ngModel` and `ngForm` directives have some other interesting configurations
    that are useful. Let’s start by examining `ngModelOptions`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel` 和 `ngForm` 指令还有一些其他有趣的配置，非常有用。让我们首先检查 `ngModelOptions`。'
- en: Additional form field options
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其他表单字段选项
- en: You can use `ngModelOptions` to configure form control instances in template-driven
    forms. The `ngModelOptions` directive can be used to define the `name` attribute,
    control the update behavior, or mark an `ngModel` instance as standalone.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `ngModelOptions` 来配置模板驱动表单中的表单控件实例。`ngModelOptions` 指令可以用来定义 `name` 属性，控制更新行为，或者将
    `ngModel` 实例标记为独立。
- en: 'You can add `ngModelOptions` by adding the directive to an input field where
    you declare the `ngModel` directive:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将指令添加到声明 `ngModel` 指令的输入字段中来添加 `ngModelOptions`：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s learn more about the properties you can set on the `ngModelOptions` directive.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解您可以在 `ngModelOptions` 指令上设置的属性。
- en: Using the name property
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名称属性
- en: When you set the `name` property of `ngModelOptions`, you can remove the `name`
    attribute on the `input` field as using the `name` property with `ngModelOptions`
    is the same as providing the `name` attribute.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当您设置 `ngModelOptions` 的 `name` 属性时，您可以移除 `input` 字段上的 `name` 属性，因为使用 `ngModelOptions`
    中的 `name` 属性与提供 `name` 属性相同。
- en: Using the updateOn property
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `updateOn` 属性
- en: 'Next, we have the `updateOn` property, which controls the update behavior of
    the form control and can take three values – `change`, `blur`, or `submit`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `updateOn` 属性，它控制表单控件的更新行为，可以取三个值——`change`、`blur` 或 `submit`：
- en: '`change`: This is the default value and doesn’t have to be set explicitly unless
    the update strategy for the entire form is changed to something else. With the
    `change` value, the form control will update on each keystroke.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`change`：这是默认值，除非整个表单的更新策略被更改为其他值，否则不需要显式设置。使用 `change` 值，表单控件将在每次按键时更新。'
- en: '`blur`: When you set `updateOn` to `blur`, the form control will update when
    you blur (focus out) from the correlating input field. This can be useful when
    you run some logic that can take a lot of time or resources to run. If you run
    heavy logic on each keystroke, your performance will suffer.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blur`：当您将 `updateOn` 设置为 `blur` 时，表单控件将在您从相关输入字段失去焦点（即模糊）时更新。这可以在您运行一些可能需要大量时间或资源的逻辑时很有用。如果您在每次按键时运行重逻辑，您的性能将受到影响。'
- en: '`submit`: If you set `updateOn` to `submit`, the form control will only be
    updated when the form is submitted. Just like `blur`, the `submit` option can
    help improve the performance of your form.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`submit`：如果您将 `updateOn` 设置为 `submit`，表单控件只有在表单提交时才会更新。就像 `blur` 一样，`submit`
    选项可以帮助提高您表单的性能。'
- en: You can also change the update behavior for all the form controls in your form
    by using the `ngFormOptions` directive on the HTML form tag. The `ngFormOptions`
    directive only takes the `updateOn` property. When you change the update behavior
    of the entire form, you can still overwrite it for individual form controls using
    the `ngModelOptions` directive.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在 HTML 表单标签上使用 `ngFormOptions` 指令来更改你表单中所有表单控件的更新行为。`ngFormOptions` 指令只接受
    `updateOn` 属性。当你更改整个表单的更新行为时，你仍然可以使用 `ngModelOptions` 指令覆盖它。
- en: Using the standalone property
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `standalone` 属性
- en: Lastly, we have the `standalone` property. When you mark a form control as standalone,
    the form control won’t register itself in the `ngForm` instance. When a form control
    is marked as standalone, you don’t have to provide the `name` attribute because
    the `ngForm` instance doesn’t have to track the value of the input. Determining
    the form’s validity will also not account for the fields marketed as standalone.
    This can be useful when you have form fields that do not represent the form model.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `standalone` 属性。当你将表单控件标记为独立时，表单控件不会在 `ngForm` 实例中注册自己。当一个表单控件被标记为独立时，你不需要提供
    `name` 属性，因为 `ngForm` 实例不需要跟踪输入的值。确定表单的有效性也不会考虑标记为独立的字段。这在你有不代表表单模型的表单字段时非常有用。
- en: Another scenario for standalone form controls is a single input for which you
    don’t need to create an entire form, but you do want to use the `ngModel` directive.
    Some examples might be a theme toggle, language selection, or search.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 独立表单控件的另一个场景是单个输入，你不需要创建整个表单，但你想使用 `ngModel` 指令。一些例子可能是一个主题切换、语言选择或搜索。
- en: Grouping template-driven form fields
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 分组模板驱动表单字段
- en: Often, you have a group of form fields that belong together. A good example
    is address fields such as street, ZIP code, and house number. You might want to
    check the validity of the fields as a group, add styling or user feedback, or
    perform validation logic on the group instead of the individual fields.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你有一组属于一起的表单字段。一个很好的例子是地址字段，如街道、邮政编码和房屋号码。你可能想作为一个组检查字段的有效性，添加样式或用户反馈，或者对组执行验证逻辑而不是单个字段。
- en: For these use cases, Angular provides the `FormGroup` class. In template-driven
    forms, you can create a `FormGroup` class using the `ngModelGroup` directive.
    When you declare the `ngModel` group, Angular will create a `FormGroup` class
    behind the scenes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些用例，Angular 提供了 `FormGroup` 类。在模板驱动表单中，你可以使用 `ngModelGroup` 指令创建 `FormGroup`
    类。当你声明 `ngModel` 组时，Angular 将在幕后创建一个 `FormGroup` 类。
- en: Declaring `ngModelGroup` is simple! Just add the `ngModelGroup` directive to
    an HTML tag, which wraps multiple HTML elements with an `ngModel` directive declared
    on it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 声明 `ngModelGroup` 非常简单！只需将 `ngModelGroup` 指令添加到 HTML 标签中，该标签包含带有 `ngModel` 指令的多个
    HTML 元素。
- en: As an example, we can group our amount, excluding VAT, and VAT percentage fields.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将金额、不含增值税和增值税百分比字段分组。
- en: 'We can do this like so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样操作：
- en: Wrap the HTML for the amount and VAT percentage fields inside a `fieldset` tag
    and declare the `ngModelGroup` directive on this `fieldset` tag.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将金额和增值税百分比字段的 HTML 包装在 `fieldset` 标签内，并在该 `fieldset` 标签上声明 `ngModelGroup` 指令。
- en: 'Assign `ngModelGroup` with a name for your `FormGroup`, and that’s it:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的 `FormGroup` 分配一个名称，然后就可以了：
- en: '[PRE8]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that all the input fields have been declared and bound to your data fields
    using the `ngModel` directive, you need a way to listen for the form submission.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有输入字段都已声明并使用 `ngModel` 指令绑定到您的数据字段，您需要一种方式来监听表单提交。
- en: Submitting template-driven forms
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 提交模板驱动表单
- en: 'As you may have noticed, we added the `submit` type to our submit button:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在提交按钮上添加了 `submit` 类型：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will trigger a submit event. When this submit event happens, Angular will
    trigger its own internal submit event called `ngSubmit`. We can listen for this
    `ngSubmit` event as we would for any other browser event or component output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将触发一个提交事件。当这个提交事件发生时，Angular 将触发其自身的内部提交事件，称为 `ngSubmit`。我们可以像监听任何其他浏览器事件或组件输出一样监听这个
    `ngSubmit` 事件：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '@ViewChild(''addExpenseForm'') form!: NgForm;'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '@ViewChild(''addExpenseForm'') form!: NgForm;'
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '@Output() addExpense = new EventEmitter<AddExpense>();'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '@Output() addExpense = new EventEmitter<AddExpense>();'
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: onSubmit() {
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: onSubmit() {
- en: this.addExpense.emit(structuredClone(this.expenseToAdd));
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: this.addExpense.emit(structuredClone(this.expenseToAdd));
- en: this.form.reset();
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: this.form.reset();
- en: '}'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <input max validator. You can still type a number higher than 100, but the form
    field will be invalid.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <input max 验证器。你仍然可以输入大于 100 的数字，但表单字段将是无效的。
- en: 'To apply the `max` validator, add the following to the input tag:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用`max`验证器，将以下内容添加到输入标签中：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also conditionally add validators. Upon using the notation with square
    brackets, as we did with the `max` validator, and supplying a property to it as
    a value when the value is set to `null`, the validation rule is disabled:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以有条件地添加验证器。使用方括号表示法，就像我们使用`max`验证器一样，并为其提供一个属性值，当该值设置为`null`时，验证规则将被禁用：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you want, you can add additional validation rules to your form; go through
    the validators in the Angular documentation and add the directives of the validation
    rules you want to use.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以向你的表单添加额外的验证规则；在Angular文档中查看验证器，并添加你想要使用的验证规则指令。
- en: I briefly want to mention the pattern validator as this is a special one. The
    pattern validator can be used for many use cases as it takes a regular expression
    and checks if the value in the input field matches the regular expression pattern.
    Other validators are used for a single purpose, such as checking for a maximum
    input value or whether the field has a value.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我简要地提一下模式验证器，因为这是一个特殊的验证器。模式验证器可以用于许多用例，因为它接受一个正则表达式，并检查输入字段中的值是否与正则表达式模式匹配。其他验证器用于单一目的，例如检查最大输入值或字段是否有值。
- en: Now that you know how to add the built-in validation rules, let’s find out how
    we can style the form fields based on the status and validity of the form and
    form controls.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何添加内置的验证规则，让我们来看看我们如何根据表单和表单控件的状态和有效性来样式化表单字段。
- en: Styling the form and form fields based on control status values
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 根据控制状态值对表单和表单字段进行样式设置
- en: To provide a good user experience for your application users, it’s important
    to provide visual feedback about the status of the form and its fields. The best
    way to do this is by utilizing the control status of your form and its form controls.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为你的应用程序用户提供良好的用户体验，提供有关表单及其字段状态的可视反馈非常重要。做到这一点的最佳方式是利用你的表单及其表单控件的控制状态。
- en: The form, as well as its `FormGroup` and `FormControl` instances, are updated
    by Angular with a control status and corresponding CSS classes. The best way to
    provide visual feedback about the status of your form and its fields is by providing
    styles for the control status CSS classes. Because these stylings are shared among
    all your applications, it’s a good practice to create them as a global styling.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 表单以及其`FormGroup`和`FormControl`实例，都由Angular通过控制状态和相应的CSS类进行更新。提供有关表单及其字段状态的可视反馈的最佳方式是为控制状态CSS类提供样式。因为这些样式在所有应用程序中都是共享的，所以将它们作为全局样式创建是一个好习惯。
- en: 'Let’s start by creating a new `global-styling` folder under the shared library
    folder. In this `global-styling` folder, create a file named `form-control-status.scss`.
    After you’ve made the folder and file, add the following under `devDependencies`
    in the root `package.json` file of the *Nx monorepo*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在共享库文件夹下创建一个新的`global-styling`文件夹开始。在这个`global-styling`文件夹中，创建一个名为`form-control-status.scss`的文件。在你创建好文件夹和文件后，在*Nx
    monorepo*根目录下的`package.json`文件中的`devDependencies`部分添加以下内容：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, you need to run `npm install` so that you can use `@global/styling` to
    import your global styling inside CSS files throughout your *Nx monorepo*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要运行`npm install`，这样你就可以在*Nx monorepo*中的CSS文件中使用`@global/styling`来导入全局样式。
- en: Now, it’s time to add the styling for the control status CSS classes inside
    our newly created CSS file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在我们的新创建的CSS文件中添加控制状态CSS类的样式了。
- en: 'Angular provides us with eight different control status CSS classes by which
    we can style our form and its form groups and controls:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Angular为我们提供了八个不同的控制状态CSS类，通过这些类我们可以对表单及其表单组和控件进行样式设置：
- en: '`ng-valid`: This is applied when the form control or group is valid based on
    the validation rules. It’s applied to the form when all groups and controls are
    valid.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-valid`：当表单控件或组根据验证规则有效时，应用此样式。当所有组和控件都有效时，应用于整个表单。'
- en: '`ng-invalid`: This is applied when the form control doesn’t pass all validation
    rules. It’s applied to the form when one or more controls are invalid.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-invalid`：当表单控件未通过所有验证规则时，应用此样式。当一个或多个控件无效时，应用于整个表单。'
- en: '`ng-pending`: This is applied when an asynchronous validation is being validated.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-pending`：当异步验证正在进行验证时，应用此样式。'
- en: '`ng-pristine`: This is applied to a form control that has not been interacted
    with. It’s applied to the form when there has been no interaction with any of
    the form controls.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-pristine`: 这是在未交互的表单控件上应用的。当没有任何表单控件被交互时，它应用于表单。'
- en: '`ng-dirty`: This is applied to a form control that has been interacted with.
    It’s applied to the form when there has been interaction with at least one form
    control.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-dirty`: 这是在已交互的表单控件上应用的。当至少有一个表单控件被交互时，它应用于表单。'
- en: '`ng-untouched`: This is applied to a form control that the user has not focused
    on or interacted with. It’s applied to the form when no field has been focused
    or interacted with.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-untouched`: 这是在用户未聚焦或未交互过的表单控件上应用的。当没有字段被聚焦或交互时，它应用于表单。'
- en: '`ng-touched`: This is applied to a form control that the user has focused on
    or interacted with. It’s applied to the form when at least one field has been
    focused or interacted with.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-touched`: 这是在用户已聚焦或交互过的表单控件上应用的。当至少有一个字段被聚焦或交互时，它应用于表单。'
- en: '`ng-submitted`: This is applied to the form element when the form has been
    submitted.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-submitted`: 这是在表单提交时应用于表单元素的。'
- en: You can use these CSS classes to style the form however you see fit. We will
    style the form fields based on their validity in our `add-expense` form but only
    do so when the form has been touched.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些 CSS 类来根据您的需求样式化表单。我们将在 `add-expense` 表单中根据其有效性样式化表单字段，但仅在表单已被触摸时这样做。
- en: 'You can add the following inside the `form-control-status.scss` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `form-control-status.scss` 文件中添加以下内容：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we only need to import this file into the CSS file of our `add-expense`
    form. Open your `add-expense.component.scss` file and add the following `import`
    statement at the top of the file to import the `form-control-status` styling:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将此文件导入到 `add-expense` 表单的 CSS 文件中。打开您的 `add-expense.component.scss`
    文件，并在文件顶部添加以下 `import` 语句以导入 `form-control-status` 样式：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After adding the import, the styles will be applied to the form.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 添加导入后，样式将应用于表单。
- en: Now that you know how to style the form and its form groups and controls using
    the control status classes, let’s learn how to display messages to the user based
    on the status of the form controls.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何使用控件状态类来样式化表单及其表单组和控件，让我们学习如何根据表单控件的状态向用户显示消息。
- en: Displaying messages based on the status of form controls
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 根据表单控件的状态显示消息
- en: You can improve the user experience even further by showing messages when a
    form field isn’t valid. You can do this by using the form control instances created
    by `ngModel`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在表单字段无效时显示消息来进一步提高用户体验。您可以通过使用由 `ngModel` 创建的表单控件实例来实现这一点。
- en: 'Start by adding a template variable to the inputs where you declared `ngModel`
    and assign the `ngModel` instance to the template variable so that you can use
    it throughout the template:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在您声明 `ngModel` 的输入中添加一个模板变量，并将 `ngModel` 实例分配给模板变量，以便您可以在整个模板中使用它：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <span>This field is required</span>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <span>This field is required</span>
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*ngIf="addExpenseForm.touched && description.hasError(''required'')"'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*ngIf="addExpenseForm.touched && description.hasError(''required'')"'
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <span *ngIf="addExpenseForm.touched && hasError with the max parameter to get
    the validity of the max validator. If you want to display the message under other
    conditions, you can change the *ngIf statement however you see fit.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <span *ngIf="addExpenseForm.touched && hasError with the max parameter to get
    the validity of the max validator. If you want to display the message under other
    conditions, you can change the *ngIf statement however you see fit.
- en: 'Another common way to improve the user experience of your form is to prevent
    the user from submitting the form when the form isn’t valid yet. You can do this
    by binding the form validity to the `disabled` attribute of the submit button:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 提高您表单用户体验的另一种常见方法是防止用户在表单尚未有效时提交表单。您可以通过将表单的有效性绑定到提交按钮的 `disabled` 属性来实现这一点。
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: export * from './lib/template-driven-validators/max-word-count.directive';
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: export * from './lib/template-driven-validators/max-word-count.directive';
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '@Input(''btLibsUtilMaxWordCount'') maxWords = 1;'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '@Input(''btLibsUtilMaxWordCount'') maxWords = 1;'
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: export class MaxWordCountDirective implements Validator {}
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 导出类 MaxWordCountDirective 实现了 Validator 接口。
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'validate(control: AbstractControl): ValidationErrors|null{}'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 'validate(control: AbstractControl): ValidationErrors|null{}'
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: const wordCount = control?.value?.trim().split(' ').length;
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: const wordCount = control?.value?.trim().split(' ').length;
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'return wordCount > this.maxWords ?   {btLibsUtilMaxWordCount: { count: wordCount
    }} : null;'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '返回 wordCount > this.maxWords ?   {btLibsUtilMaxWordCount: { count: wordCount
    }} : null;'
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'providers: [{'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'providers: [{'
- en: 'provide: NG_VALIDATORS,'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'provide: NG_VALIDATORS,'
- en: 'useExisting: MaxWordCountDirective,'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'useExisting: MaxWordCountDirective,'
- en: 'multi: true'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'multi: true'
- en: '}]'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '}]'
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<input hasError method on the control, just like we did when we checked for
    the required error:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <input hasError方法在控件上，就像我们检查必填错误时那样：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When you look at the `error` object we return in our directive, you might notice
    that we included a `count` property with the number of words we used in our form
    control:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看我们指令中返回的`error`对象时，你可能会注意到我们包含了一个带有我们表单控件中使用的单词数的`count`属性：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can retrieve the `count` value by using the `getError` method on the form
    control instance:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在表单控件实例上使用`getError`方法来检索`count`值：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we used the description template variable, which holds the reference
    to the form control instance, and called `getError` to retrieve the error object.
    You can use the `error` object to display extra information to the user in an
    error message; in our example, you can include the current count of words.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了描述模板变量，它持有表单控件实例的引用，并调用`getError`来检索错误对象。你可以使用`error`对象在错误消息中向用户显示额外信息；在我们的例子中，你可以包括当前的单词数。
- en: With that, you know how to add a custom validator to template-driven forms and
    show error messages when your custom errors occur. Next, we will learn how to
    validate form groups with custom validators.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你就知道了如何向模板驱动的表单添加自定义验证器，并在自定义错误发生时显示错误消息。接下来，我们将学习如何使用自定义验证器验证表单组。
- en: Validating form groups with custom validators
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义验证器验证表单组
- en: In our current example, we’re declaring our custom validator directive on HTML
    elements with `ngModel` declared on it. However, in some cases, you might want
    to perform cross-field validations or validate multiple fields at once. A typical
    example is when you have a password and confirm the password input field in your
    form and want to check if both fields hold the same value.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的示例中，我们正在使用在它上面声明了`ngModel`的HTML元素来声明我们的自定义验证器指令。然而，在某些情况下，你可能想要执行跨字段验证或一次性验证多个字段。一个典型的例子是，当你有一个密码和确认密码输入字段在你的表单中，并想要检查这两个字段是否持有相同的值。
- en: When you want to perform validation logic on a group of fields, you group the
    fields in your form using `ngModelGroup`, as we did with our VAT fields. Next,
    you must declare the custom validator on the HTML tag with `ngModelGroup`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要对一组字段执行验证逻辑时，你可以在你的表单中使用`ngModelGroup`来分组字段，就像我们使用VAT字段那样。接下来，你必须声明带有`ngModelGroup`的HTML标签上的自定义验证器。
- en: 'When you declare the directive on an element with `ngModelGroup` on it, the
    validator directive will receive `FormGroup` as the `AbstractControl` function
    parameter. Inside the custom validator, you can then access the values of the
    individual form controls of the form group, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在带有`ngModelGroup`的元素上声明指令时，验证器指令将接收到`FormGroup`作为`AbstractControl`函数参数。然后，在自定义验证器内部，你可以访问表单组中各个表单控件的值，如下所示：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `string` value inside the `get` method should be equal to the name you
    declared on the form control in your HTML template:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get`方法内部的`string`值应该等于你在HTML模板中表单控件上声明的名称：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'providers: [{'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'providers: [{'
- en: 'provide: NG_ASYNC_VALIDATORS,'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 'provide: NG_ASYNC_VALIDATORS,'
- en: 'useExisting: UsernameAvailabilityDirective,'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'useExisting: UsernameAvailabilityDirective,'
- en: 'multi: true,'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'multi: true,'
- en: '}]'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '}]'
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'validate(control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors
    | null> {'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'validate(control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors
    | null> {'
- en: const username = control.value;
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: const username = control.value;
- en: return checkUsernameInDatabase(username).pipe(
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: return checkUsernameInDatabase(username).pipe(
- en: 'map((isAvailable) => (isAvailable ? null : { usernameTaken: true }))'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'map((isAvailable) => (isAvailable ? null : { usernameTaken: true }))'
- en: );
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <form>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <form>
- en: <div class=»form-field">
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <div class=»form-field">
- en: <label for=»description»>Description:</label>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <label for=»description»>描述：</label>
- en: <input type=»text» id=»description»>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <input type=»text» id=»description»>
- en: </div>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: …………
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: …………
- en: <button type=»submit»>Submit</button>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <button type=»submit»>Submit</button>
- en: </form>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: </form>
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: addExpenseForm = new FormGroup({
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: addExpenseForm = new FormGroup({
- en: 'description: new FormControl(''''),'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 'description: new FormControl(''''),'
- en: 'amountExclVat: new FormControl(null),'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 'amountExclVat: new FormControl(null),'
- en: 'vatPercentage: new FormControl(null),'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 'vatPercentage: new FormControl(null),'
- en: 'date: new FormControl(''''),'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: new FormControl(''''),'
- en: '});'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<form FormControl instances to the form field by using the formControlName
    directive:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <form FormControl实例到表单字段，使用formControlName指令：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: <div>{{addExpenseForm.value | json}}</div>
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <div>{{addExpenseForm.value | json}}</div>
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: <fieldset> ……… </fieldset>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <fieldset> ……… </fieldset>
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: addExpenseForm = new FormGroup({
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: addExpenseForm = new FormGroup({
- en: 'description: new FormControl(''Test''),'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'description: new FormControl(''Test''),'
- en: 'amount: new FormGroup({'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'amount: new FormGroup({'
- en: 'amountExclVat: new FormControl(null),'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'amountExclVat: new FormControl(null),'
- en: 'vatPercentage: new FormControl(null),'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'vatPercentage: new FormControl(null),'
- en: '}),'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '}),'
- en: 'date: new FormControl(''''),'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: new FormControl(''''),'
- en: '});'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: <fieldset formGroupName="amount"> ……… </fieldset>
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <fieldset formGroupName="amount"> ……… </fieldset>
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '{'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"description": "",'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '"description": "",'
- en: 'amount": {'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '"amount": {'
- en: '"amountExclVat": null,'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '"amountExclVat": null,'
- en: '"vatPercentage": null },'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '"vatPercentage": null },'
- en: '"date": ""'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '"date": ""'
- en: '}'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'tags: new FormArray([ new FormControl('''')])'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 'tags: new FormArray([ new FormControl('''')])'
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: <fieldset formArrayName="tags"> </fieldset>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: <fieldset formArrayName="tags"> </fieldset>
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: <div class="form-field" *ngFor="let item of addExpenseForm.controls.tags.controls;
    index as i">
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: <div class="form-field" *ngFor="let item of addExpenseForm.controls.tags.controls;
    index as i">
- en: <label for=»tag-{{i}}»>Tag:</label>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: <label for=»tag-{{i}}»>标签:</label>
- en: <div class=»tag-field»>
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: <div class=»tag-field»>
- en: <input [formControlName]="i" type="text" id="tag-{{i}}">
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <input [formControlName]="i" type="text" id="tag-{{i}}">
- en: </div>
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </div>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: <div>
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: <div>
- en: <button *ngIf="i > 0" (click)="removeTag(i)">-</button>
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: <button *ngIf="i > 0" (click)="removeTag(i)">-</button>
- en: <button (click)=»addTag()">+</button>
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: <button (click)=»addTag()">+</button>
- en: </div>
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: '[PRE48]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: addTag() {
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: addTag() {
- en: this.addExpenseForm.controls.tags.insert(0, new FormControl(''));
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: this.addExpenseForm.controls.tags.insert(0, new FormControl(''));
- en: '}'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'removeTag(index: number) {'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 'removeTag(index: number) {'
- en: this.addExpenseForm.controls.tags.removeAt(index);
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: this.addExpenseForm.controls.tags.removeAt(index);
- en: '}'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'statuses: new FormRecord({})'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 'statuses: new FormRecord({})'
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: this.form.controls.statuses.addControl('someKey', new FormControl(''));
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: this.form.controls.statuses.addControl('someKey', new FormControl(''));
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'address: new FormGroup<IAddress>({…………})'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 'address: new FormGroup<IAddress>({…………})'
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'statuses: new FormRecord<FormControl<boolean>>({…………})'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 状态：new FormRecord<FormControl<boolean>>({…………})
- en: '[PRE53]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'description: new FormControl('''', ngModelOptions directive inside our template-driven
    form, you also had the option to mark an input field as standalone. As with template-driven
    forms, you can also have a standalone reactive form element, but you don’t have
    to set it with a standalone property; instead, you just declare a FormControl
    instance without FormGroup:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'description: new FormControl('''', ngModelOptions 指令在我们的模板驱动表单中，你也有将输入字段标记为独立的选择。与模板驱动表单一样，你也可以有一个独立的响应式表单元素，但你不需要使用独立属性来设置它；相反，你只需声明一个没有
    FormGroup 的 FormControl 实例：'
- en: '[PRE54]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'For a standalone reactive form field, you can use the `formControl` directive
    instead of the `formControlName` directive inside your HTML template:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个独立的响应式表单字段，你可以在你的HTML模板中使用 `formControl` 指令而不是 `formControlName` 指令：
- en: '[PRE55]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can access the value of your standalone form field by using the value property
    of `FormControl`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `FormControl` 的 value 属性来访问你独立表单字段的值：
- en: '[PRE56]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Instead of using the value property, you can also access the value more reactively
    and react to each update of `FormControl`. You can handle the changes reactively
    by subscribing to the `valueChanges` observable:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 value 属性，你也可以更反应性地访问值并响应 `FormControl` 的每个更新。你可以通过订阅 `valueChanges` 可观察对象来反应性地处理更改：
- en: '[PRE57]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now that you know how to control the update behavior of the form fields and
    how you can reactively create standalone form fields, let’s learn how to programmatically
    set and update form values.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何控制表单字段的更新行为以及如何反应性地创建独立的表单字段，让我们学习如何通过编程方式设置和更新表单值。
- en: Setting and updating values programmatically
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和更新值
- en: Often, you need a way to set and update values programmatically inside your
    component class. In reactive forms, you can use `setValue` to set values on individual
    form controls and the `patchValue` method when you want to update multiple fields
    of your form simultaneously.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要在组件类内部以编程方式设置和更新值。在响应式表单中，你可以使用 `setValue` 来设置单个表单控件上的值，当你想要同时更新表单的多个字段时，可以使用
    `patchValue` 方法。
- en: In this section, we will create our component `@Input()` directive and use `patchValue`
    to update the default form values with the values we received from the parent
    component.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建我们的组件 `@Input()` 指令并使用 `patchValue` 来更新从父组件接收到的默认表单值。
- en: 'Start by adding a new interface inside the `add-expense.interface.ts` file:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `add-expense.interface.ts` 文件中添加一个新的接口：
- en: '[PRE58]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, we will add the `@Input()` directive with a setter. Inside this setter,
    we will use the `patchValue` method:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加 `@Input()` 指令及其设置器。在这个设置器内部，我们将使用 `patchValue` 方法：
- en: '[PRE59]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `patchValue` method will update all values that are supplied inside the
    value object. So, if the value only contains the description key, only the description
    will be updated; when the value object contains the description and amount with
    both properties, all these values will be updated. The only exceptions are the
    `date` and `tags` fields.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`patchValue`方法将更新值对象内部提供的所有值。因此，如果值只包含描述键，则只更新描述；当值对象包含描述和金额，并且具有这两个属性时，所有这些值都将更新。唯一的例外是`date`和`tags`字段。'
- en: 'As you may have noticed, when we defined the date in the interface, we gave
    the `date` property a string array type; this is because to set a default value,
    we need to supply the form control with a string array, like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已注意到，当我们定义界面中的日期时，我们将`date`属性定义为字符串数组类型；这是因为为了设置默认值，我们需要向表单控件提供字符串数组，如下所示：
- en: '[PRE60]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If you provide a value in a similar format from the parent component, `patchValue`
    will also work for the date; when you provide it with a simple string, the input
    will not be populated.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从父组件提供类似格式的值，`patchValue`也会对日期有效；当您以简单字符串的形式提供它时，输入将不会被填充。
- en: 'Make sure you also update the default value inside `FormControl`; otherwise,
    you will get compiler errors because the types inside your control and patch value
    don’t match:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您还更新了`FormControl`内部的默认值；否则，您将因为控制内部和补丁值中的类型不匹配而得到编译器错误：
- en: '[PRE61]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Besides the `date` field, the `tags` field is also different because we use
    it to add controls to our form dynamically. When we assign `addExpenseForm` with
    the form model, our `FormArray` tags receive a default value of one `FormControl`.
    Because we only added one `FormControl` inside `FormArray`, when we use the `patchValue`
    method on the form, only one tag will be set, even if more tags are supplied.
    To update the value of `FormArray`, we need to add some additional logic inside
    our setter:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`date`字段外，`tags`字段也有所不同，因为我们使用它来动态地向我们的表单添加控件。当我们将`addExpenseForm`与表单模型关联时，我们的`FormArray`标签将接收一个默认值，即一个`FormControl`。因为我们只在`FormArray`内部添加了一个`FormControl`，所以当我们对表单使用`patchValue`方法时，只有一个标签将被设置，即使提供了更多标签。要更新`FormArray`的值，我们需要在我们的setter内部添加一些额外的逻辑：
- en: '[PRE62]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: First, we used the `clear` method on the `FormArray` tags. The `clear` method
    will clear all existing `FormControl` instances declared inside the `FormArray`.
    After we clear the `FormArray`, we will use a `forEach` loop to add a new `FormControl`
    for each of the tags we received from the parent component.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`FormArray`标签上使用了`clear`方法。`clear`方法将清除`FormArray`内部声明的所有`FormControl`实例。在我们清除`FormArray`之后，我们将使用`forEach`循环为从父组件接收到的每个标签添加一个新的`FormControl`。
- en: Now, when we supply an object with values from the parent component, our form
    will be populated with these values.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们从父组件提供包含值的对象时，我们的表单将填充这些值。
- en: 'In some scenarios, you only want to set the value of a single control. When
    you only want to set the value of a single control, you must use the `setValue`
    method on the `FormControl` instance:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，您可能只想设置单个控件的值。当您只想设置单个控件的值时，您必须使用`FormControl`实例上的`setValue`方法：
- en: '[PRE63]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `setValue` method doesn’t allow you to assign a number value to the description
    input field, making it a type-safe and programmatic way to set the values of form
    controls. We added the input to receive values from the parent component.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`setValue`方法不允许您将数字值分配给描述输入字段，这使得它成为一个类型安全和程序化的方式来设置表单控件的值。我们添加了输入以接收来自父组件的值。'
- en: With that, you’ve learned how to set and update values programmatically for
    your reactive forms. Next, we will start learning about validation in reactive
    forms.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，您已经学会了如何以编程方式为您的响应式表单设置和更新值。接下来，我们将开始学习响应式表单中的验证。
- en: Validating reactive forms
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 验证响应式表单
- en: As with template-driven forms, you can validate reactive forms using built-in
    or custom validators. We’ll start by looking into the built-in validators and
    then create a custom validator. Reactive forms have the same built-in validators
    as template-driven forms, except we don’t declare them using directives but the
    `Validator` class. Inside your `FormControl` instances, you can add an array with
    the validators you want to apply.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 与模板驱动表单一样，您可以使用内置或自定义验证器来验证响应式表单。我们将首先查看内置验证器，然后创建一个自定义验证器。响应式表单具有与模板驱动表单相同的内置验证器，但我们不是使用指令声明它们，而是使用`Validator`类。在您的`FormControl`实例内部，您可以添加一个包含您想要应用的验证器的数组。
- en: 'To add the required validator to our description field, we can use this syntax:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要将必需的验证器添加到我们的描述字段，我们可以使用以下语法：
- en: '[PRE64]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'export function maxWordCountValidator(maxWords: number): ValidatorFn {'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 'export function maxWordCountValidator(maxWords: number): ValidatorFn {'
- en: 'return (control: AbstractControl): ValidationErrors | null => {'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 'return (control: AbstractControl): ValidationErrors | null => {'
- en: const wordCount = control?.value?.trim().split(' ').length;
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: const wordCount = control?.value?.trim().split(' ').length;
- en: 'return wordCount > maxWords ? { maxWordCount: { count: wordCount } } : null;
    }; }'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 'return wordCount > maxWords ? { maxWordCount: { count: wordCount } } : null;
    }; }'
- en: '[PRE65]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'description: new FormControl('''', [Validators.required, null values for different
    validators; you simply call the addValidators or removeValidators method:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 'description: new FormControl('''', [Validators.required, null values for different
    validators; you simply call the addValidators or removeValidators method:'
- en: '[PRE66]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: With that, you’ve learned how to use the built-in validators, how to create
    validators using the `ValidatorFn` implementation, and how to add and remove validators
    dynamically. In the next section, you’ll learn how to provide visual feedback
    in reactive forms.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经学会了如何使用内置验证器，如何使用`ValidatorFn`实现创建验证器，以及如何动态添加和删除验证器。在下一节中，你将学习如何在响应式表单中提供视觉反馈。
- en: Providing visual feedback about the form’s state in reactive forms
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式表单中提供关于表单状态的视觉反馈
- en: Angular applies control status CSS classes to form elements, just like it does
    with template-driven forms. The control status CSS classes are the same ones that
    are used for template-driven and reactive forms, so we don’t have to change anything
    for the styles we’ve already created to be applied. The `FormGroup`, `FormArray`,
    `FormRecord`, and `FormControl` instances will all receive the control value CSS
    classes based on their current status.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Angular将控制状态CSS类应用于表单元素，就像它对模板驱动表单所做的那样。控制状态CSS类与用于模板驱动和响应式表单的相同，因此我们不需要对已经创建的样式进行任何更改，以便它们能够应用。`FormGroup`、`FormArray`、`FormRecord`和`FormControl`实例将根据它们当前的状态接收控制值CSS类。
- en: 'The only real difference is how we display the error messages. We created a
    template variable in the template-driven form and bound it to the `ngModel` instance
    to access the form controls. When we are using reactive forms, we access the form
    control instances through the form model we created:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一真正的区别是我们如何显示错误消息。我们在模板驱动表单中创建了一个模板变量，并将其绑定到`ngModel`实例以访问表单控件。当我们使用响应式表单时，我们通过我们创建的表单模型来访问表单控件实例：
- en: '[PRE67]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: For the rest, nothing changes, so go ahead and add the error messages you want
    to display to your users. We already discussed providing visual feedback when
    we covered template-driven forms, so when it comes to reactive forms, this is
    all we have to cover.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他方面，没有变化，所以请继续添加您想要显示给用户的错误消息。我们已经在介绍模板驱动表单时讨论了提供视觉反馈，因此当涉及到响应式表单时，这就是我们需要涵盖的全部内容。
- en: Submitting and resetting a reactive form works the same as for template-driven
    forms, so you can copy the submission and reset behavior from the *Building template-driven
    forms* section. To finish this chapter, we will learn how to build forms based
    on a configuration object dynamically.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 提交和重置响应式表单的工作方式与模板驱动表单相同，因此你可以从*构建模板驱动表单*部分复制提交和重置行为。为了完成这一章，我们将学习如何根据配置对象动态构建表单。
- en: Creating forms dynamically
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 动态创建表单
- en: Creating a good form requires quite a bit of code. Regardless of whether you’re
    using the template-driven or reactive approach, you need a lot of HTML; you need
    to define the model, add validators, and additional logic such as the submit behavior.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个良好的表单需要相当多的代码。无论你是使用模板驱动还是响应式方法，你都需要大量的HTML；你需要定义模型，添加验证器，以及额外的逻辑，例如提交行为。
- en: You could use a base class for some of the shared functionality, but you can
    also build a dynamic form, which will dynamically build the form based on a JSON
    input. In this section, we will build a simple example of a dynamic form. You
    can extend the dynamic form to fit your specific needs. For example, you might
    want to fetch the configuration from an external source or support additional
    validators.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个基类来提供一些共享功能，但你也可以构建一个动态表单，该表单将根据JSON输入动态构建表单。在本节中，我们将构建一个动态表单的简单示例。你可以扩展动态表单以满足你的特定需求。例如，你可能想要从外部源获取配置或支持额外的验证器。
- en: 'To start our dynamic form, create a new form component named `dynamic-form`
    in your `expenses-registration-forms` library. Next, create a `dynamic-control.interfaces.ts`
    file. I will create the new interface inside the component folder, but you can
    locate all interfaces in a designated folder or use any other folder structure
    you like. Our new dynamic control interfaces will define the interface for a form
    control, which will be generated dynamically:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的动态表单，在你的`expenses-registration-forms`库中创建一个名为`dynamic-form`的新表单组件。接下来，创建一个`dynamic-control.interfaces.ts`文件。我将在组件文件夹内创建新的接口，但你也可以将所有接口放在指定的文件夹中，或者使用你喜欢的任何其他文件夹结构。我们新的动态控制接口将定义表单控件的接口，该接口将动态生成：
- en: '[PRE68]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Once we’ve defined the interface, we need to add an input property to the component,
    which will receive an array of `DynamicControl` objects, and a `formModel` property,
    which will hold our form model:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了接口，我们需要向组件添加一个输入属性，该属性将接收一个`DynamicControl`对象的数组，并添加一个`formModel`属性，该属性将保存我们的表单模型：
- en: '[PRE69]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'When we receive the form configuration as input, we need to build our form
    model. We can use the `ngOnChanges` life cycle hook to build the form model each
    time we receive a new form configuration:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们接收到表单配置作为输入时，我们需要构建我们的表单模型。我们可以使用`ngOnChanges`生命周期钩子来构建表单模型，每次我们接收到新的表单配置时：
- en: '[PRE70]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As you can see, we check if the `changes` object contains a new `formModelConfig`;
    when `formModelConfig` is included in the changes, we use a `forEach` loop to
    add the form controls of `formModelConfig` to our form model. We also need a submit
    function and an output that will send the form model to the parent component on
    submission:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们检查`changes`对象是否包含新的`formModelConfig`；当`formModelConfig`包含在更改中时，我们使用`forEach`循环将`formModelConfig`的表单控件添加到我们的表单模型中。我们还需要一个提交函数和一个输出，它将在提交时将表单模型发送到父组件：
- en: '[PRE71]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'For our component class, this is everything we need. We need to translate this
    into the template so that our form will be built based on the configuration. Start
    by adding the form tag, bind it to the form model, and add the `ngSubmit` function
    to the `form` tag:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的组件类，这就是我们所需要的一切。我们需要将其翻译成模板，以便我们的表单将根据配置构建。首先，添加表单标签，将其绑定到表单模型，并将`ngSubmit`函数添加到`form`标签：
- en: '[PRE72]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, we need to create an input for each configuration inside `formModelConfig`.
    We will use a `*ngFor` loop to output elements for each instance inside `formModelConfig`
    and the `*ngSwitch` directive to determine which element to create. We will use
    the properties of `DynamicControl` to bind the elements to the form and provide
    all the correct values:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`formModelConfig`内部为每个配置创建一个输入。我们将使用`*ngFor`循环为`formModelConfig`中的每个实例输出元素，并使用`*ngSwitch`指令来确定要创建哪个元素。我们将使用`DynamicControl`的属性将元素绑定到表单并提供所有正确的值：
- en: '[PRE73]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Once you’ve added this HMTL, each form element will be rendered and bound to
    the form model. The last thing we need to do is add error messages. Here’s an
    example of how you can display error messages inside your dynamic form:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了此HTML，每个表单元素将被渲染并绑定到表单模型。我们最后需要做的是添加错误信息。以下是在你的动态表单中显示错误信息的一个示例：
- en: '[PRE74]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Add an additional `span` for each error message your form supports. To test
    the dynamic form, you can import it inside `expenses-overview-page.component`
    and add the selector inside the HTML template:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 为你表单支持的每个错误信息添加一个额外的`span`。为了测试动态表单，你可以在`expenses-overview-page.component`中导入它，并在HTML模板中添加选择器：
- en: '[PRE75]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create `formModelConfig` inside the component class so that the dynamic form
    has fields to generate:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件类中创建`formModelConfig`，以便动态表单有字段可以生成：
- en: '[PRE76]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Go ahead and add the rest of the fields we used inside our reactive and template-driven
    form to `formModelConfig`; you will see that the same form will be generated dynamically,
    including the validation rules and error messages.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们在响应式和模板驱动的表单中使用的其余字段添加到`formModelConfig`中；你会发现相同的表单将动态生成，包括验证规则和错误信息。
- en: This is just a simple example of a dynamic form; you can add additional logic
    if you want, such as to allow form groups, form arrays, and form records. The
    concept stays the same; just adjust the model, add the logic inside the component
    class to generate the form model correctly, and adjust the template so that you
    can render it how you intended.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个动态表单的简单示例；如果你想添加额外的逻辑，例如允许表单组、表单数组和表单记录，你可以这样做。概念保持不变；只需调整模型，在组件类中添加逻辑以正确生成表单模型，并调整模板以便你可以按预期渲染它。
- en: Summary
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about Angular’s different types of forms. You now
    know the difference between template-driven and reactive forms and when to use
    which type. We created a template-driven form that includes validation, error
    messages, default values, and styling based on control statuses. We also created
    a custom validator directive for the template-driven form. Next, we recreated
    the same for using reactive forms.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了Angular的不同类型表单。现在你知道了模板驱动和响应式表单之间的区别以及何时使用哪种类型。我们创建了一个包含验证、错误信息、默认值和基于控件状态的样式的模板驱动表单。我们还为模板驱动表单创建了一个自定义验证指令。接下来，我们为使用响应式表单做了同样的操作。
- en: We also created a custom validator function that can be used inside the reactive
    form. We learned about dynamically adding fields inside form group, form array,
    or form record classes inside the reactive form. Then, we learned how to change
    our fields’ update behavior in both template-driven and reactive forms. Lastly,
    you built a dynamic form that builds the form model based on a configuration and
    will render the form accordingly, including validations and error messages.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个自定义验证函数，可以在响应式表单内部使用。我们学习了如何在响应式表单内部动态添加表单组、表单数组或表单记录类中的字段。然后，我们学习了如何在模板驱动和响应式表单中更改我们字段的更新行为。最后，你构建了一个动态表单，该表单根据配置构建表单模型，并相应地渲染表单，包括验证和错误信息。
- en: In the next chapter, you will learn how to create dynamic components, which
    can be reused in many scenarios.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何创建动态组件，这些组件可以在许多场景中重复使用。
- en: '[PRE77]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Part 2:Handling Application State and Writing Cleaner, More Scalable Code
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：处理应用程序状态和编写更干净、更可扩展的代码
- en: In this part, you’ll learn how to develop cleaner, more scalable, and performant
    code for your Angular applications. You’ll start by developing dynamic components
    suited for more complex UI scenarios. You’ll learn about lazy-loading individual
    components on demand to reduce your bundle size and enhance performance. Then,
    you’ll explore commonly used conventions and design patterns to develop more robust
    and scalable Angular applications. You’ll finish this part by getting hands-on
    experience implementing the facade pattern, state management using NgRx, and reactive
    programming with RxJs and signals.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，你将学习如何为你的Angular应用程序开发更干净、更可扩展和性能更好的代码。你将从开发适合更复杂UI场景的动态组件开始。你将学习如何按需懒加载单个组件以减少你的包大小并提高性能。然后，你将探索常用的约定和设计模式，以开发更健壮和可扩展的Angular应用程序。你将通过实际操作实现外观模式、使用NgRx进行状态管理和使用RxJs和signals进行响应式编程来完成这部分内容。
- en: 'This part includes the following chapters:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 5*](B21625_05.xhtml#_idTextAnchor083), *Creating Dynamic Angular
    Components*'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B21625_05.xhtml#_idTextAnchor083)，*创建动态Angular组件*'
- en: '[*Chapter 6*](B21625_06.xhtml#_idTextAnchor115), *Applying Code Conventions
    and Design Patterns in Angular*'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B21625_06.xhtml#_idTextAnchor115)，*在Angular中应用代码约定和设计模式*'
- en: '[*Chapter 7*](B21625_07.xhtml#_idTextAnchor129), *Mastering Reactive Programming
    in Angular*'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21625_07.xhtml#_idTextAnchor129)，*精通Angular中的响应式编程*'
- en: '[*Chapter 8*](B21625_08.xhtml#_idTextAnchor150), *Handling Application State
    with Grace*'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21625_08.xhtml#_idTextAnchor150)，*优雅地处理应用程序状态*'
