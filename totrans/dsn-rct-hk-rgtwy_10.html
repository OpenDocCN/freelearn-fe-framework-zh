<html><head></head><body>
		<div id="_idContainer079">
			<h1 id="_idParaDest-188"><em class="italic"><a id="_idTextAnchor363"/>Chapter 10</em>: Building a Website with React</h1>
			<p>In this last chapter of this book, we will talk about <em class="italic">React</em> in general, especially the role that <em class="italic">React</em> plays in web development. We will approach this topic from three aspects to see how <em class="italic">React</em> puts resources together to build a site. First, we will take a look at how <em class="italic">React</em> embraces new <em class="italic">JavaScript ES6</em> features, such as arrow function and template strings. Then, we will walk through how a component can be styled using a <em class="italic">CSS-in-JS</em> approach via libraries such as <strong class="source-inline">styled-JSX</strong> and <strong class="source-inline">styled-components</strong>. Last, but not least, we will also get to know JSX code and how it is used to transform the <em class="italic">HTML</em>-like lines into <em class="italic">JavaScript</em> expressions.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>The function of <em class="italic">React</em></li>
				<li>Embracing <em class="italic">JavaScript</em> <em class="italic">ES6</em></li>
				<li>Adopting CSS-in-JS approach</li>
				<li>Going from <em class="italic">HTML</em> to JSX</li>
				<li>Questions and answers</li>
			</ul>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor364"/>Exploring functions of React</h1>
			<p>In this section, we will start with an exploration of the function React serves in the website development field. By doing that we hope to get a more accurate description about how React can help us.</p>
			<p>The book <a id="_idIndexMarker422"/>has been dedicated to introducing a state into a function component under <em class="italic">React</em>, especially the hook mechanism. We hope that by reading this book, you get to know how to design hooks in the right way. </p>
			<p>When comparing <em class="italic">React</em> to other UI frameworks, have you heard that sometimes people refer to it as a utility rather than a framework? There's no clear definition of what should be called a framework and what shouldn't. Judging by the amount of <em class="italic">React</em> source code and how it wires with other systems, we can hardly treat it as a utility library. But at the same time, we also should remember the goal that <em class="italic">React</em> established with in the first place, because knowing this will help you to use this technology in the right way. Let's take a look at the usage:</p>
			<p class="source-code"><strong class="bold">const</strong> rootEl = document.getElementById('root')</p>
			<p class="source-code">ReactDOM.render(&lt;App /&gt;, rootEl)</p>
			<p>The preceding code is how we start all <em class="italic">React</em> projects. It searches for a <em class="italic">DOM</em> element and renders a component under it. Moreover, afterward, the screen under that element gets "managed" by <em class="italic">React</em>. This means that <em class="italic">React</em> overwrites everything under that element and refreshes upon any state change inside the component.</p>
			<p>Therefore, the<a id="_idIndexMarker423"/> preceding <strong class="source-inline">ReactDOM.render</strong> method is the line to integrate <em class="italic">React</em> with your project. As you see, this line is powerful. In fact, it can be used multiple times for one project. Consider the following <em class="italic">HTML</em> page:</p>
			<p class="source-code"><strong class="bold">&lt;div</strong> <strong class="bold">class</strong>="slider" <strong class="bold">value</strong>="3"<strong class="bold">&gt;</strong>loading…<strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code"><strong class="bold">&lt;div</strong> <strong class="bold">cla"s</strong>="sli"er" <strong class="bold">val"e</strong>""5"<strong class="bold">&gt;</strong>loading...<strong class="bold">&lt;/div&gt;</strong></p>
			<p>Instead of controlling the whole site, we want to replace each <strong class="source-inline">slider</strong> instance with something more feature-rich:</p>
			<p class="source-code">  <strong class="bold">const</strong> elements = document.querySelectorA'l('.sli'er')</p>
			<p class="source-code">  elements.forEach(el <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">const</strong> value = el.getAttribu'e('va'ue')</p>
			<p class="source-code">    ReactDOM.render(&lt;Slider value={value} /&gt;, el)</p>
			<p class="source-code">  })</p>
			<p>We can go through the elements matching the <strong class="source-inline">slider</strong> instance in the <em class="italic">HTML</em>. For each element found, we take its <strong class="source-inline">value</strong> attribute and send it to a component with <strong class="source-inline">ReactDOM.render</strong>. Wow! All sliders are managed by <em class="italic">React</em>.</p>
			<p>Although having multiple <strong class="source-inline">render</strong> instances is not a typical approach, we build a <strong class="bold">Single Page Application</strong> (<strong class="bold">SPA</strong>). This <a id="_idIndexMarker424"/>does give us one important message; that is, from the technical aspect, the goal of <em class="italic">React</em> is to replace and manage <em class="italic">DOM</em> elements on the screen. To make this happen, a new root fiber is created internally for each element so the engine knows where to start updating when a dispatch arrives.</p>
			<p>We know by now what <em class="italic">React</em> is designed to do. Let's take a quick look at how much effort it takes to do this – for instance, what are all the dependencies to invoke the <strong class="source-inline">render</strong> statement?</p>
			<p class="source-code"><strong class="bold">const</strong> { render } = <strong class="bold">require</strong>('react-dom')</p>
			<p>To kick off the engine, we need a <strong class="source-inline">render</strong> function provided by the <strong class="source-inline">react-dom</strong> package. The component can be designed somewhere else, which requires the utilities of the <strong class="source-inline">react</strong> package, such as <strong class="source-inline">createElement</strong> and <strong class="source-inline">useState</strong>:</p>
			<p class="source-code"><strong class="bold">const</strong> { createElement, useState } = <strong class="bold">require</strong>('react')</p>
			<p class="source-code"><strong class="bold">const</strong> Slider = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [value] = useState(0)</p>
			<p class="source-code">  ...</p>
			<p class="source-code">}</p>
			<p>Other than <strong class="source-inline">react-dom</strong> and <strong class="source-inline">react</strong> packages, it's the <strong class="source-inline">document</strong> object that we need to locate and manipulate the <em class="italic">DOM</em> element. But normally, as long as we have a browser session, we assume the <strong class="source-inline">document</strong> is available.</p>
			<p>In short, there are two dependency packages. The <strong class="source-inline">react</strong> package<a id="_idIndexMarker425"/> is used for defining a component. With it, the component definition can be output into a format that the engine can understand. The <strong class="source-inline">react-dom</strong> package<a id="_idIndexMarker426"/> is used to render and manage the component to the screen. This means that before you kick off the engine, you don't need <strong class="source-inline">react-dom</strong>. Most of the development time is spent using the <strong class="source-inline">react</strong> package to define our components. From this exercise, we should clearly see the function of <em class="italic">React</em> as a utility library.</p>
			<p>To build a website with <em class="italic">React</em>, we need to do all the things that a web developer needs to do, that is, designing the site layout with <em class="italic">HTML</em>, making the site look beautiful with <em class="italic">CSS</em>, and adding business logic and interaction to engage the user with <em class="italic">JavaScript</em>. So, the question becomes how all these building blocks fit in the new component ecosystem. Let's take a look at them one at a t<a id="_idTextAnchor365"/>ime.</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor366"/>Embracing JavaScript ES6</h1>
			<p><em class="italic">React</em> is written in the <em class="italic">JavaScript</em> language. <em class="italic">JavaScript</em> has been evolving for the past 20 years. With usage in frameworks such as jQuery, Angular, <em class="italic">React</em>, and Node.js, <em class="italic">JavaScript</em> is one of the most popular and influential programming languages. </p>
			<p>The latest <em class="italic">JavaScript</em> is based on <a id="_idIndexMarker427"/>ECMAScript 2015, which is also known as <em class="italic">ES6</em>. This brought a few important features to <em class="italic">JavaScript</em>, and <em class="italic">React</em> has quickly adopted these features quite nicely. The following are just a few of the features:</p>
			<ul>
				<li>Arrow function</li>
				<li>Spread and rest</li>
				<li>Object <a id="_idIndexMarker428"/>enhancement</li>
				<li>Template strings</li>
				<li>Destructuring</li>
				<li>Let and const</li>
				<li>Modules</li>
				<li>Symbols</li>
			</ul>
			<p>If you are considering using <em class="italic">JavaScript</em> as your main language, it's recommended that in your free time, you go over all the preceding materials because they are commonly used by <em class="italic">React</em> apps. We'll go over each of these features in the following sections.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor367"/>Arrow function</h2>
			<p>The arrow function<a id="_idIndexMarker429"/> is a new syntax for function expressions. A typical function can be<a id="_idIndexMarker430"/> defined with a <strong class="source-inline">function</strong> keyword:</p>
			<p class="source-code"><strong class="bold">function</strong> abc(v) {</p>
			<p class="source-code">}</p>
			<p><em class="italic">ES6</em> introduces a more compact way of defining the preceding function with an arrow (<strong class="source-inline">=&gt;</strong>):</p>
			<p class="source-code"><strong class="bold">const</strong> abc = v <strong class="bold">=&gt;</strong> {  </p>
			<p class="source-code">}</p>
			<p>The preceding arrow version omits the word <strong class="source-inline">function</strong> and makes a function look more like an object. The arrow function is often used as a callback:</p>
			<p class="source-code">arr.map(v <strong class="bold">=&gt;</strong> v * 2)</p>
			<p>The preceding code returns a new array with each element doubled. When we make a dispatch in <em class="italic">React</em>, we also tend to use the arrow syntax:</p>
			<p class="source-code">setCount(v <strong class="bold">=&gt;</strong> v + 1)</p>
			<p>Note that the <strong class="source-inline">return</strong> statement can be omitted if the arrow function returns a single expression. We can compare the preceding line with the regular function form:</p>
			<p class="source-code">setCount(<strong class="bold">function</strong> (v) {</p>
			<p class="source-code">  <strong class="bold">return</strong> v + 1</p>
			<p class="source-code">})</p>
			<p>It's apparent that the arrow function tends to be compact while working as an object. Being an object implies that we can pass it freely to anywhere via a function input argument. Sometimes, you also see a chained version, as follows:</p>
			<p class="source-code"><strong class="bold">const</strong> fn = a <strong class="bold">=&gt;</strong> b <strong class="bold">=&gt;</strong> a + b</p>
			<p>The preceding line is equivalent to the following:</p>
			<p class="source-code"><strong class="bold">const</strong> fn = (a) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return</strong> (b) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">return</strong> a + b</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>You may find the<a id="_idIndexMarker431"/> arrow function <a id="_idIndexMarker432"/>quite expressive. The book basically uses this format solely. Only in one case does the book revert to the regular function format:</p>
			<p class="source-code">fn()</p>
			<p class="source-code"><strong class="bold">function</strong> fn() {</p>
			<p class="source-code">}</p>
			<p>We can invoke the function before the declaration in general, the compiler wouldn't complain. However, this wouldn't work for the arrow function:</p>
			<p class="source-code">fn()</p>
			<p class="source-code"><strong class="bold">const</strong> fn = () =&gt; {</p>
			<p class="source-code">}</p>
			<p>This is because <strong class="source-inline">fn</strong> needs to be declared first before it can be referenced.</p>
			<p>The <a id="_idIndexMarker433"/>arrow function, though <a id="_idIndexMarker434"/>more compact and expressive, does carry some caveats compared to the regular function:</p>
			<ul>
				<li>It sets the <strong class="source-inline">this</strong> object upon creation instead of invocation.</li>
				<li>It does not set the <strong class="source-inline">arguments</strong> object after invocation.</li>
				<li>It cannot be used as a <strong class="source-inline">construct<a id="_idTextAnchor368"/>or</strong> function.</li>
			</ul>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor369"/>Spread and rest</h2>
			<p>Pretty new to the <em class="italic">Javascript</em> language, spread is a way to express all the parts of an item, and rest is a way to express the rest of the part of an item apart from the first few parts.</p>
			<p><em class="italic">ES6</em> introduces quite a few features to allow our code to be more expressive. One of the features is to use a <strong class="source-inline">...</strong> keyword, as hardly anybody bothers to remember the exact feature name. Let's take a look at one example:</p>
			<p class="source-code"><strong class="bold">const</strong> a = [1, 2, 3, 4, 5]</p>
			<p class="source-code"><strong class="bold">const</strong> b = [...a, 6]</p>
			<p>In the preceding code, the <strong class="source-inline">b</strong> variable gets all the elements from the <strong class="source-inline">a</strong> array, spreads them into five elements, and then appends the new element so that the new array carries six elements in total. You can use this with an object as well:</p>
			<p class="source-code"><strong class="bold">const</strong> a = { first: 'John', last: 'Doe' }</p>
			<p class="source-code"><strong class="bold">const</strong> b = { ...a, age: 23 }</p>
			<p>In the preceding code, the <strong class="source-inline">b</strong> variable gets all the properties from the <strong class="source-inline">a</strong> object, spreads them, and then adds the new <strong class="source-inline">age</strong> property so that the new object carries three properties in total. </p>
			<p>Note that both <a id="_idIndexMarker435"/>usages of the spread operator<a id="_idIndexMarker436"/> create a new variable, either an array or an object. When it comes to quickly creating another variable out of an existing variable, this new syntax becomes quite popular.</p>
			<p><em class="italic">React</em> uses this feature quite often in component design:</p>
			<p class="source-code"><strong class="bold">const</strong> App = ({ title, ...props }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return &lt;div</strong> {...props}<strong class="bold">&gt;</strong>Hello<strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code">}j</p>
			<p>The preceding component uses the <strong class="source-inline">props</strong> object to capture a list of props other than <strong class="source-inline">title</strong>. This becomes useful for the following reasons: </p>
			<ul>
				<li> We do not have to care about the number of other props present in the list. </li>
				<li>We can send this list further down into the children component.</li>
			</ul>
			<p>There's another<a id="_idIndexMarker437"/> similar <em class="italic">ES6</em> feature called<a id="_idIndexMarker438"/> the <strong class="source-inline">rest</strong> operator which behaves similarly to the <strong class="source-inline">spread</strong> operator. This is when <strong class="source-inline">...</strong> is applied to a function's input argument list:</p>
			<p class="source-code"><strong class="bold">function</strong> abc(a, b, ...rest) {  </p>
			<p class="source-code">}</p>
			<p class="source-code">abc(a, b, 1)     // rest = [1]</p>
			<p class="source-code">abc(a, b, 1, 2)  // rest = [1, 2]</p>
			<p>In the preceding <strong class="source-inline">abc</strong> function, we used a <strong class="source-inline">...</strong> rest operator to obtain additional arguments.. The <strong class="source-inline">rest</strong> variable holds an array, and when we invoke the function with more than two arguments, the additional arguments get populated <a id="_idTextAnchor370"/>into this array.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor371"/>Object enhancement</h2>
			<p>With <em class="italic">ES6</em>, an object is extended to support quite a few features. Let's take a look at some of them. One of the<a id="_idIndexMarker439"/> features is that we can use a shorthand version <a id="_idIndexMarker440"/>while making an assignment to a property under an object:</p>
			<p class="source-code"><strong class="bold">const</strong> first = "John"</p>
			<p class="source-code"><strong class="bold">const</strong> last = "Doe"</p>
			<p class="source-code"><strong class="bold">const</strong> name = { first, last }</p>
			<p>If we write the preceding code in the old way, it would be equivalent to the following:</p>
			<p class="source-code"><strong class="bold">const</strong> name = { first: first, last: last }</p>
			<p>If the property name matches the assignment variable name, <em class="italic">ES6</em> allows us to write the property name only once. This becomes handy in practice, and because of this, it's common to see people take advantage of it by creating a temporary variable to match with the property name:</p>
			<p class="source-code"><strong class="bold">const</strong> onClick = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> first = "John"</p>
			<p class="source-code">  <strong class="bold">const</strong> name = { first }</p>
			<p class="source-code">}</p>
			<p>Another enhancement to an object is to support an expression as the property name:</p>
			<p class="source-code"><strong class="bold">const</strong> name = e.target.name</p>
			<p class="source-code"><strong class="bold">const</strong> value = e.target.value</p>
			<p class="source-code"><strong class="bold">return</strong> { [name]: value }</p>
			<p>The preceding code is what we write to support a form submission. Don't confuse the last line of that code with the following version:</p>
			<p class="source-code"><strong class="bold">return</strong> { name: value }</p>
			<p>Note that the<a id="_idIndexMarker441"/> difference between these two is the bracket<a id="_idIndexMarker442"/> around <strong class="source-inline">name</strong>. Without the bracket, <strong class="source-inline">name</strong> would assign the value to the "<strong class="source-inline">name</strong>" property. However, in the <strong class="source-inline">[name]</strong> version, it would assign the value to a property with a name stored in a <strong class="source-inline">name</strong> variable. If <strong class="source-inline">name</strong> carries a "<strong class="source-inline">first</strong>" word, then the <strong class="source-inline">[name]</strong> version would become the following:</p>
			<p class="source-code"><strong class="bold">return</strong> { first: value }</p>
			<p>Basically, this enables us to use any <em class="italic">JavaScript</em> expression as the property key. This was not possible before, so we used to write the following to remedy the issue:<a id="_idTextAnchor372"/></p>
			<p class="source-code">  obj[name] = value</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor373"/>Template strings</h2>
			<p>It used to be <a id="_idIndexMarker443"/>cumbersome to construct a long string in <em class="italic">JavaScript</em> without <a id="_idIndexMarker444"/>sacrificing the raw format of the string. To address this problem, <em class="italic">ES6</em> added the template strings, which allow a string to be enclosed by the back-tick (<strong class="source-inline">'</strong>), a strange character that we use often when working with <em class="italic">Markdown</em> files. With this syntax, a string can be written in the following way:</p>
			<p class="source-code">'This is a string'</p>
			<p>What's interesting about the template, beyond the regular quoted string using <strong class="source-inline">"</strong> or <strong class="source-inline">'</strong>, is that it supports a paragraph of text written across multiple lines while preserving the line breaks: </p>
			<p class="source-code">'</p>
			<p class="source-code">This </p>
			<p class="source-code">is</p>
			<p class="source-code">a </p>
			<p class="source-code">string</p>
			<p class="source-code">'</p>
			<p>This makes it<a id="_idIndexMarker445"/> useful when we want to introduce a paragraph of long text<a id="_idIndexMarker446"/> without formatting its content. The template strings also work with any <em class="italic">JavaScript</em> expression:</p>
			<p class="source-code"><strong class="bold">const</strong> what = "This"</p>
			<p class="source-code"><strong class="bold">const</strong> str = '</p>
			<p class="source-code">${what}</p>
			<p class="source-code">is </p>
			<p class="source-code">a</p>
			<p class="source-code">string</p>
			<p class="source-code">'</p>
			<p>In the preceding code, we replaced the incidence of <strong class="source-inline">${what}</strong> with the <strong class="source-inline">"This"</strong> string in the template. Essentially, what's written inside <strong class="source-inline">${}</strong> can be any <em class="italic">JavaScript</em> expression. </p>
			<p>One common usage of the template strings is to convert another format into a string:</p>
			<p class="source-code"><strong class="bold">const</strong> n = 3</p>
			<p class="source-code"><strong class="bold">const</strong> str = '${n}'</p>
			<p class="source-code"><strong class="bold">const</strong> url = 'http://foo.org/bar?id=${n}'</p>
			<p>You can see in the preceding code that this becomes handy when we need to assemble a string such as a dynamic <strong class="source-inline">url</strong>.</p>
			<p>We can apply the preceding code to a more complex version, such as the <em class="italic">CSS</em> content:</p>
			<p class="source-code"><strong class="bold">const</strong> color = 'red'</p>
			<p class="source-code"><strong class="bold">const</strong> Button = css'</p>
			<p class="source-code">  display: inline-block;</p>
			<p class="source-code">  color: ${color};</p>
			<p class="source-code">'</p>
			<p>The preceding code uses a different form called tagged templates, and <strong class="source-inline">css</strong> is what's referred to as a tagged function. Here's another example:</p>
			<p class="source-code"><strong class="bold">function</strong> image(strings) {</p>
			<p class="source-code">  <strong class="bold">return</strong> '&lt;img src="${strings[0]" /&gt;'</p>
			<p class="source-code">}</p>
			<p class="source-code">const s = image'</p>
			<p class="source-code">  http://google.com</p>
			<p class="source-code">'</p>
			<p>The preceding <a id="_idIndexMarker447"/>code defines an <strong class="source-inline">image</strong> tagged <a id="_idIndexMarker448"/>function, which transforms <strong class="source-inline">strings</strong> into another format – in our case, an image element statement. From this, you can see that tagged templates can be useful as a utility to alleviate the pain of generating strings. In the <em class="italic">Adopting CSS-in-JS </em>approach section that follows, we shall <a id="_idTextAnchor374"/>see more examples of this.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor375"/>Destructuring</h2>
			<p>The word "destructuring" is an awkward <a id="_idIndexMarker449"/>word to say and maybe we <a id="_idIndexMarker450"/>can't even find it in the dictionary. </p>
			<p>However, you might have used this feature quite a few times in the past:</p>
			<p class="source-code"><strong class="bold">const</strong> arr = [1, 2, 3]</p>
			<p class="source-code"><strong class="bold">const</strong> [a, b] = arr</p>
			<p>Essentially, destructuring allows you to destruct an object and assign the dissembled elements to variables. The preceding code is destructuring usage applied to an array, which is equivalent to the following:</p>
			<p class="source-code"><strong class="bold">const</strong> a = arr[0]</p>
			<p class="source-code"><strong class="bold">const</strong> b = arr[1]</p>
			<p>You can see that during the destructuring process, we follow the given structure to select the needed elements. Similarly, it can be applied to an object:</p>
			<p class="source-code"><strong class="bold">const</strong> name = { first: 'John', last: 'Doe' }</p>
			<p class="source-code"><strong class="bold">const</strong> { first, last } = name</p>
			<p>The preceding statement translates to the following:</p>
			<p class="source-code"><strong class="bold">const</strong> first = name.first</p>
			<p class="source-code"><strong class="bold">const</strong> last = name.last</p>
			<p>Although we can continue to use the old method, destructuring is much easier and quicker to use. Keep in mind that the element you select has to exist; otherwise, you can get an <strong class="source-inline">undefined</strong>, as shown in the following case:</p>
			<p class="source-code"><strong class="bold">const</strong> name = { first: 'John' }</p>
			<p class="source-code"><strong class="bold">const</strong> { second } = name</p>
			<p>Another useful<a id="_idIndexMarker451"/> feature with destructuring is that you can rename a <a id="_idIndexMarker452"/>property if you want to store it under another name:</p>
			<p class="source-code"><strong class="bold">const</strong> { first: firstName } = name</p>
			<p>The preceding line translates to the following:</p>
			<p class="source-code"><strong class="bold">const</strong> firstName = name.first</p>
			<p>Essentially, the <strong class="source-inline">firstName</strong> variable is used for the assignment instead of <strong class="source-inline">first</strong>, even though <strong class="source-inline">first</strong> is the property name under the object.</p>
			<p>Quite often, destructuring is used in combination with other <em class="italic">ES6</em> features, such as the spread operator:</p>
			<p class="source-code"><strong class="bold">const</strong> { first } = { ...name, last }</p>
			<p>We see this preceding statement quite often in <em class="italic">React</em> code, so let me explain each part of it: </p>
			<ul>
				<li><strong class="source-inline">...name</strong> is to spread all properties of the <strong class="source-inline">name</strong> object.</li>
				<li><strong class="source-inline">last</strong> is the enhanced object syntax to add the <strong class="source-inline">last</strong> property.</li>
				<li><strong class="source-inline">{ ...name, last }</strong> creates a new object out of the existing one. </li>
				<li><strong class="source-inline">first</strong> is destructuring the <strong class="source-inline">first</strong> property out of the new object.</li>
			</ul>
			<p>Wow, there's a lot going on! Maybe we can write it in an equivalent version using the old method:</p>
			<p class="source-code"><strong class="bold">const</strong> temp = Object.assign({}, name)</p>
			<p class="source-code">temp.last = last</p>
			<p class="source-code"><strong class="bold">const</strong> first = temp.first</p>
			<p>Essentially, the <a id="_idIndexMarker453"/>new syntax takes only one line instead of three <a id="_idIndexMarker454"/>lines, but shockingly the outcome is much more accurate and expressive. </p>
			<p>If you are new to this feature, don't hesitate in slowing down a bit while composing each part. The reason for that is, you will not only gain knowledge on what the new syntax provides but also you wo<a id="_idTextAnchor376"/>n't miss any logic accidentally.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor377"/>let and const</h2>
			<p>Using <em class="italic">JavaScript</em> in the past, you may have been confused by the <strong class="source-inline">var</strong>, <strong class="source-inline">let</strong>, and <strong class="source-inline">const</strong> keywords. Which one are you supposed to use to declare a variable?</p>
			<p>One thing to <a id="_idIndexMarker455"/>first get out of<a id="_idIndexMarker456"/> way is that <strong class="source-inline">var</strong> isn't used often anymore; it's there <a id="_idIndexMarker457"/>mostly for backward compatibility because it uses a strange scope rule. Instead, we should all use <strong class="source-inline">let</strong> and <strong class="source-inline">const</strong> because <a id="_idIndexMarker458"/>they are based on block scopes that developers are more comfortable using:</p>
			<p class="source-code"><strong class="bold">function</strong> abc() {</p>
			<p class="source-code">  <strong class="bold">let</strong> a = 1</p>
			<p class="source-code">  <strong class="bold">if</strong> (<strong class="bold">true</strong>) {</p>
			<p class="source-code">    <strong class="bold">const</strong> b = 2</p>
			<p class="source-code">    <strong class="bold">for</strong> (<strong class="bold">let</strong> i = 1; i &lt; 3; i++) {</p>
			<p class="source-code">      ...</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>In the preceding code, the <strong class="source-inline">a</strong> variable lives in the scope of the function and the <strong class="source-inline">b</strong> variable lives in the scope of the condition statement. Both references are valid in the scope specified by the <strong class="source-inline">{}</strong> parent enclosing block. If you try to reference either <strong class="source-inline">a</strong> or <strong class="source-inline">b</strong> outside of their defined scope, the compiler now throws an error. The same applies to the <strong class="source-inline">i</strong> variable, defined <a id="_idIndexMarker459"/>using <strong class="source-inline">let</strong> under the loop. If we had used <strong class="source-inline">var</strong>, it would make <strong class="source-inline">i</strong> accessible within the entire function body. </p>
			<p>As the names imply, you<a id="_idIndexMarker460"/> use <strong class="source-inline">let</strong> for a variable that needs to change later on and <strong class="source-inline">const</strong> for<a id="_idIndexMarker461"/> things <a id="_idIndexMarker462"/>you don't expect to change. Here's an example:</p>
			<p class="source-code"><strong class="bold">let</strong> x = 5</p>
			<p class="source-code">x = 6            // valid</p>
			<p class="source-code"><strong class="bold">const</strong> n = "abc"</p>
			<p class="source-code">n = "def"        // compiler error</p>
			<p>In the preceding code, if you change <strong class="source-inline">x</strong> to <strong class="source-inline">6</strong> later on, it's totally fine. But the compiler will raise an error if you try to change <strong class="source-inline">n</strong> to <strong class="source-inline">"def"</strong>. This applies to any primitive value, such as a number or a string.</p>
			<p>When it comes to a non-primitive value, such as an object or an array, it gets a bit complicated:</p>
			<p class="source-code"><strong class="bold">let</strong> obj = { a: 1, b: 2 }</p>
			<p class="source-code"><strong class="bold">const</strong> obj = { a: 1, b: 2 }</p>
			<p>Can you differentiate what the difference is between the preceding two lines? What is a variable object and what is a constant object? </p>
			<p>If an object is declared with <strong class="source-inline">const</strong>, it means only the object itself can't be used to point to another memory space: </p>
			<p class="source-code"><strong class="bold">const</strong> obj = {}</p>
			<p class="source-code">obj = {}      // compiler error</p>
			<p class="source-code">obj.key = ''  // valid</p>
			<p>In the preceding code, we defined an <strong class="source-inline">obj</strong> constant. Later on, if we attempt to overwrite <strong class="source-inline">obj</strong>, the compiler will throw an error. However, if we modify its content via a key, it's still valid. Similarly, we can expect this behavior from an array:</p>
			<p class="source-code"><strong class="bold">const</strong> arr = []</p>
			<p class="source-code">arr = []      // compiler error</p>
			<p class="source-code">arr.push('A') // valid</p>
			<p>You might find this behavior a bit strange, but it actually is designed pretty consistently for all objects and arrays when it comes to their initialization, comparison, and so on. </p>
			<p>If you see an array or object defined <a id="_idIndexMarker463"/>with a <strong class="source-inline">let</strong> statement, it should <a id="_idIndexMarker464"/>tell you that they can be overwritten later on:</p>
			<p class="source-code"><strong class="bold">let</strong> obj = {}</p>
			<p class="source-code"><strong class="bold">let</strong> arr = []</p>
			<p>This is the main<a id="_idIndexMarker465"/> diffe<a id="_idTextAnchor378"/>rence <a id="_idIndexMarker466"/>between the <strong class="source-inline">let</strong> and <strong class="source-inline">const</strong> statements.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor379"/>Modules</h2>
			<p>There's one<a id="_idIndexMarker467"/> thing a developer can't live without these days, which is code imported from <a id="_idIndexMarker468"/>another file. However, <em class="italic">JavaScript</em> didn't support this until <em class="italic">ES6</em> finally introduced a module system similar to what module loaders such as <em class="italic">AMD</em> or <em class="italic">CommonJS</em> provide. The idea is that we can export something from a file for reuse, as shown in this example:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt; &lt;div&gt;</strong>Hello World<strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code">export default Title</p>
			<p>The preceding code is quite common in a <em class="italic">React</em> application. Basically, it defines a <strong class="source-inline">Title</strong> component in a separate file and exports it as a default. From another file, we can import it and use it through an <strong class="source-inline">import</strong>, like so:</p>
			<p class="source-code">import Title from './Title'</p>
			<p class="source-code"><strong class="bold">const</strong> App = () <strong class="bold">=&gt; </strong>&lt;Title /&gt;</p>
			<p>This is the main mechanism for pulling all the files together and compiling them into a single <strong class="source-inline">index.js</strong> file because it actually imports all of them.</p>
			<p>Sometimes, we also want to export other materials along with <strong class="source-inline">default</strong>:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt; &lt;div&gt;</strong>Hello World<strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code">export default Title</p>
			<p class="source-code"><strong class="bold">const</strong> TitleType = "Component"</p>
			<p class="source-code">export { TitleType }</p>
			<p>In the preceding code, we exported <strong class="source-inline">Title</strong> as <strong class="source-inline">default</strong>, and we also exported <strong class="source-inline">TitleType</strong> as a <a id="_idIndexMarker469"/>non-default. This means that we can cherry-pick things and<a id="_idIndexMarker470"/> import them individually:</p>
			<p class="source-code">import Title, { TitleType } from './Title'</p>
			<p>This capability becomes handy when we store a bunch of related utility functionalities in a single file and export them one by one:</p>
			<p class="source-code"><strong class="bold">const</strong> fn1 = (<a id="_idTextAnchor380"/>) <strong class="bold">=&gt;</strong> {}</p>
			<p class="source-code"><strong class="bold">const</strong> fn2 = () <strong class="bold">=&gt;</strong> {}</p>
			<p class="source-code">export { fn1, fn2 }</p>
			<p>To avoid the name collision, upon import, we can use the aliasing import via the <strong class="source-inline">as</strong> keyword:</p>
			<p class="source-code"><strong class="bold">Import</strong> { fn1 as aliasFn1 } from './fns'</p>
			<p class="source-code">// we can use aliasFn1</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor381"/>Symbol</h2>
			<p>Symbol is a <a id="_idIndexMarker471"/>new <em class="italic">JavaScript</em> feature that sounds like a game term. In fact, it is a <a id="_idIndexMarker472"/>special primitive type. Normally, we could have a string as a property key:</p>
			<p class="source-code">obj['name'] = 3</p>
			<p>Anyone who writes the preceding line can access the value stored under the <strong class="source-inline">name</strong> property. But what if we want to restrict access to only people who know a key? You may ask, "what do you mean by that? Isn't the <strong class="source-inline">"name"</strong> string public to anyone?" That is the point – we want to create a key that not everyone can recreate easily. Here's what we will do:</p>
			<p class="source-code"><strong class="bold">const</strong> Name = Symbol('name')</p>
			<p class="source-code">obj[Name] = 3</p>
			<p>In the preceding code, a <strong class="source-inline">Symbol</strong> with the "<strong class="source-inline">name</strong>" string is created to serve as a key. We can still access this symbolized property under <strong class="source-inline">obj</strong> if we have the exact key. But it won't work if you create another key like that and try to access the property, like so:</p>
			<p class="source-code"><strong class="bold">const</strong> Name = Symbol('name')</p>
			<p class="source-code">obj[Name] = 4</p>
			<p>Hmm, aren't we using the same code again? Why can't we access the same key? The answer lies in the following comparison:</p>
			<p class="source-code">Symbol('name') !== Symbol('name')</p>
			<p>The preceding <a id="_idIndexMarker473"/>comparison between two <strong class="source-inline">Symbol('name')statements</strong> returns <strong class="source-inline">false</strong>! This means you can't expect to recreate the <strong class="source-inline">"name"</strong> key by writing it again; you can only have the original key you create in the first place or query through it from all registered keys in the system via <strong class="source-inline">Symbol.for</strong>:</p>
			<p class="source-code">Symbol.for('name') === Symbol.for('name')</p>
			<p>Once we find the key in the system, we can then access the property:</p>
			<p class="source-code"><strong class="bold">const</strong> Name = Symbol.for('name')</p>
			<p class="source-code">obj[Name] = 4</p>
			<p>Ahh. This is interesting, isn't it?</p>
			<p>A symbol is a <a id="_idIndexMarker474"/>primitive that cannot be recreated and is guaranteed to be <a id="_idIndexMarker475"/>unique! This means that it can serve as a unique key to a door. If the key is not present, then the door can't be opened.</p>
			<p>This becomes useful when we don't want any developer to mistakenly access some memory or assign a value. It also becomes useful to transfer this key to another project or repository in a unique way. I will show you<a id="_idTextAnchor382"/> an example of how <em class="italic">React</em> uses it in the next section.</p>
			<p>So far, we have gone over a couple of topics from <em class="italic">ES6</em>, including arrow functions, object enhancement, template strings, destructuring, <strong class="source-inline">let</strong> and <strong class="source-inline">const</strong>, modules, and symbols. But there's actually more to <em class="italic">ES6</em>, such as promise, proxy, generators, and weak map. We used promise when we referred to an API and used proxy in <a href="B17963_09_Epub.xhtml#_idTextAnchor314"><em class="italic">Chapter 9</em></a>, <em class="italic">Use Custom</em> <em class="italic">Hooks to Reuse Logic</em>. </p>
			<p>One thing for sure is that <em class="italic">React</em> really takes advantage of the latest <em class="italic">JavaScript</em> language. If you practice them often, one thing you will find is that code becomes more expressive without losing its accuracy.</p>
			<p>In the next section, we'll see how <em class="italic">React</em> uses m<a id="_idTextAnchor383"/>aterials from non-<em class="italic">JavaScript</em> languages, such as <em class="italic">CSS</em>. </p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor384"/>Adopting CSS-in-JS approach </h1>
			<p>When we build <a id="_idIndexMarker476"/>an application in <em class="italic">React</em>, at one point, we need to find a way to apply <em class="italic">CSS</em> styles to our code, right? If you have <em class="italic">CSS</em> experience in the past, one approach we're familiar with is to use <em class="italic">CSS</em> classes to style styles. Consider the following <em class="italic">CSS</em> snippet stored in a file with a .<strong class="source-inline">css</strong> extension:</p>
			<p class="source-code">h1 {</p>
			<p class="source-code">  <strong class="bold">color</strong>: red;</p>
			<p class="source-code">}</p>
			<p>We can apply this style to a <em class="italic">React</em> element via a prop called <strong class="source-inline">className</strong>:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return &lt;h1</strong> className="title"<strong class="bold">&gt;</strong>Hello<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">class</strong> is a reserved keyword for <em class="italic">JavaScript</em> and therefore can't be used. Instead, <em class="italic">React</em> chooses to use a different word, <strong class="source-inline">className</strong>.</p>
			<p>Though this old method continues to work, there's one issue about the uniqueness of the <strong class="source-inline">title</strong> class. <em class="italic">CSS</em> can be applied to all the <strong class="source-inline">title</strong> elements on the screen, but it can't skip an element inside a component that we don't want to be styled. From the <em class="italic">CSS</em> perspective, the <strong class="source-inline">title</strong> class is exposed to be styled globally.</p>
			<p>Using a component design, it's just natural that we would want to apply the style to this component only! For example, the <strong class="source-inline">title</strong> style we defined can be only valid inside the <strong class="source-inline">Title</strong> component. Believe it or not, having a scope is the foundation of the component design.</p>
			<p>One way to make the style unique to the component is to bake the style inline along with the element using a <strong class="source-inline">style</strong> prop:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return &lt;h1</strong> style={{ color: "red" }}<strong class="bold">&gt;</strong>Hello<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">}</p>
			<p>But the problem <a id="_idIndexMarker477"/>of the preceding hardcoded approach is also quite obvious. It's just not feasible to write a large amount of styles inline. This is where the <em class="italic">CSS-in-JS</em> approach comes into play. The idea is to utilize a template string to write the <em class="italic">CSS</em> using the old method. Okay, we just introduced the template strings from one of the <em class="italic">ES6</em> features:</p>
			<p class="source-code"><strong class="bold">const</strong> css = '</p>
			<p class="source-code">  h1 { color: red; }</p>
			<p class="source-code">'</p>
			<p>There's almost no learning curve to use the preceding string. Thus, this approach has been adopted by the community quickly and implemented by a couple of libraries, such as <strong class="source-inline">styled-JSX</strong> and <strong class="source-inline">styled-components</strong>. We wil<a id="_idTextAnchor385"/>l introduce both in this section, so let's get started.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor386"/>styled-SX</h2>
			<p><strong class="source-inline">styled-JSX</strong> is a <em class="italic">CSS-in-JS</em> <a id="_idIndexMarker478"/>library that allows us to write scoped <em class="italic">CSS</em> for a component where the style doesn't affect other components, thus allowing us to amend styles without worrying about making changes to other components on the screen. </p>
			<p>Let's take the same <strong class="source-inline">Title</strong> component and see how it's done with <strong class="source-inline">styled-JSX</strong>:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> (</p>
			<p class="source-code">  <strong class="bold">&lt;&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;h1&gt;</strong>Hello<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;style</strong> jsx<strong class="bold">&gt;</strong>{'</p>
			<p class="source-code">      h1 { color: red; }</p>
			<p class="source-code">    '}<strong class="bold">&lt;/style&gt;</strong>  </p>
			<p class="source-code">  <strong class="bold">&lt;/&gt;</strong></p>
			<p class="source-code">)</p>
			<p>It introduces a special <strong class="source-inline">style</strong> tag with a <strong class="source-inline">jsx</strong> prop, and underneath it, the styles can be written as <em class="italic">CSS</em> code. The styles are only injected once, even if the <strong class="source-inline">Title</strong> component is used more than once. </p>
			<p>This semi-inline approach of styles can be quite efficient when it comes to prototyping an application. Instead of putting the <em class="italic">CSS</em> inline with the component, we can put the styles in a separate file, like so:</p>
			<p class="source-code">import css from 'styled-jsx/css'</p>
			<p class="source-code">export default css'</p>
			<p class="source-code">  h1 {</p>
			<p class="source-code">    color: red; </p>
			<p class="source-code">  }</p>
			<p class="source-code">'</p>
			<p>We can import it into the <strong class="source-inline">Title</strong> component:</p>
			<p class="source-code">import titleStyle from '../titleStyle'</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> (</p>
			<p class="source-code">  <strong class="bold">&lt;&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;h1&gt;</strong>Hello<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;style</strong> jsx<strong class="bold">&gt;</strong>{titleStyle}<strong class="bold">&lt;/style&gt;</strong>  </p>
			<p class="source-code">  <strong class="bold">&lt;/&gt;</strong></p>
			<p class="source-code">)</p>
			<p>This gives us some freedom to write the CSS either inline or in a separate file.</p>
			<p>One important thing to <a id="_idIndexMarker479"/>note is that the styles we wrote so far do not apply to child components by default:</p>
			<p class="source-code"><strong class="bold">const</strong> Child = () <strong class="bold">=&gt; &lt;span&gt;</strong>World<strong class="bold">&lt;/span&gt;</strong></p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> (</p>
			<p class="source-code">  <strong class="bold">&lt;&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;h1&gt;</strong>Hello &lt;Child /&gt;<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;style</strong> jsx<strong class="bold">&gt;</strong>{'</p>
			<p class="source-code">      span { color: green; }</p>
			<p class="source-code">    '}</p>
			<p class="source-code">  <strong class="bold">&lt;/&gt;</strong></p>
			<p class="source-code">}</p>
			<p>The preceding code wouldn't make any <strong class="source-inline">span</strong> element displayed with a green color. To get it working, we can use a <strong class="source-inline">global</strong> attribute:</p>
			<p class="source-code"><strong class="bold">const</strong> Child = () <strong class="bold">=&gt; &lt;span&gt;</strong>World<strong class="bold">&lt;/span&gt;</strong></p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> (</p>
			<p class="source-code">  <strong class="bold">&lt;&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;h1&gt;</strong>Hello &lt;Child /&gt;<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;style</strong> jsx global<strong class="bold">&gt;</strong>{'</p>
			<p class="source-code">      h1 { color: red; }</p>
			<p class="source-code">      span { color: green; }</p>
			<p class="source-code">    '}</p>
			<p class="source-code">    <strong class="bold">&lt;/style&gt;</strong>  </p>
			<p class="source-code">  <strong class="bold">&lt;/&gt;</strong></p>
			<p class="source-code">)</p>
			<p><strong class="source-inline">styled-JSX</strong> is quite<a id="_idIndexMarker480"/> a unique library that makes styling easy in <em class="italic">React</em>. Moreover, since the styles are actually written in a <em class="italic">JavaScript</em> string, it can be manipulated at runtime. We'll demonstrate this feature in the next package, <strong class="source-inline">styl<a id="_idTextAnchor387"/>ed-components</strong>, since this feature works for both packages.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor388"/>styled-components</h2>
			<p>There's another library <a id="_idIndexMarker481"/>implementing the <em class="italic">CSS-in-JS</em> strategy called <strong class="source-inline">styled-components</strong>. This book has adopted this approach for all examples requiring styles. Instead of using a <strong class="source-inline">style</strong> tag, it actually allows us to define the <em class="italic">CSS</em> in a separate component:</p>
			<p class="source-code">import styled from 'styled-components'</p>
			<p class="source-code"><strong class="bold">const</strong> TitleStyle = styled.h1'</p>
			<p class="source-code">  color: red;</p>
			<p class="source-code">'</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    &lt;TitleStyle&gt;</p>
			<p class="source-code">      Hello World</p>
			<p class="source-code">    &lt;/TitleStyle&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>In the preceding code, <strong class="source-inline">styled.h1</strong> is a tagged template function that outputs a component with an embedded <strong class="source-inline">h1</strong> element.</p>
			<p>Moreover, <strong class="source-inline">styled-components</strong> allows <em class="italic">CSS</em> to apply to the children by default, which is very different from the <strong class="source-inline">styled-JSX</strong> package:</p>
			<p class="source-code"><strong class="bold">const</strong> TitleStyle = styled.h1'</p>
			<p class="source-code">  color: red;</p>
			<p class="source-code">  span { color: green; }</p>
			<p class="source-code">'</p>
			<p class="source-code"><strong class="bold">const</strong> Child = () <strong class="bold">=&gt; &lt;span&gt;</strong>World<strong class="bold">&lt;/span&gt;</strong></p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    &lt;TitleStyle&gt;</p>
			<p class="source-code">      Hello &lt;Child /&gt;</p>
			<p class="source-code">    &lt;/TitleStyle&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>The preceding code <a id="_idIndexMarker482"/>sets the <strong class="source-inline">span</strong> element with a green color. This reminds us of Sass or SCSS code.</p>
			<p>One interesting benefit that the <em class="italic">CSS-in-JS</em> solution provides is that the <em class="italic">JavaScript</em> string can be blended with other <em class="italic">JavaScript</em> expressions to support dynamic styles at runtime:</p>
			<p class="source-code"><strong class="bold">const</strong> fontSize = (props) <strong class="bold">=&gt;</strong> </p>
			<p class="source-code">  props.big ? '3em' : '1.5em'</p>
			<p class="source-code"><strong class="bold">const</strong> TitleStyle = styled.h1'</p>
			<p class="source-code">  font-size: ${fontSize};</p>
			<p class="source-code">'</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ big }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    &lt;TitleStyle big={big}&gt;</p>
			<p class="source-code">      Hello World!</p>
			<p class="source-code">    &lt;/TitleStyle&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>The preceding code defines a <strong class="source-inline">big</strong> prop that can be sent to the <strong class="source-inline">TitleStyle</strong> component where, based on the <strong class="source-inline">big</strong> value, <strong class="source-inline">fontSize</strong> can be switched between <strong class="source-inline">3em</strong> and <strong class="source-inline">1.5em</strong>.</p>
			<p>The dynamic<a id="_idIndexMarker483"/> <em class="italic">CSS</em> support makes it possible to create themeable components quite easily in <em class="italic">React</em>, and also opens the door for animating components that require a value change over time.</p>
			<p>Now that we have seen how <em class="italic">React</em> brings <em class="italic">CSS</em> into <em class="italic">JavaScript</em> to blend the two technologies together, le<a id="_idTextAnchor389"/>t's move on to <em class="italic">HTML</em> and see how it can be brought into <em class="italic">React</em>.</p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor390"/>Going from HTML to JSX</h1>
			<p>One barrier for a developer adopting <em class="italic">React</em>, especially if they are used to working with other web technologies, is that <em class="italic">HTML</em><a id="_idIndexMarker484"/> isn't imported into the project anymore. There's not a file with a <strong class="source-inline">.html</strong> extension, except the entry <strong class="source-inline">index.html</strong> file, which most of the time only has one line of <em class="italic">HTML</em> inside, like so:</p>
			<p class="source-code"><strong class="bold">&lt;div</strong> id="root"<strong class="bold">&gt;</strong>loading...<strong class="bold">&lt;/div&gt;</strong></p>
			<p>But that's it. If there was a project manager that liked to review <em class="italic">HTML</em> or even work on it, they can't do that anymore. This missing <em class="italic">HTML</em> file could be one of the reasons why teams are hesitant to adopt <em class="italic">React</em>.</p>
			<p>However, <em class="italic">HTML</em> has a similar problem to <em class="italic">CSS.</em> They don't have scopes that we have in programming languages. Even worse, a piece of <em class="italic">HTML</em>, once written, is almost turned into <em class="italic">DOM</em> elements instantly. So, a component-based system has to come up with a way to add a layer in between.</p>
			<p>How did <em class="italic">React</em> solve this problem? It chose to take the <em class="italic">HTML</em> in – no surprise. But one amazing job that <em class="italic">React</em> did is that it kept the experience of writing these statements as close as possible to <em class="italic">HTML</em>. Technically, <em class="italic">React</em> made the smooth transformation from a piece of <em class="italic">HTML</em> to a piece of <em class="italic">JavaScript</em> code possible. Sometimes, we don't notice this, nor can we tell the difference:</p>
			<p class="source-code">  <strong class="bold">return &lt;h1</strong> title="Title"<strong class="bold">&gt;</strong>Hello World<strong class="bold">&lt;/h1&gt;</strong></p>
			<p>The preceding code is what we use inside a function component. The format does look like a piece of <em class="italic">HTML</em>. What's seen by the compiler is the following:</p>
			<p class="source-code">  <strong class="bold">return</strong> React.createElement(</p>
			<p class="source-code">    'h1', { title: "Title" }, "Hello World"</p>
			<p class="source-code">  )</p>
			<p>After the compiler transformation, it becomes a <em class="italic">JavaScript</em> expression of a <strong class="source-inline">createElement</strong> function, taking three input arguments. </p>
			<p>The magic of how this transformation happens is done through a compiler with a <em class="italic">Babel</em> plugin. When the compiler builds the code, Babel converts the code into an abstract syntax tree, a token format, and then stitches them back together and puts them into the <em class="italic">JavaScript</em> format.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are interested in knowing what a compiler does, you can visit <a href="https://babeljs.io/repl">https://babeljs.io/repl</a> and try it out yourself. </p>
			<p>We are going to take a look at this <strong class="source-inline">createElement</strong> function closely now. The first input argument of the <strong class="source-inline">createElement</strong> function is the <strong class="source-inline">type</strong> of the element, which is taken from the element tag <strong class="source-inline">h1</strong>. The second one is the <strong class="source-inline">props</strong>, which is an object containing the <strong class="source-inline">title</strong> property. Last, but not least, the third one is the <strong class="source-inline">children</strong>; in our case, it's a string containing <strong class="source-inline">"Hello World"</strong>. Let's walk through these input arguments in <a id="_idTextAnchor391"/>more detail, since each of them is an essential part of <em class="italic">React</em>!</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor392"/>Props</h2>
			<p>The <strong class="source-inline">props</strong> input argument<a id="_idIndexMarker485"/> is one of the most important <em class="italic">React</em> mechanisms. We have been talking about props all the time, and this is where they receive their first-hand values. It's because <strong class="source-inline">createElement</strong> is a <em class="italic">JavaScript</em> function that we can wire any <em class="italic">JavaScript</em> expression to the props:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ title }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [count] = useState(0)</p>
			<p class="source-code">  <strong class="bold">return</strong> React.createElement(</p>
			<p class="source-code">    'h1', { title, count }, "Hello World"</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>In the preceding code, it's <a id="_idIndexMarker486"/>apparent now how a <strong class="source-inline">title</strong> prop and a <strong class="source-inline">count</strong> state are sent to <strong class="source-inline">createElement</strong> as part of the props.</p>
			<p>This also explains why we can't use the <strong class="source-inline">class</strong> reserved word as the prop to style the component:</p>
			<p class="source-code">// code below wouldn't work</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return</strong> React.createElement(</p>
			<p class="source-code">    'h1', { <strong class="bold">class</strong>: "title" }, "Hello World"</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>The p<a id="_idTextAnchor393"/>receding code would raise a compiler error due to the <strong class="source-inline">class</strong> key.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor394"/>Children</h2>
			<p>The <strong class="source-inline">children</strong> input argument<a id="_idIndexMarker487"/> is the reason that we can nest one element under another element:</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;h1&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;span&gt;</strong></p>
			<p class="source-code">        Hello World</p>
			<p class="source-code">      <strong class="bold">&lt;/span&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code">  )</p>
			<p>What the compiler sees is the following:</p>
			<p class="source-code">  <strong class="bold">return</strong> React.createElement(</p>
			<p class="source-code">    'h1', <strong class="bold">null</strong>, React.createElement(</p>
			<p class="source-code">      'span', <strong class="bold">null</strong>, "Hello World"</p>
			<p class="source-code">    )</p>
			<p class="source-code">  )</p>
			<p>Note from the preceding output that there are two usages of <strong class="source-inline">createElement</strong>, one for the <strong class="source-inline">h1</strong> element and one for the child <strong class="source-inline">span</strong> element. The second <strong class="source-inline">createElement</strong> function is used as the <strong class="source-inline">children</strong> argument of the first <strong class="source-inline">createElement</strong> function. </p>
			<p>Now, it's not too difficult to see a long list of elements nested and returned from a component via <strong class="source-inline">createElement</strong> functions. Technically, even without the compiler's help, you can code your component manually with this nested writing.</p>
			<p>Though a single <a id="_idIndexMarker488"/>element can be nested under, there can be cases where more than one element needs to be nested under another one:</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;ul&gt;</strong></p>
			<p class="source-code">      {['Apple', 'Orange'].map(v <strong class="bold">=&gt; &lt;li&gt;</strong>{v}<strong class="bold">&lt;/li&gt;</strong>)}</p>
			<p class="source-code">    <strong class="bold">&lt;/ul&gt;</strong></p>
			<p class="source-code">  )</p>
			<p>For the preceding <em class="italic">JavaScript</em> expression involving an array, the array would be sent to the <strong class="source-inline">children</strong> of <strong class="source-inline">createElement</strong>: </p>
			<p class="source-code">  <strong class="bold">return</strong> React.createElement(</p>
			<p class="source-code">    'ul',</p>
			<p class="source-code">    <strong class="bold">null</strong>,</p>
			<p class="source-code">    ['apple', 'orange'].map((v) <strong class="bold">=&gt;</strong></p>
			<p class="source-code">      React.createElement('li', <strong class="bold">null</strong>, v)</p>
			<p class="source-code">    )</p>
			<p class="source-code">  )</p>
			<p>Essentially, the <strong class="source-inline">children</strong> input argument <a id="_idIndexMarker489"/>can support the following formats:</p>
			<ul>
				<li>A <strong class="source-inline">"Hello World"</strong> string</li>
				<li>A single element via <strong class="source-inline">createElement</strong></li>
				<li>An array of elements with either of the preceding format</li>
			</ul>
			<p><em class="italic">React</em> also allows you to add any number of children in another way:</p>
			<p class="source-code">  <strong class="bold">return</strong> React.createElement(</p>
			<p class="source-code">    'ul',</p>
			<p class="source-code">    <strong class="bold">null</strong>,</p>
			<p class="source-code">    React.createElement('li', <strong class="bold">null</strong>, 'apple'),</p>
			<p class="source-code">    React.createElement('li', <strong class="bold">null</strong>, 'orange')</p>
			<p class="source-code">  )</p>
			<p>In the preceding code, we can stack the children <a id="_idTextAnchor395"/>in the input argument list, starting from the third input argument.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor396"/>Element type</h2>
			<p>An element type, the<a id="_idIndexMarker490"/> first input argument to <strong class="source-inline">createElement</strong>, can be a simple string representing an <em class="italic">HTML</em> tag, such as <strong class="source-inline">h1</strong> and <strong class="source-inline">span</strong>. However, it can also take other formats, such as a function:</p>
			<p class="source-code"><strong class="bold">const</strong> Child = () <strong class="bold">=&gt; &lt;h1&gt;</strong>Hello World<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return </strong>&lt;Child /&gt;</p>
			<p class="source-code">}</p>
			<p>What the compiler sees of the preceding code is the following:</p>
			<p class="source-code"><strong class="bold">const</strong> Child = () <strong class="bold">=&gt;</strong></p>
			<p class="source-code">  React.createElement("h1", <strong class="bold">null</strong>, "Hello World")</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> React.createElement(Child, <strong class="bold">null</strong>)</p>
			<p>Note <strong class="source-inline">Child</strong> in the preceding code – the function itself is sent to <strong class="source-inline">createElement</strong> as the element type! This is how <em class="italic">React</em> allows you to create an element out of a custom component. Because of this, it means we can support a dynamic element type at runtime:</p>
			<p class="source-code"><strong class="bold">const</strong> Child1 = () <strong class="bold">=&gt; &lt;h1&gt;</strong>Hello<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code"><strong class="bold">const</strong> Child2 = () <strong class="bold">=&gt; &lt;h1&gt;</strong>World<strong class="bold">&lt;/h1&gt;</strong></p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ flag }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> Child = flag ? Child1 : Child2</p>
			<p class="source-code">  <strong class="bold">return </strong>&lt;Child /&gt;</p>
			<p class="source-code">}</p>
			<p>In the <a id="_idIndexMarker491"/>preceding code, instead of returning either <strong class="source-inline">&lt;Child1 /&gt;</strong> or <strong class="source-inline">&lt;Child2 /&gt;</strong>, we first determine the type of <strong class="source-inline">Child</strong> component at the runtime and then return the instance from this <strong class="source-inline">&lt;Child /&gt;</strong> component. This is all possible because the component type is a <em class="italic">JavaScript</em> variable:</p>
			<p class="source-code"><strong class="bold">const</strong> Child1 = () <strong class="bold">=&gt;</strong> React.createElement(</p>
			<p class="source-code">  "h1", <strong class="bold">null</strong>, "Hello"</p>
			<p class="source-code">)</p>
			<p class="source-code"><strong class="bold">const</strong> Child2 = () <strong class="bold">=&gt;</strong> React.createElement(</p>
			<p class="source-code">  "h1", <strong class="bold">null</strong>, "World"</p>
			<p class="source-code">)</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ flag }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> Child = flag ? Child1 : Child2</p>
			<p class="source-code">  <strong class="bold">return</strong> React.createElement(Child, <strong class="bold">null</strong>)</p>
			<p class="source-code">}</p>
			<p>The preceding code confirms what the compiler sees. The <strong class="source-inline">Child</strong> component type is determined at runtime.</p>
			<p>Now that we have seen the <strong class="source-inline">createElement</strong> function and i<a id="_idTextAnchor397"/>ts three input arguments, let's take a close look at what it returns.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor398"/>React element</h2>
			<p>As the <strong class="source-inline">createElement</strong> name indicates, the function returns a root element with a tree of elements under it.</p>
			<p>Is the element a <em class="italic">DOM</em> element? No, it's called a <a id="_idIndexMarker492"/><em class="italic">React</em> element. Though the <em class="italic">React</em> documentation doesn't talk too much about it, we'll reveal it a bit briefly here:</p>
			<p class="source-code">{</p>
			<p class="source-code">  $$typeof: Symbol.for('react.element'),</p>
			<p class="source-code">  type: type,</p>
			<p class="source-code">  props: props,</p>
			<p class="source-code">}</p>
			<p>The preceding code is a short definition of the <em class="italic">React</em> element definition. As you can see, it's basically an object. We've been introduced to <strong class="source-inline">type</strong> and <strong class="source-inline">props</strong>, but what the heck is <strong class="source-inline">$$typeof</strong>? Apparently, this is not something that <em class="italic">React</em> wants anyone to tamper with. </p>
			<p>It turns out <em class="italic">React</em> supports various categories of elements. For the lack of a better word, let's call <strong class="source-inline">$$typeof</strong> another type, an internal type. The one we used most often was <strong class="source-inline">react.element</strong>, and it's defined as a <strong class="source-inline">Symbol</strong>. We just introduced <strong class="source-inline">Symbol</strong> in the previous section. Basically, <strong class="source-inline">react.element</strong> is a unique primitive value that, once created, can be used but not changed. </p>
			<p>You may ask, "what are other types are there?" Actually, there are two dozen of them; here are just a few that might interest you:</p>
			<ul>
				<li><strong class="source-inline">react.element</strong></li>
				<li><strong class="source-inline">react.portal</strong></li>
				<li><strong class="source-inline">react.fragment</strong></li>
				<li><strong class="source-inline">react.provider</strong></li>
				<li><strong class="source-inline">react.suspense</strong></li>
				<li><strong class="source-inline">react.memo</strong></li>
				<li><strong class="source-inline">react.lazy</strong></li>
			</ul>
			<p>Why do we need all these different types? </p>
			<p>Most of the application implementation is more or less around updating a <strong class="source-inline">react.element</strong>, but <a id="_idIndexMarker493"/>when it comes to special cases, it requires a different updating algorithm. Let's take a look at the following example:</p>
			<p class="source-code">import { memo } from 'react'</p>
			<p class="source-code"><strong class="bold">const</strong> App = memo(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    &lt;Provider value={3}&gt;</p>
			<p class="source-code">      <strong class="bold">&lt;&gt;</strong></p>
			<p class="source-code">        <strong class="bold">&lt;div&gt;</strong>One<strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code">        <strong class="bold">&lt;div&gt;</strong>Second<strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;/&gt;</strong></p>
			<p class="source-code">    &lt;/Provider&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">})</p>
			<p>In the preceding code, <strong class="source-inline">Provider</strong> creates an element with a <strong class="source-inline">react.provider</strong> type. Under it, <strong class="source-inline">&lt;&gt;</strong> creates an element with a <strong class="source-inline">react.fragment</strong> type, and under it, <strong class="source-inline">div</strong> creates two elements with a <strong class="source-inline">react.element</strong> type. The entire component is wrapped in a <strong class="source-inline">memo</strong> element with a <strong class="source-inline">react.memo</strong> type. This gives you a rough idea of where different <em class="italic">React</em> elements are used.</p>
			<p>In short, what returns from the JSX code block are <em class="italic">Reac<a id="_idTextAnchor399"/>t</em> elements. These <em class="italic">React</em> elements are what is fed into the <em class="italic">React</em> engine.</p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor400"/>Summary</h1>
			<p>In this chapter, we started with the function of <em class="italic">React</em> in web development. We went into three aspects of it. First, we went through the latest <em class="italic">ES6</em> features of <em class="italic">JavaScript</em>, such as the arrow function and template strings. Next, we learned the <em class="italic">CSS-in-JS</em> approach to bring <em class="italic">CSS</em> into <em class="italic">JavaScript</em>, using libraries such as <strong class="source-inline">styled-JSX</strong> and <strong class="source-inline">styled-components</strong>. Last, but not least, we learned how <em class="italic">HTML</em>-like JSX code is transformed and returned as <em class="italic">React</em> elements. All in all, we saw how <em class="italic">React</em> pulls all these resources <a id="_idTextAnchor401"/>together, including <em class="italic">JavaScript</em>, <em class="italic">CSS</em>, and <em class="italic">HTML</em>, to help us build a site.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor402"/>Questions and answers</h1>
			<p><a id="_idTextAnchor403"/>The following are some questions and answers to refresh your knowledge:</p>
			<ol>
				<li>What is <em class="italic">React</em>?<p>It's a tool that allow<a id="_idTextAnchor404"/>s us to design a component and manage its update with a render engine. </p></li>
				<li>What is <em class="italic">JavaScript ES6</em>?<p><em class="italic">JavaScript</em> has all the latest features published as <em class="italic">ES6</em>. <em class="italic">React</em> takes advantage of them, using features such as the arrow function, template strings, and destructuring. Using them in your pro<a id="_idTextAnchor405"/>ject would make your code more efficient, expressive, and maintainable.</p></li>
				<li>What's <em class="italic">CSS-in-JS</em>?<p><em class="italic">CSS-in-JS</em> refers to one opinionated but popular way to apply styles to a <em class="italic">React</em> component. The styles applied are localized to the component and don't collide with any other components. Moreover, the styles can be wir<a id="_idTextAnchor406"/>ed with any <em class="italic">JavaScript</em> expression to support dynamic styles at runtime.</p></li>
				<li>What is JSX code?<p><em class="italic">React</em> allows us to use JSX code to write <em class="italic">HTML</em>-like code. Practically, they look quite similar, except JSX allows us to transform these statements into native <em class="italic">JavaScript</em> expressions that accept element types, props, and children from the input argument and return <em class="italic">React</em> elements that the engine can put into effect.</p></li>
			</ol>
		</div>
	</body></html>