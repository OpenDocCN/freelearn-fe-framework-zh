- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Crafting Reusable Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建可复用组件
- en: The aim of this chapter is to show you how to implement React components that
    serve more than just one purpose. After reading this chapter, you’ll feel confident
    about how to compose application features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是向您展示如何实现具有多个目的的React组件。阅读本章后，您将对自己的应用功能组合充满信心。
- en: The chapter starts with a brief look at HTML elements and how they work in terms
    of helping to implement features versus having a high level of utility. Then,
    you’ll see the implementation of a **monolithic component** and discover the issues
    that it will cause down the road. The next section is devoted to re-implementing
    the monolithic component in such a way that the feature is composed of smaller
    components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先简要介绍了HTML元素及其在帮助实现功能与具有高度实用性方面的作用。然后，您将看到**单一组件**的实现，并发现它将带来的问题。下一节将致力于以这种方式重新实现单一组件，即功能由更小的组件组成。
- en: Finally, the chapter ends with a discussion of rendering trees of React components
    and gives you some tips on how to avoid introducing too much complexity as a result
    of decomposing components. I’ll close the final section by reiterating the concept
    of high-level feature components versus utility components.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章以对React组件渲染树的讨论结束，并为您提供一些关于如何避免在分解组件时引入过多复杂性的建议。我将在最后一节重申高级功能组件与实用组件的概念。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Reusable HTML elements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可复用HTML元素
- en: The difficulty with monolithic components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一组件的困难之处
- en: Refactoring component structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构组件结构
- en: Render props
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染属性
- en: Rendering component trees
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染组件树
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter05](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter05).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，链接为[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter05](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter05)。
- en: Reusable HTML elements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可复用HTML元素
- en: 'Let’s think about HTML elements for a moment. Depending on the type of HTML
    element, it’s either feature-centric or utility-centric. Utility-centric HTML
    elements are more reusable than feature-centric HTML elements. For example, consider
    the `<section>` element. This is a generic element that can be used just about
    anywhere but its primary purpose is to compose the structural aspects of a feature:
    the outer shell of the feature and the inner sections of the feature. This is
    where the `<section>` element is most useful.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时思考一下HTML元素。根据HTML元素的类型，它要么是功能中心的，要么是实用中心的。实用中心的HTML元素比功能中心的HTML元素更易于复用。例如，考虑`<section>`元素。这是一个通用元素，几乎可以用于任何地方，但其主要目的是组成功能的结构方面：功能的壳体和功能的内部部分。这就是`<section>`元素最有用的地方。
- en: On the other side of the fence, you have elements such as `<p>`, `<span>`, and
    `<button>`. These elements provide a high level of utility because they’re generic
    by design. You’re supposed to use `<button>` elements whenever you have something
    that’s clickable by the user, resulting in an action. This is a level lower than
    the concept of a feature.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一边，您有像`<p>`、`<span>`和`<button>`这样的元素。这些元素因为设计上的通用性而提供了高级的实用性。当用户可以点击并执行操作时，您应该使用`<button>`元素，这比功能的概念低一个层次。
- en: While it’s easy to talk about HTML elements that have a high level of utility
    versus those that are geared toward specific features, the discussion is more
    detailed when data is involved. HTML is static markup; React components combine
    static markup with data. The question is, how do you make sure that you’re creating
    the right feature-centric and utility-centric components?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然谈论具有高度实用性的HTML元素与针对特定功能设计的元素很容易，但当涉及数据时，讨论会更加详细。HTML是静态标记；React组件将静态标记与数据相结合。问题是，您如何确保您正在创建正确的以功能为中心和以实用为中心的组件？
- en: The aim of this chapter is to find out how to go from a monolithic React component
    that defines a feature to a smaller feature-centric component combined with utility
    components.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是找出如何将定义功能的单一React组件转变为更小的以功能为中心的组件，并结合实用组件。
- en: The diffculty with monolithic components
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一组件的困难之处
- en: If you could implement just one component for any given feature, it would simplify
    your job. At the very least, there wouldn’t be many components to maintain, and
    there wouldn’t be many communication paths for data to flow through because everything
    would be internal to the component.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只为任何给定的功能实现一个组件，这将简化你的工作。至少，维护的组件不会很多，数据的流动路径也不会很多，因为所有内容都在组件内部。
- en: However, this idea doesn’t work for a number of reasons. Having monolithic feature
    components makes it difficult to coordinate any kind of team development effort,
    such as **version control**, **merge conflicts**, and **parallel development**.
    The bigger the monolithic components become, the more difficult they are to refactor
    into something better later on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个想法由于多种原因而不可行。拥有单体功能组件使得协调任何类型的团队开发工作变得困难，例如**版本控制**、**合并冲突**和**并行开发**。单体组件越大，将来重构为更好的组件就越困难。
- en: There’s also the problem of feature overlap and feature communication. Overlap
    happens because of similarities between features; it’s unlikely that an application
    will have a set of features that are completely unique to one another. That would
    make the application very difficult to learn and use. Component communication
    essentially means that the state of something in one feature will impact the state
    of something in another feature. State is difficult to deal with, and even more
    so when there is a lot of state packaged up in a monolithic component.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个功能重叠和功能通信的问题。重叠是由于功能之间的相似性造成的；一个应用程序不太可能有一组完全独特的功能。这将使应用程序非常难以学习和使用。组件通信基本上意味着一个功能中某个东西的状态将影响另一个功能中某个东西的状态。状态很难处理，当有很多状态被封装在单体组件中时，情况更是如此。
- en: The best way to learn how to avoid monolithic components is to experience one
    firsthand. You’ll spend the remainder of this section implementing a monolithic
    component. In the following section, you’ll see how this component can be refactored
    into something a little more sustainable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何避免单体组件的最佳方式是亲身体验。你将在本节的剩余部分实现一个单体组件。在下一节中，你将看到这个组件是如何被重构为更可持续的样式的。
- en: The JSX markup
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSX 标记
- en: The **monolithic component** we’re going to implement is a feature that lists
    articles. It’s just for illustrative purposes, so we don’t want to go overboard
    on the size of the component. It’ll be simple yet monolithic. The user can add
    new items to the list, toggle the summary of items in the list, and remove items
    from the list.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的**单体组件**是一个列出文章的功能。这只是为了说明目的，所以我们不想让组件的大小过大。它将简单而单体。用户可以向列表中添加新项目，切换列表中项目的摘要，并从列表中删除项目。
- en: 'Here is the JSX markup of the component:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是组件的 JSX 标记：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is definitely more JSX than is necessary in one place. We’ll improve on
    this in the following section, but for now, let’s implement the initial state
    for this component.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 JSX 明显比必要的多。我们将在下一节中改进这一点，但现在，让我们为这个组件实现初始状态。
- en: Initial state
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始状态
- en: 'Now, let’s look at the initial state of this component:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个组件的初始状态：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The state consists of an array of `articles`, a `title` string, and a `summary`
    string. Each article object in the `articles` array has several string fields
    to help render the article and an `id` field, which is a number. The number is
    generated by `id.next().`
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 状态由一个`articles`数组、一个`title`字符串和一个`summary`字符串组成。`articles`数组中的每个文章对象都有几个字符串字段来帮助渲染文章，以及一个`id`字段，这是一个数字。这个数字是由`id.next()`生成的。
- en: 'Let’s take a look at how this works:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `id` constant is a generator. It is created by defining an inline generator
    function and calling it right away. This generator will yield numbers infinitely.
    So, calling `id.next()` the first time returns `1`, the next is `2`, and so on.
    This simple utility will come in handy when it’s time to add new articles and
    we need a new unique ID.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` 常量是一个生成器。它通过定义一个内联生成器函数并立即调用它来创建。这个生成器将无限期地产生数字。所以，第一次调用`id.next()`返回`1`，下一次是`2`，依此类推。这个简单的实用工具在需要添加新文章并需要一个新唯一
    ID 时会很有用。'
- en: Event handler implementation
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理器实现
- en: 'At this point, you have the initial state and the JSX of the component. Now,
    it’s time to implement the event handlers:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经有了组件的初始状态和 JSX 代码。现在，是时候实现事件处理器了：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `onChangeTitle()` and `onChangeSummary()` methods use the hook’s `setState()`
    to update the `title` and `summary` state values, respectively. The new values
    come from the `target.value` property of the `event` argument, which is the value
    that the user types into the text input:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`onChangeTitle()`和`onChangeSummary()`方法分别使用钩子的`setState()`来更新`title`和`summary`状态值。新值来自`event`参数的`target.value`属性，这是用户输入到文本输入中的值：'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `onClickAdd()` method adds a new article to the `articles` state. This
    state value is an array. We use the spread operator to build a new array from
    the existing array (`[...state]`), and the new object gets added to the end of
    the new array. The reason we’re building a new array and passing it to `setArticles()`
    is so that there are no surprises. In other words, we’re treating state values
    as immutable so that other code that updates the same state doesn’t accidentally
    cause problems. Next, we’ll use a handler to remove the article:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`onClickAdd()`方法向`articles`状态添加一篇新文章。这个状态值是一个数组。我们使用扩展运算符从现有数组（`[...state]`）构建一个新数组，并将新对象添加到新数组的末尾。我们构建新数组并将其传递给`setArticles()`的原因是为了避免意外。换句话说，我们将状态值视为不可变，以便更新相同状态的其它代码不会意外地造成问题。接下来，我们将使用一个处理程序来删除文章：'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `onClickRemove()` method removes the article with the given ID from the
    `articles` state. It does this by calling `filter()` on the array, which returns
    a new array, so the operation is immutable. The filter removes the object with
    the given ID:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`onClickRemove()`方法从`articles`状态中删除具有给定ID的文章。它是通过在数组上调用`filter()`来实现的，这返回一个新数组，因此操作是不可变的。过滤器删除具有给定ID的对象：'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `onClickToggle()` method toggles the visibility of the article with the
    given ID. We carry out two immutable operations in this method. First, we build
    a new `articles` array. Then, based on the index of the given ID, we replace the
    article object at the index with a new object. We use the object spread operator
    to fill in the properties (`{...articles[index]}`), and then the display property
    value is toggled based on the existing display value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`onClickToggle()`方法切换具有给定ID的文章的可见性。在这个方法中，我们执行了两个不可变操作。首先，我们构建一个新的`articles`数组。然后，根据给定ID的索引，我们用新对象替换索引处的文章对象。我们使用对象扩展运算符来填充属性（`{...articles[index]}`），然后根据现有的显示值切换显示属性值。'
- en: 'Here’s a screenshot of the output rendered:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出渲染的截图：
- en: '![](img/B19636_05_01.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_05_01.png)'
- en: 'Figure 5.1: Rendered articles'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：渲染的文章
- en: At this point, we have a component that does everything that we need our feature
    to do. However, it’s monolithic and difficult to maintain. Imagine if we had other
    places in our app that use the same pieces of `MyFeature`. They have to re-invent
    them because they cannot be shared. In the following section, we’ll work on breaking
    down `MyFeature` into smaller reusable components.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个组件，它完成了我们需要的所有功能。然而，它是单体化的，难以维护。想象一下，如果我们应用中的其他地方也使用了相同的`MyFeature`片段。他们必须重新发明它们，因为他们无法共享。在下一节中，我们将努力将`MyFeature`分解为更小的可重用组件。
- en: Refactoring component structures
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构组件结构
- en: 'You have a monolithic feature component: *now what*? Let’s make it better.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个单体功能组件：*接下来怎么办*？让我们让它变得更好。
- en: In this section, you’ll learn how to take the feature component that you just
    implemented in the preceding section and split it into more maintainable components.
    You’ll start with the **JSX**, as this is probably the best refactor starting
    point. Then, you’ll implement new components for the feature.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何将上一节中实现的功能组件拆分为更易于维护的组件。你将从**JSX**开始，因为这可能是最佳的重构起点。然后，你将为功能实现新的组件。
- en: Next, you’ll make these new components functional instead of class-based. Finally,
    you’ll learn how to use **render props** to reduce the number of direct component
    dependencies in your application, and how to remove classes entirely by using
    hooks to manage state within functional components.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使这些新组件具有功能性，而不是基于类的。最后，你将学习如何使用**渲染属性**来减少应用程序中直接组件依赖项的数量，以及如何通过在功能组件中使用钩子来管理状态来完全删除类。
- en: Starting with the JSX
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从JSX开始
- en: 'The **JSX** of any **monolithic component** is the best starting point for
    figuring out how to refactor it into smaller components. Let’s visualize the structure
    of the component that we’re currently refactoring:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 任何**单体组件**的**JSX**是将其重构为更小组件的最佳起点。让我们可视化我们目前正在重构的组件结构：
- en: '![](img/B19636_05_02.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_05_02.png)'
- en: 'Figure 5.2: Visualization of the JSX that makes up a React component'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：构成 React 组件的 JSX 可视化
- en: 'The top part of the JSX is the form controls, so this could easily become its
    own component:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 的上半部分是表单控件，因此这可以很容易地成为一个自己的组件：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, you have the list of articles:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你有文章列表：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Within this list, there’s potential for an article component, which would be
    everything in the `<li>` tag. Let’s try building this next.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，有一个文章组件的潜力，它包括了 `<li>` 标签中的所有内容。让我们尝试构建这个组件。
- en: Implementing an article list component
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现文章列表组件
- en: 'Here’s what the ArticleList component implementation looks like:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 ArticleList 组件的实现看起来像：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We’re taking the relevant JSX out of the monolithic component and putting it
    here. Now, let’s see what the feature component of JSX looks like:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将相关的 JSX 从单体组件中提取出来，并将其放在这里。现在，让我们看看功能组件的 JSX 看起来像：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The list of articles is now rendered by the `ArticleList` component. The list
    of articles to render is passed to this component as a property along with two
    of the event handlers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 文章列表现在由 `ArticleList` 组件渲染。要渲染的文章列表作为属性传递给此组件，同时还有两个事件处理程序。
- en: Why are we passing event handlers to a child component? The reason is so that
    the `ArticleList` component doesn’t have to worry about the state or how the state
    changes. All it cares about is rendering content and making sure the appropriate
    event callbacks are hooked up to the appropriate DOM elements. This is a container
    component concept that I’ll expand upon later in this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要将事件处理程序传递给子组件？原因是为了让 `ArticleList` 组件不必担心状态或状态如何变化。它只关心渲染内容和确保适当的事件回调被连接到适当的
    DOM 元素。这是一个容器组件的概念，我将在本章后面进一步阐述。
- en: Now that we have an `ArticleList` component, let’s see whether we can further
    break it down into smaller reusable components.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `ArticleList` 组件，让我们看看我们是否可以进一步将其分解成更小的可重用组件。
- en: Implementing an article item component
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现文章项目组件
- en: After implementing the article list component, you might decide that it’s a
    good idea to break this component.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了文章列表组件之后，你可能会决定将其分解成更小的组件。
- en: 'Another way to look at it is this: if it turns out that we don’t actually need
    the item as its own component, this new component doesn’t introduce much indirection
    or complexity. Without further ado, here’s the article item component:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待它的方法是：如果最终我们发现实际上不需要将项目作为自己的组件，这个新组件不会引入太多的间接或复杂性。无需多言，以下是文章项目组件：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Essentially, the component remains unchanged except for one enhancement: we
    have relocated the logic for expanding and collapsing the article to the `ArticleItem`
    component, which offers several advantages. Firstly, we reduced the original `MyFeature`
    component, since it doesn’t need to know when we hide or expand an article at
    all. Secondly, we have improved the performance of the application due to the
    fact that when expanding an article, we no longer recreate the array of articles
    using the spread operator but only change the state locally. As a result, when
    expanding the article, the list of articles remains the same and React does not
    re-render the page, but only one component is re-rendered.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，组件除了一个增强之外没有变化：我们将展开和折叠文章的逻辑重新定位到了 `ArticleItem` 组件，这提供了几个优点。首先，我们减少了原始的
    `MyFeature` 组件，因为它根本不需要知道何时隐藏或展开文章。其次，由于在展开文章时，我们不再使用展开操作符重新创建文章数组，而是仅更改本地状态，因此我们提高了应用程序的性能。结果，在展开文章时，文章列表保持不变，React
    不会重新渲染页面，但只有一个组件被重新渲染。
- en: 'Here’s the new `ArticleItem` component being rendered by the `ArticleList`
    component:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `ArticleList` 组件正在渲染的新 `ArticleItem` 组件：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Do you see how this list just maps the list of articles? What if you wanted
    to implement another article list that does some filtering too? If so, it’s beneficial
    to have a reusable `ArticleItem` component. Next, we’ll move the add article markup
    into its own component.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到这个列表是如何映射文章列表的吗？如果你想要实现另一个具有过滤功能的文章列表，那么拥有一个可重用的 `ArticleItem` 组件是有益的。接下来，我们将添加文章的标记移动到自己的组件中。
- en: Implementing an AddArticle component
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现添加文章组件
- en: 'Now that we’re done with the article list, it’s time to think about the form
    controls used to add a new article. Let’s implement a component for this aspect
    of the feature:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了文章列表，是时候考虑用于添加新文章的表单控件了。让我们为这个功能方面实现一个组件：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, our feature component only needs to render `<AddArticle>` and `<ArticleList>`
    components:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的功能组件只需要渲染 `<AddArticle>` 和 `<ArticleList>` 组件：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The focus of this component is on the feature data, while it defers to other
    components for rendering UI elements. In the next section, we’ll look at how render
    props make it possible to pass components around as properties instead of directly
    importing them as dependencies.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件的焦点在于功能数据，而它将渲染 UI 元素的任务委托给其他组件。在下一节中，我们将探讨渲染属性如何使得将组件作为属性传递而不是直接作为依赖项导入成为可能。
- en: Render props
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染属性
- en: Imagine implementing a feature that is composed of several smaller components,
    like what you’ve been working on in this chapter. The `MyFeature` component depends
    on `ArticleList` and `AddArticle`. Now, imagine using `MyFeature` in different
    parts of your application where it makes sense to use a different implementation
    of `ArticleList` or `AddArticle`. The fundamental challenge is substituting one
    component for another.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下实现一个由几个较小的组件组成的功能，就像你在本章中一直在做的那样。`MyFeature` 组件依赖于 `ArticleList` 和 `AddArticle`。现在，想象一下在不同的应用部分使用
    `MyFeature`，在这些部分使用不同的 `ArticleList` 或 `AddArticle` 实现是有意义的。基本挑战是替换一个组件为另一个组件。
- en: '**Render props** are a nice way to address this challenge. The idea is that
    you pass a property to your component whose value is a function that returns a
    component to render. This way, instead of having the feature component directly
    depend on its child components, you can configure them as you like; they pass
    them in as render prop values. Let’s look at an example. Instead of having `MyFeature`
    directly depend on `AddArticle` and `ArticleList`, you can pass them as render
    props. Here’s what the `MyFeature` looks like when it’s using render props to
    fill in the holes where `add` used to be:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**渲染属性** 是解决这个挑战的好方法。其思路是，你向你的组件传递一个属性，其值是一个返回要渲染的组件的函数。这样，你就可以配置它们，而不是让功能组件直接依赖于其子组件；它们将它们作为渲染属性值传递。让我们看看一个例子。与其让
    `MyFeature` 直接依赖于 `AddArticle` 和 `ArticleList`，不如将它们作为渲染属性传递。以下是 `MyFeature` 使用渲染属性填充
    `add` 之前所在空缺处的样子：'
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `addArticle()` and `articleList()` functions are called with the same property
    values that would have been passed to `<AddArticle>` and `<ArticleList>`, respectively.
    The difference now is that this module no longer imports `AddArticle` or `ArticleList`
    as dependencies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`addArticle()` 和 `articleList()` 函数使用与 `<AddArticle>` 和 `<ArticleList>` 分别传递的相同属性值被调用。现在的不同之处在于，这个模块不再将
    `AddArticle` 或 `ArticleList` 作为依赖项导入。'
- en: 'Now, let’s take a look at the `main.js` file where `<MyFeature>` is rendered:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `<MyFeature>` 被渲染的 `main.js` 文件：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There’s a lot more going on here now than there was when it was just `<MyFeature>`
    being rendered. Let’s break down why that is. Here is where you pass the `addArticle`
    and `articleList` render props. These prop values are functions that accept argument
    values from `MyComponent`. For example, the `onClickRemove()` function comes from
    `MyFeature` and is used to change the state of that component. You can use the
    **render prop** function to pass this to the component that will be rendered,
    along with any other values. The return value of these functions is what is ultimately
    rendered.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与仅仅渲染 `<MyFeature>` 时相比，这里现在发生的事情要多得多。让我们分析一下为什么会这样。这是你传递 `addArticle` 和 `articleList`
    渲染属性的地方。这些属性值是接受来自 `MyComponent` 的参数值的函数。例如，`onClickRemove()` 函数来自 `MyFeature`，并用于改变该组件的状态。你可以使用
    **渲染属性** 函数将此传递给将要渲染的组件，以及任何其他值。这些函数的返回值是最终要渲染的内容。
- en: 'In this section, you learned that by passing render property values: functions
    that render JSX markup: you can avoid hardcoding dependencies in places where
    you might want to share functionality. Passing a different property value to a
    component is usually easier than changing the dependencies used by a given module.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解到通过传递渲染属性值：渲染 JSX 标记的函数，你可以避免在可能想要共享功能的地方硬编码依赖项。向组件传递不同的属性值通常比更改给定模块使用的依赖项更容易。
- en: Rendering component trees
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染组件树
- en: Let’s take a moment to reflect on what we’ve accomplished so far in this chapter.
    The feature component that was once monolithic ended up focusing almost entirely
    on the state data. It handled the initial state and handled transforming the state
    and it would handle network requests that fetch state, if there were any. This
    is a typical container component in a React application, and it’s the starting
    point for data.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间回顾一下本章到目前为止所取得的成果。曾经是单体的功能组件最终几乎完全专注于状态数据。它处理初始状态，处理转换状态，并且如果有的话，它会处理获取状态的网络请求。这是一个典型的React应用程序中的容器组件，也是数据的起点。
- en: 'The new components that you implemented to better compose the feature were
    the recipients of this data. The difference between these components and their
    container is that they only care about the properties that are passed into them
    at the time they’re rendered. In other words, they only care about data snapshots
    at a particular point in time. From here, these components might pass the property
    data into their own child components as properties. The generic pattern for composing
    React components is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你为了更好地组合功能而实现的新的组件是这些数据的接收者。这些组件与它们的容器之间的区别在于，它们只关心在渲染时传入它们的属性。换句话说，它们只关心特定时间点的数据快照。从这里，这些组件可能会将属性数据作为属性传递给它们自己的子组件。组合React组件的通用模式如下：
- en: '![](img/B19636_05_03.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_05_03.png)'
- en: 'Figure 5.3: A pattern for composing larger React components from smaller components'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：从较小组件组合较大React组件的模式
- en: The **container component** will typically contain one direct **child**. In
    this diagram, you can see that the container has either an **item detail component**
    or a **list component**. Of course, there will be variations in these two categories,
    as every application is different. This generic pattern has three levels of component
    composition. Data flows in one direction from the **container** all the way down
    to the **utility** components.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器组件**通常包含一个直接**子组件**。在这个图中，你可以看到容器包含一个**项目详情组件**或一个**列表组件**。当然，这两个类别中会有所变化，因为每个应用程序都是不同的。这种通用模式有三个组件组合级别。数据从**容器**单向流向底层的**实用组件**。'
- en: Once you add more than three layers, the application architecture becomes difficult
    to comprehend. There will be the odd case where you’ll need to add four layers
    of React components but, as a rule of thumb, you should avoid this.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加超过三层，应用程序架构就难以理解。可能会有需要添加四层React组件的异常情况，但作为一个经验法则，你应该避免这样做。
- en: Feature components and utility components
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能组件和实用组件
- en: In the **monolithic component** example that we have worked on in this chapter,
    you started with a single component that was entirely focused on a feature. This
    means that the component has very little utility elsewhere in the application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论的**单体组件**示例中，你从一个完全专注于一个功能的单一组件开始。这意味着该组件在应用程序的其他地方几乎没有实用性。
- en: The reason for this is that top-level components deal with the application state.
    **Stateful components** are difficult to use in any other context. As you refactored
    the monolithic feature component, you created new components that moved further
    away from the data. The general rule is that the further your components move
    from stateful data, the more utility they have because their property values could
    be passed in from anywhere in the application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于顶层组件处理应用程序状态。**有状态组件**在其它任何上下文中都难以使用。随着你对单体功能组件进行重构，你创建了新的组件，这些组件进一步远离了数据。一般规则是，你的组件离有状态数据越远，它们的实用性就越大，因为它们的属性值可以从应用程序的任何地方传入。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter was about avoiding a monolithic component design. However, monoliths
    are often a necessary starting point in the design of any React component.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于避免单体组件设计。然而，单体通常是在任何React组件设计中必要的起点。
- en: You began by learning about how the different HTML elements have varying degrees
    of utility. Next, you learned about the issues with monolithic React components
    and walked through the implementation of a monolithic component.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先学习了不同HTML元素具有不同程度的实用性。接下来，你了解了单体React组件的问题，并了解了单体组件的实现。
- en: Then, you spent several sections learning how to refactor the monolithic component
    into a more sustainable design. From this exercise, you learned that container
    components should only have to think in terms of handling state, while smaller
    components have more utility because their property values can be passed from
    anywhere. You also learned that you could use render props for better control
    over component dependencies and substitution.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你花费了几个章节学习如何将单体组件重构为更可持续的设计。从这个练习中，你了解到容器组件只需考虑处理状态，而较小的组件因为它们的属性值可以从任何地方传递，所以具有更多的实用性。你还了解到，你可以使用渲染属性来更好地控制组件依赖和替换。
- en: In the next chapter, you’ll learn about the component props validation and type
    checking.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于组件属性验证和类型检查的内容。
