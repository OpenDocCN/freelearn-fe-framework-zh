- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Styling React Apps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式化React应用
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下几件事情：
- en: Style JSX elements via inline style assignments or with the help of CSS classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过内联样式赋值或使用CSS类来样式化JSX元素
- en: Set inline and class styles, both statically and dynamically or conditionally
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置内联和类样式，无论是静态的、动态的还是条件性的
- en: Build reusable components that allow for style customization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建可重用的组件，允许进行样式定制
- en: Utilize CSS Modules to scope styles to components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用CSS模块将样式限制在组件范围内
- en: Understand the core idea behind `styled-components` , a third-party CSS-in-JS
    library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`styled-components`这个第三方CSS-in-JS库背后的核心思想
- en: Use Tailwind CSS to style React apps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Tailwind CSS来样式化React应用
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: React.js is a frontend JavaScript library. This means that it’s all about building
    (web) user interfaces and handling user interaction.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: React.js是一个前端JavaScript库。这意味着它全部关于构建（Web）用户界面和处理用户交互。
- en: Up to this point, this book has extensively explored how React can be used to
    add interactivity to a web app. State, event handling, and dynamic content are
    key concepts relating to this.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书已经广泛探讨了如何使用React为Web应用添加交互性。状态、事件处理和动态内容是与这一主题相关的关键概念。
- en: Of course, websites and web apps are not just about interactivity. You could
    build an amazing web app that offers interactive and engaging features, and yet
    it may still be unpopular if it lacks appealing visuals. Presentation is key,
    and the web is no exception.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，网站和Web应用不仅仅是关于交互性的。你可以构建一个提供交互性和吸引人的功能的出色Web应用，但如果它缺乏吸引人的视觉元素，它可能仍然不受欢迎。展示是关键，网络也不例外。
- en: Therefore, like all other apps and websites, React apps and websites need proper
    styling, and when working with web technologies, **Cascading Style Sheets** (
    **CSS** ) is the language of choice.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，就像所有其他应用和网站一样，React应用和网站需要适当的样式，并且在处理Web技术时，**层叠样式表**（**CSS**）是首选的语言。
- en: However, this book is not about CSS. It won’t explain or teach you how to use
    CSS, as there are dedicated, better resources for that (e.g., the free CSS guides
    at [https://developer.mozilla.org/en-US/docs/Learn/CSS](https://developer.mozilla.org/en-US/docs/Learn/CSS)
    ). But this chapter will teach you how to combine CSS code with JSX and React
    concepts, such as state and props. You will learn how to add styles to your JSX
    elements, style custom components, and make those components’ styles configurable.
    This chapter will also teach you how to set styles dynamically and conditionally
    and explore popular third-party libraries, like styled-components and Tailwind
    CSS, that can be used for styling.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这本书不是关于CSS的。它不会解释或教你如何使用CSS，因为已经有针对这一主题的专用、更好的资源（例如，[https://developer.mozilla.org/en-US/docs/Learn/CSS](https://developer.mozilla.org/en-US/docs/Learn/CSS)
    上的免费CSS指南）。但本章将教你如何将CSS代码与JSX和React概念（如状态和属性）结合使用。你将学习如何为你的JSX元素添加样式，样式自定义组件，并使这些组件的样式可配置。本章还将教你如何动态和条件性地设置样式，并探索流行的第三方库，如styled-components和Tailwind
    CSS，它们可用于样式化。
- en: How Does Styling Work in React Apps?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React应用中的样式是如何工作的？
- en: Up to this point, the apps and examples presented in this book have only had
    minimal styling. But they at least had some basic styling, rather than no styling
    at all.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中展示的应用和示例都只有最基本的美化。但至少它们有一些基本的美化，而不是完全没有美化。
- en: But how was that styling added? How can styles be added to user interface elements
    (such as DOM elements) when using React?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，那种样式是如何添加的？在使用React时，如何将样式添加到用户界面元素（如DOM元素）中？
- en: The short answer is, “Just as you would to non-React apps.” You can add CSS
    styles and classes to JSX elements just as you would to regular HTML elements.
    And in your CSS code, you can use all the features and selectors you know from
    CSS. There are no React-specific changes you have to make when writing CSS code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是，“就像你对非React应用所做的那样。”你可以像对常规HTML元素一样，将CSS样式和类添加到JSX元素中。在你的CSS代码中，你可以使用你从CSS中知道的所有特性和选择器。在编写CSS代码时，你不需要做出任何特定的React更改。
- en: The code examples used so far (i.e., the activities or other examples hosted
    on GitHub) always used regular CSS styling, with the help of CSS selectors, to
    apply some basic styles to the final user interface. Those CSS rules were defined
    in an `index.css` file, which is part of every newly created React project (when
    using Vite for project creation, as shown in *Chapter 1* , *React – What and Why*
    ).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止使用的代码示例（即GitHub上托管的活动或其他示例）总是使用常规CSS样式，借助CSS选择器，将一些基本样式应用到最终用户界面。这些CSS规则定义在一个`index.css`文件中，它是每个新创建的React项目的一部分（当使用Vite创建项目时，如*第一章*，*React
    – 什么和为什么*所示）。
- en: 'For example, here’s the `index.css` file used in *Activity 5.2* of the previous
    chapter ( *Chapter 5* , *Rendering Lists and Conditional Content* ):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是前一章（*第五章*，*渲染列表和条件内容*）的*活动5.2*中使用的`index.css`文件：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The actual CSS code and its meaning are not important (as mentioned, this book
    is not about CSS). However, what is important is the fact that this code contains
    no JavaScript or React code at all. As mentioned, the CSS code you write is totally
    independent of the fact that you’re using React in your app.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的CSS代码及其含义并不重要（如前所述，这本书不是关于CSS的）。然而，重要的是这个代码完全不包含JavaScript或React代码。如前所述，你编写的CSS代码完全独立于你在应用中使用React的事实。
- en: The more interesting question is, how is that code actually applied to the rendered
    web page? How is it imported into that page?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的问题是，这些代码实际上是如何应用到渲染的网页上的？它是如何导入到该页面的？
- en: 'Normally, you would expect style file imports (via `<link href="…">` ) inside
    of the HTML files that are served. Since React apps are typically about building
    **single-page applications** (see *Chapter 1* , *React – What and Why* ), you
    only have one HTML file—the `index.html` file. But if you inspect that file, you
    won’t find any `<link href="…">` import that would point to the `index.css` file
    (only some other `<link>` element that imports a favicon), as you can see in the
    following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会在提供的HTML文件内部期望找到样式文件导入（通过`<link href="…">`）。由于React应用通常是关于构建**单页应用**（见*第一章*，*React
    – 什么和为什么*），你只有一个HTML文件——`index.html`文件。但如果你检查该文件，你不会找到任何指向`index.css`文件的`<link
    href="…">`导入（只有一些其他导入favicon的`<link>`元素），如下面的截图所示：
- en: '![img](img/B31339_06_01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_06_01.png)'
- en: 'Figure 6.1: The <head> section of the index.html file contains no <link> import
    that points to the index.css file'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：`index.html`文件的`<head>`部分不包含指向index.css文件的`<link>`导入
- en: How are the styles defined in `index.css` imported and applied then?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`index.css`中的样式是如何导入并应用的？
- en: 'You find an `import` statement in the root entry file (this is the `main.jsx`
    file in projects generated via `Vite` ):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在根入口文件（这是通过`Vite`生成的项目中的`main.jsx`文件）中，你可以找到一个`import`语句：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `import './index.css';` statement leads to the CSS file being imported and
    the defined CSS code being applied to the rendered web page.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`import ''./index.css'';`语句导致CSS文件被导入，并且定义的CSS代码被应用到渲染的网页上。'
- en: It is worth noting that this is not standard JavaScript behavior. You can’t
    import CSS files into JavaScript—at least, not if you’re just using vanilla JavaScript.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这不是标准的JavaScript行为。你不能将CSS文件导入到JavaScript中——至少，如果你只是使用纯JavaScript的话。
- en: CSS works this way in React apps because the code is transpiled before it’s
    loaded into the browser. Therefore, you won’t find that `import` statement in
    the final JavaScript code that’s executed in the browser. Instead, during the
    **transpilation process** , the transpiler identifies the CSS import, removes
    it from the JavaScript file, and injects the CSS code (or an appropriate link
    to the potentially bundled and optimized CSS file) into the `index.html` file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在React应用中，CSS以这种方式工作，因为代码在加载到浏览器之前会被转换。因此，你不会在浏览器中执行的最终JavaScript代码中找到那个`import`语句。相反，在**转换过程**中，转换器识别CSS导入，将其从JavaScript文件中移除，并将CSS代码（或指向可能捆绑和优化的CSS文件的适当链接）注入到`index.html`文件中。
- en: You can confirm this by inspecting the rendered **Document Object Model** (
    **DOM** ) content of the loaded web page in the browser.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在浏览器中检查加载的网页的渲染**文档对象模型**（**DOM**）内容来确认这一点。
- en: 'To do so, select the **Elements** tab in developer tools in Chrome, as shown
    below:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请选择Chrome开发者工具中的**元素**选项卡，如下所示：
- en: '![img](img/B31339_06_02.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_06_02.png)'
- en: 'Figure 6.2: Injected CSS <style> elements can be found in the DOM at runtime'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：在运行时DOM中可以找到注入的CSS `<style>` 元素
- en: You can define any styles you want to apply to your HTML elements (that is,
    to your JSX elements in your components) directly inside of the `index.css` file,
    or in any other CSS files that are imported by the `index.css` file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在`index.css`文件中，或在由`index.css`文件导入的任何其他CSS文件中定义要应用于你的HTML元素（即你的组件中的JSX元素）的任何样式。
- en: You could also add additional CSS import statements, pointing at other CSS files,
    to the `main.jsx` file or any other JavaScript files (including files that store
    components). However, it is important to keep in mind that CSS styles are always
    global. No matter whether you import a CSS file into `main.jsx` or a component-specific
    JavaScript file, the styles defined in that CSS file will be applied globally.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将额外的CSS导入语句添加到`main.jsx`文件或任何其他JavaScript文件（包括存储组件的文件）中。然而，重要的是要记住，CSS样式始终是全局的。无论你是否将CSS文件导入到`main.jsx`或组件特定的JavaScript文件中，该CSS文件中定义的样式都将应用于全局。
- en: That means that styles defined in a `goal-list.css` file, which may be imported
    in a `GoalList.jsx` file, could still affect JSX elements defined in a totally
    different component. Later in this chapter, you will learn about techniques that
    allow you to prevent accidental style clashes and implement style scoping.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在`goal-list.css`文件中定义的样式，即使可能被导入到`GoalList.jsx`文件中，也可能影响在完全不同的组件中定义的JSX元素。在本章的后面部分，你将了解到一些技术，这些技术可以帮助你防止意外的样式冲突并实现样式作用域。
- en: Using Inline Styles
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内联样式
- en: You can use CSS files to define global CSS styles and use different CSS selectors
    to target different JSX elements (or groups of elements).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用CSS文件来定义全局CSS样式，并使用不同的CSS选择器来针对不同的JSX元素（或元素组）。
- en: But even though it’s typically discouraged, you can also set inline styles directly
    on JSX elements via the `style` prop.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常不建议这样做，但你也可以通过`style`属性直接在JSX元素上设置内联样式。
- en: '**Note**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'If you’re wondering why inline styles are discouraged, the following discussion
    on Stack Overflow provides many arguments against inline styles: [https://stackoverflow.com/questions/2612483/whats-so-bad-about-in-line-css](https://stackoverflow.com/questions/2612483/whats-so-bad-about-in-line-css)
    .'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么不建议使用内联样式，Stack Overflow上的以下讨论提供了许多反对内联样式的论点：[https://stackoverflow.com/questions/2612483/whats-so-bad-about-in-line-css](https://stackoverflow.com/questions/2612483/whats-so-bad-about-in-line-css)。
- en: 'Setting inline styles in JSX code works like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSX代码中设置内联样式的方式如下：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the `style` prop is added to the `<li>` element (all JSX elements
    support the `style` prop), and both the `color` and `size` properties of the text
    are set via CSS.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，向`<li>`元素（所有JSX元素都支持`style`属性）添加了`style`属性，并通过CSS设置了文本的`color`和`size`属性。
- en: 'This approach differs from what you would use to set inline styles when working
    with just HTML (instead of JSX). When using plain HTML, you would set inline styles
    like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与仅使用HTML（而不是JSX）设置内联样式的方法不同。当使用纯HTML时，你会这样设置内联样式：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The difference is that the `style` prop expects to receive a JavaScript object
    that contains the style settings—not a plain string. This is something that must
    be kept in mind, since, as mentioned previously, inline styles typically aren’t
    used that often.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，`style`属性期望接收一个包含样式设置的JavaScript对象——而不是一个普通的字符串。这是必须记住的，因为，如前所述，内联样式通常不常用。
- en: Since the `style` object is an object and not a plain string, it is passed as
    a value between curly braces—just as an array, a number, or any other non-string
    value would have to be set between curly braces (anything between double or single
    quotes is treated as a string value). Therefore, it’s worth noting that the preceding
    example does not use any kind of special “double curly-braces” syntax and, instead,
    uses one pair of curly braces to surround the non-string value and another pair
    to surround the object data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`style`对象是一个对象而不是一个普通字符串，它被作为值放在大括号之间——就像数组、数字或任何其他非字符串值一样必须在大括号之间设置（双引号或单引号之间的任何内容都被视为字符串值）。因此，值得注意的是，前面的例子没有使用任何特殊的“双大括号”语法，而是使用一对大括号来包围非字符串值，另一对大括号来包围对象数据。
- en: Inside the `style` object, any CSS style properties supported by the underlying
    DOM element can be set. The property names are those defined for the HTML element
    (i.e., the same CSS property names you could target and set with vanilla JavaScript,
    when mutating an HTML element).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`style`对象内部，可以设置底层DOM元素支持的任何CSS样式属性。属性名称是针对HTML元素定义的（即，与你可以用纯JavaScript针对和设置的目标和设置的CSS属性名称相同），当修改HTML元素时。
- en: When setting styles in JavaScript code (as with the `style` prop shown above),
    JavaScript CSS property names have to be used. Those names are similar to the
    CSS property names you would use in CSS code but not quite the same. Differences
    occur for property names that consist of multiple words (e.g., `font-size` ).
    When targeting such properties in JavaScript, camelCase notation must be used
    ( `fontSize` instead of `font-size` ), as JavaScript properties cannot contain
    dashes. Alternatively, you could wrap the property name with quotes ( `'font-size'`
    ).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当在JavaScript代码中设置样式（如上面显示的`style`属性）时，必须使用JavaScript CSS属性名称。这些名称与你在CSS代码中使用的CSS属性名称相似，但并不完全相同。当针对由多个单词组成的属性名称（例如，`font-size`）时，会出现差异。在JavaScript中针对此类属性时，必须使用驼峰式命名法（`fontSize`而不是`font-size`），因为JavaScript属性不能包含破折号。或者，你也可以用引号包裹属性名称（`'font-size'`）。
- en: '**Note**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You can find more information about the HTML element style property and JavaScript
    CSS property names here: [https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style)
    .'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到有关HTML元素样式属性和JavaScript CSS属性名称的更多信息：[https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style)。
- en: Setting Styles via CSS Classes
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过CSS类设置样式
- en: As mentioned, using inline styles is typically discouraged, and therefore, CSS
    styles defined in CSS files (or between `<style>` tags in the document `<head>`
    section) are preferred.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，通常不建议使用内联样式，因此，在CSS文件中定义的CSS样式（或在文档`<head>`部分的`<style>`标签之间）更受欢迎。
- en: 'In those CSS code blocks, you can write regular CSS code and use CSS selectors
    to apply CSS styles to certain elements. You could, for example, style all `<li>`
    elements on a page (no matter which component may have rendered them) like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些CSS代码块中，你可以编写常规CSS代码并使用CSS选择器将CSS样式应用于特定元素。例如，你可以这样设置页面上的所有`<li>`元素（无论哪个组件可能渲染了它们）的样式：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As long as this code gets added to the page (because the CSS file in which it
    is defined is imported into `main.jsx` , for instance), the styling will be applied.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 只要此代码被添加到页面中（因为定义它的CSS文件被导入到`main.jsx`等），样式就会被应用。
- en: 'Quite frequently, developers aim to target specific elements or groups of elements.
    Instead of applying some style to all `<li>` elements on a page, the goal could
    be to only target the `<li>` elements that are part of a specific list. Consider
    this HTML structure that’s rendered to the page (it may be split across multiple
    components, but this doesn’t matter here):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者经常试图针对特定的元素或元素组。而不是将某些样式应用于页面上的所有`<li>`元素，目标可能是仅针对属于特定列表的`<li>`元素。考虑以下渲染到页面的HTML结构（它可能分布在多个组件中，但这在这里并不重要）：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the navigation list items will most likely not receive the
    same styling as the `course goal` list items (and vice versa).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，导航列表项很可能不会收到与`course goal`列表项相同的样式（反之亦然）。
- en: 'Typically, this problem would be solved with the help of CSS classes and the
    class selector. You could adjust the HTML code like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个问题会借助CSS类和类选择器来解决。你可以像这样调整HTML代码：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following CSS code would then only target the course goal list items but
    not the navigation list items:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下CSS代码只会针对课程目标列表项，而不会针对导航列表项：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This approach almost works in React apps as well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在React应用中也几乎同样适用。
- en: 'However, if you try to add CSS classes to JSX elements, as shown in the previous
    example, you will face a warning in the browser’s developer tools:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试向JSX元素添加CSS类，如前一个示例所示，你将在浏览器开发者工具中遇到警告：
- en: '![A white background with red text  Description automatically generated](img/B31339_06_03.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![带有红色文字的白色背景，描述自动生成](img/B31339_06_03.png)'
- en: 'Figure 6.3: A warning output by React'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：React输出的警告
- en: 'As illustrated in the preceding figure, you should not add `class` as a prop
    and, instead, use `className` . Indeed, if you swap `class` for `className` as
    a prop name, the warning will disappear, and the class CSS styles will be applied.
    Hence, the proper JSX code looks like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，你不应该将`class`作为属性添加，而应该使用`className`。实际上，如果你将`class`替换为`className`作为属性名，警告就会消失，并且类CSS样式将被应用。因此，正确的JSX代码如下：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But why is React suggesting you use `className` instead of `class` ?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么React建议你使用`className`而不是`class`？
- en: It’s similar to using `htmlFor` instead of `for` when working with `<label>`
    objects (as discussed in *Chapter 4* , *Working with Events and State* ). Just
    like `for` , `class` is a keyword in JavaScript, and therefore, `className` is
    used as a prop name instead.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在处理`<label>`对象时使用`htmlFor`而不是`for`类似（如第4章*处理事件和状态*中讨论的）。就像`for`一样，`class`是JavaScript中的一个关键字，因此，`className`被用作属性名。
- en: Setting Styles Dynamically
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态设置样式
- en: With inline styles and CSS classes (and global CSS styles in general), there
    are various ways of applying styles to elements. Thus far, all examples have shown
    static styles—that is, styles that will never change once a page has been loaded.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联样式和CSS类（以及通常的全局CSS样式），有各种方法可以将样式应用于元素。到目前为止，所有示例都显示了静态样式——也就是说，一旦页面加载完成，样式就不会改变。
- en: 'But while most page elements don’t change their styles after a page is loaded,
    you also typically have some elements that should be styled dynamically or conditionally.
    Here are some examples:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数页面元素在页面加载后不会改变它们的样式，但你通常也有一些元素应该动态或条件性地设置样式。以下是一些示例：
- en: A to-do app where different to-do priorities receive different colors
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个待办事项应用，其中不同的待办事项优先级会收到不同的颜色
- en: An input form where invalid form elements should be highlighted following an
    unsuccessful form submission
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输入表单，其中无效的表单元素应在表单提交失败后突出显示
- en: A web-based game where players can choose colors for their avatars
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基于Web的游戏，玩家可以为他们的头像选择颜色
- en: In such cases, applying static styles is not enough, and dynamic styles should
    be used instead. Setting styles dynamically is straightforward. Again, it’s just
    about applying the key React concepts covered earlier (most importantly, those
    regarding the setting of dynamic values from *Chapter 2* , *Understanding React
    Components and JSX* , and *Chapter 4* , *Working with Events and State* ).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，应用静态样式是不够的，应该使用动态样式。动态设置样式很简单。再次强调，这只是应用之前覆盖的React关键概念（最重要的是第2章*理解React组件和JSX*和第4章*处理事件和状态*中关于设置动态值的内容）。
- en: 'Here’s an example where the color of a paragraph is set dynamically to the
    color that a user enters into an input field:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，其中段落的颜色会动态设置为用户在输入字段中输入的颜色：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The text entered in the `<input>` field is stored in the `enteredColor` state.
    This state is then used to set the `color` CSS property of the `<p>` element dynamically.
    This is achieved by passing a `style` object, with the `color` property set to
    the `enteredColor` value as a value to the `style` prop of the `<p>` element.
    The text color of the paragraph is, therefore, set dynamically to the value entered
    by the user (assuming that users enter valid CSS color values into the `<input>`
    field).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<input>`字段中输入的文本存储在`enteredColor`状态中。然后使用此状态动态设置`<p>`元素的`color` CSS属性。这是通过传递一个`style`对象来实现的，其中`color`属性设置为`enteredColor`的值，作为`<p>`元素的`style`属性的值。因此，段落的文本颜色会动态设置为用户输入的值（假设用户将有效的CSS颜色值输入到`<input>`字段中）。
- en: 'You’re not limited to inline styles; CSS classes can also be set dynamically,
    as in the following snippet:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅限于内联样式；CSS类也可以动态设置，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, the `chosenPriority` state will alternate between `low-prio`
    and `high-prio` , depending on the drop-down selection. The state value is then
    output as text inside the paragraph and is also used as a dynamic CSS class name,
    applied to the `<p>` element. For this to have any visual effect, there must,
    of course, be `low-prio` and `high-prio` CSS classes defined in some CSS file
    or `<style>` block. For example, consider the following code in `index.css` :'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`chosenPriority`状态将在`low-prio`和`high-prio`之间交替，取决于下拉选择。然后状态值作为段落内的文本输出，也用作动态CSS类名，应用于`<p>`元素。当然，为了产生任何视觉效果，必须在某个CSS文件或`<style>`块中定义`low-prio`和`high-prio`
    CSS类。例如，考虑以下`index.css`中的代码：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Conditional Styles
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件样式
- en: Closely related to **dynamic styles** are **conditional styles** . In fact,
    ultimately, they are really just a special case of dynamic styles. In the previous
    examples, inline style values and class names were set as equal to values chosen
    or entered by the user.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与**动态样式**密切相关的是**条件样式**。实际上，它们最终只是动态样式的特殊案例。在先前的例子中，内联样式值和类名被设置为等于用户选择或输入的值。
- en: 'However, you can also derive styles or class names dynamically based on different
    conditions, as shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你也可以根据不同的条件动态地派生样式或类名，如下所示：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, a wrapper component around the standard `<input>` element is
    built. (For more information about wrapper components, see *Chapter 3* , *Components
    and Props* .) The main purpose of this wrapper component is to set some default
    styles for the wrapped `<input>` element. The **wrapper component** is built to
    provide a pre-styled input element that can be used anywhere in the app. Indeed,
    providing pre-styled elements is one of the most common and popular use cases
    for building wrapper components.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，围绕标准`<input>`元素构建了一个包装组件。（有关包装组件的更多信息，请参阅*第3章*，*组件和属性*。）这个包装组件的主要目的是为包装的`<input>`元素设置一些默认样式。**包装组件**被构建为提供可以用于应用中任何位置的预样式输入元素。实际上，提供预样式元素是构建包装组件最常见和最受欢迎的使用场景之一。
- en: In this concrete example, the default styles are applied using CSS classes.
    If the `isValid` prop value is `true` and the value of the `isRecommended` prop
    is `false` , the `input-default` CSS class will be applied to the `<input>` element,
    since neither of the two `if` statements become active.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个具体的例子中，默认样式是通过CSS类应用的。如果`isValid`属性值为`true`且`isRecommended`属性值为`false`，则`input-default`
    CSS类将应用于`<input>`元素，因为两个`if`语句都没有激活。
- en: If `isRecommended` is `true` (but `isValid` is `false` ), the `input-recommended`
    CSS class would be applied. If `isValid` is `false` , the `input-invalid` class
    is added instead. Of course, the CSS classes must be defined in some imported
    CSS files (for example, in `index.css` ).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isRecommended`为`true`（但`isValid`为`false`），则应用`input-recommended` CSS类。如果`isValid`为`false`，则添加`input-invalid`类。当然，CSS类必须在某些导入的CSS文件中定义（例如，在`index.css`中）。
- en: 'Inline styles could be set in a similar way, as shown in the following snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 内联样式也可以以类似的方式设置，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, the background color of the `<input>` element is set conditionally,
    based on the values received via the `isValid` and `isRecommended` props.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`<input>`元素的背景颜色是基于通过`isValid`和`isRecommended`属性接收到的值有条件地设置的。
- en: Combining Multiple Dynamic CSS Classes
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合多个动态CSS类
- en: In previous examples, a maximum of one CSS class was set dynamically at a time.
    However, it’s not uncommon to encounter scenarios where multiple dynamically derived
    CSS classes should be merged and added to an element.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，一次只能动态设置一个CSS类。然而，遇到需要合并和添加到元素中的多个动态派生CSS类的情况并不少见。
- en: 'Consider the following example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, two CSS classes are added to `<p>` by simply combining them into one
    string. Alternatively, you could directly add a string with the two classes like
    this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过简单地将它们组合成一个字符串，就可以向`<p>`元素添加两个CSS类。或者，你也可以直接添加包含两个类的字符串，如下所示：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code will work, but what if the goal is to also add another class name
    to the list of classes, based on the `isImportant` prop value (which is ignored
    in the preceding example)?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将能正常工作，但如果目标是基于`isImportant`属性值（在先前的例子中被忽略）向类列表中添加另一个类名呢？
- en: 'Replacing the default list of classes is easy, as you have learned:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 替换默认的类列表很容易，正如你所学到的：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But what if the goal is not to replace the list of default classes? What if
    `text-important` should be added as a class to `<p>` , in addition to `text-default`
    and `text-expl` ?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果目标不是替换默认类列表呢？如果`text-important`应该作为类添加到`<p>`元素中，除了`text-default`和`text-expl`呢？
- en: 'The `className` prop expects to receive a string value, so passing an array
    of classes isn’t an option. However, you can simply merge multiple classes into
    one string, and there are a couple of different ways to do that:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`className`属性期望接收一个字符串值，因此传递一个类数组不是一种选择。然而，你可以简单地合并多个类成一个字符串，并且有几种不同的方法可以做到这一点：'
- en: 'String concatenation:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串连接：
- en: '[PRE17]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using a template literal:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板字符串：
- en: '[PRE18]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Joining an array:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组连接：
- en: '[PRE19]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These examples could all be used inside the `if` statement ( `if (isImportant)`
    ) to conditionally add the `text-important` class, based on the `isImportant`
    prop value. All three approaches, as well as variations of these approaches, will
    work because all these approaches produce a string. In general, any approach that
    yields a string can be used to generate values for `className` .
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例都可以在`if`语句（`if (isImportant)`）中使用，根据`isImportant`属性值有条件地添加`text-important`类。所有这三种方法以及这些方法的变体都将工作，因为所有这些方法都产生一个字符串。一般来说，任何产生字符串的方法都可以用来生成`className`的值。
- en: Merging Multiple Inline Style Objects
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并多个内联样式对象
- en: When working with inline styles, instead of CSS classes, you can also merge
    multiple style objects. The main difference is that you don’t produce a string
    with all values but, rather, an object with all combined style values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理内联样式时，除了CSS类，您还可以合并多个样式对象。主要区别在于您不生成包含所有值的字符串，而是一个包含所有组合样式值的对象。
- en: 'This can be achieved by using standard JavaScript techniques to merge multiple
    objects into one object. The most popular technique involves using the **spread
    operator** , as shown in this example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用标准的JavaScript技术将多个对象合并为一个对象来实现。最流行的技术涉及使用**扩展运算符**，如下例所示：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, you will observe that `defaultStyle` is an object with a `color` property.
    If `isImportant` is `true` , it’s replaced with an object that contains all the
    properties it had before (via the spread operator, `...defaultStyle` ) as well
    as the `backgroundColor` property.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您会注意到`defaultStyle`是一个具有`color`属性的对象。如果`isImportant`为`true`，它将被替换为一个包含所有先前属性（通过扩展运算符`...defaultStyle`）以及`backgroundColor`属性的对象。
- en: '**Note**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: For more information on the function and use of the spread operator, see *Chapter
    5* , *Rendering Lists and Conditional Content* .
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关于扩展运算符的功能和使用，请参阅*第5章*，*渲染列表和条件内容*。
- en: Building Components with Customizable Styles
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可定制样式构建组件
- en: As you are aware by now, components can be reused. This is supported by the
    fact that they can be configured via props. The same component can be used in
    different places on a page with different configurations to yield a different
    output.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在所知，组件可以被重用。这一点得到了支持，因为它们可以通过属性进行配置。同一个组件可以在页面的不同位置使用不同的配置来产生不同的输出。
- en: Since styles can be set both statically and dynamically, you can also make the
    styling of your components customizable. The preceding examples already show such
    customization in action; for example, the `isImportant` prop was used in the previous
    example to conditionally add a `red` background color to a paragraph. The `ExplanationText`
    component therefore already allows indirect style customization via the `isImportant`
    prop.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于样式可以静态和动态设置，您也可以使组件的样式可定制。前面的示例已经展示了这种定制的作用；例如，在先前的示例中，`isImportant`属性被用来有条件地向段落添加红色背景色。因此，`ExplanationText`组件已经通过`isImportant`属性允许间接的样式定制。
- en: 'Besides this form of customization, you could also build components that accept
    props already holding CSS class names or style objects. For example, the following
    wrapper component accepts a `className` prop that is merged with a default CSS
    class ( `btn` ):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种形式的定制外，您还可以构建接受已持有CSS类名或样式对象的属性的组件。例如，以下包装组件接受一个`className`属性，该属性与默认CSS类（`btn`）合并：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This component could be used in another component in the following way:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件可以用以下方式在另一个组件中使用：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If used like this, the final `<button>` element would receive both the `btn`
    as well as `btn-alert` classes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样使用，最终的`<button>`元素将同时接收`btn`和`btn-alert`类。
- en: You don’t have to use `className` as a prop name; any name can be used, since
    it’s your component. However, it’s not a bad idea to use `className` because you
    can then keep your mental model of setting CSS classes via `className` (for built-in
    components, you will not have that choice).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必使用`className`作为属性名；任何名称都可以使用，因为它是您的组件。然而，使用`className`并不是一个坏主意，因为这样您可以保持通过`className`设置CSS类的心理模型（对于内置组件，您将没有这样的选择）。
- en: 'Instead of merging prop values with default CSS class names or style objects,
    you can overwrite default values. This allows you to build components that come
    with some styling out of the box without enforcing that styling:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与将属性值与默认CSS类名或样式对象合并不同，您可以覆盖默认值。这允许您构建一些带有默认样式的组件，而无需强制使用该样式：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can see how all the different concepts covered throughout this book are
    coming together here: props allow customization, values can be set, swapped, and
    changed dynamically and conditionally, and therefore, highly reusable and configurable
    components can be built.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，本书中涵盖的所有不同概念是如何在这里汇聚的：属性允许定制，值可以设置、交换和动态条件地更改，因此可以构建高度可重用和可配置的组件。
- en: Customization with Fixed Configuration Options
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用固定配置选项进行定制
- en: Besides exposing props such as `className` or `style` , which are merged with
    other classes or styles defined inside a component function, you can also build
    components that apply different styles or class names based on other prop values.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了暴露`className`或`style`等属性，这些属性会与组件函数内部定义的其他类或样式合并外，你还可以构建基于其他属性值应用不同样式或类名的组件。
- en: This has been shown in the previous examples where props such as `isValid` or
    `isImportant` were used to apply certain styles conditionally. This way of applying
    styles could, therefore, be called “indirect styling” (although this is not an
    official term).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这在前面的示例中已经展示过，其中使用了`isValid`或`isImportant`等属性来有条件地应用某些样式。因此，这种应用样式的做法可以被称为“间接样式”（尽管这不是一个官方术语）。
- en: Both approaches can shine in different circumstances. For wrapper components,
    for example, accepting `className` or `style` props (which can be merged with
    other styles inside the component) enables the component to be used just like
    a built-in component (e.g., like the component it wraps). Indirect styling, on
    the other hand, can be very useful if you want to build components that provide
    a couple of pre-defined variations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法在不同的环境中都能发挥作用。例如，对于包装组件，接受`className`或`style`属性（这些可以在组件内部与其他样式合并）使得组件可以像内置组件一样使用（例如，像它所包装的组件）。另一方面，如果你想要构建提供一些预定义变体的组件，间接样式可能非常有用。
- en: A good example is a text box that provides two built-in themes that can be selected
    via a specific prop.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是，一个文本框提供了两个内置主题，可以通过特定的属性进行选择。
- en: '![A screenshot of a phone  Description automatically generated](img/B31339_06_04.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![手机的截图  自动生成的描述](img/B31339_06_04.png)'
- en: 'Figure 6.4: A TextBox is styled based on the value of the “mode” prop'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：根据“mode”属性的值对TextBox进行样式化
- en: 'The code for the `TextBox` component could look like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextBox`组件的代码可能看起来像这样：'
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This `TextBox` component always yields a paragraph element. If the `mode` prop
    is set to any value other than `'alert'` or `'info'` , the paragraph doesn’t receive
    any special styling. But if `mode` is equal to `'alert'` or `'info'` , specific
    CSS classes are added to the paragraph.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`TextBox`组件始终返回一个段落元素。如果`mode`属性设置为除`'alert'`或`'info'`之外的任何值，则段落不会接收任何特殊样式。但如果`mode`等于`'alert'`或`'info'`，则会向段落添加特定的CSS类。
- en: This component, therefore, doesn’t allow direct styling via some `className`
    or `style` prop that would be merged, but it does offer different variations or
    themes that can be set with the help of a specific prop (the `mode` prop in this
    case).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个组件不允许通过某些`className`或`style`属性进行直接样式化，但它确实提供了不同的变体或主题，可以通过特定的属性（在这种情况下是`mode`属性）来设置。
- en: The Problem with Unscoped Styles
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未限定样式的问题
- en: 'If you consider the different examples you’ve so far dealt with in this chapter,
    there’s one specific use case that occurs quite frequently: styles are relevant
    to a specific component only.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑本章中迄今为止处理的不同示例，那么有一个特定的用例出现得相当频繁：样式仅与特定组件相关。
- en: For example, in the `TextBox` component in the previous section, `'box-alert'`
    and `'box-info'` are CSS classes that are likely only relevant for this specific
    component and its markup. If any other JSX element in the app had a `'box-alert'`
    class applied to it (even though that might be unlikely), it probably shouldn’t
    be styled the same as the `<p>` element in the `TextBox` component.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前一节的`TextBox`组件中，`'box-alert'`和`'box-info'`是可能只与这个特定组件及其标记相关的CSS类。如果应用了`'box-alert'`类的任何其他JSX元素（尽管这不太可能），那么它可能不应该与`TextBox`组件中的`<p>`元素以相同的样式进行样式化。
- en: Styles from different components could clash with each other and overwrite each
    other because styles are not scoped (i.e., restricted) to a specific component.
    CSS styles are always global, unless inline styles are used (which is discouraged,
    as mentioned earlier).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 来自不同组件的样式可能会相互冲突并覆盖彼此，因为样式不是限定（即，限制）在特定组件内的。CSS样式始终是全局的，除非使用内联样式（如前所述，这是不推荐的）。
- en: When working with component-based libraries such as React, this lack of scoping
    is a common issue. It’s easy to write conflicting styles as app sizes and complexities
    grow (or, in other words, as more and more components are added to the code base
    of a React app).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当与React等基于组件的库一起工作时，这种作用域缺失是一个常见问题。随着应用规模和复杂性的增长（或者说，随着越来越多的组件被添加到React应用的代码库中），很容易编写冲突的样式。
- en: 'That’s why various solutions for this problem have been developed by members
    of the React community. The following are three of the most popular solutions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，React社区成员已经开发了各种解决方案来解决这个问题。以下是最受欢迎的三种解决方案：
- en: CSS Modules (supported out of the box in React projects created with Vite)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS Modules（在用Vite创建的React项目中默认支持）
- en: Styled components (using a third-party library called `styled-components` )
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式化组件（使用名为`styled-components`的第三方库）
- en: Tailwind CSS (a popular CSS library)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tailwind CSS（一个流行的CSS库）
- en: Scoped Styles with CSS Modules
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS Modules的作用域样式
- en: '**CSS Modules** is the name for an approach where individual CSS files are
    linked to specific JavaScript files and the components defined in those files.
    This link is established by transforming CSS class names, such that every JavaScript
    file receives its own, unique CSS class names. This transformation is performed
    automatically as part of the code build workflow. Therefore, a given project setup
    must support CSS Modules by performing the described CSS class name transformation.
    Projects created via Vite support CSS Modules by default.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**CSS Modules**是一种方法，其中单个CSS文件与特定的JavaScript文件相关联，并且这些文件中定义的组件。这种链接是通过转换CSS类名来建立的，使得每个JavaScript文件都接收自己的、唯一的CSS类名。这种转换作为代码构建工作流的一部分自动执行。因此，给定的项目设置必须通过执行所描述的CSS类名转换来支持CSS
    Modules。通过Vite创建的项目默认支持CSS Modules。'
- en: '![A diagram of a program  Description automatically generated](img/B31339_06_05.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![程序图解 自动生成描述](img/B31339_06_05.png)'
- en: 'Figure 6.5: CSS modules in action. CSS class names are transformed into unique
    names during the build workflow'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：CSS模块在实际应用中的表现。在构建工作流中，CSS类名被转换成唯一的名称
- en: 'CSS Modules are enabled and used by naming CSS files in a very specific and
    clearly defined way: `<anything>.module.css` . `<anything>` is any value of your
    choosing, but the `.module` part in front of the file extension is required, as
    it signals (to the project build workflow) that this CSS file should be transformed
    according to the CSS Modules approach.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: CSS Modules通过以非常具体和明确的方式命名CSS文件来启用和使用：`<anything>.module.css`。`<anything>`是你选择的任何值，但文件扩展名前的`.module`部分是必需的，因为它向项目构建工作流发出信号，即此CSS文件应根据CSS
    Modules方法进行转换。
- en: 'Therefore, CSS files named like this must be imported into components in a
    specific way:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，像这样命名的CSS文件必须以特定的方式导入到组件中：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This `import` syntax is different from the `import` syntax shown at the beginning
    of this section for `index.css` :'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`import`语法与本节开头为`index.css`展示的`import`语法不同：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When importing CSS files as shown in the second snippet, the CSS code is simply
    merged into the `index.html` file and applied globally. When using CSS Modules
    instead (first code snippet), the CSS class names defined in the imported CSS
    file are transformed such that they are unique for the JS file that imports the
    CSS file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当像第二个代码片段中那样导入CSS文件时，CSS代码会被简单地合并到`index.html`文件中并全局应用。当使用CSS Modules（第一个代码片段）时，导入的CSS文件中定义的CSS类名会被转换，使得它们对于导入CSS文件的JS文件来说是唯一的。
- en: Since the CSS class names are transformed and are therefore no longer equal
    to the class names you defined in the CSS file, you import an object ( `classes`
    , in the preceding example) from the CSS file. This object exposes all transformed
    CSS class names under keys that match the CSS class names defined by you in the
    CSS file. The values of those properties are the transformed class names (as strings).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CSS类名被转换，因此它们不再等于你在CSS文件中定义的类名，所以你从CSS文件中导入一个对象（前例中的`classes`），这个对象通过匹配你在CSS文件中定义的CSS类名作为键，暴露了所有转换后的CSS类名。这些属性的值是转换后的类名（字符串）。
- en: 'Here’s a complete example, starting with a component-specific CSS file ( `TextBox.module.css`
    ):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个完整的示例，从一个特定组件的CSS文件（`TextBox.module.css`）开始：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The JavaScript file ( `TextBox.jsx` ) for the component to which the CSS code
    should belong looks like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 应该将CSS代码归属的组件的JavaScript文件（`TextBox.jsx`）看起来像这样：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Note**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The full example code can also be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/01-css-modules-intro](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/01-css-modules-intro)
    .
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例代码也可以在 [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/01-css-modules-intro](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/01-css-modules-intro)
    找到。
- en: 'If you inspect the rendered text element in the browser developer tools, you
    will note that the CSS class name applied to the `<p>` element does not match
    the class name specified in the `TextBox.module.css` file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用浏览器开发者工具检查渲染的文本元素，你会注意到应用到 `<p>` 元素的 CSS 类名并不匹配 `TextBox.module.css` 文件中指定的类名：
- en: '![img](img/B31339_06_06.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_06_06.png)'
- en: 'Figure 6.6: CSS class name transforms because of CSS Modules usage'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：CSS 类名因为 CSS 模块的使用而转换
- en: This is the case because, as described previously, the class name was transformed
    during the build process to be unique. If any other CSS file, imported by another
    JavaScript file, were to define a class with the same name ( `info` in this case),
    the styles would not clash and not overwrite each other, as the interfering class
    names would be transformed into different class names before being applied to
    the DOM elements.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，如前所述，类名在构建过程中被转换成唯一的。如果其他任何 CSS 文件（由另一个 JavaScript 文件导入），定义了一个具有相同名称的类（在这个例子中是
    `info`），那么样式就不会冲突，也不会相互覆盖，因为干扰的类名在应用到 DOM 元素之前会被转换成不同的类名。
- en: 'Indeed, in the example provided on GitHub, you can find another `info` CSS
    class defined in the `index.css` file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在 GitHub 上提供的示例中，你还可以找到在 `index.css` 文件中定义的另一个 `info` CSS 类：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That file is still imported into `main.jsx` , and hence its styles are applied
    globally to the entire document. Nonetheless, the `.info` styles clearly aren’t
    affecting `<p>` rendered by `TextBox` (there is no red border around the text
    box in *Figure 6.6* ). They aren’t affecting that element because it doesn’t have
    an `info` class anymore; the class was renamed `_info_1mtzh_8` by the build workflow
    (although the name you see will differ, as it contains a random element).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件仍然被导入到 `main.jsx` 中，因此其样式被应用到整个文档的全局范围内。尽管如此，`.info` 样式显然没有影响到由 `TextBox`
    渲染的 `<p>` 元素（在 *图 6.6* 中文本框周围没有红色边框）。它们没有影响到该元素，因为该元素不再有 `info` 类；该类被构建工作流程重命名为
    `_info_1mtzh_8`（尽管你看到的名称将不同，因为它包含一个随机元素）。
- en: It’s also worth noting that the `index.css` file is still imported into `main.jsx`
    , as shown at the beginning of this chapter. The `import` statement is not changed
    to `import classes from './index.css';` , nor is the CSS file called `index.module.css`
    .
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`index.css` 文件仍然被导入到 `main.jsx` 中，正如本章开头所示。`import` 语句没有被改为 `import classes
    from './index.css';`，CSS 文件也没有被命名为 `index.module.css`。
- en: Note, too, that you can use CSS Modules to scope styles to components and can
    also mix the usage of CSS Modules with regular CSS files, which are imported into
    JavaScript files without using CSS Modules (i.e., without scoping).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你还可以使用 CSS 模块将样式范围限定到组件，并且可以将 CSS 模块的使用与常规 CSS 文件混合，这些常规 CSS 文件被导入到 JavaScript
    文件中而不使用 CSS 模块（即，不进行范围限定）。
- en: One other important aspect of using CSS Modules is that you can only use CSS
    class selectors (that is, in your `.module.css` files) because CSS Modules rely
    on CSS classes. You can write selectors that combine classes with other selectors,
    such as `input.invalid` , but you can’t add selectors that don’t use classes at
    all in your `.module.css` files. For example, `input { ... }` or `#some-id { ...
    }` selectors wouldn’t work here.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CSS 模块的另一个重要方面是，你只能使用 CSS 类选择器（即，在你的 `.module.css` 文件中），因为 CSS 模块依赖于 CSS
    类。你可以编写结合类和其他选择器的选择器，例如 `input.invalid`，但你不能在你的 `.module.css` 文件中添加不使用类的选择器。例如，`input
    { ... }` 或 `#some-id { ... }` 选择器在这里将不起作用。
- en: CSS Modules are a very popular way of scoping styles to (React) components,
    and they will be used throughout many examples for the rest of this book.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 模块是将样式范围限定到（React）组件的一种非常流行的方式，本书的后续许多示例都将使用这种方式。
- en: The styled-components Library
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样式组件库
- en: The `styled-components` library is a so-called **CSS-in-JS** solution. CSS-in-JS
    solutions aim to remove the separation between CSS code and JavaScript code by
    merging them into the same file. Component styles would be defined right next
    to the component logic. It comes down to personal preference whether you favor
    separation (as enforced by using CSS files) or keeping the two languages close
    to each other.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`styled-components` 库是一种所谓的 **CSS-in-JS** 解决方案。CSS-in-JS 解决方案旨在通过将它们合并到同一个文件中来消除
    CSS 代码和 JavaScript 代码之间的分离。组件样式将直接定义在组件逻辑旁边。是否偏好分离（如通过使用 CSS 文件强制执行）或保持两种语言紧密相邻，这取决于个人喜好。'
- en: 'Since `styled-components` is a third-party library that’s not pre-installed
    in newly created React projects, you have to install this library as a first step
    if you want to use it. This can be done via `npm` (which was automatically installed
    together with Node.js in *Chapter 1* , *React – What and Why* ):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `styled-components` 是一个不在新创建的 React 项目中预安装的第三方库，如果你想使用它，你必须将其作为第一步安装。这可以通过
    `npm`（在 *第 1 章* ，*React – 什么和为什么* 中与 Node.js 自动安装）来完成：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `styled-components` library essentially provides wrapper components around
    all built-in core components (as in, around `p` , `a` , `button` , `input` , and
    so on). It exposes all these wrapper components as **tagged templates** —JavaScript
    functions that aren’t called like regular functions but, instead, are executed
    by adding backticks (a template literal) right after the function name, for example,
    `` doSomething`text data` `` .
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`styled-components` 库本质上提供了所有内置核心组件的包装组件（例如，围绕 `p`、`a`、`button`、`input` 等）。它将这些包装组件作为
    **标记模板** 暴露出来——JavaScript 函数，它们不像常规函数那样被调用，而是通过在函数名后添加反引号（模板字面量）来执行，例如，`` doSomething`text
    data` ``。'
- en: '**Note**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Tagged templates can be confusing when you see them for the first time, especially
    since it’s a JavaScript feature that isn’t used too frequently. Chances are high
    that you haven’t worked with them too often. It’s even more likely that you have
    never built a custom-tagged template before. You can learn more about tagged templates
    in this excellent documentation on MDN at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates)
    .
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次看到标记模板时，可能会感到困惑，尤其是考虑到它是一个不太常用的 JavaScript 功能。你不太可能经常使用它们。更有可能的是，你以前从未构建过自定义标记模板。你可以在
    MDN 的这篇优秀的文档中了解更多关于标记模板的信息：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates)
    。
- en: 'Here is a component that imports and uses `styled-components` to set and scope
    styling:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个导入并使用 `styled-components` 来设置和作用域样式的组件：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This component isn’t a component function but, rather, a constant that stores
    the value returned by executing the `styled.button` tagged template. That tagged
    template returns a component function that yields a `<button>` element. The styles
    passed via the tagged template (i.e., inside the template literal) are applied
    to that returned button element. You can see this if you inspect the button in
    the browser’s developer tools:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件不是一个组件函数，而是一个常量，它存储了执行 `styled.button` 标记模板返回的值。该标记模板返回一个组件函数，该函数生成一个 `<button>`
    元素。通过标记模板（即模板字面量内）传递的样式应用于该返回的按钮元素。如果你在浏览器开发者工具中检查按钮，就可以看到这一点：
- en: '![A screenshot of a computer program  Description automatically generated](img/B31339_06_07.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图  自动生成的描述](img/B31339_06_07.png)'
- en: 'Figure 6.7: The rendered button element receives the defined component styles'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：渲染的按钮元素接收定义的组件样式
- en: In *Figure 6.7* , you can also see how the `styled-components` library applies
    your styles to the element. It extracts your style definitions from the tagged
    template string and injects them into a `<style>` element in the `<head>` section
    of the document. The injected styles are then applied via a class selector that
    is generated (and named) by the `styled-components` library. Finally, the automatically
    generated CSS class name is added to the element ( `<button>` , in this case)
    by the library.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 6.7* 中，你还可以看到 `styled-components` 库如何将你的样式应用到元素上。它从标记模板字符串中提取你的样式定义，并将它们注入到文档
    `<head>` 部分的 `<style>` 元素中。然后，通过由 `styled-components` 库生成（并命名）的类选择器应用注入的样式。最后，库将自动生成的
    CSS 类名添加到元素（在这种情况下是 `<button>`）上。
- en: The components exposed by the `styled-components` library spread any extra props
    you pass to a component onto the wrapped core component. In addition, any content
    inserted between the opening and closing tags is also inserted between the tags
    of the wrapped component.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`styled-components`库暴露的组件会将你传递给组件的任何额外属性传播到包装的核心组件上。此外，任何插入在开标签和闭标签之间的内容也会插入到包装组件的标签之间。'
- en: 'That’s why the `Button` created previously can be used like this without adding
    any extra logic to it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么之前创建的`Button`可以像这样使用，而不需要添加任何额外的逻辑：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Note**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The complete example code can be found on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/02-styled-components-intro](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/02-styled-components-intro)
    .
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例代码可以在GitHub上找到，地址为[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/02-styled-components-intro](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/02-styled-components-intro)。
- en: You can do more with the `styled-components` library. For example, you can set
    styles dynamically and conditionally. This book is not primarily about that library
    though. It’s just one of many alternatives to CSS Modules. Therefore, it is recommended
    that you explore the official `styled-components` documentation if you want to
    learn more, which you can find at [https://styled-components.com/](https://styled-components.com/)
    .
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`styled-components`库做更多的事情。例如，你可以动态和有条件地设置样式。不过，这本书并不是主要关于这个库的。它只是CSS Modules的许多替代方案之一。因此，如果你想要了解更多，建议你探索官方的`styled-components`文档，你可以在这里找到[https://styled-components.com/](https://styled-components.com/)。
- en: Use the Tailwind CSS Library for Styling
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Tailwind CSS库进行样式设计
- en: Scoping styles with the help of CSS modules or the `styled-component` library
    is a very useful and popular technique.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSS模块或`styled-component`库来范围样式是一种非常有用且流行的技术。
- en: But no matter which approach you use, you must write all the CSS code on your
    own. Hence you, of course, need to know CSS.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但无论你使用哪种方法，你都必须自己编写所有的CSS代码。因此，当然你需要了解CSS。
- en: But what if you don’t? Or if you simply don’t like writing CSS code?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你不喜欢写CSS代码呢？或者你根本就不想写？
- en: In that case, you can use one of the many CSS libraries and frameworks available—for
    example, the **Bootstrap** CSS framework or the **Tailwind CSS** library. Tailwind
    has become a very popular styling solution for React projects (for developers
    who don’t want to write custom CSS code).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以使用许多可用的CSS库和框架之一——例如，**Bootstrap** CSS框架或**Tailwind CSS**库。Tailwind已经成为React项目（对于不想编写自定义CSS代码的开发者）非常流行的样式解决方案。
- en: Keep in mind that Tailwind is a CSS library that’s actually not focused on React.
    Instead, you can use Tailwind in any web project to style your HTML code—no matter
    which JavaScript library or framework (if any) is being used there.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Tailwind是一个CSS库，实际上并不专注于React。相反，你可以在任何Web项目中使用Tailwind来样式化你的HTML代码——无论在那里使用的是哪种JavaScript库或框架（如果有的话）。
- en: 'But Tailwind is a common choice for React apps, since its core philosophy plays
    nicely with the component-focused model of React. This is because when using Tailwind
    for styling, you typically compose overall styles by applying many small CSS classes
    to individual JSX elements:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 但Tailwind是React应用的常见选择，因为它的核心哲学与React的组件化模型相得益彰。这是因为当使用Tailwind进行样式设计时，你通常会通过将许多小的CSS类应用到单个JSX元素上来组合整体样式：
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When first encountering code that uses Tailwind CSS, the long list of CSS classes
    may look intimidating and chaotic. But when working with Tailwind, you typically
    quickly get used to it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次遇到使用Tailwind CSS的代码时，长长的CSS类列表可能会看起来令人畏惧且混乱。但当你与Tailwind一起工作时，你通常会很快习惯它。
- en: 'Also, because Tailwind’s approach offers many advantages:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为Tailwind的方法提供了许多优势：
- en: You don’t need to learn CSS in detail—understanding the Tailwind syntax, which
    is less complex than writing CSS from scratch, suffices.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要详细了解CSS——理解Tailwind语法就足够了，它比从头开始写CSS要简单。
- en: You compose styles by combining CSS classes—similar to how you compose user
    interfaces from components in React.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你通过组合CSS类来编写样式——类似于你在React中从组件组合用户界面。
- en: You don’t have to switch between JSX and CSS files.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要在JSX文件和CSS文件之间切换。
- en: Styling changes can be applied and tested very quickly.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式更改可以非常快速地应用和测试。
- en: As you can see in the above code snippet, the core idea of Tailwind essentially
    is that it provides many combinable CSS classes that each do very little. For
    example, the `bg-gray-200` class just sets the background color to a certain shade
    of gray, and nothing else.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如上代码片段所示，Tailwind的核心思想是它提供了许多可组合的CSS类，每个类只做很少的事情。例如，`bg-gray-200`类仅将背景颜色设置为某种灰度的色调，没有其他作用。
- en: Therefore, it’s the combination of all those CSS classes that achieves a certain
    look, and Tailwind CSS offers many such classes that you may use and combine.
    You find a full list in the official documentation at [https://tailwindcss.com/docs/utility-first](https://tailwindcss.com/docs/utility-first)
    .
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有这些CSS类的组合才能达到某种外观，Tailwind CSS提供了许多这样的类，你可以使用并组合。你可以在官方文档中找到完整的列表，网址为[https://tailwindcss.com/docs/utility-first](https://tailwindcss.com/docs/utility-first)。
- en: 'When working with Tailwind in React projects, you can therefore build React
    components not just to reuse logic or JSX markup but also styles:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在React项目中使用Tailwind时，你可以构建React组件，不仅是为了重用逻辑或JSX标记，还可以重用样式：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, the `Item` component is built to reuse the Tailwind styles
    applied to the `<li>` element.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Item`组件被构建为重用应用于`<li>`元素的Tailwind样式。
- en: '**Note**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You also find this example project on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/03-tailwind](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/03-tailwind)
    .'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在GitHub上找到这个示例项目：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/03-tailwind](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/03-tailwind)。
- en: 'If you plan on using Tailwind in your React project, you must install it as
    a first step. Detailed installation instructions for a broad variety of project
    setups can be found in the official documentation—this includes instructions for
    Vite projects: [https://tailwindcss.com/docs/guides/vite](https://tailwindcss.com/docs/guides/vite)
    .'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划在React项目中使用Tailwind，你必须将其作为第一步安装。官方文档中提供了针对各种项目设置的详细安装说明——这包括Vite项目的说明：[https://tailwindcss.com/docs/guides/vite](https://tailwindcss.com/docs/guides/vite)。
- en: The installation process is not as simple as just importing a CSS file but nonetheless
    relatively straightforward. It does require a couple of setup steps, since Tailwind
    needs to plug into the project build process to analyze your JSX files and produce
    CSS code that contains all used class names and style rules.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程不仅仅是导入一个CSS文件那么简单，但仍然相对直接。由于Tailwind需要连接到项目构建过程以分析你的JSX文件并生成包含所有使用过的类名和样式规则的CSS代码，因此它确实需要几个设置步骤。
- en: Besides offering many utility styles that can be combined, Tailwind also provides
    plenty of customization opportunities and configuration options. Therefore, entire
    books could be written about Tailwind alone. However, that’s, of course, not what
    this book is about. Therefore, if you’re interested in using Tailwind in your
    React projects, Tailwind’s official documentation (see the links above) is a great
    place to learn more.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供许多可组合的实用样式外，Tailwind还提供了大量的自定义机会和配置选项。因此，关于Tailwind的书籍可以写满整本书。然而，当然这不是本书的主题。因此，如果你对在React项目中使用Tailwind感兴趣，Tailwind的官方文档（见上面的链接）是一个学习更多的好地方。
- en: Using Other CSS or JavaScript Styling Libraries and Frameworks
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用其他CSS或JavaScript样式库和框架
- en: Obviously, it comes down to personal preferences whether you want to write custom
    CSS code (potentially scoped with CSS Modules or `styled-components` ) or whether
    you want to work with third-party CSS libraries, like Tailwind CSS. There is no
    wrong or right choice, and you’ll see all kinds of approaches being used in different
    React projects.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，是否编写自定义CSS代码（可能使用CSS Modules或`styled-components`进行范围限定）或者是否使用第三方CSS库，如Tailwind
    CSS，取决于个人喜好。没有对错之分，你会在不同的React项目中看到各种方法被使用。
- en: 'The options presented in this chapter are also not exhaustive—there are other
    kinds of CSS and JavaScript libraries, too:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中介绍的选择也不是详尽的——还有其他类型的CSS和JavaScript库：
- en: Utility libraries that solve very specific CSS problems—independent of the fact
    that you’re using them in a React project (for example, `Animate.css` , which
    helps to add animations)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决非常具体的CSS问题的实用库——无论你是在React项目中使用它们（例如，`Animate.css`，它有助于添加动画）
- en: Other CSS frameworks or libraries that provide a broad variety of pre-built
    CSS classes that can be applied to elements to quickly achieve a certain look
    (for example, **Bootstrap** )
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他CSS框架或库提供了广泛的预建CSS类，可以应用于元素以快速实现某种外观（例如，**Bootstrap**）
- en: JavaScript libraries that help with styling or specific styling aspects like
    animations (for example, **Framer Motion** )
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助进行样式或特定样式方面（例如，动画）的JavaScript库（例如，**Framer Motion**）
- en: Some libraries and frameworks have React-specific extensions or specifically
    support React, but that does not mean that you can’t use libraries that don’t
    have this.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一些库和框架有针对React的特定扩展或专门支持React，但这并不意味着你不能使用没有这种扩展的库。
- en: Summary and Key Takeaways
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概括和关键要点
- en: Standard CSS can be used to style React components and JSX elements.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用标准CSS来样式化React组件和JSX元素。
- en: CSS files are typically directly imported into JavaScript files, which is possible
    thanks to the project build process, which extracts the CSS code and injects it
    into the document (the HTML file).
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS文件通常直接导入到JavaScript文件中，这得益于项目构建过程，它提取CSS代码并将其注入到文档中（HTML文件）。
- en: As an alternative to global CSS styles (with `element` , `id` , `class` , or
    other selectors), inline styles can be used to apply styling to JSX elements.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为全局CSS样式（使用`element`、`id`、`class`或其他选择器）的替代方案，内联样式可以用来为JSX元素应用样式。
- en: When using CSS classes for styling, you must use the `className` prop (not `class`
    ).
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用CSS类进行样式化时，你必须使用`className`属性（而不是`class`）。
- en: Styles can be set statically and dynamically or conditionally with the same
    syntax that is used to inject other dynamic or conditional values into JSX code—a
    pair of curly braces.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式可以静态设置，也可以使用与将其他动态或条件值注入JSX代码相同的语法动态或条件设置——一对大括号。
- en: Highly configurable custom components can be built by setting styles (or CSS
    classes) based on prop values, or by merging received prop values with other styles
    or class name strings.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过设置样式（或CSS类）基于prop值，或者通过合并接收到的prop值与其他样式或类名字符串来构建高度可配置的自定义组件。
- en: When using just CSS, clashing CSS class names can be a problem.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当仅使用CSS时，CSS类名冲突可能是一个问题。
- en: CSS Modules solve this problem by transforming class names into unique names
    (per component) as part of the build workflow.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS Modules通过在构建工作流程中将类名转换为唯一的名称（每个组件一个）来解决此问题。
- en: Alternatively, third-party libraries such as `styled-components` can be used.
    This library is a CSS-in-JS library that also has the advantage or disadvantage
    (depending on your preference) of removing the separation between JS and CSS code.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，可以使用如`styled-components`之类的第三方库。这个库是一个CSS-in-JS库，它也有一个优点或缺点（取决于你的偏好），即消除了JS和CSS代码之间的分离。
- en: Tailwind CSS is another popular styling choice for React projects—it’s a library
    that allows you to compose styles by combining many small CSS classes.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tailwind CSS是React项目的另一种流行的样式选择——这是一个允许你通过组合许多小的CSS类来编写样式的库。
- en: Other CSS libraries or frameworks can be used as well; React does not impose
    any restrictions regarding that.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也可以使用其他CSS库或框架；React在这方面没有施加任何限制。
- en: What’s Next?
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: With styling covered, you’re now able to build not just functional but also
    visually appealing user interfaces. Even if you often work with dedicated web
    designers or CSS experts, you still typically need to be able to set and assign
    styles (dynamically) that are delivered to you.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在样式处理完毕后，你现在能够构建不仅功能性强而且视觉上吸引人的用户界面。即使你经常与专门的网页设计师或CSS专家合作，你通常也需要能够设置和分配样式（动态地）并将其传递给你。
- en: With styling being a general concept that is relatively independent of React,
    the next chapter will dive back into more React-specific features and topics.
    You will learn about **portals** and **refs** , which are two key concepts that
    are built into React. You will discover which problems are solved by these concepts
    and how the two features are used.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于样式是一个相对独立于React的一般概念，下一章将回到更多React特定的功能和主题。你将了解** portals**和**refs**，这两个是React内置的关键概念。你将发现这些概念解决了哪些问题，以及这两个功能是如何使用的。
- en: Test Your Knowledge!
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你的知识！
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to examples that can be
    found here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/06-styling/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/06-styling/exercises/questions-answers.md)
    .'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试您对本章涵盖的概念的理解。您可以将您的答案与以下示例进行比较：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/06-styling/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/06-styling/exercises/questions-answers.md)。
- en: With which language are styles for React components defined?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React组件的样式是用哪种语言定义的？
- en: Which important difference, compared to projects without React, has to be kept
    in mind when it comes to assigning classes to elements?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与没有React的项目相比，在为元素分配类时，需要牢记哪些重要差异？
- en: How can styles be assigned dynamically and conditionally?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何动态和条件性地分配样式？
- en: What does “Scoping” mean in the context of styling?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在样式上下文中，“限定”是什么意思？
- en: How could styles be scoped to components? Briefly explain at least one concept
    that helps with scoping.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 样式如何限定到组件中？简要解释至少一个有助于限定的概念。
- en: Apply What You Learned
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用所学知识
- en: You are now not only able to build interactive user interfaces but also style
    those user interface elements in engaging ways. You can set and change those styles
    dynamically or based on conditions.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您不仅能够构建交互式用户界面，还能够以引人入胜的方式对用户界面元素进行样式设计。您可以根据条件动态地设置和更改这些样式。
- en: In this section, you will find two activities that allow you to apply your newly
    gained knowledge in combination with what you learned in previous chapters.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将找到两个活动，这些活动允许您将新获得的知识与之前章节中学到的知识相结合来应用。
- en: 'Activity 6.1: Providing Input Validity Feedback upon Form Submission'
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动六.1：在表单提交时提供输入有效性反馈
- en: In this activity, you will build a basic form that allows users to enter an
    email address and a password. The provided input of each input field is validated,
    and the validation result is stored (for each individual input field).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本活动中，您将构建一个基本的表单，允许用户输入电子邮件地址和密码。每个输入字段的输入都会进行验证，并且验证结果会被存储（针对每个单独的输入字段）。
- en: The aim of this activity is to add some general form styling and some conditional
    styling that becomes active once an invalid form has been submitted. The exact
    styles are up to you, but to highlight invalid input fields, the background color
    of the affected input field must be changed, as well as its border color and the
    text color of the related label.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的目的是添加一些通用的表单样式和一些条件样式，一旦提交了无效表单，这些样式就会生效。具体的样式由您决定，但为了突出显示无效的输入字段，必须更改受影响输入字段的背景颜色、边框颜色以及相关标签的文本颜色。
- en: 'The steps are as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: Create a new React project and add a form component to it.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的React项目，并向其中添加一个表单组件。
- en: Output the form component in the project’s root component.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根组件中输出表单组件。
- en: 'In the form component, output a form that contains two input fields: one for
    entering an email address and one for entering a password.'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单组件中，输出包含两个输入字段的表单：一个用于输入电子邮件地址，另一个用于输入密码。
- en: Add labels to the input fields.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为输入字段添加标签。
- en: Store the entered values and check their validity upon form submission (you
    can be creative in forming your own validation logic).
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单提交时存储输入的值并检查它们的有效性（您可以在形成自己的验证逻辑方面发挥创意）。
- en: Pick appropriate CSS classes from the provided `index.css` file (alternatively,
    you can write your own classes as well).
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从提供的`index.css`文件中选择合适的CSS类（或者您也可以编写自己的类）。
- en: Add them to the invalid input fields and their labels once invalid values have
    been submitted.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦提交了无效值，就将它们添加到无效的输入字段及其标签上。
- en: 'The final user interface should look like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户界面应如下所示：
- en: '![A screenshot of a login screen  Description automatically generated](img/B31339_06_08.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![登录屏幕的截图 自动生成的描述](img/B31339_06_08.png)'
- en: 'Figure 6.8: The final user interface with invalid input values highlighted
    in red'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：最终用户界面，无效输入值以红色突出显示
- en: Since this book is not about CSS and you may not be a CSS expert, you can use
    the `index.css` file from the solution and focus on the React logic to apply appropriate
    CSS classes to JSX elements.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书不涉及CSS，并且您可能不是CSS专家，您可以使用解决方案中的`index.css`文件，并专注于React逻辑来将适当的CSS类应用到JSX元素上。
- en: '**Note**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: All code files used for this activity, and a full solution, can be found at
    [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/activities/practice-1)
    .
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于此活动的代码文件以及完整解决方案，可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/activities/practice-1)找到。
- en: 'Activity 6.2: Using CSS Modules for Style Scoping'
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动六.2：使用CSS模块进行样式作用域
- en: In this activity, you’ll take the final app built in *Activity 6.1* and adjust
    it to use CSS Modules. The goal is to migrate all component-specific styles into
    a component-specific CSS file, which uses CSS Modules for style scoping.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将使用*活动6.1*中构建的最终应用程序，并调整它以使用CSS模块。目标是迁移所有特定于组件的样式到一个特定于组件的CSS文件中，该文件使用CSS模块进行样式作用域。
- en: The final user interface therefore looks the same as it did in the previous
    activity. However, the styles will be scoped to the `Form` component so that clashing
    class names won’t interfere with styling.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终的用户界面看起来与上一个活动相同。然而，样式将被限制在`Form`组件中，这样冲突的类名就不会干扰样式。
- en: 'The steps are as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: Finish the previous activity or take the finished code from GitHub.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成上一个活动或从GitHub获取完成的代码。
- en: Identify the styles belonging specifically to the `Form` component and move
    them into a new, component-specific CSS file.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别属于`Form`组件的特定样式，并将它们移动到新的、特定于组件的CSS文件中。
- en: Change CSS selectors to class name selectors and add classes to JSX elements
    as needed (this is because CSS Modules require class name selectors).
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将CSS选择器更改为类名选择器，并根据需要将类添加到JSX元素中（这是因为CSS模块需要类名选择器）。
- en: Use the component-specific CSS file as explained throughout this chapter and
    assign the CSS classes to the appropriate JSX elements.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章中解释的特定于组件的CSS文件，并将CSS类分配给适当的JSX元素。
- en: '**Note**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: All code files used for this activity, and a full solution, can be found at
    [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/activities/practice-2)
    .
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于此活动的代码文件以及完整解决方案，可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/activities/practice-2)找到。
