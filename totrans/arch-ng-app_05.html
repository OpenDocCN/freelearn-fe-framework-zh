<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">RxJS Basics</h1>
                </header>
            
            <article>
                
<p><strong>Reactive Extensions for JavaScript</strong> (<strong>RxJS</strong>) is a set of libraries created by Matt Podwysocky. Version 4 of the library is maintained and developed by Microsoft. Version 4 can be found at the following link: <a href="https://github.com/Reactive-Extensions/RxJS">https://github.com/Reactive-Extensions/RxJS</a>.<a href="https://github.com/Reactive-Extensions/RxJS"/></p>
<p>Version 5 is a complete rewrite of version 4 and can be found at the following address: <a href="https://github.com/ReactiveX/rxjs">https://github.com/ReactiveX/rxjs</a>. Its largest contributor is <em>Ben Lesh</em>, with other notable contributors including <em>Andre Staltz</em>. Version 5 is also Angular's choice of library for handling HTTP, among other things. </p>
<p class="mce-root">In this chapter, you will learn:</p>
<ul>
<li>Which patterns make up RxJS</li>
<li>The core concepts of RxJS</li>
<li>How to manually create your own Observables and subscribe to them</li>
<li>The many ways you can create an Observable</li>
<li>The importance of managing cleanup</li>
<li>Understanding what lies beneath by learning to implement the core part of the RxJS library</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observer pattern</h1>
                </header>
            
            <article>
                
<p>The Observer pattern is a Gang of Four pattern. It is a pattern made famous by being included in the book <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> by <em>Erich Gamma</em>, <em>Richard Helm</em>, <em>Ralph Johnson</em>, and <em>John Vlissides</em>. The pattern has two key players involved: a <strong>Subject</strong> and an <strong>Observer</strong>. A Subject is observed by an Observer. Typically, a Subject holds an internal list of Observers that should be notified when a change happens on the Subject. It is quite common that the Subject is a model and the Observers are some kind of UI component. In short, Subjects should be able to:</p>
<ul>
<li>Hold a list of Observers</li>
<li>Add an Observer</li>
<li>Remove an Observer</li>
<li>Notify all Observers when a change happens</li>
</ul>
<p>The Observer, on the other hand, should only hold one property, and that is an <kbd>update()</kbd> method that can be called by a Subject when an update has occurred. The idea behind this pattern is to create a loose coupling between different layers. Neither Subjects nor Observers should know about each other directly by name, but rather by abstractions. A class diagram for a Subject might therefore look like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-241 image-border" src="assets/d14da8c5-3a06-4875-86c3-4543b4b26a98.png" style=""/></div>
<p>Here, we are including all the required methods: <kbd>attach()</kbd>, <kbd>detach()</kbd> and <kbd>notify()</kbd>, and we clearly specify that we are dealing with the abstraction Observer and not a concrete type. As for the Observer, this is usually an interface with just one method, <kbd>update()</kbd>, and can be represented by the following class diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-240 image-border" src="assets/a38a9906-ccf4-4743-81e0-7363ecf07869.png" style=""/></div>
<p>Given these class diagrams, let's write down some code to demonstrate what an implementation might look like, and let's start with the Subject. For this example, we will be using TypeScript, as TypeScript knows what an interface is:</p>
<pre>// observer-subject/subject.ts<br/><br/>import<span> { Observer } </span><span>from</span><span> </span><span>"./observer"</span><span>;<br/></span><br/>export<span> </span><span>class</span><span> Subject {<br/></span>  observers<span>:</span><span> Array&lt;Observer&gt;;<br/></span>  <br/>  constructor<span>() {<br/></span>    this<span>.observers </span><span>=</span><span> </span><span>new</span><span> Array&lt;Observer&gt;();<br/></span>  }<br/><br/>  attach(observer<span>:</span><span> Observer) {<br/></span>    if<span> (</span><span>this</span><span>.observers.indexOf(observer) </span><span>===</span><span> </span><span>-</span><span>1</span><span>) {<br/></span>      this<span>.observers.push(observer);<br/></span>    }<br/>  }<br/><br/>  detach(observer) {<br/>    let<span> index </span><span>=</span><span> </span><span>this</span><span>.observers.indexOf(observer);<br/></span>    if<span> (index </span><span>!==</span><span> </span><span>-</span><span>1</span><span>) {<br/></span>      this<span>.observers </span><span>=</span><span> </span><span>this</span><span>.observers.slice(index, </span><span>1</span><span>);<br/></span>    }<br/>  }<br/><br/>  notify() {<br/>    this<span>.observers.forEach(observer </span><span>=&gt;</span><span> observer.update());<br/></span>  }<br/>}</pre>
<p>As you can see, the basic implementation is very short but it is a powerful construct. As for the <kbd>Observer</kbd>, it is even shorter:</p>
<pre>// observer-subject/observer.ts<br/>export interface Observer {<br/>  update();<br/>}</pre>
<p>We can try this out by creating a file, <kbd>app.ts</kbd>, like so:</p>
<pre>// observer-subject/app.ts<br/><br/>import<span> { Subject } </span><span>from</span><span> </span><span>"./subject"</span><span>;<br/></span>import<span> { Observer } </span><span>from</span><span> </span><span>"./observer"</span><span>;<br/><br/></span>const<span> subject </span><span>=</span><span> </span><span>new</span><span> Subject();<br/></span>const<span> observer </span><span>=</span><span> &lt;Observer&gt;{<br/></span>  update: () <span>=&gt;</span><span> console.log(</span><span>"First Observer Updated"</span><span>)<br/></span>};<br/><br/>const<span> observer2 </span><span>=</span><span> &lt;Observer&gt;{<br/></span>  update: () <span>=&gt;</span><span> console.log(</span><span>"Second Observer updated"</span><span>)<br/></span>};<br/><br/>subject.attach(observer);<br/>subject.attach(observer2);<br/>subject.notify();<br/><br/>// should emit:<br/>// First Observer Updated<br/>// Second Observer updated</pre>
<p>By running the preceding code, we see that the <kbd>Subject</kbd> instance allows us to attach   <kbd>Observer</kbd>   instances to it by calling the <kbd>attach()</kbd>   method. We then call   <kbd>notify()</kbd>   on the   <kbd>Subject</kbd>   instance to ensure that all subscribing   <kbd>Observer</kbd> instances gets notified. </p>
<p>OK, so now we have some core implementation in place, what does an actual use case look like? Imagine that we have a <kbd>ProductModel</kbd> class playing the role of a <kbd>Subject</kbd> and a <kbd>ProductUI</kbd> class playing the role of an <kbd>Observer</kbd>. A simple implementation of the <kbd>ProductModel</kbd> class might look like the following:</p>
<pre>// product-model/product.model.ts<br/><br/>import { Subject } from "./subject";<br/><br/>export class ProductModel extends Subject {<br/>  private titleValue = "";<br/>  private makeValue = "";<br/><br/>  get title(){ <br/>    return this.titleValue;<br/>  }<br/><br/>  set title(value) {<br/>    this.titleValue = value;<br/>    this.notify();<br/>  }<br/><br/>  get make() {<br/>    return this.makeValue;<br/>  }<br/><br/>  set make(value) {<br/>    this.makeValue = value;<br/>    this.notify();<br/>  }<br/>}</pre>
<p>Here, we can see that we have two properties, <kbd>title</kbd> and <kbd>make</kbd>, and when both of them change, we call the <kbd>notify()</kbd> method that we inherit from the base class, <kbd>Subject</kbd>. Let's have a look at what a <kbd>ProductUI</kbd> class can look like:</p>
<pre>// product-model/product.ui.ts<br/><br/>import<span> { Observer } </span><span>from</span><span> </span><span>"./observer"</span><span>;<br/></span>import<span> { ProductModel } </span><span>from</span><span> </span><span>"./product.model"</span><span>;<br/><br/></span>export class<span> ProductUI </span><span>implements</span><span> Observer {<br/></span>  constructor<span>(</span><span>private</span><span> model</span><span>:</span><span> ProductModel) {<br/></span>    this<span>.model.attach(</span><span>this</span><span>); </span><span>// add ProductUI to the observer list<br/></span>    this<span>.renderUI();<br/></span>  }<br/><br/>  renderUI() {<br/>    console.log("calling renderUI");<br/>    this<span>.draw();<br/></span>  }<br/><br/>  draw() {<br/>    // implement<br/>    console.log("calling draw");<br/>  }<br/><br/>  update() {<br/>    console.log("calling update");<br/>    this<span>.renderUI(); </span><span>// rerender the UI when update() is called<br/></span>  }<br/>}</pre>
<p>In the preceding code, we see that we receive a <kbd>ProductModel</kbd> instance in the constructor and that we also call <kbd>attach()</kbd> on said instance so that it is registered as an <kbd>Observer</kbd>. We also define an <kbd>update()</kbd> method, in which we decide that we will rerender the UI, should it be invoked. </p>
<p>This is a typical example of using the Observer pattern and using it for model-to-UI communication is just one of many usage possibilities. The general principle is to communicate between <kbd>Subject</kbd> and <kbd>Observer</kbd> instances in a loosely coupled way. The true benefit is to be able to have multiple <kbd>Observer</kbd> instances on one <kbd>Subject</kbd> so that if the <kbd>Subject</kbd> changes, all its <kbd>Observer</kbd> instances can change with it. This is also called Publish/Subscribe, which is usually shortened to Pub/Sub.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RxJS core concepts</h1>
                </header>
            
            <article>
                
<p>RxJS consists of some core concepts that are important for you to understand early on. Those are:</p>
<ul>
<li><strong>Observable</strong>: This is a class representing a stream of data.</li>
<li><strong>Observer</strong><span>: T</span>his is a class able to emit data.</li>
<li><strong>Producer</strong><span>: T</span>his is what internally produces data, which the Observer ultimately emits.</li>
<li><strong>Operator</strong><span>: T</span>his is a method on an Observable, which allows us to manipulate the stream itself or the data it emits.</li>
<li><strong>Stream</strong><span>: T</span>his is synonymous with an instance of an Observable. The reason for it being called a stream is that you should think of the data as continuous and not really having an end, unless you explicitly define an end.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observable and Observer</h1>
                </header>
            
            <article>
                
<p>Having defined all the concepts we need to know initially, it is now time to put it all in context to further our understanding. Let's start off by defining an <kbd>Observable</kbd> and work ourselves into each previously mentioned concept. An <kbd>Observable</kbd> can be created with the following code:</p>
<pre>let stream$ = Rx.Observable.create(observer =&gt; observer.next(1));</pre>
<p>This is the least amount of code needed to create an <kbd>Observable</kbd>. At this point nothing is written to the screen because we need to subscribe to the stream. Let's add a Subscriber to our <kbd>Observable</kbd>. We do that by calling the method <kbd>subscribe()</kbd> on our stream instance:</p>
<pre>let stream$ = Rx.Observable.create(observer =&gt; observer.next(1));<br/><strong>stream$.subscribe(data =&gt; console.log('data',data) )</strong> // write data, 1 to the console</pre>
<p>Looking at this code, we see that the <kbd>Observable</kbd> calls the method <kbd>create()</kbd>, which in turn creates an instance of an <kbd>Observable</kbd>. What is interesting is how the <kbd>create()</kbd> method takes a function as a parameter; a function that itself takes an Observer instance. So, we have an API that looks like this: <kbd>Observer.create(fn(observerInstance))</kbd>. What happens inside said function is that we call <kbd>observer.next(1)</kbd>.  At a higher level, we have an <kbd>Observable</kbd> that is created by us using a <kbd>factory</kbd> function <kbd>create()</kbd>. The <kbd>create</kbd> function takes a function as a parameter which defines the behavior of the <kbd>Observable</kbd>. Our <kbd>Observable</kbd> behavior in this case is very simple, which is to emit the value 1. When we call <kbd>observer.next(1)</kbd>, we emit data. To get hold of what is emitted, we need to call the <kbd>subscribe()</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Producer</h1>
                </header>
            
            <article>
                
<p>If we try to compare this to the Observer pattern, we will see that some concepts reoccur, such as Observer. In this pattern, the Observer was notified when something happened and the Subject took the initiative to change. Looking at the previous code, it looks like the Observer is the one that takes the initiative to change. This isn't strictly true though; it is more of a mediator, which brings us to our next concept in RxJS, the <kbd>Producer</kbd>. The <kbd>Producer</kbd> is responsible for generating the values we need. By involving a <kbd>Producer</kbd> in our code, we see that the Observer is more of a mediator:</p>
<pre>// rxjs-example/producer.js<br/><br/>const<span> Rx </span><span>=</span><span> require(</span><span>"rxjs/Rx"</span><span>);<br/></span><br/>class<span> Producer {<br/></span>  constructor<span>() {<br/></span>    this<span>.counterMax </span><span>=</span><span> </span><span>5</span><span>;<br/></span>    this<span>.current </span><span>=</span><span> </span><span>0</span><span>;<br/></span>  }<br/><br/>  hasValues() {<br/>    return<span> </span><span>this</span><span>.current </span><span>&lt;</span><span> </span><span>this</span><span>.counterMax;<br/></span>  }<br/><br/>  next() {<br/>    return<span> </span><span>this</span><span>.current</span><span>++</span><span>;<br/></span>  }<br/>}<br/><br/>let<span> stream$ </span><span>=</span><span> Rx.Observable.create(observer </span><span>=&gt;</span><span> {<br/></span>  let<span> producer </span><span>=</span><span> </span><span>new</span><span> Producer();<br/></span><br/>  while<span> (producer.hasValues()) {<br/></span>    observer.next(producer.next());<br/>  }<br/>});<br/><br/>stream$.subscribe(data <span>=&gt;</span><span> console.log(</span><span>"data"</span><span>, data));<br/></span>// data 0, data 1, data 2, data 3, data 4</pre>
<p>As we can see here, the producer is the one responsible for generating the data, while the Observer is responsible for passing on that data to a subscriber. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observable error and completion</h1>
                </header>
            
            <article>
                
<p>There is more to a stream than just generating data; a stream can generate errors as well as reaching its completion. If an error or a completion happens, the stream will not generate any more values. To signal that we have an error, we call the <kbd>error()</kbd> <span>method </span><span>on the Observer, like so:</span></p>
<pre>let stream$ = Rx.Observable.create(observer =&gt; {<br/>  <strong>observer.error('we have an error');</strong><br/>});</pre>
<p>To capture the emitted error, we need to introduce a second callback in our call to <kbd>subscribe()</kbd>, like so:</p>
<pre>// rxjs-example/error.js <br/><br/>const<span> Rx </span><span>=</span><span> require(</span><span>"rxjs/Rx"</span><span>);<br/><br/></span>let stream$ = Rx.Observable.create(observer =&gt; {<br/>  <strong>observer.error("we have an error");</strong><br/>});<br/><br/>stream$.subscribe(<br/>  data =&gt; console.log("data", data),<br/>  <strong>error =&gt; console.error("err", error)</strong><br/>)</pre>
<p>So far, we have learned how to emit data but also how to signal an error. The last thing we can do is to close the stream, or complete it, as closing is also known. We do that by calling <kbd>complete()</kbd> on the Observer. This will ensure that no more values are emitted. To capture a completion signal, we need to add another callback in our <kbd>subscribe()</kbd> call. You use it in the following way:</p>
<pre>// rxjs-example/completion.js<br/><br/>const<span> Rx </span><span>=</span><span> require(</span><span>"rxjs/Rx"</span><span>);<br/><br/></span>let stream$ = Rx.Observable.create(observer =&gt; {<br/>  observer.next(1);<br/>  <strong>observer.complete();</strong><br/>});<br/><br/>stream$.subscribe( <br/>  data =&gt; console.log("data", data), // 1<br/>  error =&gt; console.error("err", error), // never hit<br/>  <strong>() =&gt; console.log("complete")<br/></strong>); // will be hit</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Operator</h1>
                </header>
            
            <article>
                
<p>Our last concept to cover is the operator. An operator is simply a method that acts on an Observable and changes the stream in some way. Operators are by nature immutable. This immutability makes the code easier to test and reason about. RxJS comes with over 60 operators to help in most situations where you define your streams and their behavior.</p>
<p><span>There might be a case where you need to create your own operator, but most likely there is an operator out there that already does what you want.</span></p>
<p>When you define your stream and its behavior, you will use one or more operators. It might look like the following:</p>
<pre>let stream$ = Rx.Observable.of(1,2)<br/><strong>  .map( x =&gt; x +1 )</strong><br/><strong>  .filter( x &gt; 2 )</strong>;<br/><br/>stream$.subscribe( data =&gt; console.log('data', data)) <br/>// data 3</pre>
<p>Here, we can see that we are using the <kbd>.map()</kbd> <span>operator </span><span>and </span><kbd>.filter()</kbd><span> to change our stream's data.</span> <kbd>.map()</kbd><span> operates on each value in the stream by incrementing each value by one.</span> <kbd>.filter()</kbd><span> operates on the changed stream; a change brought about by calling </span><kbd>.map()</kbd><span>. It also operates on each value in the stream but conditionally decides what should be emitted. The end result is only one value being emitted,</span> <kbd>3</kbd><span>. There are a ton more operators, but this should give you an idea of what operators are and how they can be used.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating Observables</h1>
                </header>
            
            <article>
                
<p>Most of the time, when creating Observables, you won't use the <kbd>create()</kbd> method to do so. You will use other methods instead. Why is that? Well, an Observable instance usually originates from some asynchronous concept. In the context of using RxJS for creating Angular applications, an Observable instance will be created by doing one of the following things:</p>
<ul>
<li>Creating or fetching data over HTTP with AJAX</li>
<li>Listening to input changes with reactive forms</li>
<li>Listening to routing changes</li>
<li>Listening to UI events</li>
<li>Wrapping an asynchronous concept</li>
</ul>
<p>In RxJS, there are different creation operators that will help you solve these tasks, but the Angular framework might actually create Observables internally. Let's look at some creation operators other than the <kbd>create()</kbd> method:</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creation operators</h1>
                </header>
            
            <article>
                
<p>An Observable is, as we stated before, a representation of data being emitted over time. Sometimes, the data arrives straight away and sometimes it takes time. Regardless of which, it is really powerful to be able to model that data in the same way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">of()</h1>
                </header>
            
            <article>
                
<p>Let's look at a very simple creation operator, <kbd>of()</kbd>. This takes a variable number of arguments, which will be emitted as values, like so:</p>
<pre>let stream$ = Rx.Observable.of(1, 2, 3, 4);<br/>stream$.subscribe( data =&gt; console.log(data)) // 1, 2, 3 ,4</pre>
<p>The values are fired off immediately. This is very useful when you just want to test things out.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">interval()</h1>
                </header>
            
            <article>
                
<p>Another interesting operator is the <kbd>interval()</kbd> operator, which takes a number of milliseconds as a parameter. This defines the number of milliseconds delay there should be between every piece of emitted data. This will start from the number 0. One thing to keep in mind is that it will generate values forever unless, for example, a <kbd>take()</kbd> operator is applied to it. A <kbd>take()</kbd> operator will limit the number of emitted values and close the stream. A typical usage of the operator is the following:</p>
<pre>let stream$ = Rx.Observable.interval(1000)<br/>  .take(3); // 1s delay between values, starting at 0<br/><br/>stream$.subscribe(data =&gt; console.log(data)) <br/>// 0, 1, 2</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">from()</h1>
                </header>
            
            <article>
                
<p>The <kbd>from()</kbd> operator allows us to create an <kbd>Observable</kbd> from some other asynchronous/synchronous concept. It's really powerful when almost anything can be made into an <kbd>Observable</kbd>, as this allows for rich composition. Here is what a typical snippet can look like:</p>
<pre>let stream$ = Rx.Observable.from(new Promise(resolve, reject) =&gt; {<br/>  resolve('some data');<br/>});<br/><br/>stream$.subscribe( data =&gt; console.log(data)); // some data<br/><br/>let stream2$ = Rx.Observable.from([1,2,3,4]);<br/>stream2$.subscribe( data =&gt; console.log(data)); // 1,2,3,4</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">fromEvent()</h1>
                </header>
            
            <article>
                
<p>We have mentioned rich composition a few times already and the power of making everything into an Observable. We have turned promises and into Observables, which have made everything into streams of data, making the whole situation more easy to reason about. What we mean by that is, when every async concept is being turned into an Observable, we are suddenly able to think about them in the same way. Operators that can be applied to mouse-clicks can also be applied to AJAX requests and so on.</p>
<p>To add to this, we can even make UI events into Observables. By using the <kbd>.fromEvent()</kbd> operator, we are able to take an element and its corresponding event and make that an Observable. This is true power at our fingertips, which allows us to turn scenarios such as autocomplete into a matter of 3-4 lines of code. A typical usage of this operator looks like this:</p>
<pre>let elem = document.getElementById('input'); <br/>// we assume we have a &lt;input id="input"&gt; in our markup<br/><br/>let keyStream$ = Rx.Observable.fromEvent(elem, 'keyUp'); <br/>// listens to the keyUp event</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">bindCallback()</h1>
                </header>
            
            <article>
                
<p>So far, we have listed a lot of ways, synchronous as well as asynchronous, in which a construct could be turned into an Observable. Callbacks is the first pattern to try to resolve the whole asynchronous matter and it should be said that a callback is probably the worst way to solve asynchronous code because of its poor readability. Luckily, there is an operator that takes a callback and turns it into an Observable called <kbd>bindCallback()</kbd>. It can be used in the following way:</p>
<pre>function<span> </span><span><strong><span>fnWithCallback</span></strong></span><span>(</span><span>cb</span><span>) {<br/>  </span>setTimeout<span>(() </span><span>=&gt;</span><span> </span><span>cb</span><span>(</span><span>'data'</span><span>), </span><span>3000</span><span>);<br/></span>}<br/><br/></pre>
<pre><span>let</span><span> </span><span>fnWithCallbackBinded</span><span> </span><span>=</span><span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>bindCallback</span><span>(</span><span><strong><span>fnWithCallback</span></strong></span><span>);<br/></span>let<span> </span><span>source$</span><span> </span><span>=</span><span> </span><span>fnWithCallbackBinded</span><span>();<br/></span><br/>source$<span>.</span><span>subscribe</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>'callback'</span><span>, </span><span>data</span><span>));</span><span><br/></span></pre>
<p>We can see that we start off by defining a function called <kbd>fnWithCallback()</kbd>. We pass this as an argument to the <kbd>bindCallback()</kbd><span> method</span><span>. This produces a</span> <kbd>fnWithCallbbackBinded()</kbd><span> </span><span>function. Invoking said function will produce an <kbd>Observable</kbd> that we can subscribe to. So, every time <kbd>cb('data')</kbd> in the <kbd>fnWithCallback()</kbd> function is invoked because of the <kbd>setTimeout()</kbd>, this will lead to the data callback for our <kbd>source$</kbd> being invoked. How does this work in practice? It's really quite simple. Let's try to implement our own <kbd>Observable</kbd> for this. We have learned the following:</span></p>
<ul>
<li>A <kbd>bindCallback()</kbd> method takes a function as a parameter</li>
<li>Invoking <kbd>bindCallback()</kbd> should produce a function</li>
<li>Invoking the result of calling <kbd>bindCallback()</kbd> should produce an <kbd>Observable</kbd></li>
<li>Calling <kbd>subscribe()</kbd> should mean that our data callback should be the <kbd>cb</kbd> parameter in <kbd>fnWithCallback()</kbd></li>
</ul>
<p>The resulting implementation should therefore look like this:</p>
<pre>// rxjs-creation-operators/bind-callback.ts<br/><br/>class<span> Observable {<br/></span>  behaviorFn;<br/>  constructor<span>(behaviorFn) {<br/></span>    this<span>.behaviorFn </span><span>=</span><span> behaviorFn;<br/></span>  }<br/><br/>  static<span> bindCallback(behaviorFn)</span><span>:</span><span> Function {<br/></span>    return<span> ()</span><span>:</span><span> Observable </span><span>=&gt;</span><span> {<br/></span>      return<span> </span><span>new</span><span> Observable(behaviorFn);<br/></span>    };<br/>  }<br/><br/>  subscribe(dataCb) {<br/>    this<span>.behaviorFn(dataCb);<br/></span>  }<br/>}<br/><br/>let<span> fn </span><span>=</span><span> Observable.bindCallback(cb </span><span>=&gt;</span><span> {<br/></span>  setTimeout(() <span>=&gt;</span><span> cb(</span><span>"data"</span><span>), </span><span>3000</span><span>);<br/></span>});<br/><br/>const<span> stream$ </span><span>=</span><span> fn();<br/></span>stream$.subscribe(data <span>=&gt;</span><span> console.log(</span><span>"data"</span><span>, data));<br/>// outputs: data data</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cleanup</h1>
                </header>
            
            <article>
                
<p>We have now covered core concepts such as Observable, Observer, Producer, and operators. We have also looked into how we can manually create an Observable, but realized that there are different creation operators that will help you create Observables from other constructs, and sometimes the Angular framework itself will create the Observable for you. We have failed to mention one important thing though, cleanup. There will be situations where an Observable will allocate resources or simply go on forever, as with the <kbd>interval()</kbd> operator. There is one clear remedy to that—define and run a cleanup function when we are done with the Observable. Defining such a function forces us to return to the <kbd>create</kbd> operator and amend some code in its behavior function, like so:</p>
<pre>let stream$ = Rx.Observable.create(observer =&gt; {<br/>  let counter = 0;<br/>  let id = setInterval(() =&gt; observer.next(counter++), 1000);<br/><br/>  <strong>return function cleanUpFn() { clearInterval(id); }</strong><br/>});</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Subscriptions</h1>
                </header>
            
            <article>
                
<p><span>The preceding code describes a situation where there is a need for a cleanup to happen. We have defined a </span><kbd>setInterval()</kbd><span> construct that seemingly emits values forever. </span><kbd>cleanUpFn()</kbd><span> has the ability to cancel that behavior, providing it is being invoked. We return </span><kbd>cleanUpFn()</kbd><span> at the end of our behavior function.</span></p>
<p>The question is, how do we get hold of it? The answer is that we need to talk about a new concept: subscription. A subscription is something that we get back when calling <kbd>subscribe()</kbd> on a stream. Let's amend the preceding code with just that:</p>
<pre>let stream$ = Rx.Observable.create(observer =&gt; {<br/>  let counter = 0;<br/>  let id = setInterval(() =&gt; observer.next(counter++), 1000);<br/><strong>  return function cleanUpFn() { clearInterval(id); }</strong><br/>});<br/><br/><strong>let subscription</strong> = stream$.subscribe((data) =&gt; console.log('data'));<br/>setTimeout(() =&gt; <strong>subscription.unsubscribe()</strong>, 2000);</pre>
<p>In the preceding code, we have created the variable <kbd>subscription</kbd> by calling <kbd>subscribe()</kbd>, but the really interesting part happens in the last line: we define a timeout that calls <kbd>unsubscribe()</kbd> on our <kbd>subscription</kbd>. This will call our <kbd>cleanUpFn()</kbd> so that the interval is cancelled.</p>
<p>Not many streams that you deal with will need to be unsubscribed from, but the ones that allocate resources or start off some construct that goes on forever, without us intercepting, will need to have a cleanup behavior which we need to invoke once we are done with our stream.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a core implementation of RxJS</h1>
                </header>
            
            <article>
                
<p>There are different phases to understanding something. Understanding a library is about learning its concepts and utilizing its methods in the correct way. Then comes deeper understanding, such as knowing what methods to use, based on some best practice guide you found in a blog. Finally, you come to a really deep stage of understanding where you want to understand what is going for relay and starts mucking about in the source code itself and maybe try to enhance it by submitting <span class="packt_screen">Pull Request</span> to a project, most likely based on GitHub.</p>
<p>This section aims to give you part of that deeper knowledge straight away. We are aware that your head might be spinning a little at this point, with all the new concepts you have learned, together with some nifty operators. Let's start from scratch with the concepts first introduced and attempt to reverse engineer what is going on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing create()</h1>
                </header>
            
            <article>
                
<p>At the beginning of this chapter, we were taught how to create an Observable. The code looked like this:</p>
<pre>let stream$ = Rx.Observable.create( observer =&gt; observer.next(1));<br/>stream$.subscribe( data =&gt; console.log(data));</pre>
<p>Just by looking at the code, we can make educated guesses as to what's going on underneath. It's clear we need an <kbd>Observable</kbd> class.</p>
<p>The class needs a <kbd>create()</kbd> method that takes a function as a parameter. The <kbd>create()</kbd> method should return an <kbd>Observable</kbd>. Furthermore, our <kbd>Observable</kbd> class needs a <kbd>subscribe()</kbd> <span>method </span><span>that takes a function as a parameter. Let's start off there and see where we land.</span></p>
<p>First, let's define our <kbd>Observable</kbd> class with the aforementioned methods:</p>
<pre>class MyObservable {<br/>  static create(behaviourFn): MyObservable {}<br/>  constructor() {}<br/>  subscribe(dataFn) {}<br/>}</pre>
<p>OK, so we have a class with three methods in it; let's attempt to implement the methods. Let's take what we know about the <kbd>create()</kbd> method and start from there:</p>
<pre>class MyObservable {<br/>  static create(behaviourFn): MyObservable {<br/>    <strong>return new Observable(behaviourFn);<br/></strong>  }<br/>  constructor(private <strong>behaviourFn</strong>) {}<br/>  subscribe(dataFn) {}<br/>}</pre>
<p>We highlighted the required changes in bold and introduced a field on the class called <kbd>behaviourFn()</kbd>. Furthermore, our <kbd>create()</kbd> method instantiated an <kbd>Observable</kbd> by passing in <kbd>behaviourFn</kbd> from the <kbd>create()</kbd> method parameter. This means the constructor needs to take a function as a parameter and save that for later use. What do we know about the <kbd>behaviourFn()</kbd> that was passed into the create method? We know it takes an Observer instance as a parameter and it also lays out what values the Observer instance should emit. For anything to be able to capture those emitted values, we need to implement our last method, <kbd>subscribe()</kbd>. We know that <kbd>subscribe()</kbd> takes <kbd>dataFn()</kbd> as a parameter and needs to somehow invoke our <kbd>behaviourFn</kbd> when the <kbd>subscribe()</kbd> method is being invoked to trigger the behavior. Let's therefore amend that in our existing code:</p>
<pre>class MyObservable {<br/>  static create(private behaviourFn): MyObservable { <br/>    return new MyObservable(behaviourFn);<br/>  }<br/>  constructor(behaviourFn) { this.behaviourFn = behaviourFn; }<br/>  subscribe(dataFn) {<br/>    this.behaviourFn(observer);<br/>  }<br/>}</pre>
<p>At this point, we realize that we need an <kbd>Observer</kbd> class so that we actually have something to pass to our <kbd>behaviourFn()</kbd>. Another thing we need to figure out is how to invoke <kbd>dataFn()</kbd> and when. After a thinking for a minute, we realize the Observer must be the one responsible for invoking <kbd>dataFn()</kbd> so it seems <span>only </span>reasonable that <kbd>dataFn()</kbd> is passed into the constructor of our <kbd>Observer</kbd> class for later use, like so:</p>
<pre>class Observer {<br/>  constructor(<strong>private dataFn</strong>) {}<br/>  next(value) { <strong>this.dataFn(val)</strong> }<br/>}</pre>
<p>By implementing this <kbd>Observer</kbd> class, we have done three things: one is to pass the <kbd>dataFn()</kbd> through the constructor and make it into a field on the <kbd>Observer</kbd> class; another is to create a <kbd>next()</kbd> method on the <kbd>Observer</kbd>, which had to be done as we learned that an Observer instance should call <kbd>next()</kbd> to generate values; the third and final thing we did was to ensure that we invoked <kbd>dataFn()</kbd> inside of the <kbd>next()</kbd> method to be sure that the subscriber is being told every time we generate a value by calling the <kbd>next()</kbd> method. Putting all of this code together, we have created a very bare implementation of RxJS, which actually works! To better understand what we have so far, let's display all the code used so far:</p>
<pre>// rxjs-core/Observable.ts<br/><br/>class Observer {<br/>  constructor(private dataFn) {}<br/>  next(value) { this.dataFn(value) }<br/>}<br/><br/>class MyObservable {<br/>  behaviourFn<strong>;</strong><br/>  static create(behaviourFn): MyObservable {<br/>    return new Observable(behaviourFn);<br/>  }<br/>  constructor(behaviourFn) { this.behaviourFn = behaviourFn; }<br/>  subscribe(dataFn) {<br/>    let observer = new Observer(dataFn);<br/>    this.behaviourFn( observer );<br/>  }<br/>}<br/><br/>let stream$ = MyObservable.create( observer =&gt; observer.next(1)); // 1</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling subscriptions</h1>
                </header>
            
            <article>
                
<p>We learned how to implement a very basic core in the last section. Earlier in the chapter, however, it was mentioned that sometimes your Observable will allocate resources or will display a behavior where it clearly won't be able to stop generating values. It is our responsibility to handle such situations in a graceful manner. RxJS has clearly laid out a path here, which is to define a cleanup function and ensure it is invoked upon calling <kbd>unsubscribe()</kbd>. Let's show such a scenario, where we clearly need to care about cleaning up:</p>
<pre>// rxjs-core/Observer-with-subscription.ts<br/><br/>interface<span> Subscription {<br/></span>  unsubscribe();<br/>}<br/><br/>class<span> MyObservableWithSubscription {<br/></span>  static<span> create(behaviourFn)</span><span>:</span><span> MyObservableWithSubscription {<br/></span>    return<span> </span><span>new</span><span> MyObservableWithSubscription(behaviourFn);<br/></span>  }<br/><br/>  constructor<span>(</span><span>private</span><span> behaviourFn) {}<br/></span><br/>  subscribe(dataFn)<span>:</span><span> Subscription {<br/></span>    let<span> observer </span><span>=</span><span> </span><span>new</span><span> MyObserver(dataFn);<br/></span>    <strong>let cleanUpFn = this</strong><span><strong>.behaviourFn(observer);</strong><br/></span>    return<span> {<br/></span>      unsubscribe: <strong>cleanUpFn</strong><br/>    };<br/>  }<br/>}<br/><br/>let<span> streamWithSubscription$ </span><span>=</span><span> MyObservableWithSubscription.create(observer </span><span>=&gt;</span><span> {<br/></span>  let<span> counter </span><span>=</span><span> </span><span>0</span><span>;<br/></span>  let<span> id </span><span>=</span><span> setInterval(() </span><span>=&gt;</span><span> observer.next(counter</span><span>++</span><span>), </span><span>1000</span><span>);<br/></span>  return<span> </span><span>function</span><span> cleanUpFn() {<br/></span>    clearInterval(id);<br/>  };<br/>});<br/><br/>const<span> subscription </span><span>=</span><span> streamWithSubscription$.subscribe(data </span><span>=&gt;<br/></span>  console.log(<span>"data"</span><span>, data)<br/></span>);<br/><br/>subscription<strong>.unsubscribe()</strong>;</pre>
<p>Looking at the code, we see that when we define the behavior function (at the bottom of the code snippet), we set up a  <kbd>setInterval()</kbd> construct that calls <kbd>observer.next(</kbd>) periodically. We ensure we save the reference in a variable ID. This need to be sure that we can cancel the <kbd>setInterval()</kbd> behavior when we choose to. We do that by defining a <kbd>cleanUpFn()</kbd> in the last row of the <kbd>behaviourFn</kbd> function. This brings us to the top half of our snippet. Here, we see that we amend the <kbd>subscribe()</kbd> method by ensuring we save the result of calling <kbd>this.behaviourFn()</kbd> into a variable called <kbd>cleanUpFn</kbd>. This is indeed the <kbd>cleanUpFn()</kbd> we defined in <kbd>behaviourFn()</kbd>. Lastly, we expose the <kbd>cleanUpFn()</kbd> property by returning it as part of an object and assigning it to the <kbd>unsubscribe() </kbd><span>property</span><span>. The last thing we need to do is to call the </span><kbd>unsubscribe()</kbd><span> method to ensure our allocated resources are released or, as in this specific example, that the </span><kbd>setInterval()</kbd><span> construct is cancelled. Calling unsubscribe will call   <kbd>cleanUpFn()</kbd>   which in turn calls <kbd>clearInterval()</kbd>, which will cancel the interval.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding operators</h1>
                </header>
            
            <article>
                
<p>We have come a long way in defining our own core implementation of RxJS, but we are missing an important piece of the puzzle—operators. Operators are the real power of RxJS and can be seen as a utility method that allows us to manipulate our stream with ease. Let's select <kbd>filter()</kbd> as the target of our example. A filter operator is a method that you can call on the stream. The idea is to provide it with a function that is able to determine, value for value, whether the specific value in question should be emitted. A typical use case looks like the following:</p>
<pre>let stream$ = Observable.of(1,2,3)<br/>  .filter( x =&gt; x &gt; 1 );<br/><br/>stream$.subscribe( data =&gt; console.log(data)) <br/>// will emit 2,3</pre>
<p>In the preceding code, we can see that the function we provide as a parameter to the filter function effectively sorts out any values not meeting the condition. In this case, all values above <kbd>1</kbd> will be emitted, thereby sorting the value <kbd>1</kbd>. Let's add the <kbd>filter()</kbd> method to our previously defined <kbd>MyObservable</kbd> class, like so:</p>
<pre>// rxjs-core/operator/Observable.ts, starting off with MyObservable, more to come<br/><br/>import<span> { MyObserver } </span><span>from</span><span> </span><span>"./Observer"</span><span>;<br/></span><br/>class<span> MyObservable {<br/></span>  behaviorFn;<br/>  <br/>  static<span> create(behaviourFn)</span><span>:</span><span> MyObservable {<br/></span>    return<span> </span><span>new</span><span> MyObservable(behaviourFn);<br/></span>  }<br/><br/> constructor<span>(behaviorFn) {<br/></span>   this<span>.behaviorFn </span><span>=</span><span> behaviorFn;<br/></span> }<br/><br/> <strong>filter(filterFn): FilterableObservable {<br/>   /* implement */<br/> }</strong><br/><br/> subscribe(dataFn) {<br/>   let<span> observer </span><span>=</span><span> </span><span>new</span><span> MyObserver(dataFn);<br/></span>   let<span> cleanUpFn </span><span>=</span><span> </span><span>this</span><span>.behaviorFn(observer);<br/></span> <br/>   return<span> {<br/></span>     unsubscribe: cleanUpFn<br/>   };<br/> }<br/>}</pre>
<p>We can see from the preceding snippet that the <kbd>filter()</kbd> method is added to the <kbd>MyObservable</kbd> and we see that it itself returns an Observable, while also taking a <kbd>filterFn()</kbd> as a parameter. The question you need to ask yourself is whether our existing <kbd>MyObservable</kbd> constructor will do. Our existing constructor takes a <kbd>behaviourFn()</kbd> and we most likely need to store the incoming <kbd>filterFn</kbd> parameter, so we need to extend the constructor or opt for a new implementation of an <kbd>MyObservable</kbd>. We ponder this for a second and realize its probably better to go for a new, more dedicated <kbd>MyObservable</kbd> as we want to avoid a lot of branching logic. Therefore, the implementation of said method should be amended to look something like this:</p>
<pre>// rxjs-core/operator/Observable.ts, starting off with MyObservable, more to come<br/><br/>import<span> { MyObserver } </span><span>from</span><span> </span><span>"./Observer"</span><span>;<br/></span><br/>class<span> MyObservable {<br/></span>  behaviorFn;<br/>  <br/>  static<span> create(behaviourFn)</span><span>:</span><span> MyObservable {<br/></span>    return<span> </span><span>new</span><span> MyObservable(behaviourFn);<br/></span>  }<br/><br/> constructor<span>(behaviorFn) {<br/></span>   this<span>.behaviorFn </span><span>=</span><span> behaviorFn;<br/></span> }<br/><br/> <strong>filter(filterFn): FilterableObservable {<br/>   return new FilterableObservable(filterFn, this.behaviorFn);<br/> }</strong><br/><br/> subscribe(dataFn) {<br/>   let<span> observer </span><span>=</span><span> </span><span>new</span><span> MyObserver(dataFn);<br/></span>   let<span> cleanUpFn </span><span>=</span><span> </span><span>this</span><span>.behaviorFn(observer);<br/></span> <br/>   return<span> {<br/></span>     unsubscribe: cleanUpFn<br/>   };<br/> }<br/>}</pre>
<p>OK, so now we have a new class to implement, <kbd>FilterableObservable</kbd>. This class should share most of the behavior of the <kbd>MyObservable</kbd>, but instead show how we emit data. So, we are talking about inheriting from <kbd>MyObservable</kbd> but with our own special twist. Let's attempt an implementation:</p>
<pre>// rxjs-core/operator/Observable.ts<br/><br/>import<span> { MyObserver } </span><span>from</span><span> </span><span>"./Observer"</span><span>;<br/></span><br/>class<span> MyObservable {<br/></span>  behaviorFn;<br/>  <br/>  static<span> create(behaviourFn)</span><span>:</span><span> MyObservable {<br/></span>    return<span> </span><span>new</span><span> MyObservable(behaviourFn);<br/></span>  }<br/><br/>  constructor<span>(behaviorFn) {<br/></span>    this<span>.behaviorFn </span><span>=</span><span> behaviorFn;<br/></span>  }<br/><br/>  filter(filterFn)<span>:</span><span> FilterableObservable {<br/></span>    return<span> </span><span>new</span><span> FilterableObservable(filterFn, </span><span>this</span><span>.behaviorFn);<br/></span>  }<br/><br/>  subscribe(dataFn) {<br/>    let<span> observer </span><span>=</span><span> </span><span>new</span><span> MyObserver(dataFn);<br/></span>    let<span> cleanUpFn </span><span>=</span><span> </span><span>this</span><span>.behaviorFn(observer);<br/></span>    <br/>     return<span> {<br/></span>      unsubscribe: cleanUpFn<br/>     };<br/>  }<br/>}<br/><br/>export<span> </span><span>class</span><span> FilterableObservable </span><span>extends</span><span> MyObservable {<br/></span>  constructor<span>(</span><span>private</span><span> filterFn, behaviourFn) {<br/></span>    super<span>(behaviourFn);<br/></span>  }<br/><br/>  subscribe(dataFn) {<br/>    let<span> observer </span><span>=</span><span> </span><span>new</span><span> MyObserver(dataFn);<br/></span>    <br/>    observer<strong>.next = value =&gt; {<br/>      if (this.filterFn(value)) {<br/>        dataFn(value);</strong><br/><strong>      }</strong><br/><strong>    };</strong><br/><br/>    let<span> cleanUpFn </span><span>=</span><span> </span><span>this</span><span>.behaviorFn(observer);<br/></span>    return<span> {<br/></span>      unsubscribe: cleanUpFn<br/>    };<br/>  }<br/>}<br/><br/>const<span> stream$ </span><span>=</span><span> </span><span>new</span><span> MyObservable(observer </span><span>=&gt;</span><span> {<br/></span>  observer.next(<span>1</span><span>);<br/></span>  observer.next(<span>2</span><span>);<br/></span>  observer.next(<span>3</span><span>);<br/></span>}).filter(x <span>=&gt;</span><span> x </span><span>&gt;</span><span> </span><span>2</span><span>);<br/></span><br/>stream$.subscribe(data <span>=&gt;</span><span> console.log(</span><span>"data"</span><span>, data));<br/><br/></span><span>// prints 3</span></pre>
<p>We can see in the preceding code snippet that we override the <kbd>subscribe()</kbd> implementation, or more specifically, we override the <kbd>next()</kbd> method on the <kbd>Observer</kbd> instance. We use <kbd>filterFn()</kbd> for what it was made for, to assess whether something should be generated or not. We have now successfully implemented the <kbd>filter()</kbd> operator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Revisiting the basics, adding errors, and complete</h1>
                </header>
            
            <article>
                
<p>After having taken on the heroic feat of implementing the basics of RxJS, we hopefully feel pretty good about understanding its inner workings. So far, we have only implemented <kbd>dataFn</kbd> in <kbd>subscribe()</kbd>; there are two more callbacks in the <kbd>subscribe()</kbd> method that we need to implement. Let's look at a code snippet and highlight what is missing:</p>
<pre>let stream$ = Rx.Observable.of(1,2,3);<br/>stream$.subscribe(<br/>  data =&gt; console.log(data),<br/><strong>  err =&gt; console.error(err),</strong><br/><strong>  () =&gt; console.log('complete');</strong>  <br/>)</pre>
<p>We have highlighted the two last callbacks as the missing functionality. We know from before that to trigger the error callback, we need to call <kbd>observer.error('some message')</kbd>. We also know that no values should be emitted after an error is raised. Let's provide an example of such a case:</p>
<pre>let stream$ = Rx.Observable.create( observer =&gt; {<br/>  observer.next(1);<br/>  observer.error('err');<br/>  observer.next(2); <br/>});<br/><br/>stream$.subscribe( <br/>  data =&gt; console.log(data),<br/>  err =&gt; console.error(err)<br/>);  <br/>// should emit 1, err</pre>
<p>At this point, we realize that our <kbd>Observer</kbd> class is the one that needs amending to support the <kbd>error()</kbd> method call. We also need to be wary of the condition we just described, as no more values should be emitted after an error has occurred. Let's jump into an implementation:</p>
<pre>class Observer {<br/>  hasError: boolean;<br/>  constructor(private dataFn, <strong>private errorFn</strong>) {}<br/>  next(value) { <br/><strong>    if (!this.hasError) {</strong> <br/>      this.dataFn(value); <br/><strong>    }</strong> <br/>  }<br/><br/>  <strong>error(err) { <br/>    this.errorFn(err); <br/>    this.hasError = true; <br/>  }</strong><br/>}</pre>
<p>We can see in the preceding snippet that we pass another parameter into the <kbd>errorFn </kbd><span>constructor</span><span>. The </span><kbd>next()</kbd><span> method needed updating, so we needed to envelope it with a conditional that says whether to generate a value or not. Lastly, we needed to define the </span><kbd>error()</kbd><span> method as calling the passed-in </span><kbd>errorFn</kbd><span> and setting the </span><kbd>hasError</kbd><span> field to <kbd>true</kbd>.</span></p>
<p>We need to do one more thing and that is to update our <kbd>subscribe()</kbd> method in the <kbd>Observable</kbd> class:</p>
<pre><br/>class Observable {<br/>  behaviourFn<strong>;</strong><br/>  static create(behaviourFn): Observable {<br/>    return new Observable(behaviourFn);<br/>  }<br/><br/>  constructor(behaviourFn) { <br/>    this.behaviourFn = behaviourFn; <br/>  }<br/><br/>  subscribe(dataFn, <strong>errorFn</strong>) {<br/>    let observer = new Observer(dataFn, <strong>errorFn</strong>);<br/>    let cleanUpFn = this.behaviourFn(observer);<br/><br/>    return { <br/>      unsubscribe: cleanUpFn <br/>    };<br/>  }<br/>}<br/><br/></pre>
<p>A little heads up is that when we define the <kbd>filter()</kbd> operator to override the  <kbd>next()</kbd> method, we need to ensure this one takes <kbd>hasError</kbd> into consideration when determining whether to generate a value. We'll leave this to you, dear reader, to implement.</p>
<p>The last order of business is to support completion. Completion has many similarities with raising an error, in the sense that no more values should be emitted. The difference is that we should hit the last callback instead. As with the <kbd>error()</kbd> method implementation, we start with the <kbd>Observer</kbd> implementation:</p>
<pre>// rxjs-core/error-complete/Observer.ts<br/><br/>class Observer {<br/>  hasError: boolean;<br/>  <strong>isCompleted: boolean;<br/></strong><br/>  constructor(<br/>    private dataFn, <br/>    private errorFn, <br/><strong>    private completeFn<br/></strong>  ) {}<br/><br/>  next(value) { <br/>    if(!this.hasError<strong> &amp;&amp; !this.isCompleted) {</strong> <br/>      this.dataFn(value); <br/><strong>    }</strong> <br/>  }<br/><br/>  error(err) { <br/>    this.errorFn(err); <br/>    this.hasError = true; <br/>  }<br/><strong><br/></strong>  <strong>complete() { <br/>    this.completeFn(); <br/>    this.isCompleted = true; <br/>  }</strong><br/>}</pre>
<p>Given the preceding code, we see that our changes entail adding an <kbd>isCompleted</kbd> field. We also pass a <kbd>completeFn()</kbd> in the constructor. Logic needs to be added in the <kbd>next()</kbd> value, as completion is now another state we need to look for besides error. Lastly, we added the <kbd>complete()</kbd> method, which just invokes the passed-in function and sets the <kbd>isComplete</kbd> field to <kbd>true</kbd>.</p>
<p>As before, we need to update the <kbd>Observable</kbd> class to pass the complete function:</p>
<pre>// rxjs-core/error-complete/Observable.ts<br/><br/>import { Observer } from './Observer';<br/><br/>class Observable {<br/>  behaviourFn<strong>;<br/></strong><br/>  static create(behaviourFn): Observable {<br/>    return new Observable(behaviourFn);<br/>  }<br/><br/>  constructor(behaviourFn) { <br/>    this.behaviourFn = behaviourFn; <br/>  }<br/><br/>  filter(filterFn):Observable {<br/>    return new FilterableObservable(<br/>      filterFn, <br/>      this.behaviourFn<br/>    );<br/>  }<br/><br/>  subscribe(dataFn, errorFn<strong>, completeFn</strong>) {<br/>    let observer = new Observer(dataFn, errorFn, <strong>completeFn</strong>);<br/>    let cleanUpFn = this.behaviourFn( observer );<br/><br/>    return { <br/>      unsubscribe: cleanUpFn <br/>    };<br/>  }<br/>}<br/><br/>const<span> stream$ </span><span>=</span><span> </span><span>new</span><span> Observable(observer </span><span>=&gt;</span><span> {<br/></span>  observer.next(<span>1</span><span>);<br/></span>  observer.error(<span>"error"</span><span>);<br/></span>  observer.next(<span>2</span><span>);<br/></span>});<br/><br/>stream$.subscribe(<br/>  data <span>=&gt;</span><span> console.log(</span><span>"data"</span><span>, data),<br/></span>  err <span>=&gt;</span><span> console.log(</span><span>"error"</span><span>, err),<br/></span>  () <span>=&gt;</span><span> console.log(</span><span>"completed"</span><span>)<br/></span>);<br/><br/>// prints 1, error, no more is emitted after that</pre>
<p>A quick reality check here: we have actually implemented the core functionality of RxJS—Observer, Observable, and one operator. We are much closer to understanding what is going on. We realize that implementing the other 59 operators is quite a feat, and it is probably not a good idea when there is a team maintaining the existing RxJS repository. Our newfound knowledge is not for nothing; understanding what is going on can never be wrong. Who knows? Maybe one of you readers will become a contributor; you have certainly been given the tools. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We started off by talking about the patterns that make up RxJS. We continued by describing its core concepts. This was followed by describing how and when it was necessary to create your own Observable, opt for one of RxJS many creation operators, or rely on the Angular framework to do this job for you. We briefly discussed the importance of cleaning up after your Observable and when it was a good idea to do so.</p>
<p>Lastly, we took on the task of implementing part of the RxJS core to gain a deeper understanding of its core concepts and how it all came together. This has hopefully given you a pretty solid foundation and in-depth understanding of RxJS as we venture into the next chapter, which will cover more operators, and some more advanced concepts.</p>


            </article>

            
        </section>
    </body></html>