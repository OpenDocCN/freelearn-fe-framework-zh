<html><head></head><body>
		<div id="_idContainer032">
			<h1 id="_idParaDest-77"><em class="italic"><a id="_idTextAnchor081"/>Chapter 6</em>: Building an Application Exploring TDD Using the React Testing Library and Cypress</h1>
			<p>To keep your application maintainable, it is good practice to have testing set up for your project. Whereas some developers hate writing tests and therefore try to avoid writing them, other developers like to make testing the core of their development process by implementing a <strong class="bold">Test-Driven Development</strong> (<strong class="bold">TDD</strong>) strategy. There are many opinions about testing your applications and how to do this. Luckily, when building an application with React, many great libraries can help you with testing.</p>
			<p>In this chapter, you'll use the <strong class="bold">React Testing Library</strong> tool to unit-test React applications. This library is maintained by the React community itself and ships with Create React App. It has lots of functionalities tailored to testing entire life cycles within your components and other React features. Therefore, the React Testing Library is a great fit for testing most React applications if you want to test whether functions or components behave as expected when they're given a certain input. Also, we'll be exploring another tool called <strong class="bold">Cypress</strong> that is perfect for end-to-end testing of our React application.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Unit testing components</li>
				<li>Testing React state and Hooks</li>
				<li>End-to-end testing with Cypress</li>
			</ul>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor082"/>Project overview</h1>
			<p>In this chapter, we <a id="_idIndexMarker322"/>will create a hotel review application build with React that has state management with the Context API. The React Testing Library will be added to perform unit and integration testing for this application, while Cypress is used for end-to-end testing. The application has been prebuilt and uses the same patterns that we've looked at in the previous chapters.</p>
			<p>The build time is 2 hours.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor083"/>Getting started</h1>
			<p>The application for this chapter builds upon an initial version, which can be found at <a href="https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter06-initial">https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter06-initial</a>. The complete code for this chapter can be found on GitHub: <a href="https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter06">https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter06</a>.</p>
			<p>Start by <a id="_idIndexMarker323"/>downloading the initial project from GitHub and move into the root directory for this project, where you must run the <strong class="source-inline">npm install</strong> command. Since this project builds upon Create React App, running this command will install <strong class="source-inline">react</strong>, <strong class="source-inline">react-dom</strong>, and <strong class="source-inline">react-scripts</strong>. Also, <strong class="source-inline">styled-components</strong> and <strong class="source-inline">react-router-dom</strong> will be installed so that they can handle styling and routing for the application. Something else that will be installed is the React Test Library, which you will recognize with the <strong class="source-inline">@testing-library/*</strong> prefix. After finishing the installation process, you can execute the <strong class="source-inline">npm start</strong> command to run the application so that you can visit the project in the browser at <strong class="source-inline">http://localhost:3000</strong>. The initial application consists of a simple header and a list of hotels. These hotels have a title and meta information, such as a thumbnail. This page will look as follows:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_6.1_B17390.jpg" alt="Figure 6.1 – The initial application"/>
				</div>
			</div>
			<p class="figure-caption">   </p>
			<p class="figure-caption">Figure 6.1 – The initial application</p>
			<p>If you click<a id="_idIndexMarker324"/> on any of the hotels in the list, a new page will open with a list of reviews for this hotel. By clicking the button at the top left of this page, you can move back to the previous page, and with the button at the top right, a page with a form where you can add a review will open. If you add a new review, this data will be stored in a global context and sent to a mock API server:</p>
			<p>If you look at the <a id="_idIndexMarker325"/>project's structure, you'll see that it's using the same structure as the projects we created previously:</p>
			<p class="source-code">chapter-6-initial </p>
			<p class="source-code">  |- node_modules </p>
			<p class="source-code">  |- public </p>
			<p class="source-code">  |- package.json </p>
			<p class="source-code">  |- src </p>
			<p class="source-code">     |- components </p>
			<p class="source-code">        |- Button </p>
			<p class="source-code">           |- Button.js </p>
			<p class="source-code">        |- FormItem </p>
			<p class="source-code">           |- FormItem.js </p>
			<p class="source-code">        |- Header </p>
			<p class="source-code">           |- Header.js </p>
			<p class="source-code">        |- HotelItem </p>
			<p class="source-code">           |- HotelItem.js </p>
			<p class="source-code">        |- NavBar </p>
			<p class="source-code">           |- NavBar.js </p>
			<p class="source-code">        |- ReviewItem </p>
			<p class="source-code">           |- ReviewItem.js </p>
			<p class="source-code">     |- context </p>
			<p class="source-code">        |- AppContext.js </p>
			<p class="source-code">        |- HotelsContext.js </p>
			<p class="source-code">        |- ReviewsContext.js </p>
			<p class="source-code">     |- pages </p>
			<p class="source-code">        |- HotelDetail.js </p>
			<p class="source-code">        |- Hotels.js </p>
			<p class="source-code">        |- ReviewForm.js </p>
			<p class="source-code">     |- App.js </p>
			<p class="source-code">     |- index.js </p>
			<p class="source-code">     |- setupTests.js</p>
			<p>Important<a id="_idIndexMarker326"/> for this chapter is the <strong class="source-inline">setupTests.js</strong> file, which is used to configure the React Testing Library for this project. The entry point of this application is a file called <strong class="source-inline">src/index.js</strong>, which renders a component called <strong class="source-inline">App</strong>. In this <strong class="source-inline">App</strong> component, all the routes are declared and wrapped within a <strong class="source-inline">Router</strong> component. These routes are as follows: </p>
			<ul>
				<li><strong class="source-inline">/</strong>: This renders <strong class="source-inline">Hotels</strong>, with an overview of all of the hotels. </li>
				<li><strong class="source-inline">/hotel/:hotelId</strong>: This renders <strong class="source-inline">HotelDetail</strong>, with an overview of all reviews for a specific hotel. </li>
				<li><strong class="source-inline">/hotel/:hotelId/new</strong>: This renders <strong class="source-inline">ReviewForm</strong>, with a form to add new reviews to a specific hotel. </li>
			</ul>
			<p>The data is fetched from a mock server that was created using the free <strong class="bold">My JSON Server</strong> service, which <a id="_idIndexMarker327"/>creates a server from the <strong class="source-inline">db.json</strong> file in the root directory of your project in GitHub. This file consists of a JSON object that has two fields, <strong class="source-inline">hotels</strong> and <strong class="source-inline">reviews</strong>, which creates multiple endpoints on a mock server. The ones you'll be using in this chapter are as follows: </p>
			<ul>
				<li><a href="https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/hotels">https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/hotels</a><span class="hidden"> </span></li>
				<li><a href="https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/reviews">https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/reviews</a><span class="hidden"> </span></li>
			</ul>
			<p>The <strong class="source-inline">db.json</strong> file must be present in the master branch (or default branch) of your GitHub repository for My JSON Server to work. Otherwise, you'll receive a <strong class="bold">404 Not Found</strong> message when trying to request the API endpoints. </p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor084"/>The hotel review application</h1>
			<p>In this <a id="_idIndexMarker328"/>section, we will add unit and integration testing to<a id="_idIndexMarker329"/> the hotel review application that was created in Create React App. This application lets you add reviews to a list of hotels and controls this data from an application context. The React Testing Library will be used to render React components to test assertions on these components. </p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor085"/>Unit testing components</h2>
			<p>Unit testing<a id="_idIndexMarker330"/> is <a id="_idIndexMarker331"/>an important part of your application, since you want to know that your functions and components behave as expected, even when you make code changes. For this, we're going to use the React Testing Library, an <a id="_idIndexMarker332"/>open source<a id="_idIndexMarker333"/> testing package for React applications that was created by the React community. With the React Testing Library, you can test assertions – for example, whether the output of a function matches the value you expected. </p>
			<p>To get started, we don't have to install anything; it's part of Create React App. If you look at the <strong class="source-inline">package.json</strong> file, you will see that a script is already there for running tests. Let's see what happens if you execute the following command from your terminal:</p>
			<p class="source-code">npm run test </p>
			<p>This will return a message saying <strong class="source-inline">No tests found related to files changed since last commit.</strong>, which means our tests are running in watch mode and only running tests for files that have been changed. Under the hood, the Jest test runner is used to run our tests. By pressing the <em class="italic">A</em> key, you can run all the tests, even if you haven't modified any files. If you press this key, the following message will be displayed:</p>
			<p class="source-code">No tests found related to files changed since last commit. </p>
			<p>Jest will automatically check all our files within the <strong class="source-inline">src</strong> directory and look for test files. In the first part of this section, we'll show how we can create tests that can be run with Jest using the React Test Library. </p>
			<h3>Creating a unit test</h3>
			<p>Since there are multiple ways that Jest can detect which file contains a test, let's choose a structure<a id="_idIndexMarker334"/> where every component has a separate test file. This test file will have the same name as the file that holds the component, with the <strong class="source-inline">.test</strong> suffix. If we choose the <strong class="source-inline">NavBar</strong> component, we can create a new file called <strong class="source-inline">NavBar.test.js</strong> in the <strong class="source-inline">src/components/NavBar</strong> directory. Add the following code to this file:</p>
			<p class="source-code">test('The NavBar component should render', () =&gt; {</p>
			<p class="source-code">    </p>
			<p class="source-code">});</p>
			<p>The global <strong class="source-inline">test</strong> function from Jest is used here to define a test; the test assertions can be placed within the curly brackets. Alternatively, you can also use the <strong class="source-inline">describe</strong> or <strong class="source-inline">it</strong> functions to declare a (block) of tests.</p>
			<p>If we now run the <strong class="source-inline">npm run test</strong> command again, the Jest runner will find our first test and show the following output:</p>
			<p class="source-code">PASS  src/components/NavBar/NavBar.test.js</p>
			<p class="source-code">  ✓ The NavBar component should render (1 ms)</p>
			<p class="source-code">Test Suites: 1 passed, 1 total</p>
			<p class="source-code">Tests:       1 passed, 1 total</p>
			<p class="source-code">Snapshots:   0 total</p>
			<p class="source-code">Time:        3.105 s</p>
			<p class="source-code">Ran all test suites related to changed files.</p>
			<p>Within the definition of a test, you can add assumptions such as <strong class="source-inline">toEqual</strong> or <strong class="source-inline">toBe</strong>, which check whether the value is exactly equal to something or whether the types just match respectively. The assumptions can be added within the callback of the <strong class="source-inline">test</strong> function:</p>
			<p class="source-code">  test('The NavBar component should render', () =&gt; {</p>
			<p class="source-code"><strong class="bold">+   expect(1 + 2).toBe(3);</strong></p>
			<p class="source-code">  });</p>
			<p>If you still <a id="_idIndexMarker335"/>have the test script running in your terminal, you will see that Jest has detected your test. The test succeeds, since <strong class="source-inline">1+2</strong> is indeed <strong class="source-inline">3</strong>. Let's go ahead and change the assumption to the following:</p>
			<p class="source-code">  test('The NavBar component should render', () =&gt; {</p>
			<p class="source-code"><strong class="bold">-   expect(1 + 2).toBe(3);</strong></p>
			<p class="source-code"><strong class="bold">+   expect(1 + 2).toBe('3');</strong></p>
			<p class="source-code">  });</p>
			<p>Now, the test will fail, as the second assumption doesn't match. Although <strong class="source-inline">1+2</strong> still equals <strong class="source-inline">3</strong>, it's assumed that a string type with a value of <strong class="source-inline">3</strong> is returned, while in fact a number type is returned. If you're still running the <strong class="source-inline">npm run test</strong> command in the terminal, you can also see this explanation described there.</p>
			<p>However, this assumption has no actual usage, as it doesn't test your component. To test your component, you need to render it. Rendering components so that you can test them will be handled in the next part of this section.</p>
			<h3>Rendering a React component for testing</h3>
			<p>Jest is <a id="_idIndexMarker336"/>based upon Node.js, meaning that it can't use the browser or (virtual) DOM to render your component and test its functionality. Therefore, we'll be using the React Testing Library to help us render these components. Create React App comes with this library by default, and the packages it uses can be<a id="_idIndexMarker337"/> found in the <strong class="source-inline">package.json</strong> file:</p>
			<ul>
				<li><strong class="source-inline">@testing-library/jest-dom</strong>: Provides custom elements to test the DOM</li>
				<li><strong class="source-inline">@testing-library/react</strong>: The core package for the React Testing Library </li>
				<li><strong class="source-inline">@testing-library/user-events</strong>: Provides methods to test user interactions</li>
			</ul>
			<p>The React Testing Library can render React components for us so that we can write tests for them. The <a id="_idIndexMarker338"/>preceding packages will be used to create our tests:</p>
			<ol>
				<li>In our test file for the <strong class="source-inline">NavBar</strong> component, we can render the component with the <strong class="source-inline">render</strong> method from <strong class="source-inline">@testing-library/react</strong> and get the output of this component. With the Jest <strong class="source-inline">toMatchSnapshot</strong> assumption, we can test the <a id="_idIndexMarker339"/>structure of the component by creating a snapshot from this render and comparing it to the actual component every time this test is run:<p class="source-code"><strong class="bold">+ import { render } from '@testing-library/react';</strong></p><p class="source-code"><strong class="bold">+ import NavBar from './NavBar';</strong></p><p class="source-code">  test('The NavBar component should render', () =&gt; {</p><p class="source-code"><strong class="bold">-   expect(1 + 2).toBe('3');</strong></p><p class="source-code"><strong class="bold">+   const view = render(&lt;NavBar /&gt;);</strong></p><p class="source-code"><strong class="bold">+   expect(view).toMatchSnapshot();</strong></p><p class="source-code">  });</p></li>
				<li>In the <strong class="source-inline">src/components/NavBar</strong> directory, a new directory called <strong class="source-inline">__snapshots__</strong> has now been created by Jest. Inside this directory is a file called <strong class="source-inline">NavBar.test.js.snap</strong>, which includes the snapshot. If you open this file, you will see that a rendered version of the <strong class="source-inline">NavBar</strong> component is stored here:<p class="source-code">// Jest Snapshot v1, https://goo.gl/fbAQLP</p><p class="source-code">exports[`The NavBar component should render 1`] = `</p><p class="source-code">Object {</p><p class="source-code">  "asFragment": [Function],</p><p class="source-code">  "baseElement": &lt;body&gt;</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">      &lt;div</p><p class="source-code">        class="sc-gsDJrp PAvEv"</p><p class="source-code">      &gt;</p><p class="source-code">        &lt;h2</p><p class="source-code">          class="sc-dkPtyc jFfuUr"</p><p class="source-code">        /&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/body&gt;,</p><p class="source-code">  // ...</p></li>
			</ol>
			<p>The components that have been created with <strong class="source-inline">styled-components</strong> will be rendered as HTML elements with a class name prefixed by <strong class="source-inline">sc-*</strong>. </p>
			<ol>
				<li value="3">No <a id="_idIndexMarker340"/>actual values are being rendered<a id="_idIndexMarker341"/> by the React Testing Library since no props have been passed to the <strong class="source-inline">NavBar</strong> component. You can inspect how the snapshot works by passing, for instance, a <strong class="source-inline">title</strong> prop to the component:<p class="source-code">  import { render } from '@testing-library/react';</p><p class="source-code">  import NavBar from './NavBar';</p><p class="source-code">  // ...</p><p class="source-code"><strong class="bold">+ test('The NavBar component should render with a title',</strong></p><p class="source-code"><strong class="bold">    () =&gt; {</strong></p><p class="source-code"><strong class="bold">+   const view = render(&lt;NavBar title='Test application' </strong></p><p class="source-code"><strong class="bold">                        /&gt;);</strong></p><p class="source-code"><strong class="bold">+   expect(view).toMatchSnapshot();</strong></p><p class="source-code"><strong class="bold">+ });</strong></p></li>
				<li>The <a id="_idIndexMarker342"/>next time the tests are run, a new snapshot will be added to the <strong class="source-inline">src/components/NavBar/__snapshots__/NavBar.test.js.snap</strong> file. This <a id="_idIndexMarker343"/>snapshot has a value rendered for the <strong class="source-inline">title</strong> prop. If you change the <strong class="source-inline">title</strong> prop that is displayed by the <strong class="source-inline">NavBar</strong> component in your test file, the rendered component will no longer match the snapshot. You can try this by changing the value for the <strong class="source-inline">title</strong> prop in the test scenario:<p class="source-code">  import { render } from '@testing-library/react';</p><p class="source-code">  import NavBar from './NavBar';</p><p class="source-code">  // ...</p><p class="source-code">  test('The NavBar component should render with a</p><p class="source-code">    title', () =&gt; {</p><p class="source-code"><strong class="bold">-   const view = </strong></p><p class="source-code"><strong class="bold">      render(&lt;NavBar title='Test application' /&gt;);</strong></p><p class="source-code"><strong class="bold">+   const view = </strong></p><p class="source-code"><strong class="bold">      render(&lt;NavBar title='Test application #2' /&gt;);</strong></p><p class="source-code">    expect(view).toMatchSnapshot();</p><p class="source-code">  });</p></li>
			</ol>
			<p>Jest will return the following message in the terminal, where it specifies which lines have<a id="_idIndexMarker344"/> changed in comparison to the snapshot. In this case, the title that's being<a id="_idIndexMarker345"/> displayed is no longer <strong class="source-inline">Test Application</strong> but <strong class="source-inline">Test Application #2</strong>, which doesn't match the title in the snapshot:</p>
			<p class="source-code">FAIL  src/components/NavBar/NavBar.test.js</p>
			<p class="source-code">  ✓ The NavBar component should render (29 ms)</p>
			<p class="source-code">  ✕ The NavBar component should render with a title</p>
			<p class="source-code">    (10 ms)</p>
			<p class="source-code">  ● The NavBar component should render with a title</p>
			<p class="source-code">    expect(received).toMatchSnapshot()</p>
			<p class="source-code">    Snapshot name: `The NavBar component should render</p>
			<p class="source-code">    with a title 1`</p>
			<p class="source-code"><strong class="bold">    - Snapshot  - 3</strong></p>
			<p class="source-code"><strong class="bold">    + Received  + 3</strong></p>
			<p class="source-code">    @@ -6,23 +6,23 @@</p>
			<p class="source-code">              class="sc-gsDJrp PAvEv"</p>
			<p class="source-code">            &gt;</p>
			<p class="source-code">              &lt;h2</p>
			<p class="source-code">                class="sc-dkPtyc jFfuUr"</p>
			<p class="source-code">              &gt;</p>
			<p class="source-code"><strong class="bold">    -           Test application</strong></p>
			<p class="source-code"><strong class="bold">    +           Test application #2</strong></p>
			<p class="source-code"><strong class="bold">    // ...</strong></p>
			<p>By<a id="_idIndexMarker346"/> pressing the <em class="italic">U</em> key, you can update the snapshot to handle this new test scenario. This is an easy way to test the structure of your <a id="_idIndexMarker347"/>component and see whether the title has been rendered. With the preceding test, the initially created snapshot still matches the rendered component for the first test. Also, another snapshot was created for the second test, where a <strong class="source-inline">title</strong> prop was added to the <strong class="source-inline">NavBar</strong> component.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can do the same for the other props that are passed to the <strong class="source-inline">NavBar</strong> component, which renders differently if you do or don't pass certain props to it. Next to <strong class="source-inline">title</strong>, this component takes <strong class="source-inline">goBack</strong> and <strong class="source-inline">openForm</strong> as props, which can also be tested.</p>
			<p>We've now created two tests for our <strong class="source-inline">NavBar</strong> component, which is a good start. But something else that Jest does is show you how many lines of code have been covered by your tests. The higher your testing coverage, the more reason to assume your code is stable. You can check the test coverage of your code by executing the <strong class="source-inline">test</strong> script command with the <strong class="source-inline">--coverage</strong> flag and an extra <strong class="source-inline">--</strong> in between, or use the following command in your terminal:</p>
			<p class="source-code">npm run test -- --coverage</p>
			<p>This command will run your tests and generate a report with all the test coverage information about<a id="_idIndexMarker348"/> your code per file. After adding the tests for <strong class="source-inline">NavBar</strong>, this report will look as follows:</p>
			<p class="source-code">---------------------------|---------|----------|---------|---------|</p>
			<p class="source-code">File                       | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s </p>
			<p class="source-code">---------------------------|---------|----------|---------|---------|</p>
			<p class="source-code">All files                  |       5 |     4.68 |    3.12 |       5 |                   </p>
			<p class="source-code"> src                       |       0 |      100 |       0 |       0 |                   </p>
			<p class="source-code">  App.js                   |       0 |      100 |       0 |       0 | </p>
			<p class="source-code">  index.js                 |       0 |      100 |     100 |       0 |              </p>
			<p class="source-code"><strong class="bold"> src/components/Button     |     100 |      100 |     100 |     100 |                   </strong></p>
			<p class="source-code"><strong class="bold">  Button.js                |     100 |      100 |     100 |     100 |                   </strong></p>
			<p class="source-code"> src/components/FormItem   |       0 |        0 |       0 |       0 |                   </p>
			<p class="source-code">  FormItem.js              |       0 |        0 |       0 |       0 | </p>
			<p class="source-code"> src/components/Header     |       0 |      100 |       0 |       0 |                   </p>
			<p class="source-code">  Header.js                |       0 |      100 |       0 |       0 | </p>
			<p class="source-code"> src/components/HotelItem  |       0 |      100 |       0 |       0 |                   </p>
			<p class="source-code">  HotelItem.js             |       0 |      100 |       0 |       0 | </p>
			<p class="source-code"> <strong class="bold">src/components/NavBar     |     100 |       60 |     100 |     100 |                   </strong></p>
			<p class="source-code"><strong class="bold">  NavBar.js                |     100 |       60 |     100 |     100 |</strong> </p>
			<p class="source-code">  // ...</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Testing coverage only tells us something about the lines and the functions of your code that have been tested and not their actual implementation. Having a test coverage of 100% doesn't mean that there aren't any bugs in your code, as there will always be edge cases. Also, reaching a testing coverage of 100% means that you may end up spending more time on writing tests than on actual code. Usually, a testing coverage above 80% is considered good practice.</p>
			<p>As you can <a id="_idIndexMarker349"/>see, the test coverage for the component is 60%, meaning that most of the lines are covered in your test. To go to a 100% coverage, we<a id="_idIndexMarker350"/> will also need to add tests for the other props that are used in the <strong class="source-inline">NavBar</strong> component to render the buttons to return to the previous stage or the <strong class="source-inline">form</strong> component. Also, the coverage for the <strong class="source-inline">Button</strong> component is 100% due to no actual elements being rendered there.</p>
			<p>However, this method of testing with snapshots will create a lot of new files and lines of code. We'll look at other ways we can test our components in the next part of this section.</p>
			<h3>Testing components with assertions</h3>
			<p>In theory, snapshot testing is not necessarily a bad practice; however, your files can get quite big over time. Also, since you're<a id="_idIndexMarker351"/> not explicitly telling Jest what part of the component you want to test, you might need to update your code regularly. </p>
			<p>Luckily, using <a id="_idIndexMarker352"/>snapshots isn't the only method we can use to test whether our components are rendering the correct props. Instead, we can also directly compare which props are being rendered by checking the value of the component and making assertions. The big advantage of testing with assertions is that you can test a lot without having to dig deeper into the logic of the component you're testing. For instance, you can see what the children that are being rendered look like. </p>
			<p>Let's change<a id="_idIndexMarker353"/> our second snapshot test for the <strong class="source-inline">NavBar</strong> component to compare the impact on the test coverage. We'll need to import the <strong class="source-inline">screen</strong> method from the React Testing Library, which is used to scan the rendered components. Instead of making a snapshot of the whole component and finding the title in there, we will look for any heading components (such as <strong class="source-inline">h2</strong>) and check whether their value is equal to the prop that we set on <strong class="source-inline">NavBar</strong>:</p>
			<p class="source-code"><strong class="bold">- import { render } from '@testing-library/react';</strong></p>
			<p class="source-code"><strong class="bold">+ import { render, screen } from '@testing-library/react';</strong></p>
			<p class="source-code">  import NavBar from './NavBar';</p>
			<p class="source-code">  // ...</p>
			<p class="source-code"><strong class="bold">+ test('The NavBar component should render with a title', </strong></p>
			<p class="source-code"><strong class="bold">    () =&gt; {</strong></p>
			<p class="source-code"><strong class="bold">-   const view = </strong></p>
			<p class="source-code"><strong class="bold">      render(&lt;NavBar title='Test application #2' /&gt;);</strong></p>
			<p class="source-code"><strong class="bold">-   expect(view).toMatchSnapshot();</strong></p>
			<p class="source-code"><strong class="bold">+   const title = 'Test application';</strong></p>
			<p class="source-code"><strong class="bold">+   render(&lt;NavBar title={title} /&gt;);</strong></p>
			<p class="source-code"><strong class="bold">+   expect(screen.getByRole('heading')).</strong></p>
			<p class="source-code"><strong class="bold">           toHaveTextContent(title);</strong></p>
			<p class="source-code">  });</p>
			<p>We've <a id="_idIndexMarker354"/>used the <strong class="source-inline">getByRole</strong> React Testing Library method to find the <strong class="source-inline">Title</strong> component in the <strong class="source-inline">NavBar</strong> component, and the <strong class="source-inline">toHaveTextContent</strong> method to check <a id="_idIndexMarker355"/>whether the text inside <strong class="source-inline">Title</strong> is equal to our prop. The test still passes and also allows us to <a id="_idIndexMarker356"/>delete the snapshot, as we're now using an assumption to test this part of the component:</p>
			<p class="source-code">PASS  src/components/NavBar/NavBar.test.js</p>
			<p class="source-code">  ✓ The NavBar component should render (13 ms)</p>
			<p class="source-code">  ✓ The NavBar component should render with a title (54 ms)</p>
			<p class="source-code"><strong class="bold"> › 1 snapshot obsolete.</strong></p>
			<p class="source-code"><strong class="bold">   • The NavBar component should render with a title 1</strong></p>
			<p class="source-code">Snapshot Summary</p>
			<p class="source-code"><strong class="bold"> › 1 snapshot obsolete from 1 test suite. To remove it, press `u`.</strong></p>
			<p class="source-code">   ↳ src/components/NavBar/NavBar.test.js</p>
			<p class="source-code">       • The NavBar component should render with a title 1</p>
			<p>By pressing <em class="italic">U</em> or running <strong class="source-inline">npm run test</strong> with the <strong class="source-inline">-u</strong> flag, the snapshot for the <strong class="source-inline">NavBar</strong> component is removed by Jest:</p>
			<p class="source-code">Snapshot Summary</p>
			<p class="source-code"><strong class="bold"> › 1 snapshot removed from 1 test suite.</strong></p>
			<p class="source-code">   ↳ src/components/NavBar/NavBar.test.js</p>
			<p class="source-code">       • The NavBar component should render with a title 1 </p>
			<p>The test <a id="_idIndexMarker357"/>coverage of the <strong class="source-inline">NavBar</strong> component <a id="_idIndexMarker358"/>should still be 60%, as we continued<a id="_idIndexMarker359"/> testing whether the <strong class="source-inline">title</strong> prop was presented and rendered, which you can check by running again:</p>
			<p class="source-code">---------------------------|---------|----------|---------|---------|</p>
			<p class="source-code">File                       | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s </p>
			<p class="source-code">---------------------------|---------|----------|---------|---------|</p>
			<p class="source-code">All files                  |       5 |     4.84 |    3.33 |       5 |                   </p>
			<p class="source-code"> src                       |       0 |      100 |       0 |       0 |                   </p>
			<p class="source-code">  App.js                   |       0 |      100 |       0 |       0 | </p>
			<p class="source-code">  index.js                 |       0 |      100 |     100 |       0 |               </p>
			<p class="source-code"><strong class="bold">src/components/NavBar      |     100 |       60 |     100 |     100 |                   </strong></p>
			<p class="source-code"><strong class="bold">  NavBar.js                |     100 |       60 |     100 |     100 |</strong></p>
			<p class="source-code">  // ...</p>
			<p>However, the <strong class="source-inline">NavBar</strong> component doesn't just<a id="_idIndexMarker360"/> take the <strong class="source-inline">title</strong> prop – it also takes the <strong class="source-inline">goBack</strong> and <strong class="source-inline">openForm</strong> functions as props. You also want to test whether these functions are triggered when you click on any of the buttons.</p>
			<p>To test these props, we <a id="_idIndexMarker361"/>need to create a mock function that we can pass as a prop to <strong class="source-inline">NavBar</strong> and mock the user click events to test whether this function is being called. The <strong class="source-inline">fireEvent</strong> method from the React Testing Library can be used to mock user events, and with Jest, we<a id="_idIndexMarker362"/> can mock a function and check whether that function is called:</p>
			<p class="source-code"><strong class="bold">- import { render, screen } from '@testing-library/react';</strong></p>
			<p class="source-code"><strong class="bold">+ import { render, screen, fireEvent } from </strong></p>
			<p class="source-code"><strong class="bold">    '@testing-library/react';</strong></p>
			<p class="source-code">  import NavBar from './NavBar';</p>
			<p class="source-code">  </p>
			<p class="source-code">  // ...</p>
			<p class="source-code"><strong class="bold">+ test('The NavBar component should respond to button</strong></p>
			<p class="source-code"><strong class="bold">    clicks', () =&gt; {</strong></p>
			<p class="source-code"><strong class="bold">+   const mockFunction = jest.fn();</strong></p>
			<p class="source-code"><strong class="bold">+   render(&lt;NavBar goBack={mockFunction} /&gt;);</strong></p>
			<p class="source-code"><strong class="bold">+   fireEvent.click(screen.getByText('&lt; Go Back'));</strong></p>
			<p class="source-code"><strong class="bold">+   expect(mockFunction).toHaveBeenCalled();</strong></p>
			<p class="source-code"><strong class="bold">+ });</strong></p>
			<p>By running the preceding test, a click on the <em class="italic">back</em> button in <strong class="source-inline">NavBar</strong> will be simulated, and Jest will check whether the mocked function is being called. The same can be done for the <strong class="source-inline">openForm</strong> prop:</p>
			<p class="source-code">  // ...</p>
			<p class="source-code">  test('The NavBar component should respond to button</p>
			<p class="source-code">    clicks', () =&gt; {</p>
			<p class="source-code">    const mockFunction = jest.fn();</p>
			<p class="source-code"><strong class="bold">-   render(&lt;NavBar goBack={mockFunction} /&gt;);</strong></p>
			<p class="source-code"><strong class="bold">+   render(&lt;NavBar goBack={mockFunction} openForm=</strong></p>
			<p class="source-code"><strong class="bold">      {mockFunction} /&gt;);</strong></p>
			<p class="source-code">    fireEvent.click(screen.getByText('&lt; Go Back'));</p>
			<p class="source-code">    expect(mockFunction).toHaveBeenCalled();</p>
			<p class="source-code"><strong class="bold">+   fireEvent.click(screen.getByText('+ Add Review'));</strong></p>
			<p class="source-code"><strong class="bold">+   expect(mockFunction).toHaveBeenCalledTimes(2);</strong></p>
			<p class="source-code">  });</p>
			<p>The <a id="_idIndexMarker363"/>mocked function for both the <strong class="source-inline">goBack</strong> and <strong class="source-inline">openForm</strong> props are the same, so we need to check whether this function is called <a id="_idIndexMarker364"/>twice after clicking the open form button. By<a id="_idIndexMarker365"/> testing the user events on these two buttons, we've tested 100% of the <strong class="source-inline">NavBar</strong> component, as you can also see in the coverage report:</p>
			<p class="source-code">PASS  src/components/NavBar/NavBar.test.js</p>
			<p class="source-code">  ✓ The NavBar component should render (27 ms)</p>
			<p class="source-code">  ✓ The NavBar component should render with a title (45 ms)</p>
			<p class="source-code">  ✓ The NavBar component should respond to button clicks (13 ms)</p>
			<p class="source-code">---------------------------|---------|----------|---------|---------|</p>
			<p class="source-code">File                       | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s </p>
			<p class="source-code">---------------------------|---------|----------|---------|---------|</p>
			<p class="source-code">All files                  |       5 |     8.06 |    3.33 |       5 |                   </p>
			<p class="source-code"> src                       |       0 |      100 |       0 |       0 |                   </p>
			<p class="source-code">  App.js                   |       0 |      100 |       0 |       0 | </p>
			<p class="source-code">  index.js                 |       0 |      100 |     100 |       0 |               </p>
			<p class="source-code"><strong class="bold"> src/components/NavBar     |     100 |      100 |     100 |     100 |                   </strong></p>
			<p class="source-code"><strong class="bold">  NavBar.js                |     100 |      100 |     100 |     100 |</strong></p>
			<p class="source-code">  // ...</p>
			<p>In this section, we've<a id="_idIndexMarker366"/> created unit tests that <a id="_idIndexMarker367"/>will test a specific part of our code. However, it can<a id="_idIndexMarker368"/> be interesting to test how different parts of our code work together. For this, we'll add integration tests to test our state management and Hooks.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor086"/>Testing React state and Hooks</h2>
			<p>The tests that we've created all render components without state management, but with the React Testing Library, we <a id="_idIndexMarker369"/>also have the option to test state and Hooks. In our setup, the pages that are rendered by our router are wrapped in an application context component. If we want to test the page components, we need to make sure that the data for these pages is being mocked or stubbed, so the integration of this component with the state can be tested.</p>
			<p>A good example <a id="_idIndexMarker370"/>of where we can test this is the <strong class="source-inline">Hotels</strong> component, which renders the list of hotels that were returned by the context:</p>
			<ol>
				<li value="1">As always, the starting point is to create a new file with the <strong class="source-inline">.test</strong> suffix in the same directory where the component we want to test is located. Here, we need to create the <strong class="source-inline">Hotels.test.js</strong> file in the <strong class="source-inline">src/pages</strong> directory. In this file, we need to add the following code:<p class="source-code">import { render, screen } from </p><p class="source-code">  '@testing-library/react';</p><p class="source-code">import Hotels from './Hotels';</p><p class="source-code">import HotelsContext from '../context/HotelsContext';</p><p class="source-code">test('The Hotels component should render', async () =&gt; {</p><p class="source-code">  const wrapper = ({ children }) =&gt; (</p><p class="source-code">    &lt;HotelsContext.Provider</p><p class="source-code">      value={{</p><p class="source-code">        loading: true,</p><p class="source-code">        error: '',</p><p class="source-code">        hotels: [],</p><p class="source-code">        fetchHotels: jest.fn(),</p><p class="source-code">      }}</p><p class="source-code">    &gt;</p><p class="source-code">      {children}</p><p class="source-code">    &lt;/HotelsContext.Provider&gt;</p><p class="source-code">  );</p><p class="source-code">  render(&lt;Hotels /&gt;, { wrapper });</p><p class="source-code">  expect(await screen.findByText(</p><p class="source-code">    'Loading...')).toBeVisible();</p><p class="source-code">});</p></li>
			</ol>
			<p>The <a id="_idIndexMarker371"/>preceding test imports the context <a id="_idIndexMarker372"/>object that the <strong class="source-inline">Hotels</strong> component uses to render the page and creates a wrapper function that creates a provider on the <strong class="source-inline">HotelsContext</strong>. To this <strong class="source-inline">Provider</strong>, we've added the mock values for the context that is used by the <strong class="source-inline">Hotels</strong> component. Our test assertion tries to find an element with the <strong class="source-inline">Loading…</strong> text value and checks whether it exists. As the value for <strong class="source-inline">loading</strong> in our context is <strong class="source-inline">true</strong>, that element can indeed be found. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">To run just a selection of tests, you can press <em class="italic">P</em> after running the <strong class="source-inline">npm run test</strong> command; you can now type a string in the terminal that will be used to pattern-match the test files.</p>
			<ol>
				<li value="2">To test whether the hotels are being rendered when data is present in the context, we <a id="_idIndexMarker373"/>need to mock this data in a<a id="_idIndexMarker374"/> new test in the <strong class="source-inline">Hotels.test.js</strong> file:<p class="source-code">  import { render, screen } from </p><p class="source-code">    '@testing-library/react';</p><p class="source-code">  import Hotels from './Hotels';</p><p class="source-code">  import HotelsContext from </p><p class="source-code">    '../context/HotelsContext';</p><p class="source-code"><strong class="bold">+ import { BrowserRouter } from 'react-router-dom';</strong></p><p class="source-code"> // ...</p><p class="source-code"><strong class="bold">+ test('The Hotels component should render a list of </strong></p><p class="source-code"><strong class="bold">    hotels', async () =&gt; {</strong></p><p class="source-code"><strong class="bold">+   const wrapper = ({ children }) =&gt; (</strong></p><p class="source-code"><strong class="bold">+     &lt;BrowserRouter&gt;</strong></p><p class="source-code"><strong class="bold">+       &lt;HotelsContext.Provider</strong></p><p class="source-code"><strong class="bold">+         value={{</strong></p><p class="source-code"><strong class="bold">+           loading: false,</strong></p><p class="source-code"><strong class="bold">+           error: '',</strong></p><p class="source-code"><strong class="bold">+           hotels: [</strong></p><p class="source-code"><strong class="bold">+             { id: 1, title: 'Test hotel 1', </strong></p><p class="source-code"><strong class="bold">                thumbnail: '' },</strong></p><p class="source-code"><strong class="bold">+             { id: 2, title: 'Test hotel 2', </strong></p><p class="source-code"><strong class="bold">                thumbnail: '' },</strong></p><p class="source-code"><strong class="bold">+           ],</strong></p><p class="source-code"><strong class="bold">+           fetchHotels: jest.fn(),</strong></p><p class="source-code"><strong class="bold">+         }}</strong></p><p class="source-code"><strong class="bold">+       &gt;</strong></p><p class="source-code"><strong class="bold">+         {children}</strong></p><p class="source-code"><strong class="bold">+       &lt;/HotelsContext.Provider&gt;</strong></p><p class="source-code"><strong class="bold">+     &lt;/BrowserRouter&gt;</strong></p><p class="source-code"><strong class="bold">+   );</strong></p><p class="source-code"><strong class="bold">+ });</strong></p></li>
			</ol>
			<p>In the <a id="_idIndexMarker375"/>preceding mocked context value, the value for <strong class="source-inline">loading</strong> is set to <strong class="source-inline">false</strong>, and mocked hotels are also added. Note that we also wrapped the Provider with <strong class="source-inline">BrowserRouter</strong> from React Router, as the <strong class="source-inline">Hotels</strong> component uses a <strong class="source-inline">Link</strong> component to make the hotels clickable. </p>
			<ol>
				<li value="3">To test <a id="_idIndexMarker376"/>whether the hotels are being rendered, we need to add a test assertion to check whether the <strong class="source-inline">loading</strong> message is gone and whether the correct number of links to hotels are rendered:<p class="source-code">  // ...</p><p class="source-code">  test('The Hotels component should render a list of</p><p class="source-code">    hotels', async () =&gt; {</p><p class="source-code">    const wrapper = ({ children }) =&gt; (</p><p class="source-code">      // ...</p><p class="source-code">    );</p><p class="source-code"><strong class="bold">+   render(&lt;Hotels /&gt;, { wrapper });</strong></p><p class="source-code"><strong class="bold">+   expect(screen.queryByText('Loading...')</strong></p><p class="source-code"><strong class="bold">      ).toBeNull();</strong></p><p class="source-code"><strong class="bold">+   expect(screen.getAllByRole('link'</strong></p><p class="source-code"><strong class="bold">      ).length).toBe(2);</strong></p><p class="source-code">  });</p></li>
			</ol>
			<p>The <strong class="source-inline">getBy</strong> methods<a id="_idIndexMarker377"/> we used before will throw an error when an element cannot be found; to test whether something is not rendered, we need to use the <strong class="source-inline">queryBy</strong> methods instead. Also, we need to check whether two <strong class="source-inline">Link</strong> components are present by looking for the <strong class="source-inline">link</strong> role and counting them.</p>
			<ol>
				<li value="4">The <strong class="source-inline">useEffect</strong> Hook<a id="_idIndexMarker378"/> in the <strong class="source-inline">Hotels</strong> component can also be tested to check whether the <strong class="source-inline">fetchHotels</strong> function is being called if there are no hotels in the context. Therefore, we can edit the first test by importing the <strong class="source-inline">waitFor</strong> method from the React Testing Library and altering the context value slightly:<p class="source-code"><strong class="bold">- import { render, screen } from </strong></p><p class="source-code"><strong class="bold">    '@testing-library/react';</strong></p><p class="source-code"><strong class="bold">+ import { render, screen, waitFor } from </strong></p><p class="source-code"><strong class="bold">    '@testing-library/react';</strong></p><p class="source-code">  import Hotels from './Hotels';</p><p class="source-code">  import HotelsContext from</p><p class="source-code">    '../context/HotelsContext';</p><p class="source-code">  import { BrowserRouter } from 'react-router-dom';</p><p class="source-code">  test('The Hotels component should render', async ()</p><p class="source-code">    =&gt; {</p><p class="source-code"><strong class="bold">+   const mockFunction = jest.fn()</strong></p><p class="source-code">    const wrapper = ({ children }) =&gt; (</p><p class="source-code">      &lt;HotelsContext.Provider</p><p class="source-code">        value={{</p><p class="source-code">          loading: true,</p><p class="source-code">          error: '',</p><p class="source-code">          hotels: [],</p><p class="source-code"><strong class="bold">-         fetchHotels: jest.fn(),</strong></p><p class="source-code"><strong class="bold">+         fetchHotels: mockFunction,</strong></p><p class="source-code">        }}</p><p class="source-code">      &gt;</p><p class="source-code">        {children}</p><p class="source-code">      &lt;/HotelsContext.Provider&gt;</p><p class="source-code">    );</p><p class="source-code">    // ...</p></li>
				<li>We also add <a id="_idIndexMarker379"/>the test assertion to wait for<a id="_idIndexMarker380"/> the mock function to be called. Here, we specifically state that the mocked function, which is <strong class="source-inline">fetchHotels</strong> from <strong class="source-inline">HotelsContext</strong>, is called only once. In our <strong class="source-inline">Hotels</strong> component, <strong class="source-inline">useEffect</strong> has a check to only fetch the hotels if there is no data:<p class="source-code">    // ...</p><p class="source-code">    render(&lt;Hotels /&gt;, { wrapper });</p><p class="source-code">    expect(await screen.findByText('Loading...')</p><p class="source-code">      ).toBeVisible();</p><p class="source-code"><strong class="bold">+   await waitFor(() =&gt; </strong></p><p class="source-code"><strong class="bold">      expect(mockFunction).toHaveBeenCalledTimes(1));</strong></p><p class="source-code">  });</p><p class="source-code">  // ...</p></li>
			</ol>
			<p>With this test, we've<a id="_idIndexMarker381"/> tested both the context in the <strong class="source-inline">Hotels</strong> component and the <strong class="source-inline">useEffect</strong> Hook to fetch hotel data in that function. </p>
			<p>After running the <a id="_idIndexMarker382"/>tests again with the <strong class="source-inline">--coverage</strong> flag, we will be able to see what impact writing this integration test has on our coverage. Since an integration test not only tests one specific component but multiple components at once, the testing coverage for <strong class="source-inline">Hotels</strong> will be updated. This test also covers the <strong class="source-inline">HotelItem</strong> component, which we will be able to see in the coverage report after running <strong class="source-inline">npm run test --coverage</strong>:</p>
			<p class="source-code">---------------------------|---------|----------|---------|---------|</p>
			<p class="source-code">File                       | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s </p>
			<p class="source-code">---------------------------|---------|----------|---------|---------|</p>
			<p class="source-code">All files                  |   19.83 |    29.03 |   16.67 |   19.83 |                   </p>
			<p class="source-code"> src                       |       0 |      100 |       0 |       0 |                   </p>
			<p class="source-code">  App.js                   |       0 |      100 |       0 |       0 | </p>
			<p class="source-code">  index.js                 |       0 |      100 |     100 |       0 |             </p>
			<p class="source-code"><strong class="bold"> src/components/HotelItem  |     100 |      100 |     100 |     100 |                   </strong></p>
			<p class="source-code"><strong class="bold">  HotelItem.js             |     100 |      100 |     100 |     100 |                   </strong></p>
			<p class="source-code"> src/components/NavBar     |     100 |      100 |     100 |     100 |                   </p>
			<p class="source-code">  NavBar.js                |     100 |      100 |     100 |     100 |                   </p>
			<p class="source-code"> src/context               |    8.16 |        0 |       0 |    8.16 |                   </p>
			<p class="source-code">  AppContext.js            |       0 |      100 |       0 |       0 | </p>
			<p class="source-code"><strong class="bold">  HotelsContext.js         |   16.67 |        0 |       0 |   16.67 | </strong></p>
			<p class="source-code">  ReviewsContext.js        |       0 |        0 |       0 |       0 | </p>
			<p class="source-code"><strong class="bold"> src/pages                 |   21.95 |    34.21 |      20 |   21.95 |                   </strong></p>
			<p class="source-code"><strong class="bold">  Hotels.js                |     100 |      100 |     100 |     100 | </strong></p>
			<p class="source-code"><strong class="bold"> </strong></p>
			<p class="source-code"><strong class="bold">  // ...</strong>  </p>
			<p class="source-code">                </p>
			<p>According to Jest, the coverage for <strong class="source-inline">Hotels</strong> is 100%. The test coverage for <strong class="source-inline">HotelItems</strong> has also reached 100%. This means that we can skip writing unit tests for <strong class="source-inline">HotelItem</strong>, assuming that we only use this component within the <strong class="source-inline">Hotels</strong> component. The <strong class="source-inline">HotelsContext</strong> component with our context already has a small amount<a id="_idIndexMarker383"/> of coverage through testing it <a id="_idIndexMarker384"/>from the <strong class="source-inline">Hotels</strong> component. To get a higher coverage, we can test even more, such as testing how the context itself or the <strong class="source-inline">useReducer</strong> Hook in the context is behaving. </p>
			<p>The only downside of having integration tests over unit tests is that they're harder to write, as they usually contain more complex logic. Also, these integration tests will run slower than unit tests because of them having more logic and bringing together multiple components. In the final section of this chapter, we'll be adding an end-to-end test that will test the entire application from a user perspective using Cypress.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor087"/>End-to-end testing with Cypress</h2>
			<p>So far, we've <a id="_idIndexMarker385"/>covered both unit and integration testing with the React Testing Library that tests our code in an isolated setting. But in order to make sure that our application is tested as a whole, we can also write an end-to-end test to cover certain aspects of our application from start to finish. End-to-end tests are <a id="_idIndexMarker386"/>considered more time-consuming to write and run than unit or integration tests. It's recommended to have more unit and integrations tests for your project than end-to-end tests, and think about what aspects of your application you really want to have tested. </p>
			<p>To add <a id="_idIndexMarker387"/>end-to-end tests, we'll install the open source test tool Cypress, which can be used to write and<a id="_idIndexMarker388"/> run such tests. Adding Cypress to the project requires several steps:</p>
			<ol>
				<li value="1">Install the library from npm in our project by running the following command from the terminal:<p class="source-code"><strong class="bold">npm install cypress --save-dev</strong></p></li>
				<li>After completing the installation, the script to run Cypress needs to be added to the <strong class="source-inline">package.json</strong> file <a id="_idIndexMarker389"/>so that it can be started with a single command:<p class="source-code">  // ... </p><p class="source-code">  "scripts": {</p><p class="source-code">    "start": "react-scripts start",</p><p class="source-code">    "build": "react-scripts build",</p><p class="source-code">    "test": "react-scripts test",</p><p class="source-code"><strong class="bold">+   "cypress": "cypress open"</strong></p><p class="source-code">    "eject": "react-scripts eject"</p><p class="source-code">  },</p><p class="source-code">  // ...</p></li>
				<li>You <a id="_idIndexMarker390"/>can now run the <strong class="source-inline">npm run cypress</strong> command to start Cypress. Make sure to do this in a new<a id="_idIndexMarker391"/> tab in the terminal, as you need to have both the application and Cypress running simultaneously. If this is the<a id="_idIndexMarker392"/> first time that you're running Cypress, it will validate whether it's able to run on your system. When all goes well, Cypress will open and create a new directory called <strong class="source-inline">cypress</strong> in our project, as shown in the following screenshot: </li>
			</ol>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_6.2_B17390.jpg" alt="Figure 6.2 – Cypress running for the first time"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Cypress running for the first time</p>
			<ol>
				<li value="4">Cypress<a id="_idIndexMarker393"/> has <a id="_idIndexMarker394"/>created example tests in the <strong class="source-inline">cypress/integration/examples</strong> directory, which you can use to learn more <a id="_idIndexMarker395"/>about how the library is working. Otherwise, you can delete these, as they will clutter the Cypress runner when we add new tests. In the <strong class="source-inline">cypress/integration</strong> directory ,we can add a new end-to-end test for our project called <strong class="source-inline">hotels.spec.js</strong> with the following contents:<p class="source-code">describe('Cypress', () =&gt; {   </p><p class="source-code">    it('opens the app', () =&gt; {   </p><p class="source-code">        cy.visit('http://localhost:3000') </p><p class="source-code">    })</p><p class="source-code">})</p></li>
				<li>You can run this test by pressing on it in the Cypress runner, after which the test will run in a browser. Which browser it uses depends on what you've selected at the top <a id="_idIndexMarker396"/>right in Cypress. This test will open the application within a browser and test it with<a id="_idIndexMarker397"/> Cypress, giving <a id="_idIndexMarker398"/>the following output:</li>
			</ol>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_6.3_B17390.jpg" alt="Figure 6.3 – Cypress rendering our application in a test&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – Cypress rendering our application in a test</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You need to make sure that you have both Cypress and the application running in your terminal. This means that one terminal tab must have <strong class="source-inline">npm run cypress</strong> running and the other <strong class="source-inline">npm start</strong>. If you don't have the application running, you'll get an error that the web page is not available.</p>
			<p>The preceding test will just render our application, without making any assertions. To test the application using Cypress, we need to use any of the assertions that are provided by the library. Using these assertions, we'll write an end-to-end test that checks the entire flow, from visiting the application to adding a review for a hotel. This way, we have tested the most critical process of our application, namely reviewing hotels.</p>
			<p>To start, we <a id="_idIndexMarker399"/>need to change the <strong class="source-inline">hotels.spec.js</strong> file so that it will open the application and navigate to a hotel page, and <a id="_idIndexMarker400"/>on that page, click on the button to open the form. After filling in this form, we want our test to submit the form and check whether our<a id="_idIndexMarker401"/> review has been added. Follow these steps to make these changes:</p>
			<ol>
				<li value="1">All the tests in the <strong class="source-inline">hotels.spec.js</strong> file will start by visiting the application in the browser, so it can click on any of the hotels listed on this page. After clicking on a hotel, we need to verify whether the location in the browser has changed by using the <strong class="source-inline">cy.location</strong> method:<p class="source-code">  describe('Cypress', () =&gt; {</p><p class="source-code"><strong class="bold">-   it('opens the app', () =&gt; {   </strong></p><p class="source-code"><strong class="bold">+   it('opens the app and clicks on a hotel', () =&gt; {</strong></p><p class="source-code"><strong class="bold">      cy.visit('http://localhost:3000');</strong></p><p class="source-code"><strong class="bold">+     cy.get('a').first().click();</strong></p><p class="source-code"><strong class="bold">+     cy.location('pathname').should('include',</strong></p><p class="source-code"><strong class="bold">        'hotel');</strong></p><p class="source-code"><strong class="bold">    });</strong>  </p><p class="source-code">  });</p></li>
			</ol>
			<p>Running this test will validate that you can click on a hotel and navigate to the correct page, which you can check in the Cypress runner.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When you need to visit many URLs over different development environments, you can also define <strong class="source-inline">baseUrl</strong> in a <strong class="source-inline">cypress.json</strong> file:</p>
			<p class="callout"><strong class="source-inline">{</strong></p>
			<p class="callout"><strong class="source-inline">  "id": "http://localhost:3000",</strong></p>
			<p class="callout"><strong class="source-inline">}</strong></p>
			<ol>
				<li value="2">In the <a id="_idIndexMarker402"/>second test, we tell Cypress to find the button with the <strong class="source-inline">+ Add Review</strong> text and click on it, which should<a id="_idIndexMarker403"/> change the browser's location to the page to add the <a id="_idIndexMarker404"/>review. This page is located at the <strong class="source-inline">/hotel/:hotelId/new</strong> route and includes the <strong class="source-inline">new</strong> string. Note that we don't have to navigate to the application anymore, as this test builds upon the previous test and is therefore already at the correct page:<p class="source-code">  describe('Cypress', () =&gt; {</p><p class="source-code">    // ...</p><p class="source-code"><strong class="bold">+   it('navigates to the form to add a review', () =&gt;</strong></p><p class="source-code"><strong class="bold">      {</strong></p><p class="source-code"><strong class="bold">+     cy.get('button').contains('+ Add </strong></p><p class="source-code"><strong class="bold">        Review').click();</strong></p><p class="source-code"><strong class="bold">+     cy.location('pathname').should('include',</strong></p><p class="source-code"><strong class="bold">        'new');</strong></p><p class="source-code"><strong class="bold">+   });</strong></p><p class="source-code">});</p></li>
				<li>In the preceding test, Cypress will look for a button that contains a specific word, something that is not future-proof if someone changes the content of the button. Deciding <a id="_idIndexMarker405"/>which selector to use (<strong class="source-inline">id</strong>, <strong class="source-inline">class</strong>, or content) is important when writing tests. To prevent failing tests, you can also add the <strong class="source-inline">data-cy</strong>, <strong class="source-inline">data-test</strong>, or <strong class="source-inline">data-testid</strong> attributes to your elements. Therefore, we need to<a id="_idIndexMarker406"/> change how <a id="_idIndexMarker407"/>the <strong class="source-inline">Button</strong> component is rendered in <strong class="source-inline">src/components/NavBar</strong>:<p class="source-code">  // ...</p><p class="source-code">  function NavBar({ goBack, title, openForm = false })</p><p class="source-code">    {</p><p class="source-code">    return (</p><p class="source-code">      &lt;NavBarWrapper&gt;</p><p class="source-code">        {goBack &amp;&amp; &lt;NavBarButton onClick={goBack}&gt;{`&lt; </p><p class="source-code">          Go Back`} &lt;/NavBarButton&gt;}</p><p class="source-code">        &lt;Title&gt;{title}&lt;/Title&gt;</p><p class="source-code">        {openForm &amp;&amp; </p><p class="source-code">          &lt;NavBarButton </p><p class="source-code">            onClick={openForm}</p><p class="source-code"><strong class="bold">+           data-cy='addReview'        </strong></p><p class="source-code">          &gt;</p><p class="source-code">           {`+ Add Review`}</p><p class="source-code">          &lt;/NavBarButton&gt;</p><p class="source-code">        }</p><p class="source-code">      &lt;/NavBarWrapper&gt;</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">  export default NavBar;</p></li>
				<li>In the <strong class="source-inline">cypress/integrations/hotels.spec.js</strong> Cypress test file, we can look for<a id="_idIndexMarker408"/> the <strong class="source-inline">data-cy</strong> attribute<a id="_idIndexMarker409"/> instead of using the content of the button as a <a id="_idIndexMarker410"/>selector:<p class="source-code">  describe('Cypress', () =&gt; {</p><p class="source-code">    // ...</p><p class="source-code">    it('navigates to the form to add a review', () =&gt; </p><p class="source-code">      {</p><p class="source-code"><strong class="bold">-     cy.get('button').contains('+ Add </strong></p><p class="source-code"><strong class="bold">        Review').click();</strong></p><p class="source-code"><strong class="bold">+     cy.get('[data-cy=addReview]').click();</strong></p><p class="source-code">      cy.location('pathname').should('include', </p><p class="source-code">        'new');</p><p class="source-code">    });</p><p class="source-code">  });</p></li>
				<li>A third test to fill in the form to add the review and submit it can also be added to this file. Using the <strong class="source-inline">cy.get</strong> command, Cypress can find the <strong class="source-inline">form</strong> element on this page, and the <strong class="source-inline">within</strong> method is used to find the <strong class="source-inline">input</strong> elements inside the form. It will search for the name of the <strong class="source-inline">input</strong> field, add a value to it, and finally submit <strong class="source-inline">button</strong> inside the form:<p class="source-code">  describe('Cypress', () =&gt; {</p><p class="source-code">    // ...</p><p class="source-code"><strong class="bold">+   it('fills in and submits the form', () =&gt; {</strong></p><p class="source-code"><strong class="bold">+     cy.get('form').within(() =&gt; {</strong></p><p class="source-code"><strong class="bold">+       cy.get('input[name=title]').type('Test </strong></p><p class="source-code"><strong class="bold">          review');</strong></p><p class="source-code"><strong class="bold">+       cy.get('input[name=description]').type('Is a </strong></p><p class="source-code"><strong class="bold">          test review by Cypress');</strong></p><p class="source-code"><strong class="bold">        cy.get('input[name=rating]').type(4);</strong></p><p class="source-code"><strong class="bold">        cy.get('button').click();</strong></p><p class="source-code"><strong class="bold">+     });</strong></p><p class="source-code"><strong class="bold">+   });</strong></p><p class="source-code">  });</p></li>
				<li>Finally, we <a id="_idIndexMarker411"/>need to write a test that checks <a id="_idIndexMarker412"/>the hotel details page again and tries to find the new review that we've added. To find this review, we need to search the page<a id="_idIndexMarker413"/> for the contents of the review that was just added by Cypress; also, we need to add a <strong class="source-inline">wait</strong> command to make sure that the review has been processed and displayed on the screen:<p class="source-code">  describe('Cypress', () =&gt; {</p><p class="source-code">    // ...</p><p class="source-code"><strong class="bold">+   it('and verifies if the review is added', () =&gt; {</strong></p><p class="source-code"><strong class="bold">+     cy.wait(600);</strong></p><p class="source-code"><strong class="bold">+     cy.get('h3').contains('Test review');</strong></p><p class="source-code"><strong class="bold">+     cy.get('div').contains('Is a test review by </strong></p><p class="source-code"><strong class="bold">        Cypress');</strong></p><p class="source-code"><strong class="bold">+   });</strong></p><p class="source-code">  });</p></li>
			</ol>
			<p>By adding this final test to Cypress, we've tested the most important scenario of our application, which you can expand even more by adding tests for edge cases such as error messages.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">We didn't add a <strong class="source-inline">data-cy</strong> attribute to the elements that display the review, which is something that you could add yourself. As we're aware of the content that we just added, it's safe to assume that we don't need a complicated selector for this.</p>
			<p>You can add <a id="_idIndexMarker414"/>more functionalities, such <a id="_idIndexMarker415"/>as mocking the API requests<a id="_idIndexMarker416"/> and responses, as the preceding test is using the same API as the application itself. In this scenario, there's nothing wrong with that, as the API we're using is already a mock API. If you're working in a production environment, you will want to replace that with a mocked response that can be generated by Cypress. </p>
			<p>For this, we need to add a <strong class="source-inline">beforeEach</strong> Hook to our test file that intercepts the API calls and replaces the response with a mocked value. The format of that mocked value should be equal to the format of the actual API. Luckily, our API is being populated from the <strong class="source-inline">db.json</strong> file that you can find in the repository for this book. From the contents of that file, you can take the data for the hotels field and paste it into two separate files inside the <strong class="source-inline">cypress/fixtures</strong> directory. Let's look at the steps:</p>
			<ol>
				<li value="1">The first one can be called <strong class="source-inline">hotels.json</strong> and needs to have an array of objects with hotel details:<p class="source-code">[</p><p class="source-code">  {</p><p class="source-code">    "id": 1,</p><p class="source-code">    "title": "Downtown Hotel (***)",</p><p class="source-code">    "thumbnail": </p><p class="source-code">      "https://picsum.photos/id/369/400/400"</p><p class="source-code">  }</p><p class="source-code">]</p></li>
				<li>The second fixture needs to have a single object that replaces the API request for a single hotel, in a file called <strong class="source-inline">hotel.json</strong>:<p class="source-code">{</p><p class="source-code">  "id": 1,</p><p class="source-code">  "title": "Downtown Hotel (***)",</p><p class="source-code">  "thumbnail": "https://picsum.photos/id/369/400/400"</p><p class="source-code">}</p></li>
				<li>Intercepting <a id="_idIndexMarker417"/>the calls<a id="_idIndexMarker418"/> to the actual API can be done from the test file in <strong class="source-inline">cypress/integrations/hotels.spec.js</strong> by adding a <strong class="source-inline">beforeEach</strong> Hook and the <strong class="source-inline">cy.intercept</strong> method. For the <strong class="source-inline">hotels</strong> and <strong class="source-inline">hotels/*</strong> endpoints, it can <a id="_idIndexMarker419"/>return the fixture, and the <strong class="source-inline">reviews</strong> endpoint can return an empty array, as Cypress will add a review itself:<p class="source-code">  describe('Cypress', () =&gt; {</p><p class="source-code"><strong class="bold">+   beforeEach(() =&gt; {</strong></p><p class="source-code"><strong class="bold">+     cy.intercept('GET', 'PacktPublishing/</strong></p><p class="source-code"><strong class="bold">        React-Projects-Second-Edition/hotels', </strong></p><p class="source-code"><strong class="bold">        { fixture: 'hotels.json' });</strong></p><p class="source-code"><strong class="bold">+     cy.intercept('GET', 'PacktPublishing/</strong></p><p class="source-code"><strong class="bold">        React-Projects-Second-Edition/hotels/*', </strong></p><p class="source-code"><strong class="bold">        { fixture: 'hotel.json' });</strong></p><p class="source-code"><strong class="bold">+     cy.intercept('GET', 'PacktPublishing/</strong></p><p class="source-code"><strong class="bold">        React-Projects-Second-Edition/hotels/*/reviews', </strong></p><p class="source-code"><strong class="bold">        []);</strong></p><p class="source-code"><strong class="bold">+   })</strong></p><p class="source-code">    it('opens the app and clicks on a hotel', () =&gt; {</p><p class="source-code">      // ...</p></li>
			</ol>
			<p>By opening<a id="_idIndexMarker420"/> the Cypress runner, you<a id="_idIndexMarker421"/> can see that our tests are now being executed with the data from the fixtures, as the API <a id="_idIndexMarker422"/>calls are being intercepted.</p>
			<p>The tests we've created in this section gave you a good start on writing end-to-end tests for React applications with Cypress. Also, Cypress can be used to do visual regression testing for your application or to test API responses.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor088"/>Summary</h1>
			<p>In this chapter, we covered testing for React applications using the React Testing Library in combination with Jest. Both packages are a great resource for any developer that wants to add test scripts to their application, and they work very well with React. The advantages of having tests for your application were discussed in this chapter, and hopefully, you now know how to add test scripts to any project. The differences between unit tests and integration tests were shown, and you've also learned how to write end-to-end tests with Cypress.</p>
			<p>Since the application that was tested in this chapter has the same structure as the applications from previous chapters, the same testing principles can be applied to any of the applications we've built in this book. </p>
			<p>The next chapter will combine a lot of the patterns and libraries we've already used in this book, as we'll be creating a full-stack e-commerce store with React, GraphQL, and Apollo.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor089"/>Further reading</h1>
			<p>For more information, refer to the following links: </p>
			<ul>
				<li>The React Testing Library: <a href="https://testing-library.com/docs/react-testing-library/intro/">https://testing-library.com/docs/react-testing-library/intro/</a></li>
				<li>Cypress: <a href="https://docs.cypress.io/">https://docs.cypress.io/</a></li>
			</ul>
		</div>
	</body></html>