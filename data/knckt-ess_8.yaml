- en: Chapter 8. Developing Web Applications with Durandal – The Cart Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章. 使用 Durandal 开发 Web 应用程序 - 购物车项目
- en: Now that we know how Durandal works, it is time to migrate our old application
    over to using our new framework. In this chapter, you will learn how to reuse
    the code we have used in the book in other projects and also adapt part of the
    code to the new environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们知道 Durandal 的工作原理，是时候将我们的旧应用程序迁移到使用我们的新框架了。在本章中，您将学习如何重用我们在书中使用的代码，并将部分代码适应新环境。 '
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: We are going to develop a completely new application in this chapter. However,
    we are going to reuse most parts of the code we developed in the last chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个全新的应用程序。但是，我们将重用上一章中开发的大部分代码。
- en: One of the disadvantages of working just with Knockout was that our application
    needs to connect to many libraries as it grows. The application we have developed
    during this book is very small, but has enough complexity and we haven't handled
    an important problem like routing. Our application always lies on the same page.
    We can't navigate between order and catalog or between cart and catalog. We have
    our entire application on the same page, showing and hiding components.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用 Knockout 的缺点之一是随着应用程序的增长，我们的应用程序需要连接到许多库。我们在本书中开发的应用程序非常小，但足够复杂，我们还没有解决一个重要的问题，即路由。我们的应用程序始终位于同一页上。我们无法在订单和目录之间或购物车和目录之间导航。我们的整个应用程序都在同一页上，显示和隐藏组件。
- en: Durandal connects some libraries you have learned in this book and makes it
    easy to connect to new ones.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal 连接了您在本书中学到的一些库，并且使连接到新库变得容易。
- en: 'Along the chapter, we are going to see some schemas with non-standard UML notation.
    Nowadays, agile methods do not recommend using UML deeply, but these kinds of
    diagrams help us to get a global and clearer view of the structure and requisites
    of our features. Also, to deploy views we will see some sketches and mockups of
    how the HMTL should be done:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到一些非标准 UML 符号的模式。现今，敏捷方法不建议深入使用 UML，但这些类型的图表帮助我们更全面、更清晰地了解我们功能的结构和需求。此外，为了部署视图，我们将看到一些关于
    HTML 如何完成的草图和模拟：
- en: '![Introduction](img/7074OS_08_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![Introduction](img/7074OS_08_01.jpg)'
- en: The life cycle of our application
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的生命周期
- en: Setting up the project
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'To start the new project, we are going to follow some steps that will give
    us a good starting point to develop our project:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动新项目，我们将按照一些步骤进行，这将为我们开发项目提供一个良好的起点：
- en: Create a new project as we did with the Knockout cart.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与 Knockout 购物车相同的项目。
- en: Inside this project, copy the content of the Durandal Starter Kit project.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此项目内，复制 Durandal Starter Kit 项目的内容。
- en: 'Now we should have three folders in our project:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的项目应该有三个文件夹：
- en: '`app`: This contains our application'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`：这包含了我们的应用程序。'
- en: '`css`: This contains stylesheets'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`css`：这包含样式表'
- en: '`lib`: This contains third-party libraries'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib`：这包含第三方库'
- en: 'Migrate the following libraries from the Knockout cart project to the Durandal
    cart project:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下库从 Knockout 购物车项目迁移到 Durandal 购物车项目：
- en: '`icheck`'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`icheck`'
- en: '`kovalidation`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kovalidation`'
- en: '`mockjax`'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mockjax`'
- en: '`mockjson`'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mockjson`'
- en: Install a new library called Toastr from [http://codeseven.github.io/toastr/](http://codeseven.github.io/toastr/).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [http://codeseven.github.io/toastr/](http://codeseven.github.io/toastr/) 安装一个名为
    Toastr 的新库。
- en: 'Update the `ko.validation.js` file on line 19 with the following code:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新第 19 行的 `ko.validation.js` 文件，使用以下代码：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Move the `style.css` file from the Knockout cart to the `css` folder in the
    Durandal cart project.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `style.css` 文件从 Knockout 购物车移动到 Durandal 购物车项目的 `css` 文件夹中。
- en: Move the `models` folder inside the `app` folder.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `models` 文件夹移动到 `app` 文件夹内。
- en: Move the `services` folder inside the `app` folder.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `services` 文件夹移动到 `app` 文件夹内。
- en: Create a file called `bindings.js` at the same level as the `main.js` file and
    move all the bindings inside the `koBindings.js` file there.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `bindings.js` 的文件，与 `main.js` 文件处于同一级别，并将所有绑定移到 `koBindings.js` 文件中。
- en: Create a file called `mocks.js` at the same level as the `main.js` file and
    move all mocks inside the `mocks` folder there.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `mocks.js` 的文件，与 `main.js` 文件处于同一级别，并将所有模拟移到 `mocks` 文件夹中。
- en: Create a file called `components.js` at the same level as the `main.js` file
    and move all the components that are in the `components.js` file there.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `components.js` 的文件，与 `main.js` 文件处于同一级别，并将所有组件移到那里。
- en: 'Update the `knockout` library. The Durandal starter kit comes with version
    3.1 and we are going to use 3.2, which is the version we used in the Knockout
    cart project. Version 3.2 allows us to use the `inputText` binding and components.
    You can see differences between all the versions at this link: [https://github.com/knockout/knockout/releases](https://github.com/knockout/knockout/releases).'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `knockout` 库。Durandal 起始套件附带版本 3.1，我们将使用 3.2 版本，这是我们在 Knockout 购物车项目中使用的版本。3.2
    版本允许我们使用 `inputText` 绑定和组件。您可以在此链接中查看所有版本之间的区别：[https://github.com/knockout/knockout/releases](https://github.com/knockout/knockout/releases)。
- en: 'Update the `main.js` file:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `main.js` 文件：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Set the project in your favorite server or copy the Mongoose executable in to
    the folder where `index.html` lies.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目设置在您喜欢的服务器上，或者将 Mongoose 可执行文件复制到 `index.html` 所在的文件夹中。
- en: 'Update `index.html` with the new css file:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的 css 文件更新 `index.html`：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now our project is ready and it is time to migrate our cart step by step.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的项目已经准备好了，是时候逐步迁移我们的购物车了。
- en: Routing the project – the shell view-model
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目路由 – shell 视图模型
- en: Durandal gives us the possibility of managing the routes in our project. We
    are going to split different parts of our project into pages. That will give a
    better user experience because we will be focused on just one task at a time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal 给了我们在项目中管理路由的可能性。我们将把项目的不同部分分割成页面。这将提供更好的用户体验，因为我们将一次只关注一个任务。
- en: 'We will split the app into four parts:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将将应用程序拆分为四个部分：
- en: The catalog
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录
- en: The cart
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车
- en: The order
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单
- en: The product CRUD
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品 CRUD
- en: These parts will contain more or less the same code we built in the Knockout
    application. Sometimes we will need to adapt small pieces of code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分将包含我们在 Knockout 应用程序中构建的几乎相同的代码。有时，我们需要适应一些小代码片段。
- en: 'To create these new routes, we will open the `shell.js` file and update the
    router:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这些新路由，我们将打开 `shell.js` 文件并更新路由器：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s review how the router works:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下路由器的工作原理：
- en: '`route` contains the relative URL. In the case of the catalog, there are three
    URLs attached to this route. They are the empty route (''''), the slash (''/'')
    route, and the catalog. To represent these three routes, we will use an array.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route` 包含相对 URL。对于目录，有三个 URL 附加到此路由。它们是空路由 ('''')，斜杠 (''/'') 路由和目录。为了表示这三个路由，我们将使用一个数组。'
- en: '`title` will contain the title attached in the `<title>` tag.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title` 将包含在 `<title>` 标签中附加的标题。'
- en: '`moduleId` will contain the view-model that handles this route. If we use conventions,
    it will look for the view in the `views` folder, looking for the view which has
    the same name as the view-model. In this case, it looks for `views/catalog.html`.
    If we choose not to use conventions, Durandal will look in the same folder as
    the view-model.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moduleId` 将包含处理此路由的视图模型。如果我们使用约定，它将在 `views` 文件夹中查找视图，查找与视图模型同名的视图。在这种情况下，它会查找
    `views/catalog.html`。如果我们选择不使用约定，Durandal 将在与视图模型相同的文件夹中查找。'
- en: If `nav` is true, a link will be shown in the navigation menu. If it is false,
    the router doesn't display the link in the navigation menu.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `nav` 为 true，则导航菜单中将显示一个链接。如果为 false，则路由器不会在导航菜单中显示链接。
- en: The navigation and shell templates
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航和 shell 模板
- en: 'As we did in [Chapter 7](ch07.html "Chapter 7. Durandal – The KnockoutJS Framework"),
    *Durandal – The KnockoutJS Framework*, we are going to compose our `shell.html`
    view in two parts: `shell.html` and `navigation.html`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 7 章](ch07.html "Chapter 7. Durandal – The KnockoutJS Framework")中所做的，*Durandal
    – The KnockoutJS Framework*，我们将会将我们的 `shell.html` 视图分为两部分：`shell.html` 和 `navigation.html`。
- en: The catalog module
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录模块
- en: In the Knockout cart, we have a view-model that manages all parts of the application.
    Here we are going to split that big view-model into several parts. The first part
    is the catalog.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Knockout 购物车中，我们有一个管理应用程序所有部分的视图模型。在这里，我们将把那个大的视图模型拆分成几个部分。第一部分是目录。
- en: 'Here we have a schema of how it should work:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它应该如何工作的模式图：
- en: '![The catalog module](img/7074OS_08_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![目录模块](img/7074OS_08_02.jpg)'
- en: The workflow of the catalog module
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 目录模块的工作流程
- en: Catalog will contain just the partial that includes the search bar and the table
    with its actions. This makes the view-model smaller and therefore more maintainable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 目录将仅包含包括搜索栏和带有其操作的表格的部分。这将使视图模型更小，因此更易于维护。
- en: Although files will be split into different folders, catalog is a module by
    itself. It contains the view-model, the view, and some services that will only
    work inside this module. Other components will be required, but they will be shared
    by more modules along the live cycle of the application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然文件将分成不同的文件夹，但目录本身是一个模块。它包含视图模型、视图以及一些仅在该模块内部工作的服务。其他组件将被引入，但它们将在应用程序生命周期中被更多模块共享。
- en: 'Create a file named `catalog.js` in the `viewmodels` folder and define a basic
    reveal pattern skeleton to begin adding features:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `viewmodels` 文件夹中创建一个名为 `catalog.js` 的文件，并定义一个基本的揭示模式骨架以开始添加功能：
- en: '[PRE4]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a file named `catalog.html` in the `views` folder:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `views` 文件夹中创建一个名为 `catalog.html` 的文件：
- en: '[PRE5]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By just doing this, our module is ready to work. Let's complete the code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅通过这样做，我们的模块就已经准备好工作了。让我们完成代码。
- en: The catalog view
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目录视图
- en: We are going to use composition to create this template. Remember that composition
    is one of the powerful features of Durandal. To complete this feature, we will
    create three new templates that contain different parts of the root view. By doing
    this, we made our view more maintainable because we isolated different parts of
    the template in different files that are smaller and easy to read.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用组合来创建这个模板。记住，组合是 Durandal 的一个强大特性之一。为了完成这个功能，我们将创建三个包含根视图不同部分的新模板。通过这样做，我们将我们的视图更加易于维护，因为我们将模板的不同部分隔离在不同的文件中，这些文件更小且易于阅读。
- en: '![The catalog view](img/7074OS_08_03.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![目录视图](img/7074OS_08_03.jpg)'
- en: Mockup of the catalog view
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 目录视图的草图
- en: 'Follow these steps to create the templates:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建模板：
- en: 'Open the `catalog.html` file and create the basic template:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `catalog.html` 文件并创建基本模板：
- en: '[PRE6]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a view called `catalog-searchbar.html`. We prefix child views with the
    name of the root view, so if your editor orders files by name, they will be displayed
    all grouped together. We can also group all of them inside a folder. We can choose
    the way we feel more comfortable:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `catalog-searchbar.html` 的视图。我们用根视图的名称为子视图添加前缀，所以如果你的编辑器按名称对文件进行排序，它们将全部显示在一起。我们也可以将它们全部组合在一个文件夹中。我们可以选择我们感觉最舒适的方式：
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now it is time to define the view named `catalog-details.html`; it will contain
    actions and cart details:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候定义名为 `catalog-details.html` 的视图了；它将包含操作和购物车详情：
- en: '[PRE8]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we will define the `catalog-table.html`, which contains the table
    we built in the Knockout cart project. Some `data-bind` elements should be updated
    and the footer needs to be removed:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将定义包含我们在 Knockout 购物车项目中构建的表格的 `catalog-table.html`。某些 `data-bind` 元素应该被更新，而页脚需要被移除：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The catalog view-model
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目录视图模型
- en: 'Now it''s time to define all the components we can identify along our templates.
    We should begin defining the basic data we can locate inside the templates:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候定义我们可以在我们的模板中识别的所有组件了。我们应该开始定义我们可以在模板中定位到的基本数据：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we define these variables, we realize that Knockout dependency is required.
    Add it to the dependencies array and also as a parameter in the `module` function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了这些变量，我们意识到需要 Knockout 依赖。将其添加到依赖项数组中，并且也作为 `module` 函数的一个参数：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we should define the `filterCatalog` method. It''s the same method that
    we have in our view-model in the Knockout project:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该定义 `filterCatalog` 方法。这是我们在 Knockout 项目中的视图模型中拥有的相同方法：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `add-to-cart-button` component was defined in the Knockout project and we
    don't need to touch any piece of code this component. This is a clear example
    of how good components are and the potential they have.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`add-to-cart-button` 组件在 Knockout 项目中被定义，我们不需要触碰该组件的任何代码。这是一个很好的组件及其潜力的明确例证。'
- en: To edit a product from the catalog, we need to navigate to the edit route. This
    creates a dependency with the router plugin. We should add the `plugins/router`
    dependency to our module.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑目录中的产品，我们需要导航到编辑路由。这会创建与路由插件的依赖关系。我们应该在我们的模块中添加 `plugins/router` 依赖关系。
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To remove a product from the catalog, we will need to remove it from the server
    and also from the cart. To speak with the server, we will use the `services/product.js`
    file, and to speak with the cart, we will create a new service in a file named
    `services/cart`. Define the `remove` method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要从目录中移除产品，我们需要从服务器和购物车中将其移除。要与服务器通信，我们将使用 `services/product.js` 文件，而要与购物车通信，我们将在一个名为
    `services/cart` 的文件中创建一个新服务。定义 `remove` 方法：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First we use the message component that Durandal has. It is very useful to handle
    modal dialogs. We will ask the user whether the product should be removed. If
    yes, we will remove it from the server and then refresh our view-model, and also
    remove the product from the cart because it is not available any more.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们使用Durandal的消息组件。它非常有用于处理模态对话框。我们将询问用户是否应删除产品。如果是，则我们将从服务器中删除它，然后刷新我们的视图模型，并且从购物车中删除产品，因为它不再可用。
- en: We should add a dependency to `durandal/app` and dependencies to `ProductService`
    and `CartService`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该添加一个依赖项到`durandal/app`，并且依赖于`ProductService`和`CartService`。
- en: '`ProductService` was defined in the Knockout project. If we keep models and
    services very simple, they will become portable and adapt themselves very well
    to different projects.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductService`在Knockout项目中被定义。如果我们保持模型和服务非常简单，它们将变得可移植，并且非常适应不同的项目。'
- en: Now is the time to implement the `refresh` method. We will call the `ProductService.all()`
    method and display a message letting the user know that the products are loaded.
    We will return the promise this method generates.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是实现`refresh`方法的时候了。我们将调用`ProductService.all()`方法，并显示一条消息，让用户知道产品已加载。我们将返回此方法生成的承诺。
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we use the same model for products that we used in the Knockout project.
    We are seeing a lot of code, but most of it was done earlier in the book, so we
    just need to move it from one project to the other.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了在Knockout项目中使用的相同模型来表示产品。我们看到了很多代码，但大部分是在书中较早完成的，所以我们只需要将它们从一个项目移到另一个项目中。
- en: 'The last step is to activate our view-model. When should a view-model be activated?
    When our products come from the server and are ready to be shown:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是激活我们的视图模型。什么时候应该激活视图模型？当我们的产品来自服务器并且准备好展示时：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first time we load the application, we check to see whether the catalog
    has products. If it has, we just return that the catalog is ready. If the catalog
    is empty, we create an event that lets other services notify the catalog that
    it should be updated. Then we refresh the catalog to get new data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次加载应用程序时，我们会检查目录是否有产品。如果有，我们只需返回目录已准备就绪。如果目录为空，我们会创建一个事件，让其他服务通知目录它应该更新。然后我们刷新目录以获取新数据。
- en: 'This is the final result of our `catalog` view-model; of course we still need
    to implement the log service and the cart service:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们`catalog`视图模型的最终结果；当然，我们仍然需要实现日志服务和购物车服务：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The cart service
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 购物车服务
- en: 'The cart service will manage cart data for all modules. The services have persistent
    data along the session, so they can help us to share data between view-models.
    In this case, the cart service will share some pages with the cart: catalog, cart,
    and order.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车服务将管理所有模块的购物车数据。服务在会话期间具有持久数据，因此它们可以帮助我们在视图模型之间共享数据。在这种情况下，购物车服务将与购物车共享一些页面：目录、购物车和订单。
- en: The cart service will react to operations performed over the `cart` observable.
    The `add` operation is managed by the `add-to-cart-button` component but it would
    be interesting to integrate this behavior here. The refactoring of code can be
    a good exercise. In this example, we will keep the component and we will implement
    the other methods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车服务将对在`cart`可观察对象上执行的操作做出反应。`add`操作由`add-to-cart-button`组件管理，但是将这个行为集成到这里会很有趣。代码重构可以是一个很好的练习。在这个例子中，我们将保留组件，并实现其他方法。
- en: The cart service also stores the total amount of the cart in the `grandTotal`
    observable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车服务还将购物车的总金额存储在`grandTotal`可观察对象中。
- en: 'The cart service updates the cart as well. This will be useful because when
    the catalog is updated, product references stored in the cart are different from
    the new products in the catalog, so we need to renew these references. It also
    updates the catalog, decreasing the stock by the units of each product that are
    in the cart. We do this because the server sends us the data it has. The server
    doesn''t know that we are shopping now. Maybe we decide not to shop, so the products
    we have in the cart are not registered as sold. This is why we need to update
    the units in the client once we get the products from the server. Here is the
    code of the cart service:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车服务也更新购物车。这很有用，因为当目录更新时，购物车中存储的产品引用与目录中的新产品不同，所以我们需要更新这些引用。它还更新了目录，通过减少购物车中每个产品的单位来减少库存。我们之所以这样做是因为服务器发送给我们它所拥有的数据。服务器不知道我们现在正在购物。也许我们决定不购物，所以我们购物车中的产品不被注册为已售出。这就是为什么我们需要在从服务器获取产品后更新客户端中的单位的原因。这是购物车服务的代码：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The log service
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志服务
- en: 'The log service allows us to display messages to inform the user about what
    is happening in our application. To do this, we use a library called Toastr. We
    can use Toastr directly on the application, but a good practice is to always encapsulate
    libraries to separate the code we should not touch. Also, wrapping the library
    in another one makes it easy to extend and customize the behavior of the library.
    In this case, we have also added the ability to log the message in the console:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 日志服务允许我们显示消息以通知用户我们的应用程序中正在发生的情况。为此，我们使用一个称为Toastr的库。我们可以直接在应用程序上使用Toastr，但是一个好的做法是始终封装库以分离我们不应该触及的代码。此外，将库包装在另一个库中使其易于扩展和定制库的行为。在这种情况下，我们还添加了在控制台中记录消息的功能：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Adding products to the catalog
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将产品添加到目录
- en: 'The add feature is related with this route:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 添加功能与此路由相关：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To create this module, we need to create the add view and the add view-model.
    To do this, create two files called `views/new` and `viewmodels/new.js` and repeat
    the template we used with the catalog module.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个模块，我们需要创建添加视图和添加视图模型。为此，请创建两个文件，名为`views/new`和`viewmodels/new.js`，并重复我们在目录模块中使用的模板。
- en: '![Adding products to the catalog](img/7074OS_08_04.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![将产品添加到目录](img/7074OS_08_04.jpg)'
- en: The add product workflow
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 添加产品的工作流程
- en: The add product view
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加产品视图
- en: Creating or updating a product is more or less the same. The difference is that
    when we edit a product, the fields have data, and when we add a new product, the
    fields of this product are empty. This might make us wonder if maybe we can isolate
    views.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建或更新产品更多或更少是相同的。不同之处在于当我们编辑一个产品时，字段具有数据，当我们添加一个新产品时，此产品的字段为空。这可能使我们想知道也许我们可以隔离视图。
- en: 'Let''s define the `new.html` file as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`new.html`文件定义如下：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This means the `new.html` file is composed by the `edit.html` file. We just
    need to define one template to manage both. Awesome, isn't it?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`new.html`文件由`edit.html`文件组成。我们只需要定义一个模板来管理两者。很棒，是吗？
- en: '![The add product view](img/7074OS_08_05.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![添加产品视图](img/7074OS_08_05.jpg)'
- en: The add new product mockup
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新产品的草图
- en: The edit view
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑视图
- en: 'We just need to copy and paste the edit form we had in the Knockout project.
    We have updated the layout, but we have used the same form:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要复制并粘贴我们在Knockout项目中使用的编辑表单。我们已经更新了布局，但是我们使用了相同的表单。
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There are some things that should be created dynamically, such as the title
    of the layout and the button name. The `edit` method will say which method of
    the product service should handle the product—`ProductService.create` or `ProductService.save`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些东西应该动态创建，比如布局的标题和按钮名称。`edit`方法将指定产品服务的哪个方法来处理产品——`ProductService.create`或`ProductService.save`。
- en: The add product view-model
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加产品视图模型
- en: 'The add product view-model is coded in the `viewmodels/new.js` file. It will
    create a new product. If all is successful, we notify the user and navigate to
    the catalog. To show the new product in the catalog, we fire the `catalog:refresh`
    event:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 添加产品视图模型编码在`viewmodels/new.js`文件中。它将创建一个新产品。如果一切顺利，我们会通知用户并导航到目录。为了在目录中显示新产品，我们触发`catalog:refresh`事件：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the first version of our mocks, if we added a new project, our catalog wasn't
    getting updated. It returned the same five products we got at the beginning. We
    are going to improve our mock library to make it more realistic.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模拟的第一个版本中，如果我们添加了一个新项目，我们的目录没有得到更新。它返回了我们一开始得到的同样五个产品。我们打算改进我们的模拟库，使其更加逼真。
- en: Making mocks real
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使模拟变得真实
- en: 'Let''s take a look at our `mocks.js` file, specifically the get products mock:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的`mocks.js`文件，特别是获取产品模拟的部分：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lets refactor this to:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其重构为：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we are going to create the `updatedCatalog` function. We generate the array
    of products at the beginning and then we always work with this copy:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要创建`updatedCatalog`函数。我们在开始时生成产品数组，然后始终使用这个副本进行操作：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the old version of the mocks, when we got a product, we got one generated
    randomly using a template. Now we are going to come back with the real one. We
    will iterate along the catalog and return the product with the selected ID. Also,
    we will update the mock object. Instead of writing a response text, we will create
    a response function that will find the product and generate the correct response:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版本的模拟中，当我们得到一个产品时，我们使用模板随机生成一个产品。现在我们将回到真实的产品。我们将沿着目录进行迭代，并返回具有选定ID的产品。此外，我们还将更新模拟对象。我们将创建一个响应函数来查找产品并生成正确的响应，而不是编写响应文本：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We should update the `POST` and `PUT` mocks to add products to the mocked catalog
    and update the ones that exist:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该更新`POST`和`PUT`模拟数据以向模拟目录添加产品并更新已存在的产品：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We should also remove products from our mock when the `DELETE` method is invoked:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`DELETE`方法时，我们还应该从模拟数据中移除产品：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we should move the order mock to this file in order to share the catalog.
    When an order is performed, the stock in the catalog should be updated:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该将订单模拟数据移动到这个文件中，以便与目录共享。当执行订单时，目录中的库存应该更新：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The order mock will generate a unique ID that identifies the order. This must
    be sent back to the user to identify the order in the future. In our application,
    this is the end of the life cycle of our project.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 订单模拟数据将生成一个用于识别订单的唯一 ID。这必须发送回给用户以便未来识别订单。在我们的应用程序中，这标志着我们项目生命周期的结束。
- en: 'This is the `uuid` function we use to generate unique IDs:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们用于生成唯一ID的`uuid`函数：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can leave this function in the mock module or create a new service that handles
    unique ID generation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将该函数保留在模拟模块中，或者创建一个新的服务来处理唯一 ID 的生成。
- en: Now our mock responds to the application in a more realistic way.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的模拟数据以更现实的方式响应应用程序。
- en: The edit view-model
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑视图模型
- en: 'Coming back to our modules, we now need to create the `edit.js` view-model.
    It will have the same structure as the `new.js` file, but in this case the activation
    will retrieve the product we are going to edit. Then we will save the product
    and the mock will update it on the (fake) server:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的模块，现在我们需要创建`edit.js`视图模型。它将与`new.js`文件有相同的结构，但在这种情况下，激活将会获取要编辑的产品。然后我们将保存产品，并且模拟数据将在（假的）服务器上更新它：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We should notice that in both add product and edit product, the model is validated.
    We made this in the Knockout project and now we are reusing it in this project.
    Isn't it amazing?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，在添加产品和编辑产品中，模型都经过了验证。我们在 Knockout 项目中已经这样做了，现在我们在这个项目中重用它。这不是很神奇吗？
- en: The cart module
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 购物车模块
- en: The cart module will manage the partial that shows the cart. As we did in the
    Knockout project, we should be able to update the quantity of the product. We
    will remove items if we don't want them anymore. Also, we will only activate this
    view if the cart has products in it, because it doesn't make sense to visit the
    cart if it is empty. In that case, we will be redirected to the catalog.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车模块将管理显示购物车的部分。就像我们在 Knockout 项目中所做的那样，我们应该能够更新产品的数量。如果不再需要商品，我们将删除它们。并且只有在购物车中有商品时才激活此视图，因为如果购物车为空，去访问购物车是没有意义的。在这种情况下，我们将被重定向到目录。
- en: '![The cart module](img/7074OS_08_06.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![购物车模块](img/7074OS_08_06.jpg)'
- en: The cart workflow
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车工作流
- en: The cart view
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 购物车视图
- en: 'The cart uses the same template we used in the Knockout project. Of course
    we have adapted it a little bit to show it centered on the screen:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车使用与我们在 Knockout 项目中使用的相同的模板。当然，我们对它进行了一些调整，使其在屏幕上居中显示：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As we did with the cart item, we also compose the view here. The `cart-item.html`
    file has the same code that is in the Knockout project. Just notice that `addUnit`
    and `removeUnit` are now called by the parent:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们处理购物车商品一样，我们也在这里组合视图。`cart-item.html`文件拥有和 Knockout 项目中相同的代码。只需注意现在`addUnit`和`removeUnit`由父组件调用：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![The cart view](img/7074OS_08_07.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![购物车视图](img/7074OS_08_07.jpg)'
- en: The cart view mockup
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车视图模拟
- en: The cart view-model
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 购物车视图模型
- en: 'The cart view-model will talk to the cart service and will update the state
    of the cart. Look how we are using the cart service to share information between
    modules. This is because we have created the service as an object and it is a
    singleton. Once it is loaded, it will persist during the application''s life cycle:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车视图模型将与购物车服务通信，并更新购物车的状态。看看我们是如何在模块之间使用购物车服务共享信息的。这是因为我们已将服务创建为对象，并且它是一个单例。一旦加载，它将在应用程序生命周期内持续存在：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There are two ways to communicate between components in Durandal, services and
    events. To share information between view-models, the best practice is to use
    services. If you want to send messages from one service to a view-model, or between
    view-models, you should use events. This is because services can be required inside
    a module and you can call them explicitly. Moreover, we can't access view-models
    from other view-models or services, which is why we need to send messages to them
    using events.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Durandal 中，有两种组件之间通信的方式，服务和事件。要在视图模型之间共享信息，最佳实践是使用服务。如果要从一个服务向视图模型或视图模型之间发送消息，则应使用事件。这是因为服务可以在模块内被引用，可以显式调用它们。此外，我们无法从其他视图模型或服务中访问视图模型，这就是为什么我们需要使用事件向它们发送消息的原因。
- en: The order module
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订单模块
- en: This module will manage the confirmation of our order. To complete an order,
    we need to introduce our personal data. We can only access the order page if we
    have something in our cart. Once we confirm our order, we will get a message from
    the server with the order ID. The product's stock will be updated and we will
    be able to continue shopping.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块将管理我们订单的确认。要完成订单，我们需要输入个人数据。只有在购物车中有商品时，我们才能访问订单页面。一旦我们确认订单，我们将收到服务器发送的订单
    ID 消息。产品库存将更新，我们将能够继续购物。
- en: '![The order module](img/7074OS_08_08.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![订单模块](img/7074OS_08_08.jpg)'
- en: The order workflow
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 订单工作流程
- en: The order view
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订单视图
- en: The order view will be the same order view we built in the Knockout project.
    This time we will use composition to make the view simpler.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 订单视图将是我们在 Knockout 项目中构建的相同订单视图。这次我们将使用组合使视图更简单。
- en: 'The `order.html` file will contain the structure of the page and we will build
    some partials to compose the entire view. These partials will be:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`order.html` 文件将包含页面的结构，我们将构建一些部分来组成整个视图。这些部分将是：'
- en: '`order-cart-detail.html`: This will contain the read-only cart'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`order-cart-detail.html`：这将包含只读购物车'
- en: '`order-contact-data.html`: This will contain the personal data'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`order-contact-data.html`：这将包含个人数据'
- en: '`order-buttons.html`: This will contain the action buttons of the page'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`order-buttons.html`：这将包含页面的操作按钮'
- en: 'The `order.html` file will contain this code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`order.html` 文件将包含这段代码：'
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `order-cart.html` file will contain the read-only cart. It's the same markup
    you can find in the `order.html` template in the Knockout cart project.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`order-cart.html` 文件将包含只读购物车。这是在 Knockout 购物车项目中的 `order.html` 模板中找到的相同标记。'
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `order-contact.html` file will contain the form that is in the view `order.html`
    Knockout cart project:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`order-contact.html` 文件将包含在视图 `order.html` Knockout 购物车项目中的表单：'
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, the `order-buttons.html` has the button to confirm the order. Of course,
    you can find it in the `order.html` file we built in the Knockout cart project.
    We re-use as much code as we are able to.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`order-buttons.html` 文件中有确认订单的按钮。当然，你可以在我们在 Knockout 购物车项目中构建的 `order.html`
    文件中找到它。我们尽可能地重用代码。
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![The order view](img/7074OS_08_09.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![订单视图](img/7074OS_08_09.jpg)'
- en: The order mockup
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 订单草图
- en: The order view-model
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订单视图模型
- en: 'The order view will check whether our cart is empty to allow the activation.
    Validation is managed by the customer model. This model was built in the Knockout
    cart project. The rest of the code is partly from the big view-model we had in
    the Knockout cart project:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 订单视图将检查我们的购物车是否为空以允许激活。验证由客户模型管理。这个模型是在 Knockout 购物车项目中构建的。其余的代码部分来自我们在 Knockout
    购物车项目中的大视图模型：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, our project is done and we have reused most of the old code. After
    migrating the project, we can see the advantages Durandal gives us. Notice also
    that we have not used the full potential of Durandal and Knockout. We can iterate
    over this project and improve all the parts again and again. We can create perfect
    isolated components. We can split the catalog into even smaller pieces and add
    more functionality, such as ordering and pagination. However, this project gives
    us a quick global overview of what Durandal is capable of.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的项目完成了，我们重新使用了大部分旧代码。迁移项目后，我们可以看到 Durandal 给我们带来的优势。还要注意，我们并没有充分利用 Durandal
    和 Knockout 的潜力。我们可以迭代这个项目，一遍又一遍地改进所有部分。我们可以创建完美的隔离组件。我们可以将目录分割成更小的部分，并添加更多功能，如订购和分页。但是，这个项目给我们提供了
    Durandal 能力的快速全局概述。
- en: Grouping code by feature – managing big projects
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按功能分组代码 - 管理大项目
- en: As you have seen in the `main.js` file, we are using Durandal conventions. This
    means that all our view-models lie in the `viewmodels` folder and all our views
    lie in the `views` folder. When we have a big project, having all the files in
    the same folder can be difficult to manage.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在 `main.js` 文件中所见，我们正在使用 Durandal 约定。这意味着我们所有的视图模型都位于 `viewmodels` 文件夹中，而所有的视图都位于
    `views` 文件夹中。当我们有一个大项目时，将所有文件放在同一个文件夹中可能会难以管理。
- en: In this case, we remove the `viewLocator.useConvention();` statement from the
    `main.js` file. This acts as an indication to Durandal that all the views are
    in the same folder as the view-model.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们从 `main.js` 文件中删除了 `viewLocator.useConvention();` 语句。这作为 Durandal 的一个指示，表明所有的视图都在与视图模型相同的文件夹中。
- en: 'We are going to group our project by features. We will define these features
    in our project:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按特性对项目进行分组。我们将在我们的项目中定义这些特性：
- en: catalog
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: catalog
- en: cart
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cart
- en: order
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: order
- en: product
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: product
- en: shell
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: shell
- en: 'They will contain the code for each feature. Services, models, and other components
    will be as we had when we used conventions. Take a look at what the folders look
    like:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 它们将包含每个特性的代码。服务、模型和其他组件将与我们使用约定时一样。看看这些文件夹是什么样子的：
- en: '![Grouping code by feature – managing big projects](img/7074OS_08_10.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![按特性分组代码 - 管理大型项目](img/7074OS_08_10.jpg)'
- en: Files grouped by features
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 文件按特性分组
- en: 'We need to update some code. The first step is to update the main folder, setting
    the new ID of the shell module:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新一些代码。第一步是更新主文件夹，设置 shell 模块的新 ID：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then we should do the same with the router inside the shell module:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们应该对 shell 模块内的路由器做同样的事情：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we need to update the compose paths. They should be full paths. This
    means that where we have the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新组合路径。它们应该是完整路径。这意味着当我们有以下代码时：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will now have the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将会有以下代码：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Our code will be ready to go.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码将准备就绪。
- en: Notice that now it is easy to find where the code we are working on is. Usually,
    we work on a feature and is more comfortable to have all the code of this feature
    in the same place. Also, we can better see whether we are isolating our feature
    properly. If we notice we are working too much out of the feature folder, maybe
    it means you are doing something wrong.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在很容易找到我们正在工作的代码所在的位置。通常，我们会在一个特性上工作，并且将所有这个特性的代码放在同一个地方更加方便。此外，我们可以更好地看到我们是否正确地隔离了我们的特性。如果我们注意到我们在特性文件夹之外工作得太多，也许这意味着你正在做错事。
- en: 'To see the code for this chapter, you can download it from GitHub:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看本章的代码，您可以从 GitHub 下载：
- en: Durandal project using conventions from [https://github.com/jorgeferrando/durandal-cart/tree/chapter8part1](https://github.com/jorgeferrando/durandal-cart/tree/chapter8part1).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Durandal 项目使用约定，来自 [https://github.com/jorgeferrando/durandal-cart/tree/chapter8part1](https://github.com/jorgeferrando/durandal-cart/tree/chapter8part1)。
- en: Durandal project grouping files by feature from [https://github.com/jorgeferrando/durandal-cart/tree/master](https://github.com/jorgeferrando/durandal-cart/tree/master).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Durandal 项目将文件按特性分组，来自 [https://github.com/jorgeferrando/durandal-cart/tree/master](https://github.com/jorgeferrando/durandal-cart/tree/master)。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Finally, we have developed a complete application that leads us to create Single
    Page Applications using Durandal.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们开发了一个完整的应用程序，引导我们使用 Durandal 创建单页面应用程序。
- en: During this book, you have learned best practices to work with the JavaScript
    code. These practices and patterns, such as the reveal pattern or the module pattern
    are used in all frameworks and libraries.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，您已经学会了使用 JavaScript 代码的最佳实践。这些实践和模式，比如揭示模式或模块模式，在所有的框架和库中都被使用。
- en: Building isolated and small pieces of code helps us to migrate our code easily
    from one environment to the other. In just one chapter, we have migrated our application
    from a basic Knockout application to a Durandal one.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 构建独立且小的代码片段有助于我们轻松地将代码从一个环境迁移到另一个环境。在仅仅一个章节中，我们已经将我们的应用程序从一个基本的 Knockout 应用程序迁移到了一个
    Durandal 应用程序。
- en: Now we have developed good skills with Knockout and Durandal, we can try to
    improve this application by ourselves.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了 Knockout 和 Durandal 的良好技能，我们可以尝试自己改进这个应用程序。
- en: We can create a user module that enables users to log in and just allows administrators
    to edit and delete projects from the catalog. Alternatively, we can paginate our
    products and order them by price. We have acquired all the skills we need to successfully
    develop all these features. We just need to follow the steps you have learned
    during this book to complete these development tasks.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个用户模块，使用户能够登录，只允许管理员编辑和删除目录中的项目。或者，我们可以对我们的产品进行分页，并按价格排序。我们已经掌握了成功开发所有这些功能所需的所有技能。我们只需按照您在本书中学到的步骤来完成这些开发任务。
- en: I hope that you have enjoyed this book as much I have. I would like to tell
    you that you need to push yourself to learn more about JavaScript, Knockout, Durandal
    and all the fantastic JavaScript frameworks that nowadays exist on the Internet.
    Learn the best practices and follow the best patterns to keep your code KISS and
    SOLID.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你像我一样喜欢这本书。我想告诉你，你需要努力学习更多关于JavaScript、Knockout、Durandal以及当今互联网上存在的所有奇妙的JavaScript框架。学习最佳实践，遵循最佳模式，保持你的代码简单和稳固。
