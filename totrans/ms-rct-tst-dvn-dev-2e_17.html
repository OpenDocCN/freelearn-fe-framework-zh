<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer053">
<h1 class="chapter-number" id="_idParaDest-276"><a id="_idTextAnchor344"/>17</h1>
<h1 id="_idParaDest-277"><a id="_idTextAnchor345"/>Writing Your First Cucumber Test</h1>
<p>Test-driven development is primarily a process for developers. Sometimes, customers and product owners want to see the results of automated tests too. Unfortunately, the humble unit test that is the foundation of TDD is simply too low-level to be helpful to non-developers. That’s where<a id="_idIndexMarker1478"/> the idea of <strong class="bold">Behavior Driven Development (BDD)</strong> comes in.</p>
<p>BDD tests have a few characteristics that set them apart from the unit tests you’ve seen so far:</p>
<ul>
<li>They are <strong class="bold">end-to-end tests</strong> that operate across the entire system.</li>
<li>They are written in natural language rather than code, which is understandable by non-coders and coders alike.</li>
<li>They avoid making references to internal mechanics, instead focusing on the outward behavior of the system.</li>
<li>The test definition describes itself (with unit tests, you need to write a test description that matches the code).</li>
<li>The syntax is designed to ensure that your tests are written as examples, and as discrete specifications of behavior.</li>
</ul>
<p class="callout-heading">BDD tools vs TDD vs unit tests</p>
<p class="callout">The style of TDD you’ve seen so far in this book treats (for the most part) its tests as examples that specify <a id="_idIndexMarker1479"/>behavior. Also, our tests were always written in the <strong class="bold">Arrange-Act-Assert (AAA)</strong> pattern. However, notice that unit test tools such as Jest do not force you to write tests this way. </p>
<p class="callout">This is one reason why BDD tools exist: to force you to be very clear when you specify the behavior of your system.</p>
<p>This chapter introduces two new software packages: Cucumber and Puppeteer.</p>
<p>We’ll use Cucumber to build our BDD tests. Cucumber is a system that exists for many different programming environments, including Node.js. It consists of a test runner that runs tests contained <a id="_idIndexMarker1480"/>within <strong class="bold">feature files</strong>. Features are written in a plain-English language<a id="_idIndexMarker1481"/> known as <strong class="bold">Gherkin</strong>. When Cucumber runs your tests, it translates these feature files into function calls; these function calls are written in JavaScript <strong class="bold">support scripts</strong>.</p>
<p>Since Cucumber has its own test runner, it doesn’t use Jest. However, we will make use of Jest’s <strong class="source-inline">expect</strong> package in some of our tests.</p>
<p class="callout-heading">Cucumber is not the only way to write system tests</p>
<p class="callout">Another popular testing<a id="_idIndexMarker1482"/> library is Cypress, which may be a better choice for you and/or your team. Cypress puts the emphasis on the visual presentation of results. I tend to avoid it because its API is very different from industry-standard testing patterns, which increases the amount of knowledge developers need to have. Cucumber is cross-platform and tests look very similar to the standard unit tests you’ve seen throughout this book.</p>
<p><strong class="bold">Puppeteer</strong> performs a similar function to the JSDOM library. However, while JSDOM implements a fake DOM API <a id="_idIndexMarker1483"/>within the Node.js environment, Puppeteer uses a real web browser, Chromium. In this book, we’ll use it in <em class="italic">headless</em> mode, which means <a id="_idIndexMarker1484"/>you won’t see the app running onscreen; but you can, if you wish, turn headless mode off. Puppeteer comes with all sorts of bolt-ons, such as the ability to take screenshots.</p>
<p class="callout-heading">Cross-browser testing</p>
<p class="callout">If you wish to test cross-browser support for your application, you may be better off looking at an alternative such as Selenium, which isn’t covered in this book. However, the same testing principles apply when writing tests for Selenium.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Integrating Cucumber and Puppeteer into your code base</li>
<li>Writing your first Cucumber test</li>
<li>Using data tables to perform setup</li>
</ul>
<p>By the end of the chapter, you’ll have a good idea of how a Cucumber test is built and run.</p>
<h1 id="_idParaDest-278"><a id="_idTextAnchor346"/>Technical requirements</h1>
<p>The code files for this chapter can be found here: </p>
<p><a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter17">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Cha<span id="_idTextAnchor347"/>pter17</a></p>
<h1 id="_idParaDest-279"><a id="_idTextAnchor348"/>Integrating Cucumber and Puppeteer into your code base</h1>
<p>Let’s <a id="_idIndexMarker1485"/>add the <a id="_idIndexMarker1486"/>necessary packages to our project:</p>
<ol>
<li>Start by installing the packages we’re after. As well as Cucumber and Puppeteer, we’ll also pull in <strong class="source-inline">@babel/register</strong>, which will enable us to use ES6 features within our support files:<p class="source-code"><strong class="bold">$ npm install --save-dev @cucumber/cucumber puppeteer </strong></p><p class="source-code"><strong class="bold">$ npm install --save-dev @babel/register</strong></p></li>
<li>Next, create a new file named <strong class="source-inline">cucumber.json</strong> with the following content. This has two settings; <strong class="source-inline">publishQuiet</strong> turns off a bunch of noise that would otherwise appear when you run tests, and <strong class="source-inline">requireModule</strong> hooks up <strong class="source-inline">@babel/register</strong> before tests are run:<p class="source-code">{</p><p class="source-code">  "default": {</p><p class="source-code">    "publishQuiet": true,</p><p class="source-code">    "requireModule": [</p><p class="source-code">      "@babel/register"</p><p class="source-code">    ]</p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>Create a new folder<a id="_idIndexMarker1487"/> called <strong class="source-inline">features</strong>. This should live at the same level as <strong class="source-inline">src</strong> and <strong class="source-inline">test</strong>.</li>
<li>Create<a id="_idIndexMarker1488"/> another <a id="_idIndexMarker1489"/>folder within that called <strong class="source-inline">features/support</strong>.</li>
</ol>
<p>You can now run tests with the following command:</p>
<p class="source-code">$ npx cucumber-js</p>
<p>You’ll see output like this:</p>
<p class="source-code">0 scenarios</p>
<p class="source-code">0 steps</p>
<p class="source-code">0m00.000s</p>
<p>Throughout this chapter and the following one, it may be helpful to narrow down the tests you’re running. You can run a single scenario by providing the test runner with the filename and starting line number of the scenario:</p>
<p class="source-code">$ npx cucumber-js features/drawin<a id="_idTextAnchor349"/>g.feature:5</p>
<p>That’s all there is to getting set up with Cucumber and Puppeteer—now it’s time to write a test.</p>
<h1 id="_idParaDest-280"><a id="_idTextAnchor350"/>Writing your first Cucumber test</h1>
<p>In this section, you’ll build a <a id="_idIndexMarker1490"/>Cucumber feature file for a part of the <a id="_idIndexMarker1491"/>Spec Logo application that we’ve already built.</p>
<p class="callout-heading">Warning on Gherkin code samples</p>
<p class="callout">If you’re reading <a id="_idIndexMarker1492"/>an electronic version of this book, be careful when copying and pasting feature definitions. You may find extra line breaks are inserted into your code that Cucumber won’t recognise. Before running your tests, please look through your pasted code snippets and remove any line breaks that shouldn’t be there.</p>
<p>Let’s get started!</p>
<ol>
<li value="1">Before running any Cucumber tests, it’s important to ensure that your build output is up to date by running <strong class="source-inline">npm run build</strong>. Your Cucumber specs are going to run against the code built in the <strong class="source-inline">dist</strong> directory, not your source in the <strong class="source-inline">src</strong> directory.</li>
</ol>
<p class="callout-heading">Use package.json scripts to your advantage</p>
<p class="callout">You could also<a id="_idIndexMarker1493"/> modify your <strong class="source-inline">package.json</strong> scripts to invoke a build before Cucumber specs are run, or to run webpack in watch mode.</p>
<ol>
<li value="2">Create a new file named <strong class="source-inline">features/sharing.feature</strong> and enter the following text. A feature has a name and a short description, as well as a bunch of scenarios listed one after another. We’ll start with just one scenario for now:<p class="source-code">Feature: Sharing</p><p class="source-code">  A user can choose to present their session to any </p><p class="source-code">  number of other users, who observe what the </p><p class="source-code">  presenter is doing via their own browser.</p><p class="source-code">  Scenario: Observer joins a session</p><p class="source-code">    Given the presenter navigated to the application page</p><p class="source-code">    And the presenter clicked the button 'startSharing'</p><p class="source-code">    When the observer navigates to the presenter's sharing link</p><p class="source-code">    Then the observer should see a message saying 'You are now watching the session'</p></li>
</ol>
<p class="callout-heading">Gherkin syntax</p>
<p class="callout"><strong class="bold">Given</strong>, <strong class="bold">When</strong>, and <strong class="bold">Then</strong> are <a id="_idIndexMarker1494"/>analogous to the <strong class="bold">Arrange</strong>, <strong class="bold">Act</strong>, and <strong class="bold">Assert</strong> phases of your Jest tests: <em class="italic">given</em> all these things are true, <em class="italic">when</em> I perform this action, <em class="italic">then</em> I expect all these things to happen.</p>
<p class="callout">Ideally, you’d have a <a id="_idIndexMarker1495"/>single <strong class="bold">When</strong> clause in each of your scenarios.</p>
<p class="callout">You’ll notice that I’ve <a id="_idIndexMarker1496"/>written the <strong class="bold">Given</strong> clauses in past tense and the <strong class="bold">When</strong> clause in the present<a id="_idIndexMarker1497"/> tense, and the <strong class="bold">Then</strong> clause has a “should” in there.</p>
<ol>
<li value="3">Go ahead and <a id="_idIndexMarker1498"/>run the feature by typing <strong class="source-inline">npx cucumber-js</strong> at the command line. You’ll see a warning printed, as shown in the following code block. Cucumber has stopped processing at the first <strong class="source-inline">Given...</strong> statement because it can’t find the JavaScript support function that maps to it. In the warning, Cucumber has helpfully given you a starting point for the definition:<p class="source-code">? Given the presenter navigated to the application page</p><p class="source-code">   Undefined. Implement with the following snippet:</p><p class="source-code">     Given('the presenter navigated to the application page', function () {</p><p class="source-code">       // Write code here that turns the phrase above</p><p class="source-code">       // into concrete actions</p><p class="source-code">       return 'pending';</p><p class="source-code">     });</p></li>
<li>Let’s do exactly what it suggested. Create the <strong class="source-inline">features/support/sharing.steps.js</strong> file and add the following code. It defines a step definition that calls Puppeteer’s API to launch a new browser, then<a id="_idIndexMarker1499"/> open a new page, and then navigate to the URL provided. The step definition description matches up with the <strong class="bold">Given</strong> clause in our test scenario.</li>
<li>The second parameter to <strong class="bold">Given</strong> is marked with the <strong class="source-inline">async</strong> keyword. This is an addition to what Cucumber tells us in its suggested function definition. We need <strong class="source-inline">async</strong> because Puppeteer’s API calls<a id="_idIndexMarker1500"/> all return promises that we’ll need to <strong class="source-inline">await</strong>:<p class="source-code">import {</p><p class="source-code">  Given, When, Then</p><p class="source-code">} from "@cucumber/cucumber";</p><p class="source-code">import puppeteer from "puppeteer";</p><p class="source-code">const port = process.env.PORT || 3000;</p><p class="source-code">const appPage = `http://localhost:${port}/index.xhtml`;</p><p class="source-code">Given(</p><p class="source-code">  "the presenter navigated to the application page",</p><p class="source-code">  async function () {</p><p class="source-code">    const browser = await puppeteer.launch();</p><p class="source-code">    const page = await browser.newPage();</p><p class="source-code">    await page.goto(appPage);</p><p class="source-code">  }</p><p class="source-code">);</p></li>
</ol>
<p class="callout-heading">Anonymous functions, not lambda expressions</p>
<p class="callout">You may be wondering why we<a id="_idIndexMarker1501"/> are defining anonymous functions (<strong class="source-inline">async function (...) { ... }</strong>) rather than lambda expressions (<strong class="source-inline">async (...) =&gt; { ... }</strong>). It allows us to take advantage of the implicit context binding that occurs with anonymous functions. If we used lambdas, we’d need to call <strong class="source-inline">.bind(this)</strong> on them.</p>
<ol>
<li value="6">Run your <a id="_idIndexMarker1502"/>tests again. Cucumber now dictates the next clause that needs work. For this clause, <strong class="source-inline">And the presenter clicked the button 'startSharing'</strong>, we need to get access to the <strong class="source-inline">page</strong> object we just created in the previous step. The way to do this is by accessing what’s known as the <strong class="source-inline">World</strong> object, which <a id="_idIndexMarker1503"/>is the context for all the clauses in the current scenario. We must build this now. Create <a id="_idIndexMarker1504"/>the <strong class="source-inline">features/support/world.js</strong> file and add the following content. It defines two methods, <strong class="source-inline">setPage</strong> and <strong class="source-inline">getPage</strong>, which allow us to save multiple pages within the world. The ability to save multiple pages is important for this test, where we have at least two pages—the presenter page and the observer page:<p class="source-code">import {</p><p class="source-code">  setWorldConstructor</p><p class="source-code">} from "@cucumber/cucumber";</p><p class="source-code">class World {</p><p class="source-code">  constructor() {</p><p class="source-code">    this.pages = {};</p><p class="source-code">  }</p><p class="source-code">  setPage(name, page) {</p><p class="source-code">    this.pages[name] = page;</p><p class="source-code">  }</p><p class="source-code">  getPage(name) {</p><p class="source-code">    return this.pages[name];</p><p class="source-code">  }</p><p class="source-code">};</p><p class="source-code">setWorldConstructor(World);</p></li>
<li>We can now<a id="_idIndexMarker1505"/> use the <strong class="source-inline">setPage</strong> and <strong class="source-inline">getPage</strong> functions from within our step definitions. Our approach will be to call <strong class="source-inline">setPage</strong> from the first step definition—the one we wrote in <em class="italic">step 3</em>—and then use <strong class="source-inline">getPage</strong> to retrieve it in subsequent steps. Modify the first step definition now to include the call to <strong class="source-inline">setPage</strong>, as shown in the following code block:<p class="source-code">Given(</p><p class="source-code">  "the presenter navigated to the application page",</p><p class="source-code">  async function () {</p><p class="source-code">    const browser = await puppeteer.launch();</p><p class="source-code">    const page = await browser.newPage();</p><p class="source-code">    await page.goto(appPage);</p><p class="source-code">    <strong class="bold">this.setPage("presenter", page);</strong></p><p class="source-code">  }</p><p class="source-code">);</p></li>
<li>Moving on to the next step, <strong class="source-inline">the presenter clicked the button 'startSharing'</strong>, we’ll solve this by <a id="_idIndexMarker1506"/>using the <strong class="source-inline">Page.click</strong> Puppeteer <a id="_idIndexMarker1507"/>function to find a button with an ID of <strong class="source-inline">startSharing</strong>. As in the last test, we use a <strong class="source-inline">buttonId</strong> parameter so that this step definition can be used with other buttons in future scenarios:<p class="source-code">Given(</p><p class="source-code">  "the presenter clicked the button {string}",</p><p class="source-code">  async function (buttonId) {</p><p class="source-code">    await this.getPage(</p><p class="source-code">      "presenter"</p><p class="source-code">    ).click(`button#${buttonId}`);</p><p class="source-code">  }</p><p class="source-code">);</p></li>
<li>The next step, <strong class="source-inline">the observer navigates to the presenter's sharing link</strong>, is like the first step in that we want to open a new browser. The difference is that it’s for the observer, and we first need to look up the path to follow. The path is given to us through the URL that the presenter is shown once they start searching. We can look that <a id="_idIndexMarker1508"/>up using the <strong class="source-inline">Page.$eval</strong> function:<p class="source-code">When(</p><p class="source-code">  "the observer navigates to the presenter's sharing link",</p><p class="source-code">  async function () {</p><p class="source-code">    await this.getPage(</p><p class="source-code">      "presenter"</p><p class="source-code">    ).waitForSelector("a");</p><p class="source-code">    const link = await this.getPage(</p><p class="source-code">      "presenter"</p><p class="source-code">    ).$eval("a", a =&gt; a.getAttribute("href"));</p><p class="source-code">    const url = new URL(link);</p><p class="source-code">    const browser = await puppeteer.launch();</p><p class="source-code">    const page = await browser.newPage();</p><p class="source-code">    await page.goto(url);</p><p class="source-code">    this.setPage("observer", page);</p><p class="source-code">  }</p><p class="source-code">);</p></li>
</ol>
<p class="callout-heading">Step definition duplication</p>
<p class="callout">There’s some duplication building up between our step definitions. Later on, we’ll extract this commonality into its own function.</p>
<ol>
<li value="10">The final step<a id="_idIndexMarker1509"/> definition uses<a id="_idIndexMarker1510"/> the <strong class="source-inline">Page.$eval</strong> Puppeteer function again, this time to find an HTML node and then transform it into a plain JavaScript object. We then test that object using the <strong class="source-inline">expect</strong> function in the normal way. Make sure to place the listed <strong class="source-inline">import</strong> statement at the top of your file:<p class="source-code">import expect from "expect";</p><p class="source-code">...</p><p class="source-code">Then(</p><p class="source-code">  "the observer should see a message saying {string}",</p><p class="source-code">  async function (message) {</p><p class="source-code">    const pageText = await this.getPage(</p><p class="source-code">      "observer"</p><p class="source-code">    ).$eval("body", e =&gt; e.outerHTML);</p><p class="source-code">    expect(pageText).toContain(message);</p><p class="source-code">  }</p><p class="source-code">);</p></li>
<li>Run your tests <a id="_idIndexMarker1511"/>with <strong class="source-inline">npx cucumber-js</strong>. The output from your test run will look as follows. While our step definitions are complete, something is amiss:<p class="source-code">1) Scenario: Observer joins a session</p><p class="source-code">   ✖ Given the presenter navigated to the application page</p><p class="source-code">        Error: net::ERR_CONNECTION_REFUSED at http://localhost:3000/index.xhtml</p></li>
<li>Although our app has loaded, we still need to spin up the server to process our requests. To do that, add the following two functions to the <strong class="source-inline">World</strong> class in <strong class="source-inline">features/support/world.js</strong>, including the <strong class="source-inline">import</strong> statement for the app at the top of the file. The <strong class="source-inline">startServer</strong> function is equivalent to how we start the server in <strong class="source-inline">server/src/server.js</strong>. The <strong class="source-inline">closeServer</strong> function stops the server, but before it does this, it closes all Puppeteer browser instances. It’s important to do this before closing the server. That’s because the server does not kill any live websocket connections when the <strong class="source-inline">close</strong> method is called. We need<a id="_idIndexMarker1512"/> to ensure they are closed first; otherwise, the server won’t stop:</li>
</ol>
<p class="callout-heading">Starting a server from within the same project</p>
<p class="callout">We are lucky that all our code lives within the same project, so it can be started within the same process. If your code base is split over multiple projects, you may find yourself dealing with multiple processes.</p>
<p class="source-code">import { app } from "../../server/src/app";</p>
<p class="source-code">class World {</p>
<p class="source-code">  ...</p>
<p class="source-code">  startServer() {</p>
<p class="source-code">    const port = process.env.PORT || 3000;</p>
<p class="source-code">    this.server = app.listen(port);</p>
<p class="source-code">  }</p>
<p class="source-code">  closeServer() {</p>
<p class="source-code">    Object.keys(this.pages).forEach(name =&gt;</p>
<p class="source-code">      this.pages[name].browser().close()</p>
<p class="source-code">    );</p>
<p class="source-code">    this.server.close();</p>
<p class="source-code">  }</p>
<p class="source-code">}</p>
<ol>
<li value="13">Make use of these new functions with the <strong class="source-inline">Before</strong> and <strong class="source-inline">After</strong> hooks. Create a new file, <strong class="source-inline">features/support/hooks.js</strong>, and add the following code:<p class="source-code">import { Before, After } from "@cucumber/cucumber";</p><p class="source-code">Before(function() {</p><p class="source-code">  this.startServer();</p><p class="source-code">});</p><p class="source-code">After(function() {</p><p class="source-code">  this.closeServer();</p><p class="source-code">});</p></li>
<li>Run the <strong class="source-inline">npx cucumber-js</strong> command and observe the output. Your scenario should now be <a id="_idIndexMarker1513"/>passing (if it isn’t, double-check you’ve run <strong class="source-inline">npm run build</strong>):<p class="source-code"><strong class="bold">&gt; npx cucumber-js</strong></p><p class="source-code"><strong class="bold">......</strong></p><p class="source-code"><strong class="bold">1 scenario (1 passed)</strong></p><p class="source-code"><strong class="bold">4 steps (4 passed)</strong></p><p class="source-code"><strong class="bold">0m00.848s</strong></p></li>
<li>Let’s go back and tidy up that repeated code. We’ll extract a function called <strong class="source-inline">browseToPageFor</strong> and place it within our <strong class="source-inline">World</strong> class. Open <strong class="source-inline">features/support/world.js</strong> and add the following method at the bottom of the class:<p class="source-code">async browseToPageFor(role, url) {</p><p class="source-code">  const browser = await puppeteer.launch();</p><p class="source-code">  const page = await browser.newPage();</p><p class="source-code">  await page.goto(url);</p><p class="source-code">  this.setPage(role, page);</p><p class="source-code">}</p></li>
<li>Also, move the Puppeteer <strong class="source-inline">import</strong> statement across from <strong class="source-inline">features/support/sharing.steps.js</strong> into <strong class="source-inline">features/support/world.js</strong>:<p class="source-code">import puppeteer from "puppeteer";</p></li>
<li>Finally, rewrite <a id="_idIndexMarker1514"/>the two navigation steps in terms of <strong class="source-inline">browseToPageFor</strong>:<p class="source-code">Given(</p><p class="source-code">  "the presenter navigated to the application page",</p><p class="source-code">  async function () {</p><p class="source-code">    <strong class="bold">await this.browseToPageFor("presenter", appPage);</strong></p><p class="source-code">  }</p><p class="source-code">);</p><p class="source-code">When(</p><p class="source-code">  "the observer navigates to the presenter's sharing link",</p><p class="source-code">  async function () {</p><p class="source-code">    await this.getPage(</p><p class="source-code">      "presenter"</p><p class="source-code">    ).waitForSelector("a");</p><p class="source-code">    const link = await this.getPage(</p><p class="source-code">      "presenter"</p><p class="source-code">    ).$eval("a", a =&gt; a.getAttribute("href"));</p><p class="source-code">    const url = new URL(link);</p><p class="source-code">    <strong class="bold">await this.browseToPageFor("observer", url);</strong></p><p class="source-code">  }</p><p class="source-code">);</p></li>
</ol>
<p class="callout-heading">Observing within a browser and with console logging</p>
<p class="callout">The tests we’ve written run <a id="_idIndexMarker1515"/>Puppeteer<a id="_idIndexMarker1516"/> in headless mode, meaning that an actual Chrome browser window doesn’t launch. If you’d like to see that happen, you can turn headless mode off by modifying the launch commands (remember there are two in the previous step definitions) to read as follows:</p>
<p class="callout"><strong class="source-inline">const browser = await puppeteer.launch(</strong></p>
<p class="callout"><strong class="source-inline">  { headless: false }</strong></p>
<p class="callout"><strong class="source-inline">);</strong></p>
<p class="callout">If you’re using console logging to <a id="_idIndexMarker1517"/>assist in your debugging, you’ll<a id="_idIndexMarker1518"/> need to provide another parameter to dump console output to <strong class="source-inline">stdout</strong>:</p>
<p class="callout"><strong class="source-inline">const browser = await puppeteer.launch(</strong></p>
<p class="callout"><strong class="source-inline">  { dumpio: true }</strong></p>
<p class="callout"><strong class="source-inline">);</strong></p>
<p>You’ve now written a <a id="_idIndexMarker1519"/>BDD test with Cucumber and Puppeteer. Next, let’s l<a id="_idTextAnchor351"/>ook at a more advanced Cucumber scenario.</p>
<h1 id="_idParaDest-281"><a id="_idTextAnchor352"/>Using data tables to perform setup</h1>
<p>In this<a id="_idIndexMarker1520"/> section, we’ll look at a useful time-saving feature of<a id="_idIndexMarker1521"/> Cucumber: data tables. We’ll write a second scenario that, as with the previous one, will already pass given the existing implementation of Spec Logo:</p>
<ol>
<li value="1">Create a new <a id="_idIndexMarker1522"/>feature file called <strong class="source-inline">features/drawing.feature</strong> with the following content. It contains a set of instructions to draw a square using a Logo function. A small side length of <strong class="source-inline">10</strong> is used; that’s to make sure the animation finishes quickly:<p class="source-code">Feature: Drawing</p><p class="source-code">  A user can draw shapes by entering commands</p><p class="source-code">  at the prompt.</p><p class="source-code">  Scenario: Drawing functions</p><p class="source-code">    Given the user navigated to the application page</p><p class="source-code">    When the user enters the following instructions at the prompt:</p><p class="source-code">      | to drawsquare |</p><p class="source-code">      |   repeat 4 [ forward 10 right 90 ] |</p><p class="source-code">      | end |</p><p class="source-code">      | drawsquare |</p><p class="source-code">    Then these lines should have been drawn:</p><p class="source-code">      | x1 | y1 | x2 | y2 |</p><p class="source-code">      | 0  | 0  | 10 | 0  |</p><p class="source-code">      | 10 | 0  | 10 | 10 |</p><p class="source-code">      | 10 | 10 | 0  | 10 |</p><p class="source-code">      | 0  | 10 | 0  | 0  |</p></li>
<li>The first phrase does the same thing as our previous step definition, except we’ve renamed <strong class="source-inline">presenter</strong> to <strong class="source-inline">user</strong>. Being more generic makes sense in this case as the role of the presenter is no longer relevant to this test. We can use the <strong class="source-inline">World</strong> function <strong class="source-inline">browseToPageFor</strong> for this first step. In the sharing feature, we used this function together with an <strong class="source-inline">appPage</strong> constant that contained the URL to navigate to. Let’s pull that constant into <strong class="source-inline">World</strong> now. In <strong class="source-inline">features/support/world.js</strong>, add the following constant at the top of the file, above<a id="_idIndexMarker1523"/> the <strong class="source-inline">World</strong> class:<p class="source-code">const port = process.env.PORT || 3000;</p></li>
<li>Add the following method to the <strong class="source-inline">World</strong> class:<p class="source-code">appPage() {</p><p class="source-code">  return `http://localhost:${port}/index.xhtml`;</p><p class="source-code">}</p></li>
<li>In <strong class="source-inline">features/support/sharing.steps.js</strong>, remove the definitions for <strong class="source-inline">port</strong> and <strong class="source-inline">appPage</strong> and update the first step definition, as shown:<p class="source-code">Given(</p><p class="source-code">  "the presenter navigated to the application page",</p><p class="source-code">  async function () {</p><p class="source-code">    await this.browseToPageFor(</p><p class="source-code">      "presenter",</p><p class="source-code">  <strong class="bold">    this.appPage()</strong></p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">);</p></li>
<li>It’s time to create a new step definition for a user page. Open the <strong class="source-inline">features/support/drawing.steps.js</strong> file <a id="_idIndexMarker1524"/>and add the following code:<p class="source-code">import {</p><p class="source-code">  Given,</p><p class="source-code">  When,</p><p class="source-code">  Then</p><p class="source-code">} from "@cucumber/cucumber";</p><p class="source-code">import expect from "expect";</p><p class="source-code">Given("the user navigated to the application page",</p><p class="source-code">  async function () {</p><p class="source-code">    await this.browseToPageFor(</p><p class="source-code">      "user",</p><p class="source-code">      this.appPage()</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">);</p></li>
<li>Now, what about the second line, with the data table? What should our step definition look like? Well, let’s ask Cucumber. Run the <strong class="source-inline">npx cucumber-js</strong> command and have a look at the output. It gives us the starting point of our definition:<p class="source-code">1) Scenario: Drawing functions</p><p class="source-code">  ✔ Before # features/support/sharing.steps.js:5</p><p class="source-code">  ✔ Given the user navigated to the application page</p><p class="source-code">  ? When the user enters the following instructions at the prompt:</p><p class="source-code">    | to drawsquare |</p><p class="source-code">    |   repeat 4 [ forward 10 right 90 ] |</p><p class="source-code">    | end |</p><p class="source-code">    | drawsquare |</p><p class="source-code">  Undefined. Implement with the following snippet:</p><p class="source-code">  When('the user enters the following instructions at the prompt:',</p><p class="source-code">    function (dataTable) {</p><p class="source-code">      // Write code here that turns the phrase above</p><p class="source-code">      // into concrete actions</p><p class="source-code">      return 'pending';</p><p class="source-code">    }</p><p class="source-code">  );</p></li>
<li>Go ahead<a id="_idIndexMarker1525"/> and add the suggested code to <strong class="source-inline">features/supports/drawing.steps.js</strong>. If you run <strong class="source-inline">npx cucumber-js</strong> at this point, you’ll notice that Cucumber successfully notices that the step definition is pending:<p class="source-code">When(</p><p class="source-code">  "the user enters the following instructions at the prompt:",</p><p class="source-code">  function (dataTable) {</p><p class="source-code">    // Write code here that turns the phrase above</p><p class="source-code">    //into concrete actions</p><p class="source-code">    return "pending";</p><p class="source-code">  }</p><p class="source-code">);</p></li>
<li>The <strong class="source-inline">dataTable</strong> variable is a <strong class="source-inline">DataTable</strong> object with a <strong class="source-inline">raw()</strong> function that returns an array of arrays. The outer array represents each row, and the inner arrays represent the columns of each row. In the next step definition, we want to take every single line and insert it into the edit prompt. Each line should be followed by a press of the <em class="italic">Enter</em> key. Create that now:<p class="source-code">When(</p><p class="source-code">  "the user enters the following instructions at the prompt:",</p><p class="source-code">  <strong class="bold">async</strong> function (dataTable) {</p><p class="source-code">    <strong class="bold">for (let instruction of dataTable.raw()) {</strong></p><p class="source-code"><strong class="bold">      await this.getPage("user").type(</strong></p><p class="source-code"><strong class="bold">        "textarea",</strong></p><p class="source-code"><strong class="bold">        `${instruction}\n`</strong></p><p class="source-code"><strong class="bold">      );</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">  }</p><p class="source-code">);</p></li>
<li>The final step<a id="_idIndexMarker1526"/> requires us to look for line elements with the right attribute values and compare them to the values in our second data table. The following code does exactly that. Copy it out now and run your tests to ensure that it works and that the test will pass. An explanation of all the detailed points will follow:<p class="source-code">Then("these lines should have been drawn:",</p><p class="source-code">  async function(dataTable) {</p><p class="source-code">    await this.getPage("user").waitForTimeout(2000);</p><p class="source-code">    const lines = await this.getPage("user").$$eval(</p><p class="source-code">      "line",</p><p class="source-code">      lines =&gt; lines.map(line =&gt; {</p><p class="source-code">        return {</p><p class="source-code">          x1: parseFloat(line.getAttribute("x1")),</p><p class="source-code">          y1: parseFloat(line.getAttribute("y1")),</p><p class="source-code">          x2: parseFloat(line.getAttribute("x2")),</p><p class="source-code">          y2: parseFloat(line.getAttribute("y2"))</p><p class="source-code">        };</p><p class="source-code">      })</p><p class="source-code">    );</p><p class="source-code">    for (let i = 0; i &lt; lines.length; ++i) {</p><p class="source-code">      expect(lines[i].x1).toBeCloseTo(</p><p class="source-code">        parseInt(dataTable.hashes()[i].x1)</p><p class="source-code">      );</p><p class="source-code">      expect(lines[i].y1).toBeCloseTo(</p><p class="source-code">        parseInt(dataTable.hashes()[i].y1)</p><p class="source-code">      );</p><p class="source-code">      expect(lines[i].x2).toBeCloseTo(</p><p class="source-code">        parseInt(dataTable.hashes()[i].x2)</p><p class="source-code">      );</p><p class="source-code">      expect(lines[i].y2).toBeCloseTo(</p><p class="source-code">        parseInt(dataTable.hashes()[i].y2)</p><p class="source-code">      );</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">});</p></li>
</ol>
<p>That last test contained some complexity that’s worth diving into:</p>
<ul>
<li>We used <strong class="source-inline">Page.waitForTimeout</strong> to<a id="_idIndexMarker1527"/> wait for 2 seconds, which gives the system time to complete animations. Including a timeout like this is not a great practice, but it’ll work for now. We’ll look at a way of making this more specific in the next chapter.</li>
<li>The <strong class="source-inline">Page.$$eval</strong> function<a id="_idIndexMarker1528"/> is like <strong class="source-inline">Page.$eval</strong> but returns an array under the hood, and calls <strong class="source-inline">document.querySelector</strong> rather than <strong class="source-inline">document.querySelectorAll</strong>.</li>
<li>It’s important that we do all of the attribute transformation logic—moving from HTML line elements and attributes to “plain” integer values of <strong class="source-inline">x1</strong>, <strong class="source-inline">y1</strong>, and so on—within the <strong class="source-inline">transform</strong> function of <strong class="source-inline">Page.$$eval</strong>. This is because Puppeteer will <a id="_idIndexMarker1529"/>garbage collect any DOM node objects once the <strong class="source-inline">$$eval</strong> call is done.</li>
<li>Our line values need to be parsed with <strong class="source-inline">parseFloat</strong> because the <strong class="source-inline">requestAnimationFrame</strong> logic we coded doesn’t perfectly line up with the integer endpoints—they are out by very slight fractional amounts.</li>
<li>That also means we need<a id="_idIndexMarker1530"/> to use the <strong class="source-inline">toBeCloseTo</strong> Jest matcher rather than <strong class="source-inline">toBe</strong>, which we need because of the fractional value difference described previously.</li>
<li>Finally, we use the <strong class="source-inline">DataTable</strong> <strong class="source-inline">hashes()</strong> function here to pull out an array of objects that has a key for each of the columns in the data table, based on the header row that we provided in the feature definition. So, for example, we can call <strong class="source-inline">hashes()[0].x1</strong> to pull out the value in the <strong class="source-inline">x1</strong> column for the first row.</li>
</ul>
<p>Go ahead and run your tests again with <strong class="source-inline">npx cucumber-js</strong>. Everything should be passing.</p>
<p>You’ve now got a good understanding of using Cuc<a id="_idTextAnchor353"/>umber data tables to make more compelling <a id="_idIndexMarker1531"/>BDD tests.</p>
<h1 id="_idParaDest-282"><a id="_idTextAnchor354"/>Summary</h1>
<p>Cucumber tests (and BDD tests in general) are similar to the unit tests we’ve been writing in the rest of the book. They are focused on specifying <em class="italic">examples</em> of behavior. They should make use of real data and numbers as means to test a general concept, like we’ve done in the two examples in this chapter.</p>
<p>BDD tests differ from unit tests in that they are system tests (having a much broader test surface area) and they are written in natural language.</p>
<p>Just as with unit tests, it’s important to find ways to simplify the code when writing BDD tests. The number one rule is to try to write generic <strong class="bold">Given</strong>, <strong class="bold">When</strong>, and <strong class="bold">Then</strong> phrases that can be reused across classes and extracted out of step definition files, either into the <strong class="source-inline">World</strong> class or some other module. We’ve seen an example of how to do that in this chapter.</p>
<p>In the next chapter, we’ll use a BDD test to drive the implementation of a new feature in Spec Logo.</p>
</div>
<div>
<div id="_idContainer054">
</div>
</div>
</div></body></html>