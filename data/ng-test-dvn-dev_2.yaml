- en: Chapter 2. Details of JavaScript Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。JavaScript测试的细节
- en: Practicing TDD is a great way to get good quality software with satisfactory
    accuracy, even with fewer people. For web applications, JavaScript has become
    the most popular scripting language and it has become a challenge to test JavaScript
    code. Browser-based testing is actually a time killer and is difficult to follow
    for TDD, but then the solution to this comes with some cool tools that support
    automated testing for JavaScript. Most web application projects were limited to
    unit tests only, and without automated test tools, end-to-end tests or functional
    tests were almost impossible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的实践是获得高质量软件和令人满意的准确性的好方法，即使人手较少。对于Web应用程序，JavaScript已经成为最流行的脚本语言，测试JavaScript代码已经成为一个挑战。基于浏览器的测试实际上是一种浪费时间的做法，对于TDD来说很难跟进，但是解决这个问题的方法是使用一些支持JavaScript自动化测试的很酷的工具。大多数Web应用项目仅限于单元测试，没有自动化测试工具，端到端测试或功能测试几乎是不可能的。
- en: A lot of tools and frameworks focusing on JavaScript testing are coming out,
    which serve different solutions, making developers' lives easy. Besides inventing
    new JavaScript frameworks, the developer's community invented some tool sets to
    make testing easy. Like the Angular team, they come with cool tools like **Karma**.
    We also have the duplication of testing frameworks or tools, where both solve
    similar problems but in different ways. Which tools or frameworks to choose is
    up to the developer; they have to choose the tool that suits their requirements
    best.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多专注于JavaScript测试的工具和框架正在涌现，它们提供不同的解决方案，使开发人员的生活变得更加轻松。除了发明新的JavaScript框架，开发人员社区还发明了一些工具集，以使测试变得更加容易。就像Angular团队一样，他们提供了像**Karma**这样的很酷的工具。我们还有测试框架或工具的重复，它们都以不同的方式解决了类似的问题。选择哪种工具或框架取决于开发人员；他们必须选择最适合他们要求的工具。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: A brief about automated testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试的简要介绍
- en: Different types of testing focused on JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于JavaScript的不同类型的测试
- en: A brief idea about some testing tools and frameworks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些测试工具和框架的简要概念
- en: The craft of JavaScript testing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript测试的技艺
- en: We all know that JavaScript is a dynamically typed, interpreted language. Therefore,
    there are no compilation steps that help you figure out errors, unlike other compiled
    languages similar to Java. So, a JavaScript developer should allocate more time
    to test code. However, life is easier now, as a developer can cover testing with
    minimal steps and time using the latest tool techniques. It's a part of an automated
    test, where the code will be automatically tested whenever it changes. In that
    process, a test could be a task running in the background, which could be integrated
    into the IDE or the CLI, and it will provide the test result during development.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道JavaScript是一种动态类型的解释语言。因此，与Java等编译语言不同，没有编译步骤可以帮助您找出错误。因此，JavaScript开发人员应该花更多的时间来测试代码。然而，现在生活变得更加容易，开发人员可以使用最新的工具技术在最少的步骤和时间内进行测试。这是自动化测试的一部分，代码在更改时将自动进行测试。在这个过程中，测试可能是在后台运行的任务，可以集成到IDE或CLI中，并且在开发过程中提供测试结果。
- en: In the subsequent sections, we will discuss how to automate the test process
    in multiple browsers with a test runner and a headless browser.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论如何使用测试运行器和无头浏览器在多个浏览器中自动化测试过程。
- en: Automated testing
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化测试
- en: Testing is fun, and writing a test will make the code better; it's a good practice,
    but the procedural manual testing is a bit time consuming, error prone, and irreproducible.
    In this process, there is a need to write the test spec, change the code to pass
    the test, refresh the browser to get the result, and repeat this process several
    times. As a programmer, it's kind of boring to repeat the same things.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 测试很有趣，编写测试会使代码更好；这是一个很好的实践，但是过程化的手动测试有点耗时、容易出错，并且不可重复。在这个过程中，需要编写测试规范，更改代码以通过测试，刷新浏览器以获取结果，并重复这个过程多次。作为程序员，重复相同的事情有点无聊。
- en: Apart from being monotonous, it also slows down the development process a lot,
    which demotivates developers from practicing TDD. So, when the manual process
    slows down progress, we have to look for some automated process to do the job
    and save time for other tasks that could add more business value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单调乏味之外，它也大大减慢了开发过程，这让开发人员对TDD的实践失去了动力。因此，当手动过程减慢进度时，我们必须寻找一些自动化的过程来完成工作，并为其他可能增加更多业务价值的任务节省时间。
- en: So, it would be great to have some tools or techniques that can help programmers
    get rid of these repetitive and boring manual steps that slow down the process
    and get things done automatically, faster, and save time to make them more valuable
    for the business. Fortunately, there are some tools to automate these tests. We
    will cover more about those tools and techniques, but not in this section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，拥有一些工具或技术可以帮助程序员摆脱这些重复乏味的手动步骤，这些步骤减慢了过程，并自动完成任务，更快地完成任务，并节省时间，使它们对业务更有价值，这将是很棒的。幸运的是，有一些工具可以自动化这些测试。我们将在其他章节中更多地介绍这些工具和技术。
- en: Besides the issue of slowing down the development process, another important
    point comes in view when we talk about the testing features, and that is the cross-browser
    compatibility issue. As web applications should run perfectly on modern platforms
    and browsers, and it's almost impossible to test them one-by-one manually, automated
    testing could be the solution with a web driver and headless browser.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了减慢开发过程的问题之外，当我们谈论测试功能时，另一个重要的问题出现了，那就是跨浏览器兼容性问题。由于Web应用程序应该在现代平台和浏览器上完美运行，而逐个手动测试几乎是不可能的，自动化测试可能是一个解决方案，使用Web驱动程序和无头浏览器。
- en: Let's recap the basic test flow that we explained in the previous chapter--test
    it, make it run, and make it better. To make this process automatic, a developer
    can implement the tool set in the CLI or even in the development IDE, and these
    tests will run continuously in a separate process without any input from the developer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在上一章中解释的基本测试流程--测试它，使其运行，并使其更好。为了使这个过程自动化，开发人员可以在CLI甚至开发IDE中实现工具集，并且这些测试将在一个单独的进程中持续运行，而不需要开发人员的任何输入。
- en: Let's think of a registering or signing up feature for any application, where
    we have to manually fill up the form and click on the submit button every time
    we want to test the feature and repeat the process by changing the data. This
    is actually known as a functional test (which we will discuss at the end of this
    chapter). To perform these processes automatically, we will use the tool set (the
    test runner, web driver, and headless browser) in the CLI and complete the process
    with a single command with some parameters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下任何应用程序的注册或注册功能，我们必须手动填写表单并每次点击提交按钮以测试该功能，并通过更改数据重复该过程。这实际上被称为功能测试（我们将在本章末讨论）。为了自动执行这些过程，我们将在CLI中使用工具集（测试运行器、Web驱动程序和无头浏览器），并使用一条命令和一些参数完成整个过程。
- en: Testing JavaScript in automated testing is not a new concept, indeed, it is
    the most commonly used automated browser. Selenium was invented for this in 2004,
    and after that, a lot of tools have emerged, including PhantomJS, Karma, Protractor,
    and CasperJS. In this chapter, we will discuss some of them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化测试中测试JavaScript并不是一个新概念，实际上，它是最常用的自动化浏览器。Selenium是在2004年为此而发明的，之后出现了许多工具，包括PhantomJS、Karma、Protractor和CasperJS。在本章中，我们将讨论其中一些。
- en: Types of testing
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的类型
- en: 'In TDD, developers have to follow a flow to fulfill the goal of the test. On
    this flow, every step has an individual goal of testing. For example, some tests
    are written just to test the behavior of each function in several ways and some
    are for testing the flow of a module/feature. Based on that, we will discuss two
    major types of testing here. They are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD中，开发人员必须遵循一种流程来实现测试的目标。在这个流程中，每一步都有一个独立的测试目标。例如，有些测试仅用于测试每个函数的行为，而有些用于测试模块/功能的流程。基于此，我们将在这里讨论两种主要类型的测试。它们如下：
- en: '**Unit testing**: This is mostly used for behavior tests.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这主要用于行为测试。'
- en: '**End-to-end testing**: This is mostly known as e2e testing and is used for
    functional tests.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：这主要被称为e2e测试，用于功能测试。'
- en: Unit testing
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: '**Unit testing** is a software development process, where the smallest testable
    part of any application is individually called a unit, and the behavior of that
    small part should be testable in isolation, without any dependency on the other
    parts. If we think of a JavaScript application as software, then every individual
    method/function of that application which has a specific behavior will be a unit
    of code. The behavior of these methods or units of code should be testable in
    an isolated way.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是一种软件开发过程，其中应用程序的最小可测试部分被单独称为一个单元，并且该小部分的行为应该能够在隔离的情况下进行测试，而不依赖于其他部分。如果我们将JavaScript应用程序视为软件，那么该应用程序的每个单独的方法/函数都将是代码的一个单元，这些方法或代码单元的行为应该能够以隔离的方式进行测试。'
- en: An important point about unit testing is that any unit of code should run/be
    testable in isolation and should run in any order, which means that if unit testing
    runs successfully in any application, it represents the isolation of the components
    or modules of that application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关于单元测试的一个重要观点是，任何代码单元都应该能够在隔离的情况下运行/进行测试，并且可以以任何顺序运行，这意味着如果单元测试在任何应用程序中成功运行，它代表了该应用程序的组件或模块的隔离。
- en: For example, we had already shown a small test example in the previous chapter
    about how to get a method tested; though we showed that without using any test
    framework, the idea is the same. We called the method by passing some parameters,
    got a result of that method, and then we compared the result with the expected
    value.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们在上一章中已经展示了一个小的测试示例，演示了如何进行方法测试；尽管我们没有使用任何测试框架，但这个想法是一样的。我们通过传递一些参数来调用方法，得到了该方法的结果，然后将结果与预期值进行比较。
- en: Typically, we will write such tests using a unit testing framework of our choice.
    There are many testing frameworks and tools now, and we have to decide and pick
    the best one based on our requirements. The most commonly used frameworks are
    Jasmine, Mocha, and QUnit. We will discuss these tools in depth in this chapter
    and real-life examples will be covered in the subsequent chapters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将使用我们选择的单元测试框架编写这些测试。现在有许多测试框架和工具，我们必须根据我们的需求决定并选择最好的一个。最常用的框架是Jasmine、Mocha和QUnit。我们将在本章深入讨论这些工具，并在随后的章节中涵盖真实的例子。
- en: Tests should run fast and be automated with a clear output. For example, you
    can verify that if a function is called with particular arguments, it should return
    an expected result.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该快速运行并且自动化，并且具有清晰的输出。例如，您可以验证如果使用特定参数调用函数，它应该返回预期的结果。
- en: 'Unit testing can run the test anytime, such as in the following instances:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以随时运行测试，例如在以下情况下：
- en: From the very beginning of the development process, even with a failing test
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从开发过程的最开始，即使测试失败
- en: After completing the development of any feature to verify that the behavior
    is correct
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成任何功能的开发后，验证行为是否正确
- en: After modifying any existing feature to verify that the behavior hasn't changed
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改任何现有功能后，以验证行为是否发生了变化
- en: After adding a new feature in the existing application, we need to verify that
    the new feature is isolated and it's not breaking any other feature
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有应用程序中添加新功能后，我们需要验证新功能是否被隔离，并且没有破坏任何其他功能
- en: End-to-end testing
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端到端测试
- en: End-to-end testing is a methodology used to test whether the flow of an application
    is performing as designed from start to finish. For example, if a user clicks
    on a product from a product list, it should prompt the modal to display detailed
    information of the selected product. In this case, the product/project owner will
    define the project requirements step by step in the specification. The project
    will be tested based on the specification's workflow after the development process.
    This is called the function/flow test and is another name for an end-to-end test.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试是一种用于测试应用程序流程是否按照设计进行的方法。例如，如果用户从产品列表中点击一个产品，它应该提示模态框显示所选产品的详细信息。在这种情况下，产品/项目所有者将根据规范逐步定义项目要求。在开发过程之后，将根据规范的工作流程对项目进行测试。这被称为功能/流程测试，也是端到端测试的另一个名称。
- en: Besides unit testing, end-to-end testing is important for confirming that individual
    components are working together as an application, passing information, and communicating
    among them. The main difference with unit testing is that it does not test any
    components in isolation; instead, it is a combined test of the flow with all the
    dependent components together.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单元测试之外，端到端测试对于确认各个组件作为一个应用程序一起工作，传递信息并相互通信非常重要。与单元测试的主要区别在于它不会单独测试任何组件；相反，它是对所有相关组件一起进行流程的综合测试。
- en: Consider a registration module where users should provide some valid information
    to complete the registration, and the function/flow test for that module/application
    should follow some steps to complete the testing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个注册模块，用户应该提供一些有效信息来完成注册，该模块/应用程序的功能/流程测试应该遵循一些步骤来完成测试。
- en: 'The steps are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: Load/compile the form
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载/编译表单
- en: Get the DOM of the form's elements
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取表单元素的DOM
- en: Trigger the click event of the submit button
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发提交按钮的点击事件
- en: Collect the value from the input fields for validation
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入字段中收集值以进行验证
- en: Validate the input fields
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证输入字段
- en: Call the fake API to store data
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用虚拟API来存储数据
- en: In every step, there will be some result which will be compared to the expected
    result set.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步中，都会有一些结果与预期结果集进行比较。
- en: These kinds of functional/flow tests can be tested manually by a person filling
    out the forms by clicking on the buttons for the next steps, completing the application
    flow, and comparing the result with the specification that is defined earlier
    in the implementation process.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的功能/流程测试可以通过人工填写表单，点击下一步按钮，完成应用程序流程，并将结果与在实施过程中早期定义的规范进行比较来进行手动测试。
- en: However, there are some techniques available to do this functional/flow testing
    in an automated way without getting input from any person, which is known as end-to-end
    testing. To make this test process easier, there are a few tools available; the
    ones used most commonly are Selenium, PhantomJS, and Protractor. These tools can
    easily integrate with any application test system. In this chapter, we will discuss
    these test tools in a bit more detail, and in the subsequent chapters, we will
    integrate these in an application's test suite.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些技术可用于以自动化方式进行功能/流测试，而无需从任何人那里获取输入，这被称为端到端测试。为了使这个测试过程更容易，有一些工具可用；最常用的是
    Selenium、PhantomJS 和 Protractor。这些工具可以轻松集成到任何应用程序测试系统中。在本章中，我们将稍微详细地讨论这些测试工具，并在随后的章节中将它们集成到应用程序的测试套件中。
- en: Testing tools and frameworks
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试工具和框架
- en: 'Knowing what the different testing tools are is half the battle. A few of them
    are very important to know in depth for Angular testing; we will learn them in
    detail throughout this book. However, in this section, we will learn about some
    well-known tools and frameworks that are used in different web applications for
    various kinds of testing and approaches. They are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 了解不同的测试工具是一大挑战。对于 Angular 测试来说，其中一些非常重要，我们将在本书中详细学习它们。然而，在本节中，我们将学习一些在不同 Web
    应用程序中用于各种测试和方法的知名工具和框架。它们如下：
- en: '**Karma**: This is the test runner for JavaScript'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Karma**：这是 JavaScript 的测试运行器'
- en: '**Protractor**: This is the end-to-end testing framework'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Protractor**：这是端到端测试框架'
- en: '**Jasmine**: This refers to the behavior-driven JavaScript testing framework'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jasmine**：这是行为驱动的 JavaScript 测试框架'
- en: '**Mocha**: This is the JavaScript testing framework'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mocha**：这是 JavaScript 测试框架'
- en: '**QUnit**: This stands for the unit testing framework'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QUnit**：这代表单元测试框架'
- en: '**Selenium**: This is the tool that automates the web browsers'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Selenium**：这是自动化 Web 浏览器的工具'
- en: '**PhantomJS**: This is the headless webkit browser'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PhantomJS**：这是无头 Webkit 浏览器'
- en: Karma
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Karma
- en: 'Before discussing what Karma is, it is best to discuss what it isn''t. It isn''t
    a framework to write tests; it is a test runner. What this means is that Karma
    gives us the ability to run tests in several different browsers in an automated
    way. In the past, developers had to perform manual steps to do this, including
    the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 Karma 是什么之前，最好先讨论它不是什么。它不是一个编写测试的框架；它是一个测试运行器。这意味着 Karma 赋予我们能力以自动化方式在多个不同的浏览器中运行测试。过去，开发人员必须手动执行以下步骤：
- en: Opening up a browser
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开浏览器
- en: Pointing the browser to the project URL
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将浏览器指向项目 URL
- en: Running the tests
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试
- en: Confirming that all the tests have passed
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认所有测试都已通过
- en: Making changes
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行更改
- en: Refreshing the page
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新页面
- en: With Karma, automation gives a developer the ability to run a single command
    and determine whether an entire test suite has passed or failed. From a TDD perspective,
    this gives us the ability to find and fix failing tests quickly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Karma，自动化使开发人员能够运行单个命令并确定整个测试套件是否通过或失败。从 TDD 的角度来看，这使我们能够快速找到并修复失败的测试。
- en: 'Some of the pros of using Karma as compared to a manual process are as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与手动流程相比，使用 Karma 的一些优点如下：
- en: Ability to automate tests in multiple browsers and devices
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个浏览器和设备中自动化测试的能力
- en: Ability to watch files
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视文件的能力
- en: Online documentation and support
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线文档和支持
- en: Does one thing--running JavaScript tests--and does it well
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只做一件事——运行 JavaScript 测试——并且做得很好
- en: Makes it easy to integrate with a continuous integration server
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使其易于与持续集成服务器集成
- en: 'Disadvantage of using Karma:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Karma 的缺点：
- en: Requires an additional tool to learn, configure, and maintain
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要学习、配置和维护额外的工具
- en: Automating the process of testing and using Karma is extremely advantageous.
    In the TDD journey through this book, Karma will be one of our primary tools.
    We will learn about Karma in detail in [Chapter 3](ch03.html "Chapter 3. The Karma
    Way"), *The Karma Way*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试和使用Karma的过程非常有利。在本书的TDD旅程中，Karma将是我们的主要工具之一。我们将在[第3章](ch03.html "第3章。Karma方式")
    *Karma方式*中详细了解Karma。
- en: Protractor
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Protractor
- en: Protractor is an end-to-end testing tool that allows developers to mimic user
    interactions. It automates the testing of functionality and features through the
    interaction of a web browser. Protractor has specific methods to assist in the
    testing of Angular, but they are not exclusive to Angular.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor是一种端到端测试工具，允许开发人员模拟用户交互。它通过与Web浏览器的交互自动化功能和特性的测试。Protractor具有特定的方法来帮助测试Angular，但它们并不专属于Angular。
- en: 'Some of the pros of using Protractor are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Protractor的一些优点如下：
- en: Configurable to test multiple environments
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可配置以测试多个环境
- en: Easy integration with Angular
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Angular轻松集成
- en: Syntax and testing can be similar to the testing framework chosen for unit testing
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法和测试可以与选择的单元测试框架类似
- en: 'Disadvantage of using Protractor:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Protractor的缺点：
- en: Its documentation and examples are limited
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的文档和示例有限
- en: For end-to-end testing of the examples in this book, Protractor will be our
    main framework. Protractor will be further introduced in detail in [Chapter 4](ch04.html
    "Chapter 4. End-to-End Testing with Protractor"), *End-to-End Testing with Protractor*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的示例的端到端测试，Protractor将是我们的主要框架。Protractor将在[第4章](ch04.html "第4章。使用Protractor进行端到端测试")
    *使用Protractor进行端到端测试*中进一步详细介绍。
- en: Jasmine
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 茉莉花
- en: Jasmine is a behavior-driven development framework for testing JavaScript code.
    It can be easily integrated and run for websites and is agnostic to Angular. It
    provides spies and other features. It can also be run on its own without Karma.
    In this chapter, we will learn details of the commonly used built-in global functions
    of Jasmine and will see how the Jasmine test suite serves the testing requirements
    for a web application. Also, throughout this book, we will use Jasmine as our
    testing framework.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine是一个用于测试JavaScript代码的行为驱动开发框架。它可以轻松集成和运行网站，并且与Angular无关。它提供间谍和其他功能。它也可以在没有Karma的情况下运行。在本章中，我们将学习Jasmine常用的内置全局函数的详细信息，并了解Jasmine测试套件如何满足Web应用程序的测试要求。此外，在整本书中，我们将使用Jasmine作为我们的测试框架。
- en: 'Some of the pros of using Jasmine are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jasmine的一些优点如下：
- en: Default integration with Karma
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Karma的默认集成
- en: Provides additional functions to assist with testing, such as test spies, fakes,
    and the pass-through functionality
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供额外的功能来辅助测试，如测试间谍、伪造和传递功能
- en: Cleans readable syntax that allows tests to be formatted in a way that relates
    to the behavior being tested
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰易读的语法，允许测试以与被测试行为相关的方式格式化
- en: Integration with several output reporters
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与多个输出报告器集成
- en: 'The following are some cons of using Jasmine:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Jasmine的一些缺点：
- en: No file-watching feature is available when running tests. This means that tests
    have to be rerun by the user as they change.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试时没有文件监视功能。这意味着测试必须在用户更改时重新运行。
- en: The learning curve can be steep for all the Protractor methods and features.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有Protractor方法和功能的学习曲线可能会很陡峭。
- en: Mocha
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摩卡
- en: Mocha is a testing framework originally written for Node.js applications, but
    it supports browser testing as well. It is very similar to Jasmine and mirrors
    much of its syntax. The main difference with Mocha is that it can't run standalone
    as a test framework--it needs some plugin and library to run as a test framework,
    while Jasmine is standalone. It's more configurable and flexible to use.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha是最初为Node.js应用程序编写的测试框架，但它也支持浏览器测试。它与Jasmine非常相似，并且大部分语法都是相似的。Mocha的主要区别在于它不能作为一个独立的测试框架运行--它需要一些插件和库来作为一个测试框架运行，而Jasmine是独立的。它更具可配置性和灵活性。
- en: 'Let''s discuss some of the pros of Mocha:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些Mocha的优点：
- en: Easy to install
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易安装
- en: Good documentation available
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有良好的文档可用
- en: Has several reporters
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有几个报告者
- en: Plugs in with several node projects
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与几个node项目插件相匹配
- en: 'Here are a few cons:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些缺点：
- en: Separate plugins/modules are required for assertions, spies, and so on
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要单独的插件/模块来进行断言、间谍等
- en: Additional configuration required to use it with Karma
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要额外的配置才能与Karma一起使用
- en: QUnit
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: QUnit
- en: QUnit is a powerful, easy-to-use JavaScript unit test suite. It's used by jQuery
    and the jQuery UI and jQuery Mobile projects and is capable of testing any generic
    JavaScript code. QUnit focuses on testing JavaScript in the browser, while providing
    as much convenience to the developer as possible.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: QUnit是一个强大、易于使用的JavaScript单元测试套件。它被jQuery、jQuery UI和jQuery Mobile项目使用，并且能够测试任何通用的JavaScript代码。QUnit专注于在浏览器中测试JavaScript，同时尽可能为开发人员提供便利。
- en: 'Some of the pros of QUnit:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: QUnit的一些优点：
- en: Easy to install
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易安装
- en: Good documentation available
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有良好的文档可用
- en: 'Here is a con of using QUnit:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用QUnit的一个缺点是：
- en: Mostly developed for jQuery, not good for use with other frameworks
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要为jQuery开发，不适合与其他框架一起使用
- en: Selenium
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenium
- en: 'Selenium ([http://www.seleniumhq.org/](http://www.seleniumhq.org/)) defines
    itself as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium（[http://www.seleniumhq.org/](http://www.seleniumhq.org/)）自我定义如下：
- en: '*"Selenium automates browsers. That''s it!"*'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"Selenium自动化浏览器。就是这样！"*'
- en: Automation of browsers means that developers can interact with browsers easily.
    They can click on buttons or links, enter data, and so on. Selenium is a powerful
    toolset that, when used and set up properly, has lots of benefits; however, it
    can be confusing and cumbersome to set it up.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器的自动化意味着开发人员可以轻松地与浏览器交互。他们可以点击按钮或链接，输入数据等。Selenium是一个强大的工具集，当正确使用和设置时，有很多好处；然而，设置它可能会令人困惑和繁琐。
- en: 'Some of the pros of Selenium are as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium的一些优点如下：
- en: Large feature set
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量功能集
- en: Distributed testing
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式测试
- en: SaaS support through services such as **Sauce Labs** ([https://saucelabs.com/](https://saucelabs.com/))
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过服务如**Sauce Labs**（[https://saucelabs.com/](https://saucelabs.com/)）支持SaaS
- en: Documentation and resources available
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有文档和资源可用
- en: 'Here are some cons of Selenium:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Selenium的一些缺点：
- en: Has to be run as a separate process
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须作为一个单独的进程运行
- en: Several steps to configure
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要几个步骤来配置
- en: As Protractor is a wrapper around Selenium, it won't be discussed in detail.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Protractor是Selenium的一个包装器，因此不会详细讨论。
- en: PhantomJS
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PhantomJS
- en: PhantomJS is a headless WebKit scriptable with a JavaScript API. It has *fast*
    and *native* support for various web standards; DOM handling, CSS selector, JSON,
    Canvas, and SVG. PhantomJS is used in the test workflow.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: PhantomJS是一个可编写JavaScript API的无头WebKit脚本。它对各种Web标准有*快速*和*本地*支持；DOM处理、CSS选择器、JSON、Canvas和SVG。PhantomJS用于测试工作流程。
- en: Simply put, PhantomJS is a browser that runs headlessly (that is, doesn't draw
    out the screen). The benefits that it brings are speed--if you're controlling
    an actual program on your computer, you've a certain overhead in booting up the
    browser, configuring a profile, and so on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，PhantomJS是一个无头运行的浏览器（即不会显示屏幕）。它带来的好处是速度--如果你在计算机上控制一个实际的程序，你会有一定的开销来启动浏览器，配置配置文件等。
- en: PhantomJS is not meant to replace a testing framework; it will work in conjunction
    with one.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: PhantomJS并不意味着取代测试框架；它将与测试框架一起使用。
- en: The choice is ours
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择权在我们手中
- en: 'As we have seen, there are a lot of toolsets and frameworks for testing JavaScript
    projects:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，有许多用于测试JavaScript项目的工具集和框架：
- en: For the assertion framework, we will go with Jasmine as Angular itself uses
    Jasmine as assertions; but in some cases, mostly for Node.js projects, Mocha is
    fun as well
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于断言框架，我们将选择Jasmine，因为Angular本身使用Jasmine作为断言；但在某些情况下，主要是对于Node.js项目，Mocha也很有趣
- en: As long as we focus on the automated test suite, the test runner is of most
    importance to us, and nothing can be compared to Karma when it's about an Angular
    project
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要我们专注于自动化测试套件，测试运行器对我们来说至关重要，当涉及到Angular项目时，没有什么可以与Karma相提并论
- en: For end-to-end testing, Protractor is the best framework, and we will use that
    in this chapter.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于端到端测试，Protractor是最好的框架，我们将在本章中使用它。
- en: As long as it's end-to-end testing, it must be automated, and Selenium is here
    to automate the browser for us.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要是端到端测试，它必须是自动化的，而Selenium就在这里为我们自动化浏览器。
- en: It's important to run tests as cross-browser support, and PhantomJS is here
    for us to serve as a headless browser.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是要进行跨浏览器支持的测试，并且PhantomJS在这里为我们提供无头浏览器。
- en: Say hello to Jasmine test suite
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Jasmine测试套件打招呼
- en: As long as we have to use a testing framework to build a test suite, there are
    some basic and common assertions on all frameworks. It's important to understand
    those assertions and spies and when to use them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们必须使用测试框架来构建测试套件，所有框架上都有一些基本和常见的断言。重要的是要理解这些断言和间谍以及何时使用它们。
- en: In this section we will explain the assertions and spies from Jasmine, as Jasmine
    will be our testing framework throughout the book.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释Jasmine的断言和间谍，因为Jasmine将是本书中的测试框架。
- en: Suites
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 套件
- en: Any test suite begins with a global Jasmine `describe` function, which receives
    two parameters. The first one is a string and the second one is a function. The
    string is the suite name/title, and the function is for the code block that will
    be implemented in the suite.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 任何测试套件都以全局的Jasmine `describe`函数开始，该函数接收两个参数。第一个是字符串，第二个是函数。字符串是套件名称/标题，函数是将在套件中实现的代码块。
- en: 'Consider the following example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子：
- en: '[PRE0]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Spec
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规范
- en: 'Any spec defined with Jasmine''s global `it` function, similar to the suite''s
    that receives two params, involves the first one being a string and the second
    one being a function. The string is the spec name/title and the function is for
    the code block that will be implemented in the spec. Take a look at the following
    example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用Jasmine的全局`it`函数定义的规范，类似于接收两个参数的套件，第一个是字符串，第二个是函数。字符串是规范名称/标题，函数是规范中将要实现的代码块。看看以下例子：
- en: '[PRE1]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Expectation
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 期望
- en: Any expectation defined with an `expect` function, which receives one param
    value that is called actual. This function is a chain with the matcher function,
    which takes an expected value as a parameter to match with the actual value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用`expect`函数定义的期望，该函数接收一个称为实际的参数值。该函数是一个与匹配器函数链接的链，该匹配器函数以预期值作为参数与实际值进行匹配。
- en: There are a few commonly used matchers; all of them implement a Boolean comparison
    between the actual value and the expected value. Any matcher can evaluate a negative
    value by chaining the `expect` method with a `not` keyword.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些常用的匹配器；它们都在实际值和预期值之间实现布尔比较。通过将`expect`方法与`not`关键字链接，任何匹配器都可以评估负值。
- en: Some common matchers are `toBe`, `toEqual`, `toMatch`, `toBeNull`, `toBeDefined`,
    `toBeUndefined`, and `toContain`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的匹配器包括`toBe`，`toEqual`，`toMatch`，`toBeNull`，`toBeDefined`，`toBeUndefined`和`toContain`。
- en: 'Consider the given example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑给定的例子：
- en: '[PRE2]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Setup and teardown
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和拆卸
- en: To improve the test suite by DRY (Don't repeat yourself) up duplicated setup
    and teardown code, Jasmine provides some global functions for the setup and teardown.
    Those global functions (`beforeEach`, `afterEach`, and so on) are as follows and
    they run as the name implies.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过DRY（不要重复自己）来改进测试套件，消除重复的设置和拆卸代码，Jasmine提供了一些全局函数用于设置和拆卸。这些全局函数（`beforeEach`，`afterEach`等）如下所示，并且它们按照名称的意思运行。
- en: Every function runs against a test spec. Jasmine's global setup and the teardown
    functions are `beforeEach`, `afterEach`, `beforeAll`, and `afterAll`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都针对一个测试规范运行。Jasmine的全局设置和拆卸函数是`beforeEach`，`afterEach`，`beforeAll`和`afterAll`。
- en: 'Consider the following example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE3]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Spies
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 间谍
- en: Spies are test double functions in Jasmine; they can stub any function and track
    calls on it and to all its arguments. There are a few matchers around to track
    if any spy has been called or not. These are `toHaveBeenCalled`, `toHaveBeenCalledTimes`,
    and so on.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍是Jasmine中的测试双函数；它们可以替换任何函数并跟踪对它及其所有参数的调用。有一些匹配器可以跟踪间谍是否被调用。这些是`toHaveBeenCalled`，`toHaveBeenCalledTimes`等。
- en: There are some useful chained methods used with spy, such as `returnValue`/
    `returnValues`, which will return one or more values when called by chaining with
    spy. There are a few more similar useful methods, such as `callThrough`, `call`,
    `stub`, `call.allArgs`, `call.first`, and `call.reset`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些与间谍一起使用的有用的链式方法，比如`returnValue`/`returnValues`，它们将在调用时返回一个或多个值。还有一些类似的有用方法，比如`callThrough`，`call`，`stub`，`call.allArgs`，`call.first`和`call.reset`。
- en: 'Consider the following example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE4]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The test suite of Jasmine
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jasmine的测试套件
- en: In the preceding section, we looked over some commonly used assertions that
    all test frameworks, including Jasmine, use in any kind of test suite.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们查看了一些常用的断言，所有测试框架，包括Jasmine，在任何类型的测试套件中都会使用。
- en: Though in this book, we will build an automated test suite for Angular testing,
    let's try some assertion in a Jasmine test suite and see how it works. This sample
    test suite will give us some hands on experience of how the assertions work on
    a test suite.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在本书中，我们将为Angular测试构建一个自动化测试套件，让我们在Jasmine测试套件中尝试一些断言，并看看它是如何工作的。这个示例测试套件将让我们亲身体验断言在测试套件中的工作方式。
- en: 'For this test suite, we will use Jasmine''s sample spec runner project (which
    is available in the Jasmine downloaded bundle in the example), and the project''s
    folder structure will look as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试套件，我们将使用Jasmine的示例规范运行器项目（该项目在Jasmine下载包中可用），项目的文件夹结构将如下所示：
- en: '![The test suite of Jasmine](graphics/image_02_001.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine的测试套件](graphics/image_02_001.jpg)'
- en: 'Let''s take a quick look at the files that we have to update in the Jasmine''s
    sample `SpecRunner` project:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下我们需要在Jasmine的示例`SpecRunner`项目中更新的文件：
- en: '[PRE5]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As long as it''s a browser-based test suite, we have to point `SpecRunner.html` to
    a web browser to get the test result. We will have all the tests passed and our
    test result will look as shown in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 只要它是基于浏览器的测试套件，我们就必须将`SpecRunner.html`指向一个web浏览器以获取测试结果。我们将通过所有测试，并且我们的测试结果将如下截图所示：
- en: '![The test suite of Jasmine](graphics/image_02_002-1.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine的测试套件](graphics/image_02_002-1.jpg)'
- en: The Jasmine test suite for Angular
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular的Jasmine测试套件
- en: In the preceding example, we saw a Jasmine test suite for JavaScript testing,
    but what about for Angular, how should that look? Actually, there is no direct
    answer as, for the Angular project test suite, we will not use a browser-based
    test suite; we have a test runner with Karma for the test suite. But as we are
    familiar with the browser-based Jasmine test suite in the preceding example, let's
    see what that will look like if we make a similar one for the Angular project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了用于JavaScript测试的Jasmine测试套件，但是对于Angular，应该如何呢？实际上，对于Angular项目测试套件，没有直接的答案；我们将不使用基于浏览器的测试套件，而是使用Karma作为测试套件的测试运行器。但是，由于我们在前面的例子中熟悉了基于浏览器的Jasmine测试套件，让我们看看如果我们为Angular项目制作一个类似的测试套件会是什么样子。
- en: 'We will have to add a subfolder as `src` in the Angular project for the test
    spec, and then the project''s folder structure will look like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不在Angular项目中添加一个名为`src`的子文件夹用于测试规范，然后项目的文件夹结构将如下所示：
- en: '![The Jasmine test suite for Angular](graphics/image_02_003.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![Angular的Jasmine测试套件](graphics/image_02_003.jpg)'
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the Angular project, we will use TypeScript rather than plain JavaScript
    as Angular officially suggests using TypeScript. So, we hope that we all know
    the TypeScript syntax and know how to compile to JS.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular项目中，我们将使用TypeScript而不是纯JavaScript，因为Angular官方建议使用TypeScript。因此，我们希望大家都了解TypeScript的语法并知道如何编译成JS。
- en: In this book, for the Angular test suite, we will use SystemJS as the module
    loader, as Angular officially suggests it; we will take a look at SystemJS.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，对于Angular测试套件，我们将使用SystemJS作为模块加载器，因为Angular官方建议使用它；我们将看一下SystemJS。
- en: This sample Angular test suite is just to show how easily we can make a test
    suite for an Angular project, though it's not following the best practices and
    the best way to load the modules.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例Angular测试套件只是为了展示我们如何轻松地为Angular项目制作一个测试套件，尽管它并没有遵循最佳实践和最佳的模块加载方式。
- en: In [Chapter 3](ch03.html "Chapter 3. The Karma Way"), *The Karma Way*, we will
    update this test suite with real-life examples and use SystemJS as the module
    loader.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。Karma方式")中，*Karma方式*，我们将使用真实的例子更新这个测试套件，并使用SystemJS作为模块加载器。
- en: There is a seed project from the Angular team in GitHub called as `Angular2-seed`
    to bootstrap any Angular project with test suite; we will follow that one for
    our real Angular project.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub上，Angular团队有一个名为`Angular2-seed`的种子项目，可以为任何Angular项目提供测试套件；我们将为我们真正的Angular项目遵循这个项目。
- en: 'If we look at the folder structure, it''s almost the same as the previous one,
    and there are minimum changes in the spec file as well; the only change in spec
    is with TypeScript:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下文件夹结构，它几乎与之前的相同，规范文件中也有最少的更改；规范中唯一的变化是使用TypeScript：
- en: '[PRE6]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As this is also a browser-based test suite, we have to point `unit-tests.html`
    in a web browser to get the test result. We will have all the tests passed, and
    our test result will look like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这也是一个基于浏览器的测试套件，我们必须在Web浏览器中指向`unit-tests.html`以获取测试结果。我们将通过所有测试，并且我们的测试结果将如下所示：
- en: '![The Jasmine test suite for Angular](graphics/image_02_004.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![Angular的Jasmine测试套件](graphics/image_02_004.jpg)'
- en: Self-test questions
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: Self-test questions will help you further test your knowledge of using TDD for
    JavaScript application testing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 自测问题将帮助您进一步测试您在JavaScript应用程序测试中使用TDD的知识。
- en: Q1\. End-to-end testing means what kind of test?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. 端到端测试意味着什么样的测试？
- en: Functional test
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试
- en: Behavior test
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为测试
- en: Q2\. Protractor is a Unit testing framework.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. Protractor是一个单元测试框架。
- en: 'True'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Q3\. PhantomJS is a type of browser.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Q3\. PhantomJS是一种类型的浏览器。
- en: 'True'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Q4\. What is QUnit a test framework for?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Q4\. QUnit是用于什么样的测试框架？
- en: jQuery
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery
- en: Angular
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular
- en: NodeJS
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NodeJS
- en: Q5\. Setup and teardown is a feature of Jasmine.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Q5\. 设置和拆卸是Jasmine的一个特性。
- en: 'True'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reviewed different mechanisms of testing TDD and covered
    automated testing. We reviewed different kinds of JavaScript testing frameworks
    and tools and reviewed the uses of those frameworks with their pros and cons.
    We also reviewed some common assertions from Jasmine and tried, hands on, how
    they worked.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了TDD的不同测试机制，并介绍了自动化测试。我们回顾了不同类型的JavaScript测试框架和工具，并审查了这些框架的优缺点。我们还回顾了Jasmine的一些常见断言，并尝试亲自动手看它们是如何工作的。
- en: In the next chapter, we will learn about Karma and see how that works with the
    Angular test suite.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于Karma，并了解它如何与Angular测试套件配合使用。
