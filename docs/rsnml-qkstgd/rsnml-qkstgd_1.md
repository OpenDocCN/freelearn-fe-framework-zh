# 第一章：ReasonML 简介

过去十年，我们在构建用户界面的方式上经历了多次范式转变。Web 应用程序已经从服务器端框架转移到客户端框架，以提供更好的用户体验。设备和浏览器已经足够强大，可以运行健壮的客户端应用程序，而 JavaScript 语言本身在多年中也经历了许多改进。渐进式 Web 应用程序提供了类似原生的用户体验，WebAssembly 允许在 Web 平台上实现类似原生的性能。越来越多的应用程序正在为浏览器构建，导致需要维护的客户端代码库越来越大。

在这个时期，几个框架、库、工具和一般最佳实践获得了流行，然后又失去了流行，导致许多开发者感到**JavaScript 疲劳**。由于新技术对招聘和保留工程人才、生产力和可维护性的影响，公司越来越谨慎地承诺采用新技术。如果向团队引入错误的技术（或错误时机上的正确技术），这可能是一个代价高昂的错误。

对于许多公司和开发者来说，React 已经被证明是一个可靠的选择。2013 年，Facebook 在 2011 年开始内部使用该库后将其开源。他们挑战我们重新思考最佳实践([`www.youtube.com/watch?v=DgVS-zXgMTk&feature=youtu.be`](https://www.youtube.com/watch?v=DgVS-zXgMTk&feature=youtu.be))，并且它已经接管了前端开发([`medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76`](https://medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76))。将标记、行为和样式封装到可重用组件中已经成为一个巨大的生产力和可维护性的胜利。DOM 的抽象使得组件可以简单地成为其 props 的声明性函数，这使得推理、组合和测试变得容易。

通过 React，Facebook 已经在前端开发者社区中做了令人难以置信的工作，教育他们关于传统的函数式编程范式，这些范式使得推理和维护代码变得更加容易。现在，Facebook 认为现在是 ReasonML 的时机。

这是一张来自[npmtrends.com](https://www.npmtrends.com/)的两年图表，显示了某些顶级 JavaScript 库和框架每周的 npm 下载量。ReactJS 看起来是一个明显的赢家，每周下载量超过 2,500,000 次：

![图片](img/b5957f88-9ae0-4aaa-ba2a-f1ec78579b88.png)

npmtrends.com

在本章中，我们将进行以下内容：

+   讨论 ReasonML 是什么以及它试图解决的问题

+   了解 Facebook 选择 ReasonML 作为 ReactJS 未来的原因

+   在在线沙盒中尝试 ReasonML 并检查其编译（JavaScript）输出

# ReasonML 是什么？

Reason 是 OCaml 语法和工具层，Facebook 正在积极使用的一种语言。乔丹 [Walke] 在 React 之前就提出了 Reason 的概念。事实上，我们正在将其用作实际的（前端）语言（以及其他用途），因为我们认为经过三年半的时间，React 的实验已经成功，人们现在准备好使用 Reason 了...

– Cheng Lou，2017 年 1 月

([`www.reactiflux.com/transcripts/cheng-lou/`](https://www.reactiflux.com/transcripts/cheng-lou/))

让我们进一步探讨这句话。ReasonML 不是一个新的语言；它是 OCaml 语言的全新语法，旨在让 JavaScript 开发者感到熟悉。从现在起，我们将称之为 Reason，它具有与 OCaml 完全相同的抽象语法树（AST），因此 Reason 和 OCaml 只在语法上有所不同。语义是相同的。通过学习 Reason，你也在学习 OCaml。实际上，有一个命令行工具可以在 OCaml 和 Reason 语法之间进行转换，称为 `refmt`，它将 Reason/OCaml 代码格式化为类似 JavaScript 的 prettier——实际上，prettier 就是受到了 `refmt` 的启发。

OCaml 是一种注重表达性和安全性的通用编程语言。它最初于 1996 年发布，拥有一个高级类型系统，可以帮助你捕捉错误而不会妨碍你的工作。和 JavaScript 一样，OCaml 具有垃圾回收功能，用于自动内存管理，以及可以像其他函数的参数一样传递的一等函数。

Reason 也是一个工具链，对于那些来自 JavaScript 背景的人来说，它使得入门变得更加容易。这个工具链允许我们利用 JavaScript 和 OCaml 生态系统的优势。我们将在第二章“设置开发环境”中深入探讨。现在，我们将直接在在线沙盒中通过访问 Reason 的在线沙盒 [`reasonml.github.io/try`](https://reasonml.github.io/try) 来进行实验。

尝试将这个“Hello World”示例输入到在线沙盒中：

```js
let message = "World";
Js.log("Hello " ++ message);
```

你会注意到两件事：

+   OCaml 语法将在编辑器的左下角自动生成（未显示）

+   Reason/OCaml 代码直接在浏览器中编译成 JavaScript：

```js
// Generated by BUCKLESCRIPT VERSION 3.2.0, PLEASE EDIT WITH CARE
'use strict';

var message = "World";

console.log("Hello World");

exports.message = message;
/* Not a pure module */
```

你可能会想知道 Reason/OCaml 代码是如何在浏览器中编译的。BuckleScript，Reason 的合作伙伴项目，将 OCaml AST 编译成 JavaScript。由于 Reason 和 OCaml 都会被转换成相同的 OCaml AST，BuckleScript 支持 Reason 和 OCaml。此外，由于 BuckleScript 本身是用 OCaml 编写的，它可以编译成 JavaScript 并直接在浏览器中运行。

检查编译后的 JavaScript 可以发现它有多么易于阅读。仔细观察，你会发现编译后的输出也进行了优化：在 `console.log` 语句中，`"Hello World"` 字符串被直接内联，而不是使用 `message` 变量。

BuckleScript 利用 OCaml 类型系统和编译器实现的功能，能够在离线编译期间提供许多优化，使得运行时代码非常快速。

– BuckleScript 文档

([`bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript`](https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript)[)](https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript)

值得注意的是，BuckleScript 还支持字符串插值([`bucklescript.github.io/docs/en/common-data-types.html#interpolation`](https://bucklescript.github.io/docs/en/common-data-types.html#interpolation))：

```js
/* The message variable is interpolated */
{j|Hello $message|j}
```

# 为什么选择 Reason？

Reason 为什么如此吸引人？Reason 能做什么是 TypeScript 或 Flow 所不能做的？仅仅是拥有静态类型检查器吗？这些问题是我刚开始接触 Reason 时产生的疑问。

# 支持不可变性和纯度

Reason 不仅仅是拥有静态类型系统。同样重要的是，Reason 默认是不可变的。不可变性是函数式编程中的一个重要概念。在实践中，使用不可变的数据结构（无法改变的数据结构）比它们可变的对应物产生更安全、更容易推理和更易于维护的代码。这一点将在整本书中反复出现。

纯度是函数式编程中的另一个重要概念。如果一个函数的输出仅由其输入决定，没有可观察的副作用，那么这个函数被认为是纯函数。换句话说，一个纯函数除了返回一个值之外，不做任何其他事情。以下是一个纯函数的示例：

```js
let add = (a, b) => a + b;
```

此外，这是一个不纯函数的示例：

```js
let add = (a, b) => {
  Js.log("side-effect");
  a + b;
};
```

在这种情况下，副作用是向浏览器的控制台写入。这就是为什么在我们的前一个`Hello World`示例中，BuckleScript 在编译输出的末尾包含了`/* Not a pure module */`注释。

修改全局变量也是一种副作用。考虑以下 JavaScript 代码：

```js
var globalObject = {total: 0};
const addAndMutate = (a, b) => globalObject.total = a + b;
addAndMutate(40, 2);
/* globalObject now is mutated */
```

全局对象被修改了，现在它的`total`属性是`42`。我们现在必须意识到所有在使用`globalObject`时可能对其进行修改的区域。忘记这个对象既是全局的又是可变的可能会导致难以调试的问题。解决这个问题的惯用方法是将`globalObject`移动到一个模块中，使其不再全局。这样，只有那个模块可以访问它。然而，我们仍然需要意识到这个模块内所有可以更新该对象的区域。

如果`globalObject`是不可变的，那么将无法对其进行修改。因此，我们不需要意识到所有可能修改`globalObject`的区域，因为这些区域将不存在。我们将看到，使用 Reason，通过创建原始数据的更新副本，以这种方式构建真实的应用程序相当简单且自然。考虑以下示例：

```js
let foo = 42;
let foo = foo + 1;
Js.log(foo);
/* 43 */
```

语法感觉非常自然。正如我们将在本书后面看到的那样，不可变性——通过返回更新后的副本而不是在原地应用破坏性更改来改变——非常适合 React/Redux 的工作方式。

原始的`foo`没有被修改；它被阴影了。一旦被阴影，旧的`foo`绑定就不可用了。绑定可以在局部作用域以及全局作用域中被阴影：

```js
let foo = 42;

{
  let foo = 43;
  Js.log(foo); /* 43 */
};

Js.log(foo); /* 42 */

let foo = 43;
Js.log(foo); /* 43 */
```

尝试修改`foo`会导致编译错误：

```js
let foo = 42;
foo = 43;
/* compilation error */
```

我们可以看到不可变性和纯度是相关的话题。拥有支持不可变性的语言允许你在没有副作用的情况下以纯方式编程。然而，如果纯度会导致代码比使用副作用更复杂、更难以推理，你可能会感到欣慰。Reason（在本书的其余部分与 OCaml 可互换）是一种实用主义语言，它允许我们在需要时产生副作用。

当使用像[Reason]这样的语言时，关键不是避免副作用，因为避免副作用等同于避免做任何有用的事情。实际上，程序不仅仅是*计算*事物，它们*做*事情。它们发送消息，写入文件，做各种各样的事情。做事情的过程会自动涉及副作用。支持纯度的语言给你带来的好处是，它让你能够大致地将涉及副作用的代码部分分割出来，使其成为清晰且可控的代码区域，这使得推理变得更加容易。

– Yaron Minsky

([`www.youtube.com/watch?v=-J8YyfrSwTk&feature=youtu.be&t=47m29s`](https://www.youtube.com/watch?v=-J8YyfrSwTk&feature=youtu.be&t=47m29s))

还很重要的一点是，不可变性不会以性能为代价。在底层，有优化措施在位，以保持 Reason 的不可变数据结构快速。

# 模块系统

Reason 有一个复杂的模块系统，允许模块化开发和代码组织。在 Reason 中，所有模块都是全局可用的，并且当需要时，模块接口可以用来隐藏实现细节。我们将在第五章，*有效的 ML*中探讨这个概念。

# 类型系统

Reason 的类型系统是健全的，这意味着一旦编译，就不会有运行时类型错误。语言中没有`null`，也没有与`null`相关的任何错误。在 JavaScript 中，当某物是`number`类型时，它也可以是`null`。Reason 为也可以是`null`的事物使用一个特殊的类型，并强制开发者通过拒绝编译来适当地处理这些情况。

到目前为止，我们已经在不讨论类型的情况下编写了一些，尽管是基本的，Reason 代码。Reason 可以自动推断类型。正如我们将在整本书中学到的，类型系统是一个提供保证而不妨碍我们的工具，并且当正确使用时，可以让我们将以前需要记住的事情卸载到编译器中。

Reason 对不可变编程、稳健的类型系统和复杂的模块系统的支持是 Reason 之所以如此出色的主要原因之一，而且在使用一个考虑到这些特性的语言中同时使用所有这些特性确实有可说之处。当 Facebook 最初发布 React 时，他们要求我们给它五分钟的时间([`signalvnoise.com/posts/3124-give-it-five-minutes`](https://signalvnoise.com/posts/3124-give-it-five-minutes))，并且，希望同样的心态在这里也能得到回报。

# 跨平台

使用 Reason 构建 React 应用是一种愉快的体验，更重要的是，由于 OCaml 能够编译成原生代码，我们将能够使用这些相同的技能来构建编译成汇编、iOS/Android 等更多平台的 app。实际上，Jared Forsyth 已经创建了一个名为 Gravitron([`github.com/jaredly/gravitron`](https://github.com/jaredly/gravitron))的游戏，它可以从一个 Reason 代码库编译到 iOS、Android、网页和 macOS。尽管如此，截至本文撰写时，前端 JavaScript 的故事已经变得更加完善。

# 可维护性

Reason 可能需要一些时间才能适应，但你可以将这段时间视为对你未来产品维护和信心的投资。尽管像 TypeScript 这样的渐进式类型系统的语言可能更容易上手，但它们并不提供像 Reason 这样的稳健类型系统所能提供的保证。Reason 的真正好处不能完全通过简单的例子来传达，只有在节省你推理、重构和维护代码的时间和精力时才能真正显现。用这种方式来说；如果有人告诉我他们有 99%的把握床里没有蜘蛛，我仍然会检查整个床，因为我不喜欢虫子！

只要你在 Reason 中 100%投入并且代码能够编译，类型系统就能保证不会有运行时类型错误。确实，当你与非 Reason 代码（例如 JavaScript）进行互操作时，你会引入运行时类型错误的可能性。Reason 的稳健类型系统让你可以相信应用中的 Reason 部分不会引起运行时类型错误，因此你可以额外关注确保这些应用区域的安全性。根据我的经验，在动态语言中编程可能会感觉特别危险。另一方面，Reason 则感觉它总是在背后支持你。

# 互操作性

话虽如此，有时——尤其是在刚开始学习类型系统时——你可能会不确定如何让你的代码编译。通过 BuckleScript，Reason 允许你在需要时直接降级到原始 JavaScript，无论是通过绑定还是直接在你的 Reason（`.re`）文件中。这给了你在 JavaScript 中边走边解决问题的自由，一旦你准备好了，就可以将代码的这一部分转换为类型安全的 Reason。

BuckleScript 还允许我们以非常合理的方式将 JavaScript 的惯用语法绑定。正如你将在第四章，“BuckleScript，Belt 和互操作性”中了解到的那样，BuckleScript 是 Reason 的一个非常强大的组成部分。

# ES2030

用 Reason 编写感觉就像是在编写 JavaScript 的未来版本。Reason 的一些语言特性，包括管道操作符([`github.com/tc39/proposal-pipeline-operator`](https://github.com/tc39/proposal-pipeline-operator))和模式匹配([`github.com/tc39/proposal-pattern-matching`](https://github.com/tc39/proposal-pattern-matching))，目前正在被提议添加到 JavaScript 语言中。有了 Reason，我们可以利用这些特性以及更多，今天就可以做到。

# 社区

毫无疑问，Reason 社区是我曾经参与过的最有帮助、最有支持性和最具包容性的社区之一。如果你有问题，或者在某件事上遇到了困难，Reason Discord 频道是获取实时支持的地方。

Reason Discord 频道：

[`discord.gg/reasonml`](https://discord.gg/reasonml)

通常，当开始使用新技术时，与有经验的人交谈五分钟可以节省你数小时的挫败感。我亲自在一天中的任何时间（包括夜晚）提问，并对有人如此迅速地帮助我感到无比感激和惊讶。花点时间加入 Discord 频道，自我介绍，提问，并分享你对如何使 Reason 变得更好的反馈！

# ReactJS 的未来

在实践中，很少有实际应用只使用 ReactJS。通常还会引入其他技术，如 Babel、ESLint、Redux、Flow/TypeScript 和 Immutable.js，以帮助提高代码库的可维护性。Reason 通过其核心语言特性取代了这些额外技术的需求。

ReasonReact 是一个 Reason 库，它将 ReactJS 绑定并提供了一种更简单、更安全的方式来构建 ReactJS 组件。就像 ReactJS 只是 JavaScript 一样，ReasonReact 只是 Reason。此外，它易于逐步采用，因为它是由创建了 ReactJS 的同一个人所制作的。

ReasonReact 自带内置路由器、类似 Redux 的数据管理以及 JSX。如果你有 ReactJS 背景，你会感到非常自在。

重要的是要提到，Reason/ReasonReact 已经被几家公司在生产中使用，包括世界上最大的代码库之一。Facebook 的 messenger.com 代码库已经超过 50% 转换为 ReasonReact。

每个 ReasonReact 功能都在 messenger.com 代码库上进行了广泛的测试。

– 程楼

([`reason.town/reason-philosophy`](https://reason.town/reason-philosophy))

因此，Reason 和 ReasonReact 的新版本都附带代码修改，自动化了代码库升级过程的大部分，如果不是全部。在发布给公众之前，新功能在 Facebook 内部进行了彻底的测试，这为开发者带来了愉快的体验。

# 探索 Reason

请问以下内容是语句还是表达式：

```js
let foo = "bar";
```

在 JavaScript 中，这是一个语句，但在 Reason 中，它是一个表达式。另一个表达式的例子是 `4 + 3`，它也可以表示为 `4 + (2 + 1)`。

Reason 中的许多事物都是表达式，包括控制结构，如 `if-else`、`switch`、`for` 和 `while`：

```js
let message = if (true) {
  "Hello"
} else {
  "Goodbye"
};
```

Reason 中也有三元运算符。以下是另一种表达前面代码的方式：

```js
let message = true ? "Hello" : "Goodbye";
```

即使是匿名块作用域也是表达式，它们评估为最后一行的表达式：

```js
let message = {
  let part1 = "Hello";
  let part2 = "World";
  {j|$part1 $part2|j};
};
/* message evaluates to "Hello World" */
/* part1 and part2 are not accessible here */
```

`tuple` 是一个不可变的数据结构，可以存储不同类型的值，并且可以是任何长度：

```js
let tuple = ("one", 2, "three");
```

让我们利用目前已知的知识，直接从 Reason 在线沙盒中的 `FizzBuzz` 示例入手。`FizzBuzz` 是一个流行的面试问题，用于判断候选人是否具备编码能力。挑战是编写一个从 `1` 到 `100` 打印数字的问题，但打印 `Fizz` 作为三的倍数，`Buzz` 作为五的倍数，以及 `FizzBuzz` 作为三和五的公倍数：

```js
/* Based on https://rosettacode.org/wiki/FizzBuzz#OCaml */
let fizzbuzz = (i) =>
  switch (i mod 3, i mod 5) {
  | (0, 0) => "FizzBuzz"
  | (0, _) => "Fizz"
  | (_, 0) => "Buzz"
  | _ => string_of_int(i)
  };

for (i in 1 to 100) {
  Js.log(fizzbuzz(i))
};
```

在这里，`fizzbuzz` 是一个接受整数并返回字符串的函数。一个命令式的 `for` 循环将其输出记录到控制台。

在 Reason 中，函数的最后一个表达式成为函数的返回值。`switch` 表达式是唯一的 `fizzbuzz` 表达式，所以它评估的结果成为 `fizzbuzz` 的输出。像 JavaScript 一样，`switch` 评估一个表达式，第一个匹配的案例执行其分支。在这种情况下，`switch` 评估元组表达式：`(i mod 3, i mod 5)`。

给定 `i=1`，`(i mod 3, i mod 5)` 变为 `(1, 1)`。由于 `(1, 1)` 不匹配 `(0, 0)`、`(0, _)` 或 `(_, 0)`，按照这个顺序，最后的情况 `_`（即任何东西）被匹配，并返回 `"1"`。同样，当给定 `i=2` 时，`fizzbuzz` 返回 `"2"`。当给定 `i=3` 时，返回 `"Fizz"`。

或者，我们也可以使用 `if-else` 实现 `fizzbuzz`：

```js
let fizzbuzz = (i) =>
  if (i mod 3 == 0 && i mod 5 == 0) {
    "FizzBuzz"
  } else if (i mod 3 == 0) {
    "Fizz"
  } else if (i mod 5 == 0) {
    "Buzz"
  } else {
    string_of_int(i)
  };
```

然而，`switch` 版本的可读性更高。并且正如我们将在本章后面看到的那样，`switch` 表达式，也称为**模式匹配**，比我们之前看到的更强大。

# 数据结构和类型

类型是一组值。更具体地说，`42`有`int`类型，因为它是一个包含在整数集合中的值。浮点数是一个包含小数点的数字，即`42.`和`42.0`。在 Reason 中，整数和浮点数有单独的操作符：

```js
/* + for ints */
40 + 2;

/* +. for floats */
40\. +. 2.;
```

对于`-.`、`-`、`*.`、`*`、`/.`和`/`也是如此。

Reason 使用双引号表示`string`类型，单引号表示`char`类型。

# 创建我们自己的类型

我们也可以创建我们的类型：

```js
type person = (string, int);

/* or */

type name = string;
type age = int;
type person = (name, age);
```

这是创建`person`类型人的方法：

```js
let person = ("Zoe", 3);
```

我们还可以用类型注解任何表达式：

```js
let name = ("Zoe" : string);
let person = ((name, 3) : person);
```

# 模式匹配

我们也可以在我们的`person`上使用模式匹配：

```js
switch (person) {
| ("Zoe", age) => {j|Zoe, $age years old|j}
| _ => "another person"
};
```

让我们用记录代替元组来表示我们的`person`。记录与 JavaScript 对象类似，但它们更轻量，默认是不可变的：

```js
type person = {
  age: int,
  name: string
};

let person = {
  name: "Zoe",
  age: 3
};
```

我们也可以在记录上使用模式匹配：

```js
switch (person) {
| {name: "Zoe", age} => {j|Zoe, $age years old|j}
| _ => "another person"
};
```

与 JavaScript 一样，`{name: "Zoe", age: age}`可以表示为`{name: "Zoe", age}`。

我们可以使用扩展（`...`）操作符从一个现有记录创建一个新的记录：

```js
let person = {...person, age: person.age + 1};
```

记录在使用之前需要类型定义。否则，编译器会报错，如下所示：

```js
The record field name can't be found.

```

记录必须与它的类型形状相同。因此，我们不能随意向我们的`person`记录添加字段：

```js
let person = {...person, favoriteFood: "broccoli"};

/*
  We've found a bug for you!

  This record expression is expected to have type person
  The field favoriteFood does not belong to type person
*/
```

元组和记录是产品类型的例子。在我们的最近例子中，我们的`person`类型需要`int`和`age`。JavaScript 的大多数数据结构都是产品类型；一个例外是`boolean`类型，它可以是`true`或`false`。

Reason 的变体类型，它是和类型的一个例子，允许我们表达“这个”或“那个”。我们可以将`boolean`类型定义为变体：

```js
type bool =
  | True
  | False;
```

我们可以有我们需要的构造函数数量：

```js
type decision =
  | Yes
  | No
  | Maybe;
```

`Yes`、`No`和`Maybe`被称为构造函数，因为我们可以使用它们来构造值。它们也通常被称为**标签**。因为这些标签可以构造值，所以变体既是类型也是数据结构：

```js
let decision = Yes;
```

当然，我们也可以在`decision`上使用模式匹配：

```js
switch (decision) {
| Yes => "Let's go."
| No => "I'm staying here."
| Maybe => "Convince me."
};
```

如果我们忘记处理一个情况，编译器会警告我们：

```js
switch (decision) {
| Yes => "Let's go."
| No => "I'm staying here."
};

/*
  Warning number 8

  You forgot to handle a possible value here, for example: 
  Maybe
*/
```

正如我们将在第二章《设置开发环境》中学习的，编译器可以被配置为将这个警告转换为错误。让我们看看一种利用这些完备性检查来帮助使我们的代码更适应未来重构的方法。

以以下例子为例，我们被要求根据座位所在的区域计算音乐厅座位的票价。楼层座位是$55，而其他所有座位是$45：

```js
type seat =
  | Floor
  | Mezzanine
  | Balcony;

let getSeatPrice = (seat) =>
  switch(seat) { 
  | Floor => 55
  | _ => 45
  };
```

如果后来音乐厅允许以$65 的价格出售乐池区域的座位，我们首先会在`seat`中添加另一个构造函数：

```js
type seat =
  | Pit
  | Floor
  | Mezzanine
  | Balcony;
```

然而，由于使用了通配符 `_` 情况，编译器在这次更改后并没有抱怨。如果它真的这样做，那会更好，因为这有助于我们在重构过程中。在更改类型定义后逐步查看编译器消息是 Reason（以及一般而言的 ML 家族语言）使重构和扩展代码成为一个更安全、更愉快的过程。当然，这不仅仅限于变体类型。向我们的 `person` 类型添加另一个字段也会导致相同的逐步查看编译器消息的过程。

相反，我们应该保留使用 `_` 来表示无限多种情况（例如我们的 `fizzbuzz` 示例）。我们可以重构 `getSeatPrice` 以使用显式的情况：

```js
let getSeatPrice = (seat) =>
  switch(seat) { 
  | Floor => 55
  | Mezzanine | Balcony => 45
  };
```

这里，我们欢迎编译器友好地通知我们未处理的案例，然后添加它：

```js
let getSeatPrice = (seat) =>
  switch(seat) {
  | Pit => 65
  | Floor => 55
  | Mezzanine | Balcony => 45
  };
```

现在让我们想象一下，每个座位，即使是同一区域（即具有相同标签）的座位，也可以有不同的价格。嗯，Reason 变体也可以存储数据：

```js
type seat =
  | Pit(int)
  | Floor(int)
  | Mezzanine(int)
  | Balcony(int);

let seat = Floor(57);
```

我们可以通过模式匹配来访问这些数据：

```js
let getSeatPrice = (seat) =>
  switch (seat) {
  | Pit(price)
  | Floor(price)
  | Mezzanine(price)
  | Balcony(price) => price
  };
```

变体不仅限于存储一条数据。让我们想象一下，我们希望我们的 `seat` 类型不仅存储价格，还要存储是否仍然可用。如果不可用，它应该存储持票人的信息：

```js
type person = {
  age: int,
  name: string,
};

type seat =
  | Pit(int, option(person))
  | Floor(int, option(person))
  | Mezzanine(int, option(person))
  | Balcony(int, option(person));
```

在解释 `option` 类型之前，让我们看看它的实现：

```js
type option('a)
  | None
  | Some('a);
```

在前面的代码中，`'a` 被称为**类型变量**。类型变量总是以 `'` 开头。这个类型定义使用类型变量，以便它可以适用于任何类型。如果不这样做，我们就需要创建一个仅适用于 `person` 类型的 `personOption` 类型：

```js
type personOption(person)
  | None
  | Some(person);
```

如果我们还想为另一种类型提供选项呢？而不是一遍又一遍地重复这个类型声明，我们应该声明一个多态类型。多态类型是一个包含类型变量的类型。在我们的例子中，`'a`（发音为 alpha）类型变量将被 `person` 替换。由于这个类型定义非常常见，它包含在 Reason 的标准库中，因此不需要在您的代码中声明 `option` 类型。

回到我们的 `seat` 示例，我们将其价格存储为 `int`，并将其持有人存储为 `option(person)`。如果没有持有人，它仍然可用。我们可以有一个 `isAvailable` 函数，它接受一个 `seat` 并返回一个 `bool`：

```js
let isAvailable = (seat) =>
  switch (seat) {
  | Pit(_, None)
  | Floor(_, None)
  | Mezzanine(_, None)
  | Balcony(_, None) => true
  | _ => false
  };
```

让我们退一步，看看 `getSeatPrice` 和 `isAvailable` 的实现。很遗憾，这两个函数需要知道不同的构造函数，尽管它们与座位的价格或可用性无关。再次看看我们的 `seat` 类型，我们看到 `(int, option(person))` 在每个构造函数中都被重复。此外，避免在 `isAvailable` 中使用 `_` 情况并没有很好的方法。这些都是表明另一个类型定义可能更好地满足我们需求的迹象。让我们从 `seat` 类型中移除参数，并将其重命名为 `section`。我们将声明一个新的记录类型，称为 `seat`，它包含 `section`、`price` 和 `person` 字段：

```js
type person = {
  age: int,
  name: string,
};

type section =
 | Pit
 | Floor
 | Mezzanine
 | Balcony;

type seat = {
  section, /* same as section: section, */
  price: int,
  person: option(person)
};

let getSeatPrice = seat => seat.price;

let isAvailable = seat =>
  switch (seat.person) {
  | None => true
  | Some(_person) => false
  };
```

现在，我们的`getSeatPrice`和`isAvailable`函数具有更高的信号与噪声比，并且当`section`类型改变时不需要更改。

作为旁注，`_`用于变量前缀，以防止编译器警告我们该变量未使用。

# 使无效状态成为不可能

假设我们想在`seat`中添加一个字段来保存座位购买日期：

```js
type seat = {
  section,
  price: int,
  person: option(person),
  dateSold: option(string)
};
```

现在，我们已经在我们的代码中引入了无效状态的可能性。以下是一个此类状态的示例：

```js
let seat = {
  section: Pit,
  price: 42,
  person: None,
  dateSold: Some("2018-07-16")
};
```

理论上，`dateSold`字段只应在`person`字段包含持票人时持有日期。票有售出日期，但没有所有者。我们可以检查我们的假设实现以验证这种状态永远不会发生，但仍然存在我们可能遗漏了某些内容，或者某些微小的重构引入了被忽视的错误的可能。

由于我们现在可以利用 Reason 的类型系统，让我们将这项工作委托给编译器。我们将使用类型系统来强制执行代码中的不变性。如果我们的代码违反了这些规则，它将无法编译。

这种无效状态可能存在的一个迹象是在我们的记录字段中使用`option`类型。在这些情况下，可能有一种方法可以使用一个变体，使得每个构造函数只包含相关的数据。在我们的例子中，我们的售出日期和持票人数据只应在座位售出时存在：

```js
type person = {
  age: int,
  name: string,
};

type date = string;

type section =
  | Pit
  | Floor
  | Mezzanine
  | Balcony;

type status =
  | Available
  | Sold(date, person);

type seat = {
  section,
  price: int,
  status
};

let getSeatPrice = (seat) => seat.price;

let isAvailable = (seat) =>
  switch (seat.status) {
  | Available => true
  | Sold(_) => false
  };
```

查看我们的新`status`类型。`Available`构造函数不包含任何数据，而`Sold`构造函数包含售出日期以及持票人。

使用这种`seat`类型，无法表示没有持票人的售出日期的先前无效状态。这也表明我们的`seat`类型不再包含`option`类型。

# 摘要

在本章中，我们感受到了 Reason 是什么以及它试图解决的问题。我们看到了 Reason 的类型推断如何减轻与静态类型语言相关的许多负担。我们了解到类型系统是一个工具，可以用来为代码库提供强大的保证，从而提供出色的开发者体验。虽然 Reason 可能需要一些时间来适应，但对于中等规模到较大的代码库来说，这种投资是非常值得的。

在下一章中，我们将学习在设置我们的开发环境时如何使用 Reason 的工具链。在第三章“创建 ReasonReact 组件”中，我们将开始构建一个我们将在这本书的其余部分中使用的应用程序。到这本书的结尾，你将能够舒适地使用 Reason 构建真实的 React 应用程序。
