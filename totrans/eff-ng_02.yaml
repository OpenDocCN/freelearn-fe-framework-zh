- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Powerful Angular Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强大的 Angular 功能
- en: 'Angular has built-in tools for everything you need to build robust web applications.
    In this chapter, you will learn about the newest and most powerful features in
    the Angular framework. We will also dive into Angular component communication,
    the router, and arguably the most important and powerful part of the Angular framework:
    dependency injection. By the end of this chapter, you will know how to inject,
    consume, provide, and adjust the hierarchy of dependencies, how to communicate
    between components, and how to effectively use the Angular router.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 为构建健壮的 Web 应用程序提供了所需的所有内置工具。在本章中，你将了解 Angular 框架中最新和最强大的功能。我们还将深入了解
    Angular 组件通信、路由器，以及 Angular 框架中可能最重要和最强大的部分：依赖注入。到本章结束时，你将了解如何注入、消费、提供和调整依赖项的层次结构，如何组件间通信，以及如何有效地使用
    Angular 路由器。
- en: 'This chapter will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: What makes Angular so powerful?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 为什么如此强大？
- en: New features in the Angular framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 框架中的新功能
- en: A deep dive into the Angular router
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解 Angular 路由器
- en: Component communication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件通信
- en: Dependency injection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: What makes Angular so powerful?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 为什么如此强大？
- en: Angular sets itself apart from other popular frontend frameworks and libraries
    such as ReactJS and VueJS because it is strongly opinionated and has everything
    you need to develop complex web applications embedded in the framework itself.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 与其他流行的前端框架和库（如 ReactJS 和 VueJS）不同，因为它具有强烈的意见，并且框架本身包含了开发复杂 Web 应用程序所需的一切。
- en: Using Angular effectively ensures that there is a certain level of consistency
    and that best practices are implemented. This is because Angular makes many decisions
    for you, such as using TypeScript and relying on **object-oriented programming**
    (**OOP**) principles and built-in tools to handle common problems such as routing,
    HTTP requests, and testing! Because Angular has everything built into it, you
    don’t need to bring in a lot of external packages, reducing the surface for potential
    exploits or packages that stop being maintained. These aspects often make Angular
    the framework of choice when building complex frontend systems or enterprise software
    composed of multiple applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有效使用 Angular 确保了一定程度的一致性，并实施了最佳实践。这是因为 Angular 为你做了许多决定，例如使用 TypeScript，并依赖于
    **面向对象编程**（**OOP**）原则和内置工具来处理诸如路由、HTTP 请求和测试等常见问题！由于 Angular 内置了所有功能，你不需要引入大量的外部包，从而减少了潜在漏洞或停止维护的包的表面。这些方面通常使得
    Angular 成为构建复杂前端系统或由多个应用程序组成的企业的首选框架。
- en: 'Angular comes packed with powerful and useful features for building web applications.
    If you are reading this book, you should already be familiar with the main features,
    but we will still mention the ones that are most essential to the framework:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 内置了构建 Web 应用程序所需的所有强大和有用的功能。如果你正在阅读这本书，你应该已经熟悉了主要功能，但我们仍将提及对框架最重要的那些：
- en: '**Components and services**: Components and services are the building blocks
    of Angular applications. Components are used to develop reusable UI elements and
    pages comprised of these UI elements. Angular services are injected throughout
    your applications using dependency injection and communicate with backend APIs,
    handle state management, provide data, and implement business logic.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件和服务**：组件和服务是 Angular 应用程序的基本构建块。组件用于开发可重用的 UI 元素和由这些 UI 元素组成的页面。Angular
    服务通过依赖注入注入到你的应用程序中，并与后端 API 通信，处理状态管理，提供数据，并实现业务逻辑。'
- en: '**Dependency injection**: Angular dependency injection is one of the fundamental
    concepts of the framework and is often regarded as its most powerful feature.
    Dependency injection allows you to inject values and logic throughout your applications.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入**：Angular 依赖注入是框架的基本概念之一，通常被认为是最强大的功能。依赖注入允许你在应用程序中注入值和逻辑。'
- en: '**Signals**: Signals are a new concept within the Angular framework that is
    used to define stateful properties. Angular tracks where and how the Signal values
    are used to optimize change detection, resulting in improved performance. Signals
    are also reactive, allowing you to automatically react when a Signal value changes.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号**：信号是 Angular 框架中的一个新概念，用于定义有状态的属性。Angular 跟踪信号值的使用位置和方法，以优化变更检测，从而提高性能。信号也是响应式的，允许你在信号值变化时自动做出反应。'
- en: '**HTTP client**: The built-in HTTP client provides an elegant and intuitive
    interface for communicating with APIs and fetching data. With built-in features
    such as request and response interceptors, error handling, and observable-based
    responses, the Angular HTTP client is everything you need for handling HTTP logic.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP客户端**: 内置的HTTP客户端提供了一个优雅直观的界面，用于与API通信和获取数据。凭借内置的功能，如请求和响应拦截器、错误处理和基于观察器的响应，Angular
    HTTP客户端提供了处理HTTP逻辑所需的一切。'
- en: '`component` class and its corresponding template, facilitating data updates
    without manual intervention. In the Angular framework, data binding can be done
    in three ways: from the component class to the view by using the square bracket
    notation, from the view to the component class with events and the round bracket
    notation, and two-way data binding with the square and round bracket notation,
    also known as banana-in-a-box.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`component`类及其对应的模板，便于在不进行手动干预的情况下更新数据。在Angular框架中，数据绑定可以通过三种方式完成：使用方括号符号从组件类绑定到视图，使用事件和圆括号符号从视图绑定到组件类，以及使用方括号和圆括号符号进行双向数据绑定，也称为“盒子里的香蕉”。'
- en: '**Router**: The Angular Router facilitates the creation of single-page applications
    with dynamic routing capabilities. It enables developers to define routes and
    associate them with specific components, allowing seamless navigation between
    different views and pages within the application.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由器**: Angular Router简化了单页应用程序的创建，并具有动态路由功能。它允许开发者定义路由并将它们与特定的组件关联起来，从而实现应用程序内不同视图和页面之间的无缝导航。'
- en: '**Directives**: Angular directives are an essential building block of the framework
    and allow you to extend HTML elements with additional functionality and behavior
    or add and remove DOM elements.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指令**: Angular指令是框架的基石，允许您通过添加额外的功能和行为或添加和删除DOM元素来扩展HTML元素。'
- en: '**Pipes**: Pipes are used for transforming and formatting data within HTML
    templates. Using pipes helps to maintain clean and concise templates while avoiding
    excessive logic in the component code.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管道**: 管道用于在HTML模板中转换和格式化数据。使用管道有助于保持模板的整洁和简洁，同时避免在组件代码中过度使用逻辑。'
- en: '**Forms**: Forms are at the heart of each web application. Angular forms come
    in two types: **template-driven forms** and **reactive forms**. With features
    such as validation, error handling, and data synchronization, forms help you to
    develop robust applications.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表单**: 表单是每个Web应用的核心。Angular表单有两种类型：**模板驱动表单**和**响应式表单**。凭借验证、错误处理和数据同步等功能，表单有助于您开发健壮的应用程序。'
- en: These features are just some of the most powerful features the framework offers.
    Let’s move on and explore what the Angular team changed in the latest versions.
    The framework is changing rapidly, and new concepts and tools are being introduced
    to make Angular even more powerful and future-proof.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能只是框架提供的最强大功能中的一部分。让我们继续前进，探索Angular团队在最新版本中做了哪些更改。框架正在迅速变化，新的概念和工具正在被引入，以使Angular更加强大和面向未来。
- en: New features in the Angular framework
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular框架的新功能
- en: The world of web development is evolving rapidly, and because of that, frameworks
    such as Angular have to keep growing to stay relevant. In this section, we will
    explore what’s new in the Angular framework and why these changes are being made.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 网络开发的世界正在迅速发展，因此，像Angular这样的框架必须不断成长以保持相关性。在本节中，我们将探讨Angular框架中的新功能以及为什么进行这些更改。
- en: Standalone components
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立组件
- en: In Angular version 14, **standalone components** were introduced as a developer’s
    preview; version 15 released them for production usage. The Angular team introduced
    standalone components to simplify how we build Angular applications. Before standalone
    components, everything had to be declared in ngModules. Many developers dislike
    ngModules, and errors related to ngModules can be hard to resolve.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 14版本中，**独立组件**作为开发者预览被引入；15版本将其发布为生产使用。Angular团队引入独立组件是为了简化我们构建Angular应用程序的方式。在独立组件之前，所有内容都必须在ngModules中声明。许多开发者不喜欢ngModules，并且与ngModules相关的错误可能难以解决。
- en: With standalone components, you can build applications without ngModules. Components,
    directives, and pipes can be marked as standalone, and then they don’t have to
    be declared in an ngModule.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用独立组件，您可以在不使用ngModules的情况下构建应用程序。组件、指令和管道可以被标记为独立，然后它们不需要在ngModule中声明。
- en: 'In [*Chapter 1*](B21625_01.xhtml#_idTextAnchor014), we made Nx generators for
    libraries and applications and applied the standalone flag for both. Because of
    that, when we generated our Angular applications, they were created with standalone
    components. Let’s look at the decorator from the `app.component.ts` file in your
    `expenses-registration` application:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B21625_01.xhtml#_idTextAnchor014)中，我们为库和应用程序创建了Nx生成器，并为两者应用了独立标志。因此，当我们生成Angular应用程序时，它们是以独立组件创建的。让我们看看您`expenses-registration`应用程序中的`app.component.ts`文件中的装饰器：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you compare this to a non-standalone component, you might notice two things
    that are out of the ordinary: the `standalone` flag is set to `true`, the component
    becomes standalone. When something is standalone, it must import all its dependencies
    directly in the `imports` array instead of getting dependencies from an ngModule.
    For example, in `app.component.html`, we use the router outlet in the template,
    and because of that, the component needs to import `RouterModule`; you can also
    only import `RouterOutlet` instead.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将此与非独立组件进行比较，您可能会注意到两个不同寻常的地方：`standalone`标志设置为`true`，组件变为独立。当某物是独立的，它必须直接在`imports`数组中导入所有依赖项，而不是从ngModule中获取依赖项。例如，在`app.component.html`中，我们在模板中使用路由出口，因此组件需要导入`RouterModule`；您也可以只导入`RouterOutlet`。
- en: 'You can also create applications without any ngModules. To do this, bootstrap
    the application with a standalone component instead of an ngModule. We need to
    look at our `main.ts` file to see how this is done. In an application that uses
    ngModules, you will find something like this in the `main.ts` file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以创建不包含任何ngModules的应用程序。为此，使用独立组件而不是ngModule来引导应用程序。我们需要查看`main.ts`文件以了解如何实现这一点。在使用ngModules的应用程序中，您将在`main.ts`文件中找到类似以下内容：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this scenario, the Angular application bootstraps with the AppModule, the
    root ngModule. When you want to work without ngModules, you can change this and
    bootstrap with your root standalone component instead. If you look at the `main.ts`
    file of your *expenses-registration application*, you will find the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Angular应用程序使用AppModule（根ngModule）引导。当您想要在没有ngModules的情况下工作，您可以更改这一点，并用您的根独立组件代替引导。如果您查看`expenses-registration应用程序`的`main.ts`文件，您将找到以下内容：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we use the `bootstrapApplication` function instead of `bootstrapModule`.
    We provide the `bootstrapApplication` function with a standalone component and
    a configuration object. This configuration object configures things such as routing,
    the HTTP client, and third-party modules. We will come back to this configuration
    object a couple of times. For now, remember you can configure application settings
    here when bootstrapping with a standalone component.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用`bootstrapApplication`函数而不是`bootstrapModule`。我们向`bootstrapApplication`函数提供了一个独立组件和一个配置对象。此配置对象配置了诸如路由、HTTP客户端和第三方模块等内容。我们将在之后多次回到这个配置对象。现在，请记住，当使用独立组件引导时，您可以在此处配置应用程序设置。
- en: You can also mix ngModules with standalone components. If you have an application
    that already uses ngModules, you can start using standalone components alongside
    your existing code and leave your modules as-is.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将ngModules与独立组件混合使用。如果您有一个已经使用ngModules的应用程序，您可以在现有代码旁边开始使用独立组件，并保持您的模块不变。
- en: Now that you understand the basics of standalone components and how to use them,
    let’s explore the new `inject` function for dependency injection.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了独立组件的基础知识以及如何使用它们，让我们探索用于依赖注入的新`inject`函数。
- en: Dependency injection using the inject function
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`inject`函数进行依赖注入
- en: 'Another cool feature that was introduced in Angular 14 is the `inject` function,
    which is used as an alternative for constructor dependency injection. Up until
    now, constructor dependency injection was the only way to inject dependencies
    into your Angular applications:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 14中引入的另一个酷炫特性是`inject`函数，它是构造函数依赖注入的替代方案。到目前为止，构造函数依赖注入是向您的Angular应用程序注入依赖的唯一方式：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the `inject` function, we have an alternative approach that looks like
    this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`inject`函数，我们有一个类似以下替代方法：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we reach the *Dependency injection* section, we will dive deeper into
    this new syntax. For now, we will move on to the next new feature: directive composition.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达*依赖注入*部分时，我们将更深入地探讨这种新语法。现在，我们将继续探讨下一个新特性：指令组合。
- en: Directive composition
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令组合
- en: '`component` decorator. Each time you use the component in a template, the configured
    directives will be applied automatically without adding the directive to the HTML
    element. You can also use directive composition inside other directives, resulting
    in a directive that applies multiple directives. In [*Chapter 3*](B21625_03.xhtml#_idTextAnchor058),
    we will dive deeper into the topic of directive composition.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`component`装饰器。每次你在模板中使用组件时，配置的指令将自动应用，而无需将指令添加到HTML元素中。你还可以在其他指令内部使用指令组合，从而产生应用多个指令的指令。在[*第3章*](B21625_03.xhtml#_idTextAnchor058)中，我们将更深入地探讨指令组合的主题。'
- en: For now, you just need to know that you can configure directives inside the
    component decorators to share common behavior and reduce template complexity.
    Now that you know about directive composition, let’s explore Angular Signals a
    bit.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你只需要知道你可以在组件装饰器内部配置指令以共享常见行为并减少模板复杂性。现在你了解了指令组合，让我们稍微探索一下Angular Signal。
- en: Angular Signals
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular Signal
- en: '**Angular Signals** were introduced in Angular 16, and it’s one of the most
    significant changes for the framework since it went from AngularJS to Angular.
    In Angular 17, the framework also introduced Signal component inputs, and query
    Signals to query template elements using Signals. With Signals, we have a **reactive
    primitive** in the Angular framework with which we can manage the application
    state.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular Signal**是在Angular 16中引入的，这是Angular从AngularJS过渡到Angular以来框架最重要的变化之一。在Angular
    17中，框架还引入了Signal组件输入和查询Signal，用于使用Signal查询模板元素。有了Signal，我们在Angular框架中有一个**响应式原语**，可以用来管理应用程序状态。'
- en: 'Signals allow you to declare, compute, mutate, and consume values reactively,
    meaning the Signal will automatically notify all consumers when the Signal’s value
    changes. Because Signals are reactive, you can automatically react when a Signal’s
    value changes, performing logic or updating other values when a Signal is set
    with a new value. Signals wrap around values and expose them through a getter,
    which allows the Angular framework to track who is consuming the Signal and notify
    the consumers when the value changes. Signals can wrap around simple values or
    complex data structures and can be writable or read-only. Here’s a straightforward
    example of a Signal and a computed Signal value:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Signal允许你声明、计算、修改和消费值以响应式的方式，这意味着当Signal的值发生变化时，Signal将自动通知所有消费者。因为Signal是响应式的，所以当Signal的值发生变化时，你可以自动做出反应，当Signal被赋予新值时执行逻辑或更新其他值。Signal围绕值并通过对getter的暴露来提供它们，这使得Angular框架能够跟踪谁在消费Signal，并在值变化时通知消费者。Signal可以围绕简单值或复杂数据结构，可以是可写的或只读的。以下是一个Signal和计算出的Signal值的简单示例：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, we have a `count` `signal` value and a computed Signal
    that doubles the count. The computed Signal will automatically compute a new value
    when the `count` `signal` value changes. To better explain the advantages of Signals,
    let’s define what a reactive primitive is. In JavaScript, you have primitive and
    non-primitive values. The JavaScript primitives are `string`, `number`, `bigint`,
    `boolean`, `symbol`, `null`, and `undefined`. The non-primitives are objects.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个`count` `signal`值和一个计算出的信号，该信号将计数翻倍。当`count` `signal`值发生变化时，计算出的信号将自动计算新的值。为了更好地解释Signal的优势，让我们定义什么是响应式原语。在JavaScript中，你有原始值和非原始值。JavaScript的原始值有`string`、`number`、`bigint`、`boolean`、`symbol`、`null`和`undefined`。非原始值是对象。
- en: JavaScript non-primitives are reference types, meaning that if you assign them
    to a new variable, you don’t create a new object but make a reference to the existing
    object. Primitives don’t work like that; if you assign a string to a new variable,
    it doesn’t hold a reference to the original variable but it does create a new
    string. Primitives are immutable, and non-primitives are mutable. This means you
    can change a non-primitive after it’s created. If you reassign a string, it’s
    a new string and not the same string with a different value. When you adjust an
    object, it remains the same object, only with different values.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的非原始值是引用类型，这意味着如果你将它们分配给新变量，你不会创建一个新的对象，而是创建对现有对象的引用。原始值不是这样工作的；如果你将一个字符串分配给新变量，它不会持有原始变量的引用，而是创建一个新的字符串。原始值是不可变的，非原始值是可变的。这意味着你可以在创建非原始值之后修改它。如果你重新分配一个字符串，它是一个新的字符串，而不是具有不同值的相同字符串。当你调整对象时，它仍然是同一个对象，只是具有不同的值。
- en: A reactive primitive is an immutable value that alerts consumers when it’s set
    with a new value. All consumers can automatically track and react to changes in
    this reactive primitive.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式原语是一个不可变值，当它被设置为新值时，会通知消费者。所有消费者都可以自动跟踪并对此响应式原语的变化做出反应。
- en: Important note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The Signal itself is a reactive primitive and is immutable. You can only update
    the Signal and notify consumers of the Signal by using the `set()` or `update()`
    method on it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 信号本身是一个响应式原语，且是不可变的。你只能通过在信号上使用`set()`或`update()`方法来更新信号并通知信号的消费者。
- en: Yet, the value held by the Signal is not immutable! So, if you use a non-primitive
    (an object or array) as a Signal value, you can still mutate the value without
    updating the Signal itself.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，信号持有的值并不是不可变的！所以，如果你使用非原始值（一个对象或数组）作为信号值，你仍然可以更新值而不更新信号本身。
- en: Because Signals are reactive primitives, the Angular framework can better detect
    changes and optimize change detection and rendering, resulting in better performance.
    Signals are the first step to an Angular version with fully fine-grained change
    detection that doesn’t need `Zone.js` to detect changes based on browser events.
    At the time of writing, Angular assumes that any triggered browser event handler
    can change any data bound to a template. Because of that, each time a browser
    event is triggered, Angular checks the entire component tree for changes because
    it can’t detect them in a fine-grained manner. This is a significant drain on
    resources and impacts performance negatively.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于信号是响应式原语，Angular框架可以更好地检测变化并优化变化检测和渲染，从而提高性能。信号是迈向Angular版本的第一步，该版本具有完全细粒度变化检测，无需`Zone.js`根据浏览器事件检测变化。在撰写本文时，Angular假设任何触发的浏览器事件处理器都可以更改绑定到模板的任何数据。正因为如此，每次浏览器事件被触发时，Angular都会检查整个组件树以查找变化，因为它无法以细粒度方式检测它们。这会显著消耗资源并负面地影响性能。
- en: In [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129), we will dive deeper into
    Signals and look at different implementations and how you can combine them with
    RxJS. For now, you just need to know that Signals can be used to manage application
    state and that they introduce a reactive primitive, which can significantly improve
    the reactivity and performance of your Angular applications.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B21625_07.xhtml#_idTextAnchor129)中，我们将更深入地探讨信号，并查看不同的实现以及如何将它们与RxJS结合使用。现在，你只需要知道信号可以用来管理应用程序状态，并且它们引入了一个响应式原语，这可以显著提高你的Angular应用程序的反应性和性能。
- en: Now that you know what Signals are and why they are important, let’s learn about
    the new Angular control flow system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了信号是什么以及为什么它们很重要，让我们来学习新的Angular控制流系统。
- en: Angular control flow
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular控制流
- en: The control flow system was introduced in Angular 17 and provides a new mechanism
    to show, hide, and repeat elements inside HTML templates. Until Angular 17, you
    could only use the `*ngIf`, `*ngFor`, and `*ngSwitch` directives to show, hide,
    or repeat elements inside the HTML templates.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流系统是在Angular 17中引入的，它提供了一个新的机制来在HTML模板中显示、隐藏和重复元素。在Angular 17之前，你只能使用`*ngIf`、`*ngFor`和`*ngSwitch`指令在HTML模板中显示、隐藏或重复元素。
- en: 'As of Angular 17, you can use both the directives and the new control flow
    system interchangeably. Let’s look at an example for each option using the new
    control flow syntax, starting with the `@if` control flow:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 截至Angular 17，你可以互换使用指令和新的控制流系统。让我们使用新的控制流语法查看每个选项的示例，从`@if`控制流开始：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the new control flow syntax uses `@if`, `@else if`, and `@else`
    to define `if`-`else` statements inside your HTML templates. The new control flow
    syntax makes it a lot easier to create `if`-`else` statements. You can use both
    the control flow and the directive syntax, so pick whichever you and your team
    prefer. Now that you’ve seen an example of the `@if` control flow, let’s see how
    you can repeat elements inside the template using the new control flow syntax:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，新的控制流语法使用`@if`、`@else if`和`@else`来在HTML模板内定义`if`-`else`语句。新的控制流语法使得创建`if`-`else`语句变得容易得多。你可以使用控制流和指令语法，所以选择你和你团队更喜欢的。现在你已经看到了`@if`控制流的例子，让我们看看如何使用新的控制流语法在模板内重复元素：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `@for` syntax can be used interchangeably with the `*ngFor` directive.
    The new control flow syntax requires you to define a `track` property. You assign
    the `track` property with a unique identifier such as an ID, which allows Angular
    to only re-render changed items when the list you are rendering changes. You can
    also provide an `@empty` block to display something when the array provided to
    the `@for` block is empty. Now that you know how to repeat elements inside your
    template with the new control flow syntax, let’s learn about the alternative for
    the `*``ngSwitch` directive:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`@for` 语法可以与 `*ngFor` 指令互换使用。新的控制流语法要求你定义一个 `track` 属性。你将 `track` 属性分配给一个唯一的标识符，例如
    ID，这允许 Angular 只在渲染的列表发生变化时重新渲染更改的项目。你还可以提供一个 `@empty` 块，在提供给 `@for` 块的数组为空时显示内容。现在，你已经知道了如何使用新的控制流语法在模板中重复元素，让我们来了解
    `*ngSwitch` 指令的替代方案：'
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Just as with the other control flow blocks, you can use the `@switch` block
    interchangeably with the `*ngSwitch` directive. The new Angular control flow also
    introduced a new concept: the `@``defer` block.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他控制流块一样，你可以使用 `@switch` 块与 `*ngSwitch` 指令互换。新的 Angular 控制流还引入了一个新概念：`@defer`
    块。
- en: 'The `@defer` block allows you to lazy-load components or native HTML elements
    inside your HTML templates. The `@defer` block can lazy load and display elements
    based on different triggers, such as when a condition is met, when the elements
    enter the viewport, when the users interact with the placeholder, or based on
    a timer. The `@defer` block can improve your performance because fewer components
    have to be loaded when the user lands on a page. Additionally, the `@defer` block
    reduces the bundle sizes as lazy-loaded page elements don’t have to be included
    in the initial application bundle. Here’s an example of the `@defer` block with
    a placeholder:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`@defer` 块允许你在 HTML 模板中懒加载组件或原生 HTML 元素。`@defer` 块可以根据不同的触发条件懒加载和显示元素，例如当条件满足时、当元素进入视口时、当用户与占位符交互时，或者基于计时器。`@defer`
    块可以提高性能，因为当用户访问页面时，不需要加载那么多的组件。此外，`@defer` 块减少了包的大小，因为懒加载的页面元素不需要包含在初始应用程序包中。以下是一个带有占位符的
    `@defer` 块的示例：'
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that you know about the new control flow syntax, let’s explore the remainder
    of the features that were introduced by the Angular framework.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了新的控制流语法，让我们来探索 Angular 框架引入的其他功能。
- en: Other noteworthy new Angular features
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他值得注意的新 Angular 功能
- en: 'Before we move on to the next section of this chapter, we will briefly go over
    other noteworthy improvements that have been made to the Angular framework:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入本章的下一节之前，我们将简要回顾对 Angular 框架所做的其他值得注意的改进：
- en: '**Types forms**: In Angular 14, reactive forms were made fully type-safe. The
    values inside form controls, groups, and arrays are now type-safe across the entire
    API of reactive forms, enabling safer forms.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型表单**：在 Angular 14 中，响应式表单被完全类型安全化。现在，表单控件、组和数组中的值在整个响应式表单 API 中都是类型安全的，从而使得表单更加安全。'
- en: '`title` property to your route configurations. This `title` property will set
    the page title without other implementations needed.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `title` 属性添加到你的路由配置中。此 `title` 属性将设置页面标题，而无需其他实现。
- en: '`NgOptimizedImage` is a built-in image directive for optimized image fetching,
    rendering, and sizing. It has been stable for usage since Angular 15.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgOptimizedImage` 是一个用于优化图像获取、渲染和大小的内置图像指令。自 Angular 15 以来，它已经稳定可用。'
- en: '**Functional approach**: Since Angular 15, you can use a functional approach
    for HTTP interceptors, route resolvers, and route guards.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数式方法**：自 Angular 15 以来，你可以使用函数式方法进行 HTTP 拦截器、路由解析器和路由守卫。'
- en: '**Route parameter mapping**: This feature allows you to automatically map route
    data, query parameters, and path parameters to your component inputs. Because
    of this, you don’t have to subscribe anymore, reducing complexity and boilerplate.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由参数映射**：此功能允许你自动将路由数据、查询参数和路径参数映射到你的组件输入。因此，你不再需要订阅，从而减少了复杂性和样板代码。'
- en: '`OnDestroy` injectable, which allows you to inject `DestroyRef` and access
    the `OnDestroy` life cycle hook more flexibly. It allows you to subscribe to the
    `OnDestroy` life cycle as well as inject it outside of your components.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDestroy` 注入器，它允许你注入 `DestroyRef` 并更灵活地访问 `OnDestroy` 生命周期钩子。它允许你订阅 `OnDestroy`
    生命周期，以及在你的组件外部注入它。'
- en: '**Self-closing tags**: In Angular 16, you can use a self-closing tag for your
    component selectors. This can improve the readability of your HTML templates.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自闭合标签**：在 Angular 16 中，你可以为你的组件选择器使用自闭合标签。这可以提高你的 HTML 模板的可读性。'
- en: '**Required inputs**: In Angular 16, you can make component inputs *required*.
    If no input is provided in the template, the compiler will specify an error.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**必需输入**：在 Angular 16 中，你可以使组件输入成为必需的。如果在模板中没有提供输入，编译器将指定一个错误。'
- en: There are more newly added features, such as Vite support and better page hydration,
    but the ones we mentioned in this section are the most important for your daily
    development practices.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多新添加的功能，例如 Vite 支持，以及更好的页面激活，但本节中提到的功能对你的日常开发实践来说是最重要的。
- en: Now that you know about the new features that have been added to the Angular
    framework, we will move on and do deep dives into specific topics, starting with
    the Angular router.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了添加到 Angular 框架中的新功能，我们将继续深入探讨特定主题，从 Angular 路由开始。
- en: A deep dive into Angular routing
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解 Angular 路由
- en: This section will teach you about the **Angular router**, a powerful tool that
    handles navigation in your Angular applications. The router is responsible for
    seamless transitions without full page loads, updating the browser URL, as well
    as handling route data, redirects, query parameters, path parameters, route resolvers,
    and guarding routes from unauthorized visitors.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍 **Angular 路由**，这是一个强大的工具，用于处理 Angular 应用程序中的导航。路由器负责实现无缝的页面转换，更新浏览器 URL，以及处理路由数据、重定向、查询参数、路径参数、路由解析器，以及保护路由免受未经授权的访问者。
- en: Let’s start by creating two new components we can navigate to.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建两个新的组件，我们可以导航到它们。
- en: Creating new components
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新组件
- en: We are going to use an Nx generator for this. You can write a custom generator,
    but I will use the built-in component generator for now. Right-click on the `app`
    folder inside your `expenses-registration` folder and select the Nx console. In
    the dropdown, search for `component` and select **@nx/angular -** **component**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个 Nx 生成器来完成这个任务。你可以编写一个自定义生成器，但我现在将使用内置的组件生成器。在你的 `expenses-registration`
    文件夹内的 `app` 文件夹上右键点击，并选择 Nx 控制台。在下拉菜单中，搜索 `component` 并选择 **@nx/angular -** **component**。
- en: 'Follow these steps to generate the necessary components:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤生成必要的组件：
- en: In the `pages/expenses-overview-page`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `pages/expenses-overview-page`。
- en: Check the **standalone** checkbox.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **独立** 复选框。
- en: Click **Show** **all options**.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **显示所有选项**。
- en: In the **changeDetection** select box, select **OnPush**.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **变更检测** 选择框中，选择 **OnPush**。
- en: In the top-right corner, click **Generate**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在右上角，点击 **生成**。
- en: Once you’ve completed these steps, repeat the same steps for creating the second
    component. You will only change the name to `pages/expenses-approval-page`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，重复相同的步骤来创建第二个组件。你只需将名称更改为 `pages/expenses-approval-page`。
- en: 'Now, let’s serve the*finance-expenses-registration application* with this command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令来运行 *finance-expenses-registration 应用程序*：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can also use the Nx console to serve your application. Just select the application
    under the **PROJECTS** tab and click on the **play** button after hovering over
    **serve**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 Nx 控制台来运行你的应用程序。只需在 **项目** 选项卡下选择应用程序，并在悬停在 **运行** 上后点击 **播放** 按钮。
- en: When you open the application at `http://localhost:4200/`, you’ll see a white
    screen. This is because you only have a router outlet in your `app.component.html`
    file, which displays the current route, and no routes have been configured for
    our application yet.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 `http://localhost:4200/` 打开应用程序时，你会看到一个空白屏幕。这是因为你只在 `app.component.html`
    文件中有一个路由出口，它显示当前路由，而我们还没有为我们的应用程序配置任何路由。
- en: Your application is running, and two components are ready to route to, so let’s
    configure some routes for your application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序正在运行，并且有两个组件可以路由，所以让我们为你的应用程序配置一些路由。
- en: Configuring routes in Angular applications
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Angular 应用程序中的路由
- en: 'Before `RouterModule` and providing it with routes in a `forRoot` or `forChild`
    method. Because we’re using the latest Angular techniques, we won’t use ngModules.
    When bootstrapping with a standalone component, your routing is configured differently.
    When you open the `main.ts` file, you’ll see an `appConfig` object being passed
    to the `bootstrapApplication` function. Open your `app.config.ts` file to locate
    this `appConfig` object. Inside, you’ll find your routing configurations:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RouterModule`之前，我们通过在`forRoot`或`forChild`方法中提供路由来配置它。因为我们使用的是最新的Angular技术，所以我们将不会使用ngModules。当你使用独立组件启动时，你的路由配置方式不同。当你打开`main.ts`文件时，你会看到一个`appConfig`对象被传递给`bootstrapApplication`函数。打开你的`app.config.ts`文件以定位这个`appConfig`对象。在里面，你会找到你的路由配置：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Routing is configured by adding the `provideRouter` function inside the `providers`
    array of the `ApplicationConfig` object. When Nx created the application, it already
    set this up for us.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是通过在`ApplicationConfig`对象的`providers`数组中添加`provideRouter`函数来配置的。当Nx创建应用程序时，它已经为我们设置了这一点。
- en: Inside the `provideRouter` function, you’ll find an array of `Route` objects
    and a `with` **EnabledBlockingInitialNavigation** function, which is required
    for routing with server-side rendering. We aren’t using server-side rendering,
    so you can delete `with``EnabledBlockingInitialNavigation`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`provideRouter`函数内部，你会找到一个`Route`对象的数组和一个`with` **EnabledBlockingInitialNavigation**函数，后者是使用服务器端渲染进行路由所必需的。我们并没有使用服务器端渲染，所以你可以删除`with`**EnabledBlockingInitialNavigation**。
- en: 'Open your `app.routes.ts` file to set up the routes for your application. To
    start, we will add two `Route` objects inside the `appRoutes` array – one for
    the expenses approval page and another for the expenses overview page:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的`app.routes.ts`文件来设置你应用程序的路由。首先，我们将在`appRoutes`数组中添加两个`Route`对象——一个用于费用审批页面，另一个用于费用概览页面：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, each object has two properties: a `path` property to define
    the URL path and a `component` property for specifying the loaded component when
    we reach the path. For `ExpensesOverviewPageComponent`, we configured `expenses-overview`,
    which means it’s accessible at `http://localhost:4200/expenses-overview`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个对象都有两个属性：一个用于定义URL路径的`path`属性，一个用于指定当我们到达路径时加载的组件的`component`属性。对于`ExpensesOverviewPageComponent`，我们配置了`expenses-overview`，这意味着它可以通过`http://localhost:4200/expenses-overview`访问。
- en: 'When you navigate to this URL, you’ll see `Router` as a dependency. Then, you
    can use this syntax:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导航到这个URL时，你会看到`Router`作为一个依赖项。然后，你可以使用以下语法：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can navigate instead your HTML templates with `routerLink`, like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`routerLink`来导航你的HTML模板，如下所示：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that you’ve configured two routes, let’s explore what else you can configure
    in your route configurations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经配置了两个路由，让我们来看看你还可以在你的路由配置中配置什么。
- en: Route configuration options
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由配置选项
- en: In this section, you will make your routing more robust and explore properties
    you can configure on your route objects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将使你的路由更加健壮，并探索你可以在你的路由对象上配置的属性。
- en: Adding page titles
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加页面标题
- en: 'The `title` property was added in Angular 14 and is used to set HTML page titles
    dynamically. Before Angular 14, you needed subscriptions and a lot of logic to
    set the page title. With the introduction of the `title` property, Angular handles
    all of that behind the scenes and sets the page title for you. You can set your
    titles with a simple string or `ResolveFn<T>`. When you use a string, you can
    use the following syntax:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`title`属性是在Angular 14中添加的，用于动态设置HTML页面标题。在Angular 14之前，你需要订阅和大量的逻辑来设置页面标题。随着`title`属性的引入，Angular在幕后处理所有这些，并为你设置页面标题。你可以使用简单的字符串或`ResolveFn<T>`来设置你的标题。当你使用字符串时，你可以使用以下语法：'
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will use `ResolveFn<T>` to set page titles dynamically, like so:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ResolveFn<T>`来动态设置页面标题，如下所示：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a simple example where we take the route path and replace the hyphen
    with a space, but you can add any logic you want. Once you’ve defined your title
    resolver, you can assign it to your route configuration like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，我们取路由路径并将连字符替换为空格，但你可以添加任何你想要的逻辑。一旦你定义了你的标题解析器，你就可以像这样将其分配给你的路由配置：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also overwrite the default behavior Angular uses to add the titles
    to your pages by overwriting the `TitleStrategy` class. This is only useful in
    edge cases, but it’s good to know it’s possible. We won’t cover an example in
    this book, but you can find a simple overwrite of `TitleStrategy` in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Effective-Angular/blob/main/apps/finance/expenses-registration/src/app/app.routes.ts](https://github.com/PacktPublishing/Effective-Angular/blob/main/apps/finance/expenses-registration/src/app/app.routes.ts).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过覆盖 `TitleStrategy` 类来覆盖 Angular 用于向页面添加标题的默认行为。这仅在边缘情况下有用，但了解这是可能的总是好的。本书中不会涵盖示例，但你可以在本书的
    GitHub 仓库中找到简单的 `TitleStrategy` 覆盖：[https://github.com/PacktPublishing/Effective-Angular/blob/main/apps/finance/expenses-registration/src/app/app.routes.ts](https://github.com/PacktPublishing/Effective-Angular/blob/main/apps/finance/expenses-registration/src/app/app.routes.ts)。
- en: Lazy loading standalone components
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 懒加载独立组件
- en: '`loadComponent` property in your route configuration.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadComponent` 属性在你的路由配置中。'
- en: 'Since Angular 15, the router also supports automated unwraps of default imports.
    With automated unwraps, you don’t need the `.then()` method to be chained to unwrap
    your import for the router. Because of this, we can make the syntax for lazy loading
    shorter and easier. Change your routes to lazy-loaded routes by changing the export
    of your component classes to `default` exports, like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Angular 15 以来，路由也支持默认导入的自动展开。使用自动展开，你不需要将 `.then()` 方法链式调用以展开路由的导入。因此，我们可以使懒加载的语法更短、更简单。通过将你的组件类的导出改为
    `default` 导出，将你的路由改为懒加载路由，如下所示：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once you’ve done this, you can configure lazy-loaded routes like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一次完成这些后，你可以这样配置懒加载路由：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Do the same for your other route so that all your routes are lazy-loaded.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的其他路由做同样的操作，以确保所有路由都是懒加载的。
- en: Next, we will learn how to use multiple router outlets and auxiliary routes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用多个路由出口和辅助路由。
- en: Router outlets and auxiliary routes
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由出口和辅助路由
- en: If you want to develop dynamic user interfaces while reducing your bundle sizes
    even more, **named router outlets** are a great way to achieve this. We won’t
    implement named router outlets, but I do want to explain how they work.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在减少包大小的同时开发动态用户界面，**命名路由出口**是一个实现这一目标的好方法。我们不会实现命名路由出口，但我确实想解释它们是如何工作的。
- en: 'With named router outlets, you can lazy load specific sections of your pages
    and lazy load different components for these page sections based on your application
    state. You can, for example, display different sidebars on each page or even on
    the same page based on application states. Because you can lazy load these sidebar
    components, they will not be part of your main application bundle and will only
    be loaded when displayed. To use named router outlets, you need to configure a
    route with an `outlet` property, like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名路由出口，你可以懒加载页面特定部分，并根据应用状态懒加载这些页面部分的组件。例如，你可以根据应用状态在每一页或同一页上显示不同的侧边栏。因为你可以懒加载这些侧边栏组件，所以它们不会成为你的主应用包的一部分，只有在显示时才会加载。要使用命名路由出口，你需要配置一个具有
    `outlet` 属性的路由，如下所示：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <router-outlet name="sidebar"><router-outlet/>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`<router-outlet name="sidebar"><router-outlet/>`'
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'this.router.navigate([''path'', { outlets: { sidebar: ''path''} }]);'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`this.router.navigate([''path'', { outlets: { sidebar: ''path''} }]);`'
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[routerLink]="[''path'', { outlets: { sidebar: ''path''} }]"'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`[routerLink]="[''path'', { outlets: { sidebar: ''path''} }]"'
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '{ path: ''……'', loadComponent: ……,'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`{ path: ''……'', loadComponent: ……,`'
- en: 'canActivate: [IsLoggedInGuard, IsAdminGuard],'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`canActivate: [IsLoggedInGuard, IsAdminGuard],`'
- en: 'canDeactivate: [hasDoneSomeTaskGuard] },'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`canDeactivate: [hasDoneSomeTaskGuard] },`'
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '{ path: ''dashboard'', component: DashboardComponent,'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`{ path: ''dashboard'', component: DashboardComponent,`'
- en: 'children: [{ path: ''summary'', component: SummaryComponent }]}'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`children: [{ path: ''summary'', component: SummaryComponent }]}`'
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '{ path: ''**'', component: NotFoundComponent }'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`{ path: ''**'', component: NotFoundComponent }`'
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '{ path: '''', pathMatch: ''full'', redirectTo: ''/expenses-overview'' }'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`{ path: '''', pathMatch: ''full'', redirectTo: ''/expenses-overview'' }`'
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'export const userDataResolver: ResolveFn<User> = ('
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`export const userDataResolver: ResolveFn<User> = (`'
- en: 'route: ActivatedRouteSnapshot) => inject(UserService)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`route: ActivatedRouteSnapshot) => inject(UserService)`'
- en: .getUserData(route.paramMap.get("userId")).catch(……);
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`.getUserData(route.paramMap.get("userId")).catch(……);`'
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '{ path: ''path'', resolve: productResolver, component: ……},'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`{ path: ''path'', resolve: productResolver, component: ……},`'
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: protected readonly route = inject(ActivatedRoute)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected readonly route = inject(ActivatedRoute)`'
- en: ngOnInit() { this.route.snapshot.data; }
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnInit() { this.route.snapshot.data; }`'
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: export * from './lib/navbar/navbar.component';
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`export * from ''./lib/navbar/navbar.component'';`'
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'export interface NavbarItem {label: string; route: string;}'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'export interface NavbarItem {label: string; route: string;}'
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '@Input() is a decorator for the navbarItems field that tells the Angular compiler
    that the property can receive input from parent components. We gave the field
    a NavbarItem array type and an empty array’s default value. If you don’t give
    it a default value, the compiler will start to complain; you can prevent this
    by adding an exclamation mark after the property’s name, like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input()` 是 `navbarItems` 字段的装饰器，它告诉 Angular 编译器该属性可以接收来自父组件的输入。我们给字段分配了 NavbarItem
    数组类型和一个空数组的默认值。如果你不提供默认值，编译器将开始抱怨；你可以通过在属性名称后添加一个感叹号来防止这种情况，如下所示：'
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'navItems: NavbarItem[] = [navItems array to the navbar component using the
    navbarItems input property. We can do this in the HTML template of the app component,
    where we declare the HTML selector tag for the navbar component. You can pass
    the navItems array as input using this syntax:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`navItems`: NavbarItem[] = 使用 `navbarItems` 输入属性将 `navItems` 数组传递给导航栏组件。我们可以在应用程序组件的
    HTML 模板中这样做，在那里我们声明导航栏组件的 HTML 选择器标签。你可以使用此语法传递 `navItems` 数组作为输入：'
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: On the left-hand side, between the square brackets, you’ll use the property
    name of the input property that’s declared inside the `navbar` component – in
    our case `navbarItems`. On the right-hand side, you must assign the input with
    a value that’s declared in the parent component – in our case, the `navItems`
    array.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，方括号之间，你将使用在 `navbar` 组件内部声明的输入属性的属性名——在我们的例子中是 `navbarItems`。在右侧，你必须分配一个在父组件中声明的值作为输入——在我们的例子中是
    `navItems` 数组。
- en: 'It is important to know that when a component receives input values, the `ngOnChanges`
    life cycle hook is triggered – once this component has been created, before the
    `ngOnInit` life cycle hook runs, and then once more every time an input receives
    a new value. You can access the previous and new input values inside the `ngOnChanges`
    method like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，当一个组件接收到输入值时，`ngOnChanges` 生命周期钩子会被触发——一旦这个组件被创建，在 `ngOnInit` 生命周期钩子运行之前，然后每次输入接收到新值时再次触发。你可以在
    `ngOnChanges` 方法中这样访问先前和新的输入值：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The current value inside the `SimpleChanges` object should be equal to the value
    of the input property declared in the component. So, if you need the current value,
    you can also access the component property. In our example, this would be `navbarItems`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleChanges` 对象中的当前值应该等于组件中声明的输入属性的值。因此，如果你需要当前值，你也可以访问组件属性。在我们的例子中，这将是指
    `navbarItems`。'
- en: The `ngOnChanges` life cycle hook is a good place to perform extra logic when
    you receive an input value. Still, this can become messy when you have a lot of
    input properties and want to perform logic for each when they receive a new value.
    If this is the case, or if you want to transform the value into something else,
    you can use the `@Input()` decorator as a getter and setter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnChanges` 生命周期钩子是在接收到输入值时执行额外逻辑的好地方。然而，当你有很多输入属性并且想要为每个属性接收新值时执行逻辑，这可能会变得很混乱。如果这种情况发生，或者你想将值转换成其他形式，你可以使用
    `@Input()` 装饰器作为获取器和设置器。'
- en: 'Let’s say we want to add `NavbarItem` for the home page to our input each time
    it receives values so that we don’t have to declare the home page and its route
    inside the object we pass as input to the `navbar` component. We can do this by
    transforming the input into an input with a getter and setter. Start by adding
    a private property to the `navbar` component, like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望在每次接收到值时都为主页添加 `NavbarItem` 到我们的输入中，这样我们就不必在传递给 `navbar` 组件的输入对象中声明主页及其路由。我们可以通过将输入转换为具有获取器和设置器的输入来实现这一点。首先，向
    `navbar` 组件添加一个私有属性，如下所示：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, change the `navbarItems` input property to a getter and setter and use
    the private property inside the getter and setter, like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将 `navbarItems` 输入属性更改为获取器和设置器，并在获取器和设置器中使用私有属性，如下所示：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '@Input({addHome with the transformation logic. You can add this function to
    a separate file or the same file underneath the navbar component class. The function
    looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用转换逻辑添加 `@Input({addHome})`。你可以将此函数添加到单独的文件或位于导航栏组件类下面的同一文件中。函数看起来像这样：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That’s all you need; no more private property or getter and setter needed for
    transforming input values! If you need to perform other logic, such as setting
    component properties or running functions inside the `component` class, you can
    still use the getter and setter approach.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你所需要的；不需要更多的私有属性或 getter 和 setter 来转换输入值！如果你需要执行其他逻辑，例如设置组件属性或在 `component`
    类内部运行函数，你仍然可以使用 getter 和 setter 方法。
- en: 'Lastly, since Angular 16, you can also make input properties required. When
    you make an input property required, it needs to be declared on the HTML tag when
    the component is used in a component’s template. The parent that’s using the component
    in its template must add the input property to the HTML tags and pass it a valid
    value; otherwise, the compiler will throw an error. To make our `navbarItem` input
    property required, we can change the input decorator like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于 Angular 16 的推出，你还可以使输入属性成为必需。当你使输入属性成为必需时，它需要在组件在组件模板中使用时在 HTML 标签上声明。在模板中使用组件的父组件必须将输入属性添加到
    HTML 标签中，并传递一个有效的值；否则，编译器将抛出错误。为了使我们的 `navbarItem` 输入属性成为必需，我们可以像这样更改输入装饰器：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '@output decorator and the property name for our EventEmitter. On the right-hand
    side, we assign the property with new EventEmitter, and between the arrow symbols
    we add the type we wish to emit – in this example, this is tableData.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`@output` 装饰器和我们的 EventEmitter 的属性名。在右侧，我们将属性分配给新的 EventEmitter，并在箭头符号之间添加我们希望发出的类型
    - 在这个例子中，这是 tableData。'
- en: 'Next, you need to listen for the `dataChanged` event in the HTML template of
    a parent component where the data table component would be defined. Listening
    for `@Output` works the same as listening for regular DOM events such as *click*
    and *mouseleave*:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在父组件的 HTML 模板中监听 `dataChanged` 事件，其中定义了数据表组件。监听 `@Output` 与监听常规 DOM 事件（如
    *click* 和 *mouseleave*）的工作方式相同：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'this.dataChanged.dataChanged property and call the .emit() method on it. You
    can pass whatever value you want to emit to the parent component inside the brackets.
    In this example, that would be the updated table data. To better illustrate how
    the input and output mechanism works, *Figure 2**.1* shows how data flows from
    the parent to the child and vice versa:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 this.dataChanged.dataChanged 属性上调用 .emit() 方法。你可以在括号内传递你想要向父组件发出的任何值。在这个例子中，这将是最新的表格数据。为了更好地说明输入和输出机制的工作原理，*图
    2**.1* 展示了数据从父组件流向子组件以及相反的过程：
- en: '![Figure 2.1: Hierarchical dependency creation](img/B21625_02_1.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1：层次依赖创建](img/B21625_02_1.jpg)'
- en: 'Figure 2.1: Hierarchical dependency creation'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：层次依赖创建
- en: Now that you also know how to emit events to the parent component using the
    `@output` decorator, let’s explore how we can combine the input and output decorators
    to create custom two-way data bindings.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何使用 `@output` 装饰器向父组件发出事件，让我们探索如何结合输入和输出装饰器来创建自定义的双向数据绑定。
- en: Two-way data binding using @Input and @Output
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 @Input 和 @Output 的双向数据绑定
- en: '`select` drop-down component with two input properties, one for the select
    options and one for the selected option. Besides this, the component also has
    a `selectionChanged` output to emit a value when a new selection is made.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`select` 下拉组件具有两个输入属性，一个用于选择选项，另一个用于选中选项。除此之外，该组件还有一个 `selectionChanged` 输出，当进行新的选择时，会发出一个值。'
- en: 'In the parent component, we have a property for the currently selected value
    of the select component. This property is used as an input for the selected input
    and needs to be updated whenever a new value is selected and the `selectionChanged`
    output is emitted. To achieve this, you must have something like the following
    inside the template of the parent component:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在父组件中，我们有一个用于选择组件当前选中值的属性。这个属性被用作选中输入的输入，并且每当选择新的值并且发出 `selectionChanged` 输出时，需要更新这个属性。为了实现这一点，你必须在父组件的模板内部有类似以下的内容：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can improve the preceding code snippet with two-way data binding and the
    banana-in-a-box syntax. For two-way data binding to work, the input and output
    properties in the child component must have the same name; only the output needs
    to add `changed` after the name. So, in our example, the input is named `selected`,
    which means the output needs to be named `selectedChanged`. When we use this naming
    convention, Angular knows to handle it as two-way data binding.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过双向数据绑定和香蕉盒语法来改进前面的代码片段。为了使双向数据绑定工作，子组件中的输入和输出属性必须具有相同的名称；只需要在名称后添加 `changed`。因此，在我们的例子中，输入被命名为
    `selected`，这意味着输出需要被命名为 `selectedChanged`。当我们使用这种命名约定时，Angular 会知道将其处理为双向数据绑定。
- en: 'To use two-way data binding, in the parent component, we must update the HTML
    like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用双向数据绑定，在父组件中，我们必须更新 HTML 如下所示：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: <select [(selected)]= "selectedValue" />
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`<select [(selected)]= "selectedValue" />`'
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: <select [selected]= "selectedValue" (selectedChanged)="this. selectedValue =
    $event" />
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`<select [selected]= "selectedValue" (selectedChanged)="this.selectedValue
    = $event" />`'
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '@ViewChild(NavbarComponent) navBar!: NavbarComponent;'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '@ViewChild(NavbarComponent) navBar!: NavbarComponent;'
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: this.navBar.navbarItems;
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: this.navBar.navbarItems;
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'const routes = [{ path: ''dashboard/:id'','
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'const routes = [{ path: ''dashboard/:id'','
- en: 'component: DashboardComponent,'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 'component: DashboardComponent,'
- en: 'data: {caption: ''Dashboard caption''},'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'data: `{caption: ''Dashboard caption''}`,'
- en: 'resolve: {permissions: DashboardResolver}}]'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'resolve: `{permissions: DashboardResolver}}]`'
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: private route = inject(ActivatedRoute);
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: private route = inject(ActivatedRoute);
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: this.route.snapshot.paramMap.get('id');
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: this.route.snapshot.paramMap.get('id');
- en: this.route.snapshot.queryParamMap.get('queryParam');
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: this.route.snapshot.queryParamMap.get('queryParam');
- en: this.route.snapshot.data['caption'];
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: this.route.snapshot.data['caption'];
- en: this.route.snapshot.data['permissions'];
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: this.route.snapshot.data['permissions'];
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: this.route.queryParamMap.subscribe(……)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: this.route.queryParamMap.subscribe(……)
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'provideRouter(appRoutes, component class, like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 提供路由器（appRoutes，组件类，如下所示：
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you want to use a different property name, you can alias the inputs like
    this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用不同的属性名称，您可以像这样为输入创建别名：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will probably give you a linting error because aliasing inputs is not recommended,
    but when using input aliases for binding your route data, it’s not a bad practice.
    So, in this case, you can disable the linting rule if it’s throwing an error.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会给您带来一个 linting 错误，因为不建议别名输入，但使用输入别名绑定路由数据时，这不是一个坏习惯。因此，在这种情况下，如果您遇到错误，可以禁用
    linting 规则。
- en: Now that you know everything about component communication using decorators
    and route data, we will start to look at dependency injection, which can be used
    to provide data to every part of your application.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了使用装饰器和路由数据进行组件通信的所有内容，我们将开始探讨依赖注入，它可以用于向应用程序的每个部分提供数据。
- en: Dependency injection
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入
- en: '`@Injectable()` decorator), but they can be strings, functions, or anything
    else you want to provide throughout your application.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Injectable()` 装饰器)，但它们可以是字符串、函数或您希望在应用程序中提供的任何其他内容。'
- en: The `Injector` abstraction is the core element of the Angular dependency injection
    system and facilitates the connection between providers and consumers of your
    dependencies. Make sure you distinguish `Injector` from the `@Injectable()` decorator,
    which marks a class as a candidate for dependency injection. The `Injector` abstraction
    checks if an instance of a dependency has already been created and provides it
    if the dependency has already been registered; it provides the dependency and
    registers if it hasn’t been registered before. When your application is bootstrapped,
    Angular creates an application-wide *root* `Injector` and makes other injectors
    as needed for all dependencies that aren’t accessible throughout the application.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Injector` 抽象是 Angular 依赖注入系统的核心元素，它促进了依赖项提供者和消费者之间的连接。确保您区分 `Injector` 和 `@Injectable()`
    装饰器，后者将类标记为依赖注入的候选者。`Injector` 抽象检查依赖项的实例是否已经创建，如果依赖项已经注册，则提供它；如果没有注册，则提供依赖项并注册。当您的应用程序启动时，Angular
    创建一个应用程序范围的 *root* `Injector`，并为所有应用程序中不可访问的依赖项创建所需的其他 `Injector`。'
- en: Providing dependencies
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 提供依赖项
- en: You can provide classes and other values such as strings, dates, objects, and
    functions as dependencies. Both are provided differently. We will start with the
    most common use case, which is providing classes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以提供类和其他值，如字符串、日期、对象和函数作为依赖项。两者提供方式不同。我们将从最常见的情况开始，即提供类。
- en: Providing classes as dependencies
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 提供作为依赖项的类
- en: 'When you provide a class in Angular, it’s most likely an Angular service, but
    you can provide any class through dependency injection. The most common way to
    prepare a class for dependency injection is to decorate it with the `@Injectable()`
    decorator, like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在Angular中提供类时，它很可能是Angular服务，但您可以通过依赖注入提供任何类。准备类以进行依赖注入的最常见方法是使用`@Injectable()`装饰器，如下所示：
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `@Injectable()` decorator shows a class is used for dependency injection;
    you can do this by marking it as a root injector or by adding it inside a `providers`
    array of a specific component or ngModule. The `@Injectable()` decorator also
    ensures Angular can perform optimizations such as tree shaking. You can also provide
    classes without the `@Injectable()` decorator inside your `providers` array, but
    it’s a good practice to mark them with the decorator unless you need to provide
    the classes in a specific place. Here’s an example of how to provide a service
    inside the `providers` array of a component:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Injectable()`装饰器表明一个类用于依赖注入；您可以通过将其标记为根注入器或将其添加到特定组件或ngModule的`providers`数组中来实现这一点。`@Injectable()`装饰器还确保Angular可以执行如摇树优化等优化。您也可以在`providers`数组中提供没有`@Injectable()`装饰器的类，但除非您需要在特定位置提供这些类，否则这是一个好习惯。以下是如何在组件的`providers`数组中提供服务的示例：'
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When using the component-level `providers` array, the provided dependency becomes
    available for dependency injection for each component instance and all child components
    or directives used within the component’s tree. If you add a dependency inside
    the `providers` array of an ngModule, the dependency can be injected and accessed
    everywhere within that module. You can declare classes inside the `providers`
    array of your modules like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用组件级别的`providers`数组时，提供的依赖项对于每个组件实例以及组件树中使用的所有子组件或指令都可用。如果您在ngModule的`providers`数组中添加依赖项，则该依赖项可以在该模块内的任何地方注入和访问。您可以在模块的`providers`数组中声明类，如下所示：
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In our *expenses-registration application*, we don’t have ngModules. When developing
    an Angular application without ngModules, you can provide dependencies inside
    your `ApplicationConfig` object; this is similar to marking a dependency as a
    root injector because it will be available for dependency injection throughout
    your application. Adding classes to your `providers` array inside the `ApplicationConfig`
    objects works like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的*支出注册应用程序*中，我们没有ngModules。当在不使用ngModule开发Angular应用程序时，您可以在`ApplicationConfig`对象中提供依赖项；这类似于将依赖项标记为根注入器，因为它将在整个应用程序中可用。在`ApplicationConfig`对象内部将类添加到`providers`数组中的操作如下：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Lastly, the most common way to provide your classes as dependencies is by marking
    the class as a *root* injector. You can do this inside the `@Injectable()` decorator
    with the `providedIn` property, like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将您的类作为依赖项提供的最常见方法是将其标记为*根*注入器。您可以在`@Injectable()`装饰器中使用`providedIn`属性来完成此操作，如下所示：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'providers: [{ provide: Logger, useClass: Logger }]'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 'providers: [{ provide: Logger, useClass: Logger }]'
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'providers: [Logger]'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 'providers: [Logger]'
- en: '[PRE59]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'providers: [{ provide: Logger, useClass: BetterLogger }]'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 'providers: [{ provide: Logger, useClass: BetterLogger }]'
- en: '[PRE60]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'providers: [ BetterLogger,'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'providers: [BetterLogger,'
- en: '{ provide: Logger, BetterLogger and Logger tokens. Both will provide the same
    instance of the service. Be careful not to use the useClass definition for this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '{ provide: Logger, BetterLogger和Logger标记。这两个都将提供相同的服务实例。请注意不要为此使用useClass定义：'
- en: '[PRE61]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'const DashboardServiceFactory = (userService: UserService) => userService.user.isAdmin
    ? new AdminDashboardService() : new DashboardService();'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 'const DashboardServiceFactory = (userService: UserService) => userService.user.isAdmin
    ? new AdminDashboardService() : new DashboardService();'
- en: '[PRE62]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '{ provide: DashboardService,'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '{ provide: DashboardService,'
- en: UserService to check if the current user is an admin user. Because of this,
    you need to add UserService inside a deps array of your provider object.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: UserService用于检查当前用户是否为管理员用户。因此，您需要在提供者对象的deps数组中添加UserService。
- en: Now that you know more about `useFactory`, let’s export `useValue`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了`useFactory`，让我们导出`useValue`。
- en: Declaring provider objects with useValue
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用useValue声明提供者对象
- en: 'The `useValue` provider definition is the simplest one. It returns a constant
    value such as a string, date, or Boolean. It’s useful for providing things such
    as a base website URL, base API URLs, or other constant values:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`useValue`提供者定义是最简单的一种。它返回一个常量值，如字符串、日期或布尔值。它对于提供诸如基本网站URL、基本API URL或其他常量值等非常有用：'
- en: '[PRE63]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'export const BASE_URL = BASE_URL – and assign it with new InjectionToken. The
    value between the arrow brackets is the type of your dependency – in this example,
    a string – and the value between the round brackets is a description for your
    InjectionToken. Now, you can use this InjectionToken in a provider object like
    this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 'export const BASE_URL = BASE_URL – and assign it with new InjectionToken. The
    value between the arrow brackets is the type of your dependency – in this example,
    a string – and the value between the round brackets is a description for your
    InjectionToken. Now, you can use this InjectionToken in a provider object like
    this:'
- en: '[PRE64]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When assigning a provider token, you can also use a simple string like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当分配提供者令牌时，您也可以使用一个简单的字符串，如下所示：
- en: '[PRE65]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'constructor(private logger: LoggerService) {}'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'constructor(private logger: LoggerService) {}'
- en: '[PRE66]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'private logger = InjectionToken as a provider token. The syntax to do this
    is slightly different in the case of constructor injection. You need to use the
    @Inject() decorator function inside your constructor like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 'private logger = InjectionToken as a provider token. The syntax to do this
    is slightly different in the case of constructor injection. You need to use the
    @Inject() decorator function inside your constructor like this:'
- en: '[PRE67]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: private logger = inject(LoggerService);
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: private logger = inject(LoggerService);
- en: '[PRE68]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: inject function, why you should use it instead of contractor injection, and
    where to declare the inject function.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: inject function, why you should use it instead of constructor injection, and
    where to declare the inject function.
- en: Using the inject function for better dependency injection
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `inject` 函数进行更好的依赖注入
- en: 'The `inject` function is more flexible than constructor injection because it
    can be used in more places and works better when using inheritance. You can declare
    the `inject` function anywhere, but it needs to run inside the *injection context*;
    otherwise, you’ll get an error. The injection context is inside the constructor
    of a class, where you initialize fields inside a class inside the factory function
    of `useFactory`, route guards, route resolvers, and HTTP interceptors:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`inject` 函数比构造函数注入更灵活，因为它可以在更多地方使用，并且在使用继承时表现更好。您可以在任何地方声明 `inject` 函数，但它需要在
    *注入上下文* 内运行；否则，您将得到一个错误。注入上下文位于类的构造函数中，在 `useFactory` 的工厂函数、路由守卫、路由解析器和 HTTP 拦截器中初始化类内部的字段：'
- en: '[PRE69]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'One of the main advantages of the `inject` function is that it allows you to
    abstract logic into a function. Let’s say you want to fetch dashboards; you can
    abstract this logic into a separate function using the `inject` function. To do
    this, you can create a function like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`inject` 函数的主要优点之一是它允许您将逻辑抽象到函数中。假设您想获取仪表板；您可以使用 `inject` 函数将此逻辑抽象到单独的函数中。为此，您可以创建一个如下所示的函数：'
- en: '[PRE70]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here, we use an arrow function. Because we don’t use brackets, the arrow function
    directly returns what we write after the arrow. This is the same as writing this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用箭头函数。因为我们没有使用括号，所以箭头函数直接返回箭头后面的内容。这与写这个相同：
- en: '[PRE71]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: export default class DashboardsListComponent {
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: export default class DashboardsListComponent {
- en: dashboards$ = fetchDashboards();
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: dashboards$ = fetchDashboards();
- en: '}'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE72]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: <h1 *ngFor="let dashboard of (dashboards$ | async)">
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: <h1 *ngFor="let dashboard of (dashboards$ | async)">
- en: '{{dashboard.title}}'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '{{dashboard.title}}'
- en: </h1>
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: </h1>
- en: '[PRE73]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'return component class, you must assign this closure function to a property,
    like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 返回组件类时，必须将此闭包函数分配给一个属性，如下所示：
- en: '[PRE74]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `fetchDashboards` function returns another function, and because of that,
    the `_fetchDashboards` property is also a function. This `_fetchDashboards` function
    now holds the function that returns the observable HTTP call for fetching the
    dashboards and can be used anywhere in your class, also outside the injection
    context:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchDashboards` 函数返回另一个函数，因此 `_fetchDashboards` 属性也是一个函数。现在 `_fetchDashboards`
    函数持有返回获取仪表板的可观察 HTTP 调用的函数，可以在您的类的任何地方使用，也可以在注入上下文之外使用：'
- en: '[PRE75]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Before converting the `fetchDashboards` function so that it can use closure,
    it can’t be used inside the `loadDashboards` function of the component because
    this is outside the injection context. By using a closure and returning the function
    to a property in our injection context, we can now use the function to fetch the
    dashboards outside the injection context. Using this pattern allows for great
    abstraction of logic and functions with a single responsibility that can be shared
    throughout your application while keeping component classes simple and clean.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 `fetchDashboards` 函数转换为可以使用闭包之前，它不能在组件的 `loadDashboards` 函数内部使用，因为这是在注入上下文之外。通过使用闭包并将函数返回到我们的注入上下文中的一个属性，我们现在可以在注入上下文之外使用该函数来获取仪表板。使用这种模式可以实现逻辑和具有单一职责的函数的高度抽象，这些函数可以在整个应用程序中共享，同时保持组件类简单且干净。
- en: 'Besides abstracting logic into dedicated functions, the `inject` function offers
    some advantages when working with inheritance. When using dependency injection
    in both the base class and the class inheriting from the base class, you need
    to call `super()` and pass the dependencies to the base class. Here’s a simple
    example:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将逻辑抽象到专用函数之外，`inject`函数在处理继承时提供了一些优势。当在基类及其继承自基类的类中同时使用依赖注入时，你需要调用`super()`并将依赖项传递给基类。以下是一个简单的示例：
- en: '[PRE76]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Calling `super()` and passing along dependencies can become a hindrance and
    look messy. With the `inject` function, you can prevent this. By using the `inject`
    function in both classes, you don’t have to pass along anything or call the `super()`
    method anymore:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`super()`并传递依赖项可能会成为一种阻碍，看起来很杂乱。使用`inject`函数，你可以防止这种情况发生。通过在两个类中都使用`inject`函数，你不再需要传递任何东西或调用`super()`方法：
- en: '[PRE77]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As you can see, you don’t have to pass along `router` to the base service,
    and there is no need for the `super()` call anymore; that looks much cleaner!
    Let’s say you only used the router for navigation inside the base class. In that
    case, you can even take it a step further and abstract the navigation functionality
    into a separate closure function, as we did before, with the `fetchDashboards`
    function:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你不需要将`router`传递给基服务，也不再需要调用`super()`；这看起来要干净得多！假设你只在基类内部使用`router`进行导航。在这种情况下，你甚至可以更进一步，将导航功能抽象成一个单独的闭包函数，就像我们之前在`fetchDashboards`函数中所做的那样：
- en: '[PRE78]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Because we’re using an arrow function that returns another arrow function,
    we can use `_navigateFn` outside the injection context. Inside the service that
    inherits the base class, you can navigate using the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了一个返回另一个箭头函数的箭头函数，我们可以在注入上下文外部使用`_navigateFn`。在继承基类的服务内部，你可以使用以下代码进行导航：
- en: '[PRE79]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Now that you know why, when, and how to use the `inject` function instead of
    constructor injection, let’s explore how dependency injection creates instances
    of the injected services and what hierarchical injectors are.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了为什么、何时以及如何使用`inject`函数而不是构造函数注入，让我们来探讨依赖注入是如何创建注入服务的实例以及什么是分层注入器。
- en: Dependency instances, injector hierarchy, and resolution modifiers
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖实例、注入层次结构和解析修饰符
- en: The last thing you need to learn is how Angular creates instances of the dependencies
    you inject, how the **injector hierarchy** works, and how to control it with **resolution
    modifiers**.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要学习的最后一件事是Angular如何创建你注入的依赖项的实例，注入层次结构是如何工作的，以及如何使用解析修饰符来控制它。
- en: Each time you inject a dependency, Angular will check how the dependency is
    provided, starting at the lowest level of the injector hierarchy – the `providers`
    array inside your component or directive. If Angular can’t find a provider, it
    will start to move up in the injector hierarchy, first to the parent components;
    if it can’t find the provider in any of the parent components, Angular will check
    the ngModule of the component or your `ApplicationConfig` object in case you don’t
    use ngModules. If Angular can’t find a provider in the ngModules, it will look
    in the root injector for a service with the `@Injectable` decorator and `providedIn`
    root. If Angular still can’t find a provider for the inject dependency, Angular
    will throw an error. If you inject a dependency in a service, Angular will skip
    the component hierarchy steps.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你注入一个依赖项时，Angular都会检查依赖项是如何提供的，从注入层次结构的最低级别开始检查——即你组件或指令内部的`providers`数组。如果Angular找不到提供者，它将开始在注入层次结构中向上移动，首先移动到父组件；如果它在任何父组件中找不到提供者，Angular将检查组件的ngModule或如果你不使用ngModules，则检查你的`ApplicationConfig`对象。如果Angular在ngModules中找不到提供者，它将在根注入器中查找带有`@Injectable`装饰器和`providedIn`根的服务。如果Angular仍然找不到注入依赖项的提供者，它将抛出一个错误。如果你在服务中注入一个依赖项，Angular将跳过组件层次结构的步骤。
- en: Let’s say we want to inject `LoggerService` as a dependency. When Angular finds
    the provider for `LoggerService`, it will check if the injector already created
    an instance of `LoggerService` at the hierarchy level where the provider was located.
    If the injector already made `LoggerService` for the given hierarchy level, it
    will return the created instance. Otherwise, it will create one and then return
    it. For each hierarchy level, a singleton instance will be created and shared
    by all consumers on the lower hierarchical levels. If two or more sibling components
    declare a provider, a singleton will be created for each provider, and each component
    will use its own singleton of `LoggerService` and share it with all its subsequent
    child components and directives.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想将 `LoggerService` 注入为依赖项。当 Angular 找到 `LoggerService` 的提供者时，它会检查注入器是否已经在提供者所在的层次级别创建了
    `LoggerService` 的实例。如果注入器已经为给定的层次级别创建了 `LoggerService`，则返回已创建的实例。否则，它将创建一个实例然后返回。对于每个层次级别，将创建一个单例实例，并由所有较低层次级别的消费者共享。如果有两个或更多兄弟组件声明了提供者，将为每个提供者创建一个单例，每个组件将使用自己的
    `LoggerService` 单例，并将其与所有后续子组件和指令共享。
- en: '*Figure 2**.2* depicts how hierarchical dependencies are created and shared:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2**.2* 展示了层次依赖的创建和共享方式：'
- en: '![Figure 2.2: Hierarchical dependency creation](img/B21625_02_2.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2：层次依赖创建](img/B21625_02_2.jpg)'
- en: 'Figure 2.2: Hierarchical dependency creation'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：层次依赖创建
- en: Knowing how Angular dependency injection creates and shares dependencies allows
    you to provide the correct instance to all application sections. If you want a
    singleton to be shared among all dependency consumers in the application, you
    just need to provide the dependency in the root injector. In some more complex
    and edge cases, you need to be able to have more control over how Angular looks
    for providers. In this scenario, you can adjust the behavior with resolution modifiers.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Angular 依赖注入如何创建和共享依赖项，使您能够为应用程序的所有部分提供正确的实例。如果您想使单例在应用程序的所有依赖项消费者之间共享，您只需在根注入器中提供依赖项即可。在某些更复杂和边缘情况下，您可能需要能够更多地控制
    Angular 查找提供者的方式。在这种情况下，您可以使用解析修饰符来调整行为。
- en: 'There are four resolution modifiers you can apply to your injected dependencies.
    Each has its own function and how you apply these modifiers differs depending
    on if you use constructor injection or the `inject` function. Let’s examine these
    four resolution modifiers and what they do:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以对注入的依赖项应用四种解析修饰符。每种修饰符都有自己的功能，并且您应用这些修饰符的方式取决于您是否使用构造函数注入或 `inject` 函数。让我们来检查这四种解析修饰符及其功能：
- en: '`@Optional()`: The `@Optional()` modifier makes sure a dependency is optional.
    Angular won’t throw an error if it can’t find a provider for the given dependency.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Optional()`: `@Optional()` 修饰符确保依赖项是可选的。如果 Angular 找不到给定依赖项的提供者，它不会抛出错误。'
- en: '`@SkipSelf()`: With the `@SkipSelf()` modifier, you tell Angular it should
    start looking for a provider in the first parent in the dependency hierarchy.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SkipSelf()`: 使用 `@SkipSelf()` 修饰符，您告诉 Angular 应该从依赖项层次结构中的第一个父组件开始查找提供者。'
- en: '`@Self()`: The `@Self()` modifier tells Angular to only look at the component
    or directive itself for the provider.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Self()`: `@Self()` 修饰符告诉 Angular 只查看组件或指令本身以查找提供者。'
- en: '`@Host()`: The `@Host()` property marks a component as the last step in the
    search for a provider, even if there are more components higher up in the tree.
    When the `@Host()` property is found, Angular stops looking for the dependency
    provider.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Host()`: `@Host()` 属性将组件标记为在搜索提供者时的最后一步，即使树中还有更高层的组件。当找到 `@Host()` 属性时，Angular
    会停止寻找依赖提供者。'
- en: 'Now that you know what resolution modifiers are available and what they do,
    let’s see how you can apply them to dependencies. When you want to apply a resolution
    modifier to a dependency that’s been injected with constructor injection, you
    can use the following syntax:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了可用的解析修饰符及其功能，让我们看看如何将它们应用到依赖项上。当您想将解析修饰符应用到使用构造函数注入注入的依赖项时，您可以使用以下语法：
- en: '[PRE80]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'logger = inject(Logger, {optional: true, self: true});'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 'logger = inject(Logger, {optional: true, self: true});'
- en: '[PRE81]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: export * from './lib/services/expenses.service';
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: export * from './lib/services/expenses.service';
- en: '[PRE82]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
