- en: RxJS Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJS 基础
- en: '**Reactive Extensions for JavaScript** (**RxJS**) is a set of libraries created
    by Matt Podwysocky. Version 4 of the library is maintained and developed by Microsoft.
    Version 4 can be found at the following link: [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript 的响应式扩展**（**RxJS**）是由 Matt Podwysocky 创建的一系列库。库的第四版由微软维护和开发。第四版可以在以下链接找到：[https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)。'
- en: 'Version 5 is a complete rewrite of version 4 and can be found at the following
    address: [https://github.com/ReactiveX/rxjs](https://github.com/ReactiveX/rxjs).
    Its largest contributor is *Ben Lesh*, with other notable contributors including
    *Andre Staltz*. Version 5 is also Angular''s choice of library for handling HTTP,
    among other things.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 第五版是对第四版的完全重写，可以在以下地址找到：[https://github.com/ReactiveX/rxjs](https://github.com/ReactiveX/rxjs)。其最大贡献者是
    *Ben Lesh*，其他值得注意的贡献者包括 *Andre Staltz*。第五版也是 Angular 在处理 HTTP 等方面的库选择。
- en: 'In this chapter, you will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: Which patterns make up RxJS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组成 RxJS 的模式有哪些
- en: The core concepts of RxJS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS 的核心概念
- en: How to manually create your own Observables and subscribe to them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何手动创建自己的 Observables 并订阅它们
- en: The many ways you can create an Observable
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以创建 Observable 的多种方式
- en: The importance of managing cleanup
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理清理的重要性
- en: Understanding what lies beneath by learning to implement the core part of the
    RxJS library
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过学习实现 RxJS 库的核心部分来理解其底层原理
- en: Observer pattern
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: 'The Observer pattern is a Gang of Four pattern. It is a pattern made famous
    by being included in the book *Design Patterns: Elements of Reusable Object-Oriented
    Software* by *Erich Gamma*, *Richard Helm*, *Ralph Johnson*, and *John Vlissides*.
    The pattern has two key players involved: a **Subject** and an **Observer**. A
    Subject is observed by an Observer. Typically, a Subject holds an internal list
    of Observers that should be notified when a change happens on the Subject. It
    is quite common that the Subject is a model and the Observers are some kind of
    UI component. In short, Subjects should be able to:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是四人帮模式。这是一个因被包含在 *Erich Gamma*、*Richard Helm*、*Ralph Johnson* 和 *John Vlissides*
    所著的《设计模式：可复用面向对象软件元素》一书中而闻名的设计模式。该模式有两个关键参与者：一个 **Subject** 和一个 **Observer**。Subject
    被观察者观察。通常，Subject 持有一个内部观察者列表，当 Subject 上发生更改时应该通知这些观察者。Subject 通常是一个模型，而观察者是一些
    UI 组件。简而言之，Subject 应该能够：
- en: Hold a list of Observers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护观察者列表
- en: Add an Observer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加观察者
- en: Remove an Observer
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除观察者
- en: Notify all Observers when a change happens
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生更改时通知所有观察者
- en: 'The Observer, on the other hand, should only hold one property, and that is
    an `update()` method that can be called by a Subject when an update has occurred.
    The idea behind this pattern is to create a loose coupling between different layers.
    Neither Subjects nor Observers should know about each other directly by name,
    but rather by abstractions. A class diagram for a Subject might therefore look
    like the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，观察者应该只持有一个属性，那就是一个可以在更新发生时由主题调用的 `update()` 方法。这个模式背后的想法是创建不同层之间的松散耦合。主题和观察者都不应该直接通过名称了解对方，而应该通过抽象。因此，一个主题的类图可能如下所示：
- en: '![](img/d14da8c5-3a06-4875-86c3-4543b4b26a98.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d14da8c5-3a06-4875-86c3-4543b4b26a98.png)'
- en: 'Here, we are including all the required methods: `attach()`, `detach()` and
    `notify()`, and we clearly specify that we are dealing with the abstraction Observer
    and not a concrete type. As for the Observer, this is usually an interface with
    just one method, `update()`, and can be represented by the following class diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们包括了所有必需的方法：`attach()`、`detach()` 和 `notify()`，并且我们明确指出我们处理的是抽象观察者，而不是具体类型。至于观察者，这通常是一个只有一个方法
    `update()` 的接口，可以由以下类图表示：
- en: '![](img/a38a9906-ccf4-4743-81e0-7363ecf07869.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a38a9906-ccf4-4743-81e0-7363ecf07869.png)'
- en: 'Given these class diagrams, let''s write down some code to demonstrate what
    an implementation might look like, and let''s start with the Subject. For this
    example, we will be using TypeScript, as TypeScript knows what an interface is:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这些类图，让我们编写一些代码来演示实现可能的样子，并且我们从主题开始。对于这个例子，我们将使用 TypeScript，因为 TypeScript 知道接口是什么：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, the basic implementation is very short but it is a powerful
    construct. As for the `Observer`, it is even shorter:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，基本实现非常简短，但它是一个强大的结构。至于 `Observer`，它甚至更短：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can try this out by creating a file, `app.ts`, like so:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个文件，例如 `app.ts`，来尝试这个例子：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By running the preceding code, we see that the `Subject` instance allows us
    to attach `Observer` instances to it by calling the `attach()` method. We then
    call `notify()` on the `Subject` instance to ensure that all subscribing `Observer`
    instances gets notified.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行前面的代码，我们看到`Subject`实例允许我们通过调用`attach()`方法将其附加到`Observer`实例上。然后我们在`Subject`实例上调用`notify()`，以确保所有订阅的`Observer`实例都得到通知。
- en: 'OK, so now we have some core implementation in place, what does an actual use
    case look like? Imagine that we have a `ProductModel` class playing the role of
    a `Subject` and a `ProductUI` class playing the role of an `Observer`. A simple
    implementation of the `ProductModel` class might look like the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以现在我们已经有一些核心实现，一个实际的使用案例是什么样的呢？想象一下，我们有一个扮演`Subject`角色的`ProductModel`类和一个扮演`Observer`角色的`ProductUI`类。`ProductModel`类的一个简单实现可能如下所示：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we can see that we have two properties, `title` and `make`, and when
    both of them change, we call the `notify()` method that we inherit from the base
    class, `Subject`. Let''s have a look at what a `ProductUI` class can look like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们有两个属性，`title`和`make`，当它们两者都发生变化时，我们调用从基类`Subject`继承的`notify()`方法。让我们看看`ProductUI`类可能是什么样子：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we see that we receive a `ProductModel` instance in the
    constructor and that we also call `attach()` on said instance so that it is registered
    as an `Observer`. We also define an `update()` method, in which we decide that
    we will rerender the UI, should it be invoked.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们看到我们在构造函数中接收一个`ProductModel`实例，并且我们还对该实例调用`attach()`方法，以便将其注册为`Observer`。我们还定义了一个`update()`方法，其中我们决定如果它被调用，我们将重新渲染UI。
- en: This is a typical example of using the Observer pattern and using it for model-to-UI
    communication is just one of many usage possibilities. The general principle is
    to communicate between `Subject` and `Observer` instances in a loosely coupled
    way. The true benefit is to be able to have multiple `Observer` instances on one
    `Subject` so that if the `Subject` changes, all its `Observer` instances can change
    with it. This is also called Publish/Subscribe, which is usually shortened to
    Pub/Sub.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用观察者模式并用于模型到UI通信的典型示例，这只是许多使用可能性之一。一般原则是在`Subject`和`Observer`实例之间以松耦合的方式进行通信。真正的优势是能够在单个`Subject`上拥有多个`Observer`实例，这样如果`Subject`发生变化，所有其`Observer`实例也会随之变化。这也被称为发布/订阅，通常简称为Pub/Sub。
- en: RxJS core concepts
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJS核心概念
- en: 'RxJS consists of some core concepts that are important for you to understand
    early on. Those are:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS由一些核心概念组成，这些概念对于你早期理解非常重要。那些是：
- en: '**Observable**: This is a class representing a stream of data.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观察的**：这是一个表示数据流的类。'
- en: '**Observer**: This is a class able to emit data.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者**：这是一个能够发出数据的类。'
- en: '**Producer**: This is what internally produces data, which the Observer ultimately
    emits.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者**：这是内部产生数据的东西，观察者最终会发出这些数据。'
- en: '**Operator**: This is a method on an Observable, which allows us to manipulate
    the stream itself or the data it emits.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作符**：这是`Observable`上的一个方法，它允许我们操作流本身或它发出的数据。'
- en: '**Stream**: This is synonymous with an instance of an Observable. The reason
    for it being called a stream is that you should think of the data as continuous
    and not really having an end, unless you explicitly define an end.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流**：这与`Observable`的一个实例同义。之所以称之为流，是因为你应该将数据视为连续的，而不是真正有结束，除非你明确地定义一个结束。'
- en: Observable and Observer
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察的和观察者
- en: 'Having defined all the concepts we need to know initially, it is now time to
    put it all in context to further our understanding. Let''s start off by defining
    an `Observable` and work ourselves into each previously mentioned concept. An
    `Observable` can be created with the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了我们最初需要了解的所有概念之后，现在是我们将这些概念放入上下文中，以进一步加深我们的理解。让我们从一个定义`Observable`开始，并逐步深入到之前提到的每个概念。`Observable`可以通过以下代码创建：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is the least amount of code needed to create an `Observable`. At this
    point nothing is written to the screen because we need to subscribe to the stream.
    Let''s add a Subscriber to our `Observable`. We do that by calling the method
    `subscribe()` on our stream instance:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建一个`Observable`所需的最少代码量。在这个阶段，屏幕上没有写入任何内容，因为我们需要订阅流。让我们给我们的`Observable`添加一个订阅者。我们通过在流实例上调用`subscribe()`方法来实现这一点：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Looking at this code, we see that the `Observable` calls the method `create()`,
    which in turn creates an instance of an `Observable`. What is interesting is how
    the `create()` method takes a function as a parameter; a function that itself
    takes an Observer instance. So, we have an API that looks like this: `Observer.create(fn(observerInstance))`.
    What happens inside said function is that we call `observer.next(1)`. At a higher
    level, we have an `Observable` that is created by us using a `factory` function
    `create()`. The `create` function takes a function as a parameter which defines
    the behavior of the `Observable`. Our `Observable` behavior in this case is very
    simple, which is to emit the value 1\. When we call `observer.next(1)`, we emit
    data. To get hold of what is emitted, we need to call the `subscribe()` method.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这段代码，我们看到`Observable`调用了`create()`方法，该方法反过来创建了一个`Observable`的实例。有趣的是，`create()`方法接受一个函数作为参数；这个函数本身接受一个观察者实例。因此，我们有一个看起来像这样的API：`Observer.create(fn(observerInstance))`。在这个函数内部发生的事情是，我们调用`observer.next(1)`。在更高层次上，我们通过使用`create()`这个`factory`函数创建了一个`Observable`。在这个例子中，我们的`Observable`行为非常简单，就是发射值1。当我们调用`observer.next(1)`时，我们发射数据。为了获取发射的数据，我们需要调用`subscribe()`方法。
- en: Producer
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产者
- en: 'If we try to compare this to the Observer pattern, we will see that some concepts
    reoccur, such as Observer. In this pattern, the Observer was notified when something
    happened and the Subject took the initiative to change. Looking at the previous
    code, it looks like the Observer is the one that takes the initiative to change.
    This isn''t strictly true though; it is more of a mediator, which brings us to
    our next concept in RxJS, the `Producer`. The `Producer` is responsible for generating
    the values we need. By involving a `Producer` in our code, we see that the Observer
    is more of a mediator:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将此与观察者模式进行比较，我们会看到一些概念是重复的，例如观察者。在这个模式中，当发生某些事情时，观察者会收到通知，而主题会主动改变。看看之前的代码，看起来像观察者是主动改变的一方。但这并不完全正确；它更像是一个中介，这带我们来到了RxJS的下一个概念，即`Producer`。`Producer`负责生成我们需要的值。通过在我们的代码中引入`Producer`，我们看到观察者更像是一个中介：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see here, the producer is the one responsible for generating the data,
    while the Observer is responsible for passing on that data to a subscriber.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，生产者是负责生成数据的一方，而观察者负责将数据传递给订阅者。
- en: Observable error and completion
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察的错误和完成
- en: 'There is more to a stream than just generating data; a stream can generate
    errors as well as reaching its completion. If an error or a completion happens,
    the stream will not generate any more values. To signal that we have an error,
    we call the `error()` method on the Observer, like so:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 流不仅仅是生成数据；流还可以生成错误以及达到其完成状态。如果发生错误或完成，流将不再生成任何值。为了表示我们有一个错误，我们在观察者上调用`error()`方法，如下所示：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To capture the emitted error, we need to introduce a second callback in our
    call to `subscribe()`, like so:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获发射的错误，我们需要在我们的`subscribe()`调用中引入第二个回调，如下所示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So far, we have learned how to emit data but also how to signal an error. The
    last thing we can do is to close the stream, or complete it, as closing is also
    known. We do that by calling `complete()` on the Observer. This will ensure that
    no more values are emitted. To capture a completion signal, we need to add another
    callback in our `subscribe()` call. You use it in the following way:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何发射数据，以及如何发出错误信号。我们能做的最后一件事是关闭流，或者完成它，因为关闭流也被称为完成。我们通过在观察者上调用`complete()`来实现这一点。这将确保不再发射任何值。为了捕获完成信号，我们需要在我们的`subscribe()`调用中添加另一个回调。你可以这样使用它：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Operator
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符
- en: Our last concept to cover is the operator. An operator is simply a method that
    acts on an Observable and changes the stream in some way. Operators are by nature
    immutable. This immutability makes the code easier to test and reason about. RxJS
    comes with over 60 operators to help in most situations where you define your
    streams and their behavior.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要讨论的最后一个概念是操作符。操作符简单地说是一个作用于`Observable`并按某种方式改变流的函数。操作符本质上是不可变的。这种不可变性使得代码更容易测试和推理。RxJS提供了60多个操作符，以帮助在大多数情况下定义你的流及其行为。
- en: There might be a case where you need to create your own operator, but most likely
    there is an operator out there that already does what you want.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有这样的情况，你需要创建自己的操作符，但很可能是已经有了一个操作符可以完成你想要的功能。
- en: 'When you define your stream and its behavior, you will use one or more operators.
    It might look like the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义你的流及其行为时，你将使用一个或多个操作符。它可能看起来像以下这样：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we can see that we are using the `.map()` operator and `.filter()` to
    change our stream's data. `.map()` operates on each value in the stream by incrementing
    each value by one. `.filter()` operates on the changed stream; a change brought
    about by calling `.map()`. It also operates on each value in the stream but conditionally
    decides what should be emitted. The end result is only one value being emitted,
    `3`. There are a ton more operators, but this should give you an idea of what
    operators are and how they can be used.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们正在使用 `.map()` 操作符和 `.filter()` 来改变我们的流数据。`.map()` 通过将每个值增加一来对流中的每个值进行操作。`.filter()`
    对改变后的流进行操作；由调用 `.map()` 引起的改变。它也针对流中的每个值进行操作，但条件性地决定应该发出什么。最终结果只发出一个值，`3`。还有许多其他的操作符，但这应该能给你一个关于操作符是什么以及如何使用它们的想法。
- en: Creating Observables
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Observables
- en: 'Most of the time, when creating Observables, you won''t use the `create()`
    method to do so. You will use other methods instead. Why is that? Well, an Observable
    instance usually originates from some asynchronous concept. In the context of
    using RxJS for creating Angular applications, an Observable instance will be created
    by doing one of the following things:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，在创建Observables时，你不会使用`create()`方法。你将使用其他方法。为什么是这样呢？好吧，一个Observable实例通常源于某种异步概念。在使用RxJS创建Angular应用程序的上下文中，Observable实例将通过执行以下操作之一来创建：
- en: Creating or fetching data over HTTP with AJAX
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AJAX通过HTTP创建或获取数据
- en: Listening to input changes with reactive forms
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应式表单监听输入变化
- en: Listening to routing changes
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听路由变化
- en: Listening to UI events
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听UI事件
- en: Wrapping an asynchronous concept
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装异步概念
- en: 'In RxJS, there are different creation operators that will help you solve these
    tasks, but the Angular framework might actually create Observables internally.
    Let''s look at some creation operators other than the `create()` method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJS中，有一些不同的创建操作符可以帮助你解决这些任务，但Angular框架实际上可能在内部创建Observables。让我们看看除了`create()`方法之外的一些创建操作符：
- en: Creation operators
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建操作符
- en: An Observable is, as we stated before, a representation of data being emitted
    over time. Sometimes, the data arrives straight away and sometimes it takes time.
    Regardless of which, it is really powerful to be able to model that data in the
    same way.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，Observable是一种表示随时间发出的数据的表现形式。有时，数据会立即到达，有时则需要时间。无论哪种情况，能够以相同的方式对数据进行建模都是非常强大的。
- en: of()
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: of()
- en: 'Let''s look at a very simple creation operator, `of()`. This takes a variable
    number of arguments, which will be emitted as values, like so:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个非常简单的创建操作符，`of()`。它接受一个可变数量的参数，这些参数将被作为值发出，如下所示：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The values are fired off immediately. This is very useful when you just want
    to test things out.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 值会立即触发。这在只想测试事情时非常有用。
- en: interval()
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: interval()
- en: 'Another interesting operator is the `interval()` operator, which takes a number
    of milliseconds as a parameter. This defines the number of milliseconds delay
    there should be between every piece of emitted data. This will start from the
    number 0\. One thing to keep in mind is that it will generate values forever unless,
    for example, a `take()` operator is applied to it. A `take()` operator will limit
    the number of emitted values and close the stream. A typical usage of the operator
    is the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的操作符是`interval()`操作符，它接受一个毫秒数作为参数。这定义了每条发出数据之间的延迟时间（以毫秒为单位）。它将从数字0开始。需要注意的是，除非例如应用了`take()`操作符，否则它将无限期地生成值。`take()`操作符将限制发出的值的数量并关闭流。该操作符的典型用法如下：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: from()
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: from()
- en: 'The `from()` operator allows us to create an `Observable` from some other asynchronous/synchronous
    concept. It''s really powerful when almost anything can be made into an `Observable`,
    as this allows for rich composition. Here is what a typical snippet can look like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`from()`操作符允许我们从其他异步/同步概念创建一个`Observable`。当几乎所有东西都可以被制作成`Observable`时，这非常强大，因为它允许丰富的组合。以下是一个典型的代码片段示例：'
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: fromEvent()
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fromEvent()
- en: We have mentioned rich composition a few times already and the power of making
    everything into an Observable. We have turned promises and into Observables, which
    have made everything into streams of data, making the whole situation more easy
    to reason about. What we mean by that is, when every async concept is being turned
    into an Observable, we are suddenly able to think about them in the same way.
    Operators that can be applied to mouse-clicks can also be applied to AJAX requests
    and so on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次提到丰富的组合以及将一切转换为 Observable 的力量。我们已经将承诺转换为 Observables，这使得一切变成了数据流，使得整个情况更容易推理。我们的意思是，当每个异步概念都被转换为
    Observable 时，我们突然能够以相同的方式思考它们。可以应用于鼠标点击的操作符也可以应用于 AJAX 请求等等。
- en: 'To add to this, we can even make UI events into Observables. By using the `.fromEvent()`
    operator, we are able to take an element and its corresponding event and make
    that an Observable. This is true power at our fingertips, which allows us to turn
    scenarios such as autocomplete into a matter of 3-4 lines of code. A typical usage
    of this operator looks like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们甚至可以将 UI 事件转换为 Observables。通过使用 `.fromEvent()` 操作符，我们能够将一个元素及其对应的事件转换为一个
    Observable。这是我们手中的真正力量，它允许我们将诸如自动完成等场景简化为 3-4 行代码。此操作符的典型用法如下：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: bindCallback()
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: bindCallback()
- en: 'So far, we have listed a lot of ways, synchronous as well as asynchronous,
    in which a construct could be turned into an Observable. Callbacks is the first
    pattern to try to resolve the whole asynchronous matter and it should be said
    that a callback is probably the worst way to solve asynchronous code because of
    its poor readability. Luckily, there is an operator that takes a callback and
    turns it into an Observable called `bindCallback()`. It can be used in the following
    way:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经列出了很多方法，无论是同步还是异步，都可以将一个结构转换为 Observable。回调是第一个尝试解决整个异步问题的模式，并且应该指出，由于可读性差，回调可能是解决异步代码的最差方式。幸运的是，有一个操作符可以将回调转换为
    Observable，称为 `bindCallback()`。它可以按以下方式使用：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can see that we start off by defining a function called `fnWithCallback()`.
    We pass this as an argument to the `bindCallback()` method. This produces a `fnWithCallbbackBinded()`
    function. Invoking said function will produce an `Observable` that we can subscribe
    to. So, every time `cb(''data'')` in the `fnWithCallback()` function is invoked
    because of the `setTimeout()`, this will lead to the data callback for our `source$`
    being invoked. How does this work in practice? It''s really quite simple. Let''s
    try to implement our own `Observable` for this. We have learned the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们首先定义了一个名为 `fnWithCallback()` 的函数。我们将这个函数作为参数传递给 `bindCallback()` 方法。这会产生一个
    `fnWithCallbbackBinded()` 函数。调用该函数将生成一个我们可以订阅的 `Observable`。因此，每当 `fnWithCallback()`
    函数中的 `cb('data')` 因为 `setTimeout()` 而被调用时，这将导致我们的 `source$` 的数据回调被调用。这在实践中是如何工作的呢？这实际上非常简单。让我们尝试实现我们自己的
    `Observable`。我们已经学习了以下内容：
- en: A `bindCallback()` method takes a function as a parameter
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bindCallback()` 方法接受一个函数作为参数'
- en: Invoking `bindCallback()` should produce a function
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `bindCallback()` 应该生成一个函数
- en: Invoking the result of calling `bindCallback()` should produce an `Observable`
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `bindCallback()` 的结果应该生成一个 `Observable`
- en: Calling `subscribe()` should mean that our data callback should be the `cb`
    parameter in `fnWithCallback()`
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `subscribe()` 应意味着我们的数据回调应该是 `fnWithCallback()` 中的 `cb` 参数
- en: 'The resulting implementation should therefore look like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终的实现应该看起来像这样：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Cleanup
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: 'We have now covered core concepts such as Observable, Observer, Producer, and
    operators. We have also looked into how we can manually create an Observable,
    but realized that there are different creation operators that will help you create
    Observables from other constructs, and sometimes the Angular framework itself
    will create the Observable for you. We have failed to mention one important thing
    though, cleanup. There will be situations where an Observable will allocate resources
    or simply go on forever, as with the `interval()` operator. There is one clear
    remedy to that—define and run a cleanup function when we are done with the Observable.
    Defining such a function forces us to return to the `create` operator and amend
    some code in its behavior function, like so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了核心概念，如Observable、Observer、Producer和操作符。我们还探讨了如何手动创建一个Observable，但意识到有不同类型的创建操作符可以帮助您从其他结构创建Observable，有时Angular框架本身会为您创建Observable。但我们遗漏了一个重要的事情，那就是清理。会有一些情况，Observable会分配资源或简单地永远持续，就像`interval()`操作符一样。有一种明确的补救措施——在我们完成Observable后定义并运行一个清理函数。定义这样的函数迫使我们回到`create`操作符，并在其行为函数中修改一些代码，如下所示：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Subscriptions
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅
- en: The preceding code describes a situation where there is a need for a cleanup
    to happen. We have defined a `setInterval()` construct that seemingly emits values
    forever. `cleanUpFn()` has the ability to cancel that behavior, providing it is
    being invoked. We return `cleanUpFn()` at the end of our behavior function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码描述了一个需要清理发生的情况。我们定义了一个`setInterval()`结构，它似乎会无限期地发出值。`cleanUpFn()`有取消这种行为的能力，前提是它被调用。我们在行为函数的末尾返回`cleanUpFn()`。
- en: 'The question is, how do we get hold of it? The answer is that we need to talk
    about a new concept: subscription. A subscription is something that we get back
    when calling `subscribe()` on a stream. Let''s amend the preceding code with just
    that:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，我们如何获取它？答案是，我们需要讨论一个新概念：订阅。订阅是在对流调用`subscribe()`时返回的东西。让我们用这个来修改前面的代码：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we have created the variable `subscription` by calling
    `subscribe()`, but the really interesting part happens in the last line: we define
    a timeout that calls `unsubscribe()` on our `subscription`. This will call our
    `cleanUpFn()` so that the interval is cancelled.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过调用`subscribe()`创建了变量`subscription`，但真正有趣的部分发生在最后一行：我们定义了一个超时，它会在我们的`subscription`上调用`unsubscribe()`。这将调用我们的`cleanUpFn()`，以便取消间隔。
- en: Not many streams that you deal with will need to be unsubscribed from, but the
    ones that allocate resources or start off some construct that goes on forever,
    without us intercepting, will need to have a cleanup behavior which we need to
    invoke once we are done with our stream.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你处理的大多数流都不需要取消订阅，但那些分配资源或启动一些永远持续的结构，而我们没有拦截的，将需要有一个清理行为，我们在完成我们的流后需要调用这个行为。
- en: Creating a core implementation of RxJS
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建RxJS的核心实现
- en: There are different phases to understanding something. Understanding a library
    is about learning its concepts and utilizing its methods in the correct way. Then
    comes deeper understanding, such as knowing what methods to use, based on some
    best practice guide you found in a blog. Finally, you come to a really deep stage
    of understanding where you want to understand what is going for relay and starts
    mucking about in the source code itself and maybe try to enhance it by submitting
    Pull Request to a project, most likely based on GitHub.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 理解某事物有不同的阶段。理解一个库就是学习其概念，并正确地利用其方法。然后是更深层次的理解，比如根据你在博客中找到的一些最佳实践指南，知道应该使用哪些方法。最后，你将达到一个真正深入的理解阶段，你想要理解正在发生的事情，开始对源代码本身进行修改，并可能通过向项目提交Pull
    Request来尝试增强它，这很可能是基于GitHub的。
- en: This section aims to give you part of that deeper knowledge straight away. We
    are aware that your head might be spinning a little at this point, with all the
    new concepts you have learned, together with some nifty operators. Let's start
    from scratch with the concepts first introduced and attempt to reverse engineer
    what is going on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在立即向您提供部分这种更深入的知识。我们意识到，在这个时候，您的大脑可能因为所有新学的概念和一些巧妙的操作符而有些混乱。让我们从头开始，先从最初介绍的概念入手，尝试逆向工程正在发生的事情。
- en: Implementing create()
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现create()
- en: 'At the beginning of this chapter, we were taught how to create an Observable.
    The code looked like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们学习了如何创建一个Observable。代码看起来是这样的：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Just by looking at the code, we can make educated guesses as to what's going
    on underneath. It's clear we need an `Observable` class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 只需看一下代码，我们就可以对底层正在发生的事情做出有根据的猜测。很明显，我们需要一个`Observable`类。
- en: The class needs a `create()` method that takes a function as a parameter. The
    `create()` method should return an `Observable`. Furthermore, our `Observable`
    class needs a `subscribe()` method that takes a function as a parameter. Let's
    start off there and see where we land.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类需要一个接受函数作为参数的`create()`方法。`create()`方法应该返回一个`Observable`。此外，我们的`Observable`类需要一个接受函数作为参数的`subscribe()`方法。让我们从这里开始，看看我们会走到哪里。
- en: 'First, let''s define our `Observable` class with the aforementioned methods:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义我们的`Observable`类，并使用上述方法：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'OK, so we have a class with three methods in it; let''s attempt to implement
    the methods. Let''s take what we know about the `create()` method and start from
    there:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们有一个包含三个方法的类；让我们尝试实现这些方法。让我们从我们所知道的`create()`方法开始：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We highlighted the required changes in bold and introduced a field on the class
    called `behaviourFn()`. Furthermore, our `create()` method instantiated an `Observable`
    by passing in `behaviourFn` from the `create()` method parameter. This means the
    constructor needs to take a function as a parameter and save that for later use.
    What do we know about the `behaviourFn()` that was passed into the create method?
    We know it takes an Observer instance as a parameter and it also lays out what
    values the Observer instance should emit. For anything to be able to capture those
    emitted values, we need to implement our last method, `subscribe()`. We know that
    `subscribe()` takes `dataFn()` as a parameter and needs to somehow invoke our
    `behaviourFn` when the `subscribe()` method is being invoked to trigger the behavior.
    Let''s therefore amend that in our existing code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用粗体标出了所需更改，并在类中引入了一个名为`behaviourFn()`的字段。此外，我们的`create()`方法通过传递`create()`方法参数中的`behaviourFn`来实例化一个`Observable`。这意味着构造函数需要接受一个函数作为参数，并将其保存以供以后使用。关于传递给`create`方法的`behaviourFn()`，我们知道它接受一个观察者实例作为参数，并规定了观察者实例应该发出哪些值。为了使任何东西能够捕获这些发出的值，我们需要实现我们的最后一个方法，`subscribe()`。我们知道`subscribe()`接受`dataFn()`作为参数，并在调用`subscribe()`方法时以某种方式调用我们的`behaviourFn`以触发行为。因此，让我们在我们的现有代码中修改这一点：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At this point, we realize that we need an `Observer` class so that we actually
    have something to pass to our `behaviourFn()`. Another thing we need to figure
    out is how to invoke `dataFn()` and when. After a thinking for a minute, we realize
    the Observer must be the one responsible for invoking `dataFn()` so it seems only
    reasonable that `dataFn()` is passed into the constructor of our `Observer` class
    for later use, like so:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们意识到我们需要一个`Observer`类，这样我们才能向`behaviourFn()`传递一些东西。我们还需要弄清楚如何调用`dataFn()`以及何时调用。经过一分钟思考，我们意识到观察者必须负责调用`dataFn()`，因此似乎只有将`dataFn()`传递到我们的`Observer`类的构造函数中，以便以后使用，才是合理的，如下所示：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'By implementing this `Observer` class, we have done three things: one is to
    pass the `dataFn()` through the constructor and make it into a field on the `Observer`
    class; another is to create a `next()` method on the `Observer`, which had to
    be done as we learned that an Observer instance should call `next()` to generate
    values; the third and final thing we did was to ensure that we invoked `dataFn()`
    inside of the `next()` method to be sure that the subscriber is being told every
    time we generate a value by calling the `next()` method. Putting all of this code
    together, we have created a very bare implementation of RxJS, which actually works!
    To better understand what we have so far, let''s display all the code used so
    far:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现这个`Observer`类，我们做了三件事：一是通过构造函数传递`dataFn()`并将其作为`Observer`类的一个字段；二是创建了一个`next()`方法在`Observer`上，这是我们必须做的，因为我们了解到观察者实例应该调用`next()`来生成值；第三，我们确保在`next()`方法内部调用`dataFn()`，以确保每当通过调用`next()`方法生成值时，订阅者都会被告知。将所有这些代码放在一起，我们创建了一个非常基础的RxJS实现，实际上它是可以工作的！为了更好地理解我们目前所拥有的，让我们显示到目前为止使用的所有代码：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Handling subscriptions
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理订阅
- en: 'We learned how to implement a very basic core in the last section. Earlier
    in the chapter, however, it was mentioned that sometimes your Observable will
    allocate resources or will display a behavior where it clearly won''t be able
    to stop generating values. It is our responsibility to handle such situations
    in a graceful manner. RxJS has clearly laid out a path here, which is to define
    a cleanup function and ensure it is invoked upon calling `unsubscribe()`. Let''s
    show such a scenario, where we clearly need to care about cleaning up:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何实现一个非常基本的内核。然而，在本章的早期部分，提到有时你的 Observable 会分配资源或显示一种明显无法停止生成值的行为。处理这种情况是我们的责任。RxJS
    明确地在这里指出了路径，即定义一个清理函数并确保在调用 `unsubscribe()` 时调用它。让我们展示这样一个场景，其中我们显然需要关注清理：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Looking at the code, we see that when we define the behavior function (at the
    bottom of the code snippet), we set up a `setInterval()` construct that calls
    `observer.next(`) periodically. We ensure we save the reference in a variable
    ID. This need to be sure that we can cancel the `setInterval()` behavior when
    we choose to. We do that by defining a `cleanUpFn()` in the last row of the `behaviourFn`
    function. This brings us to the top half of our snippet. Here, we see that we
    amend the `subscribe()` method by ensuring we save the result of calling `this.behaviourFn()`
    into a variable called `cleanUpFn`. This is indeed the `cleanUpFn()` we defined
    in `behaviourFn()`. Lastly, we expose the `cleanUpFn()` property by returning
    it as part of an object and assigning it to the `unsubscribe()` property. The
    last thing we need to do is to call the `unsubscribe()` method to ensure our allocated
    resources are released or, as in this specific example, that the `setInterval()`
    construct is cancelled. Calling unsubscribe will call `cleanUpFn()` which in turn
    calls `clearInterval()`, which will cancel the interval.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 查看代码，我们发现当我们定义行为函数（代码片段的底部）时，我们设置了一个 `setInterval()` 构造，该构造定期调用 `observer.next(`）。我们确保将引用保存在变量
    ID 中。我们需要确保当我们选择取消 `setInterval()` 行为时可以做到这一点。我们通过在 `behaviourFn` 函数的最后一行定义一个
    `cleanUpFn()` 来做到这一点。这使我们来到了代码片段的上半部分。在这里，我们看到我们通过确保将调用 `this.behaviourFn()` 的结果保存到名为
    `cleanUpFn` 的变量中来修改 `subscribe()` 方法。这确实是我们在 `behaviourFn()` 中定义的 `cleanUpFn()`。最后，我们通过将其作为对象的一部分返回并将其分配给
    `unsubscribe()` 属性来公开 `cleanUpFn()` 属性。最后我们需要做的是调用 `unsubscribe()` 方法以确保我们的分配资源被释放，或者在这个特定例子中，取消
    `setInterval()` 构造。调用 unsubscribe 将会调用 `cleanUpFn()`，然后它将调用 `clearInterval()`，这将取消间隔。
- en: Adding operators
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加操作符
- en: 'We have come a long way in defining our own core implementation of RxJS, but
    we are missing an important piece of the puzzle—operators. Operators are the real
    power of RxJS and can be seen as a utility method that allows us to manipulate
    our stream with ease. Let''s select `filter()` as the target of our example. A
    filter operator is a method that you can call on the stream. The idea is to provide
    it with a function that is able to determine, value for value, whether the specific
    value in question should be emitted. A typical use case looks like the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在定义自己的 RxJS 内核实现方面已经走了很长的路，但我们还缺少一个重要的拼图——操作符。操作符是 RxJS 的真正力量，可以被视为一个实用方法，它允许我们轻松地操作我们的流。让我们以
    `filter()` 作为我们的示例目标。一个过滤操作符是一个你可以对其流调用的方法。想法是提供一个函数，能够逐个值地确定特定值是否应该被发出。一个典型的用例如下：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code, we can see that the function we provide as a parameter
    to the filter function effectively sorts out any values not meeting the condition.
    In this case, all values above `1` will be emitted, thereby sorting the value
    `1`. Let''s add the `filter()` method to our previously defined `MyObservable`
    class, like so:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们提供给过滤函数的参数函数有效地排除了任何不符合条件的值。在这种情况下，所有大于 `1` 的值将被发出，从而对值 `1`
    进行排序。让我们将 `filter()` 方法添加到我们之前定义的 `MyObservable` 类中，如下所示：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can see from the preceding snippet that the `filter()` method is added to
    the `MyObservable` and we see that it itself returns an Observable, while also
    taking a `filterFn()` as a parameter. The question you need to ask yourself is
    whether our existing `MyObservable` constructor will do. Our existing constructor
    takes a `behaviourFn()` and we most likely need to store the incoming `filterFn`
    parameter, so we need to extend the constructor or opt for a new implementation
    of an `MyObservable`. We ponder this for a second and realize its probably better
    to go for a new, more dedicated `MyObservable` as we want to avoid a lot of branching
    logic. Therefore, the implementation of said method should be amended to look
    something like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中我们可以看到，`filter()`方法被添加到了`MyObservable`中，我们看到它本身返回一个Observable，同时接受一个`filterFn()`参数。你需要问自己的问题是，我们现有的`MyObservable`构造函数是否足够。我们现有的构造函数接受一个`behaviourFn()`，我们很可能需要存储传入的`filterFn`参数，因此我们需要扩展构造函数或选择一个新的`MyObservable`实现。我们思考了一下，意识到选择一个新的、更专门的`MyObservable`可能更好，因为我们想避免大量的分支逻辑。因此，该方法的实现应该修改为类似以下的样子：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'OK, so now we have a new class to implement, `FilterableObservable`. This class
    should share most of the behavior of the `MyObservable`, but instead show how
    we emit data. So, we are talking about inheriting from `MyObservable` but with
    our own special twist. Let''s attempt an implementation:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们有一个新的类要实现，`FilterableObservable`。这个类应该共享`MyObservable`的大部分行为，但展示我们如何发出数据。因此，我们是在从`MyObservable`继承，但有自己的特别之处。让我们尝试一个实现：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can see in the preceding code snippet that we override the `subscribe()`
    implementation, or more specifically, we override the `next()` method on the `Observer`
    instance. We use `filterFn()` for what it was made for, to assess whether something
    should be generated or not. We have now successfully implemented the `filter()`
    operator.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到我们重写了`subscribe()`实现，或者更具体地说，我们在`Observer`实例上重写了`next()`方法。我们使用`filterFn()`来评估是否应该生成某个值。现在我们已经成功实现了`filter()`操作符。
- en: Revisiting the basics, adding errors, and complete
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾基础知识，添加错误和完成
- en: 'After having taken on the heroic feat of implementing the basics of RxJS, we
    hopefully feel pretty good about understanding its inner workings. So far, we
    have only implemented `dataFn` in `subscribe()`; there are two more callbacks
    in the `subscribe()` method that we need to implement. Let''s look at a code snippet
    and highlight what is missing:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成了RxJS基础实现的英勇壮举之后，我们希望对理解其内部工作原理感到相当满意。到目前为止，我们只在`subscribe()`中实现了`dataFn`；`subscribe()`方法中还有两个回调需要实现。让我们看一个代码片段并突出显示缺失的部分：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We have highlighted the two last callbacks as the missing functionality. We
    know from before that to trigger the error callback, we need to call `observer.error(''some
    message'')`. We also know that no values should be emitted after an error is raised.
    Let''s provide an example of such a case:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经突出了最后两个回调作为缺失的功能。我们知道，为了触发错误回调，我们需要调用`observer.error('some message')`。我们也知道，在抛出错误后不应再发出任何值。让我们提供一个这样的例子：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'At this point, we realize that our `Observer` class is the one that needs amending
    to support the `error()` method call. We also need to be wary of the condition
    we just described, as no more values should be emitted after an error has occurred.
    Let''s jump into an implementation:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们意识到需要修改我们的`Observer`类以支持`error()`方法调用。我们还需要警惕我们刚才描述的条件，因为错误发生后不应再发出更多值。让我们直接进入实现：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can see in the preceding snippet that we pass another parameter into the
    `errorFn` constructor. The `next()` method needed updating, so we needed to envelope
    it with a conditional that says whether to generate a value or not. Lastly, we
    needed to define the `error()` method as calling the passed-in `errorFn` and setting
    the `hasError` field to `true`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到我们向`errorFn`构造函数传递了另一个参数。`next()`方法需要更新，因此我们需要用条件包装它，以确定是否生成值。最后，我们需要定义`error()`方法，调用传入的`errorFn`并设置`hasError`字段为`true`。
- en: 'We need to do one more thing and that is to update our `subscribe()` method
    in the `Observable` class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要做一件事，那就是更新`Observable`类中的`subscribe()`方法：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A little heads up is that when we define the `filter()` operator to override
    the `next()` method, we need to ensure this one takes `hasError` into consideration
    when determining whether to generate a value. We'll leave this to you, dear reader,
    to implement.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 提前提醒一下，当我们定义 `filter()` 操作符以覆盖 `next()` 方法时，我们需要确保这个操作符在确定是否生成值时考虑到 `hasError`。我们将把这个留给你，亲爱的读者，去实现。
- en: 'The last order of business is to support completion. Completion has many similarities
    with raising an error, in the sense that no more values should be emitted. The
    difference is that we should hit the last callback instead. As with the `error()`
    method implementation, we start with the `Observer` implementation:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件待办事项是支持完成。完成与抛出错误有许多相似之处，即不应再发出更多值。区别在于我们应该触发最后一个回调。与 `error()` 方法实现一样，我们从
    `Observer` 实现开始：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Given the preceding code, we see that our changes entail adding an `isCompleted`
    field. We also pass a `completeFn()` in the constructor. Logic needs to be added
    in the `next()` value, as completion is now another state we need to look for
    besides error. Lastly, we added the `complete()` method, which just invokes the
    passed-in function and sets the `isComplete` field to `true`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的代码，我们看到我们的更改包括添加一个 `isCompleted` 字段。我们还向构造函数中传递了一个 `completeFn()`。需要在 `next()`
    值中添加逻辑，因为完成现在是我们需要寻找的另一个状态，除了错误之外。最后，我们添加了 `complete()` 方法，它只是调用传入的函数并将 `isComplete`
    字段设置为 `true`。
- en: 'As before, we need to update the `Observable` class to pass the complete function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们需要更新 `Observable` 类以传递完成函数：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A quick reality check here: we have actually implemented the core functionality
    of RxJS—Observer, Observable, and one operator. We are much closer to understanding
    what is going on. We realize that implementing the other 59 operators is quite
    a feat, and it is probably not a good idea when there is a team maintaining the
    existing RxJS repository. Our newfound knowledge is not for nothing; understanding
    what is going on can never be wrong. Who knows? Maybe one of you readers will
    become a contributor; you have certainly been given the tools.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里做一个快速的实际情况检查：我们实际上已经实现了 RxJS 的核心功能——观察者、Observable 和一个操作符。我们离理解正在发生的事情更近了。我们意识到实现其他
    59 个操作符是一项相当大的成就，而且当有一个团队维护现有的 RxJS 存储库时，这可能不是一个好主意。我们新获得的知识并非徒劳；理解正在发生的事情永远不会错。谁知道呢？也许你们中的某位读者将成为贡献者；你们确实已经得到了工具。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started off by talking about the patterns that make up RxJS. We continued
    by describing its core concepts. This was followed by describing how and when
    it was necessary to create your own Observable, opt for one of RxJS many creation
    operators, or rely on the Angular framework to do this job for you. We briefly
    discussed the importance of cleaning up after your Observable and when it was
    a good idea to do so.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论了构成 RxJS 的模式。接着，我们描述了其核心概念。随后，我们解释了何时以及为什么需要创建自己的 Observable，选择 RxJS 的众多创建操作符之一，或者依赖
    Angular 框架来完成这项工作。我们简要讨论了清理 Observable 的重要性以及何时这样做是个好主意。
- en: Lastly, we took on the task of implementing part of the RxJS core to gain a
    deeper understanding of its core concepts and how it all came together. This has
    hopefully given you a pretty solid foundation and in-depth understanding of RxJS
    as we venture into the next chapter, which will cover more operators, and some
    more advanced concepts.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们承担了实现 RxJS 核心部分的任务，以更深入地理解其核心概念以及它是如何结合在一起的。这希望给你们提供了一个相当坚实的基础和深入的理解，当我们进入下一章时，将涵盖更多操作符和一些更高级的概念。
