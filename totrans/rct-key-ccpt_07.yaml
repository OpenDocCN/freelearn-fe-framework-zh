- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Portals and Refs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use direct DOM element access to interact with elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose the functions and data of your components to other components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control the position of rendered JSX elements in the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React.js is all about building user interfaces, and, in the context of this
    book, it’s specifically about building web user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web user interfaces are ultimately all about the **Document Object Model**
    ( **DOM** ). You can use JavaScript to read or manipulate the DOM. This is what
    allows you to build interactive websites: you can add, remove, or edit DOM elements
    after a page has been loaded. This can be used to add or remove overlay windows
    or to read values entered into input fields.'
  prefs: []
  type: TYPE_NORMAL
- en: This was discussed in *Chapter 1* , *React – What and Why* , and, as you learned
    there, React is used to simplify this process. Instead of manipulating the DOM
    or reading values from DOM elements manually, you can use React to describe the
    desired state. React then takes care of the steps needed to achieve this desired
    state.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are scenarios and use cases wherein, despite using React, you
    still want to be able to directly reach out to specific DOM elements—for example,
    to read a value entered by a user into an input field, or if you’re not happy
    with the position of a newly inserted element in the DOM that was chosen by React.
  prefs: []
  type: TYPE_NORMAL
- en: 'React provides certain functionalities that help you in exactly these kinds
    of situations: **Portals** and **Refs** . Even though directly manipulating the
    DOM will still not be a great idea, these tools, as you will learn throughout
    this chapter, can help with reading DOM element values or with changing the DOM
    structure without working against React.'
  prefs: []
  type: TYPE_NORMAL
- en: A World without Refs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following example: you have a website that renders an input field,
    requesting a user’s email address. It could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A white box with a rectangle and a purple rectangle  Description automatically
    generated](img/B31339_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: An example form with an email input field'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the component that’s responsible for rendering the form and handling
    the entered email address value might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this example uses the `useState()` Hook, combined with the `change`
    event, to register keystrokes in the `email` input field and store the entered
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code works fine, and there is nothing wrong with having this kind of code
    in your application. But adding the extra event listener and state, as well as
    adding the function to update the state whenever the `change` event is triggered,
    is quite a bit of boilerplate code for one simple task: getting the entered email
    address.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code snippet does nothing else with the email address other than
    submit it. In other words, the only reason for using the `enteredEmail` state
    in the example is to read the entered value.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the `enteredEmail` is only required in the `handleSubmitForm()`
    function, React will re-execute the `EmailForm` component function for every `enteredEmail`
    state updated, i.e., for every keystroke in the `<input>` field. This is also
    not ideal since it leads to lots of unnecessary code execution and hence potential
    performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'In scenarios such as this, quite a bit of code (and maybe performance) could
    be saved if you fell back to some vanilla JavaScript logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These two lines of code (which could be merged into one line theoretically)
    allow you to get hold of a DOM element and read the currently stored value.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this kind of code is that it does not use React. And if you’re
    building a React app, you should really stick to React when working with the DOM.
    Don’t start blending your own vanilla JavaScript code *that accesses the DOM*
    into the React code.
  prefs: []
  type: TYPE_NORMAL
- en: This can lead to unintended behaviors or bugs, especially if you start manipulating
    the DOM. It could lead to bugs because React would not be aware of your changes
    in that case; the actual rendered UI would not be in sync with React’s assumed
    UI. Even if you’re just reading from the DOM, it’s a good habit to not even start
    merging vanilla JavaScript DOM access methods with your React code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To still allow you to get hold of DOM elements and read values, as shown above,
    React gives you a special concept that you can use: **Refs** .'
  prefs: []
  type: TYPE_NORMAL
- en: Ref stands for reference, and it’s a feature that allows you to store references
    to values—for example, to DOM elements from inside a React component. The preceding
    vanilla JavaScript code would do the same (it also gives you access to a rendered
    element), but when using Refs, you can get access without mixing vanilla JavaScript
    code into your React code.
  prefs: []
  type: TYPE_NORMAL
- en: Refs can be created using a special React Hook called the `useRef()` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'This Hook can be executed to generate a `ref` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This generated Ref object, `emailRef` in the preceding example, is initially
    set to null but can then be assigned to any JSX element. This assignment is done
    via a special prop (the `ref` prop) that is automatically supported by every JSX
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Just like the `key` prop introduced in *Chapter 5* , *Rendering Lists and Conditional
    Content* , the `ref` prop is provided by React. The `ref` prop wants a Ref object,
    i.e., one that was created via `useRef()` .
  prefs: []
  type: TYPE_NORMAL
- en: In this example, `useRef()` receives `null` as an initial value since it’s technically
    not yet assigned to the DOM element when the component function executes for the
    first time. It’s only after that initial component render cycle that the connection
    will be established. Therefore, after this first component function execution,
    the value stored in the Ref will be the underlying DOM object of the `<input>`
    element in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that Ref object created and assigned, you can then use it to get access
    to the connected JSX element (to the `<input>` element in this example). There’s
    just one important thing to note: to get hold of the connected element, you must
    access a special `current` prop on the created Ref object. This is required because
    React stores the value assigned to the Ref object in a nested object, accessible
    via the `current` property, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`emailRef.current` yields the underlying DOM object that was rendered for the
    connected JSX element. In this case, it therefore allows access to the input element
    DOM object. Since that DOM object has a `value` property, this `value` property
    can be accessed without issue.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: For further information on this topic, see [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attributes)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'With this kind of code, you can read the value from the DOM element without
    having to use `useState()` and an event listener. The final component code therefore
    becomes quite a bit leaner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Refs versus State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Refs can be used to get quick and easy access to DOM elements, the question
    that might come up is whether you should always use Refs instead of state.
  prefs: []
  type: TYPE_NORMAL
- en: The clear answer to this question is “no.”
  prefs: []
  type: TYPE_NORMAL
- en: Refs can be a very good alternative in use cases like the one shown above, when
    you need read access to an element. This is very often the case when dealing with
    user input. In general, Refs can replace state if you’re just accessing some value
    to read it when some function (a form submit handler function, for example) is
    executed. As soon as you need to change values and those changes must be reflected
    in the UI (for example, by rendering some conditional content), Refs are out of
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, if, besides getting the entered value, you’d also like
    to reset (i.e., clear) the email input after the form was submitted, you should
    use state again. While you could reset the input with the help of a Ref, you should
    not do that. You would start manipulating the DOM, and only React should do that—with
    its own, internal methods, based on the declarative code you provide to React.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should avoid resetting the email input like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you should reset it by using React’s state concept and by following
    the declarative approach embraced by React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: As a rule, you should simply try to avoid writing imperative code in React projects.
    Instead, tell React how the final UI should look and let React figure out how
    to get there.
  prefs: []
  type: TYPE_NORMAL
- en: Reading values via Refs is an acceptable exception, and manipulating DOM elements
    (with or without Refs, e.g., by directly selecting DOM nodes via `document.getElementById()`
    or similar) should be avoided. A rare exception is a scenario such as calling
    `focus()` on an input element DOM object because methods like `focus()` don’t
    typically cause any DOM changes that could break the React app.
  prefs: []
  type: TYPE_NORMAL
- en: Using Refs for More than DOM Access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing DOM elements (for reading values) is one of the most common use cases
    for using Refs. As shown above, it can help you reduce code in certain situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'But Refs are more than just “element connection bridges;” they are objects
    that can be used to store all kinds of values—not just pointers at DOM objects.
    You can, for example, also store strings or numbers or any other kind of value
    in a Ref:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can pass an initial value to `useRef()` ( `0` in this example) and then
    access or change that value at any point in time inside the component to which
    the Ref belongs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: However, you still have to use the `current` property to read and change the
    stored value, because, as mentioned above, this is where React will store the
    actual value that belongs to the Ref.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be useful for storing data that should “survive” component re-evaluations.
    As you learned in *Chapter 4* , *Working with Events and State* , React will execute
    component functions every time the state of a component changes. Since the function
    is executed again, any data stored in function-scoped variables would be lost.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, counters 1 and 3 would change to 1 once the button is clicked.
    However, counter 2 would remain zero, even though the `counter2` variable gets
    changed to a value of 1 in `handleChangeCounters` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Only two of the three counter values changed'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, it should be expected that the state value changes and the
    new value is reflected in the updated user interface. That is the whole idea behind
    state, after all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ref ( `counterRef` ) also keeps its updated value across component re-evaluations,
    though. That’s the behavior described above: Refs are not reset or cleared when
    the surrounding component function is executed again. The vanilla JavaScript variable
    ( `counter2` ) does not keep its value. Even though it is changed in `handleChangeCounters`
    , a new variable is initialized when the component function is executed again;
    thus the updated value ( `1` ) is lost.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, it might again look like Refs can replace state, but the example
    actually shows very well why that is **not** the case. Try replacing `counter1`
    with another Ref (so that there is no state value left in the component) and clicking
    the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Nothing will change on the page because, while the button click is registered
    and the `handleChangeCounters` function is executed, no state change is initiated,
    and state changes (initiated via the `setXYZ` state updating function calls) are
    the triggers that cause React to re-evaluate a component. Changes to Ref values
    do **not** do that.
  prefs: []
  type: TYPE_NORMAL
- en: '![A comparison of numbers and numbers  Description automatically generated
    with medium confidence](img/B31339_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: The counter values don’t change'
  prefs: []
  type: TYPE_NORMAL
- en: As you can tell, changing Ref values does not trigger component functions to
    be executed again—state, on the other hand, does. However, if a component function
    runs again (due to a state change), Ref values are kept around and not dropped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, if you have data that should survive component re-evaluations but
    should not be managed as state (because changes to that data should not cause
    the component to be re-evaluated when changed), you could use a Ref:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is not a feature that’s used frequently, but it can be helpful from time
    to time. In all other cases, use normal state values.
  prefs: []
  type: TYPE_NORMAL
- en: Refs in Custom Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refs cannot just be used to access DOM elements. You can also use them to access
    React components—including your own components.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can sometimes be useful. Consider this example: you have a `<Form>` component
    that contains a nested `<Preferences>` component. The latter component is responsible
    for displaying two checkboxes, asking the user for their newsletter preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: A newsletter sign-up form that shows two checkboxes to set newsletter
    preferences'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of the `Preferences` component could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it’s a basic component that essentially outputs the two checkboxes,
    adds some styling, and keeps track of the selected checkbox via state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Form` component code could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now imagine that upon form submission (inside of the `handleSubmit` function),
    the `Preferences` should be reset (i.e., no checkbox is selected anymore). In
    addition, prior to resetting, the selected values should be read and used in the
    `handleSubmit` function.
  prefs: []
  type: TYPE_NORMAL
- en: This would be straightforward if the checkboxes were not put into a separate
    component. If the entire code and JSX markup reside in the `Form` component, state
    could be used in that component to read and change the values. But this is not
    the case in this example, and rewriting the code just because of this problem
    sounds like an unnecessary restriction.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Refs can help in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: You can expose features (for example, functions or state values) of a component
    to other components via Refs. Refs can essentially be used as a *communication
    device* between two components, just as they were used as a *communication device*
    with a DOM element in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conveniently, your custom components can receive a ref as a regular prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You could therefore use this `Preferences` component and pass a `ref` to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to note that this code only works when using React 19 or higher.
    When working with an older React version, passing Refs as regular props to components
    is unfortunately not supported. In such projects, you would have to wrap the component
    function that should receive a Ref with a special `forwardRef()` function that’s
    provided by React.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in React projects using React 18 or older, to receive and use Refs,
    you must wrap the receiving component ( `Preferences` , in this example) with
    `forwardRef()` .
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks slightly different than all the other components in this book because
    an arrow function is used instead of the `function` keyword. You can always use
    arrow functions instead of “normal functions”, but here it’s helpful to switch
    as it makes wrapping the function with `forwardRef()` very easy. Alternatively,
    you could stick to the `function` keyword and wrap the function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It is up to you which syntax you prefer. Both work and both are commonly used
    in React projects.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part about this code is that the component function now receives
    **two** parameters instead of one. Besides receiving `props` , which component
    functions always do, it now also receives a special `ref` parameter. And this
    parameter is only received because the component function is wrapped with `forwardRef()`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'This `ref` parameter will contain any `ref` value set by the component using
    the `Preferences` component. For example, the `Form` component could set a `ref`
    parameter on `Preferences` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Again, `useRef()` is used to create a `ref` object ( `preferencesRef` ), and
    that object is then passed via the special `ref` prop to the `Preferences` component.
    The created Ref receives a default value of an empty object ( `{}` ); it’s this
    object that can then be accessed via `ref.current` . In the `Preferences` component,
    the `ref` value can either be received and extracted like a regular prop (React
    >= 19) or must be accessed with the help of React’s `forwardRef()` function. In
    that case, it’s received via this second `ref` parameter, which exists because
    of `forwardRef()` .
  prefs: []
  type: TYPE_NORMAL
- en: But what’s the benefit of that? How can this `preferencesRef` object now be
    used inside `Preferences` to enable cross-component interaction?
  prefs: []
  type: TYPE_NORMAL
- en: Since `ref` is an object that is never replaced, even if the component in which
    it was created via `useRef()` is re-evaluated (see previous sections above), the
    receiving component can assign properties and methods to that object and the creating
    component can then use these methods and properties. The `ref` object is therefore
    used as a communication vehicle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `Preferences` component could be changed like this to
    use the `ref` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In `Preferences` , both the state values and a pointer at a newly added `reset`
    function are stored in the received `ref` object. `ref.current` is used since
    the object created by React (when using `useRef()` ) always has such a `current`
    property, and that property should be used to store the actual values in `ref`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `Preferences` and `Form` operate on the same object that’s stored in
    the `ref` object, the properties and methods assigned to the object in `Preferences`
    can also be used in `Form` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By using Refs like this, a parent component ( `Form` , in this case) is able
    to interact with some child component (for instance, `Preferences` ) in an imperative
    way—meaning properties can be accessed and methods called to manipulate the child
    component (or, to be precise, to trigger some internal functions and behavior
    inside the child component).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: React also provides an `useImperativeHandle()` Hook that may be used to expose
    data or functions from custom components.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, you don’t need to use this Hook, as the above examples prove. You
    can communicate between components via Refs without any extra Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'But you might want to consider using `useImperativeHandle()` since it will
    handle scenarios like missing `ref` values (i.e., if no `ref` value is provided).
    You can learn more about the usage of this (arguably niche) Hook in the official
    documentation: [https://react.dev/reference/react/useImperativeHandle](https://react.dev/reference/react/useImperativeHandle)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Controlled versus Uncontrolled Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Passing Refs to custom components (via props or `forwardRef()` ) is a method
    that can be used to allow the `Form` and `Preferences` components to work together.
    But even though it might look like an elegant solution at first, it should typically
    not be your default solution for this kind of problem.
  prefs: []
  type: TYPE_NORMAL
- en: Using Refs, as shown in the example above, leads to more imperative code in
    the end. It’s imperative code because instead of defining the desired user interface
    state via JSX (which would be declarative), individual step-by-step instructions
    are added in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: If you revisit *Chapter 1* , *React – What and Why* (the *The Problem with Vanilla
    JavaScript* section), you’ll see that code such as `preferencesRef.current.reset()`
    (from the example above) looks quite similar to instructions such as `buttonElement.addEventListener(…)`
    (example from *Chapter 1* ). Both examples use imperative code and should be avoided
    for the reasons mentioned in *Chapter 1* (writing step-by-step instructions leads
    to inefficient micro-management and often unnecessarily complex code).
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Form` component, the `reset()` function of `Preferences` is invoked.
    Hence, the code describes the desired action that should be performed (instead
    of the expected outcome). Typically, when working with React you should strive
    to describe the desired (UI) state instead. Remember, when working with React,
    that you should write declarative, rather than imperative, code.
  prefs: []
  type: TYPE_NORMAL
- en: When using Refs to read or manipulate data as shown in the previous sections
    of this chapter, you are building so-called **uncontrolled components** . The
    components are considered “uncontrolled” because React is not directly controlling
    the UI state. Instead, values are read from other components or the DOM. It’s
    therefore the DOM that controls the state (e.g., a state such as the value entered
    by a user into an input field).
  prefs: []
  type: TYPE_NORMAL
- en: As a React developer, you should try to minimize the use of uncontrolled components.
    It’s absolutely fine to use Refs to save some code if you only need to gather
    some entered values. But as soon as your UI logic becomes more complex (for example,
    if you also want to clear user input), you should go for **controlled components**
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing so is quite straightforward: a component becomes controlled as soon as
    React manages the state. In the case of the `EmailForm` component from the beginning
    of this chapter, the controlled component approach was shown before Refs were
    introduced. Using `useState()` to store the user’s input (and update the state
    with every keystroke) meant that React was in full control of the entered value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the previous example, the `Form` and `Preferences` components, switching
    to a controlled component approach could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Preferences` component stops managing the checkbox state
    and instead receives props from its parent component (the `Form` component).
  prefs: []
  type: TYPE_NORMAL
- en: '`bind()` is used on the `onUpdateInfo` prop (which will receive a function
    as a value) to *pre-configure* the function for future execution. `bind()` is
    a default JavaScript method that can be called on any JavaScript function to control
    which arguments will be passed to that function once it’s invoked in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about this JavaScript feature at [https://academind.com/tutorials/function-bind-event-execution](https://academind.com/tutorials/function-bind-event-execution)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Form` component now manages the checkbox states, even though it doesn’t
    directly contain the checkbox elements. But it now begins to control the `Preferences`
    component and its internal state, hence turning `Preferences` into a controlled
    component instead of an uncontrolled one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`Form` manages the checkbox selection state, including resetting the state
    via the `reset()` function, and passes the managed state values ( `wantsNewProdInfo`
    and `wantsProdUpdateInfo` ) as well as the `handleUpdateProdInfo` function, which
    updates the state values, to `Preferences` . The `Form` component now controls
    the `Preferences` component.'
  prefs: []
  type: TYPE_NORMAL
- en: If you go through the two code snippets above, you’ll notice that the final
    code is once again purely declarative. Across all components, state is managed
    and used to declare the expected user interface.
  prefs: []
  type: TYPE_NORMAL
- en: It is considered a good practice to go for controlled components in most cases.
    If you are only extracting some entered user input values, however, then using
    Refs and creating an uncontrolled component is absolutely fine.
  prefs: []
  type: TYPE_NORMAL
- en: React and Where Things End up in the DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Leaving the topic of Refs, there is one other important React feature that
    can help with influencing (indirect) DOM interaction: **Portals** .'
  prefs: []
  type: TYPE_NORMAL
- en: When building user interfaces, you sometimes need to display elements and content
    conditionally. This was already covered in *Chapter 5* , *Rendering Lists and
    Conditional Content* . When rendering conditional content, React will inject that
    content into the place in the DOM where the overall component (in which the conditional
    content is defined) is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when showing a conditional error message below an input field,
    that error message is right below the input in the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '*![A screen shot of a computer  Description automatically generated](img/B31339_07_05.png)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.5: The error message DOM element sits right below the <input> it belongs
    to'
  prefs: []
  type: TYPE_NORMAL
- en: This behavior makes sense. Indeed, it would be pretty irritating if React were
    to start inserting DOM elements in random places. But in some scenarios, you may
    prefer a (conditional) DOM element to be inserted in a different place in the
    DOM—for example, when working with overlay elements such as error dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, you could add logic to ensure that an error dialog
    is presented to the user if the form is submitted with an invalid email address.
    This could be implemented with logic similar to the `"Invalid email address!"`
    error message, and therefore the dialog element would, of course, also be injected
    dynamically into the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer screen  Description automatically generated](img/B31339_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: The error dialog and its backdrop are injected into the DOM'
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, the error dialog is opened as an overlay above a backdrop
    element, which is itself added so that it acts as an overlay to the rest of the
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The appearance is handled entirely by CSS, and you can take a look at the complete
    project (including the styling) here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/examples/05-portals-problem](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/examples/05-portals-problem)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: This example works and looks fine. However, there is room for improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Semantically, it doesn’t entirely make sense to have the overlay elements injected
    somewhere nested into the DOM next to the `<input>` element. It would make more
    sense for overlay elements to be closer to the root of the DOM (in other words,
    to be direct child elements of `<div id="root">` or even `<body>` ), instead of
    being children of `<form>` . And it’s not just a semantic problem. If the example
    app contains other overlay elements, those elements might clash with each other,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_07_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: The <footer> element at the bottom is visible above the backdrop'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `<footer>` element at the bottom (“An example project”)
    is not hidden or grayed out by the backdrop that belongs to the error dialog.
    The reason for that is that the footer also has some CSS styling attached that
    turns it into a de facto overlay (because of `position: fixed` and `left` + `bottom`
    being used in its CSS styles).'
  prefs: []
  type: TYPE_NORMAL
- en: As a solution to this problem, you could tweak some CSS styles and, for example,
    use the `z-index` CSS property to control overlay levels. However, it would be
    a cleaner solution if the overlay elements (i.e., the `<div>` backdrop and the
    `<dialog>` error elements) were inserted into the DOM in a different place—for
    example, at the very end of the `<body>` element (but as direct children to `<body>`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: And that’s exactly the kind of problem React **Portals** help you solve.
  prefs: []
  type: TYPE_NORMAL
- en: Portals to the Rescue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Portal** , in React’s world, is a feature that allows you to instruct React
    to insert a DOM element in a different place than where it would normally be inserted.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the example shown above, this portal feature can be used to *tell*
    React to not insert the `<dialog>` error and the `<div>` backdrop that belongs
    to the dialog inside the `<form>` element, but to instead insert those elements
    at the end of the `<body>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this portal feature, you first must define a place wherein elements
    can be inserted (an “injection hook”). This can be done in the HTML file that
    belongs to the React app (i.e., `index.html` ). There, you can add a new element
    (for example, a `<div>` element) somewhere in the `<body>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, a `<div id="dialogs">` element is added in the `<body>` section,
    after the `<div id="root">` element to make sure that any components (and their
    styles) inserted in that element are evaluated last. This will ensure that their
    styles take a higher priority and overlay elements inserted into `<div id="dialogs">`
    would not be overlaid by other content coming earlier in the DOM. Adding and using
    multiple hooks would be possible, but for this example, only one *injection point*
    is needed. You can also use HTML elements other than `<div>` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `index.html` file adjusted, React can be instructed to render certain
    JSX elements (i.e., components) in a specified *injection point* via the `createPortal()`
    function of `react-dom` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this `ErrorDialog` component, which is rendered conditionally by another
    component (the `EmailForm` component, the example code for which is available
    on GitHub), the returned JSX code is wrapped by `createPortal()` . `createPortal()`
    takes two arguments: the JSX code that should be rendered in the DOM and a pointer
    at the element in `index.html` where the content should be injected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the newly added `<div id="dialogs">` is selected via `document.getElementById(''dialogs'')`
    . Therefore, `createPortal()` ensures that the JSX code generated by `ErrorDialog`
    is rendered in that place in the HTML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_07_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: The overlay elements are inserted into <div id=”dialogs”>'
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, you can see that the overlay elements ( `<div>` backdrop
    and `<dialog>` error) are indeed inserted into the `<div id="dialogs">` element,
    instead of the `<form>` element (as they were before).
  prefs: []
  type: TYPE_NORMAL
- en: As a result of this change, `<footer>` no longer overlays the error dialog backdrop
    without any CSS code changes. Semantically, the final DOM structure also makes
    more sense since you would typically expect overlay elements to be closer to the
    root DOM node.
  prefs: []
  type: TYPE_NORMAL
- en: Still, using this portal feature is optional. The same visual result (though
    not the DOM structure) could have been achieved by changing some CSS styles. Nonetheless,
    aiming for a clean DOM structure is a worthwhile pursuit, and avoiding unnecessarily
    complex CSS code is also not a bad thing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Key Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refs can be used to gain direct access to DOM elements or to store values that
    won’t be reset or changed when the surrounding component is re-evaluated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only use this direct access to read values, not to manipulate DOM elements (let
    React do this instead).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components that gain DOM access via Refs, instead of state and other React features,
    are considered uncontrolled components (because React is not in direct control).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer controlled components (using state and a strictly declarative approach)
    over uncontrolled components unless you’re performing very simple tasks such as
    reading an entered input value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Refs, you can also expose features of your own components so that they
    may be used imperatively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can set and use a `ref` prop on custom components when working with React
    19 or higher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using React < 19, React’s `forwardRef()` function must be used to receive
    Refs on custom components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Portals can be used to instruct React to render JSX elements in a different
    place in the DOM than they normally would.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point in the book, you’ve encountered many key tools and concepts that
    can be used to build interactive and engaging user interfaces. Thanks to Refs,
    you can read DOM values without using state (hence avoiding unnecessary component
    re-evaluations) or manage values that persist across component updates. Thanks
    to Portals, you’re able to control where exactly component markup is inserted
    into the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, you get some new tools that can be used to fine-tune your React
    app. You may be able to improve performance (by avoiding component re-evaluations)
    or improve the structure and semantics of your DOM elements. Ultimately, it’s
    the combination of all these tools that allows you to build engaging, interactive,
    and also performant web applications with React.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, as you will learn in the next chapter, React has even more helpful core
    concepts to offer: for example, a way of handling **side effects** .'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will explore what exactly **side effects** are, why they need
    special handling, and how React helps you with that.
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Knowledge!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers with examples that can
    be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/07-portals-refs/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/07-portals-refs/exercises/questions-answers.md)
    .
  prefs: []
  type: TYPE_NORMAL
- en: How can Refs help with handling user input in forms?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an uncontrolled component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a controlled component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you **not** use Refs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the main idea behind portals?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply What You Have Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this newly gained knowledge about Refs and Portals, it’s again time to
    practice what you have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Below, you’ll find two activities that allow you to practice working with Refs
    and Portals. As always, you will, of course, also need some of the concepts covered
    in earlier chapters (e.g., working with state).
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 7.1: Extract User Input Values'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you have to add logic to an existing React component to extract
    values from a form. The form contains an input field and a drop-down menu and
    you should make sure that, upon form submission, both values are read and, for
    the purpose of this dummy app, output to the browser console.
  prefs: []
  type: TYPE_NORMAL
- en: Use your knowledge about Refs and uncontrolled components to implement a solution
    without using React state.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the starting code for this activity at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-1-start)
    . When downloading this code, you’ll always download the entire repository. Make
    sure to then navigate to the subfolder with the starting code ( `activities/practice-1-start`
    in this case) to use the right code snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading the code and running `npm install` in the project folder
    (to install all the required dependencies), the solution steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create two Refs, one for each input element that should be read (input field
    and drop-down menu).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Refs to the input elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the submit handler function, access the connected DOM elements via the Refs
    and read the currently entered or selected values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the values to the browser console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![img](img/1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The expected result (user interface) should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_07_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: The browser developer tools console outputs the selected values'
  prefs: []
  type: TYPE_NORMAL
- en: ￼ **Note**
  prefs: []
  type: TYPE_NORMAL
- en: You will find all code files used for this activity, as well as the solution,
    at [ttps://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 7.2: Add a Side Drawer'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will connect an already existing `SideDrawer` component
    with a button in the main navigation bar to open the side drawer (i.e., display
    it) whenever the button is clicked. After the side drawer opens, a click on the
    backdrop should close the drawer again.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to implementing the general logic described above, your goal will
    be to ensure proper positioning in the final DOM so that no other elements are
    overlaid on top of the `SideDrawer` (without editing any CSS code). The `SideDrawer`
    should also not be nested in any other components or JSX elements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This activity comes with some starting code, which can be found here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-2-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-2-start)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading the code and running `npm install` to install all the required
    dependencies, the solution steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add logic to conditionally show or hide the `SideDrawer` component in the `MainNavigation`
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an *injection hook* for the side drawer in the HTML document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use React’s portal feature to render the JSX elements of `SideDrawer` in the
    newly added hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final user interface should look and behave like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_07_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: A click on the menu button opens the side drawer'
  prefs: []
  type: TYPE_NORMAL
- en: Upon clicking on the menu button, the side drawer opens. If the backdrop behind
    the side drawer is clicked, it should close again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final DOM structure (with the side drawer opened) should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_07_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: The drawer-related elements are inserted in a separate place in
    the DOM'
  prefs: []
  type: TYPE_NORMAL
- en: The side drawer-related DOM elements (the `<div>` backdrop and `<aside>` ) are
    inserted into a separate DOM node ( `<div id="drawer">` ).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You will find all code files used for this activity, as well as the solution,
    at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/07-portals-refs/activities/practice-2)
    .
  prefs: []
  type: TYPE_NORMAL
