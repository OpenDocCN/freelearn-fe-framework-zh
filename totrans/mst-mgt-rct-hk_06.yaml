- en: '*Chapter 4*: Sharing Module State with Subscription'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to use Context for a global state. As
    discussed, Context is not designed for the singleton pattern; it's a mechanism
    for avoiding the singleton pattern and providing different values for different
    subtrees. For a singleton-like a global state, using a module state makes more
    sense because it's a singleton value in memory. The goal of this chapter is to
    learn to use a module state with React. It's a less well-known pattern than Context,
    but is often used to integrate the existing module state.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Module State?
  prefs: []
  type: TYPE_NORMAL
- en: A strict definition of a module state would be some constants or variables defined
    in **ECMAScript** (**ES**) module scopes. In this book, we aren't following the
    strict definition. You can simply assume that a module state is a variable defined
    globally or within the scope of a file.
  prefs: []
  type: TYPE_NORMAL
- en: We'll explore how to use a module state as a global state in React. In order
    to use a module state in React components, we use a subscription mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the module state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a module state as a global state in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a basic Subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a selector and `useSubscription`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are expected to have a moderate knowledge of React, including React Hooks.
    Refer to the official site at [https://reactjs.org](https://reactjs.org) to learn
    more.
  prefs: []
  type: TYPE_NORMAL
- en: In some code, we use TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org))
    and you should have a basic knowledge of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in this chapter is available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_04](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_04)'
  prefs: []
  type: TYPE_NORMAL
- en: To run code snippets, you need a React environment, for example, Create React
    App ([https://create-react-app.dev](https://create-react-app.dev)) or CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io)).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the module state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The module state is a variable defined at the module level. *Module* here means
    an ES module or just a file. For simplicity, we assume that a variable defined
    outside a function is a module state.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s define the `count` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Assuming this is defined in a module, this is a module state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, with React, we want to have an object state. The following defines
    an object state with `count`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: More properties can be added to the object. Nesting objects are also possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define functions to access this module state. `getState` is a function
    to read `state`, and `setState` is a function to write `state`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we added `export` to these functions to express that they are expected
    to be used outside the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In React, we often update a state with functions. Let''s modify `setState`
    to allow a `function` update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use a function update as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Instead of defining a module state directly, we can create a function for creating
    a container that includes `state` and some access functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the concrete implementation of such a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So far, a module state has nothing to do with React. In the next section, we'll
    learn how to use a module state with React.
  prefs: []
  type: TYPE_NORMAL
- en: Using a module state as a global state in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in [*Chapter 3*](B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049),
    *Sharing Component State with Context*, React Context is designed to provide different
    values for different subtrees. Using React Context for a singleton global state
    is a valid operation, but it doesn't use the full capability of Context.
  prefs: []
  type: TYPE_NORMAL
- en: If what you need is a global state for an entire tree, a module state might
    fit better. However, to use a module state in a React component, we need to handle
    re-rendering ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a simple example. Unfortunately, this is a non-working example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You will see `count` `0` at the beginning. Clicking `button` increases the `count`
    variable, but it doesn't trigger the component to re-render.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, React has only two hooks, `useState` and `useReducer`,
    to trigger re-renders. We need to use either of those to make a component reactive
    with a module state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example can work with the following modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you click `button`, it will increase the `count` variable, as well as
    trigger the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if we have another component like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Even if you click `button` in `Component1`, it won't trigger `Component2` to
    re-render. Only when you click `button` in `Component2` will it re-render and
    show the latest module state. This is the inconsistency between `Component1` and
    `Component2`, and our expectation is that both components should show the same
    value. The inconsistency also happens with two `Component1` components.
  prefs: []
  type: TYPE_NORMAL
- en: One naive approach to this problem is to invoke `setState` functions in `Component1`
    and `Component2` at the same time. This requires having `setState` functions at
    the module level. We should also consider the component life cycle and use the
    `useEffect` hook to modify a set that holds `setState` functions outside React.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is one possible solution. This is to illustrate the idea
    and is not very practical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice we return a function in `useEffect` to clean up the effect. In the `inc`
    function, we invoke all `setState` functions in the `setStateFunctions` set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, `Component2` will also be modified like `Component1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As noted, this is not a very practical solution. We have some repetitive code
    in `Component1` and `Component2`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will introduce a Subscription mechanism and reduce the
    repetitive code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a basic Subscription
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we'll learn about the Subscription mechanism and how to connect a module
    state to the React state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subscription is a way to get notified of things such as updates. A typical
    use of a Subscription would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we assume a `store` variable to have a `subscribe` method that takes a
    `callback` function and returns an `unsubscribe` function.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the expected behavior is that whenever `store` is updated, the
    callback function is invoked and it shows the console log.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement a module state with a Subscription. We''ll call it `store`,
    which holds the `state` value and the `subscribe` method, in addition to the `getState`
    and `setState` methods that we described in the *Exploring the module state* section.
    A `createStore` is a function to create `store` with an initial state value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Compared with the `createContainer` function that we implemented in the *Exploring
    the module state* section, `createStore` has the `subscribe` method and the `setState`
    method, which invokes callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `createStore` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `store` variable holds `state` in it, and the entire `store` variable can
    be seen as a module state.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is the use of the `store` variable in React.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a new hook, `useStore`, which will return a tuple of the `store`
    state value and its update function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You may notice `setState()` function once in `useEffect`. This is due to the
    fact that `useEffect` is delayed and there's a chance that `store` already has
    a new state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a component with `useStore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to update a module state immutably, the same as the React state,
    because a module state is eventually set in the React state:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `Component1`, we define another one, `Component2`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Both buttons in the two components will update the module state in `store` and
    the states in both components are shared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this app, you will see something like *Figure 4.1*. If you click
    either the **+1** or **+2** buttons, you will see that both counts (shown as **3**)
    are updated together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Screenshot of the running app ](img/Figure_4.1_B17780.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Screenshot of the running app
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we used a Subscription to connect the module state to a React
    component.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will use a selector function to use only part of the
    state, as well as learn how to use `useSubscription`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a selector and useSubscription
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `useStore` hook we created in the previous section returns a whole state
    object. This means that any small part of the state object change will notify
    all `useStore` hooks and it can cause extra re-renders.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid extra re-renders, we can introduce a selector to return the only part
    of the state that a component is interested in.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first develop `useStoreSelector`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the same `createStore` function defined in the previous section and
    create a `store` variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The state in `store` has two counts – `count1` and `count2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useStoreSelector` hook is similar to `useStore`, but it receives an additional
    selector function. It uses the selector function to scope the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Compared to `useStore`, the `useState` hook in `useStoreSelector` holds the
    return value of `selector` instead of the entire state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we define a component to use `useStoreSelector`. The return value of `useStoreSelector`
    is a count number. To update the state, we invoke `store.setState()` directly
    in this case. `Component1` is a component for displaying `count1` in the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice we need to use `useCallback` to get a stable selector function. Otherwise,
    as the selector is specified in the second argument of `useEffect`, `Component1`
    will subscribe to the `store` variable every time `Component1` renders.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define `Component2`, which is to display `count2` instead of `count1`. We
    define a selector function outside the component to avoid `useCallback` this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `App` component renders two components for each `Component1` component
    and `Component2` component for demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 4.2* is a screenshot of the running app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Screenshot of the running app ](img/Figure_4.2_B17780.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Screenshot of the running app
  prefs: []
  type: TYPE_NORMAL
- en: The first two lines in the preceding figure are rendered by `Component1`. If
    you click either of the first two `count1`, which will trigger `Component1` to
    re-render. However, `Component2` (the last two lines in *Figure 4.2*) won't re-render
    because `count2` isn't changed.
  prefs: []
  type: TYPE_NORMAL
- en: While the `useStoreSelector` hook works well and is usable in production, there's
    a caveat when `store` or `selector` is changed. Because `useEffect` fires a little
    later, it will return a stale state value until re-subscribing is done. We could
    fix it by ourselves, but it's a little technical.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the React team provides an official hook for this use case. It's
    called `use-subscription` ([https://www.npmjs.com/package/use-subscription](https://www.npmjs.com/package/use-subscription)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s re-define `useStoreSelector` using `useSubscription`. The code is as
    simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The app still works with this change.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could avoid using the `useStoreSelector` hook and use `useSubscription`
    directly in `Component1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this case, as `useMemo` is already used, `useCallback` is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: useSubscription and useSyncExternalStore
  prefs: []
  type: TYPE_NORMAL
- en: In future versions of React, a hook called `useSyncExternalStore` will be included.
    This is a successor of `useSubscription`. Hence, using the module state will become
    more accessible ([https://github.com/reactwg/react-18/discussions/86](https://github.com/reactwg/react-18/discussions/86
    ) ).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about using selectors to scope state and also the
    official `useSubscription` hook to have a more concrete solution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create a module state and integrate it in
    React. Using what we learned, you can use the module state as a global state in
    React. Subscription plays an important role in integration because it allows the
    re-rendering of components to be triggered when the module state is changed. In
    addition to the basic Subscription implementation to use the module state in React,
    there is an official package. Both the basic Subscription and the official package
    work for the production use case.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the third pattern of implementing a
    global state, which is a combination of the first pattern and the second pattern.
  prefs: []
  type: TYPE_NORMAL
