- en: Using the Vuex Plugin System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Vuex 插件系统
- en: In previous chapters, I wrote about the possibility of persisting the *EveryNote*
    application state, using the Vuex plugin system. We also learned about a built-in
    logger plugin to log every mutation. But, what exactly is a Vuex plugin? And how
    can we write a custom plugin?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我写到了使用 Vuex 插件系统持久化 *EveryNote* 应用程序状态的可能性。我们还了解了一个内置的记录器插件，用于记录每个突变。但是，Vuex
    插件究竟是什么？我们如何编写一个自定义插件？
- en: 'In the following pages, you will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下页面中，您将：
- en: Learn about the Vuex plugin system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Vuex 插件系统
- en: Add two useful plugins to the *EveryNote* application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 *EveryNote* 应用程序添加两个有用的插件
- en: Write a Google Analytics plugin to track user interaction with your app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个用于跟踪用户与您的应用程序交互的 Google Analytics 插件
- en: Develop an undo/redo plugin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个撤销/重做插件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have Node.js installed on a system. Finally, to use
    the Git repository of this book, the user needs to install Git.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在系统上安装 Node.js。最后，为了使用本书的 Git 仓库，用户需要安装 Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-6](https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-6)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[Vuex 快速入门指南第 6 章](https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-6)'
- en: '[https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-6-promises](https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-6-promises)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[Vuex 快速入门指南第 6 章承诺](https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-6-promises)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际效果：
- en: '[https://goo.gl/aZjE63](https://goo.gl/aZjE63)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[Vuex 快速入门指南第 6 章链接](https://goo.gl/aZjE63)'
- en: Understanding the Vuex plugin system
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Vuex 插件系统
- en: A Vuex plugin is a function that receives the application store as the only
    argument and can subscribe to mutations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 插件是一个函数，它接受应用程序存储作为唯一参数，并可以订阅突变。
- en: 'The following is an example of a plugin:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个插件示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can add a plugin to the store as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将插件添加到存储中，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Like components, plugins cannot directly alter the state; they have to commit
    a mutation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与组件一样，插件不能直接更改状态；它们必须提交一个突变。
- en: 'For example, imagine that we want to show the last time a mutation has been
    committed. We could write a plugin as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想显示最后一次提交突变的时间。我们可以编写一个插件如下：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since we can subscribe to every mutation receiving the new state, we could persist
    the application state with `localStorage`. In fact, there is a plugin called `vuex-persistedstate`
    that does exactly that. You can read more about this plugin in the following pages.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以订阅每个突变并接收新状态，我们可以使用 `localStorage` 持久化应用程序状态。实际上，有一个名为 `vuex-persistedstate`
    的插件正是这样做的。您可以在以下页面了解更多关于此插件的信息。
- en: Empowering EveryNote with two plugins
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用两个插件增强 EveryNote
- en: 'If you Google *Vuex plugins,* you may find various plugins for different purposes.
    I selected two that you will probably want to use in your next Vuex project. These
    plugins are:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 Google 上搜索 *Vuex 插件*，您可能会找到各种不同目的的插件。我选择了您可能在下一个 Vuex 项目中想要使用的两个插件。这些插件是：
- en: vuex-persistedstate
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: vuex-persistedstate
- en: vuex-router-sync
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: vuex-router-sync
- en: We are going to use the first one to save the EveryNote state with `localStorage,`
    so that we don't lose all the notes every time the browser page is reloaded.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用第一个插件来使用 `localStorage` 保存 EveryNote 状态，这样每次浏览器页面重新加载时就不会丢失所有笔记。
- en: It is strongly recommended that you use the second one, vuex-router-sync, if
    you are creating a single-page web application. In this case, you are already
    using vue-router and vuex-router-sync will synchronize the current route, as part
    of Vuex store's state.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在创建一个单页 Web 应用程序，强烈建议您使用第二个插件，即 vuex-router-sync。在这种情况下，您已经使用了 vue-router，vuex-router-sync
    将同步当前路由，作为 Vuex 存储状态的一部分。
- en: Saving the app state with vuex-persistedstate
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 vuex-persistedstate 保存应用程序状态
- en: The *EveryNote* application currently shows two fake notes and loses newly created
    notes every time you reload the page. By addingthe`vuex-persistedstate` plugin,
    notes will be saved with `localStorage`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当前 *EveryNote* 应用程序显示两个假笔记，并且每次您重新加载页面时都会丢失新创建的笔记。通过添加 `vuex-persistedstate`
    插件，笔记将使用 `localStorage` 保存。
- en: To add the `vuex-persistedstate` type, enter the following*:*
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加 `vuex-persistedstate` 类型，请输入以下内容：*
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After that, we need to add it to the plugins list:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要将其添加到插件列表中：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we need to remove the two fake notes from the mock API:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要从模拟 API 中删除两个假笔记：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From now on, if you add a note and then reload the page, that note will still
    be there.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，如果您添加一个笔记然后重新加载页面，那个笔记仍然会存在。
- en: '`vuex-persistedstate` is highly configurable and can persist the application
    state to every synchronous storage. For example, you can configure it to use `sessionStorage,`
    instead of `localStorage,`if you want the state to be reset when the application
    page is closed.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`vuex-persistedstate` 具有高度的可配置性，可以将应用程序状态持久化到每个同步存储。例如，如果您想当应用程序页面关闭时重置状态，您可以将其配置为使用
    `sessionStorage`，而不是 `localStorage`。'
- en: 'You can find more information at: [https://github.com/robinvdvleuten/vuex-persistedstate](https://github.com/robinvdvleuten/vuex-persistedstate).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到更多信息：[https://github.com/robinvdvleuten/vuex-persistedstate](https://github.com/robinvdvleuten/vuex-persistedstate)。
- en: Synchronizing router data with vuex-router-sync
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 vuex-router-sync 同步路由数据
- en: If you are using vue-router in your application, you may also want to use vuex-router-sync
    because, as it says on the plugin website, *it* *syncs vue-router's current $route
    as part of vuex store's state.*
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在应用程序中使用 vue-router，您可能还希望使用 vuex-router-sync，因为它在插件网站上说明，*它* *同步 vue-router
    的当前 $route 作为 vuex 存储状态的一部分*。
- en: 'To install this plugin, type:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装此插件，请输入：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To add it to the *EveryNote* app, you need to add vue-router to the project:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其添加到 *EveryNote* 应用程序中，您需要将 vue-router 添加到项目中：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'and modify `src/store/index.js` as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 并按如下方式修改 `src/store/index.js`：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'But how does it work? Each time the route changes, this plugin updates the
    `store.state.route` property. This property consists of:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但它是如何工作的？每次路由变化时，此插件都会更新 `store.state.route` 属性。此属性由以下内容组成：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To update the store property, it commits a `route.ROUTE_CHANGED` mutation, where
    `route` is the default name of the module of the vuex-router-syncplugin.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新存储属性，它提交一个 `route.ROUTE_CHANGED` 突变，其中 `route` 是 vuex-router-sync 插件模块的默认名称。
- en: 'You can change the module name it uses as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以更改它使用的模块名称如下：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In order to programmatically change a route, use vue-router; do not modify `store.state.route`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以编程方式更改路由，请使用 vue-router；不要修改 `store.state.route`。
- en: 'You can find more information at: [https://github.com/vuejs/vuex-router-sync](https://github.com/vuejs/vuex-router-sync).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到更多信息：[https://github.com/vuejs/vuex-router-sync](https://github.com/vuejs/vuex-router-sync)。
- en: In the following pages, we are going to develop a Google Analytics plugin that
    uses vuex-router-sync to send page-views to Google servers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下页面中，我们将开发一个使用 vuex-router-sync 将页面浏览量发送到 Google 服务器的 Google Analytics 插件。
- en: Developing a Google Analytics plugin
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个 Google Analytics 插件
- en: In the following pages, I will assume that you are familiar with Google Analytics
    and that you have correctly configured Google Analytics tracking in your application.
    If not, you can Google it, understand how it works, and come back here. A basic
    understanding is more than enough to proceed with the following pages.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下页面中，我将假设您熟悉 Google Analytics，并且已经正确配置了应用程序中的 Google Analytics 跟踪。如果不是这样，您可以
    Google 它，了解它是如何工作的，然后回来这里。对基本概念的了解就足够您继续阅读以下页面。
- en: 'The first step is to add this Google Analytics tracking code snippet to the
    `index.html` file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将此 Google Analytics 跟踪代码片段添加到 `index.html` 文件中：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After that, a global `gtag(...)` function will be available to send events to
    Google Analytics servers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将有一个全局的 `gtag(...)` 函数可用于向 Google Analytics 服务器发送事件。
- en: 'Typically, an application tracks page views and some events. To send an event
    to Google Analytics servers, it is enough to write:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用程序会跟踪页面浏览量和一些事件。要向 Google Analytics 服务器发送事件，只需编写以下内容：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using the preceding code, we can write a plugin that sends an Analytics event
    for each mutation, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们可以编写一个插件，为每个突变发送一个 Analytics 事件，如下所示：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In order to send page views, we can exploit the vuex-router-sync`route.ROUTE_CHANGED`
    mutation committed every time the location changes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发送页面浏览量，我们可以利用每次位置变化时提交的 vuex-router-sync`route.ROUTE_CHANGED` 突变。
- en: 'We can update the Analytics plugin accordingly, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以相应地更新 Analytics 插件，如下所示：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Where the `analytics` object is something like:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `analytics` 对象类似于：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You probably do not want to send all mutations as analytics events; in that
    case, you can create a map of mutation types that you want to send, or a list
    of mutation types you don't want to be sent.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不想发送所有突变作为分析事件；在这种情况下，您可以创建一个包含您想要发送的突变类型的映射，或者一个包含您不希望发送的突变类型的列表。
- en: 'You can download the EveryNote code with the Google Analytics plugin by typing:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过输入以下内容下载带有 Google Analytics 插件的 EveryNote 代码：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Developing an undo/redo plugin
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个撤销/重做插件
- en: The Google Analytics plugin we just coded is a good and simple example of how
    the Vuex plugin system can be exploited to add features to your application, without
    touching the application core code. But what about a more complex plugin? Is the
    Vuex plugin also suited for more complex operations? Well, of course, it is! In
    the following pages, we will develop an undo/redo plugin, which is still a simple,
    but not trivial example.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写的 Google Analytics 插件是 Vuex 插件系统如何被利用来向您的应用程序添加功能的一个好例子，而不需要触及应用程序核心代码。但是，对于更复杂的插件呢？Vuex
    插件也适合更复杂的操作吗？嗯，当然，它是！在接下来的几页中，我们将开发一个撤销/重做插件，这仍然是一个简单但非平凡的例子。
- en: We can exploit the fact that, in using the Vuex system, we have a single centralized
    state and this state can only be modified by mutations. The idea is to take a
    snapshot of the state each time it gets modified. Then, to go back in the mutation
    history, it is enough to set the current state to a snapshot, representing an
    older state before the mutation occurred.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这样一个事实：在使用 Vuex 系统时，我们有一个单一集中的状态，并且这个状态只能通过突变来修改。想法是每次状态被修改时都拍摄一个快照。然后，要回到突变历史，只需将当前状态设置为快照即可，这代表了一个突变发生之前的较旧状态。
- en: 'Let''s start by creating a plugin that registers a module called `undoRedo`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个插件，该插件注册了一个名为`undoRedo`的模块：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we define two state properties:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了两个状态属性：
- en: '**currentPosition**: This represents the index of the current snapshot. When
    an undo mutation is committed, we decrease the index; when a redo mutation or
    another one is committed, the index is increased.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**currentPosition**：这代表当前快照的索引。当提交撤销突变时，我们减少索引；当提交重做突变或其他突变时，索引增加。'
- en: '**snapshots**: This is an array containing state snapshots.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**snapshots**：这是一个包含状态快照的数组。'
- en: After that, we need two corresponding mutations to update these properties,
    as well as an `UNDO` and a `REDO` mutation to actually let plugin clients undo
    or redo modifications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要两个相应的突变来更新这些属性，以及一个`UNDO`和一个`REDO`突变，以便让插件客户端撤销或重做修改。
- en: Finally, we provide two getters, `canUndo()` and `canRedo(),` to expose the
    undoable/redoable state of the plugin.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提供了两个获取器，`canUndo()`和`canRedo()`，以公开插件的撤销/重做状态。
- en: 'We can now subscribe to mutations to take a snapshot each time the application
    state gets changed:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以订阅突变，以便每次应用程序状态发生变化时都拍摄一个快照：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Of course, there are mutations that must be excluded, such as mutations of `snapshots`
    or `currentPosition` properties, and mutations that a user of this plugin may
    want to exclude, such as `route/ROUTE_CHANGED` if vuex-router-sync is used in
    the application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有一些突变必须排除，例如`snapshots`或`currentPosition`属性的突变，以及插件用户可能想要排除的突变，例如如果应用程序中使用了`vuex-router-sync`，则`route/ROUTE_CHANGED`。
- en: 'We can now implement the undo/redo mutations as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以按照以下方式实现撤销/重做突变：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the preceding code is just about restoring the right snapshot.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的代码只是关于恢复正确快照的。
- en: 'When taking a snapshot, not every state property should be considered and each
    snapshot must be a copy of the state. The following code shows these concepts:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在拍摄快照时，不应考虑每个状态属性，并且每个快照必须是状态的副本。以下代码显示了这些概念：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we can provide a factory method to create and configure the undo/redo
    plugin. The following is the entire plugin code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以提供一个工厂方法来创建和配置撤销/重做插件。以下是完全的插件代码：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can download the EveryNote code with the undo/redo plugin, by typing:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过输入以下内容下载带有撤销/重做插件的 EveryNote 代码：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Undo/redo, implemented this way, works well with an application that does not
    synchronize its state with a server. Normally, it is not enough to restore the
    previous state, but you need also to perform an action to update the server data.
    For example, if you undo a delete note, you need to send the undeleted note data
    to the remote server. This means that a real undo/redo feature is application-dependent,
    and that the plugin we wrote needs to be extended to also handle synchronization
    with a remote server.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式实现的撤销/重做与不与其状态与服务器同步的应用程序配合得很好。通常，仅恢复先前状态是不够的，您还需要执行一个操作来更新服务器数据。例如，如果您撤销了一个删除的笔记，您需要将未删除的笔记数据发送到远程服务器。这意味着真正的撤销/重做功能是与应用程序相关的，并且我们编写的插件需要扩展以处理与远程服务器的同步。
- en: Dealing with asynchronicity using promises
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用承诺处理异步性
- en: In a real undo/redo plugin you will probably send data to a server, which is
    an asynchronous operation. We understood that asynchronicity must be dealt with
    inside Vuex actions. When you dispatch an action, `store.dispatch('anAction')`,
    the `dispatch` method returns a `Promise`. In the following pages I will explain
    how you can handle asynchronous operations using `Promise`, a relatively new JavaScript
    feature.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with asynchronous operations in JavaScript can be tricky. I have seen
    incredibly messy pieces of code just because the programmer didn't know how to
    deal with asynchronous code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'The worst way of waiting for a piece of data that will be available later is
    polling. *Never do something like this*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding example can be refactored using a callback:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Callbacks are good for simple operations, but become quickly unmanageable when
    you need to combine more than one callback. Have you ever heard of the phrase
    c*allback hell*?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, JavaScript now provides `Promise`, a simple way to deal with asynchronous
    operations. Using a `Promise`, the preceding code can be rewritten as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you are not familiar with promises, google and study them. The following
    sections will explain how promises can be chained or be executed in parallel,
    which, in my opinion, is still not well understood by programmers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Chaining promises
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `store.dispatch('action')` function returns a promise. This allows the programmer
    to wait for an action to be completed before executing another one.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example where an action is dispatched after another one is completed:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `then(callback)` method of a `Promise` returns another `Promise`, which
    will be resolved with the value returned by the callback. If the value returned
    by the callback is itself a `Promise`, it will wait for this second `Promise`
    to be completed. OK, I know—the first time you hear it, this concept sounds a
    bit twisted. I will explain promise concatenation in the following examples:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The resulting output is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, the synchronous code gets executed, printing `start` and `end`, and then
    the promise chain gets executed. In the middle step of the chain, a promise that
    is resolved after 1000 ms is returned from the callback. This makes the last `then(...)`
    of the chain wait for the `asyncEcho(...)` promise to be resolved before it can
    execute the last callback.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Until the chain promises get resolved, the code execution moves from one `then()`
    to the other. But what happens when a promise gets rejected? Let''s see another
    example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The resulting output is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Did you get the right output? Or did you expect to see *Fail 3* after the *Fail
    2* line? That is a common mistake. Only if an error occurs inside a callback or
    a rejected promise is returned is the fail callback of the next step of the chain
    executed. In all other cases, it is the next success callback that gets executed,
    even if the fail callback of the previous step was executing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure explains this concept:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图解释了这个概念：
- en: '![](img/7c34ffc1-5a35-4086-84bd-adc5f6e264f1.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c34ffc1-5a35-4086-84bd-adc5f6e264f1.png)'
- en: 'Figure 2.1: Chaining promises'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：链式调用promises
- en: Parallel execution of promises
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: promises的并行执行
- en: 'Now that we know how to chain promises, we also know how to chain Vuex actions
    since the `store.dispatch(...)` method returns a promise. But what if we want
    to execute two or more actions in parallel and wait for all of the actions to
    be completed? The `Promise` object provides a `Promise.all([p1, p2, ..., pn])`method
    that returns a promise that is either resolved after all the provided promises
    are resolved or that is rejected as soon as one of the provided promises is rejected.
    Let''s see an example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何链式调用promises，我们也知道了如何链式调用Vuex actions，因为`store.dispatch(...)`方法返回一个promise。但如果我们想并行执行两个或更多操作并等待所有操作完成呢？`Promise`对象提供了一个`Promise.all([p1,
    p2, ..., pn])`方法，它返回一个promise，在所有提供的promises都解决后解决，或者在提供的任何一个promise被拒绝时立即拒绝。让我们看一个例子：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Common mistakes when using promises
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用promises时的常见错误
- en: Finally, let's look at the two common mistakes made when using `Promise`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看使用`Promise`时犯的两个常见错误。
- en: The following code shows what happens when a **`Promise`** constructor callback
    is misunderstood**:**
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了当**`Promise`**构造函数回调被误解时会发生什么：**
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The callback function provided to `new Promise(callback)` is executed synchronously.
    If you want to schedule something immediately after the current JavaScript execution
    is completed, use `Promise.resolve().then(callback)` or `setTimeout(callback,
    0)`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`new Promise(callback)`的回调函数是同步执行的。如果你想在当前JavaScript执行完成后立即安排某些事情，请使用`Promise.resolve().then(callback)`或`setTimeout(callback,
    0)`。
- en: 'The following code shows what happens when a programmer forgets to return a
    rejected promise:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了当程序员忘记返回一个被拒绝的promise时会发生什么：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'No matter what `Math.random()` returns, the output is always Resolved Fail
    or Resolved Success because the `fail` callback of `buggyToss()` does not throw
    any error or return a rejected promise. The following is the correct version of
    `buggyToss()`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 无论`Math.random()`返回什么，输出总是Resolved Fail或Resolved Success，因为`buggyToss()`的`fail`回调没有抛出任何错误或返回一个被拒绝的promise。以下是`buggyToss()`的正确版本：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we looked at how the Vuex plugin system works, we extended
    the *EveryNote* application with two useful plugins, and we developed two plugins
    from scratch: a Google Analytics plugin and an undo/redo plugin. Furthermore,
    generally, we saw how the Vuex plugin system can be exploited to add general features
    to our application without touching the application''s core code.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Vuex插件系统的工作原理，我们扩展了*EveryNote*应用，添加了两个有用的插件，并从头开发了两款插件：一款Google Analytics插件和一款撤销/重做插件。此外，一般而言，我们看到了Vuex插件系统如何被利用来向我们的应用添加通用功能，而无需触及应用的核心代码。
- en: Finally we understood how to deal with asynchronous operations using JavaScript
    `Promise` feature.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我们理解了如何使用JavaScript `Promise`特性处理异步操作。
