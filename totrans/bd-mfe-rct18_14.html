<html><head></head><body>
		<div id="_idContainer067" class="calibre2">
			<h1 id="_idParaDest-153" class="chapter-number"><a id="_idTextAnchor152" class="pcalibre1 calibre6 pcalibre"/>10</h1>
			<h1 id="_idParaDest-154" class="calibre7"><a id="_idTextAnchor153" class="pcalibre1 calibre6 pcalibre"/>Common Pitfalls to avoid when Building Microfrontends</h1>
			<p class="calibre3">We’ve come a long way! We’ve learned how to build microfrontends, how to deploy them to the native cloud, and how to manage them <span>in production.</span></p>
			<p class="calibre3">As we start working with microfrontends, we will make mistakes, but we will learn from them and eventually build our own set of best practices, discovering what works best for our use cases. However, it is always a smart thing to learn from others’ mistakes as well. In this chapter, we will cover some of the pitfalls earlier teams faced when working <span>with microfrontends.</span></p>
			<p class="calibre3">We will teach you about some common pitfalls and how to avoid them, which are <span>as follows:</span></p>
			<ul class="calibre15">
				<li class="calibre14">Not making your microapps <span>too small</span></li>
				<li class="calibre14">Avoiding the overuse of common <span>shared code/libraries</span></li>
				<li class="calibre14">Avoiding multiple frameworks within <span>a microfrontend</span></li>
				<li class="calibre14">The inability to deploy individual <span>micro apps</span></li>
				<li class="calibre14">Excessively relying <span>on state</span></li>
				<li class="calibre14">Avoiding build-time compilation to <span>assemble Microfrontends</span></li>
				<li class="calibre14">Avoiding packing your micro apps into <span>NPM packages</span></li>
			</ul>
			<p class="calibre3">By the end of this chapter, you will have learned about the various pitfalls developers fall into when transitioning from single-page apps <span>to microfrontends.</span></p>
			<h1 id="_idParaDest-155" class="calibre7"><a id="_idTextAnchor154" class="pcalibre1 calibre6 pcalibre"/>Don’t make your micro apps too small</h1>
			<p class="calibre3">We touched upon<a id="_idIndexMarker428" class="pcalibre1 calibre6 pcalibre"/> this at the start of the book, but it’s important to stress it again. Way too many developers think that, in a microfrontend architecture, the micro apps need to be really small. This is not true, as creating very small microapps greatly increases the complexity and maintenance headaches, without achieving <span>any benefits.</span></p>
			<p class="calibre3">In trying to identify what the right size is for your micro app, we’ve seen it helps if we take into consideration<a id="_idIndexMarker429" class="pcalibre1 calibre6 pcalibre"/> the <span>following points:</span></p>
			<ol class="calibre13">
				<li class="calibre14">Is it the largest possible micro app that can <span>independently exist?</span></li>
				<li class="calibre14">Is it the largest possible micro app that’s owned by a single agile <span>scrum team?</span></li>
				<li class="calibre14">Does this app undergo changes and updates that are at a pace different from the rest of <span>the application?</span></li>
				<li class="calibre14">Another point to consider is thinking in terms of domains, based on domain-driven design principles, to determine what business features a given micro app should support or <span>not support.</span></li>
			</ol>
			<p class="calibre3">If your answer to all the preceding questions is yes, then the micro app is the right size. If the answer is no to any one of the preceding questions, then either we haven’t broken down our micro apps in the right way or microfrontends may not be the right <span>architectural choice.</span></p>
			<p class="calibre3">Another guide to help identify <a id="_idIndexMarker430" class="pcalibre1 calibre6 pcalibre"/>the right size for your app is to look at the atomic design pattern (<a href="https://bradfrost.com/blog/post/atomic-web-design/" class="pcalibre1 calibre6 pcalibre">https://bradfrost.com/blog/post/atomic-web-design/</a>), which defines how components are structured in <span>an application.</span></p>
			<div class="calibre2">
				<div id="_idContainer066" class="img---figure">
					<img src="image/Figure_10.01_B18987.jpg" alt="Figure 10.1 – Organisms and templates can be converted to micro apps" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Organisms and templates can be converted to micro apps</p>
			<p class="calibre3">If you look at the atomic design pattern in <span><em class="italic">Figure 10</em></span><em class="italic">.1</em>, the ideal level to break down your app into micro apps would be either at the organism level or the template level; anything other than that would be either too small or <span>too big.</span></p>
			<p class="calibre3">Breaking down the application<a id="_idIndexMarker431" class="pcalibre1 calibre6 pcalibre"/> into the right-sized micro app is key to building a performant and scalable microfrontend architecture, and investing more time in getting this right will pay high dividends as we <span>move forward.</span></p>
			<h1 id="_idParaDest-156" class="calibre7"><a id="_idTextAnchor155" class="pcalibre1 calibre6 pcalibre"/>Avoiding the overuse of Shared Component Code</h1>
			<p class="calibre3">When it comes to building<a id="_idIndexMarker432" class="pcalibre1 calibre6 pcalibre"/> microservices or microfrontends, team independence is the highest priority. Anything that makes a team dependent on another team should be <span>strongly discouraged.</span></p>
			<p class="calibre3">In our experience<a id="_idIndexMarker433" class="pcalibre1 calibre6 pcalibre"/> as software<a id="_idIndexMarker434" class="pcalibre1 calibre6 pcalibre"/> developers, we’ve always come across principles such as <strong class="bold">reusability</strong>, <strong class="bold">Do not Repeat Yourself</strong> (<strong class="bold">DRY</strong>), and so on. In fact most senior developers are constantly looking how do they create common utilities, helpers shared components, and so on, to help the teams be <span>more productive.</span></p>
			<p class="calibre3">However, when it comes to the world of microservices and microfrontends, overuse of these shared<a id="_idIndexMarker435" class="pcalibre1 calibre6 pcalibre"/> libraries can lead<a id="_idIndexMarker436" class="pcalibre1 calibre6 pcalibre"/> to what is called “dependency hell” or a “distributed monolith,” which is the worst of <span>both worlds.</span></p>
			<p class="calibre3">This is bad for microfrontends because using shared libraries or code immediately takes away the independence of teams, as now two or more teams are dependent on updates or bug fixes to be made for this shared library, in order for them to be able to <span>proceed further.</span></p>
			<p class="calibre3">As more and more teams start using a shared library, it tends to start getting bulkier, as it now needs to accommodate the use cases of the different teams. There is also a constant risk that changes or updates to this shared code may break the functionality of one or <span>more teams.</span></p>
			<p class="calibre3">Hence, when it comes to microfrontends, we need to be strict about not falling into this trap. As a rule of thumb, we should avoid creating any business or application logic as shared common code. One item that can ideally be shared between micro-apps is the UI component library because we want to ensure that all micro apps have a consistent look and feel. Another item that can be put into a shared library is any other low-level utility function that doesn’t contain any business logic. Some examples of these would be an HTTP client, an error-handling utility, or other utilities to format dates or <span>manipulate strings.</span></p>
			<p class="calibre3">Remember that with monorepos, it’s a lot easier to “find and replace” than to deal with the challenges of a <span>distributed monolith.</span></p>
			<p class="calibre3">While initially the whole idea<a id="_idIndexMarker437" class="pcalibre1 calibre6 pcalibre"/> of prioritizing team independence over code reuse may sound like an anti-pattern and not a smart thing to do, speaking from experience, this is the second most important point to keep in mind when you want your teams to move fast and frequently deploy code <span>to production.</span></p>
			<h1 id="_idParaDest-157" class="calibre7"><a id="_idTextAnchor156" class="pcalibre1 calibre6 pcalibre"/>Avoiding using multiple frameworks in your microfrontend</h1>
			<p class="calibre3">One of the benefits<a id="_idIndexMarker438" class="pcalibre1 calibre6 pcalibre"/> of microfrontends is that, technically, it’s possible to have each app built using a different framework. However, just because it’s possible doesn’t mean you have to. There are numerous drawbacks to using multiple frameworks within a <span>single microfrontend:</span></p>
			<ul class="calibre15">
				<li class="calibre14">The cognitive overload for team members as they potentially switch from one team to the other over time is <span>very high.</span></li>
				<li class="calibre14">Since every framework comes with its own JavaScript bundle, and since every framework will have a different set of NPM modules that the team uses, the amount of JavaScript code transferred to the user’s devices will be high. Therefore, we will not be able to take full advantage of browser caching or service worker caching, since each app uses its <span>own bundle.</span></li>
				<li class="calibre14">Different frameworks will have different performance challenges and issues, and each team will have to deal with them individually and not be able to use the collective knowledge within the <span>broader team.</span></li>
			</ul>
			<p class="calibre3">Having said that, it is fine to have multiple frameworks or multiple versions of them for a short transitional phase when you evaluate<a id="_idIndexMarker439" class="pcalibre1 calibre6 pcalibre"/> a new framework or incrementally upgrade to a newer version. Overall, though, having multiple frameworks as an architecture principle should <span>be avoided.</span></p>
			<h1 id="_idParaDest-158" class="calibre7"><a id="_idTextAnchor157" class="pcalibre1 calibre6 pcalibre"/>An inability to deploy an individual micro app</h1>
			<p class="calibre3">One of the primary<a id="_idIndexMarker440" class="pcalibre1 calibre6 pcalibre"/> reasons to adopt a microfrontend architecture is to allow certain parts of an application to be independently updated without impacting the rest <span>of it.</span></p>
			<p class="calibre3">This obviously means that we need the ability to build and deploy each micro app independently. If your DevOps build<a id="_idIndexMarker441" class="pcalibre1 calibre6 pcalibre"/> and release pipeline can’t do this, then it’s better to go with <strong class="bold">Single-Page Application</strong> (<span><strong class="bold">SPA</strong></span><span>) architecture.</span></p>
			<p class="calibre3">In the past, many DevOps tools weren’t sophisticated enough to work with monorepos or microfrontends; however, most of the latest tools are better equipped to detect which folders have changed and only trigger the necessary <span>app builds.</span></p>
			<p class="calibre3">Hence, when working on a microfrontend architecture, it is critical that you’ve thought it through and through, including how it will be deployed, as this will impact the choice of tools you select for the DevOps pipeline or <span>the monorepo.</span></p>
			<p class="calibre3">For example, if your DevOps pipelines can be conditionally triggered based on which micro app has changed, then you are free to choose any <span>monorepo tool.</span></p>
			<p class="calibre3">However, if your DevOps pipeline is unable to detect changes, or if you are limited to a single pipeline for all your microfrontends, then going with a mono repo tool such as Nx, which has built-in change detection, would be <span>more suitable.</span></p>
			<h1 id="_idParaDest-159" class="calibre7"><a id="_idTextAnchor158" class="pcalibre1 calibre6 pcalibre"/>Excessively relying on state</h1>
			<p class="calibre3">With the advent of React, state management<a id="_idIndexMarker442" class="pcalibre1 calibre6 pcalibre"/> became a thing, and with it rose the popularity of tools such as Redux that advocated a single central data store to manage state. Over time, developers seem to have become obsessed with state management, relying far too much on these state management libraries. When developers make the shift from SPAs to microfrontends, they continue their obsession with state and spend a lot of time trying to persist state, making it work across different micro apps. With SPAs and also microfrontends, it is important to sparingly use these application-level states. When working with microfrontends, we encourage exploring concepts around Pub/Sub or an event emitter approach to sharing data between different micro apps. Alternatively, look at native browser data stores, such as session storage, IndexedDB, or local storage to manage persistent state, or if none of these is an option, then explore lightweight state management libraries such as Zustand or React’s <span>Context API.</span></p>
			<p class="calibre3">As you may have realized by now, when building microfrontends, there is a fair bit of unlearning and relearning involved, especially if you have been building SPAs for a while. The use of state management in microfrontends is something that needs to be understood and is also the most difficult change that some developers occasionally have to deal with, especially those who have got used to excessively relying <span>on state.</span></p>
			<h1 id="_idParaDest-160" class="calibre7"><a id="_idTextAnchor159" class="pcalibre1 calibre6 pcalibre"/>Avoiding build-time compilation to assemble Microfrontends</h1>
			<p class="calibre3">There is a current trend<a id="_idIndexMarker443" class="pcalibre1 calibre6 pcalibre"/> in the frontend community to move as many tasks as possible to the build time phase of application compilation, rather than the runtime. Good examples of these are static site generation, where the HTML<a id="_idIndexMarker444" class="pcalibre1 calibre6 pcalibre"/> pages are generated at build time, or <strong class="bold">Ahead of Time</strong> (<strong class="bold">AoT</strong>) compilation in Angular, which improves the overall performance of <span>an application.</span></p>
			<p class="calibre3">While, in general, build-time compilation is a good practice, reducing the load on the browser and JavaScript engines during the runtime phase, it doesn’t help when assembling the microfrontend. This is because every time any microfrontend changes, you need to rebuild the assembly layer as well, defeating the principle of independent micro <span>app deployments.</span></p>
			<p class="calibre3">We can choose to have individual micro apps do more work during build time (e.g., generate static pages), but the assembling of micro apps or module federation should always be done on the server or <span>at runtime.</span></p>
			<p class="calibre3">This is another key point to keep in mind to ensure we don’t blindly follow “popular trends.” It is important to always remember what the key principles of your architecture pattern <a id="_idIndexMarker445" class="pcalibre1 calibre6 pcalibre"/>are and that you’ve thought through your pattern, end to end and all the way to how it will be deployed <span>into production.</span></p>
			<h1 id="_idParaDest-161" class="calibre7"><a id="_idTextAnchor160" class="pcalibre1 calibre6 pcalibre"/>Avoiding packing your micro apps into NPM packages</h1>
			<p class="calibre3">Another common trend<a id="_idIndexMarker446" class="pcalibre1 calibre6 pcalibre"/> within the SPA world is to convert any sharable<a id="_idIndexMarker447" class="pcalibre1 calibre6 pcalibre"/> modules into NPM packages for easier distribution and then import them into <span>other apps.</span></p>
			<p class="calibre3">In our experience, we have seen a few teams package and version their micro apps into NPM modules before importing them into the host or assembly app. We strongly discourage this practice for the primary reason that every time a new version of a micro app is published as an npm module, all the hosts using that micro app will need to update their <strong class="source-inline">package.json</strong> files and rebuild and redeploy their apps, defeating the primary principle of independent deployments. We covered this in a bit of detail in <a href="B18987_02.xhtml#_idTextAnchor029" class="pcalibre1 calibre6 pcalibre"><span><em class="italic">Chapter 2</em></span></a>, <em class="italic">Key Principles and Components of Microfrontends</em>, in the <em class="italic">Prefer runtime </em><span><em class="italic">integrations</em></span><span> section.</span></p>
			<h1 id="_idParaDest-162" class="calibre7"><a id="_idTextAnchor161" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
			<p class="calibre3">With this, we come to the end of this chapter. Being a relatively new architecture pattern, the concepts and best practices around microfrontends are <span>constantly evolving.</span></p>
			<p class="calibre3">In this chapter, we saw some of the common pitfalls that teams have fallen into while building microfrontends – namely, things such as not being able to identify the right level at which to break down an app into a micro app, overuse of state management libraries, using multiple frameworks within a micro app, the inability to individually deploy a micro app, overuse of shared common code, and ending up with a build-time integration. Hopefully, this chapter will prevent you from repeating the same mistakes your peers have made in <span>the past.</span></p>
			<p class="calibre3">Another important point to remember is to understand the reasoning behind these best practices, looking at them through the lens of your specific use case. Follow the best practices that apply to your use case and tweak the ones that don’t quite <span>fit it.</span></p>
			<p class="calibre3">As the famous saying goes, “<em class="italic">The answer to every architecture question is… </em><span><em class="italic">it depends.</em></span><span>”</span></p>
			<p class="calibre3">In the next chapter, we will look at some of the emerging trends in the world of microfrontends that you should keep an <span>eye on.</span></p>
		</div>
	</body></html>