- en: Angular Material
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角材料
- en: 'When you develop an application, you need a clear strategy on how to create
    your UI. The strategy should include using good, contrasting colors; having a
    consistent look and feel; it should work well on different devices, as well as
    browsers; and many more requirements. In short, there are a lot of requirements
    on an application being built for the web platform today when it comes to UI and
    UX. It is no wonder that most developers consider UI/UX to be a daunting task
    and therefore turn to UI frameworks that do a lot of the heavy lifting. There
    are some frameworks that are used more than others, namely:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开发应用程序时，您需要一个清晰的策略来创建您的用户界面。该策略应包括使用良好的对比色；具有一致的外观和感觉；它应该在不同的设备和浏览器上运行良好；以及许多其他要求。简而言之，在今天的
    Web 平台上构建应用程序时，对用户界面和用户体验有很多要求。难怪大多数开发人员认为 UI/UX 是一项艰巨的任务，因此转向可以减轻大部分工作的 UI 框架。有一些框架比其他框架更常用，即：
- en: Twitter Bootstrap
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter Bootstrap
- en: Foundation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础
- en: HTML5 Quickstart
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML5 快速入门
- en: There is, however, a new kid on the block, or should we say, a new design language,
    Material Design. This chapter will try to explain what Material Design is and
    will look at what frameworks implement the principles of Material Design, and
    we will especially focus on Angular Material, made especially for Angular.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个新的设计语言，Material Design。本章将尝试解释什么是 Material Design，并将查看哪些框架实现了 Material
    Design 的原则，我们将特别关注为 Angular 特别制作的 Angular Material。
- en: 'In this chapter, we will:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn about what Material Design is and a little bit of its history
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Material Design 是什么以及它的一点历史
- en: Learn more about known implementations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解更多已知的实现
- en: Delve deeper into Angular Material and what parts it consists of
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解 Angular Material 及其组成部分
- en: Build an Angular application with Angular Material
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular Material 构建 Angular 应用程序
- en: Material Design
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Material Design
- en: 'Material Design is a design language that was developed by Google in 2014\.
    Google states that its new design language is based on paper and ink. The creators
    of Material Design tried to explain the goal they were trying to reach, with the
    following quote:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Material Design 是谷歌在 2014 年开发的设计语言。谷歌表示，他们的新设计语言是基于纸张和墨水的。Material Design 的创作者试图用以下引用来解释他们试图达到的目标：
- en: '"We challenged ourselves to create a visual language for our users that synthesises
    the classic principles of good design with the innovation and possibility of technology
    and science."'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “我们挑战自己为我们的用户创建一种视觉语言，将好设计的经典原则与技术和科学的创新和可能性相结合。”
- en: 'They explain further the goals as:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 他们进一步解释了目标：
- en: Develop a single underlying system that allows for a unified experience across
    platforms and device sizes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个统一的基础系统，使跨平台和设备尺寸的体验统一
- en: Mobile precepts are fundamental, but touch, voice, mouse, and keyboard are all
    first-class input methods
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动规则是基本的，但触摸、语音、鼠标和键盘都是一流的输入方法
- en: It is clear that the design language wants to have one take, and one take only
    on how the UI and user interaction should look and feel, across devices. Also,
    that input plays a large role on the overall experience of a UI.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，设计语言希望在各种设备上对用户界面和用户交互的外观和感觉只有一个看法。此外，输入在用户界面的整体体验中起着重要作用。
- en: 'Material Design rests on three principles:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Material Design 基于三个原则：
- en: Material is the metaphor
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材料是隐喻
- en: Bold, graphic, intentional
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大胆、图形、有意
- en: Motion provides meaning
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作赋予意义
- en: All in all, it can be said that there is a lot of theory behind the design language,
    and there is good documentation on the topic should you wish to delve further
    in, such as at the official documentation site, [https://material.io/.](https://material.io/)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，可以说设计语言背后有很多理论，而且关于这个主题有很好的文档，如果你希望深入了解，可以在官方文档网站[https://material.io/.](https://material.io/)找到更多信息。
- en: Now, all of this is probably very interesting if you are a designer and care
    about graphical theory. It is our guess that you who is reading this book is a
    developer and that you are asking yourself a question right now. So what, why
    should I care?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你是一名设计师并且关心图形理论，这一切可能非常有趣。我们猜想你正在阅读这本书的人是一名开发者，现在你可能会问自己一个问题。那又怎样，为什么我要在意呢？
- en: Well, every time Google sets out to build something, it becomes big. Not everything
    remains over time, but there is sufficient muscle behind this, and Google have
    paved the way by using this on a lot of their own products such as Firebase, Gmail,
    Google Plus, and so on.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每当谷歌着手构建某物时，它都会变得很大。并非所有东西都能经受时间的考验，但是这背后有足够的实力，谷歌已经在许多自己的产品上使用了这一设计，如Firebase、Gmail、Google
    Plus等。
- en: Of course, by itself a design language isn't that interesting, at least not
    for a developer, which brings us to our next section on the fact that there does
    exist a number of implementations based on the design principles laid out by Material
    Design. More on this in the coming section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，单独的设计语言并不那么有趣，至少对于开发者来说是这样，这就引出了我们下一节的内容，即基于Material Design原则的多种实现。在接下来的部分中会详细介绍。
- en: Known implementations
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已知的实现
- en: For a developer, design is there to make sense of your code and give the user
    a nice experience, both visually and from a usability standpoint. Currently, three
    major implementations exist of Material Design.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，设计是为了理清你的代码并为用户提供良好的视觉和可用性体验。目前，Material Design存在三种主要的实现。
- en: 'Those are:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是：
- en: Materialize, [http://materializecss.com/about.html.](http://materializecss.com/about.html)24,000+
    stars on GitHub tells you that this is very well used. It works to be used as
    a standalone, but there are also bindings to frameworks such as AngularJS and
    React. It offers navigation elements, components, and much more, a good choice.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Materialize，[http://materializecss.com/about.html.](http://materializecss.com/about.html)GitHub上的24,000多个星星告诉你它被广泛使用。它可以作为独立使用，但也可以与AngularJS和React等框架进行绑定。它提供导航元素、组件等，是一个不错的选择。
- en: AngularJS Material, [https://material.angularjs.org/latest/](https://material.angularjs.org/latest/), is
    Google's own implementation meant for AngularJS. It is quite capable and comes
    with themes, navigation elements, components, and of course directives.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AngularJS Material，[https://material.angularjs.org/latest/](https://material.angularjs.org/latest/)，是谷歌专为AngularJS开发的实现。它非常强大，包括主题、导航元素、组件和指令。
- en: Angular Material, [https://material.angular.io/](https://material.angular.io/), is
    Google's own implementation and is built for Angular specifically. We will focus
    on this one throughout the rest of this chapter.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular Material，[https://material.angular.io/](https://material.angular.io/)，是谷歌专为Angular构建的实现。我们将在本章的其余部分重点介绍这个实现。
- en: If you are an Angular developer, then AngularJS Material or Materialize are
    both valid options, as the latter has AngularJS bindings, found at [https://krescruz.github.io/angular-materialize/](https://krescruz.github.io/angular-materialize/).
    Materialize can be used by many other application frameworks and is the most generic
    choice of the three. Angular Material is made for Angular alone.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是Angular开发者，那么AngularJS Material或Materialize都是有效的选择，因为后者具有AngularJS绑定，可以在[https://krescruz.github.io/angular-materialize/](https://krescruz.github.io/angular-materialize/)找到。Materialize可以被许多其他应用程序框架使用，是这三种选择中最通用的。Angular
    Material专为Angular而设计。
- en: Now the time has come to look at Angular Material in detail.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候详细了解Angular Material了。
- en: Angular Material
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular Material
- en: The library was developed to implement Material Design for the new Angular.
    It's still a work in progress, but it continues to evolve. There are, however,
    enough components in place for it to be adopted already. You should know that
    it is still in Beta, so a certain amount of caution is good if you consider adopting
    it. The official documentation can be found at [https://material.angular.io](https://material.angular.io) and
    the repository can be found at [https://github.com/angular/material2](https://github.com/angular/material2).
    It is a quite popular library with 10,000+ stars.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该库是为新的Angular实现Material Design而开发的。它仍在不断发展中，但已经有足够的组件可以使用。您应该知道它仍处于Beta阶段，因此如果考虑采用它，需要一定的谨慎。官方文档可在[https://material.angular.io](https://material.angular.io)找到，存储库可在[https://github.com/angular/material2](https://github.com/angular/material2)找到。这是一个相当受欢迎的库，拥有10,000多个星标。
- en: 'Angular Material promotes itself with the following bullet points:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material通过以下要点来宣传自己：
- en: '**Sprint from zero to app**: The intention is to make it very easy for you
    as an app developer to hit the ground running. The goal is for there to be a minimum
    amount of effort in setting it up.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从零到应用的冲刺**：目的是让您作为应用开发者能够轻松上手。目标是尽量减少设置的工作量。'
- en: '**Fast and consistent**: This is to say that performance has been a major focus
    point and also that it is guaranteed to work well on all major browsers.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速一致**：这意味着性能是一个主要关注点，同时也保证在所有主要浏览器上运行良好。'
- en: '**Versatile**: This puts focus on two major points, there should be a multitude
    of themes that should be easy to customize and there is also great support for
    localization and internationalization.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多功能**：这强调了两个主要点，应该有大量易于定制的主题，还有很好的本地化和国际化支持。'
- en: '**Optimized for Angular**: The very fact that it is built by the Angular team
    itself means the support for Angular is a big priority.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为Angular优化**：它是由Angular团队自己构建的，这意味着对Angular的支持是一个重要的优先事项。'
- en: 'The framework consists of the following parts:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架包括以下部分：
- en: '**Components**: This means that there are a ton of constructs in place to help
    you be successful, such as different kinds of input, buttons, layout, navigation,
    modals, and different ways to show tabular data.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**：这意味着有大量的构件可帮助您取得成功，如不同类型的输入、按钮、布局、导航、模态框和展示表格数据的不同方式。'
- en: '**Themes**: The library comes with themes preinstalled, but it''s also easy
    to refer to external themes. There is also a theming guide, if you have your heart
    set on creating a custom theme, at [https://material.angular.io/guide/theming.](https://material.angular.io/guide/theming)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：该库预装了主题，但也很容易引用外部主题。还有一个主题指南，如果您想创建自定义主题，可以在[https://material.angular.io/guide/theming.](https://material.angular.io/guide/theming)找到。'
- en: '**Icons**: Material Design comes with over 900 icons so you are likely to find
    just the icon you need. For a full display of what those are, go to [https://material.io/icons/.](https://material.io/icons/)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图标**：Material Design带有超过900个图标，因此您很可能会找到所需的图标。要查看所有图标，请访问[https://material.io/icons/.](https://material.io/icons/)'
- en: '**Gestures**: Not everything in a UI is a button click. As Material Design
    supports mobile, it thereby supports mobile gestures through the use of the library
    HammerJs.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手势**：UI中并非所有操作都是按钮点击。由于Material Design支持移动端，因此通过HammerJs库支持移动手势。'
- en: Installation
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'I know you are probably itching to try it out, so let''s delay no further.
    First off, we need to install it. Let''s start out by ensuring we have an Angular
    project ready to install it on, by telling the Angular CLI to scaffold a project
    for us, like so:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你可能迫不及待地想要尝试一下，所以让我们不要再拖延了。首先，我们需要安装它。让我们首先确保我们有一个准备好安装它的Angular项目，通过告诉Angular
    CLI为我们搭建一个项目。
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now it is time to install the necessary dependencies for Angular Material:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候安装Angular Material所需的依赖项了：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now let us also install support for animations. It isn't strictly necessary
    for it to work but we want some cool animations, right?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们也安装支持动画。这对它的工作并不是绝对必要的，但我们想要一些很酷的动画，对吧？
- en: 'The following is needed to install it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 需要安装以下内容：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Thereby, we are done installing Angular Material and are ready to use it in
    our app. As we have learned from previous chapters, to use external Angular modules,
    we need to import them. Once that is done, we can start using the constructs that
    these modules publicly export. In reality, there are many modules to import, depending
    on what we need, for example, every control has its own module but animation has
    only one.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经安装了Angular Material，并准备在我们的应用程序中使用它。正如我们从之前的章节中学到的，要使用外部的Angular模块，我们需要导入它们。一旦完成了这一步，我们就可以开始使用这些模块公开导出的构造。实际上，有许多要导入的模块，取决于我们的需求，例如，每个控件都有自己的模块，但动画只有一个。
- en: Our first Angular Material app
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个Angular Material应用程序
- en: By now you have already scaffolded an Angular application, using the Angular
    CLI. You have installed the necessary node modules and are eagerly waiting to
    use the constructs in Angular Material. We expect two things from our Angular
    Material application, some nice rendering as well as some nice animations to go
    with it. To start using a UI control such as a button or a checkbox, we need to
    import its corresponding module. To get the UI rendering and the animation behavior,
    we need to add the necessary modules and select a theme to use.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经使用Angular CLI搭建了一个Angular应用程序。您已经安装了必要的节点模块，并迫不及待地想要在Angular Material中使用这些构造。我们期望我们的Angular
    Material应用程序有两个方面，一些漂亮的渲染以及一些漂亮的动画。要开始使用UI控件，比如按钮或复选框，我们需要导入它们对应的模块。为了获得UI渲染和动画行为，我们需要添加必要的模块并选择要使用的主题。
- en: 'Let''s start out with the module we need, which is the `BrowserAnimationsModule`.
    To start using it, we import it and register it with our root module, like so:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们需要的模块开始，即`BrowserAnimationsModule`。要开始使用它，我们导入它并在我们的根模块中注册它，就像这样：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this point, we haven''t really added UI elements to use, so let''s do that
    as the next order of business. Our first example will be about buttons. To use
    an Angular Material button we need to add the `MatButtonModule` to our root module:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们实际上还没有添加要使用的UI元素，所以让我们把这作为下一个业务顺序。我们的第一个示例将是关于按钮。要使用Angular Material按钮，我们需要将`MatButtonModule`添加到我们的根模块中：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We need one more thing, namely a theme. If we don't add a theme we will get
    a boring button that just looks grey. If we, however, have a theme, we will get
    all the nice animations that have come to be associated with Material Design.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一件事，即主题。如果我们不添加主题，我们将得到一个看起来很无聊的灰色按钮。然而，如果我们有一个主题，我们将得到与Material Design相关的所有漂亮的动画。
- en: 'To add a theme, we need to add an entry to our `styles.css` file. This file
    is used to set CSS styles for the whole application. So let''s add the necessary
    row to `styles.css`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加主题，我们需要在`styles.css`文件中添加一个条目。这个文件用于为整个应用程序设置CSS样式。所以让我们在`styles.css`中添加必要的行：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The tilde operator `~` informs webpack,  the underlying engine that fuels Angular
    CLI, that such a path should be treated as an aliased path handled by webpack,
    and not just a regular field path or URL
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 波浪号运算符`~`通知webpack，即为Angular CLI提供动力的底层引擎，应将此路径视为webpack处理的别名路径，而不仅仅是常规字段路径或URL
- en: Now we are ready to use our first Angular Material UI element. Our choice for
    this is a Material Design button. To use it, we need to add the `mat-button` attribute
    to an element that we want Material Design rendering and behavior on.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备使用我们的第一个Angular Material UI元素。我们选择的是Material Design按钮。要使用它，我们需要在要在其上实现Material
    Design渲染和行为的元素上添加`mat-button`属性。
- en: 'We start in our root module, `app.module.ts`, adding the following entries:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从根模块`app.module.ts`开始，添加以下条目：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the template, an ordinary button becomes a Material Design button by us adding
    the   `mat-button` attribute. `mat-button`is a directive that gives our button
    a new look as well as associated animations. Clicking the button now should give
    off a nice animation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，通过添加`mat-button`属性，普通按钮变成了Material Design按钮。`mat-button`是一个指令，为我们的按钮提供了新的外观以及相关的动画。现在点击按钮应该会产生一个漂亮的动画。
- en: This demonstrates how simple it is to get started with Angular Material, but
    there is more, much more. Let's talk about most of the components in the upcoming
    section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了使用Angular Material是多么简单，但还有更多，远远不止这些。让我们在接下来的部分讨论大多数组件。
- en: Component overview
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件概述
- en: 'Angular Material consists of a lot of components of differing types, those
    are:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material包括许多不同类型的组件，包括：
- en: '**Form controls**: By form controls, we mean any type of controls that we use
    to collect data from a form, such as autocomplete, checkbox, normal input, radio
    button, select list, and so on.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表单控件**：通过表单控件，我们指的是我们用来从表单收集数据的任何类型的控件，比如自动完成、复选框、普通输入、单选按钮、选择列表等。'
- en: '**Navigation**: By navigation, we mean things like a menu, a sidenav, or a
    toolbar.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航**：通过导航，我们指的是菜单、侧边栏或工具栏等。'
- en: '**Layout**: By layout, we mean how we can place the data on the page, such
    as using a list, a card, or tabs.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局**：布局指的是我们如何在页面上放置数据，比如使用列表、卡片或选项卡。'
- en: '**Buttons**: Those are what they sound like, buttons you can push. But there
    are a number of different ones you can use, such as icon buttons, raised buttons,
    and more.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按钮**：这些就是它们听起来的样子，你可以按的按钮。但是你可以使用许多不同的按钮，比如图标按钮、凸起按钮等。'
- en: '**Popups and modals**: These are specific windows that block any user interaction
    until you have interacted with the popup or modal.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹出窗口和模态框**：这些是特定的窗口，阻止任何用户交互，直到您与弹出窗口或模态框进行交互为止。'
- en: '**Data table**: This is simply to show data in a tabular way. What kind of
    table you need depends on whether your data is massive and needs pagination, or
    if it needs to be sorted, or both.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据表**：这只是以表格方式显示数据。您需要什么样的表格取决于您的数据是庞大的并且需要分页，还是需要排序，或者两者兼而有之。'
- en: Buttons
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮
- en: 'So far, our app has only consisted of a simple button, which we declared in
    the following way:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序只包括一个简单的按钮，我们是这样声明的：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are, however, a lot more button types, namely:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有很多其他类型的按钮，包括：
- en: '`mat-button`, this is a normal looking button'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mat-button`，这是一个普通的按钮'
- en: '`mat-raised-button`, this is a raised button that is displayed with a shadow,
    to indicate its raised state'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mat-raised-button`，这是一个带有阴影显示的凸起按钮，以表示其凸起状态'
- en: '`mat-icon-button`, this button is meant to be used with an icon'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mat-icon-button`，这个按钮是用来与图标一起使用的'
- en: '`mat-fab`, this is a rounded button'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mat-fab`，这是一个圆形按钮'
- en: '`mat-button-toggle`, this is a button that indicates if it has been pressed
    or not, having pressed/not pressed as states'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mat-button-toggle`，这是一个指示是否已按下的按钮，具有按下/未按下状态'
- en: 'The markup for the buttons is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的标记如下：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It''s worth noting that we need to import the `MatButtonToggleModule` to be
    able to use the `mat-button-toggle` button. The buttons look like the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们需要导入`MatButtonToggleModule`才能使用`mat-button-toggle`按钮。按钮看起来像下面这样：
- en: '![](assets/2f091e8e-da1a-42c6-ac3c-29dcd738aadf.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2f091e8e-da1a-42c6-ac3c-29dcd738aadf.png)'
- en: 'To use these buttons, we need to make sure we import and register the modules
    they belong to. Let''s update our root module to look like the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些按钮，我们需要确保导入和注册它们所属的模块。让我们更新我们的根模块，使其看起来像下面这样：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see that we need to register `MatIconModule` to support the use of the `mat-icon`
    directive,  and we also need to register the`MatButtonToggleModule` to use the `<mat-button-toggle>`
    UI element, a toggle button.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们需要注册`MatIconModule`来支持使用`mat-icon`指令，并且我们还需要注册`MatButtonToggleModule`来使用`<mat-button-toggle>`
    UI元素，一个切换按钮。
- en: Form controls
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单控件
- en: Form controls are about collecting input data in different ways so that you
    might persist the data by calling an endpoint over HTTP.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 表单控件是关于以不同的方式收集输入数据，以便您可以通过调用HTTP端点来持久化数据。
- en: 'There are quite a few controls in Material Design of varying types, namely:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Material Design中有许多不同类型的控件，包括：
- en: '**Autocomplete**: This control enables the user to start typing in an input
    field and be presented with a list of suggestions while typing. This helps to
    narrow down the possible values that the input can take.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动完成**：此控件使用户可以在输入字段中开始输入并在输入时显示建议列表。这有助于缩小输入可以接受的可能值。'
- en: '**Checkbox**: This is a classic checkbox representing a state that is either
    checked or unchecked.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复选框**：这是一个经典的复选框，表示一个处于选中或未选中状态的状态。'
- en: '**Date picker**: This is a control that enables the user to select a date in
    the calendar.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日期选择器**：这是一个控件，使用户可以在日历中选择日期。'
- en: '**Input**: This is a classic input control. Material Design enhances the control
    with meaningful animation so you can clearly see when you are typing or not.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入**：这是一个经典的输入控件。Material Design通过有意义的动画增强了控件，因此您可以清楚地看到您何时正在输入或不在输入。'
- en: '**Radio button**: This is a classic radio button, and just like with the input
    control, Material Design''s take on this one is to add animations and transitions
    while editing to create a better user experience.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单选按钮**：这是一个经典的单选按钮，就像输入控件一样，Material Design对此的处理是在编辑时添加动画和过渡，以创造更好的用户体验。'
- en: '**Select**: This is a classic select list where the user is prompted to select
    one or more items from the list.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择**：这是一个经典的选择列表，提示用户从列表中选择一个或多个项目。'
- en: '**Slider**: The slider enables you to increase or decrease the value by pulling
    a slider button to either the right or the left.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滑块**：滑块使您可以通过拖动滑块按钮向右或向左增加或减少值。'
- en: '**Slide toggle**: This is just a checkbox, but a nicer rendition of it where
    a slider is being slid to the left or to the right.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滑动切换**：这只是一个复选框，但是一个更好的版本，其中滑块被滑向左边或右边。'
- en: Input
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入
- en: The input field is a classic input field, in that you can set different validation
    rules on it. You can however quite easily add the ability to show errors on the
    input field in a nice and reactive way.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输入字段是一个经典的输入字段，您可以在其中设置不同的验证规则。但是，您可以很容易地添加在输入字段上以一种漂亮和反应灵敏的方式显示错误的能力。
- en: 'To accomplish this, we will need to:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要：
- en: Associate a `formControl` with our input field
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`formControl`与我们的输入字段关联
- en: Define our input as a `MatInput` and add a validation rule
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的输入定义为`MatInput`并添加验证规则
- en: Define a `mat-error` element and a rule for when it should be shown
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个`mat-error`元素和一个何时应该显示的规则
- en: 'For the first bullet, we do the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个项目，我们执行以下操作：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This sets up an input control for us and a reference to a `formControl` so
    we can listen to changes on the input. This needs to be accompanied with us adding
    a reference in the code to the `app.component.ts` file, like so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们设置了一个输入控件和一个`formControl`的引用，这样我们就可以监听输入的变化。这需要与我们在`app.component.ts`文件中添加一个引用的代码一起使用，就像这样：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then need to add the `matInput` directive to the input and add a validation
    rule, so it looks like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要向输入添加`matInput`指令，并添加一个验证规则，使其看起来像这样：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lastly, we add the `mat-error` element and wrap the `mat-input-container`in
    a form element. We need to remember at this point to include the `FormsModule`in
    our root module as well. We also need to set up a rule for when the `mat-error` element
    should be shown, using `*ngIf`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加`mat-error`元素，并将`mat-input-container`包装在一个表单元素中。在这一点上，我们需要记住在根模块中包含`FormsModule`。我们还需要设置一个规则，用`*ngIf`来确定`mat-error`元素何时显示：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The previous markup sets up the input element and the validation rules of when
    to show, but as mentioned, we need to include the `FormsModule` in our root module
    as a last step, so let''s show what that looks like:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的标记设置了输入元素和何时显示验证规则，但正如前面提到的，我们需要在根模块中包含`FormsModule`作为最后一步，让我们看看它是什么样子的：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This all comes together to look like the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都汇总成以下内容：
- en: '![](assets/e58d9d42-31a6-4bd9-8b72-868ed1a4f978.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e58d9d42-31a6-4bd9-8b72-868ed1a4f978.png)'
- en: 'When the validation error has been triggered, it then looks like so:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当验证错误被触发时，它看起来是这样的：
- en: '![](assets/680ba77e-ecfa-447b-b21c-b5612739973b.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/680ba77e-ecfa-447b-b21c-b5612739973b.png)'
- en: We have gone through a subset of all the form controls that Angular Material
    consists of, namely the autocomplete, the checkbox, the date picker, and lastly
    a normal input showcasing a validation error. There are other form controls such
    as radio button, select, slider, and slide toggle that we encourage you to explore
    at your own pace.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了Angular Material包含的所有表单控件的一个子集，即自动完成、复选框、日期选择器，最后是展示验证错误的普通输入。还有其他表单控件，如单选按钮、选择器、滑块和滑动切换，我们鼓励您按照自己的节奏进行探索。
- en: Autocomplete
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动完成
- en: The idea with autocomplete is to help the user narrow down what possible values
    an input field can have. In a normal input field, you would just type something
    and hope a validation would tell you if what you input is incorrect. With autocomplete,
    you are presented with a list as you type. The list is narrowed down as you type,
    and at any point you can decide to stop typing and instead select an item from
    the list. This is a time saver as you don't have to type the entire item's name,
    and it also enhances correctness as the user is being made to select from a list,
    rather than to type in the whole thing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 自动完成的想法是帮助用户缩小输入字段可能具有的可能值。在普通的输入字段中，您只需输入一些内容，希望验证会告诉您输入的内容是否不正确。使用自动完成，您在输入时会看到一个列表。随着您的输入，列表会被缩小，您可以随时决定停止输入，而是从列表中选择一个项目。这是一个时间节省者，因为您不必输入整个项目的名称，它还增强了正确性，因为用户被要求从列表中选择，而不是输入整个内容。
- en: With this being the complete behavior of autocorrect, it means that we need
    to provide it with a list of possible answers and also an input box in which to
    receive the input.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是自动更正的完整行为，这意味着我们需要提供一个可能答案的列表，还需要一个输入框来接收输入。
- en: 'We need to set up this control in five steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要按照五个步骤设置这个控件：
- en: Import and register all the necessary modules with our root module.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入并在根模块中注册所有必要的模块。
- en: Define a `mat-form-field`, containing an input control.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含输入控件的`mat-form-field`。
- en: Define a `mat-autocomplete` control, this is the list of possible options.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`mat-autocomplete`控件，这是可能选项的列表。
- en: Link the two controls through a view reference.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过视图引用链接这两个控件。
- en: Add a filter that filters down the autocomplete control when the user types.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个过滤器，当用户输入时，可以缩小自动完成控件的范围。
- en: 'Let''s start with the first step, all our necessary imports. Here we need the
    autocomplete functionality, but as we will be working with forms, and in particular
    reactive forms, we are going to need that module as well. We will also need some
    forms to support the input fields we mean to use:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一步开始，导入所有必要的内容。在这里，我们需要自动完成功能，但由于我们将使用表单，特别是响应式表单，我们还需要该模块。我们还需要一些表单来支持我们打算使用的输入字段：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we are ready to add some markup to the `app.component.html` file template:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备向`app.component.html`文件模板添加一些标记：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At this point, we have defined the input control and added the `matInput`directive.
    We have also added a `formControl`reference. We add that so we can later on listen
    to changes to our input as they happen. Changes to an input are interesting because
    we are able to react to them and filter our list, which is essentially what autocomplete
    does. The next order of business is to define a list of values that we need to
    suggest to the user once they start typing, so let''s do that next:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经定义了输入控件并添加了`matInput`指令。我们还添加了一个`formControl`引用。我们添加这个引用是为了以后能够监听输入的变化。输入的变化很有趣，因为我们能够对其做出反应并过滤我们的列表，这本质上就是自动完成所做的事情。下一个要做的事情是定义一组值，一旦用户开始输入，我们就需要向他们建议这些值，所以让我们接着做吧：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have our list, but we lack any connection between the input field and our
    suggestion list. Before we fix that, we first need to look at our component class
    and add some code to it to support the previous markup:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了列表，但缺少输入字段和建议列表之间的任何连接。在修复之前，我们首先需要查看我们的组件类，并向其添加一些代码以支持先前的标记：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So far we have defined `matInput` and `mat-autocomplete`separately, now it''s
    time to connect the two. We do that by adding a view reference to `mat-autocomplete` that `matInput` can
    refer to, like so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经分别定义了`matInput`和`mat-autocomplete`，现在是将两者连接起来的时候了。我们通过向`mat-autocomplete`添加一个视图引用，以便`matInput`可以引用它，就像这样：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And to refer to it in `matInput`, we introduce the `MatAutocomplete` directive,
    like so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 并且为了在`matInput`中引用它，我们引入`MatAutocomplete`指令，就像这样：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, `matAutocomplete` points to the `auto` view reference, thereby
    the list is triggered when we set focus to the input field and start typing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`matAutocomplete`指向`auto`视图引用，因此当我们将焦点设置到输入字段并开始输入时，列表就会被触发。
- en: 'We have added another useful thing in the preceding code, namely that of hints.
    Adding hints to your input is a great way to convey to the user what should be
    entered in the input field. Adding the attribute `hintLabel`, we are able to tell
    the user what should go into the input field. You can even take it a step further
    by introducing a tip on how they are doing while they are typing by using the `mat-hint`element.
    Let''s zoom in on the preceding code that accomplished what we just described:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了另一个有用的东西，即提示。向输入添加提示是向用户传达应在输入字段中输入什么的好方法。通过添加属性`hintLabel`，我们能够告诉用户应该输入什么。您甚至可以通过使用`mat-hint`元素在用户输入时介绍一些提示，让他们知道他们的输入情况如何。让我们仔细看一下刚才完成了我们所描述的工作的前面的代码：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Try to make use of the `hintLabel` and `mat-hint` element where applicable,
    it will help your users greatly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在适用的地方使用`hintLabel`和`mat-hint`元素，这将极大地帮助您的用户。
- en: 'If you typed everything in correctly, you should have something that looks
    like this in the UI:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正确输入了所有内容，您应该在UI中看到类似于这样的东西：
- en: '![](assets/bc852a3a-8141-4534-80cf-d450dd248db9.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bc852a3a-8141-4534-80cf-d450dd248db9.png)'
- en: Looks great! The list is displayed when you put the input in focus. However,
    you notice that the list is not really being filtered down as you type. This is
    because we haven't picked up on the event when you type into the input control.
    So let us do that next.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！当你将输入聚焦时，列表会显示出来。然而，你会注意到随着你的输入，列表并没有真正被过滤掉。这是因为我们没有捕捉到你在输入控件中输入时的事件。所以让我们接下来做这个。
- en: 'Listening to input changing means we listen to our form control and its `valueChanges`
    property, like so:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 监听输入变化意味着我们监听我们的表单控件及其`valueChanges`属性，如下所示：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you look closely, you can see that this is an Observable. This means that
    we can use operators to filter out content we don''t want. Our definition for
    wanted content is `jedis`, that starts with the text we entered in the input box.
    This means we can flesh it out to look something like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看，你会发现这是一个Observable。这意味着我们可以使用操作符来过滤掉我们不想要的内容。我们对所需内容的定义是以我们在输入框中输入的文本开头的`jedis`。这意味着我们可以将其完善为如下所示的样子：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we just need to change our template so the `mat-option` looks at `filteredJedis` instead
    of the `jedis` array, like so:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要改变我们的模板，让`mat-option`看向`filteredJedis`而不是`jedis`数组，如下所示：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Testing this out, we see that it seems to work.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一下，我们看到它似乎是有效的。
- en: Checkbox
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复选框
- en: 'This is the classic checkbox that holds checked, unchecked, and undetermined
    statuses. It is quite simple to use but you need to import some modules to use
    it, like so:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经典的复选框，包含选中、未选中和未确定的状态。使用起来非常简单，但你需要导入一些模块来使用它，如下所示：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The markup should look like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 标记应该是这样的：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So essentially, just add `<mat-checkbox>` as an element name and make sure to
    bind the `checked` attribute to a property on our component.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，只需将`<mat-checkbox>`添加为元素名称，并确保将`checked`属性绑定到我们组件上的属性。
- en: Date picker
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期选择器
- en: As usual with a date picker, you can do a lot more with it than just selecting
    a date from a pop-up calendar. You can disable date ranges, format the date, show
    it on a yearly and monthly basis, and so on. We will only explore how to get up
    and running with it, but we encourage you to explore the documentation for this
    control at [https://material.angular.io/components/datepicker/overview.](https://material.angular.io/components/datepicker/overview)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，使用日期选择器，你可以做的远不止从弹出日历中选择日期。你可以禁用日期范围，格式化日期，按年度和月度显示日期等等。我们只会探讨如何开始并运行它，但我们鼓励你在[https://material.angular.io/components/datepicker/overview](https://material.angular.io/components/datepicker/overview)探索此控件的文档。
- en: 'First off we, need to import the necessary modules:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入必要的模块：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For the markup, we need to do the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标记，我们需要做以下事情：
- en: Define an input with a `matInput`directive. The selected date will be placed
    here.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个带有`matInput`指令的输入。选定的日期将放在这里。
- en: Define a `<mat-datepicker>`element. This is the pop-up calendar.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个`<mat-datepicker>`元素。这是弹出式日历。
- en: Create a connection between the two controls.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建两个控件之间的连接。
- en: 'For the first bullet point, we declare it in the markup, like so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个要点，我们在标记中声明它，如下所示：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can see that we point out a `formControl` instance called input in our component
    by the use of the `formControl`directive. We also add the `matInput` directive
    to give our input field that nice material look and feel.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们通过使用`formControl`指令指出了在我们组件中称为input的`formControl`实例。我们还添加了`matInput`指令，以赋予我们的输入字段漂亮的材料外观和感觉。
- en: 'For the second task, we define the `<mat-datepicker>` element, like so:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个任务，我们定义`<mat-datepicker>`元素，如下所示：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we need to make the connection between them and, just like we did with
    the autocomplete control, we define a view reference, `picker`, in the `<mat-datepicker>` element,
    and refer to that in the input element by assigning the view reference to the `matDatepicker`
    directive, so it looks like the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要建立它们之间的连接，就像我们在自动完成控件中所做的那样，我们在`<mat-datepicker>`元素中定义一个视图引用`picker`，并通过将该引用分配给输入元素中的`matDatepicker`指令来引用它，所以它看起来像下面这样：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So, in summary, we added a view reference to the `mat-datepicker` element, and
    referred to said reference by assigning it to the `[matDatePicker]` directive
    in the input element.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总之，我们在`mat-datepicker`元素中添加了一个视图引用，并通过将其分配给输入元素中的`[matDatePicker]`指令来引用该引用。
- en: 'We also added a button that will toggle the visibility of the calendar. We
    made that possible by using the `<mat-datepicker-toggle>` element and assigning
    it the `picker` view reference:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个按钮，用于切换日历的可见性。我们通过使用`<mat-datepicker-toggle>`元素并将其分配给`picker`视图引用来实现这一点：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, your creation should now look like the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您的创建现在应该看起来像下面这样：
- en: '![](assets/9294b9d1-4fa6-4045-874f-743306a58984.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9294b9d1-4fa6-4045-874f-743306a58984.png)'
- en: Navigation
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航
- en: 'Navigation is how we get around in the application. There are different ways
    for us to do that, such as clicking a link or clicking on a menu item for example.
    Angular Material offers three components for this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 导航是我们在应用程序中移动的方式。我们有不同的方式来做到这一点，比如点击链接或者点击菜单项。Angular Material为此提供了三个组件：
- en: '**Menu**: This is a pop-out list where you get to choose from many different
    menu options'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**菜单**：这是一个弹出列表，您可以从中选择许多不同的菜单选项'
- en: '**Sidenav**: This component acts like a menu docked to the left or the right
    of the page and presents itself as an overlay over the application while dimming
    the application content'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**侧边栏**：这个组件就像一个停靠在页面左侧或右侧的菜单，并以应用程序内容的遮罩形式呈现在应用程序上'
- en: '**Toolbar**: This is typical toolbar that is a way for the user to reach commonly
    used actions'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具栏**：这是用户可以使用的常用操作的典型工具栏'
- en: In this section, we will show a full example of using the menu, but we encourage
    you to keep exploring by learning to use the sidenav ([https://material.angular.io/components/sidenav/overview](https://material.angular.io/components/sidenav/overview)),
    as well as the toolbar component ([https://material.angular.io/components/toolbar/overview](https://material.angular.io/components/toolbar/overview)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将展示使用菜单的完整示例，但我们鼓励您继续探索，学习如何使用侧边栏（[https://material.angular.io/components/sidenav/overview](https://material.angular.io/components/sidenav/overview)）以及工具栏组件（[https://material.angular.io/components/toolbar/overview](https://material.angular.io/components/toolbar/overview)）。
- en: Menu
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单
- en: The menu component is what it sounds like, it's made for you to easily present
    a menu to the user. It uses three major directives, `mat-menu`, `mat-menu-item`,
    and lastly, `MatMenuTriggerFor`. There is only one `mat-menu` per menu and as
    many `mat-menu-items` as you need. The `MatMenuTriggerFor` is used to trigger
    the menu, you usually attach this one to a button.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单组件就是它听起来的样子，它是为了让您轻松地向用户呈现菜单。它使用三个主要指令，`mat-menu`，`mat-menu-item`，最后，`MatMenuTriggerFor`。每个菜单只有一个`mat-menu`，以及尽可能多的`mat-menu-items`。`MatMenuTriggerFor`用于触发菜单，通常将其附加到按钮上。
- en: 'Making the menu work can be divided into three steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使菜单工作可以分为三个步骤：
- en: Define a `mat-menu` control.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`mat-menu`控件。
- en: Add as many `mat-menu-items` as you need.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加尽可能多的`mat-menu-items`。
- en: Add a trigger to a button by adding the `MatMenuTriggerFor` directive.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加`MatMenuTriggerFor`指令将触发器添加到按钮。
- en: 'Before we do any of that, we need to import the `MatMenuModule` to be able
    to use the constructs previously mentioned, so let''s do that:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们执行任何操作之前，我们需要导入`MatMenuModule`以便能够使用先前提到的构造，所以让我们这样做：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we are ready to define our menu, like so:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备定义我们的菜单，如下所示：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Thereafter, we add as many items as we need:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们添加所需的项目：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Lastly, we add a trigger by adding a button that will trigger it and the `matMenuTriggerFor` directive,
    like so:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过添加一个按钮来触发`matMenuTriggerFor`指令来添加触发器，就像这样：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note how `matMenuTriggerFor` points to the `menu` view reference.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`matMenuTriggerFor`指向`menu`视图引用。
- en: 'Your finished result should look something like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您的最终结果应该看起来像这样：
- en: '![](assets/47b0c48c-2f08-4be1-bdac-8f2f5c2be915.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/47b0c48c-2f08-4be1-bdac-8f2f5c2be915.png)'
- en: 'Not all menus are this simple of course. Sooner or later you will encounter
    a scenario where you need a menu to be nested. Material UI easily supports this.
    The overall approach to supporting this lies in defining a `mat-menu` definition
    for each menu you need and then connecting them. Then you need to define what
    action leads to what submenu being triggered. Sounds hard? It''s really not. Let''s
    begin with our top-level menu, our root menu. Let''s give the menu items some
    meaningful names, like so:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非所有菜单都是这么简单。迟早您会遇到需要嵌套菜单的情况。Material UI很容易支持这一点。支持这一点的整体方法在于为您需要的每个菜单定义`mat-menu`，然后连接它们。然后您需要定义什么操作导致触发哪个子菜单。听起来困难吗？其实并不是。让我们从我们的顶级菜单，我们的根菜单开始。让我们给菜单项一些有意义的名称，就像这样：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'At this point, we have two menu items and the last one, `wxport`, begs for
    some suboptions. Imagine we are dealing with tabular data in a program, it would
    make sense to support exporting that data to either CSV or PDF. Let''s add a submenu
    for just that, like so:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们有两个菜单项，最后一个“wxport”需要一些子选项。想象一下我们在程序中处理表格数据，支持将数据导出为CSV或PDF是有意义的。让我们添加一个子菜单，就像这样：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'OK, so now we have two different menus, but we need to add the connection where
    a `rootMenu` item triggers the `subMenu` to show. Let''s add that by again using
    the `matMenutriggerFor` directive, like so:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们有两个不同的菜单，但我们需要添加连接，使“rootMenu”项触发“subMenu”显示。让我们再次使用`matMenutriggerFor`指令来添加，就像这样：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This should render a menu that looks like the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该呈现一个看起来像下面这样的菜单：
- en: '![](assets/1817adcb-9507-4b09-8b98-7956462229c8.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1817adcb-9507-4b09-8b98-7956462229c8.png)'
- en: There are more things you can do with a menu than just rendering a few menu
    items and have them triggered by a button. Other things to consider and try out
    are making it more professional looking by adding an icon or catering to accessibility.
    Now that you know the basics of how to create a simple menu as well as nested
    ones, go and explore.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单有更多的用途，不仅仅是渲染一些菜单项并通过按钮触发它们。其他需要考虑和尝试的事情包括通过添加图标使其看起来更专业，或者迎合无障碍。现在您已经了解了如何创建简单菜单以及嵌套菜单的基础知识，去探索吧。
- en: Layout
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: 'Layout is about defining how we place the content on our page. Angular Material
    gives us different components for this purpose, namely:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 布局是关于定义如何在页面上放置内容。Angular Material为此目的提供了不同的组件，即：
- en: '**List**: This is a way to present your content as a list of items. The list
    can be enriched with links, icons, and can even be multiline.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表：这是一种将内容呈现为项目列表的方式。列表可以用链接、图标来丰富，甚至可以是多行的。
- en: '**Grid list**: This is a control that helps you arrange your content in blocks.
    You need to define the number of columns, and the component will make sure to
    fill out the visual space.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格列表：这是一个帮助你将内容排列成块的控件。您需要定义列数，组件将确保填充视觉空间。
- en: '**Card**: This is a component that wraps content and adds a box shadow. You
    can define a header for it as well.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡片：这是一个包装内容并添加阴影的组件。您也可以为其定义一个标题。
- en: '**Tabs**: This lets you divide up your content between different tabs.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项卡：这让您可以在不同的选项卡之间划分内容。
- en: '**Stepper**: This is a component that divides up your component in wizard-like
    steps.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步进器**：这是一个将您的组件分成向导式步骤的组件。'
- en: '**Expansion panel**: This component works pretty much like an accordion, in
    that it enables you to lay out your components in a list-like way with a title
    for each item. Each item can be expanded, and only one item can be expanded at
    a time.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**展开面板**：这个组件的工作方式基本上类似于手风琴，它使您能够以列表的方式布置组件，并为每个项目添加标题。每个项目都可以展开，一次只能展开一个项目。'
- en: In this section, we will cover the list and grid list components. We urge you
    to explore the card component, [https://material.angular.io/components/card/overview](https://material.angular.io/components/card/overview),
    the tabs component, [https://material.angular.io/components/tabs/overview](https://material.angular.io/components/tabs/overview),
    the stepper, [https://material.angular.io/components/stepper/overview](https://material.angular.io/components/stepper/overview),
    and the expansion panel, [https://material.angular.io/components/expansion/overview](https://material.angular.io/components/expansion/overview),
    at your own volition.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍列表和网格列表组件。我们建议您自行探索卡片组件，[https://material.angular.io/components/card/overview](https://material.angular.io/components/card/overview)，选项卡组件，[https://material.angular.io/components/tabs/overview](https://material.angular.io/components/tabs/overview)，步进器，[https://material.angular.io/components/stepper/overview](https://material.angular.io/components/stepper/overview)，以及展开面板，[https://material.angular.io/components/expansion/overview](https://material.angular.io/components/expansion/overview)。
- en: List
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'The list control is built up by a `mat-list` element and a number of `mat-list-items`.
    The markup for this looks like:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表控件由一个`mat-list`元素和一些`mat-list-items`组成。其标记如下：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'That''s it, that is all there is to it. For your effort, you are awarded with
    a list that looks like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，就是这样。为了你的努力，你将获得一个看起来像这样的列表：
- en: '![](assets/f1291ad9-0f13-4887-a14a-3c56bf2779ec.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f1291ad9-0f13-4887-a14a-3c56bf2779ec.png)'
- en: 'A list can, of course, be a lot more complicated, containing links, icons,
    and more. A more interesting example may look like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，列表可以更加复杂，包含链接、图标等。一个更有趣的例子可能是这样的：
- en: '![](assets/30b2a9f4-790a-4738-b683-c29034da030b.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/30b2a9f4-790a-4738-b683-c29034da030b.png)'
- en: I think you get the idea, there are list items and I can put pretty much put
    anything I want in them. To read more about the capabilities, here is the link
    to the list documentation: [https://material.angular.io/components/list/overview.](https://material.angular.io/components/list/overview)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你已经明白了，这里有列表项，我可以在其中放入任何我想要的东西。要了解更多关于功能的信息，请点击以下链接查看列表文档：[https://material.angular.io/components/list/overview.](https://material.angular.io/components/list/overview)
- en: Grid list
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网格列表
- en: 'The grid list is used to display your content in a list of rows and columns,
    while ensuring that it fills out the viewport. This is a very nice component if
    you want maximum freedom of deciding how to display content. This is a separate
    module called `MatGridListModule`. We need to add this to our list of imported
    modules, like so:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 网格列表用于以行和列的列表形式显示内容，同时确保填充视口。如果您希望最大限度地自由决定如何显示内容，这是一个非常好的组件。这是一个名为`MatGridListModule`的单独模块。我们需要将其添加到我们导入的模块列表中，就像这样：
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The component consists of a `mat-grid-list` element and a number of `mat-grid-tile`
    elements.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件由一个`mat-grid-list`元素和一些`mat-grid-tile`元素组成。
- en: 'Let''s add the `mat-grid-list` element first:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先添加`mat-grid-list`元素：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Worth noting is how we set the number of columns and the height of each row.
    Now it''s time to add the content. We do that by adding a number of `mat-grid-tile`
    instances, like so:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是我们如何设置列数和每行的高度。现在是添加内容的时候了。我们通过添加一些`mat-grid-tile`实例来实现：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here we are defining an `*ngFor` to point to our list of tiles. We also bind
    to `[colspan]`, that decides how much column space it should take, `[rowspan]`,
    that determines how many rows it should take, and lastly, we bind to the background
    property in our style.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在定义一个`*ngFor`，指向我们的瓷砖列表。我们还绑定到`[colspan]`，决定它应该占用多少列空间，`[rowspan]`，确定它应该占用多少行，最后，我们绑定到我们样式中的背景属性。
- en: 'The component looks like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件如下所示：
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We encourage you to explore the card and tabs component to learn more about
    the remaining layout components.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您探索卡片和选项卡组件，以了解更多关于剩余布局组件的信息。
- en: Popups and modals
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹出窗口和模态
- en: There are different ways that we can capture the user's attention. One way is
    to show a dialog over the content of the page and prompt the user to act. Another
    way is to display information about a part of the page when the user hovers over
    that particular part.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方式可以吸引用户的注意。一种方法是在页面内容上显示对话框，并提示用户采取行动。另一种方法是在用户悬停在特定部分时显示该部分的信息。
- en: 'Angular Material offers three different components for this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material为此提供了三种不同的组件：
- en: '**Dialog**: This is simply a modal dialog displaying itself on top of the content.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对话框**：这只是一个简单的模态对话框，显示在内容的顶部。'
- en: '**Tooltip**: This displays a piece of text when you hover over a specified
    area.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tooltip**：当您悬停在指定区域时，它会显示一段文本。'
- en: '**Snackbar**: This shows an information message at the bottom of a page. The
    information message is only visible for a short amount of time. It is meant to
    convey to the user that something has happened as a result of an action, such
    as saving a form.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Snackbar**：这在页面底部显示信息消息。信息消息只在短时间内可见。它旨在向用户传达由于某种操作（例如保存表单）而发生的事情。'
- en: Dialog
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对话框
- en: 'The dialog component is quite powerful as it helps us create a modal. It can
    be customized to your heart''s content and is a bit tricky to set up. But don''t
    worry, we will guide you through the process. What we need to do is:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框组件非常强大，因为它帮助我们创建一个模态框。它可以根据您的喜好进行定制，并且设置起来有点棘手。但不用担心，我们会指导您完成整个过程。我们需要做的是：
- en: Import the dialog module.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入对话框模块。
- en: Create a component that is our dialog.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个作为我们对话框的组件。
- en: Create a component and a button that will trigger the module.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个组件和一个按钮，触发该模块。
- en: Add our dialog to the `entryComponents` property of our module.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的对话框添加到模块的`entryComponents`属性中。
- en: 'First off, we import the necessary module, like so:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入必要的模块，如下所示：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next up, we create a component that will hold our dialog. It is a normal component
    with a template and a backing class, but it does need to inject a `MatDialogRef`.
    It should look something like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个将容纳我们对话框的组件。它是一个普通的组件，有模板和后台类，但它确实需要注入一个`MatDialogRef`。它应该看起来像这样：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'What we have done here is define the following general structure in the template:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模板中定义了以下一般结构：
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: At a quick glance, we define a title, a content, and an action field, where
    buttons are defined. To send different values back we use `[mat-dialog-close]` and
    assign a value to it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，我们定义了一个标题、一个内容和一个操作字段，其中定义了按钮。为了发送不同的值回来，我们使用`[mat-dialog-close]`并为其分配一个值。
- en: As for the code part, we inject an instance of `MatDialogRef` that is typed
    to `MyDialog`, which is the very component we are in.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 至于代码部分，我们注入了一个类型为`MyDialog`的`MatDialogRef`实例，这正是我们所在的组件。
- en: 'The third thing we need to do is to set up a host component, in which there
    is a button that, when clicked, will launch a dialog. So let''s do that with the
    following code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第三件事是设置一个宿主组件，在其中有一个按钮，当点击时将启动一个对话框。所以让我们用以下代码来做到这一点：
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We do two things here, we call `dialog.open()` with a type, which is our dialog
    component. Furthermore, by listening to the Observable we get back when calling 
     `dialogRef.afterClosed()` , we are able to inspect the result coming back from
    the dialog. At this point there isn't much of a result to look at but in the next
    section we will look at a more advanced dialog example where we use this method.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们做了两件事，我们使用类型调用`dialog.open()`，这是我们的对话框组件。此外，通过监听调用`dialogRef.afterClosed()`时返回的Observable，我们能够检查来自对话框的结果。在这一点上，没有太多结果可以查看，但在下一节中，我们将看一个更高级的对话框示例，我们将使用这种方法。
- en: 'Lastly, we need to go to our `app.module.ts` file and add our`DialogComponent`
    dialog to the`entryComponents` array, like so:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要转到我们的`app.module.ts`文件，并将我们的`DialogComponent`对话框添加到`entryComponents`数组中，如下所示：
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: So, adding things to the `entryComponents`array in an Angular module is a completely
    new concept to us, what does it actually do? When we add a component to that list
    we tell the compiler that this component needs to be compiled and needs a `ComponentFactory`so
    we can create it on the fly. Thus, the criteria for putting any component in here
    is that we want to load a component dynamically or by type. This is exactly the
    case with our `DialogComponent`. It doesn't actually exist before we call   `this.dialog.open(DialogComponent)`.
    At that point, it runs a method under the hood called   `ViewContainerRef.createComponent()`.
    In short, we need to instantiate the `DialogComponent`every time we wish to open
    it. So, don't forget about `entryComponents`or it won't work. You can read more
    on `entryComponents` at[https://angular.io/guide/ngmodule-faq#what-is-an-entry-component.](https://angular.io/guide/ngmodule-faq#what-is-an-entry-component)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在Angular模块的`entryComponents`数组中添加内容对我们来说是一个全新的概念，它实际上是做什么的？当我们将组件添加到该列表中时，我们告诉编译器这个组件需要被编译，并且需要一个`ComponentFactory`，以便我们可以动态创建它。因此，将任何组件放在这里的标准是，我们希望动态加载组件或按类型加载组件。这正是我们的`DialogComponent`的情况。在调用`this.dialog.open(DialogComponent)`之前，它实际上并不存在。在那时，它会在幕后运行一个名为`ViewContainerRef.createComponent()`的方法。简而言之，我们需要在每次打开对话框时实例化`DialogComponent`。因此，不要忘记`entryComponents`，否则它将无法工作。您可以在[https://angular.io/guide/ngmodule-faq#what-is-an-entry-component](https://angular.io/guide/ngmodule-faq#what-is-an-entry-component)上阅读更多关于`entryComponents`的信息。
- en: 'Your dialog will end up looking something like this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您的对话框最终会看起来像这样：
- en: '![](assets/68bb581e-a501-4d9f-bb43-fa6c840157fc.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/68bb581e-a501-4d9f-bb43-fa6c840157fc.png)'
- en: A more advanced example – sending data to and from your dialog
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个更高级的例子-向对话框发送数据和从对话框发送数据
- en: Previously, we introduced a simple dialog example where we learned to open the
    dialog and close it. That barely scratched the surface. What is really interesting
    is how we would send data to the dialog so it comes prebooted with some data,
    and also how we would send data we gather inside of the dialog back to the host
    component that opened it. We will look at both these scenarios.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们介绍了一个简单的对话框示例，我们学会了如何打开对话框并关闭它。那只是皮毛。真正有趣的是我们如何向对话框发送数据，以便它预先加载一些数据，并且我们如何将在对话框内收集的数据发送回打开它的宿主组件。我们将研究这两种情况。
- en: The business case for sending data to the dialog, so it starts with some data,
    is so that we can, for example, show an existing record and make updates to it
    in the dialog.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 向对话框发送数据的业务案例是，这样它就可以从一些数据开始，例如，显示现有记录并在对话框中进行更新。
- en: 'By adding a second argument to the method `dialog.open()` we are able to send
    data to the dialog component that it can display:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向`dialog.open()`方法添加第二个参数，我们可以向对话框组件发送数据，以便它可以显示：
- en: '[PRE49]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'On the dialog component side of things, we need to tell it about the data we
    are sending in. We do that by injecting `MAT_DIALOG_DATA`, the needed changes
    are in bold:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话框组件方面，我们需要告诉它我们发送的数据。我们通过注入`MAT_DIALOG_DATA`来实现这一点，所需的更改如下所示：
- en: '[PRE50]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, because we have sent the data bound `jedi`instance from the `host` class,
    any changes we do to it in the `Dialog` class will be reflected in the `host`
    class. That takes care of sending data from the `host` class to the dialog, but
    what if we want to send data from dialog back? We can easily accomplish that by
    sending a parameter in the `dialogRef.close()` method call, like so:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们已经从`host`类发送了数据绑定的`jedi`实例，所以我们在`Dialog`类中对其进行的任何更改都将反映在`host`类中。这解决了从`host`类发送数据到对话框的问题，但是如果我们想要从对话框发送数据回来怎么办？我们可以通过在`dialogRef.close()`方法调用中发送一个参数来轻松实现，就像这样：
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To do something with that data, we simply subscribe to the Observable we get
    from calling   `afterClose()`. This is illustrated in bold as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要对数据进行操作，我们只需订阅从调用`afterClose()`得到的Observable。如下所示加粗说明：
- en: '[PRE52]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Data table
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据表
- en: 'There are different ways we can show the data. Showing it in rows and columns
    is an efficient way of getting a quick overview. You might, however, need to sort
    the data by column to quickly zoom in on the interesting data. Also, the amount
    of data might be so great that it needs to be shown in parts, by page. Angular
    Material addresses these issues by offering the following components:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以不同的方式显示数据。以行和列的形式显示数据是快速获得概览的有效方式。但是，您可能需要按列对数据进行排序，以便快速聚焦于感兴趣的数据。此外，数据量可能非常大，需要通过分页的方式显示。Angular
    Material通过提供以下组件来解决这些问题：
- en: '**Table**: This lays out the data in rows and columns, with headers'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表格**：这以行和列的形式布置数据，并带有标题'
- en: '**Sort table**: This allows you to sort your data'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序表格**：这允许您对数据进行排序'
- en: '**Paginator**: This allows you to slice up your data in pages while allowing
    you to navigate between pages'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分页器**：这允许您将数据分成页面，并在页面之间导航'
- en: It should be said that in most cases when trying to add a table to your app,
    it is expected that a table can be sorted and that the data can be paged so as
    not to completely overwhelm the user. Let's therefore have a look at how to achieve
    all of this step by step.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 应该说，在大多数情况下，当尝试向应用程序添加表格时，预期表格可以进行排序，并且数据可以进行分页，以免完全压倒用户。因此，让我们逐步看看如何实现所有这些。
- en: Table
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格
- en: 'The table component is able to let us present our data in columns and rows.
    We need to do the following to get a table component up and running:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 表格组件能够让我们以列和行的形式呈现数据。我们需要做以下工作才能让表格组件正常运行：
- en: Import and register the `MatTableModule` in our root module.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的根模块中导入和注册`MatTableModule`。
- en: Construct the data that we mean to display.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建我们打算显示的数据。
- en: Define the markup for our table.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们表格的标记。
- en: 'The first order of business is to import the necessary module, and that is
    easily done with the following code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是导入必要的模块，可以通过以下代码轻松完成：
- en: '[PRE53]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'At this point, we start constructing our data and create an instance of the
    `MatTableDataSource` class. The code is as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们开始构建我们的数据并创建`MatTableDataSource`类的一个实例。代码如下：
- en: '[PRE54]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Noteworthy here is how we construct a `MatTableDataSource`instance out of an
    array of objects. We will use this instance in the markup and point it out as
    the data source. The next thing to do is construct the markup needed to support
    this table. The code for that is as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们如何从对象数组构建了一个`MatTableDataSource`实例。我们将在标记中使用这个实例，并将其指定为数据源。接下来要做的是构建支持这个表格的标记。代码如下：
- en: '[PRE55]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We have pointed out several points of interest in the previous code. Columns
    for the table are constructed by creating an `ng-container` element containing
    in turn a `mat-header-cell`, where the title is defined, and a `mat-cell`where
    we say what data should go in there. The `mat-header-row` element, further down
    in the code, enables us to point out the order in which the columns should appear.
    We can see in our previous code snippet how this is just an array of strings.
    Finally, with the `mat-row` element, we simple display all the rows of our table.
    The end result should look like this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在先前的代码中指出了几个值得关注的地方。表格的列是通过创建一个包含`mat-header-cell`的`ng-container`元素来构建的，其中定义了标题，以及一个`mat-cell`，我们在其中说明了应该放入哪些数据。在代码中稍后的`mat-header-row`元素使我们能够指出列应该出现的顺序。我们可以在先前的代码片段中看到，这实际上只是一个字符串数组。最后，通过`mat-row`元素，我们简单地显示表格的所有行。最终结果应该是这样的：
- en: '![](assets/209f1380-8c94-44b2-9f78-02cefb7a73b1.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/209f1380-8c94-44b2-9f78-02cefb7a73b1.png)'
- en: Sorting
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: 'The previous figure constitutes a nice looking table, but it lacks a pretty
    standard functionality, namely that of sorting. We expect that by clicking the
    header it will sort into ascending and descending respectively, and that it is
    able to recognize common data types such as strings and integers, and sort those
    correctly. The good news is that this is very easy to achieve. We need to do the
    following to ensure that our table can be sorted:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的图表构成了一个漂亮的表格，但缺少一个非常标准的功能，即排序功能。我们期望通过点击标题，它将分别按升序和降序排序，并且能够识别常见的数据类型，如字符串和整数，并正确排序这些数据。好消息是，这非常容易实现。我们需要做以下工作来确保我们的表格可以排序：
- en: Import and register the `MatSortModule`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入并注册`MatSortModule`。
- en: Create a `ViewChild` of type `MatSort` and assign it to the `dataSources` sort
    property.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为`MatSort`的`ViewChild`并将其分配给`dataSources`的sort属性。
- en: Add the directive `matSortHeader` to the headers that should be able to be sorted.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`matSortHeader`指令添加到应该能够排序的标题上。
- en: 'We complete the first step by adding the following code to the root module:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向根模块添加以下代码来完成第一步：
- en: '[PRE56]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Thereafter, we go into our component and add the `MatSort ViewChild` and assign
    it to the sort property, as described previously:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们进入我们的组件，并添加`MatSort ViewChild`并将其分配给sort属性，如前所述：
- en: '[PRE57]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'At this point, we need to fix the markup and then sorting should work. The
    changes we need to make to the markup are to simply apply the `matSort` directive
    to the whole table and`mat-sort-header`to each header that should be possible
    to sort. The code for the markup is now as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要修复标记，然后排序应该可以工作。我们需要对标记进行的更改只是简单地将`matSort`指令应用到整个表格，以及对每个应该可以排序的标题应用`mat-sort-header`。现在标记的代码如下：
- en: '[PRE58]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The UI should now indicate with an arrow by the column **Name**, the direction
    in which the data is being sorted, as the following image indicates:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在UI应该通过列**Name**旁边的箭头指示数据排序的方向，如下图所示：
- en: '![](assets/3258351f-45cb-4f1d-9c0d-bdfd5915c036.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3258351f-45cb-4f1d-9c0d-bdfd5915c036.png)'
- en: Pagination
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分页
- en: 'Our table so far is starting to look quite good. It can even be sorted, besides
    from displaying data. We are aware though that in most cases the data for a table
    is usually quite long, which leads to the user either having to scroll or browse
    the data page by page. We can solve the latter option with the help of the pagination
    element. To use it, we need to do the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的表格看起来相当不错。除了显示数据外，它甚至可以进行排序。不过，我们意识到在大多数情况下，表格的数据通常相当长，这导致用户要么不得不滚动，要么逐页浏览数据。我们可以通过分页元素来解决后一种选项。要使用它，我们需要做以下工作：
- en: Import and register the `MatPaginatorModule`.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入并注册`MatPaginatorModule`。
- en: Assign a `paginator ViewChild` instance to the data source's paginator property.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`paginator ViewChild`实例分配给数据源的paginator属性。
- en: Add a `mat-paginator` element to the markup.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标记中添加一个`mat-paginator`元素。
- en: 'Starting with the first item on our list, we need to add the following code
    to our root module:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们列表中的第一项开始，我们需要将以下代码添加到我们的根模块中：
- en: '[PRE59]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Thereafter, we need to add assign the `paginator` property to our   `tableSource.paginator`,
    as described previously. The code for that looks like the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要将`paginator`属性分配给我们的`tableSource.paginator`，就像之前描述的那样。代码如下所示：
- en: '[PRE60]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Our remaining part is just to change the markup, which should have the following
    alterations (changes in bold):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩下的部分就是改变标记，应该有以下改变（加粗的变化）：
- en: '[PRE61]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, we clearly show that the only addition to our markup was the `mat-paginator`
    element at the bottom. Here, we specify our view reference, but also the page
    size as well as what pages we should be able to switch to, should we want to.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们清楚地表明，我们标记的唯一添加是底部的`mat-paginator`元素。在这里，我们指定了我们的视图引用，还有页面大小以及我们应该能够切换到的页面。
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We set about trying to explain what Material Design is, a design language with
    paper and ink in mind. Thereafter, we mentioned the most well-known implementations
    of Material Design.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们努力解释了什么是Material Design，这是一种以纸张和墨水为主题的设计语言。之后，我们提到了最著名的Material Design实现。
- en: Next up, we put most of our focus on Angular Material, the Material Design implementation
    meant for Angular, and how it consists of different components. We went hands-on
    in explaining how to install it, set it up, and even how to use different form
    controls and input buttons.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们把大部分注意力放在了Angular Material上，这是专为Angular设计的Material Design实现，以及它由不同的组件组成。我们亲自动手解释了如何安装它，设置它，甚至如何使用不同的表单控件和输入按钮。
- en: Time was also spent covering other aspects of the components, such as layout,
    navigation, modals, and tabular data. Hopefully, you will have read this chapter
    and found that you now have a grasp of Material Design in general and Angular
    Material in particular, and can determine whether it is a good match for your
    next Angular app.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还花了一些时间来介绍组件的其他方面，比如布局、导航、模态框和表格数据。希望你已经阅读了本章，并发现你现在对Material Design有了一般的了解，特别是对Angular
    Material，你可以确定它是否适合你的下一个Angular应用程序。
